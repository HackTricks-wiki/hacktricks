# DApps - 去中心化应用

{{#include ../../banners/hacktricks-training.md}}

## 什么是 DApp？

DApp 是一种去中心化应用，运行在点对点网络上，而不是托管在集中式服务器上。DApp 通常建立在 **区块链技术** 之上，这应该允许数据的透明性、安全性和不可篡改性。

## Web3 DApp 架构

根据 [**这篇文章**](https://www.certik.com/resources/blog/web2-meets-web3-hacking-decentralized-applications)，Web3 DApp 架构有三种不同类型：

### "无 API" DApps

这些 DApp 建立在区块链之上，不依赖于任何集中式 API 或后端。你可以认为区块链是应用的实际后端。它们是 **完全去中心化** 的，可以直接通过区块链访问。

为了与区块链交互，客户端通常会使用 **钱包**。钱包将签署交易并将其发送到区块链。客户端也可能使用 **节点** 从区块链读取数据。

### "启用 API" DApps

这些 DApp 建立在区块链之上，但也依赖于集中式 API，通常用于收集信息。它们是 **大部分去中心化** 的，因为即使依赖于集中式 API，DApp 的核心功能仍然在区块链上。客户端与区块链的通信通常通过 **钱包** 完成。

这种类型 DApp 的一个好例子是 **NFT 铸造应用**。服务器允许上传图像，但铸造是通过钱包由客户端完成的。

### "全规模" DApps

这些 DApp 建立在区块链之上，但也依赖于集中式 API 和后端服务器。它们 **可能是部分去中心化** 的，因为客户端可能能够使用钱包在区块链上执行操作。然而，通常情况下，**后端也能够在区块链上执行操作**。

这种类型 DApp 的一个好例子是跨链桥，其中需要一个链外组件来 **与不同区块链中的智能合约进行通信** 以执行资产转移。

## Web2 漏洞

Web2 漏洞仍然影响这些类型的应用，尽管它们的影响可能有所不同：

- **客户端漏洞** 的影响增加，因为在 Web3 DApp 中，客户端通常是 **通过钱包在区块链上执行操作** 的。这意味着像 XSS 这样的攻击能够在客户端执行 JS 代码或篡改页面内容，可能会产生更大的影响，因为它们可以 **与钱包交互** 并说服用户在区块链上执行不希望的操作。
- 请注意，通常即使在这些类型的应用中，客户端仍然可以在使用钱包签署操作之前进行审查。然而，如果攻击者能够篡改页面内容，它可以说服用户签署一笔将在区块链上执行不希望的操作的交易。
- **服务器端漏洞** 在依赖后端服务器的 DApp 中仍然存在。这些漏洞的影响将取决于 DApp 的架构。然而，它们仍然可能非常有问题，因为攻击者可能会在后端找到 **公司的密钥** 来访问智能合约的资金，或者可能执行账户接管，从而允许他们窃取用户的资金或 NFT。

当然，如果 DApp 不使用后端，或者所使用的后端仅提供公共链数据或静态页面，则 DApp 的攻击面会减少。

## Web3 攻击面

即使一般来说 DApp 的攻击面较小，因为区块链上始终会进行多项安全检查，但仍然存在一些攻击向量可以被攻击者利用。

Web3 DApp 漏洞可能可以分为以下几类：

- **处理不当的链上交易**：格式不正确或不受限制的交易 API、缺乏响应等待和区块确认逻辑、敏感数据的暴露，以及对失败、回滚或内部类型交易的不当处理，允许恶意 calldata 注入。

- **智能合约驱动的后端攻击**：在没有验证的情况下在合约和数据库之间存储或同步敏感数据、未检查的事件发射或合约地址，以及可利用的合约漏洞可能会污染后端逻辑。

- **有缺陷的加密资产操作**：错误处理不同类型的代币（原生与 ERC-20）、忽略小数精度、转账失败或内部交易，以及在没有验证的情况下接受假冒、通货紧缩、重置或易滑点的代币，从而通过代币元数据启用有效载荷注入。

一些来自 [**这篇文章**](https://www.certik.com/resources/blog/web2-meets-web3-hacking-decentralized-applications) 的例子：

### 浪费资金：强迫后端执行交易

在场景 **`Wasted Crypto in Gas via Unrestricted API`** 中，攻击者可以强迫后端调用智能合约的函数，这将消耗 gas。攻击者只需发送一个 ETH 账户号码且没有限制，将强迫后端调用智能合约进行注册，这将消耗 gas。

### DoS：糟糕的交易处理时间

在场景 **`Poor Transaction Time Handling Leads to DoS`** 中，解释了由于后端将 HTTP 请求保持打开状态直到交易执行，用户可以轻松发送多个 HTTP 请求到后端，这将消耗后端的所有资源并导致 DoS。

### 后端<-->区块链不同步 - 竞争条件

在场景 **`Poor Transaction Time Handling Leads to Race Condition`** 中，解释了在一个游戏中，用户可以向后端发送提款请求，后端将向用户发送他的硬币，但在交易仍在处理时，用户能够使用这些硬币购买游戏中的物品，免费获得它们。

另一个例子可能是能够使用相同的硬币购买不同的物品，因为后端立即将物品交给用户，而不等待交易确认，因此不等待用户在区块链上的余额减少。

### 智能合约地址验证

在场景 **`Bridge Backend Lacks Smart Contract Address Validation`** 中，解释了后端如何检查智能合约的地址，因此攻击者可以部署一个假智能合约，将资金放在上面，发送交易到后端，后端会认为用户将资金发送到真实的智能合约，并将代币给予用户。

### 资产类别处理不当

在场景 **`Mishandling of Asset Classes`** 中，解释了后端将一个地址中的诈骗 NFT 与 1 MATIC 混淆，因此允许攻击者向该地址发送数百个诈骗 NFT，并为每个 NFT 从平台获得 1 MATIC。

## 参考文献
- [https://www.certik.com/resources/blog/web2-meets-web3-hacking-decentralized-applications](https://www.certik.com/resources/blog/web2-meets-web3-hacking-decentralized-applications)

{{#include ../../banners/hacktricks-training.md}}
