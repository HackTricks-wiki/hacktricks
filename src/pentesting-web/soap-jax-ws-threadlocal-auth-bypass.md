# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## 요약

- 일부 미들웨어 체인은 인증된 `Subject`/`Principal`을 static `ThreadLocal`에 저장하고, 독점적인 SOAP 헤더가 도착할 때만 이를 갱신합니다.
- WebLogic/JBoss/GlassFish는 워커 스레드를 재사용하기 때문에, 해당 헤더를 생략하면 그 스레드가 처리했던 마지막 특권 `Subject`가 아무런 경고 없이 재사용됩니다.
- 취약한 엔드포인트를 헤더 없이 잘 형식화된 SOAP 바디로 반복 공격하여 재사용된 스레드가 탈취된 관리자 컨텍스트를 부여할 때까지 시도하세요.

## 근본 원인

다음과 유사한 핸들러는 커스텀 헤더가 존재할 때만 스레드 로컬 식별자를 덮어쓰므로 이전 요청의 컨텍스트가 남아 있게 됩니다:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. reverse proxy / routing rules을 열거하여 숨겨진 SOAP 트리를 찾아라. 이 트리는 `?wsdl`를 차단하지만 POSTs를 허용할 수 있다(이를 [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)의 흐름과 함께 매핑하라).
2. EAR/WAR/EJB 아티팩트를 풀고(`unzip *.ear`) `application.xml`, `web.xml`, `@WebService` annotations, 그리고 handler chains(예: `LoginHandlerChain.xml`)을 검사하여 handler class, SOAP header QName, 및 backing EJB 이름을 밝혀라.
3. 메타데이터가 없으면 `ServiceName?wsdl` 경로를 brute-force 하거나 임시로 lab proxies를 완화한 후, 복구한 WSDL을 [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)에 임포트해 baseline envelopes를 생성하라.
4. handler 소스에서 `ThreadLocal`로 유지되는 객체들(예: `SubjectHolder.setSubject()`)이 인증 헤더가 없거나 잘못되었을 때 전혀 clear되지 않는지 검토하라.

## Exploitation

1. 정상 응답 코드와 invalid token에 대해 어떤 오류가 반환되는지 파악하려면 proprietary header를 포함한 유효한 요청을 전송하라.
2. 동일한 SOAP body를 헤더 없이 다시 전송하라. XML을 well-formed하게 유지하고 required namespaces를 준수하여 handler가 정상적으로 종료되도록 하라.
3. 요청을 반복 전송하라; 이전에 privileged action을 실행했던 스레드에 도달하면 재사용된 `Subject`가 user 또는 credential managers와 같은 보호된 작업을 해제한다.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## 버그 검증

- JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) 또는 유사한 디버깅 훅을 연결하여 각 호출 전후의 `ThreadLocal` 내용을 관찰하고, 인증되지 않은 요청이 이전 관리자 `Subject`를 상속받았는지 확인하세요.

## 참고자료

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
