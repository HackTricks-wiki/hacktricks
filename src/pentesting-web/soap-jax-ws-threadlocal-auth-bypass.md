# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## 요약

- 일부 미들웨어 체인은 인증된 `Subject`/`Principal`를 정적 `ThreadLocal` 내부에 저장하고, 독점적인 SOAP 헤더가 도착할 때만 이를 갱신합니다.
- WebLogic/JBoss/GlassFish가 워커 스레드를 재사용하기 때문에, 해당 헤더가 없으면 스레드가 마지막으로 처리한 권한 있는 `Subject`를 조용히 재사용하게 됩니다.
- 취약한 엔드포인트에 대해 헤더는 없지만 형식이 올바른 SOAP 바디로 지속적으로 요청을 보내면, 재사용된 스레드가 탈취한 관리자 컨텍스트를 부여할 때까지 기다릴 수 있습니다.
- 2025 HID ActivID/IASP (HID-PSA-2025-002)는 실제 사례입니다: JAX-WS handler가 `SubjectHolder` `ThreadLocal`을 캐시하여 인증되지 않은 SOAP 호출이 이전 콘솔/SSP 요청으로 설정된 신원을 상속받도록 합니다.

## 근본 원인

Handlers similar to the following only overwrite the thread-local identity when the custom header is present, so the previous request's context survives:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Enumerate the reverse proxy / routing rules to locate hidden SOAP trees that may block `?wsdl` yet accept POSTs (map them alongside the flow in [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).  
   리버스 프록시/라우팅 규칙을 열거하여 `?wsdl` 요청을 차단하지만 POST는 허용하는 숨겨진 SOAP 트리를 찾으세요 (이를 [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md) 흐름과 함께 매핑하세요).

2. Unpack the EAR/WAR/EJB artifacts (`unzip *.ear`) and inspect `application.xml`, `web.xml`, `@WebService` annotations, and handler chains (e.g., `LoginHandlerChain.xml`) to uncover the handler class, SOAP header QName, and the backing EJB names.  
   EAR/WAR/EJB 아티팩트(`unzip *.ear`)를 풀고 `application.xml`, `web.xml`, `@WebService` 애노테이션, handler chain(예: `LoginHandlerChain.xml`)을 검사하여 handler 클래스, SOAP header QName, 백엔드 EJB 이름을 확인하세요.

3. If metadata is missing, brute-force likely `ServiceName?wsdl` paths or temporarily relax lab proxies, then import any recovered WSDL into tooling such as [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) to generate baseline envelopes.  
   메타데이터가 없으면 가능한 `ServiceName?wsdl` 경로를 무차별 시도하거나 테스트 프록시 설정을 일시적으로 완화한 뒤, 복구한 WSDL을 [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) 같은 도구로 가져와 기본 envelope를 생성하세요.

4. Review the handler sources for `ThreadLocal` keepers (e.g., `SubjectHolder.setSubject()`) that are never cleared when the authentication header is missing or malformed.  
   인증 헤더가 없거나 잘못된 경우에도 제거되지 않는 `ThreadLocal` 보관자(예: `SubjectHolder.setSubject()`)가 있는지 handler 소스 코드를 검토하세요.

## Exploitation

1. Send a valid request **with** the proprietary header to learn the normal response codes and any error used for invalid tokens.  
   **전용 헤더와 함께** 유효한 요청을 보내 정상 응답 코드와 잘못된 토큰에 대한 오류 동작을 파악하세요.

2. Resend the same SOAP body while omitting the header. Keep the XML well-formed and respect the required namespaces so the handler exits cleanly.  
   같은 SOAP 바디를 헤더 없이 재전송하세요. XML을 올바르게 구성하고 필요한 네임스페이스를 지켜 handler가 정상적으로 종료되게 하세요.

3. Loop the request; when it lands on a thread that previously executed a privileged action, the reused `Subject` unlocks protected operations such as user or credential managers.  
   요청을 반복 전송하세요. 이전에 권한 있는 작업을 실행한 스레드에 도달하면 재사용된 `Subject`가 사용자 또는 자격 증명 관리자 같은 보호된 작업의 접근을 허용합니다.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
### 2025 HID ActivID/IASP 사례 연구 (HID-PSA-2025-002)

- Synacktiv는 ActivID 8.6–8.7의 JAX-WS `LoginHandler`가 `mySubjectHeader` SOAP 헤더가 존재하거나 콘솔/SSP 트래픽이 인증될 때 `SubjectHolder.subject`를 설정하지만, 헤더가 없을 때는 이를 제거(초기화)하지 않는다는 것을 보여주었다.
- 같은 워커 스레드에서 헤더가 없는 이후의 SOAP 호출은 그 캐시된 `Subject`를 상속하여, `UserManager`나 `CredentialManager`와 같은 엔드포인트를 통해 인증되지 않은 관리자 사용자 생성 또는 자격증명 import가 가능해진다.
- 관찰된 신뢰할 수 있는 악용 패턴:
1. 많은 스레드에서 인증된 컨텍스트를 유도한다(예: `/ssp`를 대량 요청하거나 다른 브라우저 탭에서 관리자로 `/aiconsole`에 로그인).
2. 헤더 없는 SOAP 바디를 높은 병렬성으로 `/ac-iasp-backend-jaxws/UserManager` 또는 다른 EJB 기반 JAX-WS 엔드포인트로 대량 전송한다; '감염된' 스레드를 재사용하는 각 요청은 권한이 상승된 `Subject`로 실행된다.
3. 권한 있는 응답이 돌아올 때까지 반복한다; Keep-Alive 연결과 큰 워커 풀을 재사용해 스레드 재사용 확률을 최대화한다.
- 핸들러 및 프로세스 흐름 요약:
- `LoginHandlerChain.xml` → `LoginHandler.handleMessage()`는 `mySubjectHeader`를 언마샬링하여 `Subject`를 static `ThreadLocal`인 `SubjectHolder`에 저장한다.
- `ProcessManager.triggerProcess()`는 이후 비즈니스 프로세스에 `SubjectHolder.getSubject()`를 주입하므로, 헤더가 없으면 오래된 식별자가 그대로 남는다.
- 어드바이저리의 현장 PoC는 두 단계 SOAP 악용을 사용한다: 먼저 `getUsers`로 정보를 leak한 다음, 권한 있는 스레드가 처리할 때 `createUser` + `importCredential`로 악성 관리자 계정을 심는다.

## 버그 검증

- Attach JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) 또는 유사한 디버깅 훅을 연결해 각 호출 전후의 `ThreadLocal` 내용을 관찰하여, 인증되지 않은 요청이 이전 관리자 `Subject`를 상속했는지 확인한다.
- 운영 장비에서는 JFR 또는 BTrace로 각 요청마다 `SubjectHolder.getSubject()`를 덤프해 헤더 없음 재사용을 검증할 수도 있다.

## References

- [Synacktiv – ActivID authentication bypass (HID-PSA-2025-002)](https://www.synacktiv.com/en/advisories/activid-authentication-bypass.html)
- [HID Global – Product Security Advisory HID-PSA-2025-002 SOAP-API Authentication Bypass](https://www.hidglobal.com/sites/default/files/documentlibrary/HID-PSA-2025-02%20SOAP_API_a.pdf)
- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
