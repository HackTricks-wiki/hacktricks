# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Einige Middleware-Ketten speichern das authentifizierte `Subject`/`Principal` in einer statischen `ThreadLocal` und aktualisieren es nur, wenn ein proprietärer SOAP-Header eintrifft.
- Weil WebLogic/JBoss/GlassFish Worker-Threads recyceln, führt das Weglassen dieses Headers dazu, dass das zuletzt von dem Thread verarbeitete privilegierte `Subject` stillschweigend wiederverwendet wird.
- Hammer den verwundbaren endpoint mit header-less, aber wohlgeformten SOAP bodies, bis ein wiederverwendeter Thread dir den gestohlenen Administrator-Kontext gewährt.

## Ursache

Handlers ähnlich dem folgenden überschreiben die `ThreadLocal`-Identität nur, wenn der custom header vorhanden ist, sodass der Kontext der vorherigen Anfrage erhalten bleibt:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Ermitteln Sie die reverse proxy / routing rules, um versteckte SOAP-Bäume zu finden, die `?wsdl` blockieren, aber POSTs akzeptieren (map them alongside the flow in [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Packen Sie die EAR/WAR/EJB-Artefakte aus (`unzip *.ear`) und untersuchen Sie `application.xml`, `web.xml`, `@WebService`-Annotationen und handler chains (z. B. `LoginHandlerChain.xml`), um die Handler-Klasse, den SOAP-Header-QName und die zugrundeliegenden EJB-Namen aufzudecken.
3. Wenn Metadaten fehlen, brute-force wahrscheinliche `ServiceName?wsdl`-Pfade oder lockern Sie temporär Lab-Proxys, und importieren Sie dann gefundene WSDLs in Tools wie [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f), um Basis-Envelopes zu generieren.
4. Prüfen Sie die Handler-Quellen auf `ThreadLocal`-Keeper (z. B. `SubjectHolder.setSubject()`), die nicht gelöscht werden, wenn der Authentication-Header fehlt oder fehlerhaft ist.

## Exploitation

1. Senden Sie eine gültige Anfrage mit dem proprietären Header, um die normalen Response-Codes und etwaige Fehler für ungültige Tokens kennenzulernen.
2. Senden Sie denselben SOAP-Body erneut und lassen Sie dabei den Header weg. Halten Sie das XML wohlgeformt und respektieren Sie die erforderlichen Namespaces, damit der Handler sauber exitet.
3. Wiederholen Sie die Anfrage in einer Schleife; landet sie auf einem Thread, der zuvor eine privilegierte Aktion ausgeführt hat, hebt das wiederverwendete `Subject` geschützte Operationen wie User- oder Credential-Manager wieder frei.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Validierung des Bugs

- Hänge JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) oder vergleichbare Debugging-Hooks an, um die Inhalte von `ThreadLocal` vor und nach jedem Aufruf zu überwachen und zu bestätigen, dass eine nicht authentifizierte Anfrage ein vorheriges Administrator-`Subject` geerbt hat.

## Referenzen

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
