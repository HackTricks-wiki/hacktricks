# SOAP/JAX-WS ThreadLocal Authentication Bypass

{{#include ../banners/hacktricks-training.md}}

## Ukratko

- Neki middleware lanci čuvaju autentifikovani `Subject`/`Principal` u statičkom `ThreadLocal` i osvežavaju ga samo kada stigne proprietarni SOAP header.
- Pošto WebLogic/JBoss/GlassFish recikliraju worker thread-ove, izostavljanje tog headera uzrokuje da se poslednji privilegovani `Subject` obrađen od strane threada tiho ponovo iskoristi.
- Napadajte ranjiv endpoint bez headera ali sa ispravno formiranim SOAP telima dok ponovo upotrebljeni thread ne dodeli ukradeni administratorski kontekst.
- 2025 HID ActivID/IASP (HID-PSA-2025-002) je stvarni primer: JAX-WS handler kešira `SubjectHolder` `ThreadLocal`, što omogućava neautentifikovanim SOAP pozivima da naslede identitet postavljen prethodnim console/SSP zahtevima.

## Uzrok

Handleri slični sledećem prepisuju thread-local identitet samo kada je prisutan custom header, tako da kontekst prethodnog zahteva opstaje:
```java
public boolean handleMessage(SOAPMessageContext ctx) {
if (!outbound) {
SOAPHeader hdr = ctx.getMessage().getSOAPPart().getEnvelope().getHeader();
SOAPHeaderElement e = findHeader(hdr, subjectName);
if (e != null) {
SubjectHolder.setSubject(unmarshal(e));
}
}
return true;
}
```
## Recon

1. Izlistajte reverse proxy / routing rules kako biste pronašli skrivene SOAP tree-ove koji mogu blokirati `?wsdl` ali prihvataju POST-ove (mapirajte ih uz tok u [80,443 - Pentesting Web Methodology](../network-services-pentesting/pentesting-web/README.md)).
2. Raspakujte EAR/WAR/EJB artifacts (`unzip *.ear`) i pregledajte `application.xml`, `web.xml`, `@WebService` annotations, i handler chains (npr. `LoginHandlerChain.xml`) da otkrijete handler class, SOAP header QName, i backing EJB names.
3. Ako metadata nedostaje, brute-force-ujte verovatne `ServiceName?wsdl` paths ili privremeno opustite lab proxies, zatim importujte bilo koji povraćeni WSDL u tooling kao što je [Burp Suite Wsdler](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f) da generišete baseline envelopes.
4. Pregledajte handler source-ove radi `ThreadLocal` keepers (npr. `SubjectHolder.setSubject()`) koji se nikada ne clear-uju kada authentication header nedostaje ili je malformed.

## Exploitation

1. Pošaljite validan zahtev **with** proprietarnim header-om da biste saznali normalne response codes i eventualne greške koje se koriste za invalid tokens.
2. Ponovo pošaljite isti SOAP body dok izostavljate header. Održavajte XML well-formed i poštujte required namespaces tako da handler exits cleanly.
3. Loop-ujte zahtev; kada stigne na thread koji je ranije izvršio privilegovanu akciju, ponovo upotrebljeni `Subject` otključava protected operations kao što su user ili credential managers.
```http
POST /ac-iasp-backend-jaxws/UserManager HTTP/1.1
Host: target
Content-Type: text/xml;charset=UTF-8

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
xmlns:jax="http://jaxws.user.frontend.iasp.service.actividentity.com">
<soapenv:Header/>
<soapenv:Body>
<jax:findUserIds>
<arg0></arg0>
<arg1>spl*</arg1>
</jax:findUserIds>
</soapenv:Body>
</soapenv:Envelope>
```
### 2025 HID ActivID/IASP studija slučaja (HID-PSA-2025-002)

- Synacktiv je pokazao da JAX-WS `LoginHandler` u ActivID 8.6–8.7 postavlja `SubjectHolder.subject` kada je prisutan SOAP header `mySubjectHeader` ili kada se promet sa konzole/SSP autentifikuje, ali ga nikada ne briše kada header izostane.
- Bilo koji naredni SOAP poziv koji nema header na istoj radničkoj niti nasleđuje taj keširani `Subject`, što omogućava neautentifikovano kreiranje administratorskih korisnika ili import credential-a preko endpoint-a kao što su `UserManager` ili `CredentialManager`.
- Pouzdan obrazac eksploatacije uočen:
1. Pokrenuti autentifikovani kontekst na mnogim nitima (npr. spamovati `/ssp` ili se ulogovati na `/aiconsole` kao admin u drugom tabu pregledača).
2. Preplaviti SOAP tela bez header-a ka `/ac-iasp-backend-jaxws/UserManager` ili drugim EJB-backed JAX-WS endpoint-ima sa visokim paralelizmom; svaki hit koji ponovo iskoristi "infektovanu" nit izvršava se sa povišenim `Subject`.
3. Ponavljati dok ne dobijete privilegovane odgovore; ponovo koristiti Keep-Alive konekcije i velike radne pool-ove da maksimizujete verovatnoću ponovne upotrebe niti.
- Istaknuti delovi handler-a i toka procesa:
- `LoginHandlerChain.xml` → `LoginHandler.handleMessage()` unmarshaluje `mySubjectHeader` i čuva `Subject` u `SubjectHolder` (staticki `ThreadLocal`).
- `ProcessManager.triggerProcess()` kasnije ubrizgava `SubjectHolder.getSubject()` u poslovne procese, pa izostanak header-a ostavlja zastarele identitete netaknutim.
- PoC iz terena iz advisora koristi dvo-stepenu SOAP zloupotrebu: prvo `getUsers` da bi se leak-ovala informacija, zatim `createUser` + `importCredential` da se postavi lažni admin kada privilegovana nit bude iskorišćena.

## Validacija buga

- Prikačiti JDWP (`-agentlib:jdwp=transport=dt_socket,server=y,address=5005,suspend=n`) ili slične debugging hook-ove da se posmatra sadržaj `ThreadLocal` pre i posle svakog poziva, potvrđujući da je neautentifikovani zahtev nasledio prethodni administratorski `Subject`.
- Na producionim aparatima možete takođe instrumentovati sa JFR ili BTrace da dump-ujete `SubjectHolder.getSubject()` po zahtevu, verifikujući ponovnu upotrebu bez header-a.

## References

- [Synacktiv – ActivID authentication bypass (HID-PSA-2025-002)](https://www.synacktiv.com/en/advisories/activid-authentication-bypass.html)
- [HID Global – Product Security Advisory HID-PSA-2025-002 SOAP-API Authentication Bypass](https://www.hidglobal.com/sites/default/files/documentlibrary/HID-PSA-2025-02%20SOAP_API_a.pdf)
- [Synacktiv – ActivID administrator account takeover: the story behind HID-PSA-2025-002](https://www.synacktiv.com/publications/activid-administrator-account-takeover-the-story-behind-hid-psa-2025-002.html)
- [PortSwigger – Wsdler (WSDL parser) extension](https://portswigger.net/bappstore/594a49bb233748f2bc80a9eb18a2e08f)

{{#include ../banners/hacktricks-training.md}}
