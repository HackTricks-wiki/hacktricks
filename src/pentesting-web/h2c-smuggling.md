# Upgrade Header Smuggling

{{#include ../banners/hacktricks-training.md}}

### H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

#### HTTP2 Over Cleartext (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C, ili **http2 preko čistog teksta**, odstupa od norme prolaznih HTTP veza tako što nadograđuje standardnu HTTP **vezu na trajnu**. Ova nadograđena veza koristi http2 binarni protokol za kontinuiranu komunikaciju, za razliku od jedinstvene prirode zahteva čistog HTTP-a.

Suština problema sa krijumčarenjem nastaje upotrebom **obrnute proxy**. Obično, obrnuta proxy obrađuje i prosleđuje HTTP zahteve ka backend-u, vraćajući odgovor backend-a nakon toga. Međutim, kada je `Connection: Upgrade` zaglavlje prisutno u HTTP zahtevu (što se obično vidi sa websocket vezama), obrnuta **proxy održava trajnu vezu** između klijenta i servera, olakšavajući kontinuiranu razmenu potrebnu za određene protokole. Za H2C veze, pridržavanje RFC zahteva prisustvo tri specifična zaglavlja:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
Vulnerabilnost nastaje kada, nakon nadogradnje veze, obrnuti proxy prestane da upravlja pojedinačnim zahtevima, pretpostavljajući da je njegov posao usmeravanja završen nakon uspostavljanja veze. Iskorišćavanje H2C Smuggling-a omogućava zaobilaženje pravila obrnute proxy primenjenih tokom obrade zahteva, kao što su usmeravanje zasnovano na putanji, autentifikacija i WAF obrada, pod pretpostavkom da je H2C veza uspešno uspostavljena.

#### Vulnerable Proxies <a href="#exploitation" id="exploitation"></a>

Vulnerabilnost zavisi od obrade `Upgrade` i ponekad `Connection` zaglavlja od strane obrnute proxy. Sledeći proxy-ji inherentno prosleđuju ova zaglavlja tokom proxy-pasa, čime inherentno omogućavaju H2C smuggling:

- HAProxy
- Traefik
- Nuster

S druge strane, ove usluge ne prosleđuju inherentno oba zaglavlja tokom proxy-pasa. Međutim, mogu biti konfigurisane nesigurno, omogućavajući nefiltrirano prosleđivanje `Upgrade` i `Connection` zaglavlja:

- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy
- Apache Traffic Server

#### Exploitation <a href="#exploitation" id="exploitation"></a>

Važno je napomenuti da ne svi serveri inherentno prosleđuju zaglavlja potrebna za usklađenu H2C nadogradnju. Kao takvi, serveri poput AWS ALB/CLB, NGINX i Apache Traffic Server, među ostalima, prirodno blokiraju H2C veze. Ipak, vredi testirati sa neusklađenom varijantom `Connection: Upgrade`, koja isključuje `HTTP2-Settings` vrednost iz `Connection` zaglavlja, jer neki backend-ovi možda neće biti u skladu sa standardima.

> [!CAUTION]
> Bez obzira na specifičnu **putanju** određenu u `proxy_pass` URL-u (npr., `http://backend:9999/socket.io`), uspostavljena veza podrazumevano se prebacuje na `http://backend:9999`. Ovo omogućava interakciju sa bilo kojom putanjom unutar tog internog krajnjeg tačke, koristeći ovu tehniku. Kao rezultat, specifikacija putanje u `proxy_pass` URL-u ne ograničava pristup.

Alati [**h2csmuggler by BishopFox**](https://github.com/BishopFox/h2csmuggler) i [**h2csmuggler by assetnote**](https://github.com/assetnote/h2csmuggler) olakšavaju pokušaje da se **zaobiđu zaštite koje nameće proxy** uspostavljanjem H2C veze, čime se omogućava pristup resursima zaštićenim proxy-jem.

Za dodatne informacije o ovoj vulnerabilnosti, posebno u vezi sa NGINX-om, pogledajte [**ovaj detaljan resurs**](../network-services-pentesting/pentesting-web/nginx.md#proxy_set_header-upgrade-and-connection).

## Websocket Smuggling

Websocket smuggling, za razliku od kreiranja HTTP2 tunela do krajnje tačke dostupne putem proxy-ja, uspostavlja Websocket tunel kako bi zaobišao potencijalna ograničenja proxy-ja i omogućio direktnu komunikaciju sa krajnjom tačkom.

### Scenario 1

U ovom scenariju, backend koji nudi javni WebSocket API zajedno sa nedostupnim internim REST API-jem je meta zlonamernog klijenta koji traži pristup internom REST API-ju. Napad se odvija u nekoliko koraka:

1. Klijent započinje slanjem Upgrade zahteva obrnutoj proxy sa pogrešnom verzijom protokola `Sec-WebSocket-Version` u zaglavlju. Proxy, ne uspevajući da validira `Sec-WebSocket-Version` zaglavlje, veruje da je Upgrade zahtev validan i prosleđuje ga backend-u.
2. Backend odgovara sa status kodom `426`, ukazujući na pogrešnu verziju protokola u `Sec-WebSocket-Version` zaglavlju. Obrnuti proxy, zanemarujući status odgovora backend-a, pretpostavlja spremnost za WebSocket komunikaciju i prosleđuje odgovor klijentu.
3. Kao rezultat, obrnuti proxy je zavaravan da veruje da je WebSocket veza uspostavljena između klijenta i backend-a, dok je u stvarnosti backend odbio Upgrade zahtev. Ipak, proxy održava otvorenu TCP ili TLS vezu između klijenta i backend-a, omogućavajući klijentu neograničen pristup privatnom REST API-ju putem ove veze.

Pogođeni obrnuti proxy-ji uključuju Varnish, koji je odbio da reši problem, i Envoy proxy verziju 1.8.0 ili stariju, dok su novije verzije izmenile mehanizam nadogradnje. Drugi proxy-ji takođe mogu biti podložni.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

### Scenario 2

Ovaj scenario uključuje backend sa javnim WebSocket API-jem i javnim REST API-jem za proveru zdravlja, zajedno sa nedostupnim internim REST API-jem. Napad, složeniji, uključuje sledeće korake:

1. Klijent šalje POST zahtev da pokrene API za proveru zdravlja, uključujući dodatno HTTP zaglavlje `Upgrade: websocket`. NGINX, koji služi kao obrnuti proxy, tumači ovo kao standardni Upgrade zahtev isključivo na osnovu `Upgrade` zaglavlja, zanemarujući druge aspekte zahteva, i prosleđuje ga backend-u.
2. Backend izvršava API za proveru zdravlja, obraćajući se spoljnim resursu pod kontrolom napadača koji vraća HTTP odgovor sa status kodom `101`. Ovaj odgovor, kada ga backend primi i prosledi NGINX-u, zavarava proxy da misli da je WebSocket veza uspostavljena zbog njegove validacije samo status koda.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **Warning:** Složenost ove tehnike se povećava jer zahteva mogućnost interakcije sa krajnjom tačkom koja može vratiti status kod 101.

Na kraju, NGINX je prevaren da veruje da postoji WebSocket veza između klijenta i backend-a. U stvarnosti, takva veza ne postoji; API za proveru zdravlja je bio meta. Ipak, obrnuti proxy održava vezu otvorenom, omogućavajući klijentu pristup privatnom REST API-ju putem nje.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

Većina obrnutih proxy-ja je podložna ovom scenariju, ali iskorišćavanje zavisi od prisustva spoljne SSRF vulnerabilnosti, koja se obično smatra problemom niske ozbiljnosti.

#### Labs

Proverite laboratorije da testirate oba scenarija u [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

### References

- [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
- [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
- [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

{{#include ../banners/hacktricks-training.md}}
