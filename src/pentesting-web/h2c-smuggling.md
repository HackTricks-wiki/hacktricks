# Upgrade Header Smuggling

{{#include ../banners/hacktricks-training.md}}

### H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

#### HTTP2 Over Cleartext (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C, або **http2 через відкритий текст**, відхиляється від норми транзитних HTTP з'єднань, оновлюючи стандартне HTTP **з'єднання до постійного**. Це оновлене з'єднання використовує бінарний протокол http2 для постійної комунікації, на відміну від одноразового запиту відкритого тексту HTTP.

Суть проблеми контрабанди виникає з використанням **зворотного проксі**. Зазвичай зворотний проксі обробляє та пересилає HTTP запити на бекенд, повертаючи відповідь бекенду після цього. Однак, коли заголовок `Connection: Upgrade` присутній у HTTP запиті (зазвичай спостерігається з з'єднаннями websocket), зворотний **проксі підтримує постійне з'єднання** між клієнтом і сервером, полегшуючи безперервний обмін, необхідний для певних протоколів. Для H2C з'єднань дотримання RFC вимагає наявності трьох специфічних заголовків:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
Вразливість виникає, коли після оновлення з'єднання зворотний проксі перестає обробляти окремі запити, вважаючи, що його робота з маршрутизації завершена після встановлення з'єднання. Використання H2C Smuggling дозволяє обійти правила зворотного проксі, які застосовуються під час обробки запитів, такі як маршрутизація на основі шляху, аутентифікація та обробка WAF, за умови, що з'єднання H2C успішно ініційоване.

#### Вразливі проксі <a href="#exploitation" id="exploitation"></a>

Вразливість залежить від обробки зворотним проксі заголовків `Upgrade` і іноді `Connection`. Наступні проксі за замовчуванням пересилають ці заголовки під час проксі-проходу, тим самим за замовчуванням дозволяючи H2C smuggling:

- HAProxy
- Traefik
- Nuster

Навпаки, ці сервіси не пересилають обидва заголовки під час проксі-проходу за замовчуванням. Однак їх можна налаштувати ненадійно, що дозволяє нефільтровану передачу заголовків `Upgrade` і `Connection`:

- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy
- Apache Traffic Server

#### Експлуатація <a href="#exploitation" id="exploitation"></a>

Важливо зазначити, що не всі сервери за замовчуванням пересилають заголовки, необхідні для відповідного оновлення з'єднання H2C. Таким чином, такі сервери, як AWS ALB/CLB, NGINX і Apache Traffic Server, серед інших, природно блокують з'єднання H2C. Проте варто протестувати варіант, що не відповідає стандартам, `Connection: Upgrade`, який виключає значення `HTTP2-Settings` з заголовка `Connection`, оскільки деякі бекенди можуть не відповідати стандартам.

> [!CAUTION]
> Незалежно від конкретного **шляху**, вказаного в URL `proxy_pass` (наприклад, `http://backend:9999/socket.io`), встановлене з'єднання за замовчуванням переходить на `http://backend:9999`. Це дозволяє взаємодіяти з будь-яким шляхом у цьому внутрішньому кінцевому пункті, використовуючи цю техніку. Отже, вказівка шляху в URL `proxy_pass` не обмежує доступ.

Інструменти [**h2csmuggler by BishopFox**](https://github.com/BishopFox/h2csmuggler) та [**h2csmuggler by assetnote**](https://github.com/assetnote/h2csmuggler) полегшують спроби **обійти захист, накладений проксі**, встановлюючи з'єднання H2C, що дозволяє отримати доступ до ресурсів, захищених проксі.

Для отримання додаткової інформації про цю вразливість, особливо щодо NGINX, зверніться до [**цього детального ресурсу**](../network-services-pentesting/pentesting-web/nginx.md#proxy_set_header-upgrade-and-connection).

## Websocket Smuggling

Websocket smuggling, на відміну від створення HTTP2 тунелю до кінцевого пункту, доступного через проксі, встановлює Websocket тунель для обходу потенційних обмежень проксі та сприяє прямій комунікації з кінцевим пунктом.

### Сценарій 1

У цьому сценарії зловмисний клієнт намагається отримати доступ до внутрішнього REST API, націлюючись на бекенд, який пропонує публічний WebSocket API поряд з недоступним внутрішнім REST API. Атака розгортається в кілька етапів:

1. Клієнт ініціює, надсилаючи запит Upgrade до зворотного проксі з неправильним значенням протоколу `Sec-WebSocket-Version` у заголовку. Проксі, не перевіряючи заголовок `Sec-WebSocket-Version`, вважає запит Upgrade дійсним і пересилає його до бекенду.
2. Бекенд відповідає кодом статусу `426`, вказуючи на неправильну версію протоколу в заголовку `Sec-WebSocket-Version`. Зворотний проксі, ігноруючи статус відповіді бекенду, вважає, що готовий до WebSocket зв'язку, і передає відповідь клієнту.
3. В результаті зворотний проксі вводиться в оману, вважаючи, що WebSocket з'єднання було встановлено між клієнтом і бекендом, тоді як насправді бекенд відхилив запит Upgrade. Незважаючи на це, проксі підтримує відкритим TCP або TLS з'єднання між клієнтом і бекендом, що дозволяє клієнту отримати необмежений доступ до приватного REST API через це з'єднання.

Постраждалі зворотні проксі включають Varnish, який відмовився вирішити цю проблему, і версію проксі Envoy 1.8.0 або старішу, у новіших версіях механізм оновлення був змінений. Інші проксі також можуть бути вразливими.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

### Сценарій 2

Цей сценарій передбачає бекенд з публічним WebSocket API та публічним REST API для перевірки стану, а також недоступним внутрішнім REST API. Атака, більш складна, включає наступні етапи:

1. Клієнт надсилає POST запит для активації API перевірки стану, включаючи додатковий HTTP заголовок `Upgrade: websocket`. NGINX, що виконує роль зворотного проксі, інтерпретує це як стандартний запит Upgrade, спираючись лише на заголовок `Upgrade`, і ігнорує інші аспекти запиту, пересилаючи його до бекенду.
2. Бекенд виконує API перевірки стану, звертаючись до зовнішнього ресурсу, контрольованого зловмисником, який повертає HTTP відповідь з кодом статусу `101`. Ця відповідь, отримана бекендом і переслана до NGINX, вводить проксі в оману, змушуючи його вважати, що WebSocket з'єднання було встановлено, оскільки він перевіряє лише код статусу.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **Warning:** Складність цієї техніки зростає, оскільки вона вимагає можливості взаємодії з кінцевим пунктом, здатним повернути код статусу 101.

Врешті-решт, NGINX вводиться в оману, вважаючи, що WebSocket з'єднання існує між клієнтом і бекендом. Насправді такого з'єднання не існує; ціллю була API перевірки стану REST. Проте зворотний проксі підтримує з'єднання відкритим, що дозволяє клієнту отримати доступ до приватного REST API через нього.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

Більшість зворотних проксі вразливі до цього сценарію, але експлуатація залежить від наявності зовнішньої вразливості SSRF, яка зазвичай вважається проблемою низької серйозності.

#### Лабораторії

Перевірте лабораторії, щоб протестувати обидва сценарії в [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

### Посилання

- [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
- [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
- [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

{{#include ../banners/hacktricks-training.md}}
