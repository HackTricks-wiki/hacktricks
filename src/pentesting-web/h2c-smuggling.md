# Upgrade Header Smuggling

{{#include ../banners/hacktricks-training.md}}

### H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

#### HTTP2 Over Cleartext (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C, або **http2 через відкритий текст**, відхиляється від норми транзитних HTTP з'єднань, оновлюючи стандартне HTTP **з'єднання до постійного**. Це оновлене з'єднання використовує бінарний протокол http2 для постійної комунікації, на відміну від одноразового запиту відкритого тексту HTTP.

Суть проблеми контрабанди виникає з використанням **реверс-проксі**. Зазвичай реверс-проксі обробляє та пересилає HTTP запити на бекенд, повертаючи відповідь бекенду після цього. Однак, коли заголовок `Connection: Upgrade` присутній у HTTP запиті (зазвичай спостерігається з з'єднаннями websocket), реверс **проксі підтримує постійне з'єднання** між клієнтом і сервером, полегшуючи безперервний обмін, необхідний для певних протоколів. Для H2C з'єднань дотримання RFC вимагає наявності трьох специфічних заголовків:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
Уразливість виникає, коли після оновлення з'єднання реверсний проксі перестає обробляти окремі запити, вважаючи, що його робота з маршрутизації завершена після встановлення з'єднання. Використання H2C Smuggling дозволяє обійти правила реверсного проксі, які застосовуються під час обробки запитів, такі як маршрутизація на основі шляху, аутентифікація та обробка WAF, за умови, що з'єднання H2C успішно ініційоване.

#### Уразливі проксі <a href="#exploitation" id="exploitation"></a>

Уразливість залежить від обробки реверсним проксі заголовків `Upgrade` і іноді `Connection`. Наступні проксі за замовчуванням пересилають ці заголовки під час проксі-проходу, тим самим вбудовано дозволяючи H2C smuggling:

- HAProxy
- Traefik
- Nuster

Навпаки, ці сервіси не пересилають обидва заголовки за замовчуванням під час проксі-проходу. Однак їх можна налаштувати ненадійно, що дозволяє не фільтрувати пересилання заголовків `Upgrade` і `Connection`:

- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy
- Apache Traffic Server

#### Експлуатація <a href="#exploitation" id="exploitation"></a>

Важливо зазначити, що не всі сервери за замовчуванням пересилають заголовки, необхідні для відповідного оновлення з'єднання H2C. Таким чином, такі сервери, як AWS ALB/CLB, NGINX і Apache Traffic Server, серед інших, природно блокують з'єднання H2C. Проте варто протестувати варіант `Connection: Upgrade`, який виключає значення `HTTP2-Settings` з заголовка `Connection`, оскільки деякі бекенди можуть не відповідати стандартам.

> [!CAUTION]
> Незалежно від конкретного **шляху**, вказаного в URL `proxy_pass` (наприклад, `http://backend:9999/socket.io`), встановлене з'єднання за замовчуванням є `http://backend:9999`. Це дозволяє взаємодіяти з будь-яким шляхом у цьому внутрішньому кінцевому пункті, використовуючи цю техніку. Отже, вказівка шляху в URL `proxy_pass` не обмежує доступ.

Інструменти [**h2csmuggler by BishopFox**](https://github.com/BishopFox/h2csmuggler) та [**h2csmuggler by assetnote**](https://github.com/assetnote/h2csmuggler) полегшують спроби **обійти захист, накладений проксі**, встановлюючи з'єднання H2C, що дозволяє отримати доступ до ресурсів, захищених проксі.

Для отримання додаткової інформації про цю уразливість, особливо щодо NGINX, зверніться до [**цього детального ресурсу**](../network-services-pentesting/pentesting-web/nginx.md#proxy_set_header-upgrade-and-connection).

## Websocket Smuggling

Websocket smuggling, на відміну від створення HTTP2 тунелю до кінцевого пункту, доступного через проксі, встановлює Websocket тунель для обходу потенційних обмежень проксі та сприяє прямій комунікації з кінцевим пунктом.

### Сценарій 1

У цьому сценарії цільовим є бекенд, який пропонує публічний WebSocket API поряд з недоступним внутрішнім REST API, на який намагається отримати доступ зловмисний клієнт. Атака розгортається в кілька етапів:

1. Клієнт ініціює, надсилаючи запит Upgrade до реверсного проксі з неправильним протоколом версії `Sec-WebSocket-Version` у заголовку. Проксі, не перевіряючи заголовок `Sec-WebSocket-Version`, вважає запит Upgrade дійсним і пересилає його до бекенду.
2. Бекенд відповідає кодом статусу `426`, вказуючи на неправильну версію протоколу в заголовку `Sec-WebSocket-Version`. Реверсний проксі, ігноруючи статус відповіді бекенду, вважає, що готовий до WebSocket зв'язку і передає відповідь клієнту.
3. В результаті реверсний проксі вводиться в оману, вважаючи, що WebSocket з'єднання було встановлено між клієнтом і бекендом, тоді як насправді бекенд відхилив запит Upgrade. Незважаючи на це, проксі підтримує відкритим TCP або TLS з'єднання між клієнтом і бекендом, що дозволяє клієнту отримати необмежений доступ до приватного REST API через це з'єднання.

Постраждалі реверсні проксі включають Varnish, який відмовився вирішити цю проблему, і версію проксі Envoy 1.8.0 або старішу, у новіших версіях механізм оновлення був змінений. Інші проксі також можуть бути вразливими.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

### Сценарій 2

Цей сценарій передбачає бекенд з публічним WebSocket API та публічним REST API для перевірки стану, а також недоступним внутрішнім REST API. Атака, більш складна, включає наступні етапи:

1. Клієнт надсилає POST запит для активації API перевірки стану, включаючи додатковий HTTP заголовок `Upgrade: websocket`. NGINX, що виконує роль реверсного проксі, інтерпретує це як стандартний запит Upgrade, спираючись лише на заголовок `Upgrade`, і ігнорує інші аспекти запиту, пересилаючи його до бекенду.
2. Бекенд виконує API перевірки стану, звертаючись до зовнішнього ресурсу, контрольованого атакуючим, який повертає HTTP відповідь з кодом статусу `101`. Ця відповідь, отримана бекендом і переслана до NGINX, вводить проксі в оману, змушуючи його вважати, що WebSocket з'єднання було встановлено через його перевірку лише коду статусу.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **Warning:** Складність цієї техніки зростає, оскільки вона вимагає можливості взаємодії з кінцевим пунктом, здатним повернути код статусу 101.

Врешті-решт, NGINX вводиться в оману, вважаючи, що WebSocket з'єднання існує між клієнтом і бекендом. Насправді такого з'єднання не існує; цільовим був REST API перевірки стану. Проте реверсний проксі підтримує з'єднання відкритим, що дозволяє клієнту отримати доступ до приватного REST API через нього.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

Більшість реверсних проксі вразливі до цього сценарію, але експлуатація залежить від наявності зовнішньої уразливості SSRF, яка зазвичай вважається проблемою низької серйозності.

#### Лабораторії

Перевірте лабораторії, щоб протестувати обидва сценарії в [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

### Посилання

- [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
- [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
- [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

{{#include ../banners/hacktricks-training.md}}
