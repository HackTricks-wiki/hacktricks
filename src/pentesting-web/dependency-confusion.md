# Dependency Confusion

{{#include ../banners/hacktricks-training.md}}


## Basic Information

Dependency Confusion (piaf. mashambulizi ya uingizaji) hutokea wakati meneja wa kifurushi anapotatua jina la utegemezi kutoka kwa rejista/chanzo kisichokusudiwa, kisichotegemewa (kawaida rejista ya umma) badala ya ile ya kibinafsi/ndani. Hii kwa kawaida husababisha usakinishaji wa kifurushi kinachodhibitiwa na mshambuliaji.

Sababu kuu za msingi:
- Typosquatting/makosa ya tahajia: Kuagiza `reqests` badala ya `requests` (hutatuliwa kutoka rejista ya umma).
- Kifurushi cha ndani kisichopo/kilichotelekezwa: Kuagiza `company-logging` ambacho hakipo tena ndani, hivyo mtatuzi huangalia katika rejista za umma na kupata kifurushi cha mshambuliaji.
- Upendeleo wa toleo kati ya rejista nyingi: Kuagiza `company-requests` ya ndani wakati mtatuzi anaruhusiwa pia kuuliza rejista za umma na anapendelea toleo "bora"/jipya lililochapishwa hadharani na mshambuliaji.

Wazo kuu: Ikiwa mtatuzi anaweza kuona rejista nyingi kwa jina moja la kifurushi na anaruhusiwa kuchagua mgombea "bora" kimataifa, uko hatarini isipokuwa ukizuie utatuzi.


## Exploitation

> [!WARNING]
> Katika hali zote, mshambuliaji anahitaji tu kuchapisha kifurushi kibaya chenye jina sawa na utegemezi ambao ujenzi wako unautatua kutoka rejista ya umma. Vifungo vya wakati wa usakinishaji (kwa mfano, npm scripts) au njia za msimbo wa wakati wa kuagiza mara nyingi hutoa utekelezaji wa msimbo.

### Misspelled & Inexistent

Ikiwa mradi wako unarejelea maktaba ambayo haipatikani katika rejista ya kibinafsi, na zana zako zinarejelea rejista ya umma, mshambuliaji anaweza kuanzisha kifurushi kibaya chenye jina hilo katika rejista ya umma. Mashine zako za kuendesha/CI/dev zitaipata na kuitekeleza.

### Unspecified Version / “Best-version” selection across indexes

Wakuu wa maendeleo mara nyingi huacha toleo bila kufungwa au kuruhusu mipaka pana. Wakati mtatuzi amewekwa na viashiria vya ndani na vya umma, inaweza kuchagua toleo jipya bila kujali chanzo. Kwa majina ya ndani kama `requests-company`, ikiwa kiashiria cha ndani kina `1.0.1` lakini mshambuliaji anachapisha `1.0.2` kwenye rejista ya umma na mtatuzi wako unachukulia yote mawili, kifurushi cha umma kinaweza kushinda.


## AWS Fix

Uthibitisho huu ulipatikana katika AWS CodeArtifact (soma maelezo katika chapisho hili la blog). AWS iliongeza udhibiti ili kuashiria utegemezi/makundi kama ya ndani dhidi ya ya nje ili mteja asipate majina "ya ndani" kutoka kwa rejista za umma za juu.


## Finding Vulnerable Libraries

Katika chapisho la awali kuhusu mkanganyiko wa utegemezi, mwandishi alitafuta maelfu ya orodha zilizofichuliwa (kwa mfano, `package.json`, `requirements.txt`, lockfiles) ili kudhani majina ya kifurushi cha ndani na kisha kuchapisha kifurushi chenye toleo kubwa kwenye rejista za umma.


## Practical Attacker Playbook (for red teams in authorized tests)

- Tambua majina:
- Grep repos na mipangilio ya CI kwa faili za orodha/lock na majina ya ndani.
- Tafuta viambatisho maalum vya shirika (kwa mfano, `@company/*`, `company-*`, internal groupIds, NuGet ID patterns, private module paths for Go, n.k.).
- Angalia rejista za umma kwa upatikanaji:
- Ikiwa jina halijajiandikisha hadharani, jiandikishe; ikiwa ipo, jaribu kuiba utegemezi kwa kulenga majina ya ndani ya transitive.
- Chapisha kwa kipaumbele:
- Chagua semver inayoshinda (kwa mfano, toleo la juu sana) au inalingana na sheria za mtatuzi.
- Jumuisha utekelezaji wa wakati wa usakinishaji ambapo inafaa (kwa mfano, npm `preinstall`/`install`/`postinstall` scripts). Kwa Python, pendelea njia za utekelezaji wa wakati wa kuagiza, kwani magurudumu kwa kawaida hayatekelezi msimbo wa kawaida wakati wa usakinishaji.
- Exfil control:
- Hakikisha kwamba outbound inaruhusiwa kutoka CI hadi mwisho wako ulio na udhibiti; vinginevyo tumia maswali ya DNS au ujumbe wa makosa kama njia ya pembeni kuthibitisha utekelezaji wa msimbo.

> [!CAUTION]
> Daima pata idhini ya maandishi, tumia majina/majaribio ya kifurushi maalum kwa ushirikiano, na mara moja futa au kuratibu usafishaji wakati majaribio yanapokamilika.


## Defender Playbook (what actually prevents confusion)

Mikakati ya juu inayofanya kazi katika mifumo:
- Tumia majina ya ndani ya kipekee na uziunganishe na rejista moja.
- Epuka kuchanganya viwango vya kuaminika wakati wa utatuzi. Pendelea rejista moja ya ndani ambayo inachuja kifurushi kilichothibitishwa badala ya kuwapa wasimamizi wa kifurushi viungo vya ndani na vya umma.
- Kwa wasimamizi wanaounga mkono, ramani kifurushi kwa vyanzo maalum (hakuna "best-version" ya kimataifa kati ya rejista).
- Funga na lock:
- Tumia lockfiles ambazo zinaandika URL za rejista zilizotatuliwa (npm/yarn/pnpm) au tumia pinning ya hash/uthibitisho (pip `--require-hashes`, uthibitisho wa utegemezi wa Gradle).
- Zuia kurudi kwa umma kwa majina ya ndani katika safu ya rejista/mtandao.
- Hifadhi majina yako ya ndani katika rejista za umma inapowezekana ili kuzuia squat ya baadaye.


## Ecosystem Notes and Secure Config Snippets

Hapa chini kuna mipangilio ya vitendo, ya chini ili kupunguza au kuondoa mkanganyiko wa utegemezi. Pendelea kutekeleza haya katika mazingira ya CI na ya maendeleo.

### JavaScript/TypeScript (npm, Yarn, pnpm)

- Tumia kifurushi kilichopangwa kwa ajili ya msimbo wote wa ndani na uweke kiwango kwenye rejista yako ya kibinafsi.
- Hifadhi usakinishaji kuwa usioweza kubadilishwa katika CI (npm lockfile, `yarn install --immutable`).

.npmrc (project-level)
```
# Bind internal scope to private registry; do not allow public fallback for @company/*
@company:registry=https://registry.corp.example/npm/
# Always authenticate to the private registry
//registry.corp.example/npm/:_authToken=${NPM_TOKEN}
strict-ssl=true
```
package.json (kwa kifurushi cha ndani)
```
{
"name": "@company/api-client",
"version": "1.2.3",
"private": false,
"publishConfig": {
"registry": "https://registry.corp.example/npm/",
"access": "restricted"
}
}
```
Yarn Berry (.yarnrc.yml)
```
npmScopes:
company:
npmRegistryServer: "https://registry.corp.example/npm/"
npmAlwaysAuth: true
# CI should fail if lockfile would change
enableImmutableInstalls: true
```
Operational tips:
- Chapisha tu pakiti za ndani ndani ya `@company` scope.
- Kwa pakiti za upande wa tatu, ruhusu rejista ya umma kupitia proxy/mirror yako ya kibinafsi, si moja kwa moja kutoka kwa wateja.
- Fikiria kuwezesha npm package provenance kwa pakiti za umma unazochapisha ili kuongeza ufuatiliaji (haizuia mkanganyiko yenyewe).

### Python (pip / Poetry)

Kanuni kuu: Usitumie `--extra-index-url` kuchanganya viwango vya kuaminika. Ama:
- Funua index moja ya ndani inayopitisha na kuhifadhi pakiti za PyPI zilizothibitishwa, au
- Tumia uchaguzi wa index wazi na hash pinning.

pip.conf
```
[global]
index-url = https://pypi.corp.example/simple
# Disallow source distributions when possible
only-binary = :all:
# Lock with hashes generated via pip-tools
require-hashes = true
```
Zalisha mahitaji yaliyohashwa na pip-tools:
```
# From pyproject.toml or requirements.in
pip-compile --generate-hashes -o requirements.txt
pip install --require-hashes -r requirements.txt
```
Ikiwa lazima ufikie PyPI ya umma, fanya hivyo kupitia proxy yako ya ndani na uweke orodha ya ruhusa wazi hapo. Epuka `--extra-index-url` katika CI.

### .NET (NuGet)

Tumia Ramani ya Chanzo cha Kifurushi kuunganisha mifumo ya ID ya kifurushi na vyanzo wazi na kuzuia ufumbuzi kutoka kwa vyanzo visivyotarajiwa.

nuget.config
```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
<packageSources>
<clear />
<add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
<add key="corp" value="https://nuget.corp.example/v3/index.json" />
</packageSources>
<packageSourceMapping>
<packageSource key="nuget.org">
<package pattern="*" />
</packageSource>
<packageSource key="corp">
<package pattern="Company.*" />
<package pattern="Internal.Utilities" />
</packageSource>
</packageSourceMapping>
</configuration>
```
### Java (Maven/Gradle)

Maven settings.xml (kigeuzi yote kwa ndani; kataza hifadhi za ad-hoc katika POMs kupitia Enforcer):
```
<settings>
<mirrors>
<mirror>
<id>internal-mirror</id>
<mirrorOf>*</mirrorOf>
<url>https://maven.corp.example/repository/group</url>
</mirror>
</mirrors>
</settings>
```
Ongeza Enforcer ili kupiga marufuku hifadhidata zilizotangazwa katika POMs na kulazimisha matumizi ya kioo chako:
```
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-enforcer-plugin</artifactId>
<version>3.6.1</version>
<executions>
<execution>
<id>enforce-no-repositories</id>
<goals><goal>enforce</goal></goals>
<configuration>
<rules>
<requireNoRepositories />
</rules>
</configuration>
</execution>
</executions>
</plugin>
```
Gradle: Kamilisha na kufunga utegemezi.
- Lazimisha hifadhi katika `settings.gradle(.kts)` pekee:
```
dependencyResolutionManagement {
repositoriesMode = RepositoriesMode.FAIL_ON_PROJECT_REPOS
repositories {
maven { url = uri("https://maven.corp.example/repository/group") }
}
}
```
- Wezesha uthibitisho wa utegemezi (checksums/saini) na uweke `gradle/verification-metadata.xml`.

### Go Modules

Sanidi moduli za kibinafsi ili proxy ya umma na DB ya checksum zisitumike kwa ajili yao.
```
# Use corporate proxy first, then public proxy as fallback
export GOPROXY=https://goproxy.corp.example,https://proxy.golang.org
# Mark private paths to skip proxy and checksum db
export GOPRIVATE=*.corp.example.com,github.com/your-org/*
export GONOSUMDB=*.corp.example.com,github.com/your-org/*
```
### Rust (Cargo)

Badilisha crates.io na kioo cha ndani kilichothibitishwa au directory ya muuzaji kwa ajili ya ujenzi; usiruhusu kurudi kwa umma bila mpangilio.

.cargo/config.toml
```
[source.crates-io]
replace-with = "corp-mirror"

[source.corp-mirror]
registry = "https://crates-mirror.corp.example/index"
```
Kwa kuchapisha, kuwa wazi na `--registry` na kuweka akidi za kuingia kwenye usajili wa lengo.

### Ruby (Bundler)

Tumia vizuizi vya chanzo na uzuie Gemfiles za multisource ili gem ziweze kuja tu kutoka kwenye hifadhi iliyokusudiwa.

Gemfile
```
source "https://gems.corp.example"

source "https://rubygems.org" do
gem "rails"
gem "pg"
end

source "https://gems.corp.example" do
gem "company-logging"
end
```
Tekeleza katika ngazi ya usanidi:
```
bundle config set disable_multisource true
```
## CI/CD na Udhibiti wa Rejista Zinazosaidia

- Rejista binafsi kama ingizo moja:
- Tumia Artifactory/Nexus/CodeArtifact/GitHub Packages/Azure Artifacts kama kiunganishi pekee ambacho waendelezaji/CI wanaweza kufikia.
- Tekeleza sheria za kuzuia/ruhusu ili majina ya ndani yasitatuliwe kutoka vyanzo vya umma vya juu.
- Faili za kufunga hazibadilishwi katika CI:
- npm: fanya commit `package-lock.json`, tumia `npm ci`.
- Yarn: fanya commit `yarn.lock`, tumia `yarn install --immutable`.
- Python: fanya commit `requirements.txt` iliyohashishwa, lazimisha `--require-hashes`.
- Gradle: fanya commit `verification-metadata.xml` na ufele kwenye vitu visivyojulikana.
- Udhibiti wa kutoka nje: zuia ufikiaji wa moja kwa moja kutoka CI kwenda kwenye rejista za umma isipokuwa kupitia proxy iliyoidhinishwa.
- Hifadhi ya majina: sajili majina yako ya ndani/majina ya nafasi katika rejista za umma ambapo inasaidiwa.
- Uthibitisho wa kifurushi / uthibitisho: unapochapisha vifurushi vya umma, wezesha uthibitisho/uthibitisho ili kufanya udanganyifu kuwa rahisi kugundulika chini.

## Marejeleo

- [https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
- [https://zego.engineering/dependency-confusion-in-aws-codeartifact-86b9ff68963d](https://zego.engineering/dependency-confusion-in-aws-codeartifact-86b9ff68963d)
- [https://learn.microsoft.com/en-us/nuget/consume-packages/package-source-mapping](https://learn.microsoft.com/en-us/nuget/consume-packages/package-source-mapping)
- [https://yarnpkg.com/configuration/yarnrc/](https://yarnpkg.com/configuration/yarnrc/)

{{#include ../banners/hacktricks-training.md}}
