# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Tecniche di bypass del limite di velocit√†

### Esplorare endpoint simili

Dovrebbero essere effettuati tentativi di attacchi brute force su variazioni dell'endpoint mirato, come `/api/v3/sign-up`, inclusi alternativi come `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` ecc.

### Incorporare caratteri vuoti nel codice o nei parametri

Inserire byte vuoti come `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` nel codice o nei parametri pu√≤ essere una strategia utile. Ad esempio, modificare un parametro in `code=1234%0a` consente di estendere i tentativi attraverso variazioni nell'input, come aggiungere caratteri di nuova riga a un indirizzo email per aggirare le limitazioni sui tentativi.

### Manipolare l'origine IP tramite intestazioni

Modificare le intestazioni per alterare l'origine IP percepita pu√≤ aiutare a eludere il limite di velocit√† basato su IP. Intestazioni come `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, inclusa l'uso di pi√π istanze di `X-Forwarded-For`, possono essere modificate per simulare richieste da IP diversi.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Modifica di Altri Header

√à consigliato alterare altri header di richiesta come l'user-agent e i cookie, poich√© questi possono essere utilizzati per identificare e tracciare i modelli di richiesta. Cambiare questi header pu√≤ prevenire il riconoscimento e il tracciamento delle attivit√† del richiedente.

### Sfruttare il Comportamento dell'API Gateway

Alcuni API gateway sono configurati per applicare il rate limiting in base alla combinazione di endpoint e parametri. Variando i valori dei parametri o aggiungendo parametri non significativi alla richiesta, √® possibile eludere la logica di rate limiting del gateway, facendo apparire ogni richiesta come unica. Ad esempio `/resetpwd?someparam=1`.

### Accedere al Tuo Account Prima di Ogni Tentativo

Accedere a un account prima di ogni tentativo, o di ogni serie di tentativi, potrebbe resettare il contatore del rate limit. Questo √® particolarmente utile quando si testano le funzionalit√† di login. Utilizzare un attacco Pitchfork in strumenti come Burp Suite, per ruotare le credenziali ogni pochi tentativi e assicurarsi che i reindirizzamenti siano contrassegnati, pu√≤ effettivamente riavviare i contatori del rate limit.

### Utilizzare Reti di Proxy

Distribuire una rete di proxy per distribuire le richieste su pi√π indirizzi IP pu√≤ eludere efficacemente i limiti di rate basati su IP. Instradando il traffico attraverso vari proxy, ogni richiesta sembra provenire da una fonte diversa, diluendo l'efficacia del rate limit.

### Suddividere l'Attacco tra Diversi Account o Sessioni

Se il sistema target applica limiti di rate su base per-account o per-sessione, distribuire l'attacco o il test su pi√π account o sessioni pu√≤ aiutare a evitare il rilevamento. Questo approccio richiede la gestione di pi√π identit√† o token di sessione, ma pu√≤ distribuire efficacemente il carico per rimanere entro i limiti consentiti.

### Continua a Provare

Nota che anche se √® in atto un rate limit, dovresti provare a vedere se la risposta √® diversa quando viene inviato l'OTP valido. In [**questo post**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), il cacciatore di bug ha scoperto che anche se un rate limit viene attivato dopo 20 tentativi non riusciti rispondendo con 401, se quello valido veniva inviato, si riceveva una risposta 200.

---

### Abusare del multiplexing HTTP/2 e del request pipelining (2023-2025)

Le implementazioni moderne del rate-limiter contano frequentemente **connessioni TCP** (o anche singole richieste HTTP/1.1) invece del *numero di stream HTTP/2* che una connessione contiene. Quando la stessa connessione TLS viene riutilizzata, un attaccante pu√≤ aprire centinaia di stream paralleli, ognuno dei quali trasporta una richiesta separata, mentre il gateway deduce solo *una* richiesta dalla quota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Se il limitatore protegge solo `/verify` ma non `/api/v2/verify`, puoi anche combinare **confusione del percorso** con il multiplexing HTTP/2 per un *estremamente* veloce brute-forcing di OTP o credenziali.

> üêæ  **Suggerimento:** PortSwigger‚Äôs [Turbo Intruder](https://portswigger.net/research/turbo-intruder) supporta HTTP/2 e ti consente di ottimizzare `maxConcurrentConnections` e `requestsPerConnection` per automatizzare questo attacco.

### Alias GraphQL e operazioni in batch

GraphQL consente al client di inviare **diverse query o mutazioni logicamente indipendenti in una singola richiesta** prefissandole con *alias*. Poich√© il server esegue ogni alias ma il limitatore di velocit√† conta spesso solo *una* richiesta, questo √® un bypass affidabile per il throttling di accesso o reset della password.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Guarda la risposta: esattamente un alias restituir√† 200 OK quando il codice corretto viene colpito, mentre gli altri sono soggetti a limitazione di velocit√†.

La tecnica √® stata popolarizzata dalla ricerca di PortSwigger su ‚ÄúGraphQL batching & aliases‚Äù nel 2023 ed √® stata responsabile di molti recenti pagamenti di bug-bounty.

### Abuso di endpoint REST *batch* o *bulk*

Alcune API espongono endpoint di supporto come `/v2/batch` o accettano un **array di oggetti** nel corpo della richiesta. Se il limitatore √® posizionato solo davanti agli endpoint *legacy*, racchiudere pi√π operazioni all'interno di una singola richiesta bulk pu√≤ completamente eludere la protezione.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Timing the sliding-window

Un classico limitatore a token-bucket o leaky-bucket *si resetta* su un confine di tempo fisso (ad esempio, ogni minuto). Se la finestra √® nota (ad esempio, tramite messaggi di errore come `X-RateLimit-Reset: 27`), invia il numero massimo di richieste consentite **subito prima** che il bucket si resetti, quindi invia immediatamente un altro pieno scoppio.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Questa semplice ottimizzazione pu√≤ pi√π che raddoppiare il tuo throughput senza toccare alcuna altra tecnica di bypass.

---

## Strumenti

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Strumento di fuzzing che supporta la randomizzazione degli header, liste di parole a chunk e rotazione dei proxy round-robin.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Crea automaticamente endpoint API Gateway AWS usa e getta in modo che ogni richiesta provenga da un indirizzo IP diverso ‚Äì perfetto per sconfiggere il throttling basato su IP.
- **Burp Suite ‚Äì IPRotate + estensione**: Utilizza un pool di proxy SOCKS/HTTP (o AWS API Gateway) per ruotare l'IP sorgente in modo trasparente durante gli attacchi *Intruder* e *Turbo Intruder*.
- **Turbo Intruder (BApp)**: Motore di attacco ad alte prestazioni che supporta il multiplexing HTTP/2; regola `requestsPerConnection` a 100-1000 per ridurre centinaia di richieste in una singola connessione.

## Riferimenti

- PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù  (2023)  <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (sezione *Connection-based throttling*) (2024)  <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
