# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### Exploring Similar Endpoints

Il faut tenter d'effectuer des brute force attacks sur des variantes de l'endpoint ciblÃ©, comme `/api/v3/sign-up`, en incluant des alternatives telles que `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up`, etc.

### Incorporating Blank Characters in Code or Parameters

L'insertion d'octets ou de caractÃ¨res blancs tels que `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` dans le code ou les paramÃ¨tres peut Ãªtre une stratÃ©gie utile. Par exemple, modifier un paramÃ¨tre en `code=1234%0a` permet d'Ã©tendre les tentatives via des variations d'entrÃ©e, comme en ajoutant des retours Ã  la ligne dans une adresse e-mail pour contourner les limitations de tentatives.

### Manipulating IP Origin via Headers

La modification des headers pour altÃ©rer l'origine IP perÃ§ue peut aider Ã  Ã©chapper au rate limiting basÃ© sur l'IP. Des headers tels que `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, y compris l'utilisation de plusieurs occurrences de `X-Forwarded-For`, peuvent Ãªtre ajustÃ©s pour simuler des requÃªtes depuis diffÃ©rentes IP.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Modifier d'autres en-tÃªtes

Il est recommandÃ© de modifier d'autres en-tÃªtes de requÃªte tels que user-agent et cookies, car ils peuvent aussi Ãªtre utilisÃ©s pour identifier et suivre les motifs de requÃªtes. Changer ces en-tÃªtes peut empÃªcher la reconnaissance et le suivi des activitÃ©s du requester.

### Tirer parti du comportement des API gateways

Certaines API gateways sont configurÃ©es pour appliquer le rate limiting en fonction de la combinaison d'endpoint et de paramÃ¨tres. En variant les valeurs des paramÃ¨tres ou en ajoutant des paramÃ¨tres non significatifs Ã  la requÃªte, il est possible de contourner la logique de rate-limiting de la gateway, faisant apparaÃ®tre chaque requÃªte comme unique. Par exemple `/resetpwd?someparam=1`.

### Se connecter Ã  votre compte avant chaque tentative

Se connecter Ã  un compte avant chaque tentative, ou avant chaque sÃ©rie de tentatives, peut rÃ©initialiser le compteur de rate limit. Cela est particuliÃ¨rement utile lors du test des fonctionnalitÃ©s de login. Utiliser une Pitchfork attack dans des outils comme Burp Suite pour faire tourner les credentials toutes les quelques tentatives et en veillant Ã  ce que follow redirects soit cochÃ© peut effectivement redÃ©marrer les compteurs de rate limit.

### Utiliser des rÃ©seaux de proxies

DÃ©ployer un rÃ©seau de proxies pour rÃ©partir les requÃªtes sur plusieurs adresses IP peut contourner efficacement les IP-based rate limits. En routant le trafic via diffÃ©rents proxies, chaque requÃªte semble provenir d'une source diffÃ©rente, diminuant l'efficacitÃ© de la rate limit.

### RÃ©partir l'attaque sur diffÃ©rents comptes ou sessions

Si le systÃ¨me cible applique des rate limits par compte ou par session, rÃ©partir l'attaque ou le test sur plusieurs comptes ou sessions peut aider Ã  Ã©viter la dÃ©tection. Cette approche nÃ©cessite de gÃ©rer plusieurs identitÃ©s ou session tokens, mais peut efficacement rÃ©partir la charge pour rester dans les limites autorisÃ©es.

### Continuer d'essayer

Notez que mÃªme si un rate limit est en place, vous devriez vÃ©rifier si la rÃ©ponse est diffÃ©rente lorsque l'OTP valide est envoyÃ©. In [**this post**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), le bug hunter a dÃ©couvert que mÃªme si un rate limit est dÃ©clenchÃ© aprÃ¨s 20 tentatives infructueuses en rÃ©pondant avec 401, si la valeur valide Ã©tait envoyÃ©e une rÃ©ponse 200 a Ã©tÃ© reÃ§ue.

---

### Abusing HTTP/2 multiplexing & request pipelining (2023-2025)

Les implÃ©mentations modernes de rateâ€“limiter comptent frÃ©quemment les **TCP connections** (ou mÃªme des requÃªtes individuelles HTTP/1.1) au lieu du *number of HTTP/2 streams* qu'une connexion contient. Lorsque la mÃªme connexion TLS est rÃ©utilisÃ©e, un attaquant peut ouvrir des centaines de streams parallÃ¨les, chacun transportant une requÃªte distincte, tandis que la gateway ne dÃ©duit qu'*une* requÃªte du quota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Si le limiteur protÃ¨ge uniquement `/verify` mais pas `/api/v2/verify`, vous pouvez aussi combiner **path confusion** avec HTTP/2 multiplexing pour un brute-forcing d'OTP ou de credentials *extrÃªmement* rapide.

> ğŸ¾  **Astuce :** PortSwiggerâ€™s [Turbo Intruder](https://portswigger.net/research/turbo-intruder) prend en charge HTTP/2 et vous permet d'ajuster finement `maxConcurrentConnections` et `requestsPerConnection` pour automatiser cette attaque.

### GraphQL aliases & batched operations

GraphQL permet au client d'envoyer **plusieurs queries ou mutations logiquement indÃ©pendantes dans une seule requÃªte** en les prÃ©fixant avec des *aliases*. Parce que le serveur exÃ©cute chaque alias mais que le rate-limiter compte souvent seulement *une* requÃªte, c'est un contournement fiable du throttling pour login ou password-reset.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# â€¦ add up to dozens of aliases â€¦
}
```
Regardez la rÃ©ponse : exactement un alias renverra 200 OK lorsque le bon code est atteint, tandis que les autres sont rate-limited.

La technique a Ã©tÃ© popularisÃ©e par la recherche de PortSwigger sur â€œGraphQL batching & aliasesâ€ en 2023 et a entraÃ®nÃ© de nombreux paiements bug-bounty rÃ©cents.

### Abus des endpoints REST *batch* ou *bulk*

Certaines API exposent des helper endpoints tels que `/v2/batch` ou acceptent un **tableau d'objets** dans le corps de la requÃªte. Si le limiter est placÃ© uniquement devant les *legacy* endpoints, encapsuler plusieurs opÃ©rations dans une seule requÃªte bulk peut complÃ¨tement contourner la protection.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Synchronisation de la sliding-window

Un limiteur token-bucket ou leaky-bucket classique *se rÃ©initialise* Ã  des intervalles temporels fixes (par exemple, toutes les minutes). Si la fenÃªtre est connue (p. ex. via des messages d'erreur tels que `X-RateLimit-Reset: 27`), envoyez le nombre maximal de requÃªtes autorisÃ©es **juste avant** que le bucket ne se rÃ©initialise, puis dÃ©clenchez immÃ©diatement une autre rafale complÃ¨te.
```
|<-- 60 s window â€‘->|<-- 60 s window â€‘->|
######                 ######
```
Cette simple optimisation peut plus que doubler votre dÃ©bit sans toucher Ã  aucune autre technique de bypass.

### Passage Ã  WebSockets / gRPC streaming aprÃ¨s le handshake

Beaucoup de edge rate-limiters n'inspectent que la **requÃªte HTTP initiale**. Une fois la connexion passÃ©e Ã  WebSocket (HTTP 101) ou Ã  gRPC bidirectional streaming, les messages suivants contournent souvent les compteurs de requÃªtes par seconde parce qu'ils ne sont plus des requÃªtes HTTP distinctes. La documentation de Cloudflare note que seule la requÃªte d'upgrade initiale est soumise aux rÃ¨gles WAF/rate-limiting ; les frames envoyÃ©es ensuite sont opaques.

Flux de travail pratique:
```bash
# Flood 1,000 OTP guesses through a single WebSocket connection
seq -w 000000 000999 | websocat -n ws://target.tld/api/verify-ws

# gRPC streaming: send multiple Verify requests in one stream
grpcurl -d @ -plaintext target.tld:50051 service.VerifyOTP/Stream <<'EOF'
{ "code": "111111" }
{ "code": "222222" }
{ "code": "333333" }
EOF
```
Si le endpoint login/OTP expose Ã  la fois des variantes HTTP et WebSocket/gRPC, Ã©tablissez d'abord le canal upgradÃ©, puis envoyez plusieurs codes via cette mÃªme connexion pour contourner les per-request throttles.

### Exploiter les compteurs shardÃ©s par PoP des CDN

Certaines CDNs shardent les rate-limit counters **par data center/PoP plutÃ´t qu'Ã  l'Ã©chelle globale**. Cloudflare indique explicitement que les compteurs ne sont pas partagÃ©s entre les data centers. En routant les requÃªtes via des egress nodes dans de nombreuses rÃ©gions (residential proxy pools, anycast VPNs, or cloud VMs pinned to different continents), vous multipliez le dÃ©bit autorisÃ© : chaque PoP maintient un bucket indÃ©pendant pour la mÃªme clÃ©.

Disposition rapide et basique utilisant des open proxies (exemple avec `proxychains` + une liste tournante par pays) :
```bash
for p in $(cat proxies.txt); do
HTTPS_PROXY=$p curl -s -X POST https://target/api/login -d @payload.json &
done
wait
```
Assurez-vous que le limiter key n'est pas par compte ; sinon, faites aussi tourner les user IDs / session tokens.

---

## Outils

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Outil de fuzzing qui prend en charge header randomisation, chunked word-lists et round-robin proxy rotation.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): CrÃ©e automatiquement des endpoints AWS API Gateway jetables afin que chaque requÃªte provienne d'une adresse IP diffÃ©rente â€” parfait pour dÃ©jouer l'IP-based throttling.
- **Burp Suite â€“ IPRotate + extension**: Utilise un pool de SOCKS/HTTP proxies (ou AWS API Gateway) pour faire tourner l'adresse IP source de faÃ§on transparente lors des attaques *Intruder* et *Turbo Intruder*.
- **Turbo Intruder (BApp)**: Moteur d'attaque haute performance supportant HTTP/2 multiplexing ; ajustez `requestsPerConnection` Ã  100-1000 pour regrouper des centaines de requÃªtes dans une seule connexion.

## RÃ©fÃ©rences

- [PortSwigger Research â€“ â€œBypassing rate limits with GraphQL aliasingâ€ (2023)](https://portswigger.net/research/graphql-authorization-bypass)
- [PortSwigger Research â€“ â€œHTTP/2: The Sequel is Always Worseâ€ (connection-based throttling) (2024)](https://portswigger.net/research/http2)
- [Cloudflare Docs â€“ WebSockets & WAF applicability (2025)](https://developers.cloudflare.com/network/websockets/)
- [Cloudflare Docs â€“ Request rate calculation and PoP-local counters (2025)](https://developers.cloudflare.com/waf/rate-limiting-rules/request-rate/)

{{#include ../banners/hacktricks-training.md}}
