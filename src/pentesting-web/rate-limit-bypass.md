# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### √Ñhnliche Endpunkte erkunden

Es sollten Versuche unternommen werden, brute force attacks gegen Variationen des Zielendpunkts durchzuf√ºhren, wie `/api/v3/sign-up`, einschlie√ülich Alternativen wie `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` usw.

### Einf√ºgen von Blank-Zeichen in Code oder Parametern

Das Einf√ºgen von leeren Bytes wie `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` in Code oder Parameter kann eine n√ºtzliche Strategie sein. Zum Beispiel erlaubt das Anpassen eines Parameters zu `code=1234%0a` das Ausweiten von Versuchen durch Variationen in der Eingabe, etwa durch Hinzuf√ºgen von Newline-Zeichen zu einer E-Mail-Adresse, um Beschr√§nkungen der Versuche zu umgehen.

### Manipulation des IP-Ursprungs √ºber Header

Das Modifizieren von Headern, um die wahrgenommene IP-Herkunft zu √§ndern, kann helfen, IP-based rate limiting zu umgehen. Header wie `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, einschlie√ülich der Verwendung mehrerer Instanzen von `X-Forwarded-For`, k√∂nnen angepasst werden, um Anfragen von unterschiedlichen IPs zu simulieren.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### √Ñndern anderer Header

Es wird empfohlen, weitere Request-Header wie user-agent und cookies zu √§ndern, da diese ebenfalls zur Identifikation und Nachverfolgung von Anfrage-Mustern verwendet werden k√∂nnen. Durch das √Ñndern dieser Header l√§sst sich die Erkennung und Verfolgung der Aktivit√§ten des Anfragenden verhindern.

### Ausnutzung des Verhaltens von API Gateways

Einige API Gateways sind so konfiguriert, dass sie rate limiting basierend auf der Kombination aus Endpoint und Parametern anwenden. Durch Variieren der Parameterwerte oder Hinzuf√ºgen nicht-signifikanter Parameter zur Anfrage l√§sst sich die Rate-Limiting-Logik des Gateways umgehen, sodass jede Anfrage einzigartig erscheint. Zum Beispiel `/resetpwd?someparam=1`.

### Vor jedem Versuch in Ihr Konto einloggen

Ein Einloggen in ein Konto vor jedem Versuch oder vor jeder Versuchsreihe kann den Rate-Limit-Z√§hler zur√ºcksetzen. Das ist besonders n√ºtzlich beim Testen von Login-Funktionalit√§ten. Der Einsatz einer Pitchfork attack in Tools wie Burp Suite, um nach ein paar Versuchen die credentials zu rotieren, und das Sicherstellen, dass 'follow redirects' aktiviert ist, kann Rate-Limit-Z√§hler effektiv neu starten.

### Einsatz von Proxy-Netzwerken

Der Einsatz eines Netzwerks von Proxies, um Anfragen √ºber mehrere IP-Adressen zu verteilen, kann IP-basierte rate limits effektiv umgehen. Indem der Traffic √ºber verschiedene Proxies geleitet wird, scheint jede Anfrage von einer anderen Quelle zu stammen, wodurch die Wirksamkeit des Rate-Limits verw√§ssert wird.

### Aufteilen des Angriffs auf verschiedene Accounts oder Sessions

Wenn das Zielsystem rate limits pro Account oder pro Session anwendet, kann das Verteilen des Angriffs oder Tests auf mehrere Accounts oder Sessions helfen, eine Entdeckung zu vermeiden. Dieser Ansatz erfordert das Management mehrerer Identit√§ten oder Session-Tokens, kann aber die Last effektiv verteilen, um innerhalb der erlaubten Limits zu bleiben.

### Weitermachen

Beachte, dass du selbst bei vorhandenem rate limit pr√ºfen solltest, ob die Antwort anders ist, wenn der g√ºltige OTP gesendet wird. In [**this post**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), entdeckte der Bug-Hunter, dass selbst wenn nach 20 erfolglosen Versuchen ein rate limit ausgel√∂st wurde und mit 401 geantwortet wurde, beim Senden des g√ºltigen Codes eine 200-Antwort zur√ºckkam.

---

### Missbrauch von HTTP/2 multiplexing & request pipelining (2023-2025)

Moderne rate‚Äìlimiter-Implementierungen z√§hlen h√§ufig **TCP connections** (oder sogar einzelne HTTP/1.1 requests) anstatt der *number of HTTP/2 streams*, die eine Connection enth√§lt. Wenn dieselbe TLS connection wiederverwendet wird, kann ein Angreifer Hunderte parallele Streams √∂ffnen, wobei jeder eine separate Anfrage enth√§lt, w√§hrend das Gateway nur *einen* Request vom Kontingent abzieht.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Wenn der Limiter nur `/verify`, aber nicht `/api/v2/verify` sch√ºtzt, kannst du **path confusion** mit HTTP/2-Multiplexing kombinieren, um *extrem* schnelle OTP- oder credential brute-forcing-Angriffe durchzuf√ºhren.

> üêæ  **Tipp:** PortSwigger‚Äôs [Turbo Intruder](https://portswigger.net/research/turbo-intruder) unterst√ºtzt HTTP/2 und erm√∂glicht es dir, `maxConcurrentConnections` und `requestsPerConnection` fein abzustimmen, um diesen Angriff zu automatisieren.

### GraphQL aliases & geb√ºndelte Operationen

GraphQL erlaubt dem Client, **mehrere logisch unabh√§ngige queries oder mutations in einer einzigen request** zu senden, indem er sie mit *aliases* versieht. Da der Server jeden alias ausf√ºhrt, der rate-limiter jedoch oft nur *eine* request z√§hlt, ist dies ein zuverl√§ssiger Bypass gegen login- oder password-reset-throttling.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Sieh dir die Antwort an: genau ein alias wird 200 OK zur√ºckgeben, wenn der richtige Code abgefragt wird, w√§hrend die anderen rate-limited sind.

Die Technik wurde durch PortSwigger‚Äôs Forschung zu ‚ÄúGraphQL batching & aliases‚Äù im Jahr 2023 popularisiert und ist f√ºr viele k√ºrzliche bug-bounty payouts verantwortlich.

### Missbrauch von *batch* oder *bulk* REST-Endpunkten

Einige APIs stellen Hilfsendpunkte wie `/v2/batch` bereit oder akzeptieren einen **array of objects** im Request-Body. Wenn der limiter nur vor den *legacy* Endpunkten platziert ist, kann das B√ºndeln mehrerer Operationen in einer einzigen bulk-Anfrage den Schutz vollst√§ndig umgehen.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Timing des sliding-window

Ein klassischer token-bucket- oder leaky-bucket-Limiter wird an einer festen Zeitgrenze *zur√ºckgesetzt* (zum Beispiel jede Minute). Wenn das Fenster bekannt ist (z. B. via Fehlermeldungen wie `X-RateLimit-Reset: 27`), feuere die maximal erlaubte Anzahl an Requests **kurz bevor** der Bucket zur√ºckgesetzt wird, und feuere dann sofort einen weiteren vollen Burst.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Diese einfache Optimierung kann deinen Durchsatz mehr als verdoppeln, ohne irgendeine andere bypass technique zu ber√ºhren.

### Upgrade auf WebSockets / gRPC streaming nach dem handshake

Viele edge rate-limiters pr√ºfen nur die **initial HTTP request**. Sobald die Verbindung auf WebSocket (HTTP 101) oder gRPC bidirectional streaming umgestellt ist, umgehen nachfolgende Nachrichten h√§ufig die request-per-second counters, weil sie nicht mehr als separate HTTP requests behandelt werden. Cloudflare‚Äôs own docs weisen darauf hin, dass nur die initial upgrade request den WAF/rate-limiting rules unterliegt; frames, die danach gesendet werden, werden in der Regel nicht mehr gepr√ºft.

Praktischer Ablauf:
```bash
# Flood 1,000 OTP guesses through a single WebSocket connection
seq -w 000000 000999 | websocat -n ws://target.tld/api/verify-ws

# gRPC streaming: send multiple Verify requests in one stream
grpcurl -d @ -plaintext target.tld:50051 service.VerifyOTP/Stream <<'EOF'
{ "code": "111111" }
{ "code": "222222" }
{ "code": "333333" }
EOF
```
If the login/OTP endpoint exposes both HTTP and WebSocket/gRPC variants, establish the upgraded channel first and then spray codes within that single connection to evade per-request throttles.

### Ausnutzen von CDN PoP‚Äëgeshardeten Z√§hlern

Einige CDNs shard rate-limit counters **pro Rechenzentrum/PoP statt global**. Cloudflare gibt ausdr√ºcklich an, dass Z√§hler nicht zwischen Rechenzentren geteilt werden. Durch das Routen von Requests √ºber Egress‚ÄëKnoten in vielen Regionen (residential proxy pools, anycast VPNs oder cloud VMs, die auf verschiedene Kontinente gepinnt sind) vervielfachst du den erlaubten Durchsatz: jedes PoP pflegt einen unabh√§ngigen bucket f√ºr denselben key.

Schnelles, pragmatisches Setup mit open proxies (Beispiel mit `proxychains` + einer nach L√§ndern rotierenden Liste):
```bash
for p in $(cat proxies.txt); do
HTTPS_PROXY=$p curl -s -X POST https://target/api/login -d @payload.json &
done
wait
```
Stelle sicher, dass der Limiter-Key nicht pro Account vergeben wird; andernfalls rotiere zus√§tzlich user IDs / session tokens.

---

## Werkzeuge

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Fuzzing-Tool, das Header-Randomisierung, chunked word-lists und Round-Robin-Proxy-Rotation unterst√ºtzt.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Erzeugt automatisch disposable AWS API Gateway-Endpunkte, sodass jede Anfrage von einer anderen IP-Adresse stammt ‚Äì ideal, um IP-basiertes Throttling zu umgehen.
- **Burp Suite ‚Äì IPRotate + extension**: Verwendet einen Pool von SOCKS/HTTP-Proxys (oder AWS API Gateway), um die Quell-IP w√§hrend *Intruder*- und *Turbo Intruder*-Angriffen transparent zu rotieren.
- **Turbo Intruder (BApp)**: Hochleistungs-Angriffsmotor mit Unterst√ºtzung f√ºr HTTP/2-Multiplexing; passe `requestsPerConnection` auf 100‚Äì1000 an, um Hunderte von Requests in eine einzige Verbindung zusammenzufassen.

## Referenzen

- [PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù (2023)](https://portswigger.net/research/graphql-authorization-bypass)
- [PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (connection-based throttling) (2024)](https://portswigger.net/research/http2)
- [Cloudflare Docs ‚Äì WebSockets & WAF applicability (2025)](https://developers.cloudflare.com/network/websockets/)
- [Cloudflare Docs ‚Äì Request rate calculation and PoP-local counters (2025)](https://developers.cloudflare.com/waf/rate-limiting-rules/request-rate/)

{{#include ../banners/hacktricks-training.md}}
