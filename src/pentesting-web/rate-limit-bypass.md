# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### Exploring Similar Endpoints

Deve-se tentar realizar brute force attacks em varia√ß√µes do endpoint alvo, como `/api/v3/sign-up`, incluindo alternativas como `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` etc.

### Incorporating Blank Characters in Code or Parameters

Inserir bytes em branco como `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` em c√≥digo ou par√¢metros pode ser uma estrat√©gia √∫til. Por exemplo, ajustar um par√¢metro para `code=1234%0a` permite estender as tentativas atrav√©s de varia√ß√µes na entrada, como adicionar caracteres de nova linha a um endere√ßo de email para contornar limita√ß√µes de tentativas.

### Manipulating IP Origin via Headers

Modificar cabe√ßalhos para alterar a origem IP percebida pode ajudar a evadir rate limiting baseada em IP. Cabe√ßalhos como `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, incluindo usar m√∫ltiplas inst√¢ncias de `X-Forwarded-For`, podem ser ajustados para simular requisi√ß√µes de IPs diferentes.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Alterando Outros Cabe√ßalhos

Recomenda-se alterar outros headers de requisi√ß√£o, como user-agent e cookies, pois eles tamb√©m podem ser usados para identificar e rastrear padr√µes de requisi√ß√µes. Alterar esses headers pode impedir o reconhecimento e o rastreamento das atividades do solicitante.

### Aproveitando o Comportamento do API Gateway

Alguns API gateways s√£o configurados para aplicar limite de taxa com base na combina√ß√£o de endpoint e par√¢metros. Variando os valores dos par√¢metros ou adicionando par√¢metros sem significado √† requisi√ß√£o, √© poss√≠vel contornar a l√≥gica de limite de taxa do gateway, fazendo com que cada requisi√ß√£o pare√ßa √∫nica. Por exemplo `/resetpwd?someparam=1`.

### Entrar na Sua Conta Antes de Cada Tentativa

Entrar numa conta antes de cada tentativa, ou a cada conjunto de tentativas, pode reiniciar o contador de limite de taxa. Isso √© especialmente √∫til ao testar funcionalidades de login. Utilizar um Pitchfork attack em ferramentas como Burp Suite, para rotacionar credenciais a cada poucas tentativas e garantindo que follow redirects esteja marcado, pode efetivamente reiniciar os contadores de limite de taxa.

### Utilizando Redes de Proxy

Implantar uma rede de proxies para distribuir as requisi√ß√µes por v√°rios endere√ßos IP pode contornar efetivamente limites de taxa baseados em IP. Ao rotear o tr√°fego atrav√©s de v√°rios proxies, cada requisi√ß√£o parece se originar de uma fonte diferente, diluindo a efic√°cia do limite de taxa.

### Dividindo o Ataque entre Diferentes Contas ou Sess√µes

Se o sistema alvo aplica limites de taxa por conta ou por sess√£o, distribuir o ataque ou teste entre v√°rias contas ou sess√µes pode ajudar a evitar detec√ß√£o. Essa abordagem exige gerenciar m√∫ltiplas identidades ou tokens de sess√£o, mas pode efetivamente distribuir a carga para permanecer dentro dos limites permitidos.

### Continue Tentando

Observe que, mesmo se um limite de taxa estiver em vigor, voc√™ deve tentar ver se a resposta √© diferente quando o OTP v√°lido √© enviado. Em [**este post**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), o bug hunter descobriu que, mesmo quando um limite de taxa √© acionado ap√≥s 20 tentativas sem sucesso (retornando 401), o envio do OTP v√°lido ainda resultou em uma resposta 200.

---

### Abusing HTTP/2 multiplexing & request pipelining (2023-2025)

Implementa√ß√µes modernas de rate‚Äìlimiter frequentemente contam **TCP connections** (ou at√© mesmo requisi√ß√µes HTTP/1.1 individuais) em vez do *number of HTTP/2 streams* que uma conex√£o cont√©m. Quando a mesma conex√£o TLS √© reutilizada, um atacante pode abrir centenas de streams paralelos, cada um carregando uma requisi√ß√£o separada, enquanto o gateway somente desconta *one* request da cota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Se o limitador protege apenas `/verify` mas n√£o `/api/v2/verify`, voc√™ tamb√©m pode combinar **path confusion** com HTTP/2 multiplexing para brute-forcing de OTP ou credenciais em velocidade *extremamente* alta.

> üêæ  **Dica:** PortSwigger‚Äôs [Turbo Intruder](https://portswigger.net/research/turbo-intruder) supports HTTP/2 and lets you fine-tune `maxConcurrentConnections` and `requestsPerConnection` to automate this attack.

### GraphQL aliases & batched operations

GraphQL permite que o cliente envie **v√°rias queries ou mutations logicamente independentes em uma √∫nica requisi√ß√£o** prefixando-as com *aliases*. Como o servidor executa cada alias, mas o rate-limiter frequentemente conta apenas *uma* requisi√ß√£o, isso √© um bypass confi√°vel para throttling de login ou password-reset.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Veja a resposta: exatamente um alias retornar√° 200 OK quando o c√≥digo correto for atingido, enquanto os outros s√£o rate-limited.

A t√©cnica foi popularizada pela pesquisa da PortSwigger sobre ‚ÄúGraphQL batching & aliases‚Äù em 2023 e tem sido respons√°vel por muitos pagamentos recentes de bug-bounty.

### Abuso de *batch* ou *bulk* endpoints REST

Algumas APIs exp√µem endpoints auxiliares como `/v2/batch` ou aceitam um **array of objects** no corpo da requisi√ß√£o. Se o limiter estiver colocado apenas na frente dos endpoints *legacy*, agrupar m√∫ltiplas opera√ß√µes dentro de uma √∫nica bulk request pode contornar completamente a prote√ß√£o.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Sincronizando o sliding-window

Um limitador cl√°ssico token-bucket ou leaky-bucket *reinicia* em uma fronteira de tempo fixa (por exemplo, a cada minuto). Se a window for conhecida (por exemplo, via mensagens de erro como `X-RateLimit-Reset: 27`), dispare o n√∫mero m√°ximo permitido de requests **logo antes** do bucket reiniciar, e em seguida dispare outro burst completo.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Esta otimiza√ß√£o simples pode mais do que dobrar seu throughput sem mexer em qualquer outra t√©cnica de bypass.

### Atualizar para WebSockets / gRPC streaming ap√≥s o handshake

Muitos edge rate-limiters inspecionam apenas a **requisi√ß√£o HTTP inicial**. Depois que a conex√£o √© atualizada para WebSocket (HTTP 101) ou gRPC bidirectional streaming, mensagens subsequentes frequentemente contornam contadores de requisi√ß√µes por segundo porque n√£o s√£o mais requisi√ß√µes HTTP separadas. Os pr√≥prios docs da Cloudflare observam que somente a requisi√ß√£o inicial de upgrade est√° sujeita √†s regras do WAF/rate-limiting; frames enviados depois s√£o opacos.

Fluxo pr√°tico:
```bash
# Flood 1,000 OTP guesses through a single WebSocket connection
seq -w 000000 000999 | websocat -n ws://target.tld/api/verify-ws

# gRPC streaming: send multiple Verify requests in one stream
grpcurl -d @ -plaintext target.tld:50051 service.VerifyOTP/Stream <<'EOF'
{ "code": "111111" }
{ "code": "222222" }
{ "code": "333333" }
EOF
```
Se o login/OTP endpoint exp√µe variantes HTTP e WebSocket/gRPC, estabele√ßa primeiro o canal atualizado e ent√£o spray codes dentro dessa √∫nica conex√£o para evitar per-request throttles.

### Explorando contadores shardados por PoP de CDN

Algumas CDNs shardam contadores de rate-limit **por data center/PoP em vez de globalmente**. Cloudflare declara explicitamente que os contadores n√£o s√£o compartilhados entre data centers. Ao rotear requests atrav√©s de egress nodes em v√°rias regi√µes (residential proxy pools, anycast VPNs, ou cloud VMs fixadas em continentes diferentes), voc√™ multiplica o throughput permitido: cada PoP mant√©m um bucket independente para a mesma key.

Quick and dirty layout using open proxies (exemplo com `proxychains` + a country‚Äërotating list):
```bash
for p in $(cat proxies.txt); do
HTTPS_PROXY=$p curl -s -X POST https://target/api/login -d @payload.json &
done
wait
```
Certifique-se de que a chave do limitador n√£o seja por conta; caso contr√°rio, rotacione tamb√©m os IDs de usu√°rio / tokens de sess√£o.

---

## Ferramentas

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Ferramenta de fuzzing que suporta randomiza√ß√£o de headers, word-lists em chunks e rota√ß√£o round-robin de proxies.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Cria automaticamente endpoints descart√°veis no AWS API Gateway para que cada requisi√ß√£o se origine de um IP diferente ‚Äî perfeito para contornar limita√ß√£o baseada em IP.
- **Burp Suite ‚Äì IPRotate + extension**: Usa um pool de proxies SOCKS/HTTP (ou AWS API Gateway) para rotacionar o IP de origem de forma transparente durante ataques *Intruder* e *Turbo Intruder*.
- **Turbo Intruder (BApp)**: Motor de ataque de alto desempenho com suporte a multiplexa√ß√£o HTTP/2; ajuste `requestsPerConnection` para 100-1000 para agrupar centenas de requisi√ß√µes em uma √∫nica conex√£o.

## Refer√™ncias

- [PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù (2023)](https://portswigger.net/research/graphql-authorization-bypass)
- [PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (connection-based throttling) (2024)](https://portswigger.net/research/http2)
- [Cloudflare Docs ‚Äì WebSockets & WAF applicability (2025)](https://developers.cloudflare.com/network/websockets/)
- [Cloudflare Docs ‚Äì Request rate calculation and PoP-local counters (2025)](https://developers.cloudflare.com/waf/rate-limiting-rules/request-rate/)

{{#include ../banners/hacktricks-training.md}}
