# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### Exploring Similar Endpoints

대상 엔드포인트의 변형에 대해 무차별 공격을 시도해야 합니다. 예를 들어 `/api/v3/sign-up`와 같은 엔드포인트의 변형으로는 `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` 등이 있습니다.

### Incorporating Blank Characters in Code or Parameters

코드나 매개변수에 `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20`와 같은 빈 바이트를 삽입하는 것은 유용한 전략이 될 수 있습니다. 예를 들어, 매개변수를 `code=1234%0a`로 조정하면 입력의 변형을 통해 시도를 확장할 수 있습니다. 예를 들어, 이메일 주소에 줄 바꿈 문자를 추가하여 시도 제한을 우회할 수 있습니다.

### Manipulating IP Origin via Headers

헤더를 수정하여 인식된 IP 출처를 변경하면 IP 기반 속도 제한을 피하는 데 도움이 될 수 있습니다. `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`와 같은 헤더를 조정하여 여러 인스턴스의 `X-Forwarded-For`를 사용하여 다른 IP에서 요청을 시뮬레이션할 수 있습니다.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### 다른 헤더 변경하기

user-agent 및 쿠키와 같은 다른 요청 헤더를 변경하는 것이 권장됩니다. 이러한 헤더는 요청 패턴을 식별하고 추적하는 데 사용될 수 있습니다. 이러한 헤더를 변경하면 요청자의 활동을 인식하고 추적하는 것을 방지할 수 있습니다.

### API 게이트웨이 동작 활용하기

일부 API 게이트웨이는 엔드포인트와 매개변수의 조합에 따라 속도 제한을 적용하도록 구성되어 있습니다. 매개변수 값을 변경하거나 중요하지 않은 매개변수를 요청에 추가함으로써 게이트웨이의 속도 제한 논리를 우회할 수 있으며, 각 요청이 고유하게 보이도록 만들 수 있습니다. 예를 들어 `/resetpwd?someparam=1`.

### 각 시도 전에 계정에 로그인하기

각 시도 또는 각 시도 세트 전에 계정에 로그인하면 속도 제한 카운터가 재설정될 수 있습니다. 이는 로그인 기능을 테스트할 때 특히 유용합니다. Burp Suite와 같은 도구에서 Pitchfork 공격을 활용하여 몇 번의 시도마다 자격 증명을 회전시키고 리디렉션을 따르도록 표시하면 속도 제한 카운터를 효과적으로 재시작할 수 있습니다.

### 프록시 네트워크 활용하기

여러 IP 주소에 요청을 분산시키기 위해 프록시 네트워크를 배포하면 IP 기반 속도 제한을 효과적으로 우회할 수 있습니다. 다양한 프록시를 통해 트래픽을 라우팅하면 각 요청이 다른 출처에서 발생하는 것처럼 보이므로 속도 제한의 효과가 희석됩니다.

### 다른 계정이나 세션에 공격 분산하기

대상 시스템이 계정별 또는 세션별로 속도 제한을 적용하는 경우, 여러 계정이나 세션에 공격 또는 테스트를 분산시키면 탐지를 피하는 데 도움이 될 수 있습니다. 이 접근 방식은 여러 신원 또는 세션 토큰을 관리해야 하지만, 허용 가능한 한도 내에서 부하를 효과적으로 분산시킬 수 있습니다.

### 계속 시도하기

속도 제한이 설정되어 있더라도 유효한 OTP가 전송될 때 응답이 다른지 확인해 보아야 합니다. [**이 게시물**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732)에서 버그 헌터는 20번의 실패한 시도 후 401로 응답하더라도 속도 제한이 발생하더라도 유효한 OTP가 전송되면 200 응답을 받았다는 것을 발견했습니다.

---

### HTTP/2 다중화 및 요청 파이프라이닝 남용하기 (2023-2025)

현대의 속도 제한기 구현은 종종 **TCP 연결**(또는 개별 HTTP/1.1 요청)을 계산하는 대신 연결이 포함하는 *HTTP/2 스트림 수*를 계산합니다. 동일한 TLS 연결이 재사용될 때, 공격자는 수백 개의 병렬 스트림을 열 수 있으며, 각 스트림은 별도의 요청을 전달하지만 게이트웨이는 할당량에서 *하나*의 요청만 차감합니다.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
If the limiter protects only `/verify` but not `/api/v2/verify`, you can also combine **path confusion** with HTTP/2 multiplexing for *extremely* high-speed OTP or credential brute-forcing.

> 🐾  **Tip:** PortSwigger’s [Turbo Intruder](https://portswigger.net/research/turbo-intruder) supports HTTP/2 and lets you fine-tune `maxConcurrentConnections` and `requestsPerConnection` to automate this attack.

### GraphQL aliases & batched operations

GraphQL은 클라이언트가 **하나의 요청에서 여러 개의 논리적으로 독립적인 쿼리 또는 변이를 전송할 수 있도록** *별칭*으로 접두사를 붙입니다. 서버는 모든 별칭을 실행하지만 속도 제한기는 종종 *하나*의 요청만 계산하기 때문에, 이는 로그인 또는 비밀번호 재설정 속도 제한을 우회하는 신뢰할 수 있는 방법입니다.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# … add up to dozens of aliases …
}
```
정확히 하나의 별칭만이 올바른 코드가 호출될 때 200 OK를 반환하며, 나머지는 속도 제한이 있습니다.

이 기술은 2023년 PortSwigger의 “GraphQL batching & aliases” 연구에 의해 대중화되었으며, 최근 많은 버그 바운티 지급의 원인이 되었습니다.

### *배치* 또는 *대량* REST 엔드포인트의 남용

일부 API는 `/v2/batch`와 같은 도우미 엔드포인트를 노출하거나 요청 본문에서 **객체 배열**을 수락합니다. 제한기가 *구식* 엔드포인트 앞에만 배치된 경우, 여러 작업을 단일 대량 요청으로 감싸면 보호를 완전히 우회할 수 있습니다.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### 타이밍 슬라이딩 윈도우

클래식 토큰-버킷 또는 리키-버킷 리미터는 *리셋*이 고정된 시간 경계에서 발생합니다 (예: 매 분마다). 윈도우가 알려져 있다면 (예: `X-RateLimit-Reset: 27`와 같은 오류 메시지를 통해), 버킷이 리셋되기 **직전**에 허용된 최대 요청 수를 발사한 다음, 즉시 또 다른 전체 폭발을 발사합니다.
```
|<-- 60 s window ‑->|<-- 60 s window ‑->|
######                 ######
```
이 간단한 최적화는 다른 우회 기술을 건드리지 않고도 처리량을 두 배 이상 늘릴 수 있습니다.

---

## 도구

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): 헤더 무작위화, 청크 단어 목록 및 라운드 로빈 프록시 회전을 지원하는 퍼징 도구입니다.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): 모든 요청이 다른 IP 주소에서 시작되도록 일회용 AWS API Gateway 엔드포인트를 자동으로 생성합니다 – IP 기반 속도 제한을 무력화하는 데 완벽합니다.
- **Burp Suite – IPRotate + 확장**: *Intruder* 및 *Turbo Intruder* 공격 중에 소스 IP를 투명하게 회전시키기 위해 SOCKS/HTTP 프록시(또는 AWS API Gateway) 풀을 사용합니다.
- **Turbo Intruder (BApp)**: HTTP/2 다중화를 지원하는 고성능 공격 엔진; 수백 개의 요청을 단일 연결로 축소하기 위해 `requestsPerConnection`을 100-1000으로 조정합니다.

## 참고문헌

- PortSwigger Research – “GraphQL 별칭을 사용한 속도 제한 우회” (2023)  <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research – “HTTP/2: 속편은 항상 더 나쁘다” (섹션 *연결 기반 속도 제한*) (2024)  <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
