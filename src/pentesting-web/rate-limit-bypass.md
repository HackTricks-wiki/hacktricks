# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### Exploring Similar Endpoints

Hedeflenen uç noktanın varyasyonlarına, örneğin `/api/v3/sign-up`, `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` gibi alternatiflere karşı brute force saldırıları gerçekleştirmek için denemeler yapılmalıdır.

### Incorporating Blank Characters in Code or Parameters

Kod veya parametrelere `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` gibi boş baytlar eklemek faydalı bir strateji olabilir. Örneğin, bir parametreyi `code=1234%0a` olarak ayarlamak, girişteki varyasyonlar aracılığıyla deneme süresini uzatmaya olanak tanır; bu, bir e-posta adresine yeni satır karakterleri ekleyerek deneme sınırlamalarını aşmayı sağlar.

### Manipulating IP Origin via Headers

Algılanan IP kökenini değiştirmek için başlıkları değiştirmek, IP tabanlı hız sınırlamasından kaçınmaya yardımcı olabilir. `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host` gibi başlıklar, farklı IP'lerden gelen istekleri simüle etmek için birden fazla `X-Forwarded-For` örneği kullanarak ayarlanabilir.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Diğer Başlıkları Değiştirme

Kullanıcı ajanı ve çerezler gibi diğer istek başlıklarını değiştirmek önerilir, çünkü bunlar da istek kalıplarını tanımlamak ve takip etmek için kullanılabilir. Bu başlıkların değiştirilmesi, talep edenin faaliyetlerinin tanınmasını ve izlenmesini önleyebilir.

### API Gateway Davranışını Kullanma

Bazı API geçitleri, uç nokta ve parametrelerin kombinasyonuna dayalı olarak oran sınırlaması uygulamak için yapılandırılmıştır. Parametre değerlerini değiştirerek veya isteğe önemsiz parametreler ekleyerek, geçidin oran sınırlama mantığını aşmak mümkün olabilir, böylece her istek benzersiz görünür. Örneğin `/resetpwd?someparam=1`.

### Her Denemeden Önce Hesabınıza Giriş Yapma

Her denemeden veya her deneme setinden önce bir hesaba giriş yapmak, oran sınırlama sayacını sıfırlayabilir. Bu, özellikle giriş işlevselliklerini test ederken faydalıdır. Burp Suite gibi araçlarda, her birkaç denemeden sonra kimlik bilgilerini döndürmek ve yönlendirmelerin işaretlendiğinden emin olmak için bir Pitchfork saldırısı kullanmak, oran sınırlama sayaçlarını etkili bir şekilde yeniden başlatabilir.

### Proxy Ağlarını Kullanma

İstekleri birden fazla IP adresi arasında dağıtmak için bir proxy ağı dağıtmak, IP tabanlı oran sınırlamalarını etkili bir şekilde aşabilir. Trafiği çeşitli proxyler aracılığıyla yönlendirerek, her istek farklı bir kaynaktan geliyormuş gibi görünür, bu da oran sınırlamasının etkinliğini azaltır.

### Saldırıyı Farklı Hesaplar veya Oturumlar Arasında Bölme

Hedef sistem, oran sınırlamalarını hesap başına veya oturum başına uyguluyorsa, saldırıyı veya testi birden fazla hesap veya oturum arasında dağıtmak, tespiti önlemeye yardımcı olabilir. Bu yaklaşım, birden fazla kimlik veya oturum belirteci yönetmeyi gerektirir, ancak yükü izin verilen sınırlar içinde dağıtmak için etkili olabilir.

### Denemeye Devam Edin

Bir oran sınırlaması olsa bile, geçerli OTP gönderildiğinde yanıtın farklı olup olmadığını görmek için denemeye devam etmelisiniz. [**bu yazıda**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), hata avcısı, 20 başarısız denemeden sonra 401 ile yanıt verildiğinde bir oran sınırlamasının tetiklendiğini keşfetti, ancak geçerli olan gönderildiğinde 200 yanıtı alındı.

---

### HTTP/2 çoklama ve istek boru hattı istismar etme (2023-2025)

Modern oran sınırlayıcı uygulamaları genellikle **TCP bağlantılarını** (veya hatta bireysel HTTP/1.1 isteklerini) sayar, bir bağlantının içerdiği *HTTP/2 akışlarının sayısı* yerine. Aynı TLS bağlantısı yeniden kullanıldığında, bir saldırgan yüzlerce paralel akış açabilir, her biri ayrı bir isteği taşırken, geçit yalnızca *bir* isteği kotalardan düşer.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Eğer sınırlayıcı yalnızca `/verify`'yi koruyorsa ancak `/api/v2/verify`'yi korumuyorsa, **path confusion**'ı HTTP/2 çoklama ile birleştirerek *son derece* yüksek hızlı OTP veya kimlik bilgisi brute-forcing yapabilirsiniz.

> 🐾  **İpucu:** PortSwigger’in [Turbo Intruder](https://portswigger.net/research/turbo-intruder) HTTP/2'yi destekler ve bu saldırıyı otomatikleştirmek için `maxConcurrentConnections` ve `requestsPerConnection` değerlerini ince ayar yapmanıza olanak tanır.

### GraphQL takma adları ve toplu işlemler

GraphQL, istemcinin **bir istekte birden fazla mantıksal olarak bağımsız sorgu veya mutasyon göndermesine** olanak tanır; bunları *takma adlar* ile öne alarak. Sunucu her takma adı yürütse de, sınırlayıcı genellikle yalnızca *bir* isteği saydığından, bu, giriş veya şifre sıfırlama kısıtlaması için güvenilir bir geçiştir.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# … add up to dozens of aliases …
}
```
Bakın, doğru kod gönderildiğinde tam olarak bir takma ad 200 OK dönecek, diğerleri ise hız sınırlı olacak.

Bu teknik, 2023'te PortSwigger'ın “GraphQL batching & aliases” konusundaki araştırmasıyla popüler hale geldi ve birçok son zamanlardaki bug-bounty ödemelerinin sorumlusu oldu.

### *Batch* veya *bulk* REST uç noktalarının kötüye kullanımı

Bazı API'ler, `/v2/batch` gibi yardımcı uç noktaları açar veya istek gövdesinde bir **nesne dizisi** kabul eder. Eğer sınırlayıcı yalnızca *legacy* uç noktalarının önünde yer alıyorsa, birden fazla işlemi tek bir toplu isteğin içine sarmak korumayı tamamen atlayabilir.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Kaydırmalı Pencereyi Zamanlama

Klasik bir token-bucket veya sızıntılı-bucket sınırlayıcı, sabit bir zaman sınırında *sıfırlanır* (örneğin, her dakika). Pencere biliniyorsa (örneğin, `X-RateLimit-Reset: 27` gibi hata mesajları aracılığıyla), bucket sıfırlanmadan **hemen önce** izin verilen maksimum sayıda isteği gönderin, ardından hemen başka bir tam patlama yapın.
```
|<-- 60 s window ‑->|<-- 60 s window ‑->|
######                 ######
```
Bu basit optimizasyon, başka herhangi bir bypass tekniğine dokunmadan, verimliliğinizi iki katından fazla artırabilir.

---

## Araçlar

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Başlık rastgeleleştirmeyi, parçalı kelime listelerini ve yuvarlak-rota proxy döngüsünü destekleyen fuzzing aracı.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Her isteğin farklı bir IP adresinden gelmesini sağlamak için otomatik olarak harcanabilir AWS API Gateway uç noktaları oluşturur – IP tabanlı kısıtlamaları aşmak için mükemmel.
- **Burp Suite – IPRotate + uzantı**: *Intruder* ve *Turbo Intruder* saldırıları sırasında kaynak IP'yi şeffaf bir şekilde döndürmek için bir SOCKS/HTTP proxy havuzu (veya AWS API Gateway) kullanır.
- **Turbo Intruder (BApp)**: HTTP/2 çoklama desteği olan yüksek performanslı saldırı motoru; yüzlerce isteği tek bir bağlantıda birleştirmek için `requestsPerConnection` değerini 100-1000 olarak ayarlayın.

## Referanslar

- PortSwigger Research – “GraphQL aliasing ile rate limit aşma” (2023)  <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research – “HTTP/2: Devamı Her Zaman Daha Kötüdür” (bölüm *Bağlantı tabanlı kısıtlama*) (2024)  <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
