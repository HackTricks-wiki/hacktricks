# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Techniken zum Umgehen von Ratenbegrenzungen

### Erforschen √§hnlicher Endpunkte

Es sollten Versuche unternommen werden, Brute-Force-Angriffe auf Variationen des angestrebten Endpunkts durchzuf√ºhren, wie z.B. `/api/v3/sign-up`, einschlie√ülich Alternativen wie `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up` usw.

### Einf√ºgen von Leerzeichen in Code oder Parameter

Das Einf√ºgen von Leerbytes wie `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` in Code oder Parameter kann eine n√ºtzliche Strategie sein. Zum Beispiel erm√∂glicht die Anpassung eines Parameters auf `code=1234%0a` das Erweitern von Versuchen durch Variationen in der Eingabe, wie das Hinzuf√ºgen von Zeilenumbr√ºchen zu einer E-Mail-Adresse, um Versuchsbeschr√§nkungen zu umgehen.

### Manipulation des IP-Ursprungs √ºber Header

Das √Ñndern von Headern, um den wahrgenommenen IP-Ursprung zu ver√§ndern, kann helfen, IP-basierte Ratenbegrenzungen zu umgehen. Header wie `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, einschlie√ülich der Verwendung mehrerer Instanzen von `X-Forwarded-For`, k√∂nnen angepasst werden, um Anfragen von verschiedenen IPs zu simulieren.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### √Ñndern anderer Header

Es wird empfohlen, andere Anfrage-Header wie den User-Agent und Cookies zu √§ndern, da diese ebenfalls zur Identifizierung und Verfolgung von Anfrage-Mustern verwendet werden k√∂nnen. Das √Ñndern dieser Header kann die Erkennung und Verfolgung der Aktivit√§ten des Anfragenden verhindern.

### Ausnutzen des Verhaltens von API-Gateways

Einige API-Gateways sind so konfiguriert, dass sie die Ratenbegrenzung basierend auf der Kombination von Endpunkt und Parametern anwenden. Durch Variieren der Parameterwerte oder Hinzuf√ºgen von unwesentlichen Parametern zur Anfrage ist es m√∂glich, die Ratenbegrenzungslogik des Gateways zu umgehen, sodass jede Anfrage einzigartig erscheint. Zum Beispiel `/resetpwd?someparam=1`.

### Anmeldung in Ihrem Konto vor jedem Versuch

Die Anmeldung in einem Konto vor jedem Versuch oder jeder Versuchsreihe k√∂nnte den Z√§hler f√ºr die Ratenbegrenzung zur√ºcksetzen. Dies ist besonders n√ºtzlich, wenn Login-Funktionalit√§ten getestet werden. Die Nutzung eines Pitchfork-Angriffs in Tools wie Burp Suite, um die Anmeldeinformationen alle paar Versuche zu rotieren und sicherzustellen, dass Weiterleitungen markiert sind, kann die Z√§hler f√ºr die Ratenbegrenzung effektiv zur√ºcksetzen.

### Nutzung von Proxy-Netzwerken

Der Einsatz eines Netzwerks von Proxys zur Verteilung der Anfragen √ºber mehrere IP-Adressen kann IP-basierte Ratenbegrenzungen effektiv umgehen. Durch das Routen des Verkehrs √ºber verschiedene Proxys scheint jede Anfrage von einer anderen Quelle zu stammen, wodurch die Effektivit√§t der Ratenbegrenzung verringert wird.

### Aufteilen des Angriffs √ºber verschiedene Konten oder Sitzungen

Wenn das Zielsystem Ratenbegrenzungen auf Basis von Konto oder Sitzung anwendet, kann das Verteilen des Angriffs oder Tests √ºber mehrere Konten oder Sitzungen helfen, eine Erkennung zu vermeiden. Dieser Ansatz erfordert die Verwaltung mehrerer Identit√§ten oder Sitzungstoken, kann jedoch die Last effektiv verteilen, um innerhalb der zul√§ssigen Grenzen zu bleiben.

### Weiter versuchen

Beachten Sie, dass Sie auch dann versuchen sollten, zu sehen, ob die Antwort unterschiedlich ist, wenn die g√ºltige OTP gesendet wird, selbst wenn eine Ratenbegrenzung besteht. In [**diesem Beitrag**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732) entdeckte der Bug-J√§ger, dass selbst wenn eine Ratenbegrenzung nach 20 erfolglosen Versuchen durch eine Antwort mit 401 ausgel√∂st wird, eine 200-Antwort empfangen wurde, wenn die g√ºltige gesendet wurde.

---

### Missbrauch von HTTP/2-Multiplexing & Anfrage-Pipelining (2023-2025)

Moderne Implementierungen von Ratenbegrenzern z√§hlen h√§ufig **TCP-Verbindungen** (oder sogar einzelne HTTP/1.1-Anfragen) anstelle der *Anzahl der HTTP/2-Streams*, die eine Verbindung enth√§lt. Wenn dieselbe TLS-Verbindung wiederverwendet wird, kann ein Angreifer Hunderte paralleler Streams √∂ffnen, von denen jeder eine separate Anfrage tr√§gt, w√§hrend das Gateway nur *eine* Anfrage vom Kontingent abzieht.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Wenn der Limiter nur `/verify` sch√ºtzt, aber nicht `/api/v2/verify`, k√∂nnen Sie auch **Path-Verwirrung** mit HTTP/2-Multiplexing f√ºr *extrem* schnelle OTP- oder Anmeldeinformationen-Brute-Forcing kombinieren.

> üêæ  **Tipp:** PortSwigger‚Äôs [Turbo Intruder](https://portswigger.net/research/turbo-intruder) unterst√ºtzt HTTP/2 und erm√∂glicht es Ihnen, `maxConcurrentConnections` und `requestsPerConnection` fein abzustimmen, um diesen Angriff zu automatisieren.

### GraphQL-Alias und geb√ºndelte Operationen

GraphQL erm√∂glicht es dem Client, **mehrere logisch unabh√§ngige Abfragen oder Mutationen in einer einzigen Anfrage** zu senden, indem sie mit *Alias* vorangestellt werden. Da der Server jeden Alias ausf√ºhrt, der Rate-Limiter jedoch oft nur *eine* Anfrage z√§hlt, ist dies ein zuverl√§ssiger Umgehungsmechanismus f√ºr das Drosseln von Anmeldungen oder Passwortzur√ºcksetzungen.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Schau dir die Antwort an: genau ein Alias wird 200 OK zur√ºckgeben, wenn der korrekte Code getroffen wird, w√§hrend die anderen einer Rate-Limitierung unterliegen.

Die Technik wurde durch die Forschung von PortSwigger zu ‚ÄûGraphQL-Batching & Aliases‚Äú im Jahr 2023 popul√§r und war verantwortlich f√ºr viele k√ºrzliche Bug-Bounty-Auszahlungen.

### Missbrauch von *Batch* oder *Bulk* REST-Endpunkten

Einige APIs bieten Hilfsendpunkte wie `/v2/batch` an oder akzeptieren ein **Array von Objekten** im Anfragek√∂rper. Wenn der Limiter nur vor den *Legacy*-Endpunkten platziert ist, kann das Einpacken mehrerer Operationen in eine einzige Bulk-Anfrage den Schutz vollst√§ndig umgehen.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Timing the sliding-window

Ein klassischer Token-Bucket- oder Leaky-Bucket-Limiter *setzt zur√ºck* an einer festen Zeitgrenze (zum Beispiel jede Minute). Wenn das Zeitfenster bekannt ist (z. B. durch Fehlermeldungen wie `X-RateLimit-Reset: 27`), sende die maximal erlaubte Anzahl von Anfragen **kurz bevor** der Bucket zur√ºckgesetzt wird, und sende dann sofort einen weiteren vollen Burst.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Diese einfache Optimierung kann Ihre Durchsatzrate mehr als verdoppeln, ohne andere Bypass-Techniken zu ber√ºhren.

---

## Tools

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Fuzzing-Tool, das Header-Randomisierung, chunked Wortlisten und Round-Robin-Proxy-Rotation unterst√ºtzt.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Erstellt automatisch disposable AWS API Gateway-Endpunkte, sodass jede Anfrage von einer anderen IP-Adresse stammt ‚Äì perfekt, um IP-basiertes Drosseln zu √ºberwinden.
- **Burp Suite ‚Äì IPRotate + Erweiterung**: Verwendet einen Pool von SOCKS/HTTP-Proxys (oder AWS API Gateway), um die Quell-IP w√§hrend *Intruder* und *Turbo Intruder* Angriffe transparent zu rotieren.
- **Turbo Intruder (BApp)**: Hochleistungsangriffs-Engine, die HTTP/2-Multiplexing unterst√ºtzt; stellen Sie `requestsPerConnection` auf 100-1000 ein, um Hunderte von Anfragen in einer einzigen Verbindung zusammenzufassen.

## References

- PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù  (2023)  <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (Abschnitt *Connection-based throttling*) (2024)  <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
