# Rate Limit Bypass

{{#include ../banners/hacktricks-training.md}}

## Rate limit bypass techniques

### Exploring Similar Endpoints

Se deben intentar ataques de fuerza bruta en variaciones del endpoint objetivo, como `/api/v3/sign-up`, incluyendo alternativas como `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up`, etc.

### Incorporating Blank Characters in Code or Parameters

Insertar bytes en blanco como `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` en c√≥digo o par√°metros puede ser una estrategia √∫til. Por ejemplo, ajustar un par√°metro a `code=1234%0a` permite extender los intentos mediante variaciones en la entrada, como a√±adir caracteres de nueva l√≠nea a una direcci√≥n de email para eludir las limitaciones de intentos.

### Manipulating IP Origin via Headers

Modificar los headers para alterar el origen IP percibido puede ayudar a evadir el rate limiting basado en IP. Headers como `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, incluyendo el uso de m√∫ltiples instancias de `X-Forwarded-For`, pueden ajustarse para simular solicitudes desde diferentes IPs.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Cambiar otros encabezados

Se recomienda alterar otros encabezados de la solicitud, como el user-agent y las cookies, ya que tambi√©n pueden usarse para identificar y rastrear patrones de peticiones. Cambiar estos encabezados puede evitar el reconocimiento y el seguimiento de las actividades del solicitante.

### Aprovechar el comportamiento de API gateways

Algunas pasarelas de API est√°n configuradas para aplicar rate limiting bas√°ndose en la combinaci√≥n de endpoint y par√°metros. Variando los valores de los par√°metros o a√±adiendo par√°metros no significativos a la solicitud, es posible eludir la l√≥gica de rate-limiting de la pasarela, haciendo que cada petici√≥n parezca √∫nica. Por ejemplo `/resetpwd?someparam=1`.

### Iniciar sesi√≥n en tu cuenta antes de cada intento

Iniciar sesi√≥n en una cuenta antes de cada intento, o antes de cada conjunto de intentos, puede reiniciar el contador de rate limit. Esto es especialmente √∫til al testear funcionalidades de login. Utilizar un Pitchfork attack en herramientas como Burp Suite, para rotar credenciales cada pocos intentos y asegurarse de marcar 'follow redirects', puede reiniciar eficazmente los contadores de rate limit.

### Utilizar redes de proxies

Desplegar una red de proxies para distribuir las solicitudes entre m√∫ltiples direcciones IP puede eludir eficazmente los rate limits basados en IP. Al enrutar el tr√°fico a trav√©s de distintos proxies, cada petici√≥n aparenta originarse desde una fuente diferente, diluyendo la eficacia del rate limit.

### Dividir el ataque entre diferentes cuentas o sesiones

Si el sistema objetivo aplica rate limits por cuenta o por sesi√≥n, distribuir el ataque o la prueba entre m√∫ltiples cuentas o sesiones puede ayudar a evitar la detecci√≥n. Este enfoque requiere gestionar m√∫ltiples identidades o tokens de sesi√≥n, pero puede distribuir eficazmente la carga para mantenerse dentro de los l√≠mites permitidos.

### Seguir intent√°ndolo

Ten en cuenta que incluso si hay un rate limit en vigor, deber√≠as intentar comprobar si la respuesta es diferente cuando se env√≠a el OTP v√°lido. En [**esta publicaci√≥n**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), el bug hunter descubri√≥ que incluso si se desencadena un rate limit despu√©s de 20 intentos fallidos respondiendo con 401, si se enviaba el v√°lido se recib√≠a una respuesta 200.

---

### Abusar de HTTP/2 multiplexing & request pipelining (2023-2025)

Las implementaciones modernas de rate‚Äìlimiter frecuentemente cuentan **TCP connections** (or even individual HTTP/1.1 requests) en lugar del *number of HTTP/2 streams* que contiene una conexi√≥n. Cuando se reutiliza la misma conexi√≥n TLS, un atacante puede abrir cientos de streams paralelos, cada uno llevando una solicitud separada, mientras que la gateway solo descuenta *one* request de la cuota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Si el limitador protege solo `/verify` pero no `/api/v2/verify`, tambi√©n puedes combinar **path confusion** con HTTP/2 multiplexing para un brute-forcing de OTP o credenciales a velocidad *extremadamente* alta.

> üêæ  **Consejo:** PortSwigger‚Äôs [Turbo Intruder](https://portswigger.net/research/turbo-intruder) soporta HTTP/2 y te permite ajustar `maxConcurrentConnections` y `requestsPerConnection` para automatizar este ataque.

### GraphQL aliases y operaciones por lotes

GraphQL permite al cliente enviar **varias consultas o mutaciones l√≥gicamente independientes en una sola solicitud** prefij√°ndolas con *aliases*. Dado que el servidor ejecuta cada alias pero el limitador suele contar solo *una* solicitud, esto es un bypass fiable para la limitaci√≥n de intentos en login o restablecimiento de contrase√±a.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# ‚Ä¶ add up to dozens of aliases ‚Ä¶
}
```
Observa la respuesta: exactamente un alias devolver√° 200 OK cuando se acierte el c√≥digo correcto, mientras que los dem√°s est√°n rate-limited.

La t√©cnica fue popularizada por la investigaci√≥n de PortSwigger sobre ‚ÄúGraphQL batching & aliases‚Äù en 2023 y ha sido responsable de muchos pagos recientes de bug-bounty.

### Abuso de *batch* o *bulk* REST endpoints

Algunas APIs exponen endpoints auxiliares como `/v2/batch` o aceptan un **array of objects** en el cuerpo de la petici√≥n. Si el limitador se coloca solo frente a los endpoints *legacy*, agrupar m√∫ltiples operaciones dentro de una √∫nica solicitud bulk puede eludir por completo la protecci√≥n.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### Timing the sliding-window

Un limitador cl√°sico token-bucket o leaky-bucket *resets* en un l√≠mite de tiempo fijo (por ejemplo, cada minuto). Si se conoce la ventana (p. ej., mediante mensajes de error como `X-RateLimit-Reset: 27`), env√≠a el n√∫mero m√°ximo permitido de requests **justo antes** de que el bucket se reinicie y, acto seguido, lanza otra r√°faga completa.
```
|<-- 60 s window ‚Äë->|<-- 60 s window ‚Äë->|
######                 ######
```
Esta simple optimizaci√≥n puede m√°s que duplicar tu rendimiento sin tocar ninguna otra t√©cnica de bypass.

### Actualizar a WebSockets / gRPC streaming despu√©s del handshake

Muchos rate-limiters en el edge solo inspeccionan la **solicitud HTTP inicial**. Una vez que la conexi√≥n se actualiza a WebSocket (HTTP 101) o a gRPC bidirectional streaming, los mensajes posteriores a menudo evaden los contadores de request-per-second porque ya no son solicitudes HTTP separadas. La propia documentaci√≥n de Cloudflare se√±ala que solo la solicitud de upgrade inicial est√° sujeta a las reglas de WAF/rate-limiting; los frames enviados despu√©s son opacos.

Flujo de trabajo pr√°ctico:
```bash
# Flood 1,000 OTP guesses through a single WebSocket connection
seq -w 000000 000999 | websocat -n ws://target.tld/api/verify-ws

# gRPC streaming: send multiple Verify requests in one stream
grpcurl -d @ -plaintext target.tld:50051 service.VerifyOTP/Stream <<'EOF'
{ "code": "111111" }
{ "code": "222222" }
{ "code": "333333" }
EOF
```
Si el endpoint de login/OTP expone tanto variantes HTTP como WebSocket/gRPC, establece primero el canal actualizado y luego spray codes dentro de esa √∫nica conexi√≥n para evadir los per-request throttles.

### Explotando contadores PoP‚Äësharded de CDN

Algunas CDNs fragmentan los contadores de rate-limit **por data center/PoP en lugar de globalmente**. Cloudflare indica expl√≠citamente que los contadores no se comparten entre data centers. Al enrutar peticiones a trav√©s de nodos de egress en muchas regiones (residential proxy pools, anycast VPNs, o cloud VMs asignadas a distintos continentes), multiplicas el throughput permitido: cada PoP mantiene un bucket independiente para la misma key.

Quick and dirty layout using open proxies (example with `proxychains` + a country‚Äërotating list):
```bash
for p in $(cat proxies.txt); do
HTTPS_PROXY=$p curl -s -X POST https://target/api/login -d @payload.json &
done
wait
```
Aseg√∫rate de que la clave del limitador no sea por cuenta; de lo contrario rota tambi√©n los IDs de usuario / tokens de sesi√≥n.

---

## Herramientas

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz): Herramienta de fuzzing que soporta la aleatorizaci√≥n de headers, listas de palabras por fragmentos y rotaci√≥n round-robin de proxies.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox): Crea autom√°ticamente endpoints desechables en AWS API Gateway para que cada petici√≥n se origine desde una IP diferente ‚Äî perfecto para derrotar la limitaci√≥n basada en IP.
- **Burp Suite ‚Äì IPRotate + extension**: Usa un conjunto de proxies SOCKS/HTTP (o AWS API Gateway) para rotar la IP de origen de forma transparente durante ataques *Intruder* y *Turbo Intruder*.
- **Turbo Intruder (BApp)**: Motor de ataque de alto rendimiento que soporta multiplexaci√≥n HTTP/2; ajusta `requestsPerConnection` a 100-1000 para colapsar cientos de peticiones en una sola conexi√≥n.

## Referencias

- [PortSwigger Research ‚Äì ‚ÄúBypassing rate limits with GraphQL aliasing‚Äù (2023)](https://portswigger.net/research/graphql-authorization-bypass)
- [PortSwigger Research ‚Äì ‚ÄúHTTP/2: The Sequel is Always Worse‚Äù (connection-based throttling) (2024)](https://portswigger.net/research/http2)
- [Cloudflare Docs ‚Äì WebSockets & WAF applicability (2025)](https://developers.cloudflare.com/network/websockets/)
- [Cloudflare Docs ‚Äì Request rate calculation and PoP-local counters (2025)](https://developers.cloudflare.com/waf/rate-limiting-rules/request-rate/)

{{#include ../banners/hacktricks-training.md}}
