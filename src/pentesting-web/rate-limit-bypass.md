# Contournement de la Limite de Taux

{{#include ../banners/hacktricks-training.md}}

## Techniques de contournement de la limite de taux

### Exploration des Points de Terminaison Similaires

Des tentatives devraient Ãªtre faites pour effectuer des attaques par force brute sur des variations du point de terminaison ciblÃ©, comme `/api/v3/sign-up`, y compris des alternatives comme `/Sing-up`, `/SignUp`, `/singup`, `/api/v1/sign-up`, `/api/sign-up`, etc.

### Incorporation de CaractÃ¨res Vides dans le Code ou les ParamÃ¨tres

L'insertion de bytes vides comme `%00`, `%0d%0a`, `%0d`, `%0a`, `%09`, `%0C`, `%20` dans le code ou les paramÃ¨tres peut Ãªtre une stratÃ©gie utile. Par exemple, ajuster un paramÃ¨tre Ã  `code=1234%0a` permet d'Ã©tendre les tentatives Ã  travers des variations d'entrÃ©e, comme l'ajout de caractÃ¨res de nouvelle ligne Ã  une adresse e-mail pour contourner les limitations de tentatives.

### Manipulation de l'Origine IP via les En-tÃªtes

Modifier les en-tÃªtes pour altÃ©rer l'origine IP perÃ§ue peut aider Ã  Ã©chapper Ã  la limitation de taux basÃ©e sur l'IP. Des en-tÃªtes tels que `X-Originating-IP`, `X-Forwarded-For`, `X-Remote-IP`, `X-Remote-Addr`, `X-Client-IP`, `X-Host`, `X-Forwared-Host`, y compris l'utilisation de plusieurs instances de `X-Forwarded-For`, peuvent Ãªtre ajustÃ©s pour simuler des requÃªtes provenant de diffÃ©rentes IP.
```bash
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwared-Host: 127.0.0.1

# Double X-Forwarded-For header example
X-Forwarded-For:
X-Forwarded-For: 127.0.0.1
```
### Changer d'autres en-tÃªtes

Il est recommandÃ© de modifier d'autres en-tÃªtes de requÃªte tels que l'agent utilisateur et les cookies, car ceux-ci peuvent Ã©galement Ãªtre utilisÃ©s pour identifier et suivre les modÃ¨les de requÃªtes. Changer ces en-tÃªtes peut empÃªcher la reconnaissance et le suivi des activitÃ©s du demandeur.

### Tirer parti du comportement de la passerelle API

Certaines passerelles API sont configurÃ©es pour appliquer des limites de taux en fonction de la combinaison de l'endpoint et des paramÃ¨tres. En variant les valeurs des paramÃ¨tres ou en ajoutant des paramÃ¨tres non significatifs Ã  la requÃªte, il est possible de contourner la logique de limitation de taux de la passerelle, rendant chaque requÃªte unique. Par exemple `/resetpwd?someparam=1`.

### Se connecter Ã  votre compte avant chaque tentative

Se connecter Ã  un compte avant chaque tentative, ou chaque ensemble de tentatives, peut rÃ©initialiser le compteur de limite de taux. Cela est particuliÃ¨rement utile lors des tests de fonctionnalitÃ©s de connexion. Utiliser une attaque Pitchfork dans des outils comme Burp Suite, pour faire tourner les identifiants toutes les quelques tentatives et s'assurer que les redirections sont marquÃ©es, peut efficacement redÃ©marrer les compteurs de limite de taux.

### Utiliser des rÃ©seaux de proxy

DÃ©ployer un rÃ©seau de proxies pour distribuer les requÃªtes sur plusieurs adresses IP peut contourner efficacement les limites de taux basÃ©es sur l'IP. En acheminant le trafic Ã  travers divers proxies, chaque requÃªte semble provenir d'une source diffÃ©rente, diluant ainsi l'efficacitÃ© de la limite de taux.

### RÃ©partir l'attaque sur diffÃ©rents comptes ou sessions

Si le systÃ¨me cible applique des limites de taux sur une base par compte ou par session, rÃ©partir l'attaque ou le test sur plusieurs comptes ou sessions peut aider Ã  Ã©viter la dÃ©tection. Cette approche nÃ©cessite de gÃ©rer plusieurs identitÃ©s ou jetons de session, mais peut efficacement rÃ©partir la charge pour rester dans les limites autorisÃ©es.

### Continuez Ã  essayer

Notez que mÃªme si une limite de taux est en place, vous devriez essayer de voir si la rÃ©ponse est diffÃ©rente lorsque le OTP valide est envoyÃ©. Dans [**ce post**](https://mokhansec.medium.com/the-2-200-ato-most-bug-hunters-overlooked-by-closing-intruder-too-soon-505f21d56732), le chasseur de bugs a dÃ©couvert que mÃªme si une limite de taux est dÃ©clenchÃ©e aprÃ¨s 20 tentatives infructueuses en rÃ©pondant avec 401, si le valide Ã©tait envoyÃ©, une rÃ©ponse 200 Ã©tait reÃ§ue.

---

### Abuser du multiplexage HTTP/2 et du pipelining des requÃªtes (2023-2025)

Les implÃ©mentations modernes de limiteurs de taux comptent frÃ©quemment les **connexions TCP** (ou mÃªme les requÃªtes HTTP/1.1 individuelles) au lieu du *nombre de flux HTTP/2* qu'une connexion contient. Lorsque la mÃªme connexion TLS est rÃ©utilisÃ©e, un attaquant peut ouvrir des centaines de flux parallÃ¨les, chacun transportant une requÃªte distincte, tandis que la passerelle ne dÃ©duit qu'*une* requÃªte du quota.
```bash
# Send 100 POST requests in a single HTTP/2 connection with curl
seq 1 100 | xargs -I@ -P0 curl -k --http2-prior-knowledge -X POST \
-H "Content-Type: application/json" \
-d '{"code":"@"}' https://target/api/v2/verify &>/dev/null
```
Si le limiteur protÃ¨ge uniquement `/verify` mais pas `/api/v2/verify`, vous pouvez Ã©galement combiner **la confusion de chemin** avec le multiplexage HTTP/2 pour un *extrÃªmement* rapide OTP ou brute-forcing de crÃ©dentiels.

> ğŸ¾  **Astuce :** Le [Turbo Intruder](https://portswigger.net/research/turbo-intruder) de PortSwigger prend en charge HTTP/2 et vous permet d'affiner `maxConcurrentConnections` et `requestsPerConnection` pour automatiser cette attaque.

### Aliases GraphQL & opÃ©rations groupÃ©es

GraphQL permet au client d'envoyer **plusieurs requÃªtes ou mutations logiquement indÃ©pendantes dans une seule requÃªte** en les prÃ©fixant avec *des alias*. Comme le serveur exÃ©cute chaque alias mais que le limiteur de dÃ©bit compte souvent seulement *une* requÃªte, c'est un contournement fiable pour le throttling de connexion ou de rÃ©initialisation de mot de passe.
```graphql
mutation bruteForceOTP {
a: verify(code:"111111") { token }
b: verify(code:"222222") { token }
c: verify(code:"333333") { token }
# â€¦ add up to dozens of aliases â€¦
}
```
Regardez la rÃ©ponse : exactement un alias renverra 200 OK lorsque le code correct est atteint, tandis que les autres sont soumis Ã  une limitation de taux.

La technique a Ã©tÃ© popularisÃ©e par la recherche de PortSwigger sur â€œGraphQL batching & aliasesâ€ en 2023 et a Ã©tÃ© responsable de nombreux paiements rÃ©cents de bug-bounty.

### Abus des points de terminaison REST *batch* ou *bulk*

Certaines API exposent des points de terminaison d'assistance tels que `/v2/batch` ou acceptent un **tableau d'objets** dans le corps de la requÃªte. Si le limiteur est placÃ© uniquement devant les points de terminaison *legacy*, envelopper plusieurs opÃ©rations dans une seule requÃªte bulk peut complÃ¨tement contourner la protection.
```json
[
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"123"}},
{"path": "/login", "method": "POST", "body": {"user":"bob","pass":"456"}}
]
```
### ChronomÃ©trage de la fenÃªtre glissante

Un limiteur classique de type token-bucket ou leaky-bucket *se rÃ©initialise* Ã  une frontiÃ¨re temporelle fixe (par exemple, chaque minute). Si la fenÃªtre est connue (par exemple, via des messages d'erreur tels que `X-RateLimit-Reset: 27`), effectuez le nombre maximum de requÃªtes autorisÃ©es **juste avant** que le seau ne se rÃ©initialise, puis effectuez immÃ©diatement une autre pleine rafale.
```
|<-- 60 s window â€‘->|<-- 60 s window â€‘->|
######                 ######
```
Cette simple optimisation peut plus que doubler votre dÃ©bit sans toucher Ã  aucune autre technique de contournement.

---

## Outils

- [**https://github.com/Hashtag-AMIN/hashtag-fuzz**](https://github.com/Hashtag-AMIN/hashtag-fuzz) : Outil de fuzzing qui prend en charge la randomisation des en-tÃªtes, des listes de mots en morceaux et la rotation de proxy en round-robin.
- [**https://github.com/ustayready/fireprox**](https://github.com/ustayready/fireprox) : CrÃ©e automatiquement des points de terminaison AWS API Gateway jetables afin que chaque requÃªte provienne d'une adresse IP diffÃ©rente â€“ parfait pour vaincre le throttling basÃ© sur l'IP.
- **Burp Suite â€“ IPRotate + extension** : Utilise un pool de proxies SOCKS/HTTP (ou AWS API Gateway) pour faire tourner l'IP source de maniÃ¨re transparente lors des attaques *Intruder* et *Turbo Intruder*.
- **Turbo Intruder (BApp)** : Moteur d'attaque haute performance prenant en charge le multiplexage HTTP/2 ; rÃ©glez `requestsPerConnection` Ã  100-1000 pour regrouper des centaines de requÃªtes en une seule connexion.

## RÃ©fÃ©rences

- PortSwigger Research â€“ â€œBypassing rate limits with GraphQL aliasingâ€ (2023) <https://portswigger.net/research/graphql-authorization-bypass>
- PortSwigger Research â€“ â€œHTTP/2: The Sequel is Always Worseâ€ (section *Connection-based throttling*) (2024) <https://portswigger.net/research/http2>

{{#include ../banners/hacktricks-training.md}}
