# LFI2RCE via Nginx temp files

{{#include ../../banners/hacktricks-training.md}}

## Kwetsbare konfigurasie

[Example from bierbaumer.net](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/) het getoon dat selfs die volgende eenreël genoeg is wanneer PHP agter 'n nginx reverse proxy loop wat request bodies na die skyf buffert:
```php
<?php
$action = $_GET['action'] ?? 'read';
$path   = $_GET['file'] ?? 'index.php';
$action === 'read' ? readfile($path) : include $path;
```
Die nginx-kant hou tipies standaard-temp-paaie soos `/var/lib/nginx/body` en `/var/lib/nginx/fastcgi`. Wanneer 'n request body of upstream response groter is as die in-memory buffer (≈8 KB standaard), skryf nginx deursigtig die data na 'n temp-lêer, hou die file descriptor oop, en ontkoppel slegs die lêernaam. Enige PHP `include` wat simboliese skakels volg (soos `/proc/<pid>/fd/<fd>`) kan steeds die ontkoppelde inhoud uitvoer, wat jou RCE deur LFI gee.

## Waarom nginx temp-lêers misbruikbaar is

* Request bodies wat die buffer-drempel oorskry word na `client_body_temp_path` geskryf (standaard na `/tmp/nginx/client-body` of `/var/lib/nginx/body`).
* Die lêernaam is ewekansig, maar die file descriptor bly bereikbaar onder `/proc/<nginx_pid>/fd/<fd>`. Solank die request body nie voltooi is nie (of jy hou die TCP-stream hangend), hou nginx die descriptor oop selfs al is die padinskrywing ontkoppel.
* PHP’s include/require los daardie `/proc/.../fd/...` symlinks op, so 'n aanvaller met LFI kan deur procfs hop om die gebufferde temp-lêer uit te voer selfs nadat nginx dit verwyder het.

## Klassieke uitbuiting-workflow (opsomming)

1. **Enumereer worker PIDs.** Haal `/proc/<pid>/cmdline` via die LFI op totdat jy stringe soos `nginx: worker process` vind. Die aantal workers oorskry selde die CPU-telling, so jy hoef slegs die laer PID-ruimte te skandeer.
2. **Forceer nginx om die temp-lêer te skep.** Stuur baie groot POST/PUT bodies (of proxied responses) sodat nginx na `/var/lib/nginx/body/XXXXXXXX` uitloop. Maak seker die backend lees nooit die hele body nie — bv. hou die upload-thread keep-alive sodat nginx die descriptor oop hou.
3. **Koppel descriptors aan lêers.** Met die PID-lys, genereer traverseringskettings soos `/proc/<pidA>/cwd/proc/<pidB>/root/proc/<pidC>/fd/<fd>` om enige `realpath()`-normalisering te omseil voordat PHP die finale `/proc/<victim_pid>/fd/<interesting_fd>` teiken oplos. Brute-forcing van file descriptors 10–45 is gewoonlik genoeg omdat nginx daardie reeks hergebruik vir body temp-lêers.
4. **Include vir uitvoering.** Wanneer jy die descriptor tref wat steeds na die gebufferde body wys, voer 'n enkele `include` of `require`-oproep jou payload uit — selfs al is die oorspronklike lêernaam reeds ontkoppel. As jy net lêerlees benodig, skakel oor na `readfile()` om die tydelike inhoud te eksfiltreer in plaas van dit uit te voer.

## Moderne variasies (2024–2025)

Ingress controllers en service meshes stel nou gereeld nginx-instansies bloot met 'n groter aanval-oppervlak. CVE-2025-1974 ("IngressNightmare") is 'n goeie voorbeeld van hoe die klassieke temp-lêer-truuk ontwikkel:

* Aanvallers druk 'n kwaadwillige shared object as 'n request body. Omdat die body >8 KB is, buffer nginx dit na `/tmp/nginx/client-body/cfg-<random>`. Deur doelbewus te lieg in die `Content-Length` header (bv. te beweer 1 MB en nooit die laaste deel te stuur nie) bly die temp-lêer ongeveer 60 sekondes vasgehou.
* Die kwesbare ingress-nginx template code het toegelaat om direktiewe in die gegenereerde nginx-config te injekteer. Dit gekombineer met die langblywende temp-lêer het dit moontlik gemaak om `/proc/<pid>/fd/<fd>`-skakels te brute-forseer totdat die aanvaller die gebufferde shared object ontdek het.
* Deur `ssl_engine /proc/<pid>/fd/<fd>;` te inject, is nginx gedwing om die gebufferde `.so` te laai. Constructors binne die shared object het onmiddellike RCE binne die ingress controller pod veroorsaak, wat op sy beurt Kubernetes secrets blootgestel het.

'n Versmalde verkenningssnippet vir hierdie styl van aanval lyk soos:

<details>
<summary>Vinnige procfs-skandeerder</summary>
```python
#!/usr/bin/env python3
import os

def find_tempfds(pid_range=range(100, 4000), fd_range=range(10, 80)):
for pid in pid_range:
fd_dir = f"/proc/{pid}/fd"
if not os.path.isdir(fd_dir):
continue
for fd in fd_range:
try:
path = os.readlink(f"{fd_dir}/{fd}")
if "client-body" in path or "nginx" in path:
yield pid, fd, path
except OSError:
continue

for pid, fd, path in find_tempfds():
print(f"use ?file=/proc/{pid}/fd/{fd}  # {path}")
```
</details>

Voer dit uit vanaf enige primitive (command injection, template injection, ens.) wat jy reeds het. Voer die ontdekte `/proc/<pid>/fd/<fd>`-paaie terug in jou LFI-parameter om die gebufferde payload in te sluit.

## Praktiese wenke

* Wanneer nginx buffering deaktiveer (`proxy_request_buffering off`, `client_body_buffer_size` tuned high, or `proxy_max_temp_file_size 0`), word die tegniek veel moeiliker — tel daarom altyd konfigurasielêers en response headers om te kyk of buffering nog aangeskakel is.
* Hangende uploads is luidrugtig maar effektief. Gebruik meerdere prosesse om workers te oorstroom sodat ten minste een temp-lêer lank genoeg bly vir jou LFI brute force om dit te vang.
* In Kubernetes of ander orkestreerders kan privilege-grense anders lyk, maar die primitive is dieselfde: vind 'n manier om bytes in nginx-buffers neer te sit, en loop dan deur `/proc` van waar jy lêerlees-operasies kan uitvoer.

## Labs

- [https://bierbaumer.net/security/php-lfi-with-nginx-assistance/php-lfi-with-nginx-assistance.tar.xz](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/php-lfi-with-nginx-assistance.tar.xz)
- [https://2021.ctf.link/internal/challenge/ed0208cd-f91a-4260-912f-97733e8990fd/](https://2021.ctf.link/internal/challenge/ed0208cd-f91a-4260-912f-97733e8990fd/)
- [https://2021.ctf.link/internal/challenge/a67e2921-e09a-4bfa-8e7e-11c51ac5ee32/](https://2021.ctf.link/internal/challenge/a67e2921-e09a-4bfa-8e7e-11c51ac5ee32/)

## Verwysings

- [https://bierbaumer.net/security/php-lfi-with-nginx-assistance/](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/)
- [https://www.opswat.com/blog/ingressnightmare-cve-2025-1974-remote-code-execution-vulnerability-remediation](https://www.opswat.com/blog/ingressnightmare-cve-2025-1974-remote-code-execution-vulnerability-remediation)

{{#include ../../banners/hacktricks-training.md}}
