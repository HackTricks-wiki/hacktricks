# LFI2RCE via Nginx temp files

{{#include ../../banners/hacktricks-training.md}}

## Vulnerable configuration

[Example from bierbaumer.net](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/) gösterdi ki, PHP nginx reverse proxy arkasında çalışıp istek gövdelerini diske tamponluyorsa, aşağıdaki tek satırlık bile yeterlidir:
```php
<?php
$action = $_GET['action'] ?? 'read';
$path   = $_GET['file'] ?? 'index.php';
$action === 'read' ? readfile($path) : include $path;
```
The nginx side typically keeps default temp paths such as `/var/lib/nginx/body` and `/var/lib/nginx/fastcgi`. When a request body or upstream response is larger than the in-memory buffer (≈8 KB by default), nginx transparently writes the data to a temp file, keeps the file descriptor open, and only unlinks the file name. Any PHP `include` that follows symbolic links (like `/proc/<pid>/fd/<fd>`) can still execute the unlinked contents, giving you RCE through LFI.

## Neden nginx temp dosyaları kötüye kullanılabilir

* Buffer eşiğini aşan request body'leri `client_body_temp_path`'e dökülür (varsayılanlar `/tmp/nginx/client-body` veya `/var/lib/nginx/body`).
* Dosya adı rastgeledir, ancak file descriptor `/proc/<nginx_pid>/fd/<fd>` altında erişilebilir kalır. Request body tamamlanmadığı sürece (veya TCP akışını kasıtlı olarak asılı bırakırsanız) nginx yolu unlink etmiş olsa bile descriptor'ü açık tutar.
* PHP’nin include/require işlemi bu `/proc/.../fd/...` symlinklerini çözer, bu yüzden LFI sahibi bir saldırgan procfs üzerinden atlayarak nginx tarafından buffered edilmiş temp dosyayı, orijinal dosya silinmiş olsa bile çalıştırabilir.

## Klasik istismar iş akışı (özet)

1. **Worker PID'lerini enumerate edin.** LFI üzerinden `/proc/<pid>/cmdline` çekip `nginx: worker process` gibi stringleri bulun. Worker sayısı nadiren CPU sayısını aşar, bu yüzden PID alanının alt kısmını taramak genellikle yeterlidir.
2. **nginx'in temp dosya oluşturmasını zorlayın.** Çok büyük POST/PUT body'leri (veya proxied cevaplar) gönderin ki nginx `/var/lib/nginx/body/XXXXXXXX` gibi yerlere döksün. Backend'in tüm body'yi hiçbir zaman okumasını engelleyin — ör. upload thread'ini keep-alive tutarak nginx'in descriptor'ü açık tutmasını sağlayın.
3. **Descriptor'leri dosyalara eşleyin.** PID listesiyle, PHP'nin nihai `/proc/<victim_pid>/fd/<interesting_fd>` hedefini çözmeden önce herhangi bir `realpath()` normalizasyonunu atlatmak için `/proc/<pidA>/cwd/proc/<pidB>/root/proc/<pidC>/fd/<fd>` gibi traversal zincirleri üretin. Genellikle file descriptor'leri 10–45 aralığında brute-force etmek yeterlidir çünkü nginx body temp dosyaları için bu aralığı yeniden kullanır.
4. **Include ile yürütün.** Buffered body'ye hâlâ işaret eden descriptor'ü bulduğunuzda, tek bir `include` veya `require` çağrısı payload'unuzu çalıştırır — orijinal dosya adı zaten unlink edilmiş olsa bile. Eğer sadece dosya okumanız gerekiyorsa, execute yerine geçici içeriği exfiltrate etmek için `readfile()` kullanın.

## Modern varyasyonlar (2024–2025)

Ingress controller'lar ve service mesh'ler artık sıklıkla nginx örneklerini ek attack surface ile açığa çıkarıyor. CVE-2025-1974 ("IngressNightmare") klasik temp-file hilesinin nasıl evrilebileceğine iyi bir örnektir:

* Saldırganlar kötü amaçlı bir shared object'u request body olarak itiyor. Body >8 KB olduğu için nginx bunu `/tmp/nginx/client-body/cfg-<random>`'a bufferlıyor. `Content-Length` header'ında kasıtlı yalan söyleyerek (ör. 1 MB beyan edip son chunk'ı hiç göndermeyerek) temp dosya ~60 saniye boyunca pinned kalabiliyor.
* Vulnerable ingress-nginx template kodu, üretilen nginx konfigürasyonuna directive enjeksiyonuna izin veriyordu. Bu durum, kalan temp dosya ile birleştirildiğinde saldırganın buffered shared object'i keşfedene kadar `/proc/<pid>/fd/<fd>` linklerini brute-force etmesini mümkün kıldı.
* `ssl_engine /proc/<pid>/fd/<fd>;` enjeksiyonu, nginx'i buffered `.so`'yu yüklemeye zorladı. Shared object içindeki constructor'lar ingress controller pod'u içinde hemen RCE sağladı ve bu da Kubernetes secret'larının ifşasına yol açtı.

Bu saldırı tarzı için sadeleştirilmiş bir keşif snippet'i şöyle görünebilir:

<details>
<summary>Hızlı procfs tarayıcısı</summary>
```python
#!/usr/bin/env python3
import os

def find_tempfds(pid_range=range(100, 4000), fd_range=range(10, 80)):
for pid in pid_range:
fd_dir = f"/proc/{pid}/fd"
if not os.path.isdir(fd_dir):
continue
for fd in fd_range:
try:
path = os.readlink(f"{fd_dir}/{fd}")
if "client-body" in path or "nginx" in path:
yield pid, fd, path
except OSError:
continue

for pid, fd, path in find_tempfds():
print(f"use ?file=/proc/{pid}/fd/{fd}  # {path}")
```
</details>

Zaten sahip olduğunuz herhangi bir primitive (command injection, template injection, vb.) üzerinden çalıştırın. Keşfettiğiniz `/proc/<pid>/fd/<fd>` yollarını LFI parametrenize geri vererek buffered payload'u include edin.

## Pratik ipuçları

* When nginx disables buffering (`proxy_request_buffering off`, `client_body_buffer_size` tuned high, or `proxy_max_temp_file_size 0`), the technique becomes much harder—so always enumerate config files and response headers to check whether buffering is still enabled.
* Bekleyen yüklemeler gürültülüdür ama etkilidir. En az bir temp dosyasının LFI brute force'unuzun yakalaması için yeterince uzun süre kalmasını sağlamak adına worker'ları doldurmak için birden fazla process kullanın.
* Kubernetes veya diğer orchestrator'larda yetki sınırları farklı görünebilir, ancak primitive aynıdır: nginx buffer'larına byte'lar düşürebilecek bir yol bulun, sonra dosya sistemi okumaları yapabildiğiniz herhangi bir yerden `/proc` içinde gezin.

## Labs

- [https://bierbaumer.net/security/php-lfi-with-nginx-assistance/php-lfi-with-nginx-assistance.tar.xz](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/php-lfi-with-nginx-assistance.tar.xz)
- [https://2021.ctf.link/internal/challenge/ed0208cd-f91a-4260-912f-97733e8990fd/](https://2021.ctf.link/internal/challenge/ed0208cd-f91a-4260-912f-97733e8990fd/)
- [https://2021.ctf.link/internal/challenge/a67e2921-e09a-4bfa-8e7e-11c51ac5ee32/](https://2021.ctf.link/internal/challenge/a67e2921-e09a-4bfa-8e7e-11c51ac5ee32/)

## References

- [https://bierbaumer.net/security/php-lfi-with-nginx-assistance/](https://bierbaumer.net/security/php-lfi-with-nginx-assistance/)
- [https://www.opswat.com/blog/ingressnightmare-cve-2025-1974-remote-code-execution-vulnerability-remediation](https://www.opswat.com/blog/ingressnightmare-cve-2025-1974-remote-code-execution-vulnerability-remediation)

{{#include ../../banners/hacktricks-training.md}}
