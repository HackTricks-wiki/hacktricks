# LFI2RCE via Eternal waiting

{{#include ../../banners/hacktricks-training.md}}

## Grundinformationen

Standardmäßig, wenn eine Datei in PHP hochgeladen wird (auch wenn es nicht erwartet wird), wird eine temporäre Datei in `/tmp` mit einem Namen wie **`php[a-zA-Z0-9]{6}`** erstellt, obwohl ich einige Docker-Images gesehen habe, bei denen die generierten Dateien keine Ziffern enthalten.

Bei einer lokalen Dateieinbindung, **wenn es Ihnen gelingt, diese hochgeladene Datei einzubinden, erhalten Sie RCE**.

Beachten Sie, dass PHP standardmäßig **nur 20 Dateien in einer einzigen Anfrage erlaubt** (festgelegt in `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Auch die **Anzahl der potenziellen Dateinamen beträgt 62\*62\*62\*62\*62\*62 = 56800235584**

### Andere Techniken

Andere Techniken basieren darauf, PHP-Protokolle anzugreifen (du wirst nicht in der Lage sein, wenn du nur den letzten Teil des Pfades kontrollierst), den Pfad der Datei offenzulegen, erwartete Dateien auszunutzen oder **PHP dazu zu bringen, einen Segmentierungsfehler zu erleiden, sodass hochgeladene temporäre Dateien nicht gelöscht werden**.\
Diese Technik ist **sehr ähnlich der letzten, erfordert jedoch kein Finden eines Zero Days**.

### Ewige Warte-Technik

In dieser Technik **müssen wir nur einen relativen Pfad kontrollieren**. Wenn es uns gelingt, Dateien hochzuladen und das **LFI niemals enden zu lassen**, haben wir "genug Zeit", um **hochgeladene Dateien zu brute-forcen** und **eine** der hochgeladenen zu **finden**.

**Vorteile dieser Technik**:

- Du musst nur einen relativen Pfad innerhalb eines Includes kontrollieren
- Erfordert kein nginx oder unerwarteten Zugriff auf Protokolldateien
- Erfordert keinen 0-Day, um einen Segmentierungsfehler zu verursachen
- Erfordert keine Pfadoffenlegung

Die **Hauptprobleme** dieser Technik sind:

- Es müssen spezifische Datei(en) vorhanden sein (es könnten mehr sein)
- Die **wahnsinnige** Anzahl potenzieller Dateinamen: **56800235584**
- Wenn der Server **keine Ziffern verwendet**, beträgt die gesamte potenzielle Anzahl: **19770609664**
- Standardmäßig können **nur 20 Dateien** in einer **einzelnen Anfrage** hochgeladen werden.
- Die **maximale Anzahl paralleler Worker** des verwendeten Servers.
- Diese Grenze zusammen mit den vorherigen kann diesen Angriff zu lange dauern lassen
- **Timeout für eine PHP-Anfrage**. Idealerweise sollte dies ewig dauern oder den PHP-Prozess beenden, ohne die temporär hochgeladenen Dateien zu löschen, andernfalls wird das auch ein Problem sein

Wie kannst du also **eine PHP-Include-Anweisung niemals enden lassen**? Indem du einfach die Datei **`/sys/kernel/security/apparmor/revision`** einfügst (**leider nicht in Docker-Containern verfügbar...**).

Versuche es einfach, indem du aufrufst:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Standardmäßig unterstützt Apache **150 gleichzeitige Verbindungen**. Laut [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) ist es möglich, diese Zahl auf bis zu 8000 zu erhöhen. Folgen Sie dieser Anleitung, um PHP mit diesem Modul zu verwenden: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Standardmäßig (wie ich in meinen Tests sehen kann) kann ein **PHP-Prozess ewig dauern**.

Lassen Sie uns einige Berechnungen anstellen:

- Wir können **149 Verbindungen** nutzen, um **149 \* 20 = 2980 temporäre Dateien** mit unserem Webshell zu generieren.
- Dann verwenden wir die **letzte Verbindung**, um **Brute-Force** potenzielle Dateien.
- Bei einer Geschwindigkeit von **10 Anfragen/s** sind die Zeiten:
- 56800235584 / 2980 / 10 / 3600 \~= **530 Stunden** (50% Chance in 265h)
- (ohne Ziffern) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% Chance in 93h)

> [!WARNING]
> Beachten Sie, dass wir im vorherigen Beispiel **andere Clients vollständig DoSen**!

Wenn der Apache-Server verbessert wird und wir **4000 Verbindungen** missbrauchen könnten (auf halbem Weg zur maximalen Anzahl). Wir könnten `3999*20 = 79980` **Dateien** erstellen und die **Zahl** würde auf etwa **19.7h** oder **6.9h** (10h, 3.5h 50% Chance) **reduziert**.

## PHP-FMP

Wenn anstelle des regulären PHP-Moduls für Apache, um PHP-Skripte auszuführen, die **Webseite** **PHP-FMP verwendet** (dies verbessert die Effizienz der Webseite, daher ist es üblich, es zu finden), gibt es noch etwas, das getan werden kann, um die Technik zu verbessern.

PHP-FMP ermöglicht es, den **Parameter** **`request_terminate_timeout`** in **`/etc/php/<php-version>/fpm/pool.d/www.conf`** zu **konfigurieren**.\
Dieser Parameter gibt die maximale Anzahl von Sekunden an, **wann** **die Anfrage an PHP beendet werden muss** (standardmäßig unendlich, aber **30s, wenn der Parameter nicht auskommentiert ist**). Wenn eine Anfrage von PHP verarbeitet wird, wird die angegebene Anzahl von Sekunden **getötet**. Das bedeutet, dass, wenn die Anfrage temporäre Dateien hochlädt, weil die **PHP-Verarbeitung gestoppt wurde**, diese **Dateien nicht gelöscht werden**. Daher, wenn Sie eine Anfrage so lange aufrechterhalten können, können Sie **tausende temporäre Dateien generieren**, die nicht gelöscht werden, was den Prozess der Auffindung beschleunigt und die Wahrscheinlichkeit eines DoS für die Plattform verringert, indem alle Verbindungen verbraucht werden.

Um also **DoS zu vermeiden**, nehmen wir an, dass ein **Angreifer nur 100 Verbindungen** gleichzeitig verwenden wird und die maximale Verarbeitungszeit von PHP durch **php-fmp** (`request_terminate_timeout`**)** **30s** beträgt. Daher beträgt die Anzahl der **temporären Dateien**, die **pro Sekunde** generiert werden können, `100*20/30 = 66.67`.

Um dann **10000 Dateien** zu generieren, würde ein Angreifer benötigen: **`10000/66.67 = 150s`** (um **100000 Dateien** zu generieren, würde die Zeit **25min** betragen).

Dann könnte der Angreifer diese **100 Verbindungen** nutzen, um eine **Brute-Force-Suche** durchzuführen. Bei einer Geschwindigkeit von 300 req/s beträgt die benötigte Zeit für die Ausnutzung Folgendes:

- 56800235584 / 10000 / 300 / 3600 \~= **5.25 Stunden** (50% Chance in 2.63h)
- (mit 100000 Dateien) 56800235584 / 100000 / 300 / 3600 \~= **0.525 Stunden** (50% Chance in 0.263h)

Ja, es ist möglich, 100000 temporäre Dateien in einer EC2-Medium-Instanz zu generieren:

<figure><img src="../../images/image (240).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> Beachten Sie, dass es **ausreichend wäre, die anfällige LFI-Seite einzuschließen**, um den Timeout auszulösen, sodass sie in eine ewige Einschluss-Schleife eintritt.

## Nginx

Es scheint, dass Nginx standardmäßig **512 parallele Verbindungen** gleichzeitig unterstützt (und diese Zahl verbessert werden kann).

{{#include ../../banners/hacktricks-training.md}}
