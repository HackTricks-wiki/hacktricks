# LFI2RCE via Eternal waiting

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

デフォルトでは、ファイルがPHPにアップロードされると（期待されていなくても）、**`php[a-zA-Z0-9]{6}`**のような名前の一時ファイルが`/tmp`に生成されます。ただし、生成されたファイルに数字が含まれないdockerイメージも見たことがあります。

ローカルファイルインクルージョンでは、**そのアップロードされたファイルをインクルードできれば、RCEを得ることができます**。

デフォルトでは、**PHPは単一のリクエストで20ファイルのアップロードのみを許可します**（`/etc/php/<version>/apache2/php.ini`で設定されています）：
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
また、**潜在的なファイル名の数は 62\*62\*62\*62\*62\*62 = 56800235584** です。

### その他の技術

その他の技術は、PHPプロトコルを攻撃することに依存しています（パスの最後の部分だけを制御している場合はできません）、ファイルのパスを開示すること、期待されるファイルを悪用すること、または**PHPにセグメンテーションフォルトを引き起こさせてアップロードされた一時ファイルが削除されないようにすること**です。\
この技術は**最後のものと非常に似ていますが、ゼロデイを見つける必要はありません**。

### 永遠の待機技術

この技術では**相対パスを制御するだけで済みます**。ファイルをアップロードし、**LFIが決して終わらないようにすることができれば**、アップロードされたファイルを**ブルートフォース**して**見つけるための「十分な時間」を得ることができます**。

**この技術の利点**:

- インクルード内の相対パスを制御するだけで済みます
- nginxやログファイルへの予期しないアクセスレベルを必要としません
- セグメンテーションフォルトを引き起こすために0デイを必要としません
- パスの開示を必要としません

この技術の**主な問題**は次のとおりです：

- 特定のファイルが存在する必要があります（他にもあるかもしれません）
- **途方もない**潜在的なファイル名の数: **56800235584**
- サーバーが**数字を使用していない**場合、潜在的な合計は: **19770609664**
- デフォルトでは**1回のリクエストで20ファイルのみ**アップロードできます。
- 使用されるサーバーの**最大並列ワーカー数**。
- この制限は前のものと組み合わせると、この攻撃が長引く可能性があります
- **PHPリクエストのタイムアウト**。理想的にはこれは永遠であるべきか、アップロードされた一時ファイルを削除せずにPHPプロセスを終了させるべきです。そうでない場合、これもまた厄介です。

では、どうやって**PHPインクルードを決して終わらせる**ことができるのでしょうか？ファイル**`/sys/kernel/security/apparmor/revision`**をインクルードするだけです（**残念ながらDockerコンテナでは利用できません...**）。

試してみてください：
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしています。 [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) に従って、この数を最大8000まで増やすことが可能です。このモジュールでPHPを使用するには、次の手順に従ってください: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)。

デフォルトでは、（私のテストで確認したところ）**PHPプロセスは永遠に続くことができます**。

いくつかの計算をしてみましょう：

- **149接続**を使用して、**149 \* 20 = 2980の一時ファイル**を生成できます。
- 次に、**最後の接続**を使用して**ブルートフォース**で潜在的なファイルを探します。
- **10リクエスト/秒**の速度で、時間は次の通りです：
- 56800235584 / 2980 / 10 / 3600 \~= **530時間**（265時間で50%の確率）
- （数字なし）19770609664 / 2980 / 10 / 3600 \~= 185時間（93時間で50%の確率）

> [!WARNING]
> 前の例では、**他のクライアントを完全にDoSしています**！

Apacheサーバーが改善され、**4000接続**を悪用できる場合（最大数の半分）、`3999*20 = 79980` **ファイル**を作成でき、**時間**は約**19.7時間**または**6.9時間**（10時間、3.5時間で50%の確率）に**短縮**されます。

## PHP-FMP

通常のphpモジュールを使用してPHPスクリプトを実行する代わりに、**ウェブページが** **PHP-FMP**を使用している場合（これによりウェブページの効率が向上するため、一般的に見られます）、技術を改善するために他にできることがあります。

PHP-FMPは、**`/etc/php/<php-version>/fpm/pool.d/www.conf`**で**パラメータ** **`request_terminate_timeout`**を**設定**することを許可します。\
このパラメータは、**PHPへのリクエストが終了する最大秒数**を示します（デフォルトでは無限ですが、**パラメータがコメント解除されると30秒**）。リクエストがPHPによって処理されている間、指定された秒数が経過すると、**終了**します。これは、リクエストが一時ファイルをアップロードしている場合、**PHP処理が停止したため**、それらの**ファイルは削除されない**ことを意味します。したがって、その時間リクエストを持続させることができれば、削除されない**数千の一時ファイル**を**生成**でき、これによりそれらを見つけるプロセスが**加速**され、すべての接続を消費することによるプラットフォームへのDoSの確率が減少します。

したがって、**DoSを回避するために**、**攻撃者が同時に100接続のみを使用する**と仮定し、php-fmpによるPHPの最大処理時間（`request_terminate_timeout`**）が**30秒**であるとします。したがって、**秒あたり生成できる一時ファイルの数**は`100*20/30 = 66.67`です。

次に、**10000ファイル**を生成するには、攻撃者は**`10000/66.67 = 150秒`**が必要です（**100000ファイル**を生成するには、時間は**25分**になります）。

その後、攻撃者はこれらの**100接続**を使用して**ブルートフォース検索**を実行できます。 \*\*\*\* 300 req/sの速度を仮定すると、これを悪用するのに必要な時間は次の通りです：

- 56800235584 / 10000 / 300 / 3600 \~= **5.25時間**（2.63時間で50%の確率）
- （100000ファイルの場合）56800235584 / 100000 / 300 / 3600 \~= **0.525時間**（0.263時間で50%の確率）

はい、EC2の中サイズインスタンスで100000の一時ファイルを生成することは可能です：

<figure><img src="../../images/image (240).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> タイムアウトをトリガーするには、**脆弱なLFIページを含めるだけで十分**です。そうすれば、永遠のインクルードループに入ります。

## Nginx

デフォルトでは、Nginxは同時に**512の並列接続**をサポートしているようです（この数は改善可能です）。

{{#include ../../banners/hacktricks-training.md}}
