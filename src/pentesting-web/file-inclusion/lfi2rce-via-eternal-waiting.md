# LFI2RCE via Eternal waiting

{{#include ../../banners/hacktricks-training.md}}

## 基本情報

デフォルトでは、ファイルがPHPにアップロードされると（期待していなくても）、**`php[a-zA-Z0-9]{6}`**のような名前の一時ファイルが`/tmp`に生成されます。ただし、生成されたファイルに数字が含まれないdockerイメージも見たことがあります。

ローカルファイルインクルージョンでは、**そのアップロードされたファイルを含めることができれば、RCEを得ることができます**。

デフォルトでは、**PHPは単一のリクエストで20ファイルのアップロードのみを許可します**（`/etc/php/<version>/apache2/php.ini`で設定されています）：
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
また、**潜在的なファイル名の数は 62\*62\*62\*62\*62\*62 = 56800235584** です。

### その他の技術

その他の技術は、PHPプロトコルを攻撃することに依存しています（パスの最後の部分だけを制御している場合はできません）、ファイルのパスを開示すること、期待されるファイルを悪用すること、または**PHPにセグメンテーションフォルトを引き起こさせてアップロードされた一時ファイルが削除されないようにすること**です。\
この技術は**最後のものと非常に似ていますが、ゼロデイを見つける必要はありません**。

### 永遠の待機技術

この技術では**相対パスを制御する必要があるだけです**。ファイルをアップロードし、**LFIが決して終わらないようにすることができれば**、アップロードされたファイルを**ブルートフォース**して**見つけるための「十分な時間」を得ることができます**。

**この技術の利点**:

- インクルード内の相対パスを制御するだけで済む
- nginxやログファイルへの予期しないアクセスレベルを必要としない
- セグメンテーションフォルトを引き起こすために0デイを必要としない
- パスの開示を必要としない

この技術の**主な問題**は次のとおりです：

- 特定のファイルが存在する必要がある（他にもあるかもしれません）
- **潜在的なファイル名の**「狂気のような」数: **56800235584**
- サーバーが**数字を使用していない**場合、潜在的な合計は: **19770609664**
- デフォルトでは**1回のリクエストで20ファイル**しかアップロードできません。
- 使用されるサーバーの**最大並列ワーカー数**。
- この制限と前述の制限により、この攻撃が長引く可能性があります
- **PHPリクエストのタイムアウト**。理想的には、これは永遠であるべきか、アップロードされた一時ファイルを削除せずにPHPプロセスを終了させるべきです。そうでない場合、これもまた厄介です。

では、どうやって**PHPインクルードを決して終わらせる**ことができるのでしょうか？ファイル**`/sys/kernel/security/apparmor/revision`**をインクルードするだけです（**残念ながらDockerコンテナでは利用できません...**）。

試してみてください：
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしており、[https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/)に従って、この数を最大8000まで増やすことが可能です。このモジュールでPHPを使用するには、次の手順に従ってください: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)。

デフォルトでは、（私のテストで確認したところ）**PHPプロセスは永遠に続くことができます**。

いくつかの計算をしてみましょう：

- **149の接続**を使用して、**149 \* 20 = 2980の一時ファイル**を生成できます。
- 次に、**最後の接続**を使用して**ブルートフォース**で潜在的なファイルを探します。
- **10リクエスト/秒**の速度で、時間は次の通りです：
- 56800235584 / 2980 / 10 / 3600 \~= **530時間**（265時間で50%の確率）
- （数字なし）19770609664 / 2980 / 10 / 3600 \~= 185時間（93時間で50%の確率）

> [!WARNING]
> 前の例では、**他のクライアントを完全にDoSしている**ことに注意してください！

Apacheサーバーが改善され、**4000の接続**を悪用できる場合（最大数の半分）、`3999*20 = 79980` **ファイル**を作成でき、**時間**は約**19.7時間**または**6.9時間**（10時間、3.5時間で50%の確率）に**短縮**されます。

## PHP-FMP

通常のphpモジュールを使用してPHPスクリプトを実行する代わりに、**ウェブページが** **PHP-FMPを使用している**場合（これによりウェブページの効率が向上するため、一般的に見られます）、技術を改善するために他にできることがあります。

PHP-FMPは、**`/etc/php/<php-version>/fpm/pool.d/www.conf`**で**パラメータ** **`request_terminate_timeout`**を**設定**することを許可します。\
このパラメータは、**PHPへのリクエストが終了する最大秒数**を示します（デフォルトでは無限ですが、**パラメータがコメント解除されると30秒**）。PHPによってリクエストが処理されている間に指定された秒数が経過すると、**終了**します。これは、リクエストが一時ファイルをアップロードしている場合、**PHP処理が停止したため**、それらの**ファイルは削除されない**ことを意味します。したがって、その時間リクエストを持続させることができれば、削除されない**数千の一時ファイル**を**生成**でき、これによりそれらを見つけるプロセスが**加速**され、すべての接続を消費することによるプラットフォームへのDoSの可能性が減少します。

したがって、**DoSを回避するために**、**攻撃者が同時に100の接続**のみを使用すると仮定し、php-fmpによるPHPの最大処理時間（`request_terminate_timeout`**）は**30秒**です。したがって、**秒あたり生成できる一時ファイルの数**は`100*20/30 = 66.67`です。

次に、**10000ファイル**を生成するには、攻撃者は**`10000/66.67 = 150秒`**が必要です（**100000ファイル**を生成するには、時間は**25分**です）。

次に、攻撃者はこれらの**100接続**を使用して**ブルートフォース検索**を実行できます。 \*\*\*\* 300 req/sの速度を仮定すると、これを悪用するのに必要な時間は次の通りです：

- 56800235584 / 10000 / 300 / 3600 \~= **5.25時間**（2.63時間で50%の確率）
- （100000ファイルの場合）56800235584 / 100000 / 300 / 3600 \~= **0.525時間**（0.263時間で50%の確率）

はい、EC2の中サイズインスタンスで100000の一時ファイルを生成することは可能です：

<figure><img src="../../images/image (240).png" alt=""><figcaption></figcaption></figure>

> [!WARNING]
> タイムアウトをトリガーするには、**脆弱なLFIページを含めるだけで十分**です。そうすれば、永遠のインクルードループに入ります。

## Nginx

デフォルトでは、Nginxは同時に**512の並列接続**をサポートしているようです（この数は改善可能です）。

{{#include ../../banners/hacktricks-training.md}}
