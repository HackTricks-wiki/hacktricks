# Browser Extension Pentesting Methodology

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Extensions za kivinjari zimeandikwa kwa JavaScript na hupakiwa na kivinjari katika hali ya nyuma. Ina [DOM](https://www.w3schools.com/js/js_htmldom.asp) yake lakini inaweza kuingiliana na DOM za tovuti nyingine. Hii inamaanisha kwamba inaweza kuhatarisha usiri, uadilifu, na upatikanaji (CIA) wa tovuti nyingine.

## Main Components

Muundo wa nyongeza unaonekana bora unapofikiriwa na unajumuisha vipengele vitatu. Hebu tuangalie kila kipengele kwa undani.

<figure><img src="../../images/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Content Scripts**

Kila script ya maudhui ina ufikiaji wa moja kwa moja kwa DOM ya **ukurasa mmoja wa wavuti** na hivyo inakabiliwa na **ingizo linaloweza kuwa na uharibifu**. Hata hivyo, script ya maudhui haina ruhusa nyingine isipokuwa uwezo wa kutuma ujumbe kwa msingi wa nyongeza.

### **Extension Core**

Msingi wa nyongeza unajumuisha ruhusa nyingi za nyongeza, lakini msingi wa nyongeza unaweza kuingiliana tu na maudhui ya wavuti kupitia [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) na scripts za maudhui. Pia, msingi wa nyongeza haina ufikiaji wa moja kwa moja kwa mashine mwenyeji.

### **Native Binary**

Nyongeza inaruhusu binary asilia ambayo inaweza **kufikia mashine mwenyeji kwa ruhusa kamili ya mtumiaji.** Binary asilia inaingiliana na msingi wa nyongeza kupitia Kiolesura cha Programu ya Plugin ya Netscape ya kawaida ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) inayotumiwa na Flash na nyongeza nyingine za kivinjari.

### Boundaries

> [!CAUTION]
> Ili kupata ruhusa kamili ya mtumiaji, mshambuliaji lazima amshawishi nyongeza kupitisha ingizo la uharibifu kutoka kwa script ya maudhui hadi msingi wa nyongeza na kutoka kwa msingi wa nyongeza hadi binary asilia.

Kila kipengele cha nyongeza kimewekwa mbali na kingine kwa **mipaka yenye ulinzi mkali**. Kila kipengele kinakimbia katika **mchakato tofauti wa mfumo wa uendeshaji**. Scripts za maudhui na misingi ya nyongeza zinakimbia katika **mchakato wa sandbox** ambao haupatikani kwa huduma nyingi za mfumo wa uendeshaji.

Zaidi ya hayo, scripts za maudhui zimej separated kutoka kwa kurasa zao za wavuti kwa **kukimbia katika heap tofauti ya JavaScript**. Script ya maudhui na ukurasa wa wavuti zina **ufikiaji wa DOM sawa ya msingi**, lakini hizo mbili **hazibadilishani viashiria vya JavaScript**, kuzuia kuvuja kwa kazi za JavaScript.

## **`manifest.json`**

Nyongeza ya Chrome ni tu folda ya ZIP yenye [.crx file extension](https://www.lifewire.com/crx-file-2620391). Msingi wa nyongeza ni **`manifest.json`** faili katika mzizi wa folda, ambayo inaelezea muundo, ruhusa, na chaguzi zingine za usanidi.

Example:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": ["storage"],
"content_scripts": [
{
"js": ["script.js"],
"matches": ["https://example.com/*", "https://www.example.com/*"],
"exclude_matches": ["*://*/*business*"]
}
],
"background": {
"scripts": ["background.js"]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content scripts zina **pakiwa** kila wakati mtumiaji **anapohamia kwenye ukurasa unaolingana**, katika kesi yetu ukurasa wowote unaolingana na **`https://example.com/*`** expression na sio unaolingana na **`*://*/*/business*`** regex. Zinatekelezwa **kama vile scripts za ukurasa wenyewe** na zina ufikiaji wa kiholela kwa [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) wa ukurasa.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Ili kujumuisha au kutenga URL zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

Hii ni mfano wa script ya maudhui ambayo itaongeza kitufe cha maelezo kwenye ukurasa wakati [API ya hifadhi](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) inatumika kupata thamani ya `message` kutoka kwenye hifadhi ya nyongeza.
```js
chrome.storage.local.get("message", (result) => {
let div = document.createElement("div")
div.innerHTML = result.message + " <button>Explain</button>"
div.querySelector("button").addEventListener("click", () => {
chrome.runtime.sendMessage("explain")
})
document.body.appendChild(div)
})
```
<figure><img src="../../images/image (23).png" alt=""><figcaption></figcaption></figure>

Ujumbe unatumwa kwa kurasa za nyongeza na script ya maudhui wakati kitufe hiki kinapobonyezwa, kupitia matumizi ya [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Hii ni kutokana na kikomo cha script ya maudhui katika ufikiaji wa moja kwa moja wa APIs, ambapo `storage` ni miongoni mwa ubaguzi wachache. Kwa kazi zaidi ya ubaguzi hizi, ujumbe unatumwa kwa kurasa za nyongeza ambazo script za maudhui zinaweza kuwasiliana nazo.

> [!WARNING]
> Kulingana na kivinjari, uwezo wa script ya maudhui unaweza kutofautiana kidogo. Kwa vivinjari vinavyotegemea Chromium, orodha ya uwezo inapatikana katika [Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), na kwa Firefox, [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) inatumika kama chanzo kikuu.\
> Pia ni muhimu kutambua kwamba script za maudhui zina uwezo wa kuwasiliana na script za nyuma, na kuwapa uwezo wa kutekeleza vitendo na kurudisha majibu.

Ili kuona na kufanyia kazi script za maudhui katika Chrome, menyu ya zana za maendeleo za Chrome inaweza kufikiwa kutoka Options > More tools > Developer tools AU kwa kubonyeza Ctrl + Shift + I.

Baada ya zana za maendeleo kuonyeshwa, **Source tab** inapaswa kubonyezwa, ikifuatiwa na **Content Scripts** tab. Hii inaruhusu kuangalia script za maudhui zinazotumika kutoka nyongeza mbalimbali na kuweka alama za kuvunja ili kufuatilia mtiririko wa utekelezaji.

### Script za maudhui zilizoongezwa

> [!TIP]
> Kumbuka kwamba **Script za Maudhui si lazima** kwani pia inawezekana **kudumu** **kuongeza** script na **kuziingiza kimaandishi** katika kurasa za wavuti kupitia **`tabs.executeScript`**. Hii kwa kweli inatoa **udhibiti wa kina** zaidi.

Kwa kuingiza script ya maudhui kimaandishi, nyongeza inahitaji kuwa na [host permissions](https://developer.chrome.com/docs/extensions/reference/permissions) kwa ukurasa ambao script zitakuwa zinaingizwa. Ruhusa hizi zinaweza kupatikana ama kwa **kuziomba** ndani ya hati ya nyongeza au kwa msingi wa muda kupitia [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Mfano wa nyongeza inayotegemea activeTab
```json:manifest.json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
- **Ingiza faili la JS kwa kubonyeza:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange"

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"],
})
})
```
- **Ingiza kazi** kwa kubonyeza:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange"
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
func: injectedFunction,
})
})
```
#### Mfano na ruhusa za skripti
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
excludeMatches: ["*://*/*business*"],
js: ["contentScript.js"],
},
])

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" })
```
Ili kujumuisha au kutenga URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

### Content Scripts `run_at`

Sehemu ya `run_at` inasimamia **wakati faili za JavaScript zinapoinjikwa kwenye ukurasa wa wavuti**. Thamani inayopendekezwa na ya default ni `"document_idle"`.

Thamani zinazowezekana ni:

- **`document_idle`**: Kadri inavyowezekana
- **`document_start`**: Baada ya faili zozote kutoka `css`, lakini kabla ya DOM nyingine yoyote kujengwa au script nyingine yoyote kuendeshwa.
- **`document_end`**: Mara moja baada ya DOM kukamilika, lakini kabla ya rasilimali ndogo kama picha na fremu kupakiwa.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Kupitia **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
runAt: "document_idle",
js: ["contentScript.js"],
},
])
```
### `background`

Meseji zinazotumwa na scripts za maudhui zinapokelewa na **background page**, ambayo ina jukumu kuu katika kuratibu vipengele vya nyongeza. Kwa kuzingatia, background page inadumu wakati wa maisha ya nyongeza, ikifanya kazi kwa siri bila mwingiliano wa moja kwa moja na mtumiaji. Ina Modeli ya Kitu ya Hati (DOM) yake, ikiruhusu mwingiliano tata na usimamizi wa hali.

**Mambo Muhimu**:

- **Jukumu la Background Page:** Inafanya kazi kama kituo cha neva kwa nyongeza, kuhakikisha mawasiliano na uratibu kati ya sehemu mbalimbali za nyongeza.
- **Uthabiti:** Ni kitu kinachokuwepo kila wakati, kisichoonekana kwa mtumiaji lakini muhimu kwa utendaji wa nyongeza.
- **Uundaji Otomatiki:** Ikiwa haijafafanuliwa wazi, kivinjari kitaunda kiotomatiki background page. Ukurasa huu ulioundwa kiotomatiki utajumuisha scripts zote za background zilizotajwa katika hati ya nyongeza, kuhakikisha uendeshaji usio na mshikemshike wa kazi za background za nyongeza.

> [!TIP]
> Urahisi unaotolewa na kivinjari katika kuunda kiotomatiki background page (wakati haijatangazwa wazi) unahakikisha kwamba scripts zote muhimu za background zimeunganishwa na zinafanya kazi, ikirahisisha mchakato wa kuweka nyongeza. 

Mfano wa script ya background:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
if (request == "explain") {
chrome.tabs.create({ url: "https://example.net/explanation" })
}
})
```
Inatumia [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) kusikiliza ujumbe. Wakati ujumbe wa `"explain"` unapopokelewa, inatumia [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) kufungua ukurasa katika tab mpya.

Ili kubaini skripti ya nyuma unaweza kwenda kwenye **maelezo ya nyongeza na kukagua huduma ya mfanyakazi,** hii itafungua zana za maendeleo na skripti ya nyuma:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Kurasa za chaguzi na nyingine

Nyongeza za kivinjari zinaweza kuwa na aina mbalimbali za kurasa:

- **Kurasa za hatua** zinaonyeshwa katika **orodha ya kushuka wakati ikoni ya nyongeza** inabonyezwa.
- Kurasa ambazo nyongeza it **pakia katika tab mpya**.
- **Kurasa za Chaguzi**: Ukurasa huu unaonyeshwa juu ya nyongeza wakati unabonyezwa. Katika hati ya awali Katika kesi yangu niliweza kufikia ukurasa huu katika `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` au kubonyeza:

<figure><img src="../../images/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Kumbuka kwamba kurasa hizi si za kudumu kama kurasa za nyuma kwani zinapakia maudhui kwa mahitaji. Licha ya hili, zinashiriki uwezo fulani na ukurasa wa nyuma:

- **Mawasiliano na Skripti za Maudhui:** Kama ilivyo kwa ukurasa wa nyuma, kurasa hizi zinaweza kupokea ujumbe kutoka kwa skripti za maudhui, kurahisisha mwingiliano ndani ya nyongeza.
- **Upatikanaji wa APIs za Maalum za Nyongeza:** Kurasa hizi zinafurahia upatikanaji mpana wa APIs za maalum za nyongeza, kulingana na ruhusa zilizofafanuliwa kwa nyongeza.

### `permissions` & `host_permissions`

**`permissions`** na **`host_permissions`** ni entries kutoka `manifest.json` ambazo zitaonyesha **ni ruhusa zipi** nyongeza za kivinjari zina (hifadhi, eneo...) na katika **kurasa zipi za wavuti**.

Kama nyongeza za kivinjari zinaweza kuwa na **mamlaka makubwa**, moja mbaya au moja iliyovunjwa inaweza kumruhusu mshambuliaji **njia tofauti za kuiba taarifa nyeti na kupeleleza mtumiaji**.

Angalia jinsi mipangilio hii inavyofanya kazi na jinsi inaweza kutumika vibaya katika:

{{#ref}}
browext-permissions-and-host_permissions.md
{{#endref}}

### `content_security_policy`

**sera ya usalama wa maudhui** inaweza kutangazwa pia ndani ya `manifest.json`. Ikiwa kuna moja iliyofafanuliwa, inaweza kuwa **hatari**.

Mipangilio ya default kwa kurasa za nyongeza za kivinjari ni ya kukatisha tamaa:
```bash
script-src 'self'; object-src 'self';
```
Kwa maelezo zaidi kuhusu CSP na uwezekano wa kupita angalia:

{{#ref}}
../content-security-policy-csp-bypass/
{{#endref}}

### `web_accessible_resources`

ili kuruhusu ukurasa wa wavuti kufikia ukurasa wa Kiongezeo cha Kivinjari, ukurasa wa `.html` kwa mfano, ukurasa huu unahitaji kutajwa katika uwanja wa **`web_accessible_resources`** wa `manifest.json`.\
Kwa mfano:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Hizi kurasa zinapatikana katika URL kama:
```
chrome-extension://<extension-id>/message.html
```
Katika nyongeza za umma, **extension-id inapatikana**:

<figure><img src="../../images/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Hata hivyo, ikiwa parameter ya `manifest.json` **`use_dynamic_url`** inatumika, **id hii inaweza kuwa ya dynamic**.

> [!TIP]
> Kumbuka kwamba hata kama ukurasa umeelezewa hapa, unaweza kuwa **umejilinda dhidi ya ClickJacking** kwa sababu ya **Content Security Policy**. Hivyo unahitaji kuangalia pia (sehemu ya frame-ancestors) kabla ya kuthibitisha kuwa shambulio la ClickJacking linawezekana.

Kuruhusiwa kufikia kurasa hizi kunafanya kurasa hizi **kuwa na uwezekano wa kuwa na udhaifu wa ClickJacking**:

{{#ref}}
browext-clickjacking.md
{{#endref}}

> [!TIP]
> Kuruhusu kurasa hizi kupakuliwa tu na nyongeza na si kwa URL za nasibu kunaweza kuzuia mashambulizi ya ClickJacking.

> [!CAUTION]
> Kumbuka kwamba kurasa kutoka **`web_accessible_resources`** na kurasa nyingine za nyongeza pia zina uwezo wa **kuwasiliana na scripts za nyuma**. Hivyo ikiwa moja ya kurasa hizi ina udhaifu wa **XSS** inaweza kufungua udhaifu mkubwa zaidi.
>
> Aidha, kumbuka kwamba unaweza kufungua tu kurasa zilizoonyeshwa katika **`web_accessible_resources`** ndani ya iframes, lakini kutoka kwenye tab mpya inawezekana kufikia ukurasa wowote katika nyongeza ukijua extension ID. Hivyo, ikiwa XSS inapatikana ikitumia vigezo sawa, inaweza kutumika hata kama ukurasa haujawekwa katika **`web_accessible_resources`**.

### `externally_connectable`

Kulingana na [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), Mali ya `"externally_connectable"` katika manifest inatangaza **ni nyongeza zipi na kurasa za wavuti zinaweza kuungana** na nyongeza yako kupitia [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) na [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

- Ikiwa funguo ya **`externally_connectable`** **haijatangazwa** katika manifest ya nyongeza yako au imetangazwa kama **`"ids": ["*"]`**, **nyongeza zote zinaweza kuungana, lakini hakuna kurasa za wavuti zinaweza kuungana**.
- Ikiwa **IDs maalum zimeelezwa**, kama katika `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **ni hizo programu pekee** zinaweza kuungana.
- Ikiwa **mifano** imeelezwa, programu hizo za wavuti zitakuwa na uwezo wa kuungana:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
- Ikiwa imeelezwa kama tupu: **`"externally_connectable": {}`**, hakuna programu au wavuti itakayoweza kuungana.

**Mipanuzi na URL** zilizoorodheshwa hapa, **uso wa shambulio** utakuwa mdogo.

> [!CAUTION]
> Ikiwa ukurasa wa wavuti **una hatari ya XSS au kuchukuliwa** umeonyeshwa katika **`externally_connectable`**, mshambuliaji ataweza **kutuma ujumbe moja kwa moja kwa skripti ya nyuma**, akipita kabisa Skripti ya Maudhui na CSP yake.
>
> Hivyo, hii ni **kikosi cha kupita nguvu sana**.
>
> Zaidi ya hayo, ikiwa mteja ataweka upanuzi wa uongo, hata kama haukubaliwi kuwasiliana na upanuzi unaohatarisha, inaweza kuingiza **data za XSS katika ukurasa wa wavuti ulioidhinishwa** au kutumia **`WebRequest`** au **`DeclarativeNetRequest`** APIs kubadilisha maombi kwenye kikoa kilicholengwa kubadilisha ombi la ukurasa kwa **faili ya JavaScript**. (Kumbuka kwamba CSP kwenye ukurasa uliohatarishwa inaweza kuzuia mashambulizi haya). Wazo hili linatokana na [**hiki andiko**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).

## Muhtasari wa mawasiliano

### Upanuzi <--> WebApp

Ili kuwasiliana kati ya skripti ya maudhui na ukurasa wa wavuti ujumbe wa posta hutumiwa mara nyingi. Hivyo, katika programu ya wavuti mara nyingi utapata wito kwa kazi **`window.postMessage`** na katika skripti ya maudhui wasikilizaji kama **`window.addEventListener`**. Kumbuka hata hivyo, kwamba upanuzi unaweza pia **kuwasiliana na programu ya wavuti kwa kutuma Ujumbe wa Post** (na hivyo wavuti inapaswa kuutarajia) au tu kufanya wavuti ipakue skripti mpya.

### Ndani ya upanuzi

Mara nyingi kazi **`chrome.runtime.sendMessage`** hutumiwa kutuma ujumbe ndani ya upanuzi (mara nyingi inashughulikiwa na skripti ya `background`) na ili kupokea na kushughulikia inatangazwa msikilizaji akitumia **`chrome.runtime.onMessage.addListener`**.

Pia inawezekana kutumia **`chrome.runtime.connect()`** kuwa na muunganisho endelevu badala ya kutuma ujumbe mmoja mmoja, inawezekana kuitumia **kutuma** na **kupokea** **ujumbe** kama katika mfano ufuatao:

<details>

<summary><code>chrome.runtime.connect()</code> mfano</summary>
```javascript
var port = chrome.runtime.connect()

// Listen for messages from the web page
window.addEventListener(
"message",
(event) => {
// Only accept messages from the same window
if (event.source !== window) {
return
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage({ type: "FROM_PAGE", text: event.data.text })
}
},
false
)

// Listen for messages from the background script
port.onMessage.addListener(function (msg) {
console.log("Content script received message from background script:", msg)
// Handle the response message from the background script
})
```
</details>

Pia inawezekana kutuma ujumbe kutoka kwa script ya nyuma hadi script ya maudhui iliyoko katika tab maalum kwa kuita **`chrome.tabs.sendMessage`** ambapo utahitaji kuashiria **ID ya tab** ya kutuma ujumbe.

### Kutoka kwa `externally_connectable` inayoruhusiwa hadi nyongeza

**Programu za wavuti na nyongeza za kivinjari za nje zinazoruhusiwa** katika usanidi wa `externally_connectable` zinaweza kutuma maombi kwa kutumia :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Mahali ambapo inahitajika kutaja **kitambulisho cha nyongeza**.

### Ujumbe wa Asili

Inawezekana kwa skripti za nyuma kuwasiliana na binaries ndani ya mfumo, ambayo yanaweza kuwa **na hatari za msingi kama RCEs** ikiwa mawasiliano haya hayajashughulikiwa ipasavyo. [More on this later](./#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
## Web **↔︎** Mawasiliano ya Skripti za Maudhui

Mazingira ambapo **skripti za maudhui** zinafanya kazi na ambapo kurasa za mwenyeji zipo ni **separated** kutoka kwa kila mmoja, kuhakikisha **isolation**. Licha ya isolation hii, zote zina uwezo wa kuingiliana na **Document Object Model (DOM)** ya ukurasa, rasilimali inayoshirikiwa. Ili ukurasa wa mwenyeji uweze kushiriki katika mawasiliano na **skripti ya maudhui**, au kwa njia isiyo ya moja kwa moja na nyongeza kupitia skripti ya maudhui, inahitajika kutumia **DOM** inayopatikana na pande zote kama njia ya mawasiliano.

### Post Messages
```javascript:content-script.js
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect()

window.addEventListener(
"message",
(event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return
}

if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage(event.data.text)
}
},
false
)
```

```javascript:example.js
document.getElementById("theButton").addEventListener(
"click",
() => {
window.postMessage(
{ type: "FROM_PAGE", text: "Hello from the webpage!" },
"*"
)
},
false
)
```
Mawasiliano salama ya Post Message yanapaswa kuangalia uhalali wa ujumbe ulipokelewa, hii inaweza kufanywa kwa kuangalia:

- **`event.isTrusted`**: Hii ni Kweli tu ikiwa tukio lilichochewa na kitendo cha mtumiaji
- Skripti ya maudhui inaweza kutarajia ujumbe tu ikiwa mtumiaji atafanya kitendo fulani
- **domain ya asili**: inaweza kutarajia ujumbe tu kwenye orodha ya kuruhusiwa ya maeneo.
- Ikiwa regex inatumika, kuwa makini sana
- **Chanzo**: `received_message.source !== window` inaweza kutumika kuangalia ikiwa ujumbe ulikuwa **kutoka kwenye dirisha lile lile** ambapo Skripti ya Maudhui inasikiliza.

Ukaguzi wa awali, hata kama umefanywa, unaweza kuwa na udhaifu, hivyo angalia kwenye ukurasa ufuatao **mipango ya Post Message**:

{{#ref}}
../postmessage-vulnerabilities/
{{#endref}}

### Iframe

Njia nyingine inay posible ya mawasiliano inaweza kuwa kupitia **Iframe URLs**, unaweza kupata mfano katika:

{{#ref}}
browext-xss-example.md
{{#endref}}

### DOM

Hii si "haswa" njia ya mawasiliano, lakini **mtandao na skripti ya maudhui zitakuwa na ufikiaji wa DOM ya wavuti**. Hivyo, ikiwa **skripti ya maudhui** inasoma taarifa fulani kutoka kwake, **ikitegemea DOM ya wavuti**, wavuti inaweza **kubadilisha data hii** (kwa sababu wavuti haipaswi kuaminika, au kwa sababu wavuti ina udhaifu wa XSS) na **kuathiri Skripti ya Maudhui**.

Unaweza pia kupata mfano wa **XSS inayotegemea DOM kuathiri nyongeza ya kivinjari** katika:

{{#ref}}
browext-xss-example.md
{{#endref}}

## Mawasiliano ya Skripti ya Maudhui **↔︎** Skripti ya Nyuma

Skripti ya Maudhui inaweza kutumia kazi [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **au** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) kutuma ujumbe **wa mara moja unaoweza kuandikwa kwa JSON**.

Ili kushughulikia **jibu**, tumia **Promise** iliyorejeshwa. Ingawa, kwa ajili ya ulinganifu wa nyuma, bado unaweza kupitisha **callback** kama hoja ya mwisho.

Kutuma ombi kutoka kwa **skripti ya maudhui** kunaonekana kama hii:
```javascript
;(async () => {
const response = await chrome.runtime.sendMessage({ greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
Kutuma ombi kutoka kwa **extension** (kawaida **background script**). Mfano wa jinsi ya kutuma ujumbe kwa script ya maudhui katika tab iliyochaguliwa:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
;(async () => {
const [tab] = await chrome.tabs.query({
active: true,
lastFocusedWindow: true,
})
const response = await chrome.tabs.sendMessage(tab.id, { greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
Katika **kipande cha kupokea**, unahitaji kuweka [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **mwanachama wa tukio** ili kushughulikia ujumbe. Hii inaonekana sawa kutoka kwa skripti ya maudhui au ukurasa wa nyongeza.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
console.log(
sender.tab
? "from a content script:" + sender.tab.url
: "from the extension"
)
if (request.greeting === "hello") sendResponse({ farewell: "goodbye" })
})
```
Katika mfano ulioangaziwa, **`sendResponse()`** ilitekelezwa kwa njia ya synchronous. Ili kubadilisha mhandisi wa tukio la `onMessage` kwa utekelezaji wa asynchronous wa `sendResponse()`, ni muhimu kuingiza `return true;`.

Kitu muhimu cha kuzingatia ni kwamba katika hali ambapo kurasa nyingi zimewekwa kupokea matukio ya `onMessage`, **kurasa ya kwanza kutekeleza `sendResponse()`** kwa tukio maalum itakuwa pekee inayoweza kutoa jibu kwa ufanisi. Majibu yoyote yanayofuata kwa tukio hilo hilo hayatazingatiwa.

Wakati wa kuunda nyongeza mpya, upendeleo unapaswa kuwa kwa ahadi badala ya callbacks. Kuhusu matumizi ya callbacks, kazi ya `sendResponse()` inachukuliwa kuwa halali tu ikiwa inatekelezwa moja kwa moja ndani ya muktadha wa synchronous, au ikiwa mhandisi wa tukio unaonyesha operesheni ya asynchronous kwa kurudisha `true`. Ikiwa hakuna mhandisi anayerudisha `true` au ikiwa kazi ya `sendResponse()` imeondolewa kutoka kwenye kumbukumbu (garbage-collected), callback inayohusiana na kazi ya `sendMessage()` itachochewa kwa default.

## Ujumbe wa Asili

Nyongeza za kivinjari pia zinaruhusu kuwasiliana na **binaries katika mfumo kupitia stdin**. Programu lazima iweke json ikionyesha hivyo katika json kama:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Mahali ambapo `name` ni mfuatano unaopitishwa kwa [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) au [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) ili kuwasiliana na programu kutoka kwa skripti za nyuma za nyongeza ya kivinjari. `path` ni njia ya binary, kuna aina 1 tu halali ambayo ni stdio (tumia stdin na stdout) na `allowed_origins` inaonyesha nyongeza ambazo zinaweza kuipata (na haziwezi kuwa na wildcard).

Chrome/Chromium itatafuta json hii katika baadhi ya rejista za windows na baadhi ya njia katika macOS na Linux (maelezo zaidi katika [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

> [!TIP]
> Nyongeza ya kivinjari pia inahitaji ruhusa ya `nativeMessaing` kutangazwa ili iweze kutumia mawasiliano haya.

Hivi ndivyo inavyoonekana kama baadhi ya msimbo wa skripti ya nyuma ikituma ujumbe kwa programu asilia:
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
Katika [**hiki kipande cha blogu**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), mfano wa muundo dhaifu unaotumia ujumbe wa asili unapendekezwa:

1. Kiendelezi cha kivinjari kina muundo wa wildcard kwa skripti ya maudhui.
2. Skripti ya maudhui inapita ujumbe wa `postMessage` kwa skripti ya nyuma kwa kutumia `sendMessage`.
3. Skripti ya nyuma inapita ujumbe kwa programu ya asili kwa kutumia `sendNativeMessage`.
4. Programu ya asili inashughulikia ujumbe kwa njia hatari, ikisababisha utekelezaji wa msimbo.

Na ndani yake mfano wa **kuenda kutoka ukurasa wowote hadi RCE kwa kutumia kiendelezi cha kivinjari umeelezewa**.

## Taarifa Nyeti katika Kumbukumbu/Msimbo/Clipboard

Ikiwa Kiendelezi cha Kivinjari kina **taarifa nyeti ndani ya kumbukumbu yake**, hii inaweza **kutolewa** (hasa kwenye mashine za Windows) na **kutafutwa** kwa taarifa hii.

Kwa hivyo, kumbukumbu ya Kiendelezi cha Kivinjari **haipaswi kuzingatiwa kuwa salama** na **taarifa nyeti** kama vile akidi au maneno ya kumbukumbu **haipaswi kuhifadhiwa**.

Kwa hakika, usiweke **taarifa nyeti katika msimbo**, kwani itakuwa **ya umma**.

Ili kutoa kumbukumbu kutoka kwa kivinjari unaweza **kutoa kumbukumbu ya mchakato** au kwenda kwenye **mipangilio** ya kiendelezi cha kivinjari bonyeza **`Inspect pop-up`** -> Katika sehemu ya **`Memory`** -> **`Take a snapshot`** na **`CTRL+F`** kutafuta ndani ya picha ya kumbukumbu kwa taarifa nyeti.

Zaidi ya hayo, taarifa nyeti sana kama vile funguo za kumbukumbu au nywila **hazipaswi kuruhusiwa kunakiliwa kwenye clipboard** (au angalau kuondolewa kutoka kwenye clipboard ndani ya sekunde chache) kwa sababu basi michakato inayofuatilia clipboard itakuwa na uwezo wa kuzipata.

## Kupakia Kiendelezi katika Kivinjari

1. **Pakua** Kiendelezi cha Kivinjari & uondoe zipu
2. Nenda kwenye **`chrome://extensions/`** na **wezesha** `Developer Mode`
3. Bonyeza kitufe cha **`Load unpacked`**

Katika **Firefox** unakwenda kwenye **`about:debugging#/runtime/this-firefox`** na bonyeza kitufe cha **`Load Temporary Add-on`**.

## Kupata msimbo wa chanzo kutoka duka

Msimbo wa chanzo wa kiendelezi cha Chrome unaweza kupatikana kupitia njia mbalimbali. Hapa chini kuna maelezo ya kina na maagizo kwa kila chaguo.

### Pakua Kiendelezi kama ZIP kupitia Mstari wa Amri

Msimbo wa chanzo wa kiendelezi cha Chrome unaweza kupakuliwa kama faili ya ZIP kwa kutumia mstari wa amri. Hii inahusisha kutumia `curl` kupata faili ya ZIP kutoka URL maalum na kisha kutoa yaliyomo ya faili ya ZIP kwenye directory. Hapa kuna hatua:

1. Badilisha `"extension_id"` na ID halisi ya kiendelezi.
2. Tekeleza amri zifuatazo:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Tumia tovuti ya CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Tumia kiendelezi cha CRX Viewer

Njia nyingine rahisi ni kutumia Chrome Extension Source Viewer, ambayo ni mradi wa chanzo wazi. Inaweza kupakuliwa kutoka [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Msimbo wa chanzo wa mtazamaji upatikana katika [GitHub repository](https://github.com/Rob--W/crxviewer).

### Angalia chanzo cha kiendelezi kilichosakinishwa kwa ndani

Viendelezi vya Chrome vilivyowekwa ndani vinaweza pia kukaguliwa. Hapa kuna jinsi:

1. Fikia saraka yako ya wasifu wa Chrome kwa kutembelea `chrome://version/` na kutafuta uwanja wa "Profile Path".
2. Tembelea folda ndogo ya `Extensions/` ndani ya saraka ya wasifu.
3. Folda hii ina viendelezi vyote vilivyowekwa, kwa kawaida na msimbo wao wa chanzo katika muundo unaoweza kusomeka.

Ili kubaini viendelezi, unaweza kuoanisha IDs zao na majina:

- Washa Mode ya Developer kwenye ukurasa wa `about:extensions` ili kuona IDs za kila kiendelezi.
- Ndani ya folda ya kila kiendelezi, faili ya `manifest.json` ina uwanja wa `name` unaoweza kusomeka, ikikusaidia kubaini kiendelezi.

### Tumia Mchambuzi wa Faili au Unpacker

Nenda kwenye Chrome Web Store na upakue kiendelezi. Faili itakuwa na kiambishi cha `.crx`. Badilisha kiambishi cha faili kutoka `.crx` hadi `.zip`. Tumia mchambuzi wowote wa faili (kama WinRAR, 7-Zip, nk.) kutoa yaliyomo ya faili ya ZIP.

### Tumia Mode ya Developer kwenye Chrome

Fungua Chrome na nenda kwenye `chrome://extensions/`. Washa "Developer mode" kwenye kona ya juu kulia. Bonyeza "Load unpacked extension...". Tembelea saraka ya kiendelezi chako. Hii haisaidii kupakua msimbo wa chanzo, lakini ni muhimu kwa kutazama na kubadilisha msimbo wa kiendelezi ambacho tayari kimepakuliwa au kimeandaliwa.

## Seti ya data ya manifest ya kiendelezi cha Chrome

Ili kujaribu kubaini viendelezi vya kivinjari vilivyo hatarini unaweza kutumia [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) na kuangalia faili zao za manifest kwa ishara zinazoweza kuwa hatarini. Kwa mfano kuangalia viendelezi vyenye watumiaji zaidi ya 25000, `content_scripts` na ruhusa `nativeMessaing`:
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
## Orodha ya Ukaguzi wa Usalama

Ingawa Kiongezeo cha Kivinjari kina **uso wa shambulio ulio na mipaka**, baadhi yao wanaweza kuwa na **mapungufu** au **mabadiliko yanayoweza kuimarishwa**. Hizi hapa ni za kawaida zaidi:

- [ ] **Punguza** kadri iwezekanavyo **`permissions`** zinazohitajika
- [ ] **Punguza** kadri iwezekanavyo **`host_permissions`**
- [ ] Tumia **sera thabiti** ya **`content_security_policy`**
- [ ] **Punguza** kadri iwezekanavyo **`externally_connectable`**, ikiwa hakuna inahitajika na inawezekana, usiache kwa chaguo la kawaida, eleza **`{}`**
- [ ] Ikiwa **URL inayoweza kuathiriwa na XSS au kuchukuliwa** imetajwa hapa, mshambuliaji ataweza **kutuma ujumbe kwa scripts za nyuma moja kwa moja**. Njia yenye nguvu ya kupita.
- [ ] **Punguza** kadri iwezekanavyo **`web_accessible_resources`**, hata ikiwa tupu ikiwa inawezekana.
- [ ] Ikiwa **`web_accessible_resources`** si hakuna, angalia [**ClickJacking**](browext-clickjacking.md)
- [ ] Ikiwa mawasiliano yoyote yanatokea kutoka kwa **kiongezeo** hadi **ukurasa wa wavuti**, [**angalia XSS**](browext-xss-example.md) **mapungufu** yaliyosababishwa katika mawasiliano.
- [ ] Ikiwa Post Messages zinatumika, angalia [**Post Message vulnerabilities**](../postmessage-vulnerabilities/)**.**
- [ ] Ikiwa **Content Script inapata maelezo ya DOM**, angalia kwamba hazifanyi **XSS** ikiwa zinabadilishwa na wavuti
- [ ] Fanya mkazo maalum ikiwa mawasiliano haya yanahusishwa pia katika **Mawasiliano ya Content Script -> Script ya Nyuma**
- [ ] Ikiwa script ya nyuma inawasiliana kupitia **ujumbe wa asili** angalia mawasiliano ni salama na yameondolewa
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **msimbo** wa Kiongezeo cha Kivinjari
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **kumbukumbu** ya Kiongezeo cha Kivinjari
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya **mfumo wa faili usio na ulinzi**

## Hatari za Kiongezeo cha Kivinjari

- Programu [https://crxaminer.tech/](https://crxaminer.tech/) inachambua data kama ruhusa ambazo kiongezeo cha kivinjari kinahitaji ili kutoa kiwango cha hatari cha kutumia kiongezeo cha kivinjari.

## Zana

### [**Tarnish**](https://thehackerblog.com/tarnish/)

- Inavuta kiongezeo chochote cha Chrome kutoka kiungo kilichotolewa cha duka la wavuti la Chrome.
- [**manifest.json**](https://developer.chrome.com/extensions/manifest) **mtazamaji**: inaonyesha toleo la JSON lililopambwa la hati ya kiongezeo.
- **Uchambuzi wa Alama**: Ugunduzi wa [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) na uzalishaji wa moja kwa moja wa JavaScript ya alama ya kiongezeo cha Chrome.
- **Uchambuzi wa Hatari ya Clickjacking**: Ugunduzi wa kurasa za HTML za kiongezeo zenye mwelekeo wa [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) zilizowekwa. Hizi zinaweza kuwa na hatari ya clickjacking kulingana na kusudi la kurasa hizo.
- **Mtazamaji wa Onyo la Ruhusa**: unaonyesha orodha ya onyo zote za ruhusa za Chrome ambazo zitaonyeshwa wakati mtumiaji anajaribu kufunga kiongezeo.
- **Kazi Hatari**: inaonyesha eneo la kazi hatari ambazo zinaweza kutumiwa na mshambuliaji (mfano, kazi kama innerHTML, chrome.tabs.executeScript).
- **Nukta za Kuingia**: inaonyesha mahali kiongezeo kinapochukua pembejeo za mtumiaji/za nje. Hii ni muhimu kwa kuelewa eneo la uso la kiongezeo na kutafuta maeneo yanayoweza kutumiwa kutuma data iliyoundwa kwa uovu kwa kiongezeo.
- Wote skana za Kazi Hatari na Nukta za Kuingia zina yafuatayo kwa arifa zao zilizozalishwa:
- Kipande cha msimbo kinachohusiana na mstari ulioleta arifa.
- Maelezo ya tatizo.
- Kitufe cha "Tazama Faili" ili kuona faili kamili ya chanzo inayohusisha msimbo.
- Njia ya faili iliyoarifiwa.
- URI kamili ya kiongezeo cha Chrome ya faili iliyoarifiwa.
- Aina ya faili ni, kama vile script ya Ukurasa wa Nyuma, Script ya Maudhui, Kitendo cha Kivinjari, nk.
- Ikiwa mstari unaoweza kuathiriwa uko katika faili ya JavaScript, njia za kurasa zote ambapo imejumuishwa pamoja na aina za kurasa hizi, na hali ya [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
- **Mchambuzi wa Sera ya Usalama wa Maudhui (CSP) na mchakato wa kupita**: Hii itaonyesha udhaifu katika CSP ya kiongezeo chako na pia itaonyesha njia zozote zinazoweza kupita CSP yako kutokana na CDNs zilizoorodheshwa, nk.
- **Maktaba Zinazojulikana za Hatari**: Hii inatumia [Retire.js](https://retirejs.github.io/retire.js/) kuangalia matumizi ya maktaba za JavaScript zinazojulikana kuwa na hatari.
- Pakua kiongezeo na toleo lililopangwa.
- Pakua kiongezeo asilia.
- Pakua toleo lililopambwa la kiongezeo (HTML na JavaScript iliyopambwa kiotomatiki).
- Hifadhi matokeo ya uchunguzi kiotomatiki, kuendesha uchunguzi wa kiongezeo kutachukua muda mzuri mara ya kwanza unapoendesha. Hata hivyo, mara ya pili, ikiwa kiongezeo hakijasasishwa, itakuwa karibu mara moja kutokana na matokeo kuhifadhiwa.
- URL za Ripoti zinazoweza kuunganishwa, rahisi kuunganisha mtu mwingine kwenye ripoti ya kiongezeo iliyozalishwa na tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Mradi wa Neto ni kifurushi cha Python 3 kilichoundwa kuchambua na kufichua vipengele vilivyofichwa vya nyongeza za kivinjari na kiongezeo kwa vivinjari maarufu kama Firefox na Chrome. Inafanya mchakato wa kufungua faili zilizofungashwa ili kutoa vipengele hivi kutoka kwa rasilimali zinazohusiana katika kiongezeo kama `manifest.json`, folda za lugha au faili za chanzo za Javascript na HTML.

## Marejeleo

- **Shukrani kwa** [**@naivenom**](https://twitter.com/naivenom) **kwa msaada na mbinu hii**
- [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
- [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
- [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
- [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
- [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
- [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
- [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
- [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
- [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{{#include ../../banners/hacktricks-training.md}}
