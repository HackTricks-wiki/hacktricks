# Browser Extension Pentesting Methodology

{{#include ../../banners/hacktricks-training.md}}

## Maelezo ya Msingi

Extensions za browser zimeandikwa kwa JavaScript na zinasomwa na browser kwa background. Ina DOM yake lakini inaweza kuingiliana na DOM za tovuti nyingine. Hii inamaanisha inaweza kuhatarisha usiri, uadilifu, na upatikana (CIA) wa tovuti nyingine.

## Main Components

Mapangilio ya extension yanaonekana bora zaidi yanapoweza kuonekana kwa picha na yanaundwa na vipengele vitatu. Hebu 튜angalie kila kipengele kwa undani.

<figure><img src="../../images/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Content Scripts**

Kila content script ina ufikiaji wa moja kwa moja kwenye DOM ya **single web page** na kwa hivyo inakabiliwa na **potentially malicious input**. Hata hivyo, content script haina ruhusa zaidi isipokuwa uwezo wa kutuma ujumbe kwa extension core.

### **Extension Core**

Extension core ina nyingi ya vibali/ufikiaji vya extension, lakini extension core inaweza kuingiliana na web content tu kupitia XMLHttpRequest na content scripts. Pia, extension core haina ufikiaji wa moja kwa moja kwa host machine.

### **Native Binary**

Extension inaweza kuruhusu native binary ambayo inaweza **access the host machine with the user’s full privileges.** Native binary inaingiliana na extension core kupitia Netscape Plugin Application Programming Interface ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) ya kawaida iliyotumika na Flash na plug-ins nyingine za browser.

### Mipaka

> [!CAUTION]
> Ili kupata user’s full privileges, mshambuliaji lazima amshawishi extension kusafirisha malicious input kutoka content script kwenda extension's core na kutoka extension's core kwenda native binary.

Kila kipengele cha extension kimegawanywa kwa kila mmoja kwa **strong protective boundaries**. Kila kipengele kinaendesha katika **separate operating system process**. Content scripts na extension cores zinaendesha katika **sandbox processes** ambazo hazipatikani kwa huduma nyingi za mfumo wa uendeshaji.

Zaidi ya hayo, content scripts zimetengwa na kurasa zao za wavuti kwa **running in a separate JavaScript heap**. The content script and web page have **access to the same underlying DOM**, lakini vyao viwili **never exchange JavaScript pointers**, preventing the leaking of JavaScript functionality.

## **`manifest.json`**

Extension ya Chrome ni tu folda ya ZIP yenye [.crx file extension](https://www.lifewire.com/crx-file-2620391). Core ya extension ni faili ya **`manifest.json`** kwenye mzizi wa folda, ambayo inaelezea layout, permissions, na chaguzi nyingine za configuration.

Example:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": ["storage"],
"content_scripts": [
{
"js": ["script.js"],
"matches": ["https://example.com/*", "https://www.example.com/*"],
"exclude_matches": ["*://*/*business*"]
}
],
"background": {
"scripts": ["background.js"]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content scripts **zinapakiwa** kila mtumiaji **anapotembelea ukurasa unaofanana**, katika kesi yetu ukurasa wowote unaofanana na usemi **`https://example.com/*`** na usiofanana na regex **`*://*/*/business*`**. Zinakimbia **kama scripts za ukurasa mwenyewe** na zina ufikaji wa aina yoyote kwa [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model).
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Ili kujumuisha au kutokujumuisha URLs zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

Huu ni mfano wa skripti ya maudhui ambayo itaongeza kitufe cha explain kwenye ukurasa wakati [the storage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) itakapotumika ili kupata thamani ya `message` kutoka kwa hifadhi ya extension.
```js
chrome.storage.local.get("message", (result) => {
let div = document.createElement("div")
div.innerHTML = result.message + " <button>Explain</button>"
div.querySelector("button").addEventListener("click", () => {
chrome.runtime.sendMessage("explain")
})
document.body.appendChild(div)
})
```
<figure><img src="../../images/image (23).png" alt=""><figcaption></figcaption></figure>

Ujumbe hutumwa kwa ukurasa za extension na content script wakati kitufe hiki kinabofiwa, kwa kutumia [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Hii ni kutokana na vikwazo vya content script katika ufikiaji wa moja kwa moja wa APIs, huku `storage` ikiwa mojawapo ya vichache vinavyoruhusiwa. Kwa kazi ambazo zinazidi utekelezaji wa vikwazo hivi, ujumbe hutumwa kwa extension pages ambazo content scripts zinaweza kuwasiliana nazo.

> [!WARNING]
> Kulingana na browser, uwezo wa content script unaweza kutofautiana kidogo. Kwa browsers zinazotegemea Chromium, orodha ya uwezo inapatikana katika the [Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), na kwa Firefox, the [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) ni chanzo kikuu.\
> Pia inafaa kutambua kuwa content scripts zina uwezo wa kuwasiliana na background scripts, zikiruhusu kutekeleza vitendo na kurudisha majibu.

Ili kuona na kutatua matatizo ya content scripts katika Chrome, menyu ya Chrome developer tools inaweza kufikiwa kupitia Options > More tools > Developer tools au kwa kubonyeza Ctrl + Shift + I.

Mara tu developer tools zikionekana, bonyeza **Source tab**, kisha **Content Scripts** tab. Hii inaruhusu kuona content scripts zinazoendelea kutoka kwa extensions mbalimbali na kuweka breakpoints ili kufuatilia mtiririko wa utekelezaji.

### Imeingizwa content scripts

> [!TIP]
> Kumbuka kwamba **Content Scripts si lazima** kwani pia inawezekana **dynamically** **kuingiza** scripts na **programatically kuziingiza** kwenye kurasa za wavuti kupitia **`tabs.executeScript`**. Hii kwa kweli inatoa **udhibiti wa kina zaidi**.

Kwa kuingiza content script kwa njia ya programmatic, extension inatakiwa kuwa na [host permissions](https://developer.chrome.com/docs/extensions/reference/permissions) kwa ukurasa ambao scripts zitaingizwa. Ruhusa hizi zinaweza kupatikana kwa kuziomba ndani ya manifest ya extension au kwa muda mfupi kupitia [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Mfano activeTab-based extension
```json:manifest.json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
- **Inject faili ya JS kwa kubonyeza:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange"

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"],
})
})
```
- **Inject a function** wakati wa kubofya:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange"
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
func: injectedFunction,
})
})
```
#### Mfano wenye ruhusa za scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
excludeMatches: ["*://*/*business*"],
js: ["contentScript.js"],
},
])

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" })
```
Ili kujumuisha au kuondoa URL zaidi, pia inawezekana kutumia **`include_globs`** na **`exclude_globs`**.

### Scripts za Maudhui `run_at`

Uwanja wa `run_at` unadhibiti **mara gani faili za JavaScript zinaingizwa kwenye ukurasa wa wavuti**. Thamani inayopendekezwa na ya chaguo-msingi ni `"document_idle"`.

Thamani zinazowezekana ni:

- **`document_idle`**: Kadri inavyowezekana
- **`document_start`**: Baada ya faili yoyote kutoka `css`, lakini kabla DOM nyingine yoyote iundwe au script nyingine yoyote iendeshe.
- **`document_end`**: Mara DOM itakapokamilika, lakini kabla rasilimali ndogo kama picha na frames zimepakiwa.

#### Kupitia `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Kupitia **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
runAt: "document_idle",
js: ["contentScript.js"],
},
])
```
### `background`

Ujumbe unaotumwa na content scripts huwasilishwa kwa **background page**, ambayo inatimiza jukumu kuu la kuratibu vipengele vya extension. Jambo la muhimu, background page inadumu kwa muda wa maisha ya extension, ikifanya kazi kimya bila mwingiliano wa moja kwa moja wa mtumiaji. Ina Document Object Model (DOM) yake mwenyewe, ikiruhusu mwingiliano tata na usimamizi wa hali.

**Key Points**:

- **Background Page Role:** Inafanya kazi kama kitovu cha udhibiti kwa extension, ikihakikisha mawasiliano na uratibu kati ya sehemu mbalimbali za extension.
- **Persistence:** Ni kitu kinachodumu kila wakati, kisichoonekana kwa mtumiaji lakini muhimu kwa utendaji wa extension.
- **Automatic Generation:** Ikiwa haijatamkwa wazi, browser itaunda background page kiotomatiki. Kurasa hii iliyotengenezwa kiotomatiki itajumuisha background scripts zote zilizotajwa kwenye manifest ya extension, kuhakikisha utekelezaji bila matatizo wa kazi za background za extension.

> [!TIP]
> Urahisi unaotolewa na browser kwa kuunda background page kiotomatiki (wakati haijatangazwa wazi) unahakikisha background scripts zote muhimu zimeingizwa na zinafanya kazi, kurahisisha mchakato wa usanidi wa extension.

Mfano wa background script:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
if (request == "explain") {
chrome.tabs.create({ url: "https://example.net/explanation" })
}
})
```
Inatumia [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) kusikiliza ujumbe. Wakati ujumbe wa "explain" unapopokelewa, inatumia [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) kufungua ukurasa kwenye tabo mpya.

Ili ku-debug background script unaweza kwenda kwenye **extension details and inspect the service worker,** hii itaifungua developer tools ikionyesha background script:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Options pages and other

Browser extensions zinaweza kuwa na aina mbalimbali za kurasa:

- **Action pages** zinaonyeshwa katika **drop-down when the extension ico**n is clicked.
- Kurasa ambazo extension itapakia zinaweza kuonekana katika **load in a new tab**.
- **Option Pages**: Ukurasa huu unaonyeshwa juu ya extension wakati unabonyezwa. Katika manifest ya awali, katika kesi yangu niliweza kufikia ukurasa huu katika `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` au kwa kubofya:

<figure><img src="../../images/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Kumbuka kuwa kurasa hizi hazidumu kama background pages kwani zinapakia maudhui dynamically zinapohitajika. Licha ya hayo, zina sifa fulani zinazofanana na background page:

- **Communication with Content Scripts:** Kama background page, kurasa hizi zinaweza kupokea ujumbe kutoka kwa Content Scripts, kuwezesha mwingiliano ndani ya extension.
- **Access to Extension-Specific APIs:** Kurasa hizi zina ufikiaji mpana wa Extension-Specific APIs, kutegemea ruhusa zilizowekwa kwa extension.

### `permissions` & `host_permissions`

**`permissions`** na **`host_permissions`** ni vipengele katika `manifest.json` vinavyoonyesha **ni ruhusa gani** browser extension ina (storage, location...) na **ni kwenye kurasa gani za wavuti**.

Kwa kuwa browser extensions zinaweza kuwa zenye **privileged**, extension yenye nia mbaya au iliyodukuliwa inaweza kumruhusu mshambuliaji **njia mbalimbali za kuiba taarifa nyeti na kumfuatilia mtumiaji**.

Angalia jinsi vipimo hivi vinavyofanya kazi na jinsi vinavyoweza kutumiwa vibaya katika:

{{#ref}}
browext-permissions-and-host_permissions.md
{{#endref}}

### `content_security_policy`

**content security policy** pia inaweza kutangazwa ndani ya `manifest.json`. Ikiwa imewekwa, inaweza kuwa **dhaifu**.

Mipangilio ya default kwa kurasa za browser extension ni ya kufunga kwa kiasi fulani:
```bash
script-src 'self'; object-src 'self';
```
Kwa habari zaidi kuhusu CSP na potential bypasses angalia:


{{#ref}}
../content-security-policy-csp-bypass/
{{#endref}}

### `web_accessible_resources`

Ili ukurasa wa wavuti upate kufikia ukurasa wa Browser Extension, mfano `.html`, ukurasa huu unahitaji kutajwa katika uwanja wa **`web_accessible_resources`** wa `manifest.json`.\
Kwa mfano:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Kurasa hizi zinapatikana kwa URL kama:
```
chrome-extension://<extension-id>/message.html
```
Katika public extensions the **extension-id is accesible**:

<figure><img src="../../images/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Hata hivyo, ikiwa parameter ya `manifest.json` **`use_dynamic_url`** inatumiwa, **id hii inaweza kubadilika**.

> [!TIP]
> Tambua kwamba hata kama ukurasa umeonyeshwa hapa, unaweza kuwa **umehifadhiwa dhidi ya ClickJacking** shukrani kwa **Content Security Policy**. Hivyo pia unahitaji kuangalia (sehemu ya frame-ancestors) kabla ya kuthibitisha kwamba shambulio la ClickJacking linawezekana.

Kuruhusiwa kufikia kurasa hizi kunafanya kurasa hizi kuwa **zinaweza kuwa dhaifu kwa ClickJacking**:


{{#ref}}
browext-clickjacking.md
{{#endref}}

> [!TIP]
> Kuruhusu kurasa hizi kupakiwa tu na extension na si kutoka kwa URL za bahati nasibu kunaweza kuzuia mashambulio ya ClickJacking.

> [!CAUTION]
> Tambua kwamba kurasa kutoka **`web_accessible_resources`** na kurasa nyingine za extension pia zina uwezo wa **kuwasiliana na background scripts**. Kwa hivyo, ikiwa moja ya kurasa hizi ina udhaifu wa **XSS**, inaweza kufungua udhaifu mkubwa.
>
> Zaidi ya hayo, kumbuka kwamba unaweza tu kufungua kurasa zilizoonyeshwa katika **`web_accessible_resources`** ndani ya iframes, lakini kutoka tab mpya inawezekana kufikia ukurasa wowote ndani ya extension ukijua extension ID. Kwa hiyo, ikiwa XSS imetambulika ikitumia vigezo hivyo, inaweza kutumiwa hata kama ukurasa haujatangazwa katika **`web_accessible_resources`**.

### `externally_connectable`

Kulingana na [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), mali ya manifest `"externally_connectable"` inatangaza **ni extensions na kurasa za wavuti gani zinaweza kuungana** na extension yako kupitia [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) na [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

- Ikiwa ufunguo wa **`externally_connectable`** haujatangazwa katika manifest ya extension yako au umeelezwa kama **`"ids": ["*"]`**, **extensions zote zinaweza kuungana, lakini hakuna kurasa za wavuti zinaweza kuungana**.
- Ikiwa **IDs maalum zimejazwa**, kama katika `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **ni programu hizo pekee** zinaweza kuungana.
- Ikiwa **matches** zimeelezwa, app hizo za wavuti zitaweza kuungana:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
- Ikiwa imetajwa kama tupu: **`"externally_connectable": {}`**, hakuna app au wavuti itakayoweza kuunganishwa.

Kadri idadi ya extensions na URLs zilizoonyeshwa hapa zitakavyokuwa chache, ndivyo attack surface itakavyokuwa ndogo.

> [!CAUTION]
> Ikiwa ukurasa wa wavuti **unaoweza kuathiriwa na XSS au takeover** umeonyeshwa katika **`externally_connectable`**, mshambuliaji ataweza **kutuma messages moja kwa moja kwa background script**, akikwepa kabisa Content Script na CSP yake.
>
> Kwa hivyo, hili ni **bypass yenye nguvu sana**.
>
> Zaidi ya hayo, ikiwa client ataweka rogue extension, hata kama hauruhusiwi kuwasiliana na extension iliyo vunjwa, inaweza kuingiza **XSS data in an allowed web page** au kutumia vibaya **`WebRequest`** au **`DeclarativeNetRequest`** APIs kubadilisha requests kwenye domain lengwa, ikibadilisha request ya ukurasa kwa ajili ya **JavaScript file**. (Kumbuka kwamba CSP kwenye ukurasa lengwa inaweza kuzuia mashambulizi haya). This idea comes [**from this writeup**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).

## Muhtasari wa Mawasiliano

### Extension <--> WebApp

Ili kuwasiliana kati ya content script na ukurasa wa wavuti, kwa kawaida hutumika post messages. Kwa hivyo, katika web application utapata mara nyingi viito kwa function **`window.postMessage`** na katika content script listeners kama **`window.addEventListener`**. Kumbuka, hata hivyo, kwamba extension pia inaweza **kuwasiliana na web application kwa kutuma Post Message** (na kwa hivyo web inapaswa kutegemea hilo) au hatua rahisi ni kumfanya web ipakie script mpya.

### Ndani ya extension

Kawaida function **`chrome.runtime.sendMessage`** hutumika kutuma ujumbe ndani ya extension (kwa kawaida hushughulikiwa na `background` script) na ili kupokea na kushughulikia ujumbe huo listener hutangazwa kwa kutumia **`chrome.runtime.onMessage.addListener`**.

Pia inawezekana kutumia **`chrome.runtime.connect()`** kupata muunganisho wa kudumu badala ya kutuma ujumbe moja moja; inawezekana kuitumia **kutuma** na **kupokea** **messages** kama katika mfano ufuatao:

<details>

<summary><code>chrome.runtime.connect()</code> mfano</summary>
```javascript
var port = chrome.runtime.connect()

// Listen for messages from the web page
window.addEventListener(
"message",
(event) => {
// Only accept messages from the same window
if (event.source !== window) {
return
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage({ type: "FROM_PAGE", text: event.data.text })
}
},
false
)

// Listen for messages from the background script
port.onMessage.addListener(function (msg) {
console.log("Content script received message from background script:", msg)
// Handle the response message from the background script
})
```
</details>

Pia inawezekana kutuma ujumbe kutoka background script kwenda content script iliyoko kwenye tab maalum kwa kuita **`chrome.tabs.sendMessage`** ambapo utahitaji kuonyesha **ID of the tab** ili kutuma ujumbe.

### Kutoka kwa `externally_connectable` zilizoruhusiwa kwenda kwa extension

**Programu za wavuti na extension za kivinjari za nje zilizoruhusiwa** katika usanidi wa `externally_connectable` zinaweza kutuma ombi kwa kutumia :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Wakati inapohitajika kutaja **extension ID**.

### Native Messaging

Inawezekana kwa skripti za background kuwasiliana na faili za binari ndani ya mfumo, ambayo yanaweza kuwa **nyeti kwa udhaifu mkubwa kama RCEs** ikiwa mawasiliano haya hayatakuwa salama ipasavyo. [Taarifa zaidi baadaye](#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
## Web **↔︎** Mawasiliano ya Content Script

Mazingira ambapo **content scripts** zinafanya kazi na ambako kurasa za mwenyeji zipo **imegawanywa** kutoka kwa kila mmoja, zikihakikisha **utengwa**. Licha ya **utengwa** huu, pande zote zina uwezo wa kuingiliana na **Document Object Model (DOM)** ya ukurasa, rasilimali inayoshirikishwa. Ili ukurasa mwenyeji uweze kujihusisha katika mawasiliano na **content script**, au kwa njia isiyo ya moja kwa moja na extension kupitia **content script**, inahitajika kutumia **DOM** inayopatikana kwa pande zote kama njia ya mawasiliano.

### Post Messages
```javascript:content-script.js
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect()

window.addEventListener(
"message",
(event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return
}

if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage(event.data.text)
}
},
false
)
```

```javascript:example.js
document.getElementById("theButton").addEventListener(
"click",
() => {
window.postMessage(
{ type: "FROM_PAGE", text: "Hello from the webpage!" },
"*"
)
},
false
)
```
Mawasiliano salama ya Post Message yanapaswa kukagua uhalali wa ujumbe uliopokelewa, hili linaweza kufanywa kwa kukagua:

- **`event.isTrusted`**: Hii ni True tu ikiwa tukio liliamshwa na kitendo cha mtumiaji
- Content Script inaweza kutarajia ujumbe tu ikiwa mtumiaji atafanya kitendo fulani
- **origin domain**: inaweza kutarajia ujumbe tu kutoka kwenye orodha ya kuruhusiwa ya domains.
- Ikiwa regex inatumiwa, kuwa mwangalifu sana
- **Source**: `received_message.source !== window` inaweza kutumika kukagua kama ujumbe ulikuwa **kutoka window ile ile** ambapo Content Script inasikiliza.

Ukaguzi ulio hapo juu, hata ukifanywa, unaweza kuwa na udhaifu; angalia ukurasa ufuatao kwa **potential Post Message bypasses**:


{{#ref}}
../postmessage-vulnerabilities/
{{#endref}}

### Iframe

Njia nyingine ya mawasiliano inaweza kuwa kupitia **Iframe URLs**, unaweza kupata mfano katika:


{{#ref}}
browext-xss-example.md
{{#endref}}

### DOM

Hii si "kabisa" njia ya mawasiliano, lakini **web na content script zitakuwa na ufikiaji wa web DOM**. Kwa hivyo, ikiwa **content script** inasoma baadhi ya taarifa kutoka kwake, ikiikubali web DOM, web inaweza **kubadilisha data hii** (kwa sababu web haipaswi kuaminiwa, au kwa sababu web ina udhaifu wa XSS) na **kuathiri Content Script**.

Unaweza pia kupata mfano wa **DOM based XSS to compromise a browser extension** katika:


{{#ref}}
browext-xss-example.md
{{#endref}}

## Content Script **↔︎** Background Script Communication

Content Script inaweza kutumia functions [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **au** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) kutuma ujumbe wa **one-time JSON-serializable**.

Ili kushughulikia **response**, tumia **Promise** iliyorejeshwa. Ingawa, kwa backward compatibility, bado unaweza kupitisha **callback** kama hoja ya mwisho.

Kutuma ombi kutoka kwa **content script** inaonekana hivi:
```javascript
;(async () => {
const response = await chrome.runtime.sendMessage({ greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
Kutuma ombi kutoka kwa **extension** (kawaida kwa **background script**). Mfano wa jinsi ya kutuma ujumbe kwa content script kwenye tab iliyochaguliwa:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
;(async () => {
const [tab] = await chrome.tabs.query({
active: true,
lastFocusedWindow: true,
})
const response = await chrome.tabs.sendMessage(tab.id, { greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
Kwa upande wa **kupokea**, unahitaji kuweka [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **msikilizaji wa matukio** ili kushughulikia ujumbe. Hii inaonekana sawa kutoka kwa script ya maudhui au ukurasa wa extension.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
console.log(
sender.tab
? "from a content script:" + sender.tab.url
: "from the extension"
)
if (request.greeting === "hello") sendResponse({ farewell: "goodbye" })
})
```
Katika mfano uliotajwa, **`sendResponse()`** ilitekelezwa kwa njia synchronous. Ili kurekebisha event handler ya `onMessage` kwa utekelezaji wa asynchronous wa `sendResponse()`, ni muhimu kujumuisha `return true;`.

Jambo muhimu la kuzingatia ni kwamba katika matukio ambapo kurasa nyingi zimewekwa kupokea matukio ya `onMessage`, **ukurasa wa kwanza kutekeleza `sendResponse()`** kwa tukio maalum utakuwa yule pekee atakayewawezesha kuwasilisha jibu kwa ufanisi. Majibu yoyote yanayofuata kwa tukio hilo hayatazingatiwa.

Wakati wa kutengeneza extensions mpya, inashauriwa kutumia promises badala ya callbacks. Kuhusu matumizi ya callbacks, kazi ya `sendResponse()` inachukuliwa kuwa halali tu ikiwa inatekelezwa moja kwa moja ndani ya muktadha wa synchronous, au ikiwa event handler inaonyesha operesheni ya asynchronous kwa kurudisha `true`. Iwapo hakuna handler atakayerudisha `true` au ikiwa `sendResponse()` itaondolewa kwenye kumbukumbu (garbage-collected), callback inayohusiana na `sendMessage()` itaitwa kwa chaguo-msingi.

## Native Messaging

Browser extensions pia zinawezesha kuwasiliana na **binaries in the system via stdin**. Programu lazima iweke json inayobainisha hivyo katika json kama:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
Ambapo `name` ni string inayopitishwa kwa [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) au [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage) kwa ajili ya kuwasiliana na application kutoka kwa background scripts ya extension ya kivinjari. `path` ni njia (path) ya binary, kuna tu `type` 1 halali ambayo ni stdio (tumia stdin na stdout) na `allowed_origins` inaonyesha extensions zinazoweza kuifikia (na haiwezi kuwa na wildcard).

Chrome/Chromium itatafuta json hii kwenye Windows registry fulani na baadhi ya paths kwenye macOS na Linux (maelezo zaidi kwenye [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

> [!TIP]
> Extension ya kivinjari pia inahitaji ruhusa ya `nativeMessaing` iliyotangazwa ili iweze kutumia mawasiliano haya.

Hivi ndivyo inavyoonekana baadhi ya code za background script zinapotuma ujumbe kwa native application:
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
In [**this blog post**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), mpangilio dhaifu unaotumia native messages umependekezwa:

1. Browser extension ina wildcard pattern kwa content script.
2. Content script hupitisha ujumbe wa `postMessage` kwenda background script kwa kutumia `sendMessage`.
3. Background script hupitisha ujumbe kwa native application kwa kutumia `sendNativeMessage`.
4. Native application inashughulikia ujumbe kwa njia hatari, ikisababisha code execution.

Ndani yake kuna mfano wa **kuenda kutoka ukurasa wowote hadi RCE ukitumia browser extension**.

## Sensitive Information in Memory/Code/Clipboard

Ikiwa Browser Extension inahifadhi **taarifa nyeti ndani ya memory yake**, hizi zinaweza **kudumped** (hasa kwenye mashine za Windows) na **kutafutwa** kwa ajili ya taarifa hizo.

Kwa hivyo, memory ya Browser Extension **haipaswi kuchukuliwa kuwa salama** na **taarifa nyeti** kama vile credentials au mnemonic phrases **hazipaswi kuhifadhiwa**.

Kweli kabisa, usiweweka taarifa nyeti kwenye code, kwani itakuwa **public**.

Ili dump memory kutoka kwa browser unaweza **kudump the process memory** au kwenda kwenye **settings** za browser extension kisha ubofye **`Inspect pop-up`** -> Katika sehemu ya **`Memory`** -> **`Take a snaphost`** na **`CTRL+F`** kutafuta ndani ya snapshot kwa taarifa nyeti.

Zaidi ya hayo, taarifa zenye ulinzi mkubwa kama mnemonic keys au passwords **hazipaswi kuruhusiwa kukopiwa kwenye clipboard** (au angalau zitoe kutoka clipboard ndani ya sekunde chache) kwani basi michakato inayos-monitor clipboard itawaweza kuzichukua.

## Kupakia Extension kwenye Kivinjari

1. **Pakua** Browser Extension na ifungue (unzip)
2. Nenda kwenye **`chrome://extensions/`** na **wezeshwa** `Developer Mode`
3. Bonyeza kitufe cha **`Load unpacked`**

Katika **Firefox** nenda kwa **`about:debugging#/runtime/this-firefox`** na ubofye kitufe cha **`Load Temporary Add-on`**.

## Getting the source code from the store

Msimbo chanzo wa Chrome extension unaweza kupatikana kwa njia mbalimbali. Hapo chini kuna maelezo ya kina na maelekezo kwa kila chaguo.

### Download Extension as ZIP via Command Line

Msimbo chanzo wa Chrome extension unaweza kupakuliwa kama faili ZIP ukitumia command line. Hii inahusisha kutumia `curl` kuvuta faili la ZIP kutoka URL maalum kisha kutoa yaliyomo ya ZIP kwenda kwenye directory. Hapa kuna hatua:

1. Badilisha `"extension_id"` na ID halisi ya extension.
2. Tekeleza amri zifuatazo:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Tumia tovuti ya CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Tumia extension ya CRX Viewer

Njia nyingine inayofaa ni kutumia Chrome Extension Source Viewer, ambayo ni mradi wa open-source. Inaweza kusanikishwa kutoka kwenye [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Msimbo wa chanzo wa viewer upo kwenye [GitHub repository](https://github.com/Rob--W/crxviewer).

### Angalia chanzo la extension iliyosakinishwa kwa ndani

Chrome extensions zilizowekwa kwa ndani pia zinaweza kuchunguzwa. Hivi ndivyo:

1. Fikia saraka ya profile ya Chrome iliyoko kwenye kompyuta yako kwa kutembelea `chrome://version/` na kutafuta uwanja wa "Profile Path".
2. Nenda kwenye saraka ndogo `Extensions/` ndani ya saraka ya profile.
3. Folda hii ina extensions zote zilizosakinishwa, kwa kawaida pamoja na source code yao katika muundo unaosomwa.

Ili kutambua extensions, unaweza kuoanisha ID zao na majina:

- Washa Developer Mode kwenye ukurasa wa `about:extensions` ili kuona ID za kila extension.
- Ndani ya kila folda ya extension, faili ya `manifest.json` ina uwanja unaosomwa wa `name` utakaokusaidia kutambua extension.

### Tumia File Archiver au Unpacker

Nenda Chrome Web Store na pakua extension. Faili itakuwa na extension `.crx`. Badilisha extension ya faili kutoka `.crx` hadi `.zip`. Tumia file archiver yoyote (kama WinRAR, 7-Zip, nk.) ili kutoa yaliyomo ya faili la ZIP.

### Tumia Developer Mode katika Chrome

Fungua Chrome na nenda `chrome://extensions/`. Washa "Developer mode" juu kulia. Bonyeza "Load unpacked extension...". Elekea kwenye saraka ya extension yako. Hii haitapakua source code, lakini ni muhimu kwa kuona na kuhariri code ya extension iliyopakuliwa au iliyotengenezwa tayari.

## Chrome extension manifest dataset

Ili kujaribu kubaini browser extensions zenye udhaifu unaweza kutumia the[https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset) na kukagua faili zao za manifest kwa dalili zinazoweza kuwa za udhaifu. Kwa mfano, ili kuangalia extensions zenye zaidi ya watumiaji 25000, `content_scripts` na ruhusa `nativeMessaing`:
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
## Post-exploitation: Forced extension load & persistence (Windows)

Mbinu ya kimya kusababisha backdoor kwenye Chromium kwa kuhariri moja kwa moja per-user Preferences na kutengeneza HMACs halali, ambayo husababisha browser kukubali na kuamsha arbitrary unpacked extension bila prompts au flags.

{{#ref}}
forced-extension-load-preferences-mac-forgery-windows.md
{{#endref}}

## Orodha ya Ukaguzi wa Usalama

Ingawa Browser Extensions zina **limited attack surface**, baadhi yao zinaweza kuwa na **vulnerabilities** au **potential hardening improvements**. Zifuatazo ni za kawaida:

- [ ] **Punguza** kadri iwezekanavyo `permissions` zinazohitajika
- [ ] **Punguza** kadri iwezekanavyo `host_permissions`
- [ ] Tumia **strong** `content_security_policy`
- [ ] **Punguza** kadri iwezekanavyo `externally_connectable`; ikiwa haifai au haitegemezeki, usiache kwa default, weka **`{}`**
- [ ] Ikiwa URL inayoweza kuwa vulnerable to XSS au takeover imetajwa hapa, mshambuliaji ataweza **kutuma messages kwa background scripts moja kwa moja**. Bypass yenye nguvu sana.
- [ ] **Punguza** kadri iwezekanavyo `web_accessible_resources`, hata ikiwa ni tupu ikiwa inawezekana.
- [ ] Ikiwa `web_accessible_resources` si none, angalia kwa [**ClickJacking**](browext-clickjacking.md)
- [ ] Ikiwa mawasiliano yoyote yanafanyika kutoka kwa extension kwenda kwenye web page, [**angalia kwa XSS**](browext-xss-example.md) **vulnerabilities** zinazotokana katika mawasiliano.
- [ ] Ikiwa Post Messages zinatumika, angalia kwa [**Post Message vulnerabilities**](../postmessage-vulnerabilities/index.html)**.**
- [ ] Ikiwa Content Script inapata ufikiaji wa DOM details, hakikisha kuwa haileti XSS ikiwa zitabadilishwa na web
- [ ] Toa mkazo maalum ikiwa mawasiliano haya ni sehemu ya **Content Script -> Background script communication**
- [ ] Ikiwa background script yanawasiliana kupitia **native messaging**, hakikisha mawasiliano ni salama na yamefanyiwa sanitize
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya code ya Browser Extension
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** ndani ya memory ya Browser Extension
- [ ] **Taarifa nyeti hazipaswi kuhifadhiwa** kwenye file system bila ulinzi

## Browser Extension Risks

- App [https://crxaminer.tech/](https://crxaminer.tech/) inachambua baadhi ya data kama `permissions` ambazo browser extension inaomba ili kutoa level ya hatari ya kutumia browser extension.

## Tools

### [**Tarnish**](https://thehackerblog.com/tarnish/)

- Inashusha Chrome extension yoyote kutoka kwa provided Chrome webstore link.
- [**manifest.json**](https://developer.chrome.com/extensions/manifest) **viewer**: inaonyesha tu toleo la JSON lililosafishwa la manifest ya extension.
- **Fingerprint Analysis**: Ugundaji wa [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) na uzalishaji wa moja kwa moja wa Chrome extension fingerprinting JavaScript.
- **Potential Clickjacking Analysis**: Ugundaji wa kurasa za HTML za extension zilizo na directive ya [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) imewezeshwa. Hizi zinaweza kuwa zinazoathiriwa na clickjacking kulingana na kusudi la kurasa.
- **Permission Warning(s) viewer**: inaonyesha orodha ya warnings zote za Chrome permission prompt ambazo zitaonekana wakati mtumiaji anapo jaribu kusanisha extension.
- **Dangerous Function(s)**: inaonyesha mahali pa functions hatari ambazo zinaweza kutumika na mshambuliaji (kwa mfano functions kama innerHTML, chrome.tabs.executeScript).
- **Entry Point(s)**: inaonyesha wapi extension inapata input ya mtumiaji/ya nje. Hii ni muhimu kwa kuelewa surface area ya extension na kutafuta pointi za kutuma data iliyochorwa kwa usalama kwa extension.
- Scanner za Dangerous Function(s) na Entry Point(s) zinaripoti zifuatazo kwa alerts zao:
  - Kipande cha code kinachohusiana na line ambayo ilisababisha alert.
  - Maelezo ya tatizo.
  - Kitufe “View File” kuona faili kamili la chanzo linalohusiana na code.
  - Path ya faili iliyoelezwa.
  - URI kamili ya Chrome extension ya faili iliyoelezwa.
  - Aina ya faili, kama Background Page script, Content Script, Browser Action, n.k.
  - Ikiwa line yenye udhaifu iko kwenye faili la JavaScript, paths za kurasa zote ambapo imejumuishwa pamoja na aina za kurasa hizo, na status ya [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
- **Content Security Policy (CSP) analyzer and bypass checker**: Hii itaonyesha udhaifu katika CSP ya extension yako na pia itaonyesha njia zinazoweza kutumika kupitisha CSP yako kutokana na CDNs zilizo kwenye whitelist, n.k.
- **Known Vulnerable Libraries**: Inatumia [Retire.js](https://retirejs.github.io/retire.js/) kutafuta matumizi ya maktaba za JavaScript zilizo na vulnerabilities zinazojulikana.
- Pakua extension na matoleo yaliyoandaliwa.
- Pakua extension asilia.
- Pakua toleo lililosafishwa la extension (HTML na JavaScript zimepangwa vizuri).
- Caching ya matokeo ya skeni kwa kiotomatiki; kukimbia skeni itachukua muda mzito mara ya kwanza. Mara ya pili itakuwa karibu mara moja ikiwa extension haijatengenezwa upya.
- Linkable Report URLs, rahisi kumtumia mtu mwingine link ya ripoti ya extension iliyotengenezwa na tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Mradi Neto ni package ya Python 3 iliyoundwa kuchambua na kufichua sifa zilizojificha za browser plugins na extensions kwa browsers zinazojulikana kama Firefox na Chrome. Inafanya automatiska mchakato wa kufungua faili zilizopakiwa (unzipping) ili kukusanya sifa hizi kutoka kwa rasilimali muhimu ndani ya extension kama `manifest.json`, folda za localization au vyanzo vya Javascript na HTML.

## References

- **Thanks to** [**@naivenom**](https://twitter.com/naivenom) **for the help with this methodology**
- [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
- [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
- [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
- [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
- [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
- [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
- [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
- [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
- [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{{#include ../../banners/hacktricks-training.md}}
