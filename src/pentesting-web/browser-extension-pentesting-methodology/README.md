# 브라우저 확장 Pentesting Methodology

{{#include ../../banners/hacktricks-training.md}}

## 기본 정보

Browser extensions은 JavaScript로 작성되며 브라우저에 의해 백그라운드에서 로드됩니다. 확장에는 자체 [DOM](https://www.w3schools.com/js/js_htmldom.asp)이 있지만 다른 사이트의 DOM과 상호작용할 수 있습니다. 이는 다른 사이트의 기밀성, 무결성 및 가용성 (CIA)을 침해할 수 있음을 의미합니다.

## 주요 구성 요소

Extension layouts는 시각화했을 때 가장 잘 보이며 세 가지 구성 요소로 이루어져 있습니다. 각 구성 요소를 자세히 살펴보겠습니다.

<figure><img src="../../images/image (16) (1) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Content Scripts**

각 content script는 **단일 웹 페이지**의 DOM에 직접 접근할 수 있으므로 **잠재적으로 악성 입력**에 노출됩니다. 그러나 content script는 extension core에 메시지를 보내는 기능 이외의 권한은 포함하지 않습니다.

### **Extension Core**

extension core는 확장의 대부분의 권한/접근을 포함하지만, extension core는 웹 콘텐츠와 [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) 및 content scripts를 통해서만 상호작용할 수 있습니다. 또한 extension core는 호스트 머신에 직접 접근할 수 없습니다.

### **Native Binary**

확장은 사용자의 전체 권한으로 호스트 머신에 접근할 수 있는 native binary를 허용할 수 있습니다. native binary는 Flash 및 기타 브라우저 플러그인에서 사용되는 표준 Netscape Plugin Application Programming Interface ([NPAPI](https://en.wikipedia.org/wiki/NPAPI))를 통해 extension core와 상호작용합니다.

### 경계

> [!CAUTION]
> 사용자의 전체 권한을 얻으려면, 공격자는 content script에서 extension core로, 그리고 extension core에서 native binary로 악성 입력을 전달하도록 확장을 설득해야 합니다.

확장의 각 구성 요소는 서로 간에 **강력한 보호 경계**로 분리되어 있습니다. 각 구성 요소는 **별도의 운영 체제 프로세스**에서 실행됩니다. Content scripts와 extension cores는 대부분의 운영 체제 서비스에서 사용할 수 없는 **sandbox 프로세스**에서 실행됩니다.

더욱이, content scripts는 연관된 웹 페이지와 **별도의 JavaScript 힙에서 실행**됨으로써 분리됩니다. content script와 웹 페이지는 **동일한 기본 DOM에 접근**할 수 있지만, 두 객체는 **절대 JavaScript 포인터를 교환하지 않으며**, 이는 JavaScript 기능의 leaking을 방지합니다.

## **`manifest.json`**

A Chrome extension은 [.crx file extension](https://www.lifewire.com/crx-file-2620391)을 가진 단순한 ZIP 폴더입니다. 확장의 핵심은 폴더 루트에 있는 **`manifest.json`** 파일로, 레이아웃, 권한 및 기타 구성 옵션을 지정합니다.

Example:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": ["storage"],
"content_scripts": [
{
"js": ["script.js"],
"matches": ["https://example.com/*", "https://www.example.com/*"],
"exclude_matches": ["*://*/*business*"]
}
],
"background": {
"scripts": ["background.js"]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content scripts는 사용자가 **일치하는 페이지로 이동할 때마다** **로드됩니다**. 우리의 경우 **`https://example.com/*`** 표현과 일치하고 **`*://*/*/business*`** 정규식과 일치하지 않는 모든 페이지가 해당됩니다. 이들은 **페이지의 고유한 스크립트처럼 실행되며** 페이지의 [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)에 임의로 접근할 수 있습니다.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
더 많은 URL을 포함하거나 제외하려면 **`include_globs`**와 **`exclude_globs`**를 사용할 수도 있습니다.

다음은 [the storage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage)를 사용하여 확장 프로그램의 저장소에서 `message` 값을 가져올 때 페이지에 explain 버튼을 추가하는 예시 content script입니다.
```js
chrome.storage.local.get("message", (result) => {
let div = document.createElement("div")
div.innerHTML = result.message + " <button>Explain</button>"
div.querySelector("button").addEventListener("click", () => {
chrome.runtime.sendMessage("explain")
})
document.body.appendChild(div)
})
```
<figure><img src="../../images/image (23).png" alt=""><figcaption></figcaption></figure>

이 버튼이 클릭되면 content script에 의해 extension pages로 메시지가 전송되며, 이는 [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage)를 이용해서 이루어진다. 이는 content script가 API에 직접 접근하는 데 제한이 있기 때문이며, `storage`는 그 몇 안 되는 예외 중 하나다. 이러한 예외를 벗어나는 기능들은 extension pages로 메시지를 보내어 content scripts가 통신하게 된다.

> [!WARNING]
> 브라우저에 따라 content script의 기능이 약간씩 다를 수 있다. Chromium 기반 브라우저의 경우 기능 목록은 [Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities)에서 확인할 수 있고, Firefox의 경우 주요 출처는 [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis)이다.\
> 또한 content scripts는 background scripts와 통신할 수 있어 작업을 수행하고 응답을 다시 전달할 수 있다는 점도 주목할 만하다.

Chrome에서 content scripts를 보고 디버깅하려면 Chrome developer tools 메뉴에서 Options > More tools > Developer tools로 이동하거나 Ctrl + Shift + I를 눌러 개발자 도구를 열면 된다.

개발자 도구가 표시되면 **Source tab**을 클릭한 다음 **Content Scripts** 탭을 클릭한다. 이를 통해 여러 확장 프로그램에서 실행 중인 content scripts를 관찰하고 브레이크포인트를 설정해 실행 흐름을 추적할 수 있다.

### 주입된 content scripts

> [!TIP]
> 참고로 **Content Scripts aren't mandatory** — 웹페이지에 스크립트를 **동적으로** inject하거나 프로그래밍 방식으로 inject하는 것이 가능하며, 이를 통해 **tabs.executeScript**를 사용해 주입할 수 있다. 이는 실제로 더 **세밀한 제어**를 제공한다.

content script를 프로그래밍 방식으로 주입하려면, 확장은 스크립트를 주입하려는 페이지에 대한 [host permissions](https://developer.chrome.com/docs/extensions/reference/permissions)를 가지고 있어야 한다. 이러한 권한은 확장 manifest 내에서 **요청**하여 확보하거나 [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)를 통해 임시로 얻을 수 있다.

#### activeTab 기반 확장 예제
```json:manifest.json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
- **클릭 시 JS 파일 Inject:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange"

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"],
})
})
```
- **함수 주입** 클릭 시:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange"
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
func: injectedFunction,
})
})
```
#### 스크립팅 권한 예시
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
excludeMatches: ["*://*/*business*"],
js: ["contentScript.js"],
},
])

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" })
```
In order to include or exclude more URLs it's also possible to use **`include_globs`** and **`exclude_globs`**.

### 콘텐츠 스크립트 `run_at`

The `run_at` field controls **언제 JavaScript 파일이 웹 페이지에 주입되는지**. The preferred and default value is `"document_idle"`.

The possible values are:

- **`document_idle`**: 가능한 경우
- **`document_start`**: `css`의 파일들 이후에, 하지만 다른 DOM이 구성되거나 다른 스크립트가 실행되기 전에.
- **`document_end`**: DOM이 완성된 직후이지만, 이미지나 프레임 같은 하위 리소스가 로드되기 전.

#### `manifest.json`에서
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
다음 파일인 **`service-worker.js`**를 통해
```javascript
chrome.scripting.registerContentScripts([
{
id: "test",
matches: ["https://*.example.com/*"],
runAt: "document_idle",
js: ["contentScript.js"],
},
])
```
### `background`

content scripts가 보낸 메시지는 확장 프로그램의 구성 요소를 조정하는 중심 역할을 하는 **백그라운드 페이지**에서 수신됩니다. 특히, 백그라운드 페이지는 확장 프로그램의 수명 동안 지속적으로 존재하며 사용자가 직접 상호작용하지 않아도 조용히 동작합니다. 자체 Document Object Model (DOM)을 가지므로 복잡한 상호작용과 상태 관리를 수행할 수 있습니다.

**핵심 포인트**:

- **백그라운드 페이지 역할:** 확장 프로그램의 다양한 부분 간 통신과 조정을 보장하는 신경중추 역할을 합니다.
- **지속성:** 사용자에게는 보이지 않지만 확장 기능의 동작에 필수적인 상시 존재입니다.
- **자동 생성:** 명시적으로 정의되지 않으면 브라우저가 자동으로 백그라운드 페이지를 생성합니다. 이 자동 생성된 페이지에는 확장 프로그램의 manifest에 지정된 모든 백그라운드 스크립트가 포함되어 확장 기능의 백그라운드 작업이 원활하게 실행되도록 합니다.

> [!TIP]
> 브라우저가 (명시적으로 선언되지 않았을 때) 백그라운드 페이지를 자동으로 생성해 주는 편의성은 필요한 모든 백그라운드 스크립트가 통합되어 작동하도록 하여 확장 설정 과정을 간소화합니다.

Example background script:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
if (request == "explain") {
chrome.tabs.create({ url: "https://example.net/explanation" })
}
})
```
It uses [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) to listen to messages. When an `"explain"` message is received, it uses [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) to open a page in a new tab.

이는 [runtime.onMessage API]를 사용해 메시지를 수신합니다. `"explain"` 메시지를 받으면 [tabs API]를 사용해 새 탭에서 페이지를 엽니다.

To debug the background script you could go to the **extension details and inspect the service worker,** this will open the developer tools with the background script:

background script을 디버그하려면 **확장 프로그램 세부 정보에서 service worker를 검사**하면 개발자 도구에서 background script가 열립니다:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Options pages and other

Browser extensions can contain various kinds of pages:

- **Action pages** are displayed in a **drop-down when the extension ico**n is clicked.
- Pages that the extension will **load in a new tab**.
- **Option Pages**: This page displays on top of the extension when clicked. In the previous manifest In my case I was able to access this page in `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` or clicking:

브라우저 확장 프로그램에는 여러 종류의 페이지가 포함될 수 있습니다:

- **Action pages**는 확장 아이콘을 클릭했을 때 표시되는 드롭다운에 나타납니다.
- 확장 프로그램이 **새 탭에서 로드할** 페이지들.
- **Option Pages**: 이 페이지는 클릭하면 확장 프로그램 위에 표시됩니다. 이전 manifest에서는 제 경우 `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` 또는 클릭으로 이 페이지에 접근할 수 있었습니다:

<figure><img src="../../images/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Note that these pages aren't persistent like background pages as they load dynamically content on necessity. Despite this, they share certain capabilities with the background page:

- **Communication with Content Scripts:** Similar to the background page, these pages can receive messages from content scripts, facilitating interaction within the extension.
- **Access to Extension-Specific APIs:** These pages enjoy comprehensive access to extension-specific APIs, subject to the permissions defined for the extension.

이 페이지들은 필요할 때 동적으로 콘텐츠를 로드하기 때문에 background pages처럼 지속적이지 않습니다. 그럼에도 불구하고 background page와 몇 가지 기능을 공유합니다:

- **Communication with Content Scripts:** background page와 마찬가지로 이 페이지들은 content scripts로부터 메시지를 수신할 수 있어 확장 내부 상호작용을 용이하게 합니다.
- **Access to Extension-Specific APIs:** 이 페이지들은 확장에 정의된 권한에 따라 확장 전용 API에 광범위하게 접근할 수 있습니다.

### `permissions` & `host_permissions`

**`permissions`** and **`host_permissions`** are entries from the `manifest.json` that will indicate **which permissions** the browser extensions has (storage, location...) and in **which web pages**.

**`permissions`**와 **`host_permissions`**는 `manifest.json`의 항목으로, 브라우저 확장 프로그램이 어떤 권한(storage, location...)을 가지는지와 어떤 웹 페이지에서 적용되는지를 나타냅니다.

As browser extensions can be so **privileged**, a malicious one or one being compromised could allow the attacker **different means to steal sensitive information and spy on the user**.

브라우저 확장 프로그램은 매우 **privileged**할 수 있기 때문에, 악성 확장이나 탈취된 확장은 공격자에게 민감한 정보를 훔치거나 사용자를 감시할 수 있는 다양한 수단을 제공할 수 있습니다.

Check how these settings work and how they could get abused in:


{{#ref}}
browext-permissions-and-host_permissions.md
{{#endref}}

이 설정들이 어떻게 동작하며 어떻게 악용될 수 있는지 확인하세요:


{{#ref}}
browext-permissions-and-host_permissions.md
{{#endref}}

### `content_security_policy`

A **content security policy** can be declared also inside the `manifest.json`. If there is one defined, it could be **vulnerable**.

`manifest.json` 안에도 **content security policy**를 선언할 수 있습니다. 만약 정의되어 있다면, 취약할 수 있습니다.

The default setting for browser extension pages is rather restrictive:

브라우저 확장 페이지의 기본 설정은 다소 제한적입니다:
```bash
script-src 'self'; object-src 'self';
```
CSP 및 잠재적 우회에 대한 자세한 내용은 다음을 참조하세요:


{{#ref}}
../content-security-policy-csp-bypass/
{{#endref}}

### `web_accessible_resources`

웹페이지가 브라우저 확장 프로그램의 페이지(예: `.html` 페이지)에 접근하려면 해당 페이지가 `manifest.json`의 **`web_accessible_resources`** 필드에 명시되어 있어야 합니다.\
예를 들어:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
이 페이지들은 다음과 같은 URL에서 접근할 수 있습니다:
```
chrome-extension://<extension-id>/message.html
```
In public extensions the **extension-id is accesible**:

<figure><img src="../../images/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Although, if the `manifest.json` parameter **`use_dynamic_url`** is used, this **id can be dynamic**.

> [!TIP]
> Note that even if a page is mentioned here, it might be **protected against ClickJacking** thanks to the **Content Security Policy**. So you also need to check it (frame-ancestors section) before confirming a ClickJacking attack is possible.

Being allowed to access these pages make these pages **potentially vulnerable ClickJacking**:


{{#ref}}
browext-clickjacking.md
{{#endref}}

> [!TIP]
> Allowing these pages to be loaded only by the extension and not by random URLs could prevent ClickJacking attacks.

> [!CAUTION]
> Note that the pages from **`web_accessible_resources`** and other pages of the extension are also capable of **contacting background scripts**. So if one of these pages is vulnerable to **XSS** it could open a bigger vulnerability.
>
> Moreover, note that you can only open pages indicated in **`web_accessible_resources`** inside iframes, but from a new tab it's possible to access any page in the extension knowing the extension ID. Therefore, if an XSS is found abusing same parameters, it could be abused even if the page isn't configured in **`web_accessible_resources`**.

### `externally_connectable`

A per the [**docs**](https://developer.chrome.com/docs/extensions/reference/manifest/externally_connectable), The `"externally_connectable"` manifest property declares **which extensions and web pages can connect** to your extension via [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) and [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

- If the **`externally_connectable`** key is **not** declared in your extension's manifest or it's declared as **`"ids": ["*"]`**, **all extensions can connect, but no web pages can connect**.
- If **specific IDs are specified**, like in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **only those applications** can connect.
- If **matches** are specified, those web apps will be able to connect:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
- If it's specified as empty: **`"externally_connectable": {}`**, no app or web will be able to connect.

여기에 **`"externally_connectable": {}`**로 비어있다고 지정되어 있으면 어떤 앱이나 웹도 연결할 수 없습니다.

The **less extensions and URLs** indicated here, the **smaller the attack surface** will be.

여기에 지정된 **확장 프로그램과 URL이 적을수록**, **공격 표면이 더 작아집니다**.

> [!CAUTION]
> If a web page **vulnerable to XSS or takeover** is indicated in **`externally_connectable`**, an attacker will be able to **send messages directly to the background script**, completely bypassing the Content Script and its CSP.
>
> Therefore, this is a **very powerful bypass**.
>
> Moreover, if the client installs a rouge extension, even if it isn't allowed to communicate with the vulnerable extension, it could inject **XSS data in an allowed web page** or abuse **`WebRequest`** or **`DeclarativeNetRequest`** APIs to manipulate requests on a targeted domain altering a page's request for a **JavaScript file**. (Note that CSP on the targeted page could prevent these attacks). This idea comes [**from this writeup**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).

> [!CAUTION]
> 만약 웹 페이지가 **XSS 또는 takeover에 취약**한 상태로 **`externally_connectable`**에 지정되어 있다면, 공격자는 **background script에 직접 메시지를 보낼 수 있으며**, Content Script와 해당 CSP를 완전히 우회할 수 있습니다.
>
> 따라서, 이것은 **매우 강력한 우회 방법**입니다.
>
> 또한 클라이언트가 악성 확장 프로그램을 설치한 경우, 해당 확장 프로그램이 취약한 확장과 통신하도록 허용되지 않더라도 허용된 웹 페이지에 **XSS 데이터를 주입**하거나 **`WebRequest`** 또는 **`DeclarativeNetRequest`** API를 악용해 대상 도메인의 요청을 조작하여 페이지의 **JavaScript 파일** 요청을 변경할 수 있습니다. (대상 페이지의 CSP가 이러한 공격을 방지할 수 있다는 점에 유의하세요). 이 아이디어는 [**from this writeup**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability)에서 나왔습니다.

## Communication summary

## 통신 요약

### Extension <--> WebApp

### 확장 프로그램 <--> WebApp

To communicate between the content script and the web page post messages are usually used. Therefore, in the web application you will usually find calls to the function **`window.postMessage`** and in the content script listeners like **`window.addEventListener`**. Note however, that the extension could also **communicate with the web application sending a Post Message** (and therefore the web should expect it) or just make the web load a new script.

content script와 웹 페이지 사이의 통신에는 보통 post message가 사용됩니다. 따라서 웹 애플리케이션에서는 일반적으로 함수 호출 **`window.postMessage`**를, content script 쪽에서는 **`window.addEventListener`** 같은 리스너를 찾을 수 있습니다. 다만, 확장 프로그램이 웹 애플리케이션으로 Post Message를 보내어(따라서 웹 쪽이 이를 예상해야 함) 통신하거나 단순히 웹에 새 스크립트를 로드하게 할 수도 있다는 점에 유의하세요.

### Inside the extension

### 확장 프로그램 내부

Usually the function **`chrome.runtime.sendMessage`** is used to send a message inside the extension (usually handled by the `background` script) and in order to receive and handle it a listener is declared calling **`chrome.runtime.onMessage.addListener`**.

확장 프로그램 내부에서는 보통 **`chrome.runtime.sendMessage`** 함수로 메시지를 보냅니다(대개 `background` script에서 처리). 이를 수신·처리하려면 **`chrome.runtime.onMessage.addListener`**를 호출해 리스너를 선언합니다.

It's also possible to use **`chrome.runtime.connect()`** to have a persistent connection instead of sending single messages, it's possible to use it to **send** and **receive** **messages** like in the following example:

또한 단일 메시지를 보내는 대신 지속적인 연결을 위해 **`chrome.runtime.connect()`**를 사용할 수 있으며, 이를 통해 다음 예제처럼 **메시지를 전송**하고 **수신**할 수 있습니다:

<details>

<summary><code>chrome.runtime.connect()</code> 예제</summary>
```javascript
var port = chrome.runtime.connect()

// Listen for messages from the web page
window.addEventListener(
"message",
(event) => {
// Only accept messages from the same window
if (event.source !== window) {
return
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage({ type: "FROM_PAGE", text: event.data.text })
}
},
false
)

// Listen for messages from the background script
port.onMessage.addListener(function (msg) {
console.log("Content script received message from background script:", msg)
// Handle the response message from the background script
})
```
</details>

백그라운드 스크립트에서 특정 탭에 위치한 content script로 메시지를 보내려면 **`chrome.tabs.sendMessage`**를 호출하면 되며, 이때 메시지를 보낼 **탭의 ID**를 지정해야 합니다.

### 허용된 `externally_connectable`에서 확장 프로그램으로

**`externally_connectable` 구성에서 허용된 웹 앱 및 외부 브라우저 확장 프로그램**은 다음을 사용하여 요청을 보낼 수 있습니다 :
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
필요한 경우 **extension ID**를 언급합니다.

### Native Messaging

백그라운드 스크립트(background scripts)가 시스템 내부의 바이너리(binaries)와 통신할 수 있으며, 이 통신이 적절히 보호되지 않으면 **RCEs와 같은 치명적인 취약점에 노출될 수 있습니다**. [More on this later](#native-messaging).
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
## 웹 **↔︎** Content Script 통신

**content scripts**가 실행되는 환경과 호스트 페이지가 존재하는 환경은 서로 **분리되어** 있어 **격리**가 보장됩니다. 이 격리에도 불구하고, 양쪽은 공통 자원인 페이지의 **Document Object Model (DOM)**과 상호작용할 수 있습니다. 호스트 페이지가 **content script**와 통신하거나 content script를 통해 확장 프로그램과 간접적으로 통신하려면, 양측에서 접근 가능한 **DOM**을 통신 채널로 사용해야 합니다.

### Post Messages
```javascript:content-script.js
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect()

window.addEventListener(
"message",
(event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return
}

if (event.data.type && event.data.type === "FROM_PAGE") {
console.log("Content script received: " + event.data.text)
// Forward the message to the background script
port.postMessage(event.data.text)
}
},
false
)
```

```javascript:example.js
document.getElementById("theButton").addEventListener(
"click",
() => {
window.postMessage(
{ type: "FROM_PAGE", text: "Hello from the webpage!" },
"*"
)
},
false
)
```
A secure Post Message communication should check the authenticity of the received message, this can be done checking:

- **`event.isTrusted`**: This is True only if the event was triggered by a users action
- The content script might expecting a message only if the user performs some action
- **origin domain**: might expecting a message only allowlist of domains.
- If a regex is used, be very careful
- **Source**: `received_message.source !== window` can be used to check if the message was **from the same window** where the Content Script is listening.

The previous checks, even if performed, could be vulnerable, so check in the following page **potential Post Message bypasses**:


{{#ref}}
../postmessage-vulnerabilities/
{{#endref}}

### Iframe

Another possible way of communication might be through **Iframe URLs**, you can find an example in:


{{#ref}}
browext-xss-example.md
{{#endref}}

### DOM

This isn't "exactly" a communication way, but the **web and the content script will have access to the web DOM**. So, if the **content script** is reading some information from it, **trusting the web DOM**, the web could **modify this dat**a (because the web shouldn't be trusted, or because the web is vulnerable to XSS) and **compromise the Content Script**.

You can also find an example of a **DOM based XSS to compromise a browser extension** in:


{{#ref}}
browext-xss-example.md
{{#endref}}

## Content Script **↔︎** Background Script Communication

A Content Script can use the functions [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **or** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) to send a **one-time JSON-serializable** message.

To handle the **response**, use the returned **Promise**. Although, for backward compatibility, you can still pass a **callback** as the last argument.

Sending a request from a **content script** looks like this:
```javascript
;(async () => {
const response = await chrome.runtime.sendMessage({ greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
**extension** (보통 **background script**)에서 요청 보내기. 선택된 탭의 content script로 메시지를 보내는 예:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
;(async () => {
const [tab] = await chrome.tabs.query({
active: true,
lastFocusedWindow: true,
})
const response = await chrome.tabs.sendMessage(tab.id, { greeting: "hello" })
// do something with response here, not outside the function
console.log(response)
})()
```
**수신 측**에서는 메시지를 처리하려면 [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **이벤트 리스너**를 설정해야 합니다. 이는 content script 또는 extension page에서 동일합니다.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {
console.log(
sender.tab
? "from a content script:" + sender.tab.url
: "from the extension"
)
if (request.greeting === "hello") sendResponse({ farewell: "goodbye" })
})
```
위 예제에서, **`sendResponse()`**는 동기 방식으로 실행되었습니다. `sendResponse()`를 비동기적으로 실행하도록 `onMessage` 이벤트 핸들러를 수정하려면 `return true;`를 반드시 포함해야 합니다.

중요한 점은 여러 페이지가 `onMessage` 이벤트를 수신하도록 설정된 경우, 특정 이벤트에 대해 **가장 먼저 `sendResponse()`를 실행한 페이지**만이 응답을 실제로 전달할 수 있다는 것입니다. 동일한 이벤트에 대한 이후의 응답은 무시됩니다.

새 확장 기능을 설계할 때는 callbacks보다 promises를 사용하는 것이 바람직합니다. callbacks를 사용할 경우, `sendResponse()` 함수는 동기 컨텍스트 내에서 직접 실행되거나 이벤트 핸들러가 `true`를 반환해 비동기 동작을 명시한 경우에만 유효합니다. 어떤 핸들러도 `true`를 반환하지 않거나 `sendResponse()`가 메모리에서 가비지 컬렉션되면, 기본적으로 `sendMessage()`에 연결된 콜백이 호출됩니다.

## Native Messaging

브라우저 확장도 **binaries in the system via stdin**를 통해 시스템의 바이너리와 통신할 수 있습니다. 애플리케이션은 이를 나타내는 json을 설치해야 하며, 예시는 다음과 같습니다:
```json
{
"name": "com.my_company.my_application",
"description": "My Application",
"path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
"type": "stdio",
"allowed_origins": ["chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"]
}
```
`name`은 브라우저 확장 프로그램의 백그라운드 스크립트에서 애플리케이션과 통신하기 위해 [`runtime.connectNative()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-connectNative) 또는 [`runtime.sendNativeMessage()`](https://developer.chrome.com/docs/extensions/reference/api/runtime#method-sendNativeMessage)에 전달되는 문자열입니다. `path`는 바이너리의 경로이고, 유효한 `type`은 stdio (stdin과 stdout 사용) 하나뿐이며 `allowed_origins`는 접근 가능한 확장들을 나타냅니다(와일드카드 사용 불가).

Chrome/Chromium은 이 json을 일부 windows registry와 macOS 및 Linux의 특정 경로에서 검색합니다 (자세한 내용은 [**docs**](https://developer.chrome.com/docs/extensions/develop/concepts/native-messaging)).

> [!TIP]
> 브라우저 확장도 이 통신을 사용하려면 `nativeMessaing` 권한을 선언해야 합니다.

아래는 백그라운드 스크립트가 네이티브 애플리케이션으로 메시지를 보내는 코드 예시입니다:
```javascript
chrome.runtime.sendNativeMessage(
"com.my_company.my_application",
{ text: "Hello" },
function (response) {
console.log("Received " + response)
}
)
```
In [**this blog post**](https://spaceraccoon.dev/universal-code-execution-browser-extensions/), native messages를 악용하는 취약한 패턴이 제안되었습니다:

1. 브라우저 확장 프로그램은 content script에 대해 와일드카드 패턴을 가집니다.
2. Content script는 `postMessage` 메시지를 `sendMessage`를 사용해 background script로 전달합니다.
3. Background script는 메시지를 `sendNativeMessage`를 사용해 native application으로 전달합니다.
4. Native application이 메시지를 위험하게 처리하여 code execution으로 이어집니다.

그리고 그 안에는 **임의의 페이지에서 브라우저 확장 기능을 악용해 RCE로 가는 예시**가 설명되어 있습니다.

## Sensitive Information in Memory/Code/Clipboard

브라우저 확장 프로그램이 **민감한 정보를 메모리에 저장**하는 경우, 이는 (특히 Windows 머신에서) **덤프**되어 해당 정보를 **검색**당할 수 있습니다.

따라서 브라우저 확장 프로그램의 메모리는 **안전하다고 간주해서는 안 되며**, 자격 증명이나 mnemonic phrases 같은 **민감한 정보는 저장해서는 안 됩니다**.

물론, 코드에 민감한 정보를 넣지 마세요. 코드에 들어가면 **공개**됩니다.

브라우저에서 메모리를 덤프하려면 **프로세스 메모리를 덤프**하거나 브라우저 확장 설정으로 가서 **`Inspect pop-up`** -> **`Memory`** 섹션 -> **`Take a snaphost`** 하고 **`CTRL+F`** 로 스냅샷 내에서 민감한 정보를 검색할 수 있습니다.

또한 mnemonic keys나 passwords처럼 매우 민감한 정보는 클립보드에 복사되지 않도록 해야 합니다(최소한 몇 초 내에 클립보드에서 제거). 그렇지 않으면 클립보드를 모니터링하는 프로세스가 이를 얻을 수 있습니다.

## Loading an Extension in the Browser

1. 브라우저 확장 프로그램을 **다운로드**하고 압축을 풉니다
2. **`chrome://extensions/`** 로 가서 `Developer Mode`를 **활성화**합니다
3. **`Load unpacked`** 버튼을 클릭합니다

**Firefox**에서는 **`about:debugging#/runtime/this-firefox`** 로 가서 **`Load Temporary Add-on`** 버튼을 클릭합니다.

## Getting the source code from the store

Chrome 확장 프로그램의 소스 코드는 여러 방법으로 얻을 수 있습니다. 아래는 각 옵션에 대한 자세한 설명과 지침입니다.

### Download Extension as ZIP via Command Line

Chrome 확장 프로그램의 소스 코드는 커맨드 라인을 사용해 ZIP 파일로 다운로드할 수 있습니다. 이는 `curl`을 사용해 특정 URL에서 ZIP 파일을 가져오고 ZIP 파일의 내용을 디렉터리로 추출하는 과정을 포함합니다. 절차는 다음과 같습니다:

1. 실제 확장 프로그램 ID로 `"extension_id"`를 교체합니다.
2. 다음 명령어들을 실행합니다:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### CRX Viewer 웹사이트 사용

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### CRX Viewer extension 사용

다른 편리한 방법으로는 오픈소스 프로젝트인 Chrome Extension Source Viewer를 사용하는 것입니다. 이 확장 프로그램은 [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en)에서 설치할 수 있습니다. 뷰어의 소스 코드는 해당 [GitHub repository](https://github.com/Rob--W/crxviewer)에서 확인할 수 있습니다.

### 로컬에 설치된 확장 프로그램 소스 보기

Chrome에 로컬로 설치된 확장 프로그램도 검사할 수 있습니다. 방법은 다음과 같습니다:

1. `chrome://version/`를 방문하여 로컬 Chrome 프로필 디렉터리에 접근하고 "Profile Path" 필드를 찾습니다.
2. 프로필 디렉터리 내의 `Extensions/` 하위 폴더로 이동합니다.
3. 이 폴더에는 설치된 모든 확장 프로그램이 포함되어 있으며, 일반적으로 소스 코드를 읽을 수 있는 형식으로 확인할 수 있습니다.

확장 프로그램을 식별하려면 ID와 이름을 매핑할 수 있습니다:

- `about:extensions` 페이지에서 Developer Mode를 활성화하면 각 확장 프로그램의 ID를 확인할 수 있습니다.
- 각 확장 프로그램 폴더 내의 `manifest.json` 파일에는 읽을 수 있는 `name` 필드가 있어 확장 프로그램을 식별하는 데 도움이 됩니다.

### 파일 아카이버 또는 언패커 사용

Chrome Web Store에서 확장 프로그램을 다운로드하면 파일 확장자가 `.crx`입니다. 파일 확장자를 `.crx`에서 `.zip`으로 변경한 후, WinRAR, 7-Zip 등과 같은 파일 아카이버로 ZIP 파일의 내용을 추출하면 됩니다.

### Chrome에서 Developer Mode 사용

Chrome을 열고 `chrome://extensions/`로 이동합니다. 오른쪽 상단에서 "Developer mode"를 활성화합니다. "Load unpacked extension..."을 클릭하고 확장 프로그램의 디렉터리로 이동합니다. 이 방법은 소스 코드를 다운로드하지는 않지만, 이미 다운로드하거나 개발 중인 확장 프로그램의 코드를 보고 수정하는 데 유용합니다.

## Chrome extension manifest dataset

취약한 브라우저 확장 프로그램을 찾아보려면 [https://github.com/palant/chrome-extension-manifests-dataset](https://github.com/palant/chrome-extension-manifests-dataset)를 사용하여 manifest 파일에서 잠재적으로 취약한 징후를 확인할 수 있습니다. 예를 들어, 사용자 수가 25000명 이상이고 `content_scripts`가 있으며 권한 `nativeMessaing`이 있는 확장 프로그램을 찾으려면:
```bash
# Query example from https://spaceraccoon.dev/universal-code-execution-browser-extensions/
node query.js -f "metadata.user_count > 250000" "manifest.content_scripts?.length > 0 && manifest.permissions?.includes('nativeMessaging')"
```
## Post-exploitation: Forced extension load & persistence (Windows)

사용자별 Preferences를 직접 편집하고 유효한 HMACs를 위조해 Chromium에 백도어를 심는 은밀한 기법으로, 브라우저가 prompts나 flags 없이 임의의 unpacked extension을 수락하고 활성화하게 만듭니다.

{{#ref}}
forced-extension-load-preferences-mac-forgery-windows.md
{{#endref}}

## 보안 감사 체크리스트

브라우저 확장(extensions)은 **공격 표면이 제한적**이지만, 일부는 **취약점**이나 **하드닝 개선 여지**를 포함할 수 있습니다. 다음 항목들은 가장 흔한 항목들입니다:

- [ ] 요청된 **`permissions`**을 가능한 한 **제한**하세요
- [ ] **`host_permissions`**을 가능한 한 **제한**하세요
- [ ] **강력한** **`content_security_policy`**를 사용하세요
- [ ] **`externally_connectable`**을 가능한 한 **제한**하세요. 필요 없고 가능하다면 기본값으로 두지 말고 **`{}`**로 지정하세요
- [ ] 여기서 **URL vulnerable to XSS or to takeover**가 언급되면, 공격자는 **send messages to the background scripts directly**할 수 있습니다. 매우 강력한 우회 방법입니다.
- [ ] **`web_accessible_resources`**를 가능한 한 **제한**하세요. 가능하면 비워두세요.
- [ ] **`web_accessible_resources`**가 none이 아닌 경우, [**ClickJacking**](browext-clickjacking.md)을 확인하세요
- [ ] extension에서 web page로 어떤 **communication**이 발생하면, 그 통신으로 인해 발생할 수 있는 [**XSS**](browext-xss-example.md) **vulnerabilities**를 확인하세요.
- [ ] Post Messages가 사용되는 경우, [**Post Message vulnerabilities**](../postmessage-vulnerabilities/index.html)를 확인하세요.
- [ ] **Content Script**가 DOM 세부사항에 접근하는 경우, 웹에 의해 수정되면 **XSS를 유발하지 않는지** 확인하세요
- [ ] 이 통신이 **Content Script -> Background script communication**에 관여한다면 특히 주의하세요
- [ ] background script가 **native messaging**을 통해 통신하는 경우, 통신이 안전하고 입력이 정제(sanitized)되었는지 확인하세요
- [ ] 민감한 정보는 Browser Extension 코드 내부에 저장되어서는 안 됩니다
- [ ] 민감한 정보는 Browser Extension 메모리 내부에 저장되어서는 안 됩니다
- [ ] 민감한 정보는 보호되지 않은 파일 시스템에 저장되어서는 안 됩니다

## Browser Extension Risks

- 앱 [https://crxaminer.tech/](https://crxaminer.tech/)은 확장(extension)이 요청하는 permissions 같은 일부 데이터를 분석하여 확장 사용의 위험도를 제공합니다.

## Tools

### [**Tarnish**](https://thehackerblog.com/tarnish/)

- 제공된 Chrome webstore 링크에서 Chrome extension을 가져옵니다.
- [**manifest.json**](https://developer.chrome.com/extensions/manifest) **viewer**: 확장의 manifest를 JSON 형식으로 보기 좋게 표시합니다.
- **Fingerprint Analysis**: [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources)를 탐지하고 Chrome extension fingerprinting JavaScript를 자동 생성합니다.
- **Potential Clickjacking Analysis**: [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) 지시자가 설정된 extension HTML 페이지를 탐지합니다. 이 페이지들은 목적에 따라 Clickjacking에 취약할 수 있습니다.
- **Permission Warning(s) viewer**: 사용자가 확장을 설치하려 할 때 표시될 모든 Chrome permission prompt 경고 목록을 보여줍니다.
- **Dangerous Function(s)**: 공격자가 악용할 수 있는 위험한 함수들의 위치를 보여줍니다 (예: innerHTML, chrome.tabs.executeScript).
- **Entry Point(s)**: 확장이 사용자/외부 입력을 받는 지점을 보여줍니다. 이는 확장의 공격 표면을 이해하고 악의적으로 조작된 데이터를 보낼 수 있는 잠재적 지점을 찾는 데 유용합니다.
- Dangerous Function(s)와 Entry Point(s) 스캐너는 생성된 경고에 대해 다음 정보를 제공합니다:
  - 경고를 유발한 관련 코드 스니펫과 라인
  - 이슈 설명
  - 전체 소스 파일을 보도록 하는 “View File” 버튼
  - 경고가 발생한 파일의 경로
  - 경고 파일의 전체 Chrome extension URI
  - Background Page script, Content Script, Browser Action 등 파일 유형
  - 취약한 라인이 JavaScript 파일에 있다면, 해당 파일이 포함된 모든 페이지의 경로와 그 페이지의 유형 및 [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources) 상태
- **Content Security Policy (CSP) analyzer and bypass checker**: 확장의 CSP의 약점을 지적하고, 화이트리스트된 CDN 등으로 인해 CSP를 우회할 수 있는 잠재적 방법을 밝힙니다.
- **Known Vulnerable Libraries**: [Retire.js](https://retirejs.github.io/retire.js/)를 사용해 알려진 취약 JavaScript 라이브러리 사용 여부를 검사합니다.
- 확장 및 포맷된 버전 다운로드
- 원본 확장 다운로드
- 보기 좋게 정리된 버전(자동으로 prettified된 HTML 및 JavaScript 포함) 다운로드
- 스캔 결과 자동 캐싱: 확장 스캔은 처음 실행 시 시간이 많이 걸릴 수 있지만, 확장이 업데이트되지 않았다면 두 번째 실행부터는 캐시된 결과로 거의 즉시 실행됩니다.
- 링크 가능한 리포트 URL: tarnish가 생성한 확장 리포트에 쉽게 링크를 공유할 수 있습니다.

### [Neto](https://github.com/elevenpaths/neto)

Project Neto는 Firefox와 Chrome 같은 잘 알려진 브라우저용 브라우저 플러그인 및 확장의 숨겨진 기능을 분석하고 드러내기 위해 고안된 Python 3 패키지입니다. 패키지된 파일을 자동으로 압축 해제하여 `manifest.json`, localization 폴더, 또는 Javascript와 HTML 소스 파일 같은 확장의 관련 리소스에서 이러한 기능을 추출합니다.

## References

- **이 방법론에 도움을 준** [**@naivenom**](https://twitter.com/naivenom) **에게 감사드립니다**
- [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
- [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
- [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
- [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
- [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
- [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
- [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
- [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
- [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

{{#include ../../banners/hacktricks-training.md}}
