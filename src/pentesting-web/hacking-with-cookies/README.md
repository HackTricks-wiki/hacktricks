# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie-Attribute

Cookies verfügen über mehrere Attribute, die ihr Verhalten im Browser des Benutzers steuern. Hier ist eine Übersicht über diese Attribute in einer passiveren Stimme:

### Expires und Max-Age

Das Ablaufdatum eines Cookies wird durch das Attribut `Expires` bestimmt. Im Gegensatz dazu definiert das Attribut `Max-age` die Zeit in Sekunden, bis ein Cookie gelöscht wird. **Bevorzugen Sie `Max-age`, da es modernere Praktiken widerspiegelt.**

### Domain

Die Hosts, die ein Cookie empfangen, werden durch das Attribut `Domain` festgelegt. Standardmäßig ist dies auf den Host eingestellt, der das Cookie ausgegeben hat, ohne seine Subdomains einzuschließen. Wenn das Attribut `Domain` jedoch ausdrücklich festgelegt wird, umfasst es auch Subdomains. Dies macht die Spezifikation des Attributs `Domain` zu einer weniger restriktiven Option, die nützlich ist, wenn das Teilen von Cookies über Subdomains erforderlich ist. Zum Beispiel macht die Einstellung `Domain=mozilla.org` Cookies auf seinen Subdomains wie `developer.mozilla.org` zugänglich.

### Path

Ein spezifischer URL-Pfad, der in der angeforderten URL vorhanden sein muss, damit der `Cookie`-Header gesendet wird, wird durch das Attribut `Path` angezeigt. Dieses Attribut betrachtet das Zeichen `/` als Verzeichnistrenner, was Übereinstimmungen in Unterverzeichnissen ermöglicht.

### Reihenfolge-Regeln

Wenn zwei Cookies denselben Namen tragen, wird dasjenige, das zum Senden ausgewählt wird, basierend auf:

- Dem Cookie, das den längsten Pfad in der angeforderten URL übereinstimmt.
- Dem zuletzt gesetzten Cookie, wenn die Pfade identisch sind.

### SameSite

- Das Attribut `SameSite` bestimmt, ob Cookies bei Anfragen von Drittanbieter-Domains gesendet werden. Es bietet drei Einstellungen:
- **Strict**: Beschränkt das Cookie, um bei Anfragen von Drittanbietern gesendet zu werden.
- **Lax**: Erlaubt das Cookie, bei GET-Anfragen, die von Drittanbieter-Websites initiiert werden, gesendet zu werden.
- **None**: Erlaubt das Cookie, von jeder Drittanbieter-Domain gesendet zu werden.

Denken Sie daran, dass das Verständnis dieser Attribute bei der Konfiguration von Cookies helfen kann, um sicherzustellen, dass sie in verschiedenen Szenarien wie erwartet funktionieren.

| **Anfragetyp**   | **Beispielcode**                   | **Cookies gesendet, wenn** |
| ---------------- | ---------------------------------- | --------------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None        |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None        |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None        |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None             |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None             |
| AJAX             | $.get("...")                       | NotSet\*, None             |
| Bild             | \<img src="...">                   | NetSet\*, None             |

Tabelle von [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) und leicht modifiziert.\
Ein Cookie mit dem _**SameSite**_ Attribut wird **CSRF-Angriffe mildern**, bei denen eine angemeldete Sitzung erforderlich ist.

**\*Beachten Sie, dass ab Chrome80 (Februar 2019) das Standardverhalten eines Cookies ohne ein Cookie SameSite** **Attribut lax** sein wird ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Beachten Sie, dass temporär, nach Anwendung dieser Änderung, die **Cookies ohne eine SameSite** **Richtlinie** in Chrome **während der ersten 2 Minuten als None** behandelt werden und dann als Lax für die oberste Ebene Cross-Site POST-Anfrage.

## Cookies-Flags

### HttpOnly

Dies verhindert, dass der **Client** auf das Cookie zugreift (zum Beispiel über **Javascript**: `document.cookie`)

#### **Umgehungen**

- Wenn die Seite **die Cookies als Antwort** auf eine Anfrage sendet (zum Beispiel auf einer **PHPinfo**-Seite), ist es möglich, XSS auszunutzen, um eine Anfrage an diese Seite zu senden und **die Cookies** aus der Antwort zu **stehlen** (siehe ein Beispiel in [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Dies könnte mit **TRACE** **HTTP**-Anfragen umgangen werden, da die Antwort des Servers (wenn diese HTTP-Methode verfügbar ist) die gesendeten Cookies widerspiegelt. Diese Technik wird als **Cross-Site Tracking** bezeichnet.
- Diese Technik wird von **modernen Browsern vermieden, indem das Senden einer TRACE**-Anfrage von JS nicht erlaubt wird. Einige Umgehungen dafür wurden jedoch in spezifischer Software gefunden, wie das Senden von `\r\nTRACE` anstelle von `TRACE` an IE6.0 SP2.
- Eine andere Möglichkeit ist die Ausnutzung von Zero-Day-Sicherheitsanfälligkeiten der Browser.
- Es ist möglich, **HttpOnly-Cookies** durch einen Cookie-Jar-Overflow-Angriff zu **überschreiben**:

{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Es ist möglich, den [**Cookie Smuggling**](./#cookie-smuggling) Angriff zu verwenden, um diese Cookies zu exfiltrieren.

### Secure

Die Anfrage sendet das Cookie **nur**, wenn die Anfrage über einen sicheren Kanal (typischerweise **HTTPS**) übertragen wird.

## Cookies-Präfixe

Cookies, die mit `__Secure-` beginnen, müssen zusammen mit dem `secure`-Flag von Seiten gesetzt werden, die durch HTTPS gesichert sind.

Für Cookies, die mit `__Host-` beginnen, müssen mehrere Bedingungen erfüllt sein:

- Sie müssen mit dem `secure`-Flag gesetzt werden.
- Sie müssen von einer durch HTTPS gesicherten Seite stammen.
- Es ist verboten, eine Domain anzugeben, was ihre Übertragung an Subdomains verhindert.
- Der Pfad für diese Cookies muss auf `/` gesetzt werden.

Es ist wichtig zu beachten, dass Cookies, die mit `__Host-` beginnen, nicht an Superdomains oder Subdomains gesendet werden dürfen. Diese Einschränkung hilft, Anwendungscookies zu isolieren. Daher kann die Verwendung des `__Host-`-Präfixes für alle Anwendungscookies als gute Praxis zur Verbesserung der Sicherheit und Isolation angesehen werden.

### Überschreiben von Cookies

Eine der Schutzmaßnahmen von mit `__Host-` beginnenden Cookies besteht darin, sie daran zu hindern, von Subdomains überschrieben zu werden. Dies verhindert beispielsweise [**Cookie Tossing-Angriffe**](cookie-tossing.md). In dem Vortrag [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**Paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) wird präsentiert, dass es möglich war, \_\_HOST- beginnende Cookies von einer Subdomain zu setzen, indem der Parser getäuscht wurde, zum Beispiel durch Hinzufügen von "=" am Anfang oder am Ende...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Oder in PHP war es möglich, **andere Zeichen am Anfang** des Cookie-Namens hinzuzufügen, die durch Unterstrich-Zeichen **ersetzt** werden sollten, was das Überschreiben von `__HOST-` Cookies ermöglichte:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookies-Angriffe

Wenn ein benutzerdefiniertes Cookie sensible Daten enthält, überprüfen Sie es (insbesondere wenn Sie an einem CTF teilnehmen), da es anfällig sein könnte.

### Dekodierung und Manipulation von Cookies

Sensible Daten, die in Cookies eingebettet sind, sollten immer überprüft werden. Cookies, die in Base64 oder ähnlichen Formaten codiert sind, können oft dekodiert werden. Diese Sicherheitsanfälligkeit ermöglicht es Angreifern, den Inhalt des Cookies zu ändern und sich als andere Benutzer auszugeben, indem sie ihre modifizierten Daten wieder in das Cookie codieren.

### Sitzungsübernahme

Dieser Angriff besteht darin, das Cookie eines Benutzers zu stehlen, um unbefugten Zugriff auf dessen Konto innerhalb einer Anwendung zu erlangen. Durch die Verwendung des gestohlenen Cookies kann ein Angreifer den legitimen Benutzer imitieren.

### Sitzungsfixierung

In diesem Szenario bringt ein Angreifer ein Opfer dazu, ein bestimmtes Cookie zum Anmelden zu verwenden. Wenn die Anwendung beim Anmelden kein neues Cookie zuweist, kann der Angreifer, der das ursprüngliche Cookie besitzt, das Opfer imitieren. Diese Technik beruht darauf, dass das Opfer sich mit einem Cookie anmeldet, das vom Angreifer bereitgestellt wurde.

Wenn Sie ein **XSS in einer Subdomain** gefunden haben oder **eine Subdomain kontrollieren**, lesen Sie:

{{#ref}}
cookie-tossing.md
{{#endref}}

### Sitzungsdonation

Hier überzeugt der Angreifer das Opfer, das Sitzungscookie des Angreifers zu verwenden. Das Opfer, das glaubt, in seinem eigenen Konto angemeldet zu sein, wird unbeabsichtigt Aktionen im Kontext des Kontos des Angreifers ausführen.

Wenn Sie ein **XSS in einer Subdomain** gefunden haben oder **eine Subdomain kontrollieren**, lesen Sie:

{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT-Cookies](../hacking-jwt-json-web-tokens.md)

Klicken Sie auf den vorherigen Link, um auf eine Seite zuzugreifen, die mögliche Schwächen in JWT erklärt.

JSON Web Tokens (JWT), die in Cookies verwendet werden, können ebenfalls Sicherheitsanfälligkeiten aufweisen. Für detaillierte Informationen zu potenziellen Schwächen und deren Ausnutzung wird empfohlen, das verlinkte Dokument über das Hacken von JWT zu konsultieren.

### Cross-Site Request Forgery (CSRF)

Dieser Angriff zwingt einen angemeldeten Benutzer, unerwünschte Aktionen in einer Webanwendung auszuführen, in der er derzeit authentifiziert ist. Angreifer können Cookies ausnutzen, die automatisch mit jeder Anfrage an die anfällige Seite gesendet werden.

### Leere Cookies

(Weitere Details finden Sie in der [originalen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Browser erlauben die Erstellung von Cookies ohne Namen, was durch JavaScript wie folgt demonstriert werden kann:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Das Ergebnis im gesendeten Cookie-Header ist `a=v1; test value; b=v2;`. Interessanterweise ermöglicht dies die Manipulation von Cookies, wenn ein Cookie mit leerem Namen gesetzt wird, wodurch möglicherweise andere Cookies kontrolliert werden können, indem das leere Cookie auf einen bestimmten Wert gesetzt wird:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Dies führt dazu, dass der Browser einen Cookie-Header sendet, der von jedem Webserver als ein Cookie mit dem Namen `a` und dem Wert `b` interpretiert wird.

#### Chrome-Fehler: Unicode-Surrogat-Codepunkt-Problem

In Chrome, wenn ein Unicode-Surrogat-Codepunkt Teil eines gesetzten Cookies ist, wird `document.cookie` beschädigt und gibt anschließend einen leeren String zurück:
```js
document.cookie = "\ud800=meep"
```
Dies führt dazu, dass `document.cookie` einen leeren String ausgibt, was auf eine permanente Beschädigung hinweist.

#### Cookie-Smuggling aufgrund von Parsing-Problemen

(Weitere Details finden Sie in der [originalen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Mehrere Webserver, einschließlich der von Java (Jetty, TomCat, Undertow) und Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), behandeln Cookie-Strings aufgrund veralteter RFC2965-Unterstützung falsch. Sie lesen einen doppelt zitierten Cookie-Wert als einen einzigen Wert, selbst wenn er Semikolons enthält, die normalerweise Schlüssel-Wert-Paare trennen sollten:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie-Injektionsanfälligkeiten

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Die falsche Analyse von Cookies durch Server, insbesondere Undertow, Zope und solche, die Python's `http.cookie.SimpleCookie` und `http.cookie.BaseCookie` verwenden, schafft Möglichkeiten für Cookie-Injektionsangriffe. Diese Server versäumen es, den Beginn neuer Cookies ordnungsgemäß zu kennzeichnen, was Angreifern ermöglicht, Cookies zu fälschen:

- Undertow erwartet ein neues Cookie sofort nach einem zitierten Wert ohne Semikolon.
- Zope sucht nach einem Komma, um mit der Analyse des nächsten Cookies zu beginnen.
- Pythons Cookie-Klassen beginnen die Analyse bei einem Leerzeichen.

Diese Anfälligkeit ist besonders gefährlich in Webanwendungen, die auf cookie-basiertem CSRF-Schutz basieren, da sie Angreifern ermöglicht, gefälschte CSRF-Token-Cookies einzuschleusen, was potenziell Sicherheitsmaßnahmen umgeht. Das Problem wird durch Pythons Umgang mit doppelten Cookienamen verschärft, bei dem das letzte Vorkommen frühere überschreibt. Es wirft auch Bedenken hinsichtlich `__Secure-` und `__Host-` Cookies in unsicheren Kontexten auf und könnte zu Autorisierungsumgehungen führen, wenn Cookies an Backend-Server weitergegeben werden, die anfällig für Spoofing sind.

### Cookies $version und WAF-Umgehungen

Laut [**diesem Blogbeitrag**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie) könnte es möglich sein, das Cookie-Attribut **`$Version=1`** zu verwenden, um das Backend dazu zu bringen, eine alte Logik zur Analyse des Cookies aufgrund der **RFC2109** zu verwenden. Darüber hinaus können andere Werte wie **`$Domain`** und **`$Path`** verwendet werden, um das Verhalten des Backends mit dem Cookie zu ändern.

#### Umgehung der Wertanalyse mit kodierten Zeichenfolgen

Diese Analyse deutet darauf hin, dass escaped Werte innerhalb der Cookies unescaped werden, sodass "\a" zu "a" wird. Dies kann nützlich sein, um WAFs zu umgehen, da:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Umgehung von Cookie-Namen-Blocklisten

In der RFC2109 wird angegeben, dass ein **Komma als Trennzeichen zwischen Cookie-Werten verwendet werden kann**. Außerdem ist es möglich, **Leerzeichen und Tabs vor und nach dem Gleichheitszeichen hinzuzufügen**. Daher erzeugt ein Cookie wie `$Version=1; foo=bar, abc = qux` nicht das Cookie `"foo":"bar, admin = qux"`, sondern die Cookies `foo":"bar"` und `"admin":"qux"`. Beachten Sie, wie 2 Cookies generiert werden und wie der Raum vor und nach dem Gleichheitszeichen für admin entfernt wurde.

#### Umgehung der Wertanalyse mit Cookie-Splitting

Schließlich würden verschiedene Backdoors in einem String verschiedene Cookies zusammenführen, die in verschiedenen Cookie-Headern übergeben werden, wie in:&#x20;
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Was es ermöglichen könnte, eine WAF zu umgehen, wie in diesem Beispiel:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Zusätzliche Überprüfungen von verwundbaren Cookies

#### **Grundlegende Überprüfungen**

- Das **Cookie** ist jedes Mal, wenn Sie sich **einloggen**, **gleich**.
- Melden Sie sich ab und versuchen Sie, dasselbe Cookie zu verwenden.
- Versuchen Sie, sich mit 2 Geräten (oder Browsern) mit demselben Cookie in dasselbe Konto einzuloggen.
- Überprüfen Sie, ob das Cookie Informationen enthält, und versuchen Sie, es zu ändern.
- Versuchen Sie, mehrere Konten mit fast demselben Benutzernamen zu erstellen, und überprüfen Sie, ob Sie Ähnlichkeiten sehen können.
- Überprüfen Sie die Option "**angemeldet bleiben**", falls vorhanden, um zu sehen, wie sie funktioniert. Wenn sie vorhanden ist und anfällig sein könnte, verwenden Sie immer das Cookie von **angemeldet bleiben** ohne ein anderes Cookie.
- Überprüfen Sie, ob das vorherige Cookie funktioniert, selbst nachdem Sie das Passwort geändert haben.

#### **Erweiterte Cookie-Angriffe**

Wenn das Cookie beim Einloggen gleich bleibt (oder fast gleich bleibt), bedeutet dies wahrscheinlich, dass das Cookie mit einem Feld Ihres Kontos (wahrscheinlich dem Benutzernamen) verbunden ist. Dann können Sie:

- Versuchen, viele **Konten** mit sehr **ähnlichen** Benutzernamen zu erstellen und versuchen, **zu erraten**, wie der Algorithmus funktioniert.
- Versuchen, den **Benutzernamen zu bruteforcen**. Wenn das Cookie nur als Authentifizierungsmethode für Ihren Benutzernamen gespeichert wird, können Sie ein Konto mit dem Benutzernamen "**Bmin**" erstellen und jeden einzelnen **Bit** Ihres Cookies bruteforcen, da eines der Cookies, die Sie versuchen werden, das von "**admin**" sein wird.
- Versuchen Sie **Padding** **Oracle** (Sie können den Inhalt des Cookies entschlüsseln). Verwenden Sie **padbuster**.

**Padding Oracle - Padbuster Beispiele**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wird mehrere Versuche unternehmen und Sie fragen, welche Bedingung die Fehlerbedingung ist (die, die nicht gültig ist).

Dann beginnt es, das Cookie zu entschlüsseln (es kann mehrere Minuten dauern).

Wenn der Angriff erfolgreich durchgeführt wurde, könnten Sie versuchen, eine Zeichenfolge Ihrer Wahl zu verschlüsseln. Zum Beispiel, wenn Sie **encrypt** **user=administrator** verschlüsseln möchten.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Diese Ausführung gibt Ihnen das Cookie korrekt verschlüsselt und kodiert mit dem String **user=administrator** darin.

**CBC-MAC**

Vielleicht könnte ein Cookie einen Wert haben und mit CBC signiert werden. Dann ist die Integrität des Wertes die Signatur, die durch die Verwendung von CBC mit demselben Wert erstellt wird. Da empfohlen wird, als IV einen Nullvektor zu verwenden, könnte diese Art der Integritätsprüfung anfällig sein.

**Der Angriff**

1. Holen Sie sich die Signatur des Benutzernamens **administ** = **t**
2. Holen Sie sich die Signatur des Benutzernamens **rator\x00\x00\x00 XOR t** = **t'**
3. Setzen Sie im Cookie den Wert **administrator+t'** (**t'** wird eine gültige Signatur von **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** sein)

**ECB**

Wenn das Cookie mit ECB verschlüsselt ist, könnte es anfällig sein.\
Wenn Sie sich anmelden, muss das Cookie, das Sie erhalten, immer dasselbe sein.

**Wie man erkennt und angreift:**

Erstellen Sie 2 Benutzer mit fast denselben Daten (Benutzername, Passwort, E-Mail usw.) und versuchen Sie, ein Muster im gegebenen Cookie zu entdecken.

Erstellen Sie einen Benutzer mit dem Namen "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" und überprüfen Sie, ob es ein Muster im Cookie gibt (da ECB mit demselben Schlüssel jeden Block verschlüsselt, könnten die gleichen verschlüsselten Bytes erscheinen, wenn der Benutzername verschlüsselt wird).

Es sollte ein Muster (mit der Größe eines verwendeten Blocks) geben. Wenn Sie wissen, wie eine Menge von "a" verschlüsselt ist, können Sie einen Benutzernamen erstellen: "a"\*(Größe des Blocks)+"admin". Dann könnten Sie das verschlüsselte Muster eines Blocks von "a" aus dem Cookie löschen. Und Sie haben das Cookie des Benutzernamens "admin".

## Referenzen

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)

{{#include ../../banners/hacktricks-training.md}}
