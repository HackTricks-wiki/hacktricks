# クッキーのハッキング

{{#include ../../banners/hacktricks-training.md}}

## クッキー属性

クッキーには、ユーザーのブラウザでの動作を制御するいくつかの属性があります。これらの属性について、より受動的な表現で説明します。

### Expires と Max-Age

クッキーの有効期限は `Expires` 属性によって決まります。一方、`Max-age` 属性は、クッキーが削除されるまでの時間（秒単位）を定義します。**より現代的な慣行を反映するために `Max-age` を選択してください。**

### Domain

クッキーを受け取るホストは `Domain` 属性によって指定されます。デフォルトでは、これはクッキーを発行したホストに設定され、サブドメインは含まれません。ただし、`Domain` 属性が明示的に設定されると、サブドメインも含まれます。これにより、サブドメイン間でのクッキー共有が必要なシナリオで、`Domain` 属性の指定が制限の少ないオプションとなります。たとえば、`Domain=mozilla.org` を設定すると、`developer.mozilla.org` のようなサブドメインでもクッキーにアクセスできます。

### Path

`Cookie` ヘッダーが送信されるために、要求された URL に存在しなければならない特定の URL パスは `Path` 属性によって示されます。この属性は `/` 文字をディレクトリ区切りとして扱い、サブディレクトリ内でも一致を許可します。

### Ordering Rules

同じ名前のクッキーが2つある場合、送信されるクッキーは以下に基づいて選択されます：

- 要求された URL で最も長いパスに一致するクッキー。
- パスが同じ場合は、最も最近設定されたクッキー。

### SameSite

- `SameSite` 属性は、サードパーティのドメインからのリクエストでクッキーが送信されるかどうかを決定します。3つの設定があります：
- **Strict**: サードパーティのリクエストでクッキーが送信されるのを制限します。
- **Lax**: サードパーティのウェブサイトによって開始された GET リクエストでクッキーが送信されることを許可します。
- **None**: どのサードパーティのドメインからでもクッキーが送信されることを許可します。

クッキーを設定する際には、これらの属性を理解することで、さまざまなシナリオで期待通りに動作することを確保できます。

| **リクエストタイプ** | **例コード**                   | **クッキーが送信されるとき** |
| ---------------- | ---------------------------------- | --------------------- |
| リンク             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| プリレンダリング        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| フォーム GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| フォーム POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| 画像            | \<img src="...">                   | NetSet\*, None        |

表は [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) からのもので、若干修正されています。\
_**SameSite**_ 属性を持つクッキーは、**CSRF攻撃を軽減**します。

**\*Chrome80（2019年2月）以降、SameSite 属性を持たないクッキーのデフォルトの動作は Lax になります** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
この変更を適用した後、一時的に、Chrome の **SameSite ポリシーを持たないクッキーは最初の2分間は None として扱われ、その後はトップレベルのクロスサイト POST リクエストに対して Lax として扱われます。**

## クッキーのフラグ

### HttpOnly

これにより、**クライアント**がクッキーにアクセスするのを防ぎます（例えば、**Javascript** を介して：`document.cookie`）。

#### **バイパス**

- ページがリクエストのレスポンスとしてクッキーを**送信している**場合（例えば、**PHPinfo** ページで）、XSS を悪用してこのページにリクエストを送り、レスポンスから**クッキーを盗む**ことが可能です（例は [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/) を参照）。
- **TRACE** **HTTP** リクエストを使用することでバイパス可能です。サーバーからのレスポンスは送信されたクッキーを反映します。この技術は **Cross-Site Tracking** と呼ばれます。
- この技術は、**モダンブラウザが JS から TRACE リクエストを送信することを許可しないことによって回避されます**。ただし、特定のソフトウェアでは、`TRACE` の代わりに `\r\nTRACE` を送信することでバイパスが見つかっています。
- 別の方法は、ブラウザのゼロデイ脆弱性を悪用することです。
- クッキージャーオーバーフロー攻撃を実行することで、**HttpOnly クッキーを上書きする**ことが可能です：

{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- これらのクッキーを外部に持ち出すために [**Cookie Smuggling**](./#cookie-smuggling) 攻撃を使用することが可能です。

### Secure

リクエストは、**HTTPS** などの安全なチャネルを介して送信される場合にのみ、HTTP リクエストでクッキーを**送信します**。

## クッキーのプレフィックス

`__Secure-` で始まるクッキーは、HTTPS によって保護されたページから `secure` フラグとともに設定される必要があります。

`__Host-` で始まるクッキーには、いくつかの条件が満たされなければなりません：

- `secure` フラグで設定されなければなりません。
- HTTPS によって保護されたページから発信されなければなりません。
- ドメインを指定することは禁じられており、サブドメインへの送信を防ぎます。
- これらのクッキーのパスは `/` に設定されなければなりません。

`__Host-` で始まるクッキーは、スーパードメインやサブドメインに送信されることは許可されていないことに注意することが重要です。この制限は、アプリケーションクッキーを隔離するのに役立ちます。したがって、すべてのアプリケーションクッキーに `__Host-` プレフィックスを使用することは、セキュリティと隔離を強化するための良いプラクティスと見なされます。

### クッキーの上書き

したがって、`__Host-` プレフィックスのクッキーの保護の1つは、サブドメインからの上書きを防ぐことです。たとえば、[**Cookie Tossing attacks**](cookie-tossing.md) を防ぎます。トークで [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**論文**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) では、パーサーを騙すことでサブドメインから __HOST- プレフィックスのクッキーを設定することが可能であることが示されています。たとえば、最初や最後に "=" を追加することです：

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

また、PHP では、クッキー名の先頭に**他の文字を追加する**ことで、**アンダースコア**文字に置き換えられ、`__HOST-` クッキーを上書きすることが可能でした：

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## クッキー攻撃

カスタムクッキーに機密データが含まれている場合は、確認してください（特に CTF をプレイしている場合）、脆弱性があるかもしれません。

### クッキーのデコードと操作

クッキーに埋め込まれた機密データは常に精査されるべきです。Base64 や類似の形式でエンコードされたクッキーは、しばしばデコード可能です。この脆弱性により、攻撃者はクッキーの内容を変更し、修正されたデータを再度クッキーにエンコードすることで他のユーザーを偽装することができます。

### セッションハイジャック

この攻撃は、ユーザーのクッキーを盗んで、アプリケーション内のアカウントに不正にアクセスすることを含みます。盗まれたクッキーを使用することで、攻撃者は正当なユーザーを偽装できます。

### セッション固定

このシナリオでは、攻撃者が被害者を特定のクッキーを使用してログインさせるように仕向けます。アプリケーションがログイン時に新しいクッキーを割り当てない場合、攻撃者は元のクッキーを持っているため、被害者を偽装できます。この技術は、被害者が攻撃者が提供したクッキーでログインすることに依存しています。

**サブドメインに XSS を見つけた場合**や**サブドメインを制御している場合**は、次をお読みください：

{{#ref}}
cookie-tossing.md
{{#endref}}

### セッション寄付

ここでは、攻撃者が被害者に攻撃者のセッションクッキーを使用させるように仕向けます。被害者は自分のアカウントにログインしていると信じて、攻撃者のアカウントのコンテキストで意図せずにアクションを実行します。

**サブドメインに XSS を見つけた場合**や**サブドメインを制御している場合**は、次をお読みください：

{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT クッキー](../hacking-jwt-json-web-tokens.md)

前のリンクをクリックして、JWT の可能な欠陥を説明するページにアクセスしてください。

クッキーで使用される JSON Web Tokens (JWT) も脆弱性を示す可能性があります。潜在的な欠陥とそれを悪用する方法についての詳細情報を得るには、JWT のハッキングに関するリンクされた文書にアクセスすることをお勧めします。

### クロスサイトリクエストフォージェリ (CSRF)

この攻撃は、ログイン中のユーザーに対して、現在認証されているウェブアプリケーションで不要なアクションを実行させるものです。攻撃者は、脆弱なサイトへのすべてのリクエストに自動的に送信されるクッキーを悪用できます。

### 空のクッキー

（詳細は[元の研究](https://blog.ankursundara.com/cookie-bugs/)を参照してください）ブラウザは名前のないクッキーの作成を許可しており、次のように JavaScript で示すことができます：
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
送信されたクッキー ヘッダーの結果は `a=v1; test value; b=v2;` です。興味深いことに、これは空の名前のクッキーが設定されている場合にクッキーを操作することを可能にし、空のクッキーを特定の値に設定することで他のクッキーを制御する可能性があります。
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
これにより、ブラウザはすべてのウェブサーバーによって `a` という名前のクッキーと `b` という値を持つクッキーとして解釈されるクッキー ヘッダーを送信します。

#### Chromeのバグ: Unicodeサロゲートコードポイントの問題

Chromeでは、Unicodeサロゲートコードポイントがセットされたクッキーの一部である場合、`document.cookie` が破損し、その後空の文字列を返します:
```js
document.cookie = "\ud800=meep"
```
この結果、`document.cookie`が空の文字列を出力し、永続的な破損を示します。

#### パースの問題によるクッキーのスモグリング

(詳細は[元の研究](https://blog.ankursundara.com/cookie-bugs/)を参照) Java（Jetty、TomCat、Undertow）やPython（Zope、cherrypy、web.py、aiohttp、bottle、webob）を含むいくつかのウェブサーバーは、古いRFC2965サポートのためにクッキーストリングを誤処理します。彼らは、セミコロンを含んでいても、ダブルクオートされたクッキー値を単一の値として読み取ります。セミコロンは通常、キーと値のペアを区切るべきです。
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) サーバーによるクッキーの不適切な解析、特にUndertow、Zope、およびPythonの`http.cookie.SimpleCookie`と`http.cookie.BaseCookie`を使用しているものは、クッキーインジェクション攻撃の機会を生み出します。これらのサーバーは新しいクッキーの開始を適切に区切ることができず、攻撃者がクッキーを偽装することを可能にします：

- Undertowは、引用された値の直後にセミコロンなしで新しいクッキーを期待します。
- Zopeは、次のクッキーの解析を開始するためにカンマを探します。
- Pythonのクッキークラスは、スペース文字で解析を開始します。

この脆弱性は、クッキーベースのCSRF保護に依存するWebアプリケーションにとって特に危険であり、攻撃者が偽装されたCSRFトークンクッキーを注入し、セキュリティ対策を回避する可能性があります。この問題は、Pythonが重複したクッキー名を処理する方法によって悪化し、最後の出現が以前のものを上書きします。また、`__Secure-`および`__Host-`クッキーが安全でないコンテキストで扱われることに対する懸念を引き起こし、クッキーが偽装に対して脆弱なバックエンドサーバーに渡されると、認可のバイパスにつながる可能性があります。

### Cookies $version and WAF bypasses

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), **`$Version=1`**というクッキー属性を使用して、バックエンドが**RFC2109**のために古いロジックを使用してクッキーを解析することが可能かもしれません。さらに、**`$Domain`**や**`$Path`**などの他の値を使用して、クッキーに対するバックエンドの動作を変更することができます。

#### Bypassing value analysis with quoted-string encoding

この解析は、クッキー内のエスケープされた値をアンエスケープすることを示しており、したがって"\a"は"a"になります。これはWAFを回避するのに役立つ可能性があります：

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

RFC2109では、**カンマをクッキー値の区切りとして使用できる**ことが示されています。また、**等号の前後にスペースやタブを追加することも可能です**。したがって、`$Version=1; foo=bar, abc = qux`のようなクッキーは、クッキー`"foo":"bar, admin = qux"`を生成するのではなく、クッキー`foo":"bar"`と`"admin":"qux"`を生成します。2つのクッキーが生成され、adminの前後のスペースが削除されたことに注意してください。

#### Bypassing value analysis with cookie splitting

最後に、異なるバックドアは、異なるクッキーヘッダーで渡された異なるクッキーを文字列に結合します。
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
これにより、この例のようにWAFをバイパスできる可能性があります:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### 追加の脆弱なクッキーチェック

#### **基本チェック**

- **クッキー**は、**ログイン**するたびに**同じ**です。
- ログアウトして、同じクッキーを使用してみてください。
- 2つのデバイス（またはブラウザ）を使用して、同じアカウントに同じクッキーでログインしてみてください。
- クッキーに情報が含まれているか確認し、変更を試みてください。
- ほぼ同じユーザー名で複数のアカウントを作成し、類似点が見えるか確認してください。
- "**ログイン状態を保持**"オプションが存在する場合、その動作を確認してください。存在し、脆弱である可能性がある場合は、他のクッキーを使用せずに**ログイン状態を保持**のクッキーを常に使用してください。
- パスワードを変更しても前のクッキーが機能するか確認してください。

#### **高度なクッキー攻撃**

ログイン時にクッキーが同じ（またはほぼ同じ）である場合、これはおそらくクッキーがアカウントのいくつかのフィールド（おそらくユーザー名）に関連していることを意味します。次に、以下を試みることができます：

- 非常に**似た**ユーザー名でたくさんの**アカウント**を作成し、アルゴリズムがどのように機能しているかを**推測**してみてください。
- **ユーザー名をブルートフォース**してみてください。クッキーがユーザー名の認証方法としてのみ保存されている場合、ユーザー名"**Bmin**"でアカウントを作成し、クッキーのすべての**ビット**を**ブルートフォース**することができます。なぜなら、試すクッキーの1つは"**admin**"に属するものだからです。
- **パディング** **オラクル**を試みてください（クッキーの内容を復号化できます）。**padbuster**を使用してください。

**パディングオラクル - Padbusterの例**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbusterは複数回試行し、どの条件がエラー条件（無効なもの）であるかを尋ねます。

その後、クッキーの復号を開始します（数分かかる場合があります）。

攻撃が成功した場合、任意の文字列を暗号化してみることができます。たとえば、**encrypt** **user=administrator**を暗号化したい場合。
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
この実行により、**user=administrator**という文字列が含まれた正しく暗号化され、エンコードされたクッキーが得られます。

**CBC-MAC**

クッキーにはいくつかの値があり、CBCを使用して署名される可能性があります。すると、値の整合性は、同じ値を使用してCBCで作成された署名になります。IVとしてヌルベクターを使用することが推奨されるため、このタイプの整合性チェックは脆弱である可能性があります。

**攻撃**

1. ユーザー名 **administ** の署名を取得 = **t**
2. ユーザー名 **rator\x00\x00\x00 XOR t** の署名を取得 = **t'**
3. クッキーに値 **administrator+t'** を設定 (**t'** は **(rator\x00\x00\x00 XOR t) XOR t** の有効な署名になります = **rator\x00\x00\x00**)

**ECB**

クッキーがECBを使用して暗号化されている場合、脆弱である可能性があります。\
ログインすると、受け取るクッキーは常に同じでなければなりません。

**検出と攻撃方法:**

ほぼ同じデータ（ユーザー名、パスワード、メールなど）を持つ2つのユーザーを作成し、与えられたクッキー内のパターンを発見しようとします。

例えば「aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa」というユーザーを作成し、クッキーにパターンがあるかどうかを確認します（ECBは同じキーで各ブロックを暗号化するため、ユーザー名が暗号化されると同じ暗号化されたバイトが現れる可能性があります）。

使用されるブロックのサイズでパターンが存在するはずです。したがって、「a」をブロックのサイズ分繰り返した後に「admin」を追加したユーザー名を作成できます。その後、クッキーから「a」のブロックの暗号化パターンを削除することができます。そして、ユーザー名「admin」のクッキーを得ることができます。

## 参考文献

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)

{{#include ../../banners/hacktricks-training.md}}
