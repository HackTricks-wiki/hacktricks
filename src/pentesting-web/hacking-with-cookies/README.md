# クッキーのハッキング

{{#include ../../banners/hacktricks-training.md}}

## クッキー属性

クッキーには、ユーザーのブラウザでの動作を制御するいくつかの属性があります。これらの属性について、より受動的な声で説明します。

### Expires と Max-Age

クッキーの有効期限は `Expires` 属性によって決まります。対照的に、`Max-age` 属性はクッキーが削除されるまでの時間（秒単位）を定義します。**`Max-age` を選択することをお勧めします。これはより現代的な慣行を反映しています。**

### Domain

クッキーを受け取るホストは `Domain` 属性によって指定されます。デフォルトでは、これはクッキーを発行したホストに設定され、サブドメインは含まれません。しかし、`Domain` 属性が明示的に設定されると、サブドメインも含まれます。これにより、`Domain` 属性の指定が制限の少ないオプションとなり、サブドメイン間でのクッキー共有が必要なシナリオで便利です。たとえば、`Domain=mozilla.org` を設定すると、`developer.mozilla.org` のようなサブドメインでもクッキーにアクセスできます。

### Path

`Cookie` ヘッダーが送信されるために要求された URL に存在しなければならない特定の URL パスは、`Path` 属性によって示されます。この属性は `/` 文字をディレクトリ区切りとして考慮し、サブディレクトリ内でも一致を許可します。

### Ordering Rules

同じ名前のクッキーが2つある場合、送信されるクッキーは以下に基づいて選択されます：

- 要求された URL で最も長いパスに一致するクッキー。
- パスが同じ場合は、最も最近設定されたクッキー。

### SameSite

- `SameSite` 属性は、クッキーがサードパーティのドメインからのリクエストで送信されるかどうかを決定します。3つの設定があります：
- **Strict**: サードパーティのリクエストでクッキーが送信されるのを制限します。
- **Lax**: サードパーティのウェブサイトによって開始された GET リクエストでクッキーが送信されることを許可します。
- **None**: どのサードパーティのドメインからでもクッキーが送信されることを許可します。

クッキーを設定する際には、これらの属性を理解することで、さまざまなシナリオで期待通りに動作することを確保できます。

| **リクエストタイプ** | **例コード**                   | **クッキーが送信されるとき** |
| ---------------- | ---------------------------------- | --------------------- |
| リンク             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| プリレンダリング        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| フォーム GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| フォーム POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| 画像            | \<img src="...">                   | NetSet\*, None        |

表は [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) からのもので、若干修正されています。\
_**SameSite**_ 属性を持つクッキーは、**CSRF攻撃を軽減**します。

**\*Chrome80（2019年2月）から、SameSite 属性を持たないクッキーのデフォルトの動作は Lax になります** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
この変更を適用した後、Chrome では **SameSite ポリシーを持たないクッキーは最初の2分間は None として扱われ、その後はトップレベルのクロスサイト POST リクエストに対して Lax として扱われます。**

## クッキーのフラグ

### HttpOnly

これにより、**クライアント**がクッキーにアクセスするのを防ぎます（例えば、**Javascript** を介して： `document.cookie`）。

#### **バイパス**

- ページがリクエストの応答としてクッキーを**送信している**場合（例えば、**PHPinfo** ページで）、XSS を悪用してこのページにリクエストを送り、応答から**クッキーを盗む**ことが可能です（例は [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/) を参照）。
- **TRACE** **HTTP** リクエストを使用することでバイパス可能です。この場合、サーバーからの応答は送信されたクッキーを反映します。この技術は **Cross-Site Tracking** と呼ばれます。
- この技術は、**モダンブラウザがJSからTRACEリクエストを送信することを許可しないことによって回避されます**。ただし、IE6.0 SP2に対して `\r\nTRACE` を送信するなど、特定のソフトウェアでのバイパスが見つかっています。
- 別の方法は、ブラウザのゼロデイ脆弱性を悪用することです。
- クッキージャーオーバーフロー攻撃を実行することで、**HttpOnly クッキーを上書き
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
送信されたクッキー ヘッダーの結果は `a=v1; test value; b=v2;` です。興味深いことに、これは空の名前のクッキーが設定されている場合にクッキーを操作することを可能にし、空のクッキーを特定の値に設定することで他のクッキーを制御できる可能性があります。
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
これにより、ブラウザはすべてのウェブサーバーによって `a` という名前のクッキーと `b` という値として解釈されるクッキー ヘッダーを送信します。

#### Chrome バグ: Unicode サロゲート コードポイントの問題

Chrome では、Unicode サロゲート コードポイントが設定されたクッキーの一部である場合、`document.cookie` が破損し、その後空の文字列を返します:
```js
document.cookie = "\ud800=meep"
```
この結果、`document.cookie`が空の文字列を出力し、永続的な破損を示します。

#### パースの問題によるクッキーのスモグリング

(詳細は[元の研究](https://blog.ankursundara.com/cookie-bugs/)を参照) Java（Jetty、TomCat、Undertow）やPython（Zope、cherrypy、web.py、aiohttp、bottle、webob）を含むいくつかのウェブサーバーは、古いRFC2965サポートのためにクッキー文字列を誤って処理します。彼らは、セミコロンを含んでいても、ダブルクオートされたクッキー値を単一の値として読み取ります。これは通常、キーと値のペアを区切るべきです。
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) サーバーによるクッキーの不適切な解析、特に Undertow、Zope、および Python の `http.cookie.SimpleCookie` と `http.cookie.BaseCookie` を使用しているものは、クッキーインジェクション攻撃の機会を生み出します。これらのサーバーは新しいクッキーの開始を適切に区切ることができず、攻撃者がクッキーを偽装することを可能にします：

- Undertow は、セミコロンなしで引用された値の直後に新しいクッキーを期待します。
- Zope は、次のクッキーの解析を開始するためにカンマを探します。
- Python のクッキークラスは、スペース文字で解析を開始します。

この脆弱性は、クッキーに基づく CSRF 保護に依存するウェブアプリケーションにとって特に危険です。攻撃者が偽装された CSRF トークンクッキーを注入できるため、セキュリティ対策を回避する可能性があります。この問題は、Python が重複したクッキー名を処理する方法によって悪化し、最後の出現が以前のものを上書きします。また、`__Secure-` および `__Host-` クッキーが安全でないコンテキストで扱われることに対する懸念も生じ、クッキーが偽装に対して脆弱なバックエンドサーバーに渡されると、認可のバイパスにつながる可能性があります。

### Cookies $version and WAF bypasses

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), **`$Version=1`** クッキー属性を使用して、バックエンドが **RFC2109** に基づいて古いロジックを使用してクッキーを解析することが可能かもしれません。さらに、**`$Domain`** や **`$Path`** といった他の値も、クッキーを使用してバックエンドの動作を変更するために使用できます。

#### Bypassing value analysis with quoted-string encoding

この解析は、クッキー内のエスケープされた値をアンエスケープすることを示しています。したがって、"\a" は "a" になります。これは WAF を回避するのに役立つ可能性があります：

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

RFC2109 では、**カンマをクッキー値の区切りとして使用できる**ことが示されています。また、**等号の前後にスペースやタブを追加することも可能です**。したがって、`$Version=1; foo=bar, abc = qux` のようなクッキーは、クッキー `"foo":"bar, admin = qux"` を生成するのではなく、クッキー `foo":"bar"` と `"admin":"qux"` を生成します。2つのクッキーが生成され、admin の前後のスペースが削除されたことに注意してください。

#### Bypassing value analysis with cookie splitting

最後に、異なるバックドアは、異なるクッキーヘッダーで渡された異なるクッキーを文字列として結合します。
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
この例のようにWAFをバイパスすることを可能にするかもしれません:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### 追加の脆弱なクッキーチェック

#### **基本チェック**

- **クッキー**は、**ログイン**するたびに**同じ**です。
- ログアウトして、同じクッキーを使用してみてください。
- 2つのデバイス（またはブラウザ）で同じアカウントに同じクッキーを使用してログインしてみてください。
- クッキーに情報が含まれているか確認し、変更を試みてください。
- ほぼ同じユーザー名で複数のアカウントを作成し、類似点が見えるか確認してください。
- "**ログイン状態を保持する**"オプションが存在する場合、その動作を確認してください。存在し、脆弱である可能性がある場合は、他のクッキーを使用せずに**ログイン状態を保持する**のクッキーを常に使用してください。
- パスワードを変更しても前のクッキーが機能するか確認してください。

#### **高度なクッキー攻撃**

ログイン時にクッキーが同じ（またはほぼ同じ）である場合、これはおそらくクッキーがアカウントのいくつかのフィールド（おそらくユーザー名）に関連していることを意味します。次に、以下を試みることができます：

- 非常に**似た**ユーザー名でたくさんの**アカウント**を作成し、アルゴリズムがどのように機能しているかを**推測**してみてください。
- **ユーザー名をブルートフォース**してみてください。クッキーがユーザー名の認証方法としてのみ保存されている場合、ユーザー名"**Bmin**"でアカウントを作成し、クッキーの**ビット**をすべて**ブルートフォース**することができます。なぜなら、試すクッキーの1つは"**admin**"に属するものだからです。
- **パディング** **オラクル**を試してください（クッキーの内容を復号化できます）。**padbuster**を使用してください。

**パディングオラクル - Padbusterの例**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbusterは複数回の試行を行い、どの条件がエラー条件（無効なもの）であるかを尋ねます。

その後、クッキーの復号を開始します（数分かかる場合があります）。

攻撃が成功した場合、任意の文字列を暗号化してみることができます。たとえば、**encrypt** **user=administrator**を暗号化したい場合。
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
この実行により、文字列 **user=administrator** が内部に含まれた正しく暗号化され、エンコードされたクッキーが得られます。

**CBC-MAC**

クッキーには何らかの値があり、CBCを使用して署名される可能性があります。その場合、値の整合性は、同じ値を使用してCBCで作成された署名です。IVとしてヌルベクターを使用することが推奨されているため、このタイプの整合性チェックは脆弱である可能性があります。

**攻撃**

1. ユーザー名 **administ** の署名を取得 = **t**
2. ユーザー名 **rator\x00\x00\x00 XOR t** の署名を取得 = **t'**
3. クッキーに値 **administrator+t'** を設定 (**t'** は **(rator\x00\x00\x00 XOR t) XOR t** の有効な署名になります = **rator\x00\x00\x00**)

**ECB**

クッキーがECBを使用して暗号化されている場合、脆弱である可能性があります。\
ログインすると、受け取るクッキーは常に同じでなければなりません。

**検出と攻撃方法:**

ほぼ同じデータ（ユーザー名、パスワード、メールなど）を持つ2人のユーザーを作成し、与えられたクッキー内のパターンを発見しようとします。

例えば "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" というユーザーを作成し、クッキーにパターンがあるかどうかを確認します（ECBは同じキーで各ブロックを暗号化するため、ユーザー名が暗号化されると同じ暗号化されたバイトが現れる可能性があります）。

使用されるブロックのサイズでパターンが存在するはずです。したがって、"a" の一群がどのように暗号化されるかを知っていれば、ユーザー名を "a"\*(ブロックのサイズ)+"admin" と作成できます。その後、クッキーから "a" のブロックの暗号化パターンを削除することができます。そして、ユーザー名 "admin" のクッキーを得ることができます。

## 参考文献

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)

{{#include ../../banners/hacktricks-training.md}}
