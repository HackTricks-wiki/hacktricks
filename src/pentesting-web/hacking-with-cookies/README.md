# Hacking sa Kolačićima

{{#include ../../banners/hacktricks-training.md}}

## Atributi Kolačića

Kolačići dolaze sa nekoliko atributa koji kontrolišu njihovo ponašanje u korisnikovom pretraživaču. Evo pregleda ovih atributa u pasivnijem tonu:

### Expires i Max-Age

Datum isteka kolačića određuje atribut `Expires`. Nasuprot tome, atribut `Max-age` definiše vreme u sekundama do brisanja kolačića. **Izaberite `Max-age` jer odražava modernije prakse.**

### Domen

Domaćini koji primaju kolačić su određeni atributom `Domain`. Po defaultu, ovo je postavljeno na domaćina koji je izdao kolačić, ne uključujući njegove poddomene. Međutim, kada je atribut `Domain` eksplicitno postavljen, obuhvata i poddomene. Ovo čini specifikaciju atributa `Domain` manje restriktivnom opcijom, korisnom za scenarije gde je deljenje kolačića preko poddomena neophodno. Na primer, postavljanje `Domain=mozilla.org` čini kolačiće dostupnim na njegovim poddomenama kao što je `developer.mozilla.org`.

### Putanja

Specifična URL putanja koja mora biti prisutna u traženom URL-u da bi se `Cookie` zaglavlje poslalo je označena atributom `Path`. Ovaj atribut smatra karakter `/` kao separator direktorijuma, omogućavajući podudaranja u poddirektorijumima.

### Pravila Redosleda

Kada dva kolačića imaju isto ime, onaj koji se bira za slanje zasniva se na:

- Kolačiću koji se podudara sa najdužom putanjom u traženom URL-u.
- Najnovije postavljenom kolačiću ako su putanje identične.

### SameSite

- Atribut `SameSite` određuje da li se kolačići šalju na zahteve koji potiču sa trećih domena. Nudi tri podešavanja:
- **Strict**: Ograničava kolačić da se ne šalje na zahteve trećih strana.
- **Lax**: Omogućava kolačiću da se šalje sa GET zahtevima koje pokreću treće veb stranice.
- **None**: Dozvoljava kolačiću da se šalje sa bilo kog trećeg domena.

Zapamtite, dok konfigurišete kolačiće, razumevanje ovih atributa može pomoći da se osigura da se ponašaju kako se očekuje u različitim scenarijima.

| **Tip Zahteva** | **Primer Koda**                   | **Kolačići Se Šalju Kada** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Slika            | \<img src="...">                   | NetSet\*, None        |

Tabela iz [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) i malo izmenjena.\
Kolačić sa _**SameSite**_ atributom će **ublažiti CSRF napade** gde je potrebna prijavljena sesija.

**\*Napomena da od Chrome80 (feb/2019) podrazumevano ponašanje kolačića bez samesite** **atributa će biti lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Napomena da će privremeno, nakon primene ove promene, **kolačići bez SameSite** **politike** u Chrome-u biti **tretirani kao None** tokom **prvih 2 minuta, a zatim kao Lax za POST zahteve na vrhunskim stranicama.**

## Zastavice Kolačića

### HttpOnly

Ovo sprečava **klijenta** da pristupi kolačiću (putem **Javascript-a**, na primer: `document.cookie`)

#### **Obilaženja**

- Ako stranica **šalje kolačiće kao odgovor** na zahteve (na primer na **PHPinfo** stranici), moguće je zloupotrebiti XSS da se pošalje zahtev ovoj stranici i **ukrade kolačiće** iz odgovora (proverite primer u [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Ovo se može zaobići sa **TRACE** **HTTP** zahtevima jer će odgovor servera (ako je ova HTTP metoda dostupna) odražavati poslate kolačiće. Ova tehnika se naziva **Cross-Site Tracking**.
- Ova tehnika se izbegava od strane **modernih pretraživača ne dozvoljavajući slanje TRACE** zahteva iz JS-a. Međutim, neka obilaženja su pronađena u specifičnom softveru kao što je slanje `\r\nTRACE` umesto `TRACE` za IE6.0 SP2.
- Drugi način je iskorišćavanje zero/day ranjivosti pretraživača.
- Moguće je **prepisati HttpOnly kolačiće** izvođenjem napada na prelivanje kolačića:

{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Moguće je koristiti [**Cookie Smuggling**](#cookie-smuggling) napad za eksfiltraciju ovih kolačića.

### Secure

Zahtev će **samo** poslati kolačić u HTTP zahtevu samo ako je zahtev prenet preko sigurnog kanala (tipično **HTTPS**).

## Prefiksi Kolačića

Kolačići sa prefiksom `__Secure-` moraju biti postavljeni zajedno sa `secure` zastavicom sa stranica koje su zaštićene HTTPS-om.

Za kolačiće sa prefiksom `__Host-`, mora biti ispunjeno nekoliko uslova:

- Moraju biti postavljeni sa `secure` zastavicom.
- Moraju poticati sa stranice zaštićene HTTPS-om.
- Zabranjeno im je da specificiraju domen, sprečavajući njihovu transmisiju na poddomene.
- Putanja za ove kolačiće mora biti postavljena na `/`.

Važno je napomenuti da kolačići sa prefiksom `__Host-` ne smeju biti poslati na superdomenima ili poddomenima. Ova restrikcija pomaže u izolaciji aplikacionih kolačića. Stoga, korišćenje `__Host-` prefiksa za sve aplikacione kolačiće može se smatrati dobrom praksom za poboljšanje sigurnosti i izolacije.

### Prepisivanje kolačića

Dakle, jedna od zaštita kolačića sa prefiksom `__Host-` je sprečavanje da budu prepisani sa poddomena. Sprečavanje, na primer, [**Cookie Tossing napada**](cookie-tossing.md). U predavanju [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**rad**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) je predstavljeno da je bilo moguće postaviti kolačiće sa prefiksom \_\_HOST- sa poddomena, varajući parser, na primer, dodavanjem "=" na početak ili na kraj...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ili u PHP-u je bilo moguće dodati **druge karaktere na početak** imena kolačića koji će biti **zamenjeni donjim crticama**, omogućavajući prepisivanje `__HOST-` kolačića:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Napadi na Kolačiće

Ako prilagođeni kolačić sadrži osetljive podatke, proverite ga (posebno ako učestvujete u CTF-u), jer može biti ranjiv.

### Dekodiranje i Manipulacija Kolačićima

Osjetljivi podaci ugrađeni u kolačiće uvek treba da budu pažljivo ispitani. Kolačići kodirani u Base64 ili sličnim formatima često se mogu dekodirati. Ova ranjivost omogućava napadačima da izmene sadržaj kolačića i predstavljaju druge korisnike tako što ponovo kodiraju svoje izmenjene podatke u kolačić.

### Otimanje Sesije

Ovaj napad uključuje krađu korisnikovog kolačića kako bi se dobio neovlašćen pristup njihovom nalogu unutar aplikacije. Korišćenjem ukradenog kolačića, napadač može predstavljati legitimnog korisnika.

### Fiksacija Sesije

U ovom scenariju, napadač vara žrtvu da koristi određeni kolačić za prijavu. Ako aplikacija ne dodeljuje novi kolačić prilikom prijave, napadač, posedujući originalni kolačić, može predstavljati žrtvu. Ova tehnika se oslanja na to da se žrtva prijavi sa kolačićem koji je obezbedio napadač.

Ako ste pronašli **XSS u poddomeni** ili **kontrolišete poddomen**, pročitajte:

{{#ref}}
cookie-tossing.md
{{#endref}}

### Donacija Sesije

Ovde, napadač ubeđuje žrtvu da koristi napadačev kolačić sesije. Žrtva, verujući da je prijavljena na svoj nalog, nenamerno će izvršiti radnje u kontekstu napadačevog naloga.

Ako ste pronašli **XSS u poddomeni** ili **kontrolišete poddomen**, pročitajte:

{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Kolačići](../hacking-jwt-json-web-tokens.md)

Kliknite na prethodni link da biste pristupili stranici koja objašnjava moguće slabosti u JWT.

JSON Web Tokens (JWT) korišćeni u kolačićima takođe mogu predstavljati ranjivosti. Za detaljne informacije o potencijalnim slabostima i kako ih iskoristiti, preporučuje se pristup povezanom dokumentu o hakovanju JWT.

### Cross-Site Request Forgery (CSRF)

Ovaj napad prisiljava prijavljenog korisnika da izvrši neželjene radnje na veb aplikaciji u kojoj su trenutno autentifikovani. Napadači mogu iskoristiti kolačiće koji se automatski šalju sa svakim zahtevom na ranjivu stranicu.

### Prazni Kolačići

(Proverite dalje detalje u [originalnom istraživanju](https://blog.ankursundara.com/cookie-bugs/)) Pregledači dozvoljavaju kreiranje kolačića bez imena, što se može demonstrirati putem JavaScript-a na sledeći način:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Rezultat u poslatom cookie header-u je `a=v1; test value; b=v2;`. Zanimljivo je da ovo omogućava manipulaciju kolačićima ako je postavljen kolačić sa praznim imenom, potencijalno kontrolišući druge kolačiće postavljanjem praznog kolačića na specifičnu vrednost:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
To dovodi do toga da pregledač šalje zaglavlje kolačića koje svaki veb server interpretira kao kolačić nazvan `a` sa vrednošću `b`.

#### Chrome greška: Problem sa Unicode zamenskim kodnim tačkama

U Chrome-u, ako je Unicode zamenska kodna tačka deo postavljenog kolačića, `document.cookie` postaje oštećen, vraćajući prazan string kasnije:
```js
document.cookie = "\ud800=meep"
```
Ovo rezultira time da `document.cookie` ispisuje prazan string, što ukazuje na trajnu korupciju.

#### Krađa kolačića zbog problema sa parsiranjem

(Pogledajte dalje detalje u[originalnom istraživanju](https://blog.ankursundara.com/cookie-bugs/)) Nekoliko veb servera, uključujući one iz Jave (Jetty, TomCat, Undertow) i Pythona (Zope, cherrypy, web.py, aiohttp, bottle, webob), pogrešno obrađuje stringove kolačića zbog zastarele podrške za RFC2965. Oni čitaju vrednost kolačića u dvostrukim navodnicima kao jednu vrednost čak i ako uključuje tačke-zareze, koje bi obično trebale da razdvajaju parove ključ-vrednost:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Neispravno parsiranje kolačića od strane servera, posebno Undertow, Zope, i onih koji koriste Pythonov `http.cookie.SimpleCookie` i `http.cookie.BaseCookie`, stvara mogućnosti za napade putem injekcije kolačića. Ovi serveri ne uspevaju pravilno da odvoje početak novih kolačića, omogućavajući napadačima da lažiraju kolačiće:

- Undertow očekuje novi kolačić odmah nakon citirane vrednosti bez tačke-zareza.
- Zope traži zarez da započne parsiranje sledećeg kolačića.
- Pythonove klase kolačića započinju parsiranje na razmak.

Ova ranjivost je posebno opasna u web aplikacijama koje se oslanjaju na CSRF zaštitu zasnovanu na kolačićima, jer omogućava napadačima da ubace lažirane CSRF-token kolačiće, potencijalno zaobilazeći bezbednosne mere. Problem se dodatno pogoršava načinom na koji Python obrađuje duple nazive kolačića, gde poslednja pojava preuzima prethodne. Takođe, postavlja se pitanje za `__Secure-` i `__Host-` kolačiće u nesigurnim kontekstima i može dovesti do zaobilaženja autorizacije kada se kolačići proslede back-end serverima koji su podložni lažiranju.

### Cookies $version and WAF bypasses

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), može biti moguće koristiti atribut kolačića **`$Version=1`** da se backend koristi starom logikom za parsiranje kolačića zbog **RFC2109**. Štaviše, druge vrednosti kao što su **`$Domain`** i **`$Path`** mogu se koristiti za modifikaciju ponašanja backenda sa kolačićem.

#### Bypassing value analysis with quoted-string encoding

Ovo parsiranje ukazuje na to da se neizbežene vrednosti unutar kolačića, tako da "\a" postaje "a". Ovo može biti korisno za zaobilaženje WAFS-a kao:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

U RFC2109 je naznačeno da se **zarez može koristiti kao separator između vrednosti kolačića**. Takođe, moguće je dodati **razmake i tabove pre i posle znaka jednakosti**. Stoga kolačić poput `$Version=1; foo=bar, abc = qux` ne generiše kolačić `"foo":"bar, admin = qux"` već kolačiće `foo":"bar"` i `"admin":"qux"`. Obratite pažnju na to kako su generisana 2 kolačića i kako je adminu uklonjen razmak pre i posle znaka jednakosti.

#### Bypassing value analysis with cookie splitting

Na kraju, različiti backdoor-i bi se spojili u string različitih kolačića prosleđenih u različitim header-ima kolačića kao u:&#x20;
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Što bi moglo omogućiti zaobilaženje WAF-a kao u ovom primeru:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Dodatne provere ranjivih kolačića

#### **Osnovne provere**

- **kolačić** je **isti** svaki put kada se **prijavite**.
- Odjavite se i pokušajte da koristite isti kolačić.
- Pokušajte da se prijavite sa 2 uređaja (ili pregledača) na isti nalog koristeći isti kolačić.
- Proverite da li kolačić sadrži neku informaciju i pokušajte da ga izmenite.
- Pokušajte da kreirate nekoliko naloga sa gotovo istim korisničkim imenom i proverite da li možete primetiti sličnosti.
- Proverite opciju "**zapamti me**" ako postoji da vidite kako funkcioniše. Ako postoji i može biti ranjiva, uvek koristite kolačić **zapamti me** bez bilo kog drugog kolačića.
- Proverite da li prethodni kolačić funkcioniše čak i nakon što promenite lozinku.

#### **Napadi na kolačiće**

Ako kolačić ostaje isti (ili gotovo isti) kada se prijavite, to verovatno znači da je kolačić povezan sa nekim poljem vašeg naloga (verovatno korisničkim imenom). Tada možete:

- Pokušajte da kreirate mnogo **naloga** sa vrlo **sličnim** korisničkim imenima i pokušajte da **pogodite** kako algoritam funkcioniše.
- Pokušajte da **bruteforce-ujete korisničko ime**. Ako se kolačić čuva samo kao metoda autentifikacije za vaše korisničko ime, tada možete kreirati nalog sa korisničkim imenom "**Bmin**" i **bruteforce-ovati** svaki pojedinačni **bit** vašeg kolačića jer će jedan od kolačića koje ćete pokušati biti onaj koji pripada "**admin**".
- Pokušajte **Padding** **Oracle** (možete dekriptovati sadržaj kolačića). Koristite **padbuster**.

**Padding Oracle - Padbuster primeri**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster će napraviti nekoliko pokušaja i pitaće vas koja je greška (koja nije validna).

Zatim će početi da dekriptuje kolačić (može potrajati nekoliko minuta)

Ako je napad uspešno izveden, možete pokušati da enkriptujete string po vašem izboru. Na primer, ako želite da **enkriptujete** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Ova izvršenja će vam dati kolačić ispravno enkriptovan i kodiran sa stringom **user=administrator** unutra.

**CBC-MAC**

Možda kolačić može imati neku vrednost i može biti potpisan koristeći CBC. Tada je integritet vrednosti potpis koji je kreiran korišćenjem CBC sa istom vrednošću. Kako se preporučuje korišćenje nultog vektora kao IV, ova vrsta provere integriteta može biti ranjiva.

**Napad**

1. Dobijte potpis korisničkog imena **administ** = **t**
2. Dobijte potpis korisničkog imena **rator\x00\x00\x00 XOR t** = **t'**
3. Postavite u kolačić vrednost **administrator+t'** (**t'** će biti validan potpis **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Ako je kolačić enkriptovan koristeći ECB, može biti ranjiv.\
Kada se prijavite, kolačić koji dobijate mora uvek biti isti.

**Kako otkriti i napasti:**

Kreirajte 2 korisnika sa gotovo istim podacima (korisničko ime, lozinka, email, itd.) i pokušajte da otkrijete neki obrazac unutar datog kolačića.

Kreirajte korisnika pod imenom "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" i proverite da li postoji neki obrazac u kolačiću (pošto ECB enkriptuje sa istim ključem svaki blok, isti enkriptovani bajtovi mogu se pojaviti ako je korisničko ime enkriptovano).

Trebalo bi da postoji obrazac (sa veličinom korišćenog bloka). Tako, znajući kako su enkriptovani nizovi "a", možete kreirati korisničko ime: "a"\*(veličina bloka)+"admin". Tada biste mogli da obrišete enkriptovani obrazac jednog bloka "a" iz kolačića. I imaćete kolačić korisničkog imena "admin".

## References

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)

{{#include ../../banners/hacktricks-training.md}}
