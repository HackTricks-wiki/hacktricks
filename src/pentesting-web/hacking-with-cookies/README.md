# Cookies Hacking

{{#include ../../banners/hacktricks-training.md}}

## Cookie Attributes

Τα cookies συνοδεύονται από αρκετά χαρακτηριστικά που ελέγχουν τη συμπεριφορά τους στον περιηγητή του χρήστη. Ακολουθεί μια ανασκόπηση αυτών των χαρακτηριστικών σε πιο παθητική φωνή:

### Expires and Max-Age

Η ημερομηνία λήξης ενός cookie καθορίζεται από το χαρακτηριστικό `Expires`. Αντίθετα, το χαρακτηριστικό `Max-age` ορίζει τον χρόνο σε δευτερόλεπτα μέχρι να διαγραφεί ένα cookie. **Επιλέξτε το `Max-age` καθώς αντικατοπτρίζει πιο σύγχρονες πρακτικές.**

### Domain

Οι υπολογιστές που θα λάβουν ένα cookie καθορίζονται από το χαρακτηριστικό `Domain`. Από προεπιλογή, αυτό ορίζεται στον υπολογιστή που εξέδωσε το cookie, χωρίς να περιλαμβάνει τους υποτομείς του. Ωστόσο, όταν το χαρακτηριστικό `Domain` ορίζεται ρητά, περιλαμβάνει και τους υποτομείς. Αυτό καθιστά την καθοριστική επιλογή του χαρακτηριστικού `Domain` λιγότερο περιοριστική, χρήσιμη για σενάρια όπου η κοινή χρήση cookies μεταξύ υποτομέων είναι απαραίτητη. Για παράδειγμα, η ρύθμιση `Domain=mozilla.org` καθιστά τα cookies προσβάσιμα στους υποτομείς του όπως `developer.mozilla.org`.

### Path

Ένας συγκεκριμένος διαδρομή URL που πρέπει να είναι παρούσα στο ζητούμενο URL για να σταλεί η κεφαλίδα `Cookie` υποδεικνύεται από το χαρακτηριστικό `Path`. Αυτό το χαρακτηριστικό θεωρεί τον χαρακτήρα `/` ως διαχωριστικό καταλόγου, επιτρέποντας αντιστοιχίες σε υποκαταλόγους επίσης.

### Ordering Rules

Όταν δύο cookies φέρουν το ίδιο όνομα, το επιλεγμένο για αποστολή βασίζεται σε:

- Το cookie που ταιριάζει με τη μεγαλύτερη διαδρομή στο ζητούμενο URL.
- Το πιο πρόσφατα ρυθμισμένο cookie αν οι διαδρομές είναι ταυτόσημες.

### SameSite

- Το χαρακτηριστικό `SameSite` καθορίζει αν τα cookies αποστέλλονται σε αιτήματα που προέρχονται από τρίτους τομείς. Προσφέρει τρεις ρυθμίσεις:
- **Strict**: Περιορίζει το cookie από το να αποστέλλεται σε αιτήματα τρίτων.
- **Lax**: Επιτρέπει στο cookie να αποστέλλεται με αιτήματα GET που ξεκινούν από τρίτους ιστότοπους.
- **None**: Επιτρέπει στο cookie να αποστέλλεται από οποιονδήποτε τρίτο τομέα.

Θυμηθείτε, ενώ ρυθμίζετε cookies, η κατανόηση αυτών των χαρακτηριστικών μπορεί να βοηθήσει να διασφαλιστεί ότι συμπεριφέρονται όπως αναμένεται σε διάφορα σενάρια.

| **Request Type** | **Example Code**                   | **Cookies Sent When** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Image            | \<img src="...">                   | NetSet\*, None        |

Table from [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) and slightly modified.\
Ένα cookie με το χαρακτηριστικό _**SameSite**_ θα **μειώσει τις επιθέσεις CSRF** όπου απαιτείται μια συνδεδεμένη συνεδρία.

**\*Σημειώστε ότι από το Chrome80 (φλεβ/2019) η προεπιλεγμένη συμπεριφορά ενός cookie χωρίς χαρακτηριστικό cookie samesite** **θα είναι lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Σημειώστε ότι προσωρινά, μετά την εφαρμογή αυτής της αλλαγής, τα **cookies χωρίς πολιτική SameSite** **στο Chrome θα θεωρούνται** **ως None** κατά τη διάρκεια των **πρώτων 2 λεπτών και στη συνέχεια ως Lax για αιτήματα POST διασύνδεσης κορυφαίου επιπέδου.**

## Cookies Flags

### HttpOnly

Αυτό αποτρέπει τον **πελάτη** να έχει πρόσβαση στο cookie (Μέσω **Javascript** για παράδειγμα: `document.cookie`)

#### **Bypasses**

- Αν η σελίδα **στέλνει τα cookies ως απάντηση** σε αιτήματα (για παράδειγμα σε μια σελίδα **PHPinfo**), είναι δυνατόν να καταχραστεί το XSS για να στείλει ένα αίτημα σε αυτή τη σελίδα και να **κλέψει τα cookies** από την απάντηση (ελέγξτε ένα παράδειγμα στο [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
- Αυτό μπορεί να παρακαμφθεί με **TRACE** **HTTP** αιτήματα καθώς η απάντηση από τον διακομιστή (αν αυτή η μέθοδος HTTP είναι διαθέσιμη) θα αντικατοπτρίζει τα cookies που στάλθηκαν. Αυτή η τεχνική ονομάζεται **Cross-Site Tracking**.
- Αυτή η τεχνική αποφεύγεται από **σύγχρονους περιηγητές με το να μην επιτρέπουν την αποστολή ενός TRACE** αιτήματος από JS. Ωστόσο, έχουν βρεθεί ορισμένες παρακάμψεις σε συγκεκριμένο λογισμικό όπως η αποστολή `\r\nTRACE` αντί για `TRACE` στο IE6.0 SP2.
- Ένας άλλος τρόπος είναι η εκμετάλλευση ευπαθειών μηδενικής ημέρας στους περιηγητές.
- Είναι δυνατόν να **επικαλύψετε τα HttpOnly cookies** εκτελώντας μια επίθεση overflow Cookie Jar:

{{#ref}}
cookie-jar-overflow.md
{{#endref}}

- Είναι δυνατόν να χρησιμοποιήσετε την επίθεση [**Cookie Smuggling**](#cookie-smuggling) για να εξάγετε αυτά τα cookies

### Secure

Η αίτηση θα **στείλει** το cookie μόνο σε ένα HTTP αίτημα εάν η αίτηση μεταδίδεται μέσω ενός ασφαλούς καναλιού (συνήθως **HTTPS**).

## Cookies Prefixes

Τα cookies που προεξάγονται με `__Secure-` απαιτείται να ρυθμιστούν παράλληλα με τη σημαία `secure` από σελίδες που είναι ασφαλισμένες με HTTPS.

Για τα cookies που προεξάγονται με `__Host-`, πρέπει να πληρούνται αρκετές προϋποθέσεις:

- Πρέπει να ρυθμιστούν με τη σημαία `secure`.
- Πρέπει να προέρχονται από μια σελίδα ασφαλισμένη με HTTPS.
- Απαγορεύεται να καθορίζουν ένα domain, αποτρέποντας τη μετάδοσή τους σε υποτομείς.
- Η διαδρομή για αυτά τα cookies πρέπει να ρυθμιστεί σε `/`.

Είναι σημαντικό να σημειωθεί ότι τα cookies που προεξάγονται με `__Host-` δεν επιτρέπεται να αποστέλλονται σε υπερτομείς ή υποτομείς. Αυτή η περιοριστική ρύθμιση βοηθά στην απομόνωση των cookies εφαρμογής. Έτσι, η χρήση του προθέματος `__Host-` για όλα τα cookies εφαρμογής μπορεί να θεωρηθεί καλή πρακτική για την ενίσχυση της ασφάλειας και της απομόνωσης.

### Overwriting cookies

Έτσι, μία από τις προστασίες των cookies που προεξάγονται με `__Host-` είναι να αποτρέπουν την επικάλυψή τους από υποτομείς. Αποτρέποντας για παράδειγμα [**Cookie Tossing attacks**](cookie-tossing.md). Στην ομιλία [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) παρουσιάζεται ότι ήταν δυνατό να ρυθμιστούν cookies με προθέματα \_\_HOST- από υποτομέα, παραπλανώντας τον αναλυτή, για παράδειγμα, προσθέτοντας "=" στην αρχή ή στην αρχή και στο τέλος...:

<figure><img src="../../images/image (6) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Ή σε PHP ήταν δυνατό να προστεθούν **άλλοι χαρακτήρες στην αρχή** του ονόματος cookie που θα **αντικαθίσταντο με χαρακτήρες υπογράμμισης**, επιτρέποντας την επικάλυψη των cookies `__HOST-`:

<figure><img src="../../images/image (7) (1) (1) (1) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookies Attacks

Αν ένα προσαρμοσμένο cookie περιέχει ευαίσθητα δεδομένα, ελέγξτε το (ιδιαίτερα αν συμμετέχετε σε CTF), καθώς μπορεί να είναι ευάλωτο.

### Decoding and Manipulating Cookies

Τα ευαίσθητα δεδομένα που ενσωματώνονται σε cookies θα πρέπει πάντα να εξετάζονται προσεκτικά. Τα cookies που είναι κωδικοποιημένα σε Base64 ή παρόμοιες μορφές μπορούν συχνά να αποκωδικοποιηθούν. Αυτή η ευπάθεια επιτρέπει στους επιτιθέμενους να τροποποιούν το περιεχόμενο του cookie και να προσποιούνται άλλους χρήστες κωδικοποιώντας τα τροποποιημένα δεδομένα πίσω στο cookie.

### Session Hijacking

Αυτή η επίθεση περιλαμβάνει την κλοπή ενός cookie χρήστη για να αποκτήσει μη εξουσιοδοτημένη πρόσβαση στον λογαριασμό τους σε μια εφαρμογή. Χρησιμοποιώντας το κλεμμένο cookie, ένας επιτιθέμενος μπορεί να προσποιηθεί τον νόμιμο χρήστη.

### Session Fixation

Σε αυτό το σενάριο, ένας επιτιθέμενος παραπλανεί ένα θύμα να χρησιμοποιήσει ένα συγκεκριμένο cookie για να συνδεθεί. Αν η εφαρμογή δεν αναθέσει ένα νέο cookie κατά την είσοδο, ο επιτιθέμενος, που κατέχει το αρχικό cookie, μπορεί να προσποιηθεί το θύμα. Αυτή η τεχνική βασίζεται στο να συνδεθεί το θύμα με ένα cookie που παρέχεται από τον επιτιθέμενο.

Αν βρείτε ένα **XSS σε υποτομέα** ή ελέγχετε έναν υποτομέα, διαβάστε:

{{#ref}}
cookie-tossing.md
{{#endref}}

### Session Donation

Εδώ, ο επιτιθέμενος πείθει το θύμα να χρησιμοποιήσει το cookie συνεδρίας του επιτιθέμενου. Το θύμα, πιστεύοντας ότι είναι συνδεδεμένο στον δικό του λογαριασμό, θα εκτελέσει ακούσια ενέργειες στο πλαίσιο του λογαριασμού του επιτιθέμενου.

Αν βρείτε ένα **XSS σε υποτομέα** ή ελέγχετε έναν υποτομέα, διαβάστε:

{{#ref}}
cookie-tossing.md
{{#endref}}

### [JWT Cookies](../hacking-jwt-json-web-tokens.md)

Κάντε κλικ στον προηγούμενο σύνδεσμο για να αποκτήσετε πρόσβαση σε μια σελίδα που εξηγεί πιθανά ελαττώματα στα JWT.

Τα JSON Web Tokens (JWT) που χρησιμοποιούνται σε cookies μπορούν επίσης να παρουσιάσουν ευπάθειες. Για λεπτομερείς πληροφορίες σχετικά με πιθανά ελαττώματα και πώς να τα εκμεταλλευτείτε, συνιστάται η πρόσβαση στο συνδεδεμένο έγγραφο σχετικά με την εκμετάλλευση JWT.

### Cross-Site Request Forgery (CSRF)

Αυτή η επίθεση αναγκάζει έναν συνδεδεμένο χρήστη να εκτελέσει ανεπιθύμητες ενέργειες σε μια διαδικτυακή εφαρμογή στην οποία είναι αυτή τη στιγμή αυθεντικοποιημένος. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν τα cookies που αποστέλλονται αυτόματα με κάθε αίτημα προς τον ευάλωτο ιστότοπο.

### Empty Cookies

(Δείτε περισσότερες λεπτομέρειες στην [πρωτότυπη έρευνα](https://blog.ankursundara.com/cookie-bugs/)) Οι περιηγητές επιτρέπουν τη δημιουργία cookies χωρίς όνομα, κάτι που μπορεί να αποδειχθεί μέσω JavaScript ως εξής:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Το αποτέλεσμα στην αποστολή του cookie header είναι `a=v1; test value; b=v2;`. Ενδιαφέρον είναι ότι αυτό επιτρέπει τη χειραγώγηση των cookies αν έχει οριστεί ένα cookie με κενό όνομα, ελέγχοντας δυνητικά άλλα cookies ορίζοντας το κενό cookie σε μια συγκεκριμένη τιμή:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`
}

setCookie("", "a=b") // Setting the empty cookie modifies another cookie's value
```
Αυτό οδηγεί στο να στέλνει ο περιηγητής ένα cookie header που ερμηνεύεται από κάθε web server ως ένα cookie με όνομα `a` και τιμή `b`.

#### Chrome Bug: Πρόβλημα Unicode Surrogate Codepoint

Στο Chrome, αν ένα Unicode surrogate codepoint είναι μέρος ενός σετ cookie, το `document.cookie` γίνεται κατεστραμμένο, επιστρέφοντας μια κενή συμβολοσειρά στη συνέχεια:
```js
document.cookie = "\ud800=meep"
```
Αυτό έχει ως αποτέλεσμα το `document.cookie` να επιστρέφει μια κενή συμβολοσειρά, υποδεικνύοντας μόνιμη διαφθορά.

#### Cookie Smuggling λόγω προβλημάτων ανάλυσης

(Δείτε περισσότερες λεπτομέρειες στην [πρωτότυπη έρευνα](https://blog.ankursundara.com/cookie-bugs/)) Πολλοί διακομιστές ιστού, συμπεριλαμβανομένων αυτών από Java (Jetty, TomCat, Undertow) και Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), χειρίζονται λανθασμένα τις συμβολοσειρές cookie λόγω παρωχημένης υποστήριξης του RFC2965. Διαβάζουν μια τιμή cookie με διπλά εισαγωγικά ως μία μόνο τιμή, ακόμη και αν περιλαμβάνει ερωτηματικά, τα οποία κανονικά θα έπρεπε να διαχωρίζουν τα ζεύγη κλειδιού-τιμής:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Ευπάθειες Εισαγωγής Cookie

(Δείτε περισσότερες λεπτομέρειες στην [πρωτότυπη έρευνα](https://blog.ankursundara.com/cookie-bugs/)) Η λανθασμένη ανάλυση των cookies από τους διακομιστές, ιδίως τους Undertow, Zope και αυτούς που χρησιμοποιούν το `http.cookie.SimpleCookie` και `http.cookie.BaseCookie` της Python, δημιουργεί ευκαιρίες για επιθέσεις εισαγωγής cookies. Αυτοί οι διακομιστές αποτυγχάνουν να καθορίσουν σωστά την αρχή νέων cookies, επιτρέποντας στους επιτιθέμενους να παραποιήσουν cookies:

- Ο Undertow αναμένει ένα νέο cookie αμέσως μετά από μια παρατιθέμενη τιμή χωρίς ερωτηματικό.
- Ο Zope αναζητά μια κόμμα για να αρχίσει την ανάλυση του επόμενου cookie.
- Οι κλάσεις cookie της Python αρχίζουν την ανάλυση σε έναν χαρακτήρα κενό.

Αυτή η ευπάθεια είναι ιδιαίτερα επικίνδυνη σε διαδικτυακές εφαρμογές που βασίζονται στην προστασία CSRF μέσω cookies, καθώς επιτρέπει στους επιτιθέμενους να εισάγουν παραποιημένα cookies CSRF-token, πιθανώς παρακάμπτοντας τα μέτρα ασφαλείας. Το πρόβλημα επιδεινώνεται από την επεξεργασία των διπλών ονομάτων cookie από την Python, όπου η τελευταία εμφάνιση υπερκαλύπτει τις προηγούμενες. Επίσης, εγείρει ανησυχίες για τα cookies `__Secure-` και `__Host-` σε ανασφαλείς περιβάλλοντες και θα μπορούσε να οδηγήσει σε παρακάμψεις εξουσιοδότησης όταν τα cookies μεταφέρονται σε διακομιστές backend που είναι ευάλωτοι σε παραποίηση.

### Cookies $version και παρακάμψεις WAF

Σύμφωνα με [**αυτή την ανάρτηση**](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie), μπορεί να είναι δυνατό να χρησιμοποιηθεί το χαρακτηριστικό cookie **`$Version=1`** για να κάνει το backend να χρησιμοποιήσει μια παλιά λογική για την ανάλυση του cookie λόγω του **RFC2109**. Επιπλέον, άλλες τιμές όπως **`$Domain`** και **`$Path`** μπορούν να χρησιμοποιηθούν για να τροποποιήσουν τη συμπεριφορά του backend με το cookie.

#### Ανάλυση παρακάμψεων τιμών με κωδικοποίηση παρατιθέμενης συμβολοσειράς

Αυτή η ανάλυση υποδεικνύει την αποσυμπίεση των κωδικοποιημένων τιμών μέσα στα cookies, έτσι ώστε το "\a" να γίνεται "a". Αυτό μπορεί να είναι χρήσιμο για την παράκαμψη των WAFS καθώς:

- `eval('test') => forbidden`
- `"\e\v\a\l\(\'\t\e\s\t\'\)" => allowed`

#### Ανάλυση παρακάμψεων λιστών αποκλεισμού ονομάτων cookie

Στο RFC2109 αναφέρεται ότι μια **κόμμα μπορεί να χρησιμοποιηθεί ως διαχωριστής μεταξύ των τιμών cookie**. Και επίσης είναι δυνατό να προστεθούν **κενά και ταμπς πριν και μετά το ίσον**. Επομένως, ένα cookie όπως `$Version=1; foo=bar, abc = qux` δεν παράγει το cookie `"foo":"bar, admin = qux"` αλλά τα cookies `foo":"bar"` και `"admin":"qux"`. Παρατηρήστε πώς παράγονται 2 cookies και πώς το admin απέκτησε το κενό πριν και μετά το ίσον.

#### Ανάλυση παρακάμψεων τιμών με διαχωρισμό cookie

Τέλος, διάφορες πίσω πόρτες θα συνδυάζουν σε μια συμβολοσειρά διαφορετικά cookies που περνούν σε διαφορετικούς επικεφαλής cookie όπως σε:&#x20;
```
GET / HTTP/1.1
Host: example.com
Cookie: param1=value1;
Cookie: param2=value2;
```
Ποιο θα μπορούσε να επιτρέψει την παράκαμψη ενός WAF όπως σε αυτό το παράδειγμα:
```
Cookie: name=eval('test//
Cookie: comment')

Resulting cookie: name=eval('test//, comment') => allowed
```
### Έλεγχοι για Εξαιρετικά Ευάλωτα Cookies

#### **Βασικοί έλεγχοι**

- Το **cookie** είναι το **ίδιο** κάθε φορά που **συνδέεστε**.
- Αποσυνδεθείτε και προσπαθήστε να χρησιμοποιήσετε το ίδιο cookie.
- Προσπαθήστε να συνδεθείτε με 2 συσκευές (ή προγράμματα περιήγησης) στον ίδιο λογαριασμό χρησιμοποιώντας το ίδιο cookie.
- Ελέγξτε αν το cookie έχει οποιαδήποτε πληροφορία μέσα του και προσπαθήστε να το τροποποιήσετε.
- Προσπαθήστε να δημιουργήσετε αρκετούς λογαριασμούς με σχεδόν το ίδιο όνομα χρήστη και ελέγξτε αν μπορείτε να δείτε ομοιότητες.
- Ελέγξτε την επιλογή "**remember me**" αν υπάρχει για να δείτε πώς λειτουργεί. Αν υπάρχει και μπορεί να είναι ευάλωτη, χρησιμοποιήστε πάντα το cookie του **remember me** χωρίς κανένα άλλο cookie.
- Ελέγξτε αν το προηγούμενο cookie λειτουργεί ακόμα και μετά την αλλαγή του κωδικού πρόσβασης.

#### **Προχωρημένες επιθέσεις με cookies**

Αν το cookie παραμένει το ίδιο (ή σχεδόν) όταν συνδέεστε, αυτό πιθανώς σημαίνει ότι το cookie σχετίζεται με κάποιο πεδίο του λογαριασμού σας (πιθανώς το όνομα χρήστη). Τότε μπορείτε να:

- Προσπαθήσετε να δημιουργήσετε πολλούς **λογαριασμούς** με ονόματα χρήστη πολύ **παρόμοια** και να προσπαθήσετε να **μαντέψετε** πώς λειτουργεί ο αλγόριθμος.
- Προσπαθήστε να **bruteforce το όνομα χρήστη**. Αν το cookie αποθηκεύεται μόνο ως μέθοδος αυθεντικοποίησης για το όνομα χρήστη σας, τότε μπορείτε να δημιουργήσετε έναν λογαριασμό με το όνομα χρήστη "**Bmin**" και να **bruteforce** κάθε κομμάτι του cookie σας γιατί ένα από τα cookies που θα δοκιμάσετε θα είναι αυτό που ανήκει στον "**admin**".
- Προσπαθήστε **Padding** **Oracle** (μπορείτε να αποκρυπτογραφήσετε το περιεχόμενο του cookie). Χρησιμοποιήστε **padbuster**.

**Padding Oracle - Παραδείγματα Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Το Padbuster θα κάνει αρκετές προσπάθειες και θα σας ρωτήσει ποια είναι η συνθήκη σφάλματος (αυτή που δεν είναι έγκυρη).

Στη συνέχεια, θα ξεκινήσει την αποκρυπτογράφηση του cookie (μπορεί να διαρκέσει αρκετά λεπτά).

Εάν η επίθεση έχει εκτελεστεί με επιτυχία, τότε μπορείτε να προσπαθήσετε να κρυπτογραφήσετε μια συμβολοσειρά της επιλογής σας. Για παράδειγμα, αν θέλετε να **encrypt** **user=administrator**.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Αυτή η εκτέλεση θα σας δώσει το cookie σωστά κρυπτογραφημένο και κωδικοποιημένο με τη συμβολοσειρά **user=administrator** μέσα.

**CBC-MAC**

Ίσως ένα cookie να έχει κάποια τιμή και να μπορεί να υπογραφεί χρησιμοποιώντας CBC. Τότε, η ακεραιότητα της τιμής είναι η υπογραφή που δημιουργείται χρησιμοποιώντας CBC με την ίδια τιμή. Καθώς συνιστάται να χρησιμοποιείται ως IV ένα μηδενικό διάνυσμα, αυτός ο τύπος ελέγχου ακεραιότητας θα μπορούσε να είναι ευάλωτος.

**Η επίθεση**

1. Πάρτε την υπογραφή του ονόματος χρήστη **administ** = **t**
2. Πάρτε την υπογραφή του ονόματος χρήστη **rator\x00\x00\x00 XOR t** = **t'**
3. Ορίστε στο cookie την τιμή **administrator+t'** (**t'** θα είναι μια έγκυρη υπογραφή του **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Εάν το cookie είναι κρυπτογραφημένο χρησιμοποιώντας ECB, θα μπορούσε να είναι ευάλωτο.\
Όταν συνδεθείτε, το cookie που λαμβάνετε πρέπει πάντα να είναι το ίδιο.

**Πώς να ανιχνεύσετε και να επιτεθείτε:**

Δημιουργήστε 2 χρήστες με σχεδόν τα ίδια δεδομένα (όνομα χρήστη, κωδικό, email, κ.λπ.) και προσπαθήστε να ανακαλύψετε κάποιο μοτίβο μέσα στο δεδομένο cookie.

Δημιουργήστε έναν χρήστη που ονομάζεται για παράδειγμα "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" και ελέγξτε αν υπάρχει κάποιο μοτίβο στο cookie (καθώς το ECB κρυπτογραφεί με το ίδιο κλειδί κάθε μπλοκ, τα ίδια κρυπτογραφημένα bytes θα μπορούσαν να εμφανιστούν αν το όνομα χρήστη είναι κρυπτογραφημένο).

Θα πρέπει να υπάρχει ένα μοτίβο (με το μέγεθος ενός χρησιμοποιούμενου μπλοκ). Έτσι, γνωρίζοντας πώς είναι κρυπτογραφημένα μια σειρά από "a", μπορείτε να δημιουργήσετε ένα όνομα χρήστη: "a"\*(μέγεθος του μπλοκ)+"admin". Στη συνέχεια, θα μπορούσατε να διαγράψετε το κρυπτογραφημένο μοτίβο ενός μπλοκ "a" από το cookie. Και θα έχετε το cookie του ονόματος χρήστη "admin".

## Αναφορές

- [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
- [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)
- [https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie](https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie)

{{#include ../../banners/hacktricks-training.md}}
